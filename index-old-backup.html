<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP - The Emergence</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Georgia', serif;
        }
        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; gap: 30px;
            z-index: 100; cursor: pointer;
            background: #000;
        }
        #enter.off { display: none; }
        #enter h1 {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 8px;
            color: rgba(255,255,255,0.25);
        }
        #enter p {
            font-size: 9px;
            letter-spacing: 3px;
            color: rgba(255,255,255,0.12);
            max-width: 280px;
            text-align: center;
            line-height: 1.8;
        }
        #enter .circle {
            width: 80px; height: 80px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.06);
            transition: all 0.8s;
        }
        #enter:hover .circle { border-color: rgba(255,255,255,0.15); }
        #world {
            position: fixed; inset: 0;
            display: none;
            background: #000;
        }
        #world.on { display: block; }
        canvas { position: fixed; inset: 0; }

        #zone-indicator {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            width: 200px; height: 200px;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10;
        }

        #unlocks {
            position: fixed;
            bottom: 20px; left: 20px;
            font-size: 8px;
            color: rgba(255,255,255,0.15);
            letter-spacing: 2px;
            line-height: 1.8;
            font-family: monospace;
            text-transform: uppercase;
        }
        #unlocks span.on { color: rgba(255,255,255,0.5); }

        #era-name {
            position: fixed;
            top: 20px; left: 0; right: 0;
            text-align: center;
            font-size: 10px;
            letter-spacing: 8px;
            color: rgba(255,255,255,0.1);
            text-transform: uppercase;
            z-index: 50;
        }

        #zone-name {
            position: fixed;
            bottom: 20px; right: 20px;
            font-size: 9px;
            letter-spacing: 3px;
            color: rgba(255,255,255,0.08);
            font-family: monospace;
            z-index: 50;
        }

        #dwell-bar {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 2px;
            background: rgba(255,255,255,0.02);
        }
        #dwell-fill {
            height: 100%;
            width: 0%;
            background: rgba(255,255,255,0.2);
            transition: width 0.1s linear;
        }
    </style>
</head>
<body>

<div id="enter">
    <h1>THE EMERGENCE</h1>
    <div class="circle"></div>
    <p>tilt to explore · dwell to activate · discover the patterns</p>
</div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="zone-indicator"></div>
    <div id="era-name">genesis</div>
    <div id="zone-name">center</div>
    <div id="unlocks"></div>
    <div id="dwell-bar"><div id="dwell-fill"></div></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// GUMP - THE EMERGENCE
// ═══════════════════════════════════════════════════════════════════════════
//
// An RPG of sound. Your movements are codes that unlock layers.
// Where you tilt, how long you stay, and the patterns you trace
// all shape what emerges from the void.
//
// ZONES:
//   center - stillness, the seed
//   north  - higher frequencies rise
//   south  - sub bass deepens
//   east   - brightness, filter opens
//   west   - darkness, filter closes
//   corners - specific instrument layers
//
// DWELL:
//   < 1s   - touch (brief influence)
//   1-3s   - activate (layer comes in)
//   > 3s   - lock (becomes permanent)
//
// SEQUENCES:
//   Certain movement patterns unlock hidden layers
//
// ═══════════════════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ═══════════════════════════════════════════════════════════════════════════
// ZONE SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

const ZONES = {
    center: { x: [0.35, 0.65], y: [0.35, 0.65] },
    north: { x: [0.25, 0.75], y: [0, 0.35] },
    south: { x: [0.25, 0.75], y: [0.65, 1] },
    east: { x: [0.65, 1], y: [0.25, 0.75] },
    west: { x: [0, 0.35], y: [0.25, 0.75] },
    northeast: { x: [0.65, 1], y: [0, 0.35] },
    northwest: { x: [0, 0.35], y: [0, 0.35] },
    southeast: { x: [0.65, 1], y: [0.65, 1] },
    southwest: { x: [0, 0.35], y: [0.65, 1] },
};

function getZone(x, y) {
    for (const [name, bounds] of Object.entries(ZONES)) {
        if (x >= bounds.x[0] && x <= bounds.x[1] &&
            y >= bounds.y[0] && y <= bounds.y[1]) {
            return name;
        }
    }
    return 'center';
}

// ═══════════════════════════════════════════════════════════════════════════
// UNLOCK SYSTEM - Layers that can be activated
// ═══════════════════════════════════════════════════════════════════════════

const LAYERS = {
    // Genesis layers
    void: { era: 'genesis', default: true, description: 'the presence' },
    fundamental: { era: 'genesis', zone: 'center', dwell: 2, description: 'first tone' },
    overtones: { era: 'genesis', zone: 'north', dwell: 2, description: 'harmonics bloom' },
    sub: { era: 'genesis', zone: 'south', dwell: 2, description: 'depths open' },
    brightness: { era: 'genesis', zone: 'east', dwell: 1, description: 'light enters' },
    darkness: { era: 'genesis', zone: 'west', dwell: 1, description: 'shadow grows' },
    shimmer: { era: 'genesis', sequence: ['north', 'south', 'north'], description: 'the shimmer' },
    pulse: { era: 'genesis', sequence: ['east', 'west', 'east', 'west'], description: 'first pulse' },
    width: { era: 'genesis', sequence: ['northeast', 'southeast', 'southwest', 'northwest'], description: 'space expands' },

    // Tribal layers
    feet: { era: 'tribal', zone: 'south', dwell: 2, description: 'footsteps' },
    hands: { era: 'tribal', zone: 'north', dwell: 2, description: 'claps' },
    wood: { era: 'tribal', zone: 'west', dwell: 2, description: 'wood strikes' },
    stone: { era: 'tribal', zone: 'east', dwell: 2, description: 'stone clicks' },
    drum: { era: 'tribal', zone: 'center', dwell: 3, description: 'the drum' },
    voice: { era: 'tribal', sequence: ['northwest', 'northeast', 'southeast', 'southwest'], description: 'voice awakens' },
    poly: { era: 'tribal', sequence: ['north', 'east', 'south', 'west', 'north'], description: 'polyrhythm' },
};

// ═══════════════════════════════════════════════════════════════════════════
// GLOBAL STATE
// ═══════════════════════════════════════════════════════════════════════════

const world = {
    x: 0.5, y: 0.5,              // Position (0-1)
    zone: 'center',              // Current zone
    zoneDwell: 0,                // Time in current zone
    zoneHistory: [],             // Recent zones visited
    energy: 0,                   // Movement intensity
    breath: 0,                   // Slow oscillation
};

const music = {
    era: 'genesis',
    unlocked: new Set(['void']), // Which layers are active
    locked: new Set(),           // Permanently locked in layers
    layerVolumes: {},            // Current volume of each layer
    tick: 0,
};

let ctx, masterGain, masterFilter, reverbGain;
let canvas, vc;
let audioReady = false;
let lastTime = performance.now();

// ═══════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════════════════

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master filter - zone controlled
    masterFilter = ctx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 1500;
    masterFilter.Q.value = 0.7;

    // Reverb
    const reverbBuffer = createReverb(5.0);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.35;

    // Compressor
    const compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -15;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.005;
    compressor.release.value = 0.15;

    // Master
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.85;

    // Routing
    masterFilter.connect(compressor);
    masterFilter.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);
    compressor.connect(masterGain);
    masterGain.connect(ctx.destination);

    // Initialize sound layers
    initGenesis();
    initTribal();

    audioReady = true;
}

function createReverb(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / ctx.sampleRate;
            data[i] = (Math.random() * 2 - 1) * Math.exp(-t / (duration * 0.4)) * 0.4;
        }
    }
    return buffer;
}

// ═══════════════════════════════════════════════════════════════════════════
// GENESIS SOUNDS
// ═══════════════════════════════════════════════════════════════════════════

const genesis = {};

function initGenesis() {
    // ═══════════════════════════════════════════════════════════════════════
    // VOID - The base presence, always there in genesis
    // ═══════════════════════════════════════════════════════════════════════
    genesis.voidOsc = ctx.createOscillator();
    genesis.voidOsc.type = 'sine';
    genesis.voidOsc.frequency.value = 18;

    genesis.voidGain = ctx.createGain();
    genesis.voidGain.gain.value = 0;

    const voidFilter = ctx.createBiquadFilter();
    voidFilter.type = 'lowpass';
    voidFilter.frequency.value = 50;

    genesis.voidOsc.connect(voidFilter);
    voidFilter.connect(genesis.voidGain);
    genesis.voidGain.connect(masterFilter);
    genesis.voidOsc.start();

    // ═══════════════════════════════════════════════════════════════════════
    // FUNDAMENTAL - The first tone (center zone)
    // ═══════════════════════════════════════════════════════════════════════
    genesis.fundOsc = ctx.createOscillator();
    genesis.fundOsc.type = 'sine';
    genesis.fundOsc.frequency.value = 27.5; // A0

    // Breathing LFO
    const fundLfo = ctx.createOscillator();
    fundLfo.frequency.value = 0.07;
    const fundLfoGain = ctx.createGain();
    fundLfoGain.gain.value = 1.5;
    fundLfo.connect(fundLfoGain);
    fundLfoGain.connect(genesis.fundOsc.frequency);
    fundLfo.start();

    genesis.fundGain = ctx.createGain();
    genesis.fundGain.gain.value = 0;

    genesis.fundOsc.connect(genesis.fundGain);
    genesis.fundGain.connect(masterFilter);
    genesis.fundOsc.start();

    // ═══════════════════════════════════════════════════════════════════════
    // OVERTONES - Harmonics (north zone)
    // ═══════════════════════════════════════════════════════════════════════
    genesis.overtones = [];
    genesis.overtonesGain = ctx.createGain();
    genesis.overtonesGain.gain.value = 0;

    const harmonics = [2, 3, 4, 5, 6, 7, 8];
    harmonics.forEach((ratio, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 27.5 * ratio;

        const lfo = ctx.createOscillator();
        lfo.frequency.value = 0.03 + i * 0.01;
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = ratio * 0.2;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start();

        const gain = ctx.createGain();
        gain.gain.value = 0.12 / ratio;

        osc.connect(gain);
        gain.connect(genesis.overtonesGain);
        osc.start();

        genesis.overtones.push({ osc, gain, ratio });
    });

    genesis.overtonesGain.connect(masterFilter);

    // ═══════════════════════════════════════════════════════════════════════
    // SUB - Deep bass (south zone)
    // ═══════════════════════════════════════════════════════════════════════
    genesis.subOsc = ctx.createOscillator();
    genesis.subOsc.type = 'sine';
    genesis.subOsc.frequency.value = 13.75; // Sub-sub A

    genesis.subGain = ctx.createGain();
    genesis.subGain.gain.value = 0;

    const subFilter = ctx.createBiquadFilter();
    subFilter.type = 'lowpass';
    subFilter.frequency.value = 35;
    subFilter.Q.value = 2;

    genesis.subOsc.connect(subFilter);
    subFilter.connect(genesis.subGain);
    genesis.subGain.connect(masterFilter);
    genesis.subOsc.start();

    // ═══════════════════════════════════════════════════════════════════════
    // SHIMMER - High ethereal layer (sequence unlock)
    // ═══════════════════════════════════════════════════════════════════════
    genesis.shimmerOscs = [];
    genesis.shimmerGain = ctx.createGain();
    genesis.shimmerGain.gain.value = 0;

    [880, 1320, 1760].forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        osc.detune.value = (Math.random() - 0.5) * 10;

        const lfo = ctx.createOscillator();
        lfo.frequency.value = 0.2 + i * 0.1;
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = 5;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.detune);
        lfo.start();

        const gain = ctx.createGain();
        gain.gain.value = 0.04;

        osc.connect(gain);
        gain.connect(genesis.shimmerGain);
        osc.start();

        genesis.shimmerOscs.push(osc);
    });

    genesis.shimmerGain.connect(masterFilter);

    // ═══════════════════════════════════════════════════════════════════════
    // PULSE - Rhythmic throb (sequence unlock)
    // ═══════════════════════════════════════════════════════════════════════
    genesis.pulseOsc = ctx.createOscillator();
    genesis.pulseOsc.type = 'sine';
    genesis.pulseOsc.frequency.value = 36;

    genesis.pulseGain = ctx.createGain();
    genesis.pulseGain.gain.value = 0;

    genesis.pulseOsc.connect(genesis.pulseGain);
    genesis.pulseGain.connect(masterFilter);
    genesis.pulseOsc.start();

    // ═══════════════════════════════════════════════════════════════════════
    // WIDTH - Stereo spread (corner sequence unlock)
    // ═══════════════════════════════════════════════════════════════════════
    genesis.widthOscL = ctx.createOscillator();
    genesis.widthOscL.type = 'sine';
    genesis.widthOscL.frequency.value = 55;

    genesis.widthOscR = ctx.createOscillator();
    genesis.widthOscR.type = 'sine';
    genesis.widthOscR.frequency.value = 55.3; // Slight detune for width

    genesis.widthGainL = ctx.createGain();
    genesis.widthGainL.gain.value = 0;
    genesis.widthGainR = ctx.createGain();
    genesis.widthGainR.gain.value = 0;

    const panL = ctx.createStereoPanner();
    panL.pan.value = -0.8;
    const panR = ctx.createStereoPanner();
    panR.pan.value = 0.8;

    genesis.widthOscL.connect(genesis.widthGainL);
    genesis.widthGainL.connect(panL);
    panL.connect(masterFilter);

    genesis.widthOscR.connect(genesis.widthGainR);
    genesis.widthGainR.connect(panR);
    panR.connect(masterFilter);

    genesis.widthOscL.start();
    genesis.widthOscR.start();
}

function updateGenesis() {
    if (!audioReady || music.era !== 'genesis') return;

    const now = ctx.currentTime;
    const u = music.unlocked;

    // VOID - always present in genesis
    if (u.has('void')) {
        const vol = 0.25 + Math.sin(world.breath * 0.2) * 0.1;
        genesis.voidGain.gain.setTargetAtTime(vol, now, 0.5);
    }

    // FUNDAMENTAL - center dwelling
    if (u.has('fundamental')) {
        const vol = music.locked.has('fundamental') ? 0.4 : 0.3;
        genesis.fundGain.gain.setTargetAtTime(vol + world.energy * 0.15, now, 0.3);
    } else {
        genesis.fundGain.gain.setTargetAtTime(0, now, 0.5);
    }

    // OVERTONES - north dwelling
    if (u.has('overtones')) {
        const vol = music.locked.has('overtones') ? 0.35 : 0.25;
        genesis.overtonesGain.gain.setTargetAtTime(vol + world.energy * 0.1, now, 0.3);
    } else {
        genesis.overtonesGain.gain.setTargetAtTime(0, now, 0.5);
    }

    // SUB - south dwelling
    if (u.has('sub')) {
        const vol = music.locked.has('sub') ? 0.5 : 0.35;
        genesis.subGain.gain.setTargetAtTime(vol, now, 0.3);
    } else {
        genesis.subGain.gain.setTargetAtTime(0, now, 0.5);
    }

    // BRIGHTNESS/DARKNESS - affects master filter
    let filterTarget = 1500;
    if (u.has('brightness')) filterTarget += 2000;
    if (u.has('darkness')) filterTarget -= 800;
    filterTarget += world.energy * 500;
    masterFilter.frequency.setTargetAtTime(Math.max(200, filterTarget), now, 0.15);

    // SHIMMER - sequence unlock
    if (u.has('shimmer')) {
        const vol = 0.15 + Math.sin(world.breath * 0.5) * 0.05;
        genesis.shimmerGain.gain.setTargetAtTime(vol, now, 0.4);
    } else {
        genesis.shimmerGain.gain.setTargetAtTime(0, now, 0.5);
    }

    // PULSE - creates rhythmic throb
    if (u.has('pulse')) {
        const pulsePhase = (world.breath * 2) % TAU;
        const pulseVol = Math.pow(Math.sin(pulsePhase) * 0.5 + 0.5, 3) * 0.4;
        genesis.pulseGain.gain.setTargetAtTime(pulseVol, now, 0.05);
    } else {
        genesis.pulseGain.gain.setTargetAtTime(0, now, 0.3);
    }

    // WIDTH - stereo expansion
    if (u.has('width')) {
        const vol = 0.2;
        genesis.widthGainL.gain.setTargetAtTime(vol, now, 0.3);
        genesis.widthGainR.gain.setTargetAtTime(vol, now, 0.3);
    } else {
        genesis.widthGainL.gain.setTargetAtTime(0, now, 0.5);
        genesis.widthGainR.gain.setTargetAtTime(0, now, 0.5);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// TRIBAL SOUNDS
// ═══════════════════════════════════════════════════════════════════════════

const tribal = {
    buffers: {},
    lastTrigger: {},
    voiceOsc: null,
    voiceGain: null,
    polyPhase: 0,
};

function initTribal() {
    // FEET - low thump
    tribal.buffers.feet = createBuffer((t, sr) => {
        const freq = 55 + 35 * Math.exp(-t * 25);
        return Math.sin(TAU * freq * t) * Math.exp(-t * 10) * 0.7;
    }, 0.4);

    // HANDS - clap
    tribal.buffers.hands = createBuffer((t, sr) => {
        return (Math.random() * 2 - 1) * Math.exp(-t * 35) * 0.6;
    }, 0.2);

    // WOOD - resonant hit
    tribal.buffers.wood = createBuffer((t, sr) => {
        const freq = 350 + 150 * Math.exp(-t * 15);
        return (Math.sin(TAU * freq * t) * 0.7 + Math.sin(TAU * freq * 2.4 * t) * 0.3)
               * Math.exp(-t * 12) * 0.5;
    }, 0.5);

    // STONE - high click
    tribal.buffers.stone = createBuffer((t, sr) => {
        return (Math.sin(TAU * 2200 * t) + Math.sin(TAU * 3500 * t) * 0.4)
               * Math.exp(-t * 50) * 0.4;
    }, 0.15);

    // DRUM - deep resonant
    tribal.buffers.drum = createBuffer((t, sr) => {
        const freq = 75 + 50 * Math.exp(-t * 12);
        const body = Math.sin(TAU * freq * t) * Math.exp(-t * 4);
        const slap = Math.sin(TAU * 250 * t) * Math.exp(-t * 40) * 0.3;
        const skin = (Math.random() * 2 - 1) * Math.exp(-t * 18) * 0.15;
        return (body + slap + skin) * 0.75;
    }, 0.9);

    // VOICE - drone oscillator
    tribal.voiceOsc = ctx.createOscillator();
    tribal.voiceOsc.type = 'sawtooth';
    tribal.voiceOsc.frequency.value = 110;

    const voiceFilter = ctx.createBiquadFilter();
    voiceFilter.type = 'lowpass';
    voiceFilter.frequency.value = 500;
    voiceFilter.Q.value = 4;

    // Vibrato
    const vibrato = ctx.createOscillator();
    vibrato.frequency.value = 5.5;
    const vibGain = ctx.createGain();
    vibGain.gain.value = 5;
    vibrato.connect(vibGain);
    vibGain.connect(tribal.voiceOsc.frequency);
    vibrato.start();

    tribal.voiceGain = ctx.createGain();
    tribal.voiceGain.gain.value = 0;

    tribal.voiceOsc.connect(voiceFilter);
    voiceFilter.connect(tribal.voiceGain);
    tribal.voiceGain.connect(masterFilter);
    tribal.voiceOsc.start();

    // Initialize last trigger times
    Object.keys(tribal.buffers).forEach(k => tribal.lastTrigger[k] = 0);
}

function createBuffer(fn, duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < length; i++) {
        data[i] = fn(i / ctx.sampleRate, ctx.sampleRate);
    }
    return buffer;
}

function playTribalSound(name, vol = 1, pan = 0) {
    if (!tribal.buffers[name]) return;

    const now = ctx.currentTime;
    const minInterval = { feet: 0.25, hands: 0.15, wood: 0.2, stone: 0.1, drum: 0.4 };
    if (now - (tribal.lastTrigger[name] || 0) < (minInterval[name] || 0.2)) return;
    tribal.lastTrigger[name] = now;

    const source = ctx.createBufferSource();
    source.buffer = tribal.buffers[name];

    const gain = ctx.createGain();
    gain.gain.value = vol;

    const panner = ctx.createStereoPanner();
    panner.pan.value = pan;

    source.connect(gain);
    gain.connect(panner);
    panner.connect(masterFilter);
    source.start();
}

function updateTribal() {
    if (!audioReady || music.era !== 'tribal') return;

    const now = ctx.currentTime;
    const u = music.unlocked;

    // Base tempo
    world.breath += 0.02;
    tribal.polyPhase += 0.015;

    // FEET - south zone
    if (u.has('feet')) {
        const pattern = Math.sin(world.breath * 1.2) > 0.7;
        if (pattern) playTribalSound('feet', 0.6, (Math.random() - 0.5) * 0.2);
    }

    // HANDS - north zone
    if (u.has('hands')) {
        const pattern = Math.sin(world.breath * 2.4 + 1.5) > 0.75;
        if (pattern) playTribalSound('hands', 0.5, (Math.random() - 0.5) * 0.4);
    }

    // WOOD - west zone
    if (u.has('wood')) {
        const pattern = Math.sin(world.breath * 1.8 + 0.8) > 0.8;
        if (pattern) playTribalSound('wood', 0.4, -0.3);
    }

    // STONE - east zone
    if (u.has('stone')) {
        if (Math.random() < 0.015) {
            playTribalSound('stone', 0.3, 0.4);
        }
    }

    // DRUM - center zone (needs longer dwell)
    if (u.has('drum')) {
        const pattern = Math.sin(world.breath * 0.6) > 0.85;
        if (pattern) playTribalSound('drum', 0.7, 0);
    }

    // VOICE - sequence unlock
    if (u.has('voice')) {
        const vol = 0.18 + Math.sin(world.breath * 0.3) * 0.06;
        tribal.voiceGain.gain.setTargetAtTime(vol, now, 0.3);

        // Pentatonic - position controls note
        const pent = [0, 3, 5, 7, 10];
        const noteIdx = Math.floor(world.y * pent.length);
        const note = 110 * Math.pow(2, pent[noteIdx] / 12);
        tribal.voiceOsc.frequency.setTargetAtTime(note, now, 0.1);
    } else {
        tribal.voiceGain.gain.setTargetAtTime(0, now, 0.5);
    }

    // POLY - sequence unlock, adds cross-rhythm
    if (u.has('poly')) {
        // 3 against 4 polyrhythm
        const poly3 = Math.sin(tribal.polyPhase * 3) > 0.8;
        const poly4 = Math.sin(tribal.polyPhase * 4 + 0.5) > 0.8;

        if (poly3 && u.has('wood')) playTribalSound('wood', 0.3, -0.5);
        if (poly4 && u.has('stone')) playTribalSound('stone', 0.25, 0.5);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// UNLOCK LOGIC
// ═══════════════════════════════════════════════════════════════════════════

function checkUnlocks() {
    const zone = world.zone;
    const dwell = world.zoneDwell;
    const history = world.zoneHistory;

    // Check zone-based unlocks
    for (const [layerName, layer] of Object.entries(LAYERS)) {
        if (music.unlocked.has(layerName)) continue;
        if (layer.era !== music.era) continue;

        // Zone + dwell unlock
        if (layer.zone && layer.dwell) {
            if (zone === layer.zone && dwell >= layer.dwell) {
                unlock(layerName);
            }
        }

        // Sequence unlock
        if (layer.sequence) {
            if (matchesSequence(history, layer.sequence)) {
                unlock(layerName);
            }
        }
    }

    // Lock in layers after extended dwell (5+ seconds)
    if (dwell >= 5) {
        for (const [layerName, layer] of Object.entries(LAYERS)) {
            if (music.unlocked.has(layerName) && !music.locked.has(layerName)) {
                if (layer.zone === zone) {
                    music.locked.add(layerName);
                    console.log(`Locked: ${layerName}`);
                }
            }
        }
    }
}

function matchesSequence(history, sequence) {
    if (history.length < sequence.length) return false;

    // Check if the last N zones match the sequence
    const recent = history.slice(-sequence.length);
    return recent.every((z, i) => z === sequence[i]);
}

function unlock(layerName) {
    if (music.unlocked.has(layerName)) return;

    music.unlocked.add(layerName);
    console.log(`Unlocked: ${layerName} - ${LAYERS[layerName].description}`);

    // Check for era transition
    checkEraTransition();
}

function checkEraTransition() {
    // Transition to tribal when certain genesis layers are locked
    if (music.era === 'genesis') {
        const genesisLocked = ['fundamental', 'overtones', 'sub'].filter(l => music.locked.has(l));
        if (genesisLocked.length >= 2 && music.unlocked.has('pulse')) {
            transitionToEra('tribal');
        }
    }
}

function transitionToEra(newEra) {
    console.log(`Transitioning to: ${newEra}`);
    music.era = newEra;

    // Fade out previous era
    if (genesis.voidGain) genesis.voidGain.gain.setTargetAtTime(0, ctx.currentTime, 2);
    if (genesis.fundGain) genesis.fundGain.gain.setTargetAtTime(0, ctx.currentTime, 2);
    if (genesis.overtonesGain) genesis.overtonesGain.gain.setTargetAtTime(0, ctx.currentTime, 2);
    if (genesis.subGain) genesis.subGain.gain.setTargetAtTime(0, ctx.currentTime, 2);
    if (genesis.shimmerGain) genesis.shimmerGain.gain.setTargetAtTime(0, ctx.currentTime, 2);
    if (genesis.pulseGain) genesis.pulseGain.gain.setTargetAtTime(0, ctx.currentTime, 2);
}

// ═══════════════════════════════════════════════════════════════════════════
// INPUT
// ═══════════════════════════════════════════════════════════════════════════

function updateInput(nx, ny, dt) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.9 + movement * 5);

    // Zone detection
    const newZone = getZone(nx, ny);

    if (newZone !== world.zone) {
        // Zone changed
        if (world.zoneDwell > 0.3) {
            // Only record if we dwelt for a bit
            world.zoneHistory.push(world.zone);
            if (world.zoneHistory.length > 10) world.zoneHistory.shift();
        }
        world.zone = newZone;
        world.zoneDwell = 0;
    } else {
        // Same zone - accumulate dwell
        world.zoneDwell += dt;
    }

    // Check for unlocks
    checkUnlocks();
}

function onMove(nx, ny) {
    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    updateInput(nx, ny, dt);
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    // Convert tilt to position
    const nx = Math.max(0, Math.min(1, 0.5 + ax * 0.8));
    const ny = Math.max(0, Math.min(1, 0.5 - ay * 0.8));

    const now = performance.now();
    const dt = (now - lastTime) / 1000;
    lastTime = now;
    updateInput(nx, ny, Math.min(dt, 0.1));
}

// ═══════════════════════════════════════════════════════════════════════════
// VISUALS
// ═══════════════════════════════════════════════════════════════════════════

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    // Fade
    vc.fillStyle = 'rgba(0,0,0,0.06)';
    vc.fillRect(0, 0, w, h);

    // Zone grid (very subtle)
    vc.strokeStyle = 'rgba(255,255,255,0.015)';
    vc.lineWidth = 1;

    // Horizontal thirds
    vc.beginPath();
    vc.moveTo(0, h * 0.35);
    vc.lineTo(w, h * 0.35);
    vc.moveTo(0, h * 0.65);
    vc.lineTo(w, h * 0.65);
    // Vertical thirds
    vc.moveTo(w * 0.35, 0);
    vc.lineTo(w * 0.35, h);
    vc.moveTo(w * 0.65, 0);
    vc.lineTo(w * 0.65, h);
    vc.stroke();

    // Center circle
    const breath = Math.sin(world.breath * 0.5) * 0.5 + 0.5;
    const centerSize = 30 + breath * 15 + world.energy * 30 + music.unlocked.size * 3;

    vc.strokeStyle = `rgba(255,255,255,${0.03 + world.energy * 0.05})`;
    vc.beginPath();
    vc.arc(w/2, h/2, centerSize, 0, TAU);
    vc.stroke();

    // Rings for each unlock
    let ring = 0;
    music.unlocked.forEach(layer => {
        if (LAYERS[layer]?.era === music.era) {
            const ringSize = centerSize + 20 + ring * 15;
            const alpha = music.locked.has(layer) ? 0.06 : 0.025;
            vc.strokeStyle = `rgba(255,255,255,${alpha})`;
            vc.beginPath();
            vc.arc(w/2, h/2, ringSize, 0, TAU);
            vc.stroke();
            ring++;
        }
    });

    // Position orb
    const px = world.x * w;
    const py = world.y * h;
    const ps = 4 + world.energy * 15 + (world.zoneDwell > 1 ? 5 : 0);

    // Glow when dwelling
    if (world.zoneDwell > 0.5) {
        const glowSize = ps + world.zoneDwell * 8;
        const glowAlpha = Math.min(0.15, world.zoneDwell * 0.03);
        vc.fillStyle = `rgba(255,255,255,${glowAlpha})`;
        vc.beginPath();
        vc.arc(px, py, glowSize, 0, TAU);
        vc.fill();
    }

    vc.fillStyle = `rgba(255,255,255,${0.3 + world.energy * 0.5})`;
    vc.beginPath();
    vc.arc(px, py, ps, 0, TAU);
    vc.fill();
}

function updateUI() {
    // Era name
    document.getElementById('era-name').textContent = music.era;

    // Zone name
    document.getElementById('zone-name').textContent = world.zone;

    // Dwell bar
    const dwellPercent = Math.min(100, (world.zoneDwell / 3) * 100);
    document.getElementById('dwell-fill').style.width = dwellPercent + '%';

    // Unlocks list
    const unlocksList = Array.from(music.unlocked)
        .filter(l => LAYERS[l]?.era === music.era)
        .map(l => {
            const locked = music.locked.has(l) ? ' class="on"' : '';
            return `<span${locked}>${l}</span>`;
        })
        .join(' · ');
    document.getElementById('unlocks').innerHTML = unlocksList;
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════

function frame() {
    world.breath += 0.015;
    world.energy *= 0.995;

    // Update sounds
    updateGenesis();
    updateTribal();

    // Draw
    draw();
    updateUI();

    requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════════

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    await initAudio();
    initVisuals();

    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();
    frame();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
