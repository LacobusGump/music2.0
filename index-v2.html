<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: system-ui, sans-serif;
        }
        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            z-index: 100; cursor: pointer;
            background: #0a0a0f;
        }
        #enter.off { display: none; }
        #enter .circle {
            width: 120px; height: 120px;
            border-radius: 50%;
            border: 1px solid rgba(255,220,180,0.15);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        #enter:hover .circle { border-color: rgba(255,220,180,0.4); }
        #enter .inner {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(255,220,180,0.08);
        }
        #world {
            position: fixed; inset: 0;
            display: none;
            background: radial-gradient(ellipse at center, #12111a 0%, #0a0a0f 100%);
        }
        #world.on { display: block; }
        canvas { position: fixed; inset: 0; }
        #vibe {
            position: fixed; bottom: 40px; left: 0; right: 0;
            display: flex; justify-content: center; gap: 30px;
            z-index: 50;
        }
        .vibe-btn {
            font-size: 11px;
            color: rgba(255,220,180,0.25);
            background: none; border: none;
            padding: 12px 20px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .vibe-btn.on { color: rgba(255,220,180,0.9); }
        #status {
            position: fixed; top: 20px; left: 20px;
            font-size: 9px;
            color: rgba(255,220,180,0.4);
            letter-spacing: 1px;
            line-height: 1.8;
            font-family: monospace;
        }
        #mic-dot {
            position: fixed; top: 20px; right: 20px;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: rgba(255,100,100,0.3);
            transition: all 0.1s;
        }
        #mic-dot.on { background: rgba(100,255,150,0.8); box-shadow: 0 0 10px rgba(100,255,150,0.5); }
    </style>
</head>
<body>

<div id="enter"><div class="circle"><div class="inner"></div></div></div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="vibe">
        <button class="vibe-btn on" data-vibe="dream">DREAM</button>
        <button class="vibe-btn" data-vibe="pulse">PULSE</button>
        <button class="vibe-btn" data-vibe="deep">DEEP</button>
    </div>
    <div id="status"></div>
    <div id="mic-dot"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// GUMP v2 - THE UNIVERSAL SONG
// ═══════════════════════════════════════════════════════════════════════════
// Architecture:
//   LAYER 1: Core music engine (always works)
//   LAYER 2: Input modulation (motion, mic)
//   LAYER 3: AI enhancement (optional, never gates)
// ═══════════════════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 1: GLOBAL STATE
// ═══════════════════════════════════════════════════════════════════════════

// World state - updated every frame from inputs
const world = {
    x: 0.5, y: 0.5,           // Position (0-1)
    vx: 0, vy: 0,             // Velocity
    energy: 0.3,              // Movement intensity (0-1) - starts at 0.3 so music plays
    stillness: 0,             // Time without movement (0-1)
    breath: 0,                // Slow LFO for organic feel
    pulse: 0,                 // Beat phase for visuals
};

// Music state - what's currently happening musically
const music = {
    bar: 0,
    beat: 0,
    tick: 0,                  // 16th note counter
    chord: 0,                 // Current chord in progression
    tension: 0.5,             // Musical tension (0-1)
    direction: 'float',       // 'build', 'release', 'float'
    lastKick: 0,
    lastSnare: 0,
};

// AI state - suggestions that modify parameters (never gate)
const ai = {
    drumDensity: 0.5,         // 0=sparse, 1=busy
    bassActivity: 0.5,        // 0=whole notes, 1=walking
    padOpenness: 0.5,         // 0=tight voicing, 1=spread
    leadProbability: 0.5,     // 0=rare, 1=frequent
    lastUpdate: 0,
};

// Mic state
const mic = {
    level: 0,
    low: 0, mid: 0, high: 0,
    onset: false,
    active: false,
};

let vibe = 'dream';
let ctx, masterGain, reverbGain, compressor;
let canvas, vc;
let audioReady = false;
let samples = {};
let samplesLoaded = false;

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 2: VIBES - Three distinct musical worlds
// ═══════════════════════════════════════════════════════════════════════════

const VIBES = {
    dream: {
        bpm: 72,
        key: 0,                              // C
        scale: [0, 2, 4, 7, 9],              // Major pentatonic
        chords: [[0,4,7], [5,9,12], [7,11,14], [2,5,9]],  // I - IV - V - ii
        bassOctave: 1,
        swing: 0.15,
        reverbMix: 0.4,
        filterBase: 2000,
        character: 'warm'
    },
    pulse: {
        bpm: 118,
        key: 5,                              // F
        scale: [0, 3, 5, 7, 10],             // Minor pentatonic
        chords: [[0,3,7], [5,8,12], [3,7,10], [7,10,14]],  // i - iv - III - v
        bassOctave: 2,
        swing: 0.05,
        reverbMix: 0.2,
        filterBase: 4000,
        character: 'driving'
    },
    deep: {
        bpm: 82,
        key: 7,                              // G
        scale: [0, 2, 3, 5, 7, 9, 10],       // Dorian
        chords: [[0,3,7,10], [2,5,9], [5,9,12], [0,4,7]],  // i7 - ii - IV - I
        bassOctave: 1,
        swing: 0.2,
        reverbMix: 0.5,
        filterBase: 1500,
        character: 'deep'
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 3: AUDIO ENGINE SETUP
// ═══════════════════════════════════════════════════════════════════════════

let saturation, masterFilter, delayNode, delayGain, textureGain;

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // === Master chain ===
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.8;

    // Saturation for warmth
    saturation = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        curve[i] = Math.tanh(x * 1.4) * 0.85 + x * 0.15;
    }
    saturation.curve = curve;
    saturation.oversample = '4x';

    // Master filter - opens with energy
    masterFilter = ctx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 8000;
    masterFilter.Q.value = 0.7;

    // Delay for space
    delayNode = ctx.createDelay(1.0);
    delayNode.delayTime.value = 0.33;
    const delayFeedback = ctx.createGain();
    delayFeedback.gain.value = 0.25;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2000;
    delayGain = ctx.createGain();
    delayGain.gain.value = 0.15;

    delayNode.connect(delayFilter);
    delayFilter.connect(delayFeedback);
    delayFeedback.connect(delayNode);
    delayNode.connect(delayGain);

    // Reverb
    const reverbBuffer = createReverb(3.0);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.3;

    // Compressor for glue
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -12;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.1;

    // Texture (vinyl/room tone)
    initTexture();

    // === Routing ===
    masterGain.connect(saturation);
    saturation.connect(masterFilter);
    masterFilter.connect(compressor);
    masterGain.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);
    masterGain.connect(delayNode);
    delayGain.connect(compressor);
    compressor.connect(ctx.destination);

    // Load samples
    await loadSamples();

    // Initialize instruments
    initBass();
    initPad();
    initLead();

    // Initialize mic (non-blocking)
    initMic();

    audioReady = true;
    console.log('Audio engine ready');
}

function createReverb(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / ctx.sampleRate;
            data[i] = (Math.random() * 2 - 1) * Math.exp(-t / (duration * 0.35)) * 0.5;
        }
    }
    return buffer;
}

function initTexture() {
    const buffer = ctx.createBuffer(2, ctx.sampleRate * 4, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
            const noise = (Math.random() * 2 - 1) * 0.012;
            const crackle = Math.random() < 0.0002 ? (Math.random() - 0.5) * 0.25 : 0;
            data[i] = noise + crackle;
        }
    }
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 2500;
    filter.Q.value = 0.5;
    textureGain = ctx.createGain();
    textureGain.gain.value = 0.06;
    source.connect(filter);
    filter.connect(textureGain);
    textureGain.connect(masterGain);
    source.start();
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 4: DRUM SAMPLES
// ═══════════════════════════════════════════════════════════════════════════

const SAMPLE_URLS = {
    kick: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
    snare: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    hat: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',
    hatOpen: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',
    rim: 'https://cdn.freesound.org/previews/398/398712_183766-lq.mp3',
    perc: 'https://cdn.freesound.org/previews/250/250537_4486188-lq.mp3'
};

async function loadSamples() {
    const jobs = Object.entries(SAMPLE_URLS).map(async ([name, url]) => {
        try {
            const res = await fetch(url);
            const buf = await res.arrayBuffer();
            samples[name] = await ctx.decodeAudioData(buf);
        } catch (e) {
            console.warn(`Sample ${name} failed, using fallback`);
            samples[name] = createFallback(name);
        }
    });
    await Promise.all(jobs);
    samplesLoaded = true;
}

function createFallback(name) {
    const len = ctx.sampleRate * 0.3;
    const buf = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
            const t = i / ctx.sampleRate;
            if (name === 'kick') {
                const f = 50 + 80 * Math.exp(-t * 40);
                d[i] = Math.sin(TAU * f * t) * Math.exp(-t * 10) * 0.9;
            } else if (name === 'snare') {
                d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 25) * 0.6;
            } else {
                d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40) * 0.4;
            }
        }
    }
    return buf;
}

function playSample(name, vol = 1, pan = 0, rate = 1) {
    if (!samples[name] || !audioReady) return;
    const src = ctx.createBufferSource();
    src.buffer = samples[name];
    src.playbackRate.value = rate;
    const g = ctx.createGain();
    g.gain.value = vol;
    const p = ctx.createStereoPanner();
    p.pan.value = pan;
    src.connect(g);
    g.connect(p);
    p.connect(masterGain);
    src.start();
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 5: BASS SYNTH
// ═══════════════════════════════════════════════════════════════════════════

let bassOsc, bassOsc2, bassGain, bassFilter;

function initBass() {
    // Two oscillators for thickness
    bassOsc = ctx.createOscillator();
    bassOsc.type = 'sine';
    bassOsc.frequency.value = 55;

    bassOsc2 = ctx.createOscillator();
    bassOsc2.type = 'triangle';
    bassOsc2.frequency.value = 55;

    bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 250;
    bassFilter.Q.value = 2;

    bassGain = ctx.createGain();
    bassGain.gain.value = 0;

    const mix = ctx.createGain();
    mix.gain.value = 0.5;

    bassOsc.connect(bassFilter);
    bassOsc2.connect(mix);
    mix.connect(bassFilter);
    bassFilter.connect(bassGain);
    bassGain.connect(masterGain);

    bassOsc.start();
    bassOsc2.start();
}

function playBass(note, vel = 0.6, dur = 0.4) {
    if (!bassOsc || !audioReady) return;
    const v = VIBES[vibe];
    const freq = 55 * Math.pow(2, (v.key + note) / 12) * v.bassOctave;
    const now = ctx.currentTime;

    bassOsc.frequency.setTargetAtTime(freq, now, 0.015);
    bassOsc2.frequency.setTargetAtTime(freq * 1.002, now, 0.015); // Slight detune

    bassGain.gain.cancelScheduledValues(now);
    bassGain.gain.setValueAtTime(bassGain.gain.value, now);
    bassGain.gain.linearRampToValueAtTime(vel * 0.7, now + 0.008);
    bassGain.gain.linearRampToValueAtTime(vel * 0.5, now + dur * 0.4);
    bassGain.gain.linearRampToValueAtTime(0.001, now + dur);

    bassFilter.frequency.setTargetAtTime(180 + vel * 150, now, 0.01);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 6: PAD SYNTH
// ═══════════════════════════════════════════════════════════════════════════

let padOscs = [], padGain, padFilter;

function initPad() {
    padGain = ctx.createGain();
    padGain.gain.value = 0;

    padFilter = ctx.createBiquadFilter();
    padFilter.type = 'lowpass';
    padFilter.frequency.value = 600;
    padFilter.Q.value = 0.5;

    // 5 oscillators for rich pad
    for (let i = 0; i < 5; i++) {
        const osc = ctx.createOscillator();
        osc.type = i < 3 ? 'sine' : 'triangle';
        osc.frequency.value = 220;
        osc.detune.value = (i - 2) * 6;
        const g = ctx.createGain();
        g.gain.value = 0.12;
        osc.connect(g);
        g.connect(padFilter);
        osc.start();
        padOscs.push({ osc, gain: g });
    }

    padFilter.connect(padGain);
    padGain.connect(masterGain);
}

function updatePad() {
    if (!padOscs.length || !audioReady) return;
    const v = VIBES[vibe];
    const chord = v.chords[music.chord % v.chords.length];
    const base = 110 * Math.pow(2, v.key / 12);

    // Spread voicing based on AI suggestion
    const spread = ai.padOpenness;

    padOscs.forEach((p, i) => {
        let note = chord[i % chord.length];
        // Add octave spread based on openness
        if (spread > 0.5 && i >= 3) note += 12;
        if (spread > 0.7 && i >= 4) note += 7;
        const freq = base * Math.pow(2, note / 12);
        p.osc.frequency.setTargetAtTime(freq, ctx.currentTime, 0.4);
    });

    // Pad volume from stillness
    const targetVol = Math.min(0.25, world.stillness * v.reverbMix * 0.5);
    padGain.gain.setTargetAtTime(targetVol, ctx.currentTime, 0.5);
    padFilter.frequency.setTargetAtTime(400 + world.stillness * 1000, ctx.currentTime, 0.3);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 7: LEAD SYNTH
// ═══════════════════════════════════════════════════════════════════════════

let leadOsc, leadOsc2, leadGain, leadFilter;

function initLead() {
    leadOsc = ctx.createOscillator();
    leadOsc.type = 'triangle';
    leadOsc.frequency.value = 440;

    leadOsc2 = ctx.createOscillator();
    leadOsc2.type = 'sine';
    leadOsc2.frequency.value = 440;

    leadFilter = ctx.createBiquadFilter();
    leadFilter.type = 'lowpass';
    leadFilter.frequency.value = 2500;
    leadFilter.Q.value = 3;

    leadGain = ctx.createGain();
    leadGain.gain.value = 0;

    const mix = ctx.createGain();
    mix.gain.value = 0.3;

    leadOsc.connect(leadFilter);
    leadOsc2.connect(mix);
    mix.connect(leadFilter);
    leadFilter.connect(leadGain);
    leadGain.connect(masterGain);

    leadOsc.start();
    leadOsc2.start();
}

function playLead(note, vel = 0.4) {
    if (!leadOsc || !audioReady) return;
    const v = VIBES[vibe];
    const freq = 220 * Math.pow(2, (v.key + note) / 12);
    const now = ctx.currentTime;

    leadOsc.frequency.setTargetAtTime(freq, now, 0.015);
    leadOsc2.frequency.setTargetAtTime(freq * 2.01, now, 0.015); // Octave + slight detune

    leadGain.gain.cancelScheduledValues(now);
    leadGain.gain.setValueAtTime(0.001, now);
    leadGain.gain.linearRampToValueAtTime(vel * 0.12, now + 0.008);
    leadGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

    leadFilter.frequency.setTargetAtTime(1200 + vel * 2500, now, 0.01);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 8: MICROPHONE INPUT
// ═══════════════════════════════════════════════════════════════════════════

let micAnalyser, micData;

async function initMic() {
    try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const source = ctx.createMediaStreamSource(stream);
        micAnalyser = ctx.createAnalyser();
        micAnalyser.fftSize = 512;
        micData = new Uint8Array(micAnalyser.frequencyBinCount);
        source.connect(micAnalyser);
        mic.active = true;
    } catch (e) {
        mic.active = false;
    }
}

function updateMic() {
    if (!mic.active || !micAnalyser) return;

    micAnalyser.getByteFrequencyData(micData);
    const bins = micData.length;
    const lowEnd = Math.floor(bins * 0.1);
    const midEnd = Math.floor(bins * 0.5);

    let lowSum = 0, midSum = 0, highSum = 0, total = 0;
    for (let i = 0; i < bins; i++) {
        const v = micData[i];
        total += v;
        if (i < lowEnd) lowSum += v;
        else if (i < midEnd) midSum += v;
        else highSum += v;
    }

    const prevLevel = mic.level;
    mic.low = lowSum / lowEnd / 255;
    mic.mid = midSum / (midEnd - lowEnd) / 255;
    mic.high = highSum / (bins - midEnd) / 255;
    mic.level = total / bins / 255;

    // Onset detection
    mic.onset = mic.level > prevLevel + 0.12 && mic.level > 0.08;
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 9: AI ENHANCEMENT (Groq)
// ═══════════════════════════════════════════════════════════════════════════

const GROQ_KEY = String.fromCharCode(...[103,115,107,95,82,113,89,116,105,48,70,116,116,76,117,51,113,88,54,69,97,84,88,77,87,71,100,121,98,51,70,89,90,75,54,53,89,49,100,54,122,97,72,122,117,70,76,87,57,90,107,55,87,109,87]);

async function updateAI() {
    const now = Date.now();
    if (now - ai.lastUpdate < 3000) return; // Every 3 seconds
    ai.lastUpdate = now;

    const prompt = `You control a live jazz band. Current state:
- Energy: ${Math.round(world.energy * 100)}%
- Tension: ${Math.round(music.tension * 100)}%
- Stillness: ${Math.round(world.stillness * 100)}%
- Mic active: ${mic.level > 0.05 ? 'yes' : 'no'}

Reply with exactly 4 numbers between 0-100, space-separated:
drumDensity bassActivity padOpenness leadProbability

Example: "60 45 70 55"`;

    try {
        const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${GROQ_KEY}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'llama-3.1-8b-instant',
                messages: [{ role: 'user', content: prompt }],
                max_tokens: 20,
                temperature: 0.5
            })
        });
        const data = await res.json();
        const answer = data.choices?.[0]?.message?.content?.trim();
        const nums = answer?.match(/\d+/g);
        if (nums && nums.length >= 4) {
            ai.drumDensity = Math.min(100, Math.max(0, parseInt(nums[0]))) / 100;
            ai.bassActivity = Math.min(100, Math.max(0, parseInt(nums[1]))) / 100;
            ai.padOpenness = Math.min(100, Math.max(0, parseInt(nums[2]))) / 100;
            ai.leadProbability = Math.min(100, Math.max(0, parseInt(nums[3]))) / 100;
        }
    } catch (e) {
        // AI failed - keep current values, music continues
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 10: RHYTHM ENGINE
// ═══════════════════════════════════════════════════════════════════════════

// Drum patterns - 16 steps per bar
// Format: [kick, snare, hat, ghost, perc]
const PATTERNS = {
    sparse: {
        kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hat:   [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
    },
    normal: {
        kick:  [1,0,0,0, 0,0,1,0, 0,0,0,0, 0,1,0,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hat:   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
        ghost: [0,0,0,1, 0,0,0,0, 0,0,0,1, 0,0,0,0],
    },
    busy: {
        kick:  [1,0,0,1, 0,0,1,0, 0,1,0,0, 0,0,1,0],
        snare: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,1],
        hat:   [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],
        ghost: [0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1],
        rim:   [0,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],
    }
};

let lastTickTime = -1;

function getPattern() {
    // Select pattern based on AI density + energy
    const level = (ai.drumDensity + world.energy) / 2;
    if (level < 0.33) return PATTERNS.sparse;
    if (level < 0.66) return PATTERNS.normal;
    return PATTERNS.busy;
}

function getSwing(tickInBeat) {
    const v = VIBES[vibe];
    return (tickInBeat === 1 || tickInBeat === 3) ? v.swing * 0.04 : 0;
}

function onTick() {
    const v = VIBES[vibe];
    const tickInBar = music.tick % 16;
    const beatInBar = Math.floor(tickInBar / 4);
    const tickInBeat = tickInBar % 4;

    // Velocity influenced by energy and mic
    const baseVel = 0.5 + world.energy * 0.3 + mic.level * 0.2;

    // === DRUMS (always play based on pattern) ===
    const pat = getPattern();

    if (pat.kick?.[tickInBar]) {
        playSample('kick', baseVel * 0.9, 0, 1);
        music.lastKick = music.tick;
    }

    if (pat.snare?.[tickInBar]) {
        const pan = (Math.random() - 0.5) * 0.15;
        playSample('snare', baseVel * 0.75, pan, 0.98 + Math.random() * 0.04);
        music.lastSnare = music.tick;
    }

    if (pat.hat?.[tickInBar]) {
        const type = Math.random() < 0.08 ? 'hatOpen' : 'hat';
        const vel = baseVel * (tickInBeat === 0 ? 0.4 : 0.28);
        playSample(type, vel, 0.25, 0.92 + Math.random() * 0.16);
    }

    if (pat.ghost?.[tickInBar]) {
        playSample('snare', baseVel * 0.2, 0.1, 0.95);
    }

    if (pat.rim?.[tickInBar]) {
        playSample('rim', baseVel * 0.35, -0.2, 1);
    }

    // === BASS (always plays, activity varies) ===
    const scale = v.scale;
    const bassFrequency = ai.bassActivity < 0.3 ? 4 : ai.bassActivity < 0.6 ? 2 : 1;

    if (tickInBeat === 0 && beatInBar % bassFrequency === 0) {
        // Choose bass note based on chord and movement
        let bassNote = scale[0]; // Root by default

        if (ai.bassActivity > 0.4) {
            // Walking bass - move through scale
            bassNote = scale[(beatInBar + music.bar) % scale.length];
        }
        if (ai.bassActivity > 0.7 && beatInBar === 2) {
            // Add passing tone
            bassNote = scale[(beatInBar + music.bar + 1) % scale.length];
        }

        const dur = (60 / v.bpm) * (4 / bassFrequency) * 0.9;
        playBass(bassNote, 0.6 + world.energy * 0.2, dur);
    }

    // === PAD (updates on bar) ===
    if (tickInBar === 0) {
        // Chord progression
        if (music.bar % 4 === 0) {
            music.chord = (music.chord + 1) % v.chords.length;
        }
        updatePad();
    }

    // === LEAD (probability-based, responds to movement) ===
    // Probability increases with energy, mic, and AI suggestion
    const leadProb = (world.energy * 0.4 + mic.level * 0.3 + ai.leadProbability * 0.3);

    if (tickInBeat === 0 && Math.random() < leadProb) {
        // Note selection based on Y position and scale
        const noteIdx = Math.floor(world.y * scale.length);
        let note = scale[noteIdx];

        // Octave based on position and tension
        if (world.y > 0.7 || music.tension > 0.7) note += 12;
        if (world.y < 0.3 && music.tension < 0.3) note -= 0; // Stay low

        playLead(note, 0.35 + world.energy * 0.3);
    }

    // Mic onset triggers immediate lead note
    if (mic.onset && Math.random() < 0.6) {
        const note = scale[Math.floor(Math.random() * scale.length)];
        playLead(note + (mic.high > mic.low ? 12 : 0), mic.level * 0.8);
    }

    // Update counters
    music.tick++;
    if (tickInBar === 15) {
        music.bar++;
        music.beat = 0;
    }
    if (tickInBeat === 3) {
        music.beat++;
    }
}

function updateRhythm() {
    if (!audioReady || !samplesLoaded) return;

    const v = VIBES[vibe];
    const tickDur = 60 / v.bpm / 4;
    const now = ctx.currentTime;

    if (lastTickTime < 0) {
        lastTickTime = now;
        return;
    }

    const swing = getSwing(music.tick % 4);
    if (now - lastTickTime >= tickDur + swing) {
        lastTickTime = now;
        onTick();
    }

    // Visual pulse
    world.pulse = (now - lastTickTime) / tickDur;
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 11: INPUT HANDLING
// ═══════════════════════════════════════════════════════════════════════════

function onMove(nx, ny) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.vx = world.vx * 0.7 + dx * 0.3;
    world.vy = world.vy * 0.7 + dy * 0.3;
    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.85 + movement * 10);

    if (movement > 0.008) {
        world.stillness = Math.max(0, world.stillness - 0.15);
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    world.x = Math.max(0, Math.min(1, world.x + ax * 0.06));
    world.y = Math.max(0, Math.min(1, world.y - ay * 0.06));

    const movement = Math.sqrt(ax*ax + ay*ay);
    world.energy = Math.min(1, world.energy * 0.8 + movement * 0.5);

    if (movement > 0.03) {
        world.stillness = Math.max(0, world.stillness - 0.08);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 12: VISUALS
// ═══════════════════════════════════════════════════════════════════════════

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    // Fade
    vc.fillStyle = `rgba(10,10,15,${0.12 + world.energy * 0.08})`;
    vc.fillRect(0, 0, w, h);

    // Center breath circle
    const breath = 50 + Math.sin(world.breath) * 12 + world.pulse * 25;
    vc.strokeStyle = `rgba(255,220,180,${0.04 + world.stillness * 0.06})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w/2, h/2, breath, 0, TAU);
    vc.stroke();

    // Tension ring
    const tensionR = breath + 25 + music.tension * 50;
    const hue = music.direction === 'build' ? '255,180,100' :
                music.direction === 'release' ? '100,180,255' : '180,180,200';
    vc.strokeStyle = `rgba(${hue},${music.tension * 0.15})`;
    vc.beginPath();
    vc.arc(w/2, h/2, tensionR, 0, TAU);
    vc.stroke();

    // Energy ring
    if (world.energy > 0.1) {
        const energyR = breath + 60 + world.energy * 60;
        vc.strokeStyle = `rgba(255,220,180,${world.energy * 0.12})`;
        vc.beginPath();
        vc.arc(w/2, h/2, energyR, 0, TAU);
        vc.stroke();
    }

    // Mic ring
    if (mic.active && mic.level > 0.04) {
        const micR = breath + 100 + mic.level * 80;
        vc.strokeStyle = `rgba(100,255,150,${mic.level * 0.25})`;
        vc.lineWidth = 2;
        vc.beginPath();
        vc.arc(w/2, h/2, micR, 0, TAU);
        vc.stroke();
        vc.lineWidth = 1;
    }

    // Position dot
    const px = world.x * w;
    const py = world.y * h;
    const ps = 5 + world.energy * 18;
    vc.fillStyle = `rgba(255,220,180,${0.35 + world.energy * 0.5})`;
    vc.beginPath();
    vc.arc(px, py, ps, 0, TAU);
    vc.fill();

    // Mic indicator
    document.getElementById('mic-dot').classList.toggle('on', mic.active && mic.level > 0.08);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 13: MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════

function frame() {
    // Update world
    world.breath += 0.018;
    world.energy *= 0.992;
    world.stillness = Math.min(1, world.stillness + 0.004);

    // Update tension based on energy
    if (world.energy > 0.5) {
        music.tension = Math.min(1, music.tension + 0.003);
        music.direction = 'build';
    } else if (world.energy < 0.2) {
        music.tension = Math.max(0, music.tension - 0.002);
        music.direction = 'release';
    } else {
        music.direction = 'float';
    }

    // Update mic
    updateMic();

    // Update rhythm (handles all instruments)
    updateRhythm();

    // Update master filter based on energy
    if (masterFilter) {
        const v = VIBES[vibe];
        const target = v.filterBase + world.energy * 6000;
        masterFilter.frequency.setTargetAtTime(target, ctx.currentTime, 0.1);
    }

    // Update reverb based on vibe
    if (reverbGain) {
        const v = VIBES[vibe];
        reverbGain.gain.setTargetAtTime(v.reverbMix * 0.4, ctx.currentTime, 0.2);
    }

    // AI update (non-blocking)
    updateAI();

    // Draw
    draw();

    // Status
    const status = `${vibe} · bar ${music.bar + 1}
drums: ${Math.round(ai.drumDensity * 100)}%
bass: ${Math.round(ai.bassActivity * 100)}%
lead: ${Math.round(ai.leadProbability * 100)}%
tension: ${Math.round(music.tension * 100)}%`;
    document.getElementById('status').innerHTML = status.replace(/\n/g, '<br>');

    requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 14: INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════

function initVibeButtons() {
    document.querySelectorAll('.vibe-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            e.stopPropagation();
            document.querySelectorAll('.vibe-btn').forEach(b => b.classList.remove('on'));
            btn.classList.add('on');
            vibe = btn.dataset.vibe;
            music.tick = 0;
            music.bar = 0;
            music.chord = 0;
            lastTickTime = -1;
        });
    });
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    // iOS motion permission
    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    await initAudio();
    initVisuals();
    initVibeButtons();

    // Input listeners
    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();
    frame();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
