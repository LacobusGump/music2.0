<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GUMP</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"
            onerror="document.getElementById('err').style.display='flex'"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        html,body{width:100%;height:100%;background:#050505;overflow:hidden;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,sans-serif}
        #entry{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
        #entry.gone{display:none}
        #entry h1{font-size:10px;font-weight:300;letter-spacing:8px;color:rgba(255,255,255,.15);margin-bottom:40px}
        #entry p{font-size:11px;color:rgba(255,255,255,.25);text-align:center;line-height:2.4;max-width:260px;margin-bottom:50px}
        #entry button{width:90px;height:90px;border-radius:50%;background:0;border:1px solid rgba(255,255,255,.08);color:rgba(255,255,255,.2);font-size:9px;letter-spacing:3px;cursor:pointer;transition:.6s}
        #entry button:hover{border-color:rgba(255,255,255,.2)}
        canvas{position:fixed;inset:0}
        .hud{position:fixed;pointer-events:none;font-size:9px;letter-spacing:2px;color:rgba(255,255,255,.12);z-index:5}
        #stageName{top:24px;left:24px}
        #sectionName{bottom:24px;right:24px;font-size:8px;letter-spacing:3px;color:rgba(255,255,255,.06)}
        #sensorStatus{bottom:24px;left:24px;font-size:7px;letter-spacing:1px;color:rgba(255,255,255,.08)}
        #sensorStatus .on{color:rgba(120,200,120,.25)}
        #energyBar{bottom:0;left:0;right:0;height:2px;z-index:5}
        #energyFill{height:100%;width:0%;background:rgba(255,255,255,.15);transition:width .3s linear}
        #notif{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:11px;letter-spacing:5px;color:rgba(255,255,255,.5);opacity:0;transition:opacity .3s;pointer-events:none;z-index:10}
        #notif.show{opacity:1}
        #weatherInfo{top:24px;right:24px;font-size:8px;color:rgba(255,255,255,.06)}
        #micBtn{position:fixed;bottom:20px;left:80px;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,.08);background:0;color:rgba(255,255,255,.12);font-size:8px;cursor:pointer;z-index:10;display:none}
        #micBtn.on{border-color:rgba(200,100,100,.3);color:rgba(200,100,100,.3)}
        #err{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000;color:rgba(255,255,255,.3);font-size:11px;text-align:center;z-index:999;flex-direction:column}
    </style>
</head>
<body>
<div id="entry">
    <h1>GUMP</h1>
    <p>
        move to conduct<br>
        tilt for expression<br>
        touch to play<br>
        stillness to breathe
    </p>
    <button id="begin">AWAKEN</button>
</div>
<canvas id="c"></canvas>
<div class="hud" id="stageName"></div>
<div class="hud" id="sectionName"></div>
<div class="hud" id="weatherInfo"></div>
<div class="hud" id="sensorStatus"></div>
<div id="energyBar"><div id="energyFill"></div></div>
<div id="notif"></div>
<button id="micBtn">MIC</button>
<div id="err">Failed to load audio engine.<br>Check connection and reload.</div>

<script>
(function() {
'use strict';

const TAU = Math.PI * 2;
const A = 432;

// ═══════════════════════════════════════════════════════════════════════════════
// MUSICAL DNA
// ═══════════════════════════════════════════════════════════════════════════════

const PROGRESSIONS = {
    drift: [
        [0, 3, 7],     [7, 10, 14],   [5, 8, 12],    [0, 3, 7],
    ],
    wander: [
        [0, 3, 7],     [5, 9, 12],    [3, 7, 10],    [7, 11, 14],
        [0, 3, 7],     [8, 12, 15],   [3, 7, 10],    [10, 14, 17],
    ],
    ascend: [
        [3, 7, 10],    [10, 14, 17],  [0, 4, 7],     [5, 9, 12],
        [8, 12, 15],   [3, 7, 10],
    ],
    summit: [
        [3, 7, 10],    [10, 14, 17],  [0, 3, 7],     [8, 12, 15],
        [5, 9, 12],    [0, 4, 7],     [7, 11, 14],   [3, 6, 10],
    ],
    descend: [
        [5, 8, 12],    [10, 14, 17],  [3, 7, 10],    [8, 12, 15],
        [0, 3, 7],     [7, 11, 14],   [0, 3, 7],
    ],
};

const SCALES = {
    minor:      [0, 2, 3, 5, 7, 8, 10],
    major:      [0, 2, 4, 5, 7, 9, 11],
    dorian:     [0, 2, 3, 5, 7, 9, 10],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    phrygian:   [0, 1, 3, 5, 7, 8, 10],
};

const DRUM_PATTERNS = {
    minimal: {
        K:  [1,0,0,0, 0,0,0,0, .6,0,0,0, 0,0,0,0],
        SN: [0,0,0,0, 1,0,0,0, 0,0,0,0, .8,0,0,0],
        HH: [.4,0,.2,0, .4,0,.2,0, .4,0,.2,0, .4,0,.2,0],
        OH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    },
    groove: {
        K:  [1,0,0,0, 0,0,.4,0, .8,0,0,0, 0,0,0,0],
        SN: [0,0,0,0, 1,0,.1,.15, 0,0,.1,0, 1,0,.15,.1],
        HH: [.6,.2,.4,.2, .6,.25,.4,.25, .6,.2,.4,.2, .6,.25,.4,.25],
        OH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,.25,0],
    },
    drive: {
        K:  [1,0,.2,0, 0,0,.5,0, .9,0,0,.2, 0,0,.4,0],
        SN: [0,0,0,0, 1,0,.2,.1, 0,0,.1,0, 1,.1,.2,.15],
        HH: [.7,.3,.5,.3, .7,.35,.5,.35, .7,.3,.5,.3, .7,.35,.5,.35],
        OH: [0,0,0,0, 0,0,0,.2, 0,0,0,0, 0,0,0,.25],
    },
    peak: {
        K:  [1,0,.3,0, 0,.15,.6,0, 1,0,.2,.1, 0,.15,.5,0],
        SN: [0,0,.08,0, 1,0,.2,.12, 0,.08,.12,0, 1,.08,.25,.15],
        HH: [.8,.35,.6,.35, .8,.4,.6,.4, .8,.35,.6,.35, .8,.4,.6,.4],
        OH: [0,0,0,.15, 0,0,0,.2, 0,0,0,.15, 0,0,0,.25],
    },
    fill: {
        K:  [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        SN: [0,.35,.35,.45, .55,.55,.65,.65, .75,.75,.85,.8, .95,.9,1,1],
        HH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        OH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    },
};

const BASS_PATTERNS = [
    [0, 7, 0, 7],     [0, 3, 7, 5],     [0, 7, 5, 3],
    [0, 5, 7, 10],    [0, 0, 7, 6],     [0, 3, 5, 7],
];

const ARP_PATTERNS = {
    up:      [0,1,2,3,4,5],
    down:    [5,4,3,2,1,0],
    updown:  [0,1,2,3,4,5,4,3,2,1],
    cascade: [0,2,1,3,2,4,3,5],
};

const SWING = 0.18;

const SECTIONS = [
    { name: 'DRIFT',   scale: 'minor',      tr: 0,  tempoMul: 0.9,  threshold: 0,    holdTime: 0  },
    { name: 'WANDER',  scale: 'dorian',     tr: 0,  tempoMul: 1.0,  threshold: 0.35, holdTime: 30 },
    { name: 'ASCEND',  scale: 'mixolydian', tr: 2,  tempoMul: 1.05, threshold: 0.55, holdTime: 45 },
    { name: 'SUMMIT',  scale: 'major',      tr: 5,  tempoMul: 1.1,  threshold: 0.80, holdTime: 60 },
    { name: 'DESCEND', scale: 'minor',      tr: 0,  tempoMul: 0.85, threshold: -1,   holdTime: 25 },
];

const TIERS = [
    { name: 'SILENCE',    e: 0,    voices: 0, drums: false, pat: 'minimal' },
    { name: 'AWAKENING',  e: 0.05, voices: 1, drums: false, pat: 'minimal' },
    { name: 'PULSE',      e: 0.15, voices: 2, drums: false, pat: 'minimal' },
    { name: 'WARMTH',     e: 0.30, voices: 3, drums: false, pat: 'groove'  },
    { name: 'GROOVE',     e: 0.42, voices: 3, drums: true,  pat: 'groove'  },
    { name: 'SWELL',      e: 0.55, voices: 4, drums: true,  pat: 'groove'  },
    { name: 'SURGE',      e: 0.68, voices: 5, drums: true,  pat: 'drive'   },
    { name: 'RADIANCE',   e: 0.82, voices: 6, drums: true,  pat: 'peak'    },
    { name: 'BEYOND',     e: 0.94, voices: 6, drums: true,  pat: 'peak'    },
];

const PALETTES = {
    DRIFT:   { h: 220, s: 25, l: 45 },
    WANDER:  { h: 200, s: 30, l: 50 },
    ASCEND:  { h: 170, s: 35, l: 55 },
    SUMMIT:  { h: 35,  s: 45, l: 60 },
    DESCEND: { h: 260, s: 30, l: 45 },
};

function noteFreq(semi) { return A * Math.pow(2, semi / 12); }

// ═══════════════════════════════════════════════════════════════════════════════
// NEUROMORPHIC SENSORY MODULES
// Each module: receptor → local memory → compute → output signal
// Memory is LOCAL to the compute. Compute happens AFTER inputs register.
// ═══════════════════════════════════════════════════════════════════════════════

const SENSE = {
    // ── MOTION (accelerometer) ──
    motion: {
        // Receptor: raw accelerometer data
        raw: { x: 0, y: 0, z: 0 },
        prev: { x: 0, y: 0, z: 0 },

        // Local memory: history buffer (G7 flywheel pattern)
        buffer: [],          // last 150 deviation samples
        totalAccumulated: 0, // G7's flywheel — total motion ever
        lastDataTime: 0,     // when we last received data
        requestTime: 0,      // when we requested permission

        // Computed features
        magnitude: 0,        // |acceleration|
        deviation: 0,        // deviation from gravity
        speed: 0,            // smoothed normalized speed [0,1]
        smoothSpeed: 0,      // very smooth speed for audio modulation
        avgMotion: 0,        // average of buffer
        variance: 0,         // variance of buffer
        pattern: 'still',    // still / gentle / rhythmic / vigorous / chaotic
        direction: { x: 0, y: 0 },

        // Output signal
        energyContrib: 0,    // how much energy this sense contributes per frame

        // Status
        listening: false,    // event listener attached?
        receiving: false,    // actually getting data?
        permitted: false,    // permission requested and not denied?
    },

    // ── ORIENTATION (gyroscope/compass) ──
    orientation: {
        // Receptor
        raw: { alpha: 0, beta: 45, gamma: 0 },

        // Computed
        tiltX: 0,            // left/right roll [-1, 1]
        tiltY: 0,            // forward/back tilt [-1, 1]
        brightness: 0.5,     // derived from tiltY [0, 1]
        stereoField: 0,      // derived from tiltX [-1, 1]

        // Status
        listening: false,
        receiving: false,
        permitted: false,
    },

    // ── TOUCH ──
    touch: {
        // Receptor
        raw: { x: 0.5, y: 0.5 },
        pressing: false,
        pressActive: false,  // for arp: sustained press

        // Local memory
        buffer: [],          // last 30 positions for gesture detection
        prevX: 0.5, prevY: 0.5,

        // Computed
        velocity: 0,         // movement speed of touch
        gestureType: null,   // detected gesture (SHAKE, SWIPE_UP, etc.)
        gestureCooldown: 0,

        // Output signal
        energyContrib: 0,

        // Status
        active: false,
    },

    // ── BREATH (derived from accelZ) ──
    breath: {
        // Local memory
        azSmooth: 0,
        azHist: [],

        // Computed
        phase: 'none',       // none / inhale / peak / exhale / valley
        progress: 0,
        depth: 0,
        breathStart: 0,
        breathDur: 4000,
        breathDurs: [],
        lastPeakTime: 0,

        // Output signal
        energyContrib: 0,

        // Status
        active: false,
    },

    // ── MICROPHONE ──
    mic: {
        centroid: 0,
        amplitude: 0,
        filterMod: 0,
        active: false,
    },

    // ── ENVIRONMENT ──
    env: {
        temperature: null,
        weatherCode: null,
        tempoMod: 0,
        reverbMod: 0.25,
        scaleMod: null,
        active: false,
    },
};

// ── CONDUCTOR STATE (synthesized from all senses) ──
const S = {
    active: false,
    energy: 0, peakEnergy: 0, stillness: 0,

    // Musical
    tier: TIERS[0], prevTier: TIERS[0],
    section: SECTIONS[0], sectionIndex: 0, sectionHoldTimer: 0,
    chordIndex: 0, transpose: 0,
    bpm: 85, baseBpm: 85, activeScale: 'minor',

    // Groove
    groovePlaying: false, grooveStep: 0, nextStepTime: 0, fillCountdown: 0,
    bassPatIdx: 0, arpStep: 0, arpPattern: 'up',

    // Viz
    particles: [], rings: [],
};

let FX = {}, V = {}, DRUMS = {}, MELODY = null, BASS = null, ARP = null, MIC = null;

// ═══════════════════════════════════════════════════════════════════════════════
// AUDIO INIT (unchanged — this code works)
// ═══════════════════════════════════════════════════════════════════════════════

async function initAudio() {
    const master = new Tone.Gain(0.6).toDestination();
    const limiter = new Tone.Limiter(-2).connect(master);

    const comp = new Tone.Compressor({
        threshold: -18, ratio: 4, attack: 0.003, release: 0.15
    }).connect(limiter);

    const reverb = new Tone.Reverb({ decay: 4, wet: 0.22 });
    reverb.connect(comp);
    try { await reverb.generate(); } catch(e) {}

    const delay = new Tone.PingPongDelay({
        delayTime: 60 / S.bpm / 2,
        feedback: 0.22, wet: 0.08, maxDelay: 2
    }).connect(reverb);

    const dust = new Tone.Filter({ frequency: 4000, type: 'lowpass', Q: 0.5 }).connect(delay);
    const sat = new Tone.Distortion({ distortion: 0.1, wet: 0.12, oversample: '2x' }).connect(dust);
    const warmth = new Tone.EQ3({ low: 4, mid: -1, high: -3, lowFrequency: 300, highFrequency: 5000 }).connect(sat);
    const chorus = new Tone.Chorus({ frequency: 1.2, delayTime: 4, depth: 0.35, wet: 0.25 }).connect(warmth);
    chorus.start();

    const panner = new Tone.AutoPanner({ frequency: 0.07, depth: 0.3 }).connect(chorus);
    panner.start();

    const sidechain = new Tone.Gain(1).connect(chorus);
    const padBus = new Tone.Gain(1).connect(panner);

    const drumComp = new Tone.Compressor({
        threshold: -14, ratio: 6, attack: 0.001, release: 0.08
    }).connect(comp);
    const drumWarmth = new Tone.EQ3({ low: 3, mid: -2, high: -4, lowFrequency: 200, highFrequency: 6000 }).connect(drumComp);
    const drumSat = new Tone.Distortion({ distortion: 0.06, wet: 0.1 }).connect(drumWarmth);
    const drumBus = new Tone.Gain(0.55).connect(drumSat);

    const drumRoom = new Tone.Reverb({ decay: 0.8, wet: 0.06 });
    drumRoom.connect(drumComp);
    try { await drumRoom.generate(); } catch(e) {}
    const drumRoomSend = new Tone.Gain(0.4).connect(drumRoom);

    const melodySend = new Tone.Gain(0.75).connect(chorus);
    const bassBus = new Tone.Gain(0.85).connect(warmth);
    const arpBus = new Tone.Gain(0.6).connect(delay);

    FX = { master, limiter, comp, reverb, delay, dust, sat, warmth, chorus,
           panner, sidechain, padBus, drumBus, drumSat, drumComp, drumWarmth,
           drumRoom, drumRoomSend, melodySend, bassBus, arpBus };

    createVoices();
    createDrums();
    createMelody();
    createBass();
    createArp();
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICES (unchanged)
// ═══════════════════════════════════════════════════════════════════════════════

function makeOsc(cfg) {
    let osc;
    if (cfg.type === 'fm') {
        osc = new Tone.FMOscillator({
            frequency: cfg.freq,
            type: cfg.carrier || 'sine',
            modulationType: cfg.modType || 'sine',
            modulationIndex: cfg.modIndex || 2,
            harmonicity: cfg.harmonicity || 1.5
        });
    } else if (cfg.type === 'fat') {
        osc = new Tone.FatOscillator({
            frequency: cfg.freq,
            type: cfg.waveform || 'sawtooth',
            count: cfg.count || 3,
            spread: cfg.spread || 20
        });
    } else if (cfg.type === 'am') {
        osc = new Tone.AMOscillator({
            frequency: cfg.freq,
            type: cfg.carrier || 'sine',
            modulationType: cfg.modType || 'sine',
            harmonicity: cfg.harmonicity || 2
        });
    }
    if (cfg.detune) osc.detune.value = cfg.detune;
    return osc;
}

function createLayer(configs, filterFreq, dest) {
    const filter = new Tone.Filter({ frequency: filterFreq, type: 'lowpass', rolloff: -12, Q: 0.7 });
    const gain = new Tone.Gain(0);
    filter.connect(gain);
    gain.connect(dest || FX.sidechain);
    const oscs = configs.map(cfg => {
        const osc = makeOsc(cfg);
        osc.connect(filter);
        osc.start();
        return osc;
    });
    return { oscs, filter, gain };
}

function createVoices() {
    const ch = getChord();

    V.lead = createLayer([
        { type: 'fm', freq: noteFreq(ch[0]), modIndex: 1.2, harmonicity: 1.5 },
        { type: 'fm', freq: noteFreq(ch[0]), modIndex: 0.8, harmonicity: 2, detune: 7 }
    ], 600);

    V.sub = createLayer([
        { type: 'fm', freq: noteFreq(ch[0] - 24), modIndex: 0.3, harmonicity: 1 },
        { type: 'fm', freq: noteFreq(ch[0] - 24), modIndex: 0.2, harmonicity: 1, detune: 3 }
    ], 300);

    V.pad = createLayer(ch.map((n, i) => ({
        type: 'fm', freq: noteFreq(n - 12), carrier: 'triangle',
        modType: 'sine', modIndex: 1.8, harmonicity: 2, detune: (i - 1) * 10
    })), 1200, FX.padBus);

    V.strings = createLayer(ch.map(n => ({
        type: 'fat', freq: noteFreq(n + 12), waveform: 'sawtooth', count: 3, spread: 25
    })), 2500);

    V.brass = createLayer([
        { type: 'fm', freq: noteFreq(ch[0] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 5, harmonicity: 3 },
        { type: 'fm', freq: noteFreq(ch[2] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 4, harmonicity: 3 }
    ], 1000);

    V.choir = createLayer(ch.map(n => ({
        type: 'am', freq: noteFreq(n + 24), carrier: 'sine', modType: 'sine', harmonicity: 2.5
    })), 6000);
}

function glideChord(chord, dur) {
    const t = dur || 0.6;
    const tr = S.transpose;
    V.lead.oscs[0].frequency.rampTo(noteFreq(chord[0] + tr), t);
    V.lead.oscs[1].frequency.rampTo(noteFreq(chord[0] + tr), t);
    V.sub.oscs[0].frequency.rampTo(noteFreq(chord[0] + tr - 24), t);
    V.sub.oscs[1].frequency.rampTo(noteFreq(chord[0] + tr - 24), t);
    chord.forEach((n, i) => {
        if (V.pad.oscs[i]) V.pad.oscs[i].frequency.rampTo(noteFreq(n + tr - 12), t);
        if (V.strings.oscs[i]) V.strings.oscs[i].frequency.rampTo(noteFreq(n + tr + 12), t);
        if (V.choir.oscs[i]) V.choir.oscs[i].frequency.rampTo(noteFreq(n + tr + 24), t);
    });
    if (V.brass.oscs[0]) V.brass.oscs[0].frequency.rampTo(noteFreq(chord[0] + tr + 12), t);
    if (V.brass.oscs[1]) V.brass.oscs[1].frequency.rampTo(noteFreq(chord[2] + tr + 12), t);
}

function getChord() {
    const progName = S.section.name.toLowerCase();
    const prog = PROGRESSIONS[progName] || PROGRESSIONS.drift;
    return prog[S.chordIndex % prog.length];
}

// ═══════════════════════════════════════════════════════════════════════════════
// DRUMS (unchanged)
// ═══════════════════════════════════════════════════════════════════════════════

function createDrums() {
    DRUMS.kickBody = new Tone.MembraneSynth({
        pitchDecay: 0.07, octaves: 8,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.002, decay: 0.5, sustain: 0, release: 0.35 },
        volume: -6
    }).connect(FX.drumBus);

    DRUMS.kickSub = new Tone.Oscillator({ frequency: 50, type: 'sine' });
    DRUMS.kickSubGain = new Tone.Gain(0).connect(FX.drumBus);
    DRUMS.kickSub.connect(DRUMS.kickSubGain);
    DRUMS.kickSub.start();

    const kickClickF = new Tone.Filter({ frequency: 3000, type: 'bandpass', Q: 2 }).connect(FX.drumBus);
    DRUMS.kickClick = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.015, sustain: 0, release: 0.008 },
        volume: -14
    }).connect(kickClickF);

    DRUMS.snareBody = new Tone.MembraneSynth({
        pitchDecay: 0.01, octaves: 3.5,
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.06 },
        volume: -9
    }).connect(FX.drumBus);

    const snareCrackF = new Tone.Filter({ frequency: 3500, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.snareCrack = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.03 },
        volume: -8
    }).connect(snareCrackF);

    const snareTailF = new Tone.Filter({ frequency: 2000, type: 'bandpass', Q: 1.5 }).connect(FX.drumBus);
    DRUMS.snareTail = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.18, sustain: 0, release: 0.06 },
        volume: -12
    }).connect(snareTailF);
    DRUMS.snareTail.connect(FX.drumRoomSend);

    const hatF = new Tone.Filter({ frequency: 9000, type: 'highpass' }).connect(FX.drumBus);
    const hatBP = new Tone.Filter({ frequency: 10000, type: 'bandpass', Q: 0.8 }).connect(hatF);
    DRUMS.hat = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.035, sustain: 0, release: 0.01 },
        volume: -14
    }).connect(hatBP);

    const openHatF = new Tone.Filter({ frequency: 7000, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.openHat = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.22, sustain: 0.02, release: 0.08 },
        volume: -16
    }).connect(openHatF);

    const crashF = new Tone.Filter({ frequency: 4000, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.crash = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.005, decay: 1.8, sustain: 0.01, release: 0.4 },
        volume: -18
    }).connect(crashF);
    DRUMS.crash.connect(FX.drumRoomSend);

    DRUMS.tom = new Tone.MembraneSynth({
        pitchDecay: 0.06, octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.25, sustain: 0, release: 0.15 },
        volume: -10
    }).connect(FX.drumBus);
    DRUMS.tom.connect(FX.drumRoomSend);
}

function triggerKick(t, vel) {
    DRUMS.kickBody.triggerAttackRelease('C1', '8n', t, vel);
    DRUMS.kickClick.triggerAttackRelease('32n', t, vel * 0.7);
    DRUMS.kickSubGain.gain.cancelScheduledValues(t);
    DRUMS.kickSubGain.gain.setValueAtTime(vel * 0.12, t);
    DRUMS.kickSubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
}

function triggerSnare(t, vel) {
    DRUMS.snareBody.triggerAttackRelease('E3', '16n', t, vel);
    DRUMS.snareCrack.triggerAttackRelease('16n', t, vel * 0.9);
    DRUMS.snareTail.triggerAttackRelease('16n', t, vel * 0.5);
}

// ═══════════════════════════════════════════════════════════════════════════════
// GROOVE ENGINE (reads from SENSE modules)
// ═══════════════════════════════════════════════════════════════════════════════

function runGroove() {
    if (!S.groovePlaying) return;

    const stepDur = (60 / S.bpm) / 4;
    const lookAhead = 0.1;
    const e = S.energy;
    const intensity = 0.3 + e * 0.7;
    const chord = getChord();
    const tierIdx = TIERS.indexOf(S.tier);
    // User active = motion OR touch (reads from sensory modules)
    const userActive = SENSE.motion.speed > 0.02 || SENSE.touch.pressing;

    while (S.nextStepTime < Tone.now() + lookAhead) {
        const step = S.grooveStep;
        const now = Math.max(Tone.now(), S.nextStepTime);

        const isFill = S.fillCountdown > 0;
        const patName = isFill ? 'fill' : (S.tier.pat || 'groove');
        const pat = DRUM_PATTERNS[patName] || DRUM_PATTERNS.groove;

        const jit = (Math.random() - 0.5) * 0.005;
        const vVar = 0.88 + Math.random() * 0.24;
        const t = now + jit;

        if (pat.K[step]) {
            triggerKick(t, pat.K[step] * intensity * vVar);
            FX.sidechain.gain.cancelScheduledValues(t);
            FX.sidechain.gain.setValueAtTime(1, t);
            FX.sidechain.gain.linearRampToValueAtTime(0.25, t + 0.015);
            FX.sidechain.gain.linearRampToValueAtTime(1, t + 0.12);
        }
        if (pat.SN[step]) {
            triggerSnare(t, pat.SN[step] * intensity * vVar);
        }
        if (pat.HH[step]) {
            DRUMS.hat.triggerAttackRelease('32n', t, pat.HH[step] * intensity * vVar * 0.7);
        }
        if (pat.OH && pat.OH[step]) {
            DRUMS.openHat.triggerAttackRelease('8n', t, pat.OH[step] * intensity * vVar);
        }

        if (isFill && step >= 8 && step % 2 === 0) {
            const tomNotes = ['G2', 'D2', 'A1', 'E1'];
            DRUMS.tom.triggerAttackRelease(tomNotes[Math.floor((step-8)/2) % 4], '16n', t, 0.5 + Math.random() * 0.3);
        }
        if (isFill) S.fillCountdown--;

        // Walking bass — only when user is active
        if (userActive && BASS && tierIdx >= 4 && step % 4 === 0) {
            const beatIdx = step / 4;
            const bassPat = BASS_PATTERNS[S.bassPatIdx % BASS_PATTERNS.length];
            const bassNote = chord[0] + S.transpose + bassPat[beatIdx % bassPat.length] - 24;
            BASS.triggerAttackRelease(noteFreq(bassNote), '4n', t, 0.45 + e * 0.35);
        }

        // Arp — only during sustained touch
        if (SENSE.touch.pressActive && ARP && tierIdx >= 5) {
            const arpRate = tierIdx >= 7 ? 1 : 2;
            if (step % arpRate === 0) {
                const patArr = ARP_PATTERNS[S.arpPattern] || ARP_PATTERNS.up;
                const spread = [];
                chord.forEach(n => { spread.push(n); spread.push(n + 12); });
                spread.sort((a, b) => a - b);
                const idx = patArr[S.arpStep % patArr.length] % spread.length;
                const octShift = Math.floor((1 - SENSE.touch.raw.y) * 2) * 12;
                const arpNote = spread[idx] + S.transpose + octShift;
                const accent = (S.arpStep % patArr.length === 0) ? 0.4 : 0.25;
                ARP.triggerAttackRelease(noteFreq(arpNote), arpRate === 1 ? '16n' : '8n', t, accent);
                S.arpStep++;
            }
        }

        const sw = step % 2 === 0 ? 1 + SWING : 1 - SWING;
        S.nextStepTime += stepDur * sw;
        S.grooveStep = (step + 1) % 16;
    }
}

function startGroove() {
    if (S.groovePlaying) return;
    S.groovePlaying = true;
    S.nextStepTime = Tone.now() + 0.05;
    S.grooveStep = 0;
    notify('GROOVE');
}

function stopGroove() { S.groovePlaying = false; }

function triggerFill() {
    S.fillCountdown = 16;
    DRUMS.crash.triggerAttackRelease('2n', Tone.now(), 0.3);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BASS + ARP SYNTHS (unchanged)
// ═══════════════════════════════════════════════════════════════════════════════

function createBass() {
    BASS = new Tone.FMSynth({
        harmonicity: 1, modulationIndex: 0.5,
        oscillator: { type: 'triangle' },
        modulation: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.12 },
        modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.1 },
        volume: -10
    }).connect(FX.bassBus);
}

function createArp() {
    ARP = new Tone.PolySynth(Tone.FMSynth);
    ARP.maxPolyphony = 4;
    ARP.set({
        modulationIndex: 2.5, harmonicity: 3,
        oscillator: { type: 'sine' },
        modulation: { type: 'triangle' },
        envelope: { attack: 0.005, decay: 0.12, sustain: 0.04, release: 0.25 },
        modulationEnvelope: { attack: 0.01, decay: 0.08, sustain: 0.15, release: 0.15 },
        volume: -16
    });
    ARP.connect(FX.arpBus);
}

// ═══════════════════════════════════════════════════════════════════════════════
// MELODY (unchanged)
// ═══════════════════════════════════════════════════════════════════════════════

function createMelody() {
    MELODY = new Tone.PolySynth(Tone.FMSynth);
    MELODY.maxPolyphony = 8;
    MELODY.set({
        modulationIndex: 3, harmonicity: 2,
        oscillator: { type: 'sine' },
        modulation: { type: 'triangle' },
        envelope: { attack: 0.06, decay: 0.35, sustain: 0.12, release: 0.7 },
        modulationEnvelope: { attack: 0.08, decay: 0.2, sustain: 0.3, release: 0.4 },
        volume: -10
    });
    MELODY.connect(FX.melodySend);
}

function playNote(x, y, vel) {
    if (!MELODY) return;
    const scale = SCALES[S.activeScale] || SCALES.minor;
    const tr = S.transpose;
    const notes = [];
    for (let oct = -1; oct <= 2; oct++) {
        scale.forEach(s => notes.push(s + tr + oct * 12));
    }
    notes.sort((a, b) => a - b);

    const idx = Math.floor((1 - y) * notes.length);
    const note = notes[Math.max(0, Math.min(idx, notes.length - 1))];
    MELODY.triggerAttackRelease(noteFreq(note), 0.25 + vel * 0.2, Tone.now(), Math.min(1, vel * 0.8));
    S.particles.push({ x: x * window.innerWidth, y: y * window.innerHeight, birth: performance.now(), vel });
}

function triggerPhrase(type) {
    if (!MELODY) return;
    const chord = getChord();
    const base = chord[0] + S.transpose;
    const now = Tone.now();

    if (type === 'SHAKE') {
        for (let i = 0; i < 8; i++) {
            const semi = i % 2 === 0 ? base : base + 3;
            MELODY.triggerAttackRelease(noteFreq(semi + (i < 4 ? 0 : 12)), 0.05, now + i * 0.06, 0.5);
        }
        notify('TRILL');
    } else if (type === 'SWIPE_UP') {
        chord.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose + 12), 0.2, now + i * 0.1, 0.6 - i * 0.1);
        });
        MELODY.triggerAttackRelease(noteFreq(chord[0] + S.transpose + 24), 0.3, now + chord.length * 0.1, 0.4);
        advanceChord();
        notify('RISE');
    } else if (type === 'SWIPE_DOWN') {
        const rev = [...chord].reverse();
        rev.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose + 12), 0.2, now + i * 0.1, 0.6 - i * 0.1);
        });
        MELODY.triggerAttackRelease(noteFreq(chord[0] + S.transpose - 12), 0.4, now + rev.length * 0.1, 0.4);
        advanceChord();
        notify('FALL');
    } else if (type === 'HOLD') {
        chord.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose), 2.5, now + i * 0.04, 0.3);
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose + 12), 2.5, now + i * 0.04 + 0.02, 0.2);
        });
        advanceChord();
        notify('SWELL');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SECTIONS (unchanged)
// ═══════════════════════════════════════════════════════════════════════════════

function updateSection(dt) {
    const e = S.energy;
    const idx = S.sectionIndex;

    if (S.section.name === 'SUMMIT' && e < 0.35) {
        S.sectionHoldTimer += dt;
        if (S.sectionHoldTimer > 20) changeSection(4);
    } else if (S.section.name === 'DESCEND' && e < 0.1) {
        S.sectionHoldTimer += dt;
        if (S.sectionHoldTimer > 15) changeSection(0);
    } else if (idx < 3) {
        const next = SECTIONS[idx + 1];
        if (e >= next.threshold) {
            S.sectionHoldTimer += dt;
            if (S.sectionHoldTimer > next.holdTime) changeSection(idx + 1);
        } else {
            S.sectionHoldTimer = Math.max(0, S.sectionHoldTimer - dt * 3);
        }
    } else {
        S.sectionHoldTimer = Math.max(0, S.sectionHoldTimer - dt);
    }
}

function changeSection(idx) {
    if (idx === S.sectionIndex) return;
    S.sectionIndex = idx;
    S.section = SECTIONS[idx];
    S.sectionHoldTimer = 0;
    S.transpose = S.section.tr;
    S.chordIndex = 0;

    if (!SENSE.env.scaleMod) S.activeScale = S.section.scale;

    S.bpm = Math.round(S.baseBpm * S.section.tempoMul + SENSE.env.tempoMod);
    FX.delay.delayTime.rampTo(60 / S.bpm / 2, 2);

    if (S.groovePlaying) triggerFill();
    glideChord(getChord(), 1.2);

    const arpKeys = Object.keys(ARP_PATTERNS);
    S.arpPattern = arpKeys[idx % arpKeys.length];
    S.bassPatIdx = idx;
    S.arpStep = 0;

    notify(S.section.name);
    document.getElementById('sectionName').textContent = S.section.name;
}

// ═══════════════════════════════════════════════════════════════════════════════
// TIER + CHORD (unchanged)
// ═══════════════════════════════════════════════════════════════════════════════

function updateTier() {
    let newTier = TIERS[0];
    for (const t of TIERS) {
        if (S.energy >= t.e) newTier = t;
    }
    if (newTier.name !== S.tier.name) {
        const prevIdx = TIERS.indexOf(S.tier);
        const newIdx = TIERS.indexOf(newTier);
        S.prevTier = S.tier;
        S.tier = newTier;
        document.getElementById('stageName').textContent = newTier.name;
        if (newTier.name !== 'SILENCE') notify(newTier.name);

        if (newTier.drums && !S.groovePlaying) startGroove();
        if (!newTier.drums && S.groovePlaying) stopGroove();

        if (newIdx > prevIdx && S.groovePlaying && newIdx >= 5) triggerFill();
        if (newIdx - prevIdx >= 2 && newIdx >= 4) {
            DRUMS.crash.triggerAttackRelease('2n', Tone.now(), 0.25);
        }
    }
}

function advanceChord() {
    S.chordIndex++;
    glideChord(getChord());
    if (S.chordIndex % 4 === 0) {
        S.bassPatIdx = (S.bassPatIdx + 1) % BASS_PATTERNS.length;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SENSORY MODULE: MOTION RECEPTOR + COMPUTE
// G7 Flywheel pattern: buffer → pattern classification → energy signal
// ═══════════════════════════════════════════════════════════════════════════════

function onMotionData(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const m = SENSE.motion;
    m.prev.x = m.raw.x; m.prev.y = m.raw.y; m.prev.z = m.raw.z;
    m.raw.x = a.x || 0;
    m.raw.y = a.y || 0;
    m.raw.z = a.z || 0;

    // Mark as actually receiving data
    m.receiving = true;
    m.lastDataTime = performance.now();

    // Compute deviation from gravity (G7 pattern)
    const dx = Math.abs(m.raw.x - m.prev.x);
    const dy = Math.abs(m.raw.y - m.prev.y);
    const dz = Math.abs(m.raw.z - m.prev.z);
    m.deviation = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;

    // Speed: smoothed, normalized
    m.speed = m.speed * 0.8 + Math.min(1, m.deviation * 0.4) * 0.2;

    // Direction from velocity integration (G7)
    m.direction.x += m.raw.x * 0.01;
    m.direction.y += m.raw.y * 0.01;
    // Decay direction
    m.direction.x *= 0.95;
    m.direction.y *= 0.95;
}

function computeMotion(dt) {
    const m = SENSE.motion;

    // Push to history buffer (G7's 150-sample flywheel)
    m.buffer.push(m.deviation);
    if (m.buffer.length > 150) m.buffer.shift();

    // Accumulate total motion (flywheel never resets)
    m.totalAccumulated += m.deviation * dt;

    // Running statistics from buffer
    if (m.buffer.length >= 10) {
        let sum = 0, sqSum = 0;
        for (let i = 0; i < m.buffer.length; i++) {
            sum += m.buffer[i];
            sqSum += m.buffer[i] * m.buffer[i];
        }
        m.avgMotion = sum / m.buffer.length;
        m.variance = (sqSum / m.buffer.length) - (m.avgMotion * m.avgMotion);

        // Pattern classification (G7)
        if (m.avgMotion < 0.3) m.pattern = 'still';
        else if (m.avgMotion < 0.8 && m.variance < 0.5) m.pattern = 'gentle';
        else if (m.variance < 1.5 && m.avgMotion >= 0.8) m.pattern = 'rhythmic';
        else if (m.avgMotion > 1.5 && m.variance < 3) m.pattern = 'vigorous';
        else if (m.variance >= 3) m.pattern = 'chaotic';
    }

    // Smooth speed for audio modulation
    m.smoothSpeed = m.smoothSpeed * 0.92 + m.speed * 0.08;

    // Energy signal: speed drives energy contribution
    m.energyContrib = m.speed > 0.02 ? m.speed * 0.008 : 0;
}

// ═══════════════════════════════════════════════════════════════════════════════
// SENSORY MODULE: ORIENTATION RECEPTOR + COMPUTE
// ═══════════════════════════════════════════════════════════════════════════════

function onOrientationData(e) {
    const o = SENSE.orientation;

    if (e.gamma !== null || e.beta !== null) {
        o.raw.alpha = e.alpha || 0;
        o.raw.beta = e.beta || 45;
        o.raw.gamma = e.gamma || 0;

        // Mark as receiving
        o.receiving = true;
    }
}

function computeOrientation() {
    const o = SENSE.orientation;

    // Normalize tilt values (same as before)
    o.tiltX = Math.max(-1, Math.min(1, o.raw.gamma / 45));
    o.tiltY = Math.max(-1, Math.min(1, (o.raw.beta - 45) / 45));

    // Derived signals
    o.brightness = (o.tiltY + 1) * 0.5;   // 0=dark, 1=bright
    o.stereoField = o.tiltX;               // -1=left, 1=right
}

// ═══════════════════════════════════════════════════════════════════════════════
// SENSORY MODULE: TOUCH RECEPTOR + COMPUTE
// ═══════════════════════════════════════════════════════════════════════════════

function computeTouch(dt) {
    const t = SENSE.touch;

    // Gesture detection from buffer
    if (t.gestureCooldown > 0) { t.gestureCooldown--; return; }
    if (t.buffer.length < 10) return;

    let totalSpeed = 0, dirChanges = 0, netX = 0, netY = 0;
    for (let i = 1; i < t.buffer.length; i++) {
        const dx = t.buffer[i].x - t.buffer[i-1].x;
        const dy = t.buffer[i].y - t.buffer[i-1].y;
        totalSpeed += Math.sqrt(dx*dx + dy*dy);
        netX += dx; netY += dy;
        if (i > 1) {
            const pdx = t.buffer[i-1].x - t.buffer[i-2].x;
            const pdy = t.buffer[i-1].y - t.buffer[i-2].y;
            if (dx * pdx < 0 || dy * pdy < 0) dirChanges++;
        }
    }
    const avg = totalSpeed / t.buffer.length;

    t.gestureType = null;
    if (avg > 0.03 && dirChanges >= 4) {
        t.gestureType = 'SHAKE'; t.gestureCooldown = 30;
    } else if (avg > 0.02 && Math.abs(netY) > 0.2) {
        t.gestureType = netY < 0 ? 'SWIPE_UP' : 'SWIPE_DOWN'; t.gestureCooldown = 20;
    } else if (avg < 0.003 && S.stillness > 80 && S.energy > 0.1) {
        t.gestureType = 'HOLD'; t.gestureCooldown = 150;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SENSORY MODULE: BREATH COMPUTE (reads from motion.raw.z)
// ═══════════════════════════════════════════════════════════════════════════════

function computeBreath() {
    const b = SENSE.breath;
    const z = SENSE.motion.raw.z;
    const now = performance.now();

    // Only active if motion sensor is receiving
    if (!SENSE.motion.receiving) return;

    b.azSmooth = b.azSmooth * 0.82 + z * 0.18;
    b.azHist.push({ z: b.azSmooth, t: now });
    if (b.azHist.length > 300) b.azHist = b.azHist.slice(-200);
    if (b.azHist.length < 30) return;

    const win = b.azHist.slice(-80);
    const vals = win.map(h => h.z);
    const lo = Math.min(...vals), hi = Math.max(...vals);
    const range = hi - lo, mid = (lo + hi) / 2;
    b.depth = Math.min(1, range * 2.5);

    if (range < 0.08) { b.phase = 'none'; b.active = false; return; }
    b.active = true;

    const tail = b.azHist.slice(-12);
    let trend = 0;
    for (let i = 1; i < tail.length; i++) trend += tail[i].z - tail[i - 1].z;
    trend /= tail.length;

    if (b.phase === 'none' || b.phase === 'valley') {
        if (trend > 0.004 && b.azSmooth > lo + range * 0.25) {
            b.phase = 'inhale';
            b.breathStart = now;
        }
    } else if (b.phase === 'inhale') {
        b.progress = Math.min(1, (now - b.breathStart) / (b.breathDur * 0.4));
        if (trend < 0.001 && b.azSmooth > mid + range * 0.2) {
            b.phase = 'peak';
            b.lastPeakTime = now;
        }
    } else if (b.phase === 'peak') {
        if (trend < -0.003) b.phase = 'exhale';
    } else if (b.phase === 'exhale') {
        b.progress = Math.min(1, (now - b.lastPeakTime) / (b.breathDur * 0.5));
        if (b.azSmooth < mid - range * 0.15 && trend > -0.002) {
            b.phase = 'valley';
            const dur = now - b.breathStart;
            if (dur > 1500 && dur < 12000) {
                b.breathDurs.push(dur);
                if (b.breathDurs.length > 8) b.breathDurs.shift();
                b.breathDur = b.breathDurs.reduce((a, c) => a + c) / b.breathDurs.length;
            }
            b.energyContrib = 0.02 + b.depth * 0.03;
            if (b.depth > 0.3) advanceChord();
            S.rings.push({ birth: performance.now(), depth: b.depth });
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SENSOR PERMISSION SYSTEM (Radiohead + G7 pattern)
// Critical: permissions must be requested IN a user gesture handler
// Critical: requestPermission() must be called BEFORE e.preventDefault()
// ═══════════════════════════════════════════════════════════════════════════════

let permissionRequested = false;

async function requestSensorPermissions() {
    if (permissionRequested) return;
    permissionRequested = true;

    const m = SENSE.motion;
    const o = SENSE.orientation;

    // ── DeviceMotion (accelerometer) ──
    if (typeof DeviceMotionEvent !== 'undefined') {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            // iOS 13+ — needs user gesture
            try {
                const result = await DeviceMotionEvent.requestPermission();
                if (result === 'granted') {
                    m.permitted = true;
                    m.listening = true;
                    m.requestTime = performance.now();
                    window.addEventListener('devicemotion', onMotionData);
                } else {
                    notify('MOTION DENIED');
                    m.permitted = false;
                }
            } catch(e) {
                notify('MOTION FAILED');
                m.permitted = false;
                permissionRequested = false; // allow retry
            }
        } else {
            // Android / desktop — no permission needed
            m.permitted = true;
            m.listening = true;
            m.requestTime = performance.now();
            window.addEventListener('devicemotion', onMotionData);
        }
    }

    // ── DeviceOrientation (gyroscope/tilt) ──
    if (typeof DeviceOrientationEvent !== 'undefined') {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            // iOS 13+ — on iOS, motion+orientation share the same permission
            try {
                const result = await DeviceOrientationEvent.requestPermission();
                if (result === 'granted') {
                    o.permitted = true;
                    o.listening = true;
                    window.addEventListener('deviceorientation', onOrientationData);
                    notify('TILT ON');
                } else {
                    notify('TILT DENIED');
                    o.permitted = false;
                }
            } catch(e) {
                o.permitted = false;
                permissionRequested = false; // allow retry
            }
        } else {
            // Android / desktop — no permission needed
            o.permitted = true;
            o.listening = true;
            window.addEventListener('deviceorientation', onOrientationData);
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// TOUCH SYSTEM (Radiohead pattern: permission BEFORE preventDefault)
// ═══════════════════════════════════════════════════════════════════════════════

function setupTouch() {
    // ── Touch handlers ──
    document.addEventListener('touchstart', async function(e) {
        // CRITICAL: Request sensor permissions FIRST, BEFORE preventDefault
        // On iOS, calling preventDefault first can invalidate the gesture context
        // needed for DeviceMotionEvent.requestPermission()
        if (!permissionRequested) {
            await requestSensorPermissions();
        }

        // Resume AudioContext if suspended (safety net)
        if (Tone.context.state !== 'running') {
            Tone.context.resume();
        }

        e.preventDefault();

        const t = e.touches[0];
        const x = t.clientX / window.innerWidth;
        const y = t.clientY / window.innerHeight;
        touchDown(x, y);
    }, { passive: false });

    document.addEventListener('touchmove', function(e) {
        e.preventDefault();
        const t = e.touches[0];
        const x = t.clientX / window.innerWidth;
        const y = t.clientY / window.innerHeight;
        touchMove(x, y);
    }, { passive: false });

    document.addEventListener('touchend', function(e) {
        e.preventDefault();
        SENSE.touch.pressing = false;
        SENSE.touch.pressActive = false;
    }, { passive: false });

    // ── Mouse handlers (desktop fallback) ──
    document.addEventListener('mousedown', function(e) {
        const x = e.clientX / window.innerWidth;
        const y = e.clientY / window.innerHeight;
        touchDown(x, y);
    });
    document.addEventListener('mousemove', function(e) {
        const x = e.clientX / window.innerWidth;
        const y = e.clientY / window.innerHeight;
        touchMove(x, y);
    });
    document.addEventListener('mouseup', function() {
        SENSE.touch.pressing = false;
        SENSE.touch.pressActive = false;
    });
}

function touchDown(x, y) {
    const t = SENSE.touch;
    t.pressing = true;
    t.pressActive = true;
    t.active = true;
    t.raw.x = x;
    t.raw.y = y;
    t.prevX = x;
    t.prevY = y;

    // Touch provides tilt fallback when orientation isn't available
    if (!SENSE.orientation.receiving) {
        SENSE.orientation.tiltX = (x - 0.5) * 2;
        SENSE.orientation.tiltY = (y - 0.5) * 2;
        SENSE.orientation.brightness = y; // top=0(dark), bottom=1(bright)
    }

    playNote(x, y, 0.65);
    t.energyContrib = 0.008;
}

function touchMove(x, y) {
    const t = SENSE.touch;
    if (!t.pressing) return;

    const dist = Math.sqrt((x - t.prevX)**2 + (y - t.prevY)**2);
    if (dist > 0.015) {
        playNote(x, y, 0.3 + Math.min(1, dist * 4));
        t.energyContrib = dist * 0.08;
        t.velocity = t.velocity * 0.7 + dist * 5 * 0.3;

        // Feed touch speed into motion speed (when no accelerometer)
        if (!SENSE.motion.receiving) {
            SENSE.motion.speed = SENSE.motion.speed * 0.7 + dist * 5 * 0.3;
        }
    }

    t.raw.x = x;
    t.raw.y = y;
    t.prevX = x;
    t.prevY = y;

    // Touch fallback for tilt
    if (!SENSE.orientation.receiving) {
        SENSE.orientation.tiltX = (x - 0.5) * 2;
        SENSE.orientation.tiltY = (y - 0.5) * 2;
        SENSE.orientation.brightness = y;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT
// ═══════════════════════════════════════════════════════════════════════════════

function fetchWeather() {
    if (!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(async (pos) => {
        try {
            const { latitude, longitude } = pos.coords;
            const resp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,weathercode`);
            const data = await resp.json();
            const temp = data.current.temperature_2m;
            const code = data.current.weathercode;

            if (temp < 10) { SENSE.env.tempoMod = -10; S.baseBpm = 75; }
            else if (temp < 25) { SENSE.env.tempoMod = 0; S.baseBpm = 85; }
            else { SENSE.env.tempoMod = 10; S.baseBpm = 95; }

            S.bpm = Math.round(S.baseBpm * S.section.tempoMul + SENSE.env.tempoMod);
            FX.delay.delayTime.rampTo(60 / S.bpm / 2, 1);

            if (code >= 51 && code <= 67) { SENSE.env.reverbMod = 0.35; SENSE.env.scaleMod = 'minor'; }
            else if (code >= 71 && code <= 77) { SENSE.env.reverbMod = 0.4; SENSE.env.scaleMod = 'dorian'; }
            else if (code >= 95) { SENSE.env.scaleMod = 'phrygian'; SENSE.env.reverbMod = 0.3; }
            else if (code >= 45 && code <= 48) { SENSE.env.reverbMod = 0.38; SENSE.env.scaleMod = 'dorian'; }
            else { SENSE.env.scaleMod = null; }

            if (SENSE.env.scaleMod) S.activeScale = SENSE.env.scaleMod;
            FX.reverb.wet.rampTo(SENSE.env.reverbMod, 2);
            SENSE.env.active = true;

            const cond = code === 0 ? 'clear' : code <= 3 ? 'cloudy' :
                code <= 48 ? 'fog' : code <= 67 ? 'rain' : code <= 77 ? 'snow' : 'storm';
            document.getElementById('weatherInfo').textContent = `${Math.round(temp)}° ${cond}`;
        } catch(e) {}
    }, () => {}, { timeout: 5000 });
}

async function initMicrophone() {
    if (SENSE.mic.active) return;
    try {
        MIC = new Tone.UserMedia();
        await MIC.open();
        const analyser = new Tone.Analyser('fft', 256);
        MIC.connect(analyser);
        SENSE.mic.active = true;
        document.getElementById('micBtn').classList.add('on');
        notify('MIC ON');

        setInterval(() => {
            if (!SENSE.mic.active) return;
            const sp = analyser.getValue();
            let sum = 0, wSum = 0, tPow = 0;
            for (let i = 0; i < sp.length; i++) {
                const p = Math.pow(10, sp[i] / 20);
                sum += p; wSum += p * i; tPow += p;
            }
            SENSE.mic.amplitude = Math.min(1, sum / sp.length * 10);
            SENSE.mic.centroid = tPow > 0 ? (wSum / tPow) / sp.length : 0;
        }, 100);
    } catch(e) {
        notify('MIC DENIED');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// CONDUCTOR — Synthesizes all sensory modules into musical decisions
// This is the "brain" that reads from all local memories
// ═══════════════════════════════════════════════════════════════════════════════

function conduct(dt) {
    const m = SENSE.motion;
    const o = SENSE.orientation;
    const t = SENSE.touch;
    const b = SENSE.breath;
    const mic = SENSE.mic;
    const e = S.energy;

    // ── BRIGHTNESS: orientation (primary) → touch fallback ──
    const brightness = o.receiving ? o.brightness : (t.pressing ? t.raw.y : 0.5);
    const tiltX = o.receiving ? o.tiltX : (t.pressing ? (t.raw.x - 0.5) * 2 : 0);
    const tiltY = o.receiving ? o.tiltY : (t.pressing ? (t.raw.y - 0.5) * 2 : 0);

    // ── DUST FILTER — tilt Y = master expression ──
    const dustFreq = 2000 + brightness * 10000 * (0.3 + e * 0.7);
    FX.dust.frequency.rampTo(Math.min(14000, dustFreq), 0.08);

    // ── VOICE SHAPING ──
    const now = performance.now();
    const breathe1 = Math.sin(now * 0.0008) * 0.5 + 0.5;
    const breathe2 = Math.sin(now * 0.0012 + 1.2) * 0.5 + 0.5;
    const breathe3 = Math.sin(now * 0.0005 + 2.4) * 0.5 + 0.5;

    const layers = [
        { name: 'lead',    minV: 1, vol: 0.13, bCut: 500,  mCut: 4500, mod: breathe1 * 0.1 },
        { name: 'sub',     minV: 2, vol: 0.14, bCut: 200,  mCut: 600,  mod: 0 },
        { name: 'pad',     minV: 3, vol: 0.07, bCut: 400,  mCut: 3000, mod: breathe2 * 0.12 },
        { name: 'strings', minV: 4, vol: 0.05, bCut: 600,  mCut: 5000, mod: breathe3 * 0.1 },
        { name: 'brass',   minV: 5, vol: 0.04, bCut: 400,  mCut: 3000, mod: breathe1 * 0.06 },
        { name: 'choir',   minV: 6, vol: 0.03, bCut: 1000, mCut: 7000, mod: breathe2 * 0.06 },
    ];

    const tier = S.tier;
    layers.forEach(({ name, minV, vol, bCut, mCut, mod }) => {
        const layer = V[name];
        if (!layer) return;

        let amp, cutoff;
        if (tier.voices < minV) {
            amp = 0;
            cutoff = bCut;
        } else {
            const headroom = Math.min(1, (e - (tier.e || 0)) * 4);
            amp = (vol + mod) * headroom;
            cutoff = bCut + (mCut - bCut) * brightness * headroom;

            // Breath modulation
            if (b.phase === 'inhale') {
                amp *= 0.3 + b.progress * 0.7;
                cutoff *= 0.5 + b.progress * 0.5;
            } else if (b.phase === 'exhale') {
                const ease = 1 - b.progress * b.progress;
                amp *= Math.max(0.2, ease);
                cutoff *= Math.max(0.3, ease);
            }
        }

        // Mic modulation
        if (mic.active && mic.centroid > 0.1) cutoff += mic.centroid * 800;

        cutoff = Math.max(150, Math.min(9000, cutoff));
        layer.gain.gain.rampTo(amp, 0.15);
        layer.filter.frequency.rampTo(cutoff, 0.15);
    });

    // Lead expression: tiltX = pitch bend, speed = FM depth
    if (V.lead && V.lead.oscs[0]) {
        const vibrato = Math.sin(now * 0.028) * (2 + e * 10);
        V.lead.oscs[0].detune.rampTo(tiltX * 40 + vibrato, 0.05);
    }

    // Motion speed modulates FM modulation index (G7 pattern)
    const spd = m.receiving ? m.smoothSpeed : t.velocity;
    if (V.lead && V.lead.oscs[0].modulationIndex) {
        const targetMod = 1.2 + spd * 8;
        try { V.lead.oscs[0].modulationIndex.rampTo(targetMod, 0.2); } catch(ex) {}
    }

    // Pad detuning widens with energy
    if (V.pad) {
        V.pad.oscs.forEach((osc, i) => {
            if (i > 0) osc.detune.rampTo((i - 1) * 10 + e * 8, 0.3);
        });
    }

    // Effects follow energy + section
    const revWet = SENSE.env.reverbMod + e * 0.08 + (S.sectionIndex >= 3 ? 0.05 : 0);
    FX.reverb.wet.rampTo(Math.min(0.4, revWet), 0.3);
    FX.delay.wet.rampTo(0.05 + S.sectionIndex * 0.02 + e * 0.03, 0.3);
    FX.chorus.depth = 0.2 + brightness * 0.3;

    // ── PROCESS GESTURES ──
    if (t.gestureType) {
        triggerPhrase(t.gestureType);
        t.gestureType = null;
    }

    // ── PROCESS BREATH ──
    if (b.energyContrib > 0) {
        S.energy = Math.min(1, S.energy + b.energyContrib);
        b.energyContrib = 0;
    }

    // ── TIER / SECTION / GROOVE ──
    updateTier();
    updateSection(dt);
    if (S.groovePlaying) runGroove();

    S.peakEnergy = Math.max(S.peakEnergy, S.energy);
}

// ═══════════════════════════════════════════════════════════════════════════════
// VISUALIZATION (reads from SENSE modules)
// ═══════════════════════════════════════════════════════════════════════════════

let canvas, vc;

function initCanvas() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    onResize();
    window.addEventListener('resize', onResize);
}

function onResize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth, h = window.innerHeight;
    const now = performance.now();
    const o = SENSE.orientation;
    const tiltX = o.receiving ? o.tiltX : (SENSE.touch.pressing ? (SENSE.touch.raw.x - 0.5) * 2 : 0);
    const tiltY = o.receiving ? o.tiltY : (SENSE.touch.pressing ? (SENSE.touch.raw.y - 0.5) * 2 : 0);
    const cx = w / 2 + tiltX * w * 0.2;
    const cy = h / 2 + tiltY * h * 0.2;
    const e = S.energy;
    const tierIdx = TIERS.indexOf(S.tier);
    const pal = PALETTES[S.section.name] || PALETTES.DRIFT;
    const hue = pal.h + tierIdx * 6;

    vc.fillStyle = `rgba(5, 5, 5, ${0.08 + (1 - e) * 0.05})`;
    vc.fillRect(0, 0, w, h);

    if (e > 0.15) {
        const bg = vc.createRadialGradient(cx, cy, 0, cx, cy, Math.min(w, h) * 0.6);
        bg.addColorStop(0, `hsla(${hue}, ${pal.s}%, ${pal.l * 0.3}%, ${e * 0.02})`);
        bg.addColorStop(1, 'transparent');
        vc.fillStyle = bg;
        vc.fillRect(0, 0, w, h);
    }

    // Breath rings
    for (let i = S.rings.length - 1; i >= 0; i--) {
        const ring = S.rings[i];
        const age = (now - ring.birth) / 1000;
        if (age > 20) { S.rings.splice(i, 1); continue; }
        const r = 30 + age * 18;
        const alpha = Math.max(0, 0.15 - age * 0.008) * ring.depth;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue}, ${pal.s}%, ${pal.l + 10}%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    }

    // Energy rings
    const numRings = Math.min(6, S.tier.voices);
    for (let i = 0; i < numRings; i++) {
        const r = 50 + i * 40 + Math.sin(now * 0.001 + i) * 5 + e * 25;
        const alpha = 0.05 + e * 0.15;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue + i * 20}, ${pal.s + e * 20}%, ${pal.l + e * 10}%, ${alpha})`;
        vc.lineWidth = 1.5 + e;
        vc.stroke();
    }

    // Core orb
    const smoothSpd = SENSE.motion.smoothSpeed;
    const coreR = 15 + e * 25 + smoothSpd * 25;
    const grad = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    grad.addColorStop(0, `hsla(${hue}, ${pal.s + 20}%, ${pal.l + 15}%, ${0.5 + e * 0.5})`);
    grad.addColorStop(0.5, `hsla(${hue}, ${pal.s}%, ${pal.l}%, ${0.2 + e * 0.25})`);
    grad.addColorStop(1, 'transparent');
    vc.fillStyle = grad;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, TAU);
    vc.fill();

    // Voice orbit dots
    for (let i = 0; i < numRings; i++) {
        const angle = (i / Math.max(1, numRings)) * TAU + now * 0.0005;
        const dist = 50 + i * 40;
        vc.beginPath();
        vc.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 2 + e, 0, TAU);
        vc.fillStyle = `hsla(${hue + i * 20}, ${pal.s + 10}%, ${pal.l + 15}%, ${0.1 + e * 0.2})`;
        vc.fill();
    }

    // Touch particles
    for (let i = S.particles.length - 1; i >= 0; i--) {
        const p = S.particles[i];
        const age = (now - p.birth) / 1000;
        if (age > 1.5) { S.particles.splice(i, 1); continue; }
        const alpha = Math.max(0, 0.6 - age * 0.4) * p.vel;
        vc.beginPath();
        vc.arc(p.x, p.y, 3 + age * 20, 0, TAU);
        vc.strokeStyle = `hsla(${hue + 40}, ${pal.s + 15}%, ${pal.l + 15}%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    }

    // Speed trail
    if (smoothSpd > 0.05) {
        const len = smoothSpd * 100;
        vc.beginPath();
        vc.moveTo(cx, cy);
        vc.lineTo(cx - tiltX * len, cy - tiltY * len);
        vc.strokeStyle = `hsla(${hue}, ${pal.s}%, ${pal.l + 10}%, ${smoothSpd * 0.4})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Edge glow at high tiers
    if (tierIdx >= 6) {
        const glow = vc.createRadialGradient(w/2, h/2, Math.min(w,h)*0.25, w/2, h/2, Math.min(w,h)*0.65);
        glow.addColorStop(0, 'transparent');
        glow.addColorStop(1, `hsla(${hue + 30}, ${pal.s + 10}%, ${pal.l}%, ${(e - 0.6) * 0.1})`);
        vc.fillStyle = glow;
        vc.fillRect(0, 0, w, h);
    }

    document.getElementById('energyFill').style.width = (e * 100) + '%';
}

// ═══════════════════════════════════════════════════════════════════════════════
// SENSOR STATUS — shows what's actually working
// ═══════════════════════════════════════════════════════════════════════════════

let statusTimer = 0;
function updateSensorStatus() {
    statusTimer++;
    if (statusTimer % 60 !== 0) return; // Update once per second

    const parts = [];
    const m = SENSE.motion;
    const o = SENSE.orientation;
    const mic = SENSE.mic;

    if (m.receiving) parts.push('<span class="on">MOT</span>');
    else if (m.listening) parts.push('MOT?');

    if (o.receiving) parts.push('<span class="on">TILT</span>');
    else if (o.listening) parts.push('TILT?');

    if (mic.active) parts.push('<span class="on">MIC</span>');

    if (SENSE.breath.active) parts.push('<span class="on">BRE</span>');

    // Show motion pattern if receiving
    if (m.receiving && m.pattern !== 'still') {
        parts.push(m.pattern.toUpperCase());
    }

    document.getElementById('sensorStatus').innerHTML = parts.join(' · ');

    // Check for sensors that were requested but never received data (timeout)
    const now = performance.now();
    if (m.listening && !m.receiving && m.requestTime > 0 && now - m.requestTime > 5000) {
        // 5 seconds with no data — sensors aren't working
        if (!m._warned) {
            notify('NO MOTION DATA');
            m._warned = true;
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN LOOP — Neuromorphic pipeline: register → compute → conduct → render
// ═══════════════════════════════════════════════════════════════════════════════

let lastFrame = 0;

function loop(ts) {
    if (!S.active) { requestAnimationFrame(loop); return; }

    const dt = Math.min(50, ts - lastFrame) / 1000;
    lastFrame = ts;

    // ── PHASE 1: COMPUTE — each module processes its local memory ──
    computeMotion(dt);
    computeOrientation();
    computeTouch(dt);
    computeBreath();

    // ── PHASE 2: ENERGY SYNTHESIS — combine all sensory signals ──
    const m = SENSE.motion;
    const t = SENSE.touch;

    const motionActive = m.speed > 0.02;
    const touchActive = t.pressing;
    const anyActive = motionActive || touchActive;

    if (anyActive) {
        S.stillness = 0;
        // Motion energy (from accelerometer OR touch-derived)
        if (motionActive) {
            S.energy = Math.min(1, S.energy + m.energyContrib);
        }
        // Touch energy
        if (touchActive) {
            S.energy = Math.min(1, S.energy + dt * 0.012 + t.energyContrib);
            t.energyContrib = 0; // consumed
        }
    } else {
        // Slow decay: 0.997 per frame ≈ 40 seconds from 1.0 to 0.1
        S.energy *= 0.997;
        S.stillness += dt * 10;
    }

    // Gesture buffer (reads from whichever tilt source is active)
    const tiltX = SENSE.orientation.receiving ? SENSE.orientation.tiltX :
                  (t.pressing ? (t.raw.x - 0.5) * 2 : 0);
    const tiltY = SENSE.orientation.receiving ? SENSE.orientation.tiltY :
                  (t.pressing ? (t.raw.y - 0.5) * 2 : 0);
    t.buffer.push({ x: tiltX, y: tiltY, speed: m.speed, time: performance.now() });
    if (t.buffer.length > 30) t.buffer.shift();

    // ── PHASE 3: CONDUCT — synthesize into musical decisions ──
    conduct(dt);

    // ── PHASE 4: RENDER ──
    draw();
    updateSensorStatus();

    requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════════════════════════════════════
// NOTIFICATIONS
// ═══════════════════════════════════════════════════════════════════════════════

let notifTimer = null;
function notify(text) {
    const el = document.getElementById('notif');
    el.textContent = text;
    el.classList.add('show');
    if (notifTimer) clearTimeout(notifTimer);
    notifTimer = setTimeout(() => el.classList.remove('show'), 1800);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BEGIN — Proper startup sequence
// ═══════════════════════════════════════════════════════════════════════════════

async function begin() {
    try {
        // 1. AudioContext FIRST — needs the user gesture context
        await Tone.start();

        // 2. Request sensor permissions IMMEDIATELY after Tone.start
        //    Still within the user gesture context from the click
        await requestSensorPermissions();

        // 3. Init audio engine
        await initAudio();

        // 4. Setup canvas and input
        initCanvas();
        setupTouch();

        document.getElementById('entry').classList.add('gone');
        document.getElementById('sectionName').textContent = 'DRIFT';

        setTimeout(() => { document.getElementById('micBtn').style.display = 'block'; }, 3000);
        fetchWeather();

        S.active = true;
        lastFrame = performance.now();
        requestAnimationFrame(loop);
    } catch(e) {
        console.error('Start failed:', e);
        document.getElementById('err').textContent = 'Error: ' + e.message;
        document.getElementById('err').style.display = 'flex';
    }
}

// Event listeners
document.getElementById('micBtn').addEventListener('click', (e) => { e.stopPropagation(); initMicrophone(); });
document.getElementById('begin').addEventListener('click', begin);
document.getElementById('begin').addEventListener('touchstart', (e) => { e.preventDefault(); begin(); }, { passive: false });
document.addEventListener('contextmenu', (e) => e.preventDefault());

})();
</script>
</body>
</html>
