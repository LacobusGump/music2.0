<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GUMP</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"
            onerror="document.getElementById('err').style.display='flex'"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        html,body{width:100%;height:100%;background:#020204;overflow:hidden;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,sans-serif}
        #entry{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
        #entry.gone{display:none}
        #entry p{font-size:11px;color:rgba(255,255,255,.25);text-align:center;line-height:2.4;max-width:260px;margin-bottom:50px}
        #entry button{width:90px;height:90px;border-radius:50%;background:0;border:1px solid rgba(255,255,255,.08);color:rgba(255,255,255,.2);font-size:9px;letter-spacing:3px;cursor:pointer;transition:.6s}
        #entry button:hover{border-color:rgba(255,255,255,.2)}
        #entry .sub{margin-top:40px;font-size:8px;color:rgba(255,255,255,.08);letter-spacing:1px}
        canvas{position:fixed;inset:0}
        .hud{position:fixed;pointer-events:none;font-size:9px;letter-spacing:2px;color:rgba(255,255,255,.12);z-index:5}
        #breathCount{bottom:24px;right:24px}
        #phaseName{top:50%;left:50%;transform:translate(-50%,-50%);font-size:12px;letter-spacing:5px;color:rgba(255,255,255,.18);transition:opacity .5s}
        #journeyName{top:24px;left:24px}
        #weatherInfo{top:24px;right:24px;font-size:8px;color:rgba(255,255,255,.06)}
        #micBtn{position:fixed;bottom:24px;left:24px;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,.1);background:0;color:rgba(255,255,255,.15);font-size:8px;letter-spacing:1px;cursor:pointer;z-index:10;display:none}
        #micBtn.on{border-color:rgba(200,100,100,.3);color:rgba(200,100,100,.3)}
        #err{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000;color:rgba(255,255,255,.3);font-size:11px;text-align:center;z-index:999;flex-direction:column}
    </style>
</head>
<body>
<div id="entry">
    <p>
        lie down<br>
        phone on your chest<br>
        close your eyes<br><br>
        breathe
    </p>
    <button id="begin">BEGIN</button>
    <div class="sub">or touch to play</div>
</div>
<canvas id="c"></canvas>
<div class="hud" id="breathCount"></div>
<div class="hud" id="phaseName"></div>
<div class="hud" id="journeyName"></div>
<div class="hud" id="weatherInfo"></div>
<button id="micBtn">MIC</button>
<div id="err">Failed to load audio engine.<br>Check connection and reload.</div>

<script>
(function() {
'use strict';

// ═══════════════════════════════════════════════════════════════════════════════
// CONSTANTS
// ═══════════════════════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;
const A = 432; // A=432Hz tuning

// Chord progression: Am - F - C - G - Am - Cm - Fm - Gm (semitones from A)
const CHORDS = [
    [0, 3, 7],      // Am  (home)
    [5, 9, 12],     // F   (warmth)
    [0, 4, 7],      // C   (hope - major third)
    [7, 11, 14],    // G   (reaching)
    [0, 3, 7],      // Am  (return)
    [3, 7, 10],     // Cm  (shadow)
    [5, 8, 12],     // Fm  (ache)
    [7, 10, 14],    // Gm  (tension)
];

// Journey phases - breath count unlocks layers
const PHASES = [
    { name: 'SOLITUDE',    start: 0,  voices: 1, drums: false },
    { name: 'AWAKENING',   start: 5,  voices: 2, drums: false },
    { name: 'UNFOLDING',   start: 11, voices: 3, drums: false },
    { name: 'SWELLING',    start: 19, voices: 4, drums: true  },
    { name: 'FULLNESS',    start: 29, voices: 5, drums: true  },
    { name: 'RADIANCE',    start: 41, voices: 6, drums: true  },
    { name: 'LETTING GO',  start: 53, voices: 4, drums: true  },
    { name: 'RETURN',      start: 63, voices: 2, drums: false },
    { name: 'SILENCE',     start: 71, voices: 0, drums: false },
];

// Purdie shuffle pattern (16 steps)
const KICK   = [1,0,0,0, 0,0,.5,0, .8,0,0,0, 0,0,0,0];
const SNARE  = [0,0,0,0, 1,0,.15,.2, 0,0,.15,0, 1,0,.2,.15];
const HATS   = [.7,.25,.5,.25, .7,.3,.5,.3, .7,.25,.5,.25, .7,.3,.5,.3];
const SWING  = 0.18;

// Scales for weather-driven melody
const SCALES = {
    minor:      [0, 2, 3, 5, 7, 8, 10],
    major:      [0, 2, 4, 5, 7, 9, 11],
    dorian:     [0, 2, 3, 5, 7, 9, 10],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    phrygian:   [0, 1, 3, 5, 7, 8, 10],
};

function noteFreq(semitones) {
    return A * Math.pow(2, semitones / 12);
}

// ═══════════════════════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════════════════════

const S = {
    active: false,

    // Breath detection
    az: 0,
    azSmooth: 0,
    azHist: [],
    breathPhase: 'waiting',  // waiting | inhale | peak | exhale | valley
    breathStart: 0,
    breathDur: 4000,
    breathDurs: [],
    breathCount: 0,
    breathProgress: 0,
    breathDepth: 0,
    lastPeakTime: 0,
    hasSensors: false,

    // Orientation
    tiltX: 0,
    tiltY: 0,
    beta: 0,
    gamma: 0,

    // Touch
    touching: false,
    touchX: 0.5,
    touchY: 0.5,

    // Derived perception
    speed: 0,
    energy: 0,
    stillness: 0,
    motionHist: [],

    // Gesture
    gestureBuffer: [],
    gestureCooldown: 0,

    // Journey
    journey: PHASES[0],
    chordIndex: 0,

    // Drums
    drumStep: 0,
    nextDrumTime: 0,
    drumsActive: false,

    // Environment
    weatherScale: 'minor',
    weatherTempo: 85,
    weatherReverb: 0.25,
    micActive: false,
    micLevel: 0,
    micCentroid: 0,
    ambientLight: -1,

    // Visualization
    rings: [],
    breathRadius: 50,
};

// Audio references
let FX = {};   // Effects chain
let V = {};    // Voice layers
let DRUMS = {};
let MELODY = null;
let MIC = null;

// ═══════════════════════════════════════════════════════════════════════════════
// AUDIO INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

async function initAudio() {
    // Effects chain: voices → chorus → warmth → saturation → dust → reverb → comp → master
    const master = new Tone.Gain(0.65).toDestination();
    const comp = new Tone.Compressor({ threshold: -18, ratio: 4, attack: 0.003, release: 0.15 }).connect(master);

    const reverb = new Tone.Reverb({ decay: 3.5, wet: S.weatherReverb });
    reverb.connect(comp);
    try { await reverb.generate(); } catch(e) { console.warn('Reverb generation:', e); }

    const dust = new Tone.Filter({ frequency: 7000, type: 'lowpass' }).connect(reverb);
    const sat = new Tone.Distortion({ distortion: 0.12, wet: 0.15, oversample: '2x' }).connect(dust);
    const warmth = new Tone.EQ3({ low: 4, mid: 0, high: -2 }).connect(sat);
    const chorus = new Tone.Chorus({ frequency: 1.5, delayTime: 3.5, depth: 0.4, wet: 0.3 }).connect(warmth);
    chorus.start();

    // Sidechain bus — all voices route through here, kick ducks it
    const sidechain = new Tone.Gain(1).connect(chorus);

    // Drum bus — bypasses chorus (drums don't need width), goes to warmth
    const drumBus = new Tone.Gain(0).connect(warmth);

    FX = { master, comp, reverb, dust, sat, warmth, chorus, sidechain, drumBus };

    // Create voices
    createVoices();

    // Create drums
    createDrums();

    // Create melody synth
    MELODY = new Tone.PolySynth(Tone.FMSynth);
    MELODY.maxPolyphony = 8;
    MELODY.set({
        modulationIndex: 3,
        harmonicity: 2,
        oscillator: { type: 'sine' },
        modulation: { type: 'triangle' },
        envelope: { attack: 0.08, decay: 0.4, sustain: 0.15, release: 0.8 },
        modulationEnvelope: { attack: 0.1, decay: 0.3, sustain: 0.3, release: 0.5 },
        volume: -12
    });
    MELODY.connect(FX.sidechain);
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICE LAYERS — FM/AM/Fat oscillators for rich, warm tones
// ═══════════════════════════════════════════════════════════════════════════════

function createLayer(oscConfigs, filterFreq) {
    const filter = new Tone.Filter({ frequency: filterFreq, type: 'lowpass', rolloff: -12 });
    const gain = new Tone.Gain(0);
    filter.connect(gain);
    gain.connect(FX.sidechain);

    const oscs = oscConfigs.map(cfg => {
        let osc;
        if (cfg.type === 'fm') {
            osc = new Tone.FMOscillator({
                frequency: cfg.freq,
                type: cfg.carrier || 'sine',
                modulationType: cfg.modType || 'sine',
                modulationIndex: cfg.modIndex || 2,
                harmonicity: cfg.harmonicity || 1.5
            });
        } else if (cfg.type === 'fat') {
            osc = new Tone.FatOscillator({
                frequency: cfg.freq,
                type: cfg.waveform || 'sawtooth',
                count: cfg.count || 3,
                spread: cfg.spread || 20
            });
        } else if (cfg.type === 'am') {
            osc = new Tone.AMOscillator({
                frequency: cfg.freq,
                type: 'sine',
                modulationType: 'sine',
                harmonicity: cfg.harmonicity || 2
            });
        }
        if (cfg.detune) osc.detune.value = cfg.detune;
        osc.connect(filter);
        osc.start();
        return osc;
    });

    return { oscs, filter, gain };
}

function createVoices() {
    const chord = CHORDS[0];

    // Lead — pure FM tone, intimate, "your voice"
    V.lead = createLayer([
        { type: 'fm', freq: noteFreq(chord[0]), modIndex: 0.8, harmonicity: 1.5 }
    ], 500);

    // Sub bass — deep foundation, subtle FM warmth
    V.sub = createLayer([
        { type: 'fm', freq: noteFreq(chord[0] - 24), modIndex: 0.3, harmonicity: 1 }
    ], 250);

    // Pad — warm FM triad, mid register, slightly detuned
    V.pad = createLayer(chord.map((note, i) => ({
        type: 'fm', freq: noteFreq(note - 12), carrier: 'triangle',
        modIndex: 1.5, harmonicity: 2, detune: (i - 1) * 8
    })), 900);

    // Strings — fat detuned sawtooths, upper register
    V.strings = createLayer(chord.map(note => ({
        type: 'fat', freq: noteFreq(note + 12), waveform: 'sawtooth', count: 3, spread: 20
    })), 2000);

    // Brass — aggressive FM, filtered
    V.brass = createLayer([
        { type: 'fm', freq: noteFreq(chord[0] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 5, harmonicity: 3 },
        { type: 'fm', freq: noteFreq(chord[2] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 5, harmonicity: 3 }
    ], 900);

    // Choir — AM oscillators for shimmer, high register
    V.choir = createLayer(chord.map(note => ({
        type: 'am', freq: noteFreq(note + 24), harmonicity: 2.5
    })), 6000);
}

function updateChordFreqs(chord) {
    const gl = 0.5; // half-second portamento between chords
    V.lead.oscs[0].frequency.rampTo(noteFreq(chord[0]), gl);
    V.sub.oscs[0].frequency.rampTo(noteFreq(chord[0] - 24), gl);
    chord.forEach((note, i) => {
        if (V.pad.oscs[i]) V.pad.oscs[i].frequency.rampTo(noteFreq(note - 12), gl);
        if (V.strings.oscs[i]) V.strings.oscs[i].frequency.rampTo(noteFreq(note + 12), gl);
        if (V.choir.oscs[i]) V.choir.oscs[i].frequency.rampTo(noteFreq(note + 24), gl);
    });
    if (V.brass.oscs[0]) V.brass.oscs[0].frequency.rampTo(noteFreq(chord[0] + 12), gl);
    if (V.brass.oscs[1]) V.brass.oscs[1].frequency.rampTo(noteFreq(chord[2] + 12), gl);
}

// ═══════════════════════════════════════════════════════════════════════════════
// DRUM ENGINE — Purdie shuffle with Tone.js synths
// ═══════════════════════════════════════════════════════════════════════════════

function createDrums() {
    DRUMS.kick = new Tone.MembraneSynth({
        pitchDecay: 0.05,
        octaves: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.4, sustain: 0, release: 0.4 },
        volume: -6
    }).connect(FX.drumBus);

    DRUMS.snareBody = new Tone.MembraneSynth({
        pitchDecay: 0.008,
        octaves: 3,
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.04 },
        volume: -10
    }).connect(FX.drumBus);

    const snareFilter = new Tone.Filter({ frequency: 3000, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.snareNoise = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.12, sustain: 0, release: 0.03 },
        volume: -8
    }).connect(snareFilter);

    DRUMS.hat = new Tone.MetalSynth({
        frequency: 400,
        envelope: { attack: 0.001, decay: 0.04, release: 0.01 },
        harmonicity: 5.1,
        modulationIndex: 32,
        resonance: 5000,
        octaves: 1.5,
        volume: -18
    }).connect(FX.drumBus);
}

function scheduleDrums() {
    if (!S.journey.drums || S.breathPhase === 'valley' || S.breathPhase === 'waiting') return;

    const breathSec = S.breathDur / 1000;
    const stepBase = breathSec / 16;
    const lookAhead = 0.08;
    const intensity = 0.5 + S.breathDepth * 0.5;
    const humanize = 0.005;

    while (S.nextDrumTime < Tone.now() + lookAhead) {
        const step = S.drumStep;
        const jitter = (Math.random() - 0.5) * humanize;
        const t = S.nextDrumTime + jitter;

        if (KICK[step]) {
            DRUMS.kick.triggerAttackRelease('C1', '8n', t, KICK[step] * intensity);
            triggerSidechain(t);
        }
        if (SNARE[step]) {
            DRUMS.snareBody.triggerAttackRelease('D3', '16n', t, SNARE[step] * intensity);
            DRUMS.snareNoise.triggerAttackRelease('16n', t, SNARE[step] * intensity);
        }
        if (HATS[step]) {
            DRUMS.hat.triggerAttackRelease('32n', t, HATS[step] * intensity * 0.5);
        }

        const swing = step % 2 === 0 ? 1 + SWING : 1 - SWING;
        S.nextDrumTime += stepBase * swing;
        S.drumStep = (step + 1) % 16;
    }
}

function triggerSidechain(time) {
    const g = FX.sidechain.gain;
    g.cancelScheduledValues(time);
    g.setValueAtTime(1, time);
    g.linearRampToValueAtTime(0.3, time + 0.012);
    g.linearRampToValueAtTime(1, time + 0.12);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BREATH DETECTION — Z-axis accelerometer state machine
// ═══════════════════════════════════════════════════════════════════════════════

function detectBreath() {
    if (!S.hasSensors) {
        // Desktop fallback: energy-based progression
        if (S.touching) {
            S.energy = Math.min(1, S.energy + 0.003);
        } else {
            S.energy *= 0.998;
        }
        updateJourneyByEnergy();
        shapeVoicesByEnergy();
        return;
    }

    const z = S.az;
    const now = performance.now();

    S.azSmooth = S.azSmooth * 0.82 + z * 0.18;
    S.azHist.push({ z: S.azSmooth, t: now });
    if (S.azHist.length > 300) S.azHist = S.azHist.slice(-200);
    if (S.azHist.length < 30) return;

    // Range in recent window
    const win = S.azHist.slice(-80);
    const vals = win.map(h => h.z);
    const lo = Math.min(...vals);
    const hi = Math.max(...vals);
    const range = hi - lo;
    const mid = (lo + hi) / 2;
    S.breathDepth = Math.min(1, range * 2.5);

    if (range < 0.06) return;

    // Trend (derivative)
    const tail = S.azHist.slice(-12);
    let trend = 0;
    for (let i = 1; i < tail.length; i++) trend += tail[i].z - tail[i - 1].z;
    trend /= tail.length;

    // State machine
    if (S.breathPhase === 'waiting' || S.breathPhase === 'valley') {
        if (trend > 0.004 && S.azSmooth > lo + range * 0.25) {
            S.breathPhase = 'inhale';
            S.breathStart = now;
            onInhaleStart();
        }
    } else if (S.breathPhase === 'inhale') {
        S.breathProgress = Math.min(1, (now - S.breathStart) / (S.breathDur * 0.4));
        if (trend < 0.001 && S.azSmooth > mid + range * 0.2) {
            S.breathPhase = 'peak';
            S.lastPeakTime = now;
        }
    } else if (S.breathPhase === 'peak') {
        if (trend < -0.003) {
            S.breathPhase = 'exhale';
        }
    } else if (S.breathPhase === 'exhale') {
        S.breathProgress = Math.min(1, (now - S.lastPeakTime) / (S.breathDur * 0.5));
        if (S.azSmooth < mid - range * 0.15 && trend > -0.002) {
            S.breathPhase = 'valley';
            onBreathComplete(now);
        }
    }

    shapeVoices();
    if (S.drumsActive) scheduleDrums();
}

// ═══════════════════════════════════════════════════════════════════════════════
// BREATH EVENTS
// ═══════════════════════════════════════════════════════════════════════════════

function onInhaleStart() {
    if (S.journey.drums) {
        S.drumsActive = true;
        S.drumStep = 0;
        S.nextDrumTime = Tone.now() + 0.05;
        FX.drumBus.gain.rampTo(0.7, 0.1);
    }
}

function onBreathComplete(now) {
    S.breathCount++;
    S.chordIndex++;
    S.breathProgress = 0;

    // Learn breath duration
    const dur = now - S.breathStart;
    if (dur > 1500 && dur < 12000) {
        S.breathDurs.push(dur);
        if (S.breathDurs.length > 8) S.breathDurs.shift();
        S.breathDur = S.breathDurs.reduce((a, b) => a + b) / S.breathDurs.length;
    }

    // Fade drums during valley
    if (S.drumsActive) {
        FX.drumBus.gain.rampTo(0, 0.3);
        S.drumsActive = false;
    }

    // Update chord (smooth portamento)
    const newChord = CHORDS[S.chordIndex % CHORDS.length];
    updateChordFreqs(newChord);

    // Update journey phase
    let newPhase = PHASES[0];
    for (const p of PHASES) {
        if (S.breathCount >= p.start) newPhase = p;
    }
    if (newPhase.name !== S.journey.name) {
        S.journey = newPhase;
        document.getElementById('journeyName').textContent = newPhase.name;
        // Evolve reverb with journey
        const reverbWet = newPhase.voices >= 5 ? 0.35 : newPhase.voices >= 3 ? 0.28 : 0.2;
        FX.reverb.wet.rampTo(reverbWet, 1);
    }

    // Visual ring
    S.rings.push({ birth: performance.now(), depth: S.breathDepth });
    if (S.rings.length > 40) S.rings.shift();

    document.getElementById('breathCount').textContent = S.breathCount;
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICE SHAPING — Breath envelope controls all layers
// ═══════════════════════════════════════════════════════════════════════════════

function shapeVoices() {
    const phase = S.breathPhase;
    const prog = S.breathProgress;
    const jPhase = S.journey;

    // Target volumes per layer based on journey phase
    const targets = {
        lead:    jPhase.voices >= 1 ? 0.14 : 0,
        sub:     jPhase.voices >= 2 ? 0.18 : 0,
        pad:     jPhase.voices >= 3 ? 0.07 : 0,
        strings: jPhase.voices >= 4 ? 0.05 : 0,
        brass:   jPhase.voices >= 5 ? 0.04 : 0,
        choir:   jPhase.voices >= 6 ? 0.03 : 0,
    };

    // Tilt expression: orientation modulates brightness
    const brightness = S.tiltY * 0.5 + 0.5; // 0 to 1

    Object.entries(targets).forEach(([name, vol]) => {
        const layer = V[name];
        if (!layer) return;

        let amp = 0;
        let cutoff = 400;

        if (vol === 0) {
            amp = 0;
            cutoff = 300;
        } else if (phase === 'inhale') {
            // Build: amplitude and brightness rise
            amp = vol * (0.15 + prog * 0.85);
            cutoff = 400 + prog * 3500;
        } else if (phase === 'peak') {
            // Full expression
            amp = vol;
            cutoff = 4000;
        } else if (phase === 'exhale') {
            // Resolve: quadratic ease-out
            const ease = 1 - prog * prog;
            amp = vol * Math.max(0.05, ease);
            cutoff = 4000 - prog * 3200;
        } else {
            // Valley/waiting: quiet hum
            amp = vol * 0.04;
            cutoff = 350;
        }

        // Tilt opens filter
        cutoff *= (0.7 + brightness * 0.6);
        cutoff = Math.max(200, Math.min(8000, cutoff));

        // Mic influence: ambient sound opens resonance slightly
        if (S.micActive && S.micCentroid > 0) {
            cutoff += S.micCentroid * 500;
        }

        layer.gain.gain.rampTo(amp, 0.08);
        layer.filter.frequency.rampTo(cutoff, 0.08);
    });

    // Pitch bend on lead: tension on inhale, resolve on exhale
    if (V.lead && V.lead.oscs[0]) {
        let detune = 0;
        if (phase === 'inhale') detune = prog * 20;
        else if (phase === 'exhale') detune = 20 * (1 - prog);
        V.lead.oscs[0].detune.rampTo(detune, 0.1);
    }
}

// Desktop fallback: energy drives voices instead of breath
function shapeVoicesByEnergy() {
    const e = S.energy;
    // Map energy to journey-like progression
    const brightness = S.tiltY * 0.5 + 0.5;

    const layers = [
        { name: 'lead',    threshold: 0,    vol: 0.14 },
        { name: 'sub',     threshold: 0.05, vol: 0.18 },
        { name: 'pad',     threshold: 0.15, vol: 0.07 },
        { name: 'strings', threshold: 0.30, vol: 0.05 },
        { name: 'brass',   threshold: 0.50, vol: 0.04 },
        { name: 'choir',   threshold: 0.70, vol: 0.03 },
    ];

    layers.forEach(({ name, threshold, vol }) => {
        const layer = V[name];
        if (!layer) return;
        const amp = e >= threshold ? vol * Math.min(1, (e - threshold) * 4) : 0;
        const cutoff = 400 + e * 4000 * (0.7 + brightness * 0.6);
        layer.gain.gain.rampTo(amp, 0.15);
        layer.filter.frequency.rampTo(Math.max(200, Math.min(8000, cutoff)), 0.15);
    });

    // Start groove at energy > 0.3
    if (e > 0.3 && !S.drumsActive) {
        S.drumsActive = true;
        S.drumStep = 0;
        S.nextDrumTime = Tone.now() + 0.05;
        FX.drumBus.gain.rampTo(0.7, 0.3);
        S.journey = PHASES.find(p => p.drums) || S.journey;
    }
    if (e < 0.1 && S.drumsActive) {
        S.drumsActive = false;
        FX.drumBus.gain.rampTo(0, 0.5);
    }
    if (S.drumsActive) scheduleDrums();
}

function updateJourneyByEnergy() {
    const e = S.energy;
    let best = PHASES[0];
    const thresholds = [0, 0.05, 0.15, 0.30, 0.50, 0.70, 0.90, 0.95, 1.1];
    for (let i = 0; i < PHASES.length; i++) {
        if (e >= (thresholds[i] || 0)) best = PHASES[i];
    }
    if (best.name !== S.journey.name) {
        S.journey = best;
        document.getElementById('journeyName').textContent = best.name;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// GESTURE DETECTION — Touch triggers musical phrases
// ═══════════════════════════════════════════════════════════════════════════════

function detectGesture() {
    if (S.gestureCooldown > 0) { S.gestureCooldown--; return; }
    const buf = S.gestureBuffer;
    if (buf.length < 10) return;

    let totalSpeed = 0, dirChanges = 0, netX = 0, netY = 0;
    for (let i = 1; i < buf.length; i++) {
        const dx = buf[i].x - buf[i-1].x;
        const dy = buf[i].y - buf[i-1].y;
        totalSpeed += Math.sqrt(dx*dx + dy*dy);
        netX += dx; netY += dy;
        if (i > 1) {
            const pdx = buf[i-1].x - buf[i-2].x;
            const pdy = buf[i-1].y - buf[i-2].y;
            if (dx * pdx < 0 || dy * pdy < 0) dirChanges++;
        }
    }
    const avg = totalSpeed / buf.length;

    if (avg > 0.03 && dirChanges >= 4) {
        triggerPhrase('SHAKE'); S.gestureCooldown = 30;
    } else if (avg > 0.02 && Math.abs(netY) > 0.2) {
        triggerPhrase(netY < 0 ? 'SWIPE_UP' : 'SWIPE_DOWN'); S.gestureCooldown = 20;
    } else if (avg < 0.005 && S.stillness > 60) {
        triggerPhrase('HOLD'); S.gestureCooldown = 120;
    }
}

function triggerPhrase(type) {
    if (!MELODY) return;
    const scale = SCALES[S.weatherScale] || SCALES.minor;
    const chord = CHORDS[S.chordIndex % CHORDS.length];
    const baseNote = chord[0];
    const baseFreq = noteFreq(baseNote);
    const now = Tone.now();

    if (type === 'SHAKE') {
        for (let i = 0; i < 6; i++) {
            const f = baseFreq * (i % 2 === 0 ? 1 : Math.pow(2, scale[2]/12));
            MELODY.triggerAttackRelease(f, 0.06, now + i * 0.08, 0.5);
        }
    } else if (type === 'SWIPE_UP') {
        for (let i = 0; i < 4; i++) {
            const note = scale[Math.min(i * 2, scale.length - 1)];
            MELODY.triggerAttackRelease(noteFreq(baseNote + note), 0.15, now + i * 0.12, 0.55 - i * 0.08);
        }
    } else if (type === 'SWIPE_DOWN') {
        for (let i = 0; i < 4; i++) {
            const note = scale[Math.min(i * 2, scale.length - 1)];
            MELODY.triggerAttackRelease(noteFreq(baseNote + 12 - note), 0.15, now + i * 0.12, 0.55 - i * 0.08);
        }
    } else if (type === 'HOLD') {
        chord.forEach((semitone, i) => {
            MELODY.triggerAttackRelease(noteFreq(semitone + 12), 2.0, now + i * 0.05, 0.3);
        });
    }
}

function playTouchNote(x, y, vel) {
    if (!MELODY) return;
    const scale = SCALES[S.weatherScale] || SCALES.minor;
    const octave = 1 + Math.floor(x * 3);
    const idx = Math.floor((1 - y) * scale.length);
    const note = scale[Math.max(0, Math.min(idx, scale.length - 1))];
    const freq = noteFreq(note + octave * 12);
    MELODY.triggerAttackRelease(freq, 0.25, Tone.now(), Math.min(1, vel));
}

// ═══════════════════════════════════════════════════════════════════════════════
// INPUT HANDLERS — Sensors, touch, mouse
// ═══════════════════════════════════════════════════════════════════════════════

async function requestSensors() {
    let granted = false;
    // Motion (accelerometer)
    if (typeof DeviceMotionEvent !== 'undefined') {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            try {
                const r = await DeviceMotionEvent.requestPermission();
                if (r === 'granted') {
                    window.addEventListener('devicemotion', onMotion);
                    granted = true;
                }
            } catch(e) {}
        } else {
            window.addEventListener('devicemotion', onMotion);
            granted = true;
        }
    }
    // Orientation
    if (typeof DeviceOrientationEvent !== 'undefined') {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const r = await DeviceOrientationEvent.requestPermission();
                if (r === 'granted') window.addEventListener('deviceorientation', onOrientation);
            } catch(e) {}
        } else {
            window.addEventListener('deviceorientation', onOrientation);
        }
    }
    S.hasSensors = granted;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (a) {
        S.az = a.z || 0;
        const motion = Math.sqrt((a.x||0)**2 + (a.y||0)**2 + (a.z||0)**2) / 10;
        S.speed = S.speed * 0.8 + Math.min(1, motion * 0.5) * 0.2;
    }
}

function onOrientation(e) {
    S.beta = e.beta || 0;
    S.gamma = e.gamma || 0;
    S.tiltX = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    S.tiltY = Math.max(-1, Math.min(1, ((e.beta || 45) - 45) / 45));
}

function setupTouch() {
    document.addEventListener('touchstart', (e) => {
        e.preventDefault();
        S.touching = true;
        const t = e.touches[0];
        S.touchX = t.clientX / window.innerWidth;
        S.touchY = t.clientY / window.innerHeight;
        if (!S.hasSensors) {
            S.tiltX = (S.touchX - 0.5) * 2;
            S.tiltY = (S.touchY - 0.5) * 2;
        }
        playTouchNote(S.touchX, S.touchY, 0.6);
        S.energy = Math.min(1, S.energy + 0.04);
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
        if (!S.touching) return;
        const t = e.touches[0];
        const nx = t.clientX / window.innerWidth;
        const ny = t.clientY / window.innerHeight;
        const dist = Math.sqrt((nx-S.touchX)**2 + (ny-S.touchY)**2);
        if (dist > 0.015) {
            playTouchNote(nx, ny, 0.3 + dist * 3);
            S.energy = Math.min(1, S.energy + dist * 0.5);
        }
        S.touchX = nx; S.touchY = ny;
        if (!S.hasSensors) {
            S.tiltX = (nx - 0.5) * 2;
            S.tiltY = (ny - 0.5) * 2;
        }
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
        e.preventDefault();
        S.touching = false;
    }, { passive: false });

    // Mouse fallback
    document.addEventListener('mousedown', (e) => {
        S.touching = true;
        S.touchX = e.clientX / window.innerWidth;
        S.touchY = e.clientY / window.innerHeight;
        S.tiltX = (S.touchX - 0.5) * 2;
        S.tiltY = (S.touchY - 0.5) * 2;
        playTouchNote(S.touchX, S.touchY, 0.6);
        S.energy = Math.min(1, S.energy + 0.04);
    });
    document.addEventListener('mousemove', (e) => {
        if (!S.touching) return;
        const nx = e.clientX / window.innerWidth;
        const ny = e.clientY / window.innerHeight;
        const dist = Math.sqrt((nx-S.touchX)**2 + (ny-S.touchY)**2);
        if (dist > 0.01) {
            playTouchNote(nx, ny, 0.3 + dist * 3);
            S.energy = Math.min(1, S.energy + dist * 0.5);
        }
        S.touchX = nx; S.touchY = ny;
        S.tiltX = (nx - 0.5) * 2;
        S.tiltY = (ny - 0.5) * 2;
        S.speed = S.speed * 0.7 + dist * 10 * 0.3;
    });
    document.addEventListener('mouseup', () => { S.touching = false; });

    // Gesture buffer
    setInterval(() => {
        S.gestureBuffer.push({ x: S.tiltX, y: S.tiltY, speed: S.speed, time: performance.now() });
        if (S.gestureBuffer.length > 30) S.gestureBuffer.shift();
        detectGesture();
    }, 50);

    // Stillness counter
    setInterval(() => {
        if (S.speed < 0.02) S.stillness++;
        else S.stillness = 0;
    }, 100);
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT — Microphone, weather, ambient light
// ═══════════════════════════════════════════════════════════════════════════════

async function initMicrophone() {
    if (S.micActive) return;
    try {
        MIC = new Tone.UserMedia();
        await MIC.open();
        const analyser = new Tone.Analyser('fft', 256);
        MIC.connect(analyser);
        S.micActive = true;
        document.getElementById('micBtn').classList.add('on');

        // Periodically read mic spectrum
        setInterval(() => {
            if (!S.micActive) return;
            const spectrum = analyser.getValue();
            // Calculate amplitude
            let sum = 0, weightedSum = 0, totalPower = 0;
            for (let i = 0; i < spectrum.length; i++) {
                const power = Math.pow(10, spectrum[i] / 20);
                sum += power;
                weightedSum += power * i;
                totalPower += power;
            }
            S.micLevel = Math.min(1, sum / spectrum.length * 10);
            S.micCentroid = totalPower > 0 ? (weightedSum / totalPower) / spectrum.length : 0;

            // Mic level influences reverb wetness
            const targetWet = S.weatherReverb + S.micLevel * 0.15;
            FX.reverb.wet.rampTo(Math.min(0.5, targetWet), 0.5);
        }, 100);
    } catch(e) {
        console.log('Mic access denied');
    }
}

function fetchWeather() {
    if (!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(async (pos) => {
        try {
            const { latitude, longitude } = pos.coords;
            const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,weathercode`;
            const resp = await fetch(url);
            const data = await resp.json();
            const temp = data.current.temperature_2m;
            const code = data.current.weathercode;

            // Temperature -> tempo and scale
            if (temp < 10) {
                S.weatherScale = 'minor';
                S.weatherTempo = 75;
            } else if (temp < 25) {
                S.weatherScale = 'mixolydian';
                S.weatherTempo = 85;
            } else {
                S.weatherScale = 'major';
                S.weatherTempo = 95;
            }

            // Weather code -> reverb and character
            if (code >= 51 && code <= 82) {
                // Rain/drizzle: more reverb, softer
                S.weatherReverb = 0.35;
                S.weatherScale = 'minor';
            } else if (code >= 71 && code <= 77) {
                // Snow: ethereal
                S.weatherReverb = 0.4;
                S.weatherScale = 'dorian';
            } else if (code >= 95) {
                // Thunderstorm: dramatic
                S.weatherScale = 'phrygian';
                S.weatherReverb = 0.3;
            } else if (code >= 45 && code <= 48) {
                // Fog: mysterious
                S.weatherReverb = 0.38;
                S.weatherScale = 'dorian';
            } else if (code === 0) {
                // Clear
                S.weatherReverb = 0.22;
            }

            FX.reverb.wet.rampTo(S.weatherReverb, 2);

            const conditions = code === 0 ? 'clear' : code <= 3 ? 'cloudy' :
                code <= 48 ? 'fog' : code <= 67 ? 'rain' : code <= 77 ? 'snow' : 'storm';
            document.getElementById('weatherInfo').textContent = `${Math.round(temp)}° ${conditions}`;
        } catch(e) {
            console.log('Weather fetch failed:', e);
        }
    }, () => {}, { timeout: 5000 });
}

function initAmbientLight() {
    try {
        if ('AmbientLightSensor' in window) {
            const sensor = new AmbientLightSensor();
            sensor.addEventListener('reading', () => {
                S.ambientLight = Math.min(1, sensor.illuminance / 500);
            });
            sensor.start();
        }
    } catch(e) {}
}

// ═══════════════════════════════════════════════════════════════════════════════
// VISUALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

let canvas, vc;

function initCanvas() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    onResize();
    window.addEventListener('resize', onResize);
}

function onResize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const now = performance.now();
    const cx = w / 2;
    const cy = h / 2;

    // Slow trail fade
    vc.fillStyle = 'rgba(2, 2, 4, 0.06)';
    vc.fillRect(0, 0, w, h);

    // Journey phase color
    const phaseIdx = PHASES.indexOf(S.journey);
    const hue = 200 + phaseIdx * 15; // Cool blue → warm gold at radiance
    const sat = S.journey.voices >= 5 ? 40 : 20;

    // Completed breath rings
    S.rings.forEach(ring => {
        const age = (now - ring.birth) / 1000;
        if (age > 25) return;
        const r = 40 + age * 15;
        const alpha = Math.max(0, 0.12 - age * 0.005) * ring.depth;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue}, ${sat}%, 60%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    });

    // Current breath circle
    let targetR = 40;
    if (S.breathPhase === 'inhale') targetR = 40 + S.breathProgress * 80;
    else if (S.breathPhase === 'peak') targetR = 120 + Math.sin(now * 0.008) * 5;
    else if (S.breathPhase === 'exhale') targetR = 120 - S.breathProgress * 80;

    // Desktop: energy-based radius
    if (!S.hasSensors) targetR = 40 + S.energy * 100;

    S.breathRadius += (targetR - S.breathRadius) * 0.08;

    const bAlpha = (S.breathPhase === 'valley' || S.breathPhase === 'waiting') && S.hasSensors
        ? 0.04 : 0.12 + S.breathDepth * 0.15;
    vc.beginPath();
    vc.arc(cx, cy, S.breathRadius, 0, TAU);
    vc.strokeStyle = `hsla(${hue}, ${sat}%, 65%, ${bAlpha})`;
    vc.lineWidth = 1.5;
    vc.stroke();

    // Voice orbit dots
    const nv = S.journey.voices;
    for (let i = 0; i < nv; i++) {
        const angle = (i / Math.max(1, nv)) * TAU + now * 0.0005;
        const dist = S.breathRadius + 18;
        const vx = cx + Math.cos(angle) * dist;
        const vy = cy + Math.sin(angle) * dist;
        const dotAlpha = S.breathPhase === 'valley' ? 0.05 : 0.2;
        vc.beginPath();
        vc.arc(vx, vy, 2.5, 0, TAU);
        vc.fillStyle = `hsla(${hue + i * 20}, 50%, 70%, ${dotAlpha})`;
        vc.fill();
    }

    // Center dot (stillness indicator)
    const cAlpha = S.breathPhase === 'peak' ? 0.5 : 0.08 + S.stillness * 0.002;
    vc.beginPath();
    vc.arc(cx, cy, 3, 0, TAU);
    vc.fillStyle = `rgba(255,255,255,${Math.min(0.6, cAlpha)})`;
    vc.fill();

    // Phase indicator
    const phaseEl = document.getElementById('phaseName');
    if (S.hasSensors) {
        if (S.breathPhase === 'inhale') phaseEl.textContent = String.fromCharCode(8593); // up arrow
        else if (S.breathPhase === 'peak') phaseEl.textContent = String.fromCharCode(183); // dot
        else if (S.breathPhase === 'exhale') phaseEl.textContent = String.fromCharCode(8595); // down arrow
        else phaseEl.textContent = '';
    }

    // Radiance glow at peak journey
    if (S.journey.voices >= 5) {
        const glowIntensity = (S.journey.voices - 4) * 0.05;
        const grad = vc.createRadialGradient(cx, cy, S.breathRadius, cx, cy, Math.min(w, h) * 0.6);
        grad.addColorStop(0, `hsla(${hue}, ${sat + 20}%, 50%, ${glowIntensity})`);
        grad.addColorStop(1, 'transparent');
        vc.fillStyle = grad;
        vc.fillRect(0, 0, w, h);
    }

    // Mic level indicator
    if (S.micActive && S.micLevel > 0.01) {
        const micR = S.breathRadius + 30 + S.micLevel * 40;
        vc.beginPath();
        vc.arc(cx, cy, micR, 0, TAU);
        vc.strokeStyle = `rgba(200,120,120,${S.micLevel * 0.15})`;
        vc.lineWidth = 1;
        vc.stroke();
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════════

function loop() {
    if (!S.active) { requestAnimationFrame(loop); return; }
    detectBreath();
    draw();
    requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BOOTSTRAP
// ═══════════════════════════════════════════════════════════════════════════════

async function begin() {
    try {
        await Tone.start();
        await requestSensors();
        await initAudio();
        initCanvas();
        setupTouch();

        document.getElementById('entry').classList.add('gone');
        document.getElementById('journeyName').textContent = 'SOLITUDE';

        // Show mic button after 5 seconds
        setTimeout(() => {
            document.getElementById('micBtn').style.display = 'block';
        }, 5000);

        // Fetch weather (non-blocking)
        fetchWeather();

        // Try ambient light
        initAmbientLight();

        S.active = true;
        loop();
    } catch(e) {
        console.error('Start failed:', e);
        document.getElementById('err').style.display = 'flex';
        document.getElementById('err').textContent = 'Error: ' + e.message;
    }
}

// Mic button
document.getElementById('micBtn').addEventListener('click', (e) => {
    e.stopPropagation();
    initMicrophone();
});

// Start button
document.getElementById('begin').addEventListener('click', begin);
document.getElementById('begin').addEventListener('touchstart', (e) => {
    e.preventDefault();
    begin();
}, { passive: false });

// Prevent context menu
document.addEventListener('contextmenu', (e) => e.preventDefault());

})();
</script>
</body>
</html>
