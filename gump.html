<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GUMP</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"
            onerror="document.getElementById('err').style.display='flex'"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        html,body{width:100%;height:100%;background:#020204;overflow:hidden;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,sans-serif}
        #entry{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
        #entry.gone{display:none}
        #entry h1{font-size:10px;font-weight:300;letter-spacing:8px;color:rgba(255,255,255,.15);margin-bottom:40px}
        #entry p{font-size:11px;color:rgba(255,255,255,.25);text-align:center;line-height:2.4;max-width:260px;margin-bottom:50px}
        #entry button{width:90px;height:90px;border-radius:50%;background:0;border:1px solid rgba(255,255,255,.08);color:rgba(255,255,255,.2);font-size:9px;letter-spacing:3px;cursor:pointer;transition:.6s}
        #entry button:hover{border-color:rgba(255,255,255,.2)}
        canvas{position:fixed;inset:0}
        .hud{position:fixed;pointer-events:none;font-size:9px;letter-spacing:2px;color:rgba(255,255,255,.12);z-index:5}
        #stageName{top:24px;left:24px}
        #energyBar{bottom:0;left:0;right:0;height:2px;z-index:5}
        #energyFill{height:100%;width:0%;background:rgba(255,255,255,.2);transition:width .15s linear}
        #notif{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:11px;letter-spacing:5px;color:rgba(255,255,255,.5);opacity:0;transition:opacity .3s;pointer-events:none;z-index:10}
        #notif.show{opacity:1}
        #weatherInfo{top:24px;right:24px;font-size:8px;color:rgba(255,255,255,.06)}
        #micBtn{position:fixed;bottom:20px;left:20px;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,.08);background:0;color:rgba(255,255,255,.12);font-size:8px;cursor:pointer;z-index:10;display:none}
        #micBtn.on{border-color:rgba(200,100,100,.3);color:rgba(200,100,100,.3)}
        #err{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000;color:rgba(255,255,255,.3);font-size:11px;text-align:center;z-index:999;flex-direction:column}
    </style>
</head>
<body>
<div id="entry">
    <h1>GUMP</h1>
    <p>
        move to conduct<br>
        tilt for expression<br>
        touch to play<br>
        stillness to breathe
    </p>
    <button id="begin">AWAKEN</button>
</div>
<canvas id="c"></canvas>
<div class="hud" id="stageName"></div>
<div class="hud" id="weatherInfo"></div>
<div id="energyBar"><div id="energyFill"></div></div>
<div id="notif"></div>
<button id="micBtn">MIC</button>
<div id="err">Failed to load audio engine.<br>Check connection and reload.</div>

<script>
(function() {
'use strict';

const TAU = Math.PI * 2;
const A = 432;

// ═══════════════════════════════════════════════════════════════════════════════
// MUSICAL DNA
// ═══════════════════════════════════════════════════════════════════════════════

// Chord progression (semitones from A)
const CHORDS = [
    [0, 3, 7],      // Am
    [5, 9, 12],     // F
    [0, 4, 7],      // C (major third — hope)
    [7, 11, 14],    // G
    [0, 3, 7],      // Am
    [3, 7, 10],     // Cm
    [5, 8, 12],     // Fm
    [7, 10, 14],    // Gm
];

const SCALES = {
    minor:      [0, 2, 3, 5, 7, 8, 10],
    major:      [0, 2, 4, 5, 7, 9, 11],
    dorian:     [0, 2, 3, 5, 7, 9, 10],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    phrygian:   [0, 1, 3, 5, 7, 8, 10],
};

// Purdie shuffle
const K  = [1,0,0,0, 0,0,.5,0, .8,0,0,0, 0,0,0,0];
const SN = [0,0,0,0, 1,0,.15,.2, 0,0,.15,0, 1,0,.2,.15];
const HH = [.7,.25,.5,.25, .7,.3,.5,.3, .7,.25,.5,.25, .7,.3,.5,.3];
const SWING = 0.18;

// Tiers — energy unlocks layers
const TIERS = [
    { name: 'SILENCE',    e: 0,    voices: 0, drums: false },
    { name: 'AWAKENING',  e: 0.02, voices: 1, drums: false },
    { name: 'PULSE',      e: 0.08, voices: 2, drums: false },
    { name: 'WARMTH',     e: 0.18, voices: 3, drums: false },
    { name: 'GROOVE',     e: 0.30, voices: 3, drums: true  },
    { name: 'SWELL',      e: 0.45, voices: 4, drums: true  },
    { name: 'SURGE',      e: 0.60, voices: 5, drums: true  },
    { name: 'RADIANCE',   e: 0.78, voices: 6, drums: true  },
    { name: 'BEYOND',     e: 0.92, voices: 6, drums: true  },
];

function noteFreq(semi) { return A * Math.pow(2, semi / 12); }

// ═══════════════════════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════════════════════

const S = {
    active: false,

    // Motion
    tiltX: 0, tiltY: 0,
    accelX: 0, accelY: 0, accelZ: 0,
    speed: 0,
    energy: 0,
    peakEnergy: 0,
    stillness: 0,

    // Touch
    touching: false,
    touchX: 0.5, touchY: 0.5,

    // Breath (bonus layer — detected from Z when phone is on chest)
    azSmooth: 0, azHist: [],
    breathPhase: 'none', breathProgress: 0, breathDepth: 0,
    breathStart: 0, breathDur: 4000, breathDurs: [], lastPeakTime: 0,

    // Gesture
    gestureBuffer: [], gestureCooldown: 0,

    // Musical
    tier: TIERS[0],
    chordIndex: 0,
    chordTimer: 0,
    bpm: 85,

    // Drums
    groovePlaying: false,
    grooveStep: 0,
    nextStepTime: 0,

    // Environment
    weatherScale: 'minor',
    weatherReverb: 0.25,
    micActive: false, micLevel: 0, micCentroid: 0,

    // Viz
    particles: [],
    rings: [],
    orbs: [],
};

let FX = {}, V = {}, DRUMS = {}, MELODY = null, MIC = null;

// ═══════════════════════════════════════════════════════════════════════════════
// AUDIO INIT — Tone.js effects chain
// ═══════════════════════════════════════════════════════════════════════════════

async function initAudio() {
    // Chain from destination backward
    const master = new Tone.Gain(0.7).toDestination();

    const limiter = new Tone.Limiter(-3).connect(master);

    const comp = new Tone.Compressor({
        threshold: -20, ratio: 4, attack: 0.003, release: 0.15
    }).connect(limiter);

    const reverb = new Tone.Reverb({ decay: 3.5, wet: 0.25 });
    reverb.connect(comp);
    try { await reverb.generate(); } catch(e) { console.warn('Reverb:', e); }

    const dust = new Tone.Filter({ frequency: 7000, type: 'lowpass', Q: 0.5 }).connect(reverb);

    const sat = new Tone.Distortion({ distortion: 0.12, wet: 0.15, oversample: '2x' }).connect(dust);

    const warmth = new Tone.EQ3({ low: 4, mid: 0, high: -2, lowFrequency: 300, highFrequency: 5000 }).connect(sat);

    const chorus = new Tone.Chorus({ frequency: 1.5, delayTime: 3.5, depth: 0.4, wet: 0.3 }).connect(warmth);
    chorus.start();

    // Sidechain bus for voice ducking
    const sidechain = new Tone.Gain(1).connect(chorus);

    // Drum bus (bypasses chorus)
    const drumBus = new Tone.Gain(0.6).connect(warmth);

    // Reverb send for melody (wetter)
    const melodySend = new Tone.Gain(0.8).connect(chorus);

    FX = { master, limiter, comp, reverb, dust, sat, warmth, chorus, sidechain, drumBus, melodySend };

    createVoices();
    createDrums();
    createMelody();
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICES — 6 layers of FM/AM/Fat synthesis
// ═══════════════════════════════════════════════════════════════════════════════

function makeOsc(cfg) {
    let osc;
    if (cfg.type === 'fm') {
        osc = new Tone.FMOscillator({
            frequency: cfg.freq,
            type: cfg.carrier || 'sine',
            modulationType: cfg.modType || 'sine',
            modulationIndex: cfg.modIndex || 2,
            harmonicity: cfg.harmonicity || 1.5
        });
    } else if (cfg.type === 'fat') {
        osc = new Tone.FatOscillator({
            frequency: cfg.freq,
            type: cfg.waveform || 'sawtooth',
            count: cfg.count || 3,
            spread: cfg.spread || 20
        });
    } else if (cfg.type === 'am') {
        osc = new Tone.AMOscillator({
            frequency: cfg.freq,
            type: cfg.carrier || 'sine',
            modulationType: cfg.modType || 'sine',
            harmonicity: cfg.harmonicity || 2
        });
    }
    if (cfg.detune) osc.detune.value = cfg.detune;
    return osc;
}

function createLayer(configs, filterFreq, dest) {
    const filter = new Tone.Filter({ frequency: filterFreq, type: 'lowpass', rolloff: -12, Q: 0.7 });
    const gain = new Tone.Gain(0);
    filter.connect(gain);
    gain.connect(dest || FX.sidechain);

    const oscs = configs.map(cfg => {
        const osc = makeOsc(cfg);
        osc.connect(filter);
        osc.start();
        return osc;
    });

    return { oscs, filter, gain };
}

function createVoices() {
    const ch = CHORDS[0];

    // 1. Lead — FM, warm and present
    V.lead = createLayer([
        { type: 'fm', freq: noteFreq(ch[0]), modIndex: 1.2, harmonicity: 1.5 },
        { type: 'fm', freq: noteFreq(ch[0]), modIndex: 0.8, harmonicity: 2, detune: 6 }
    ], 600);

    // 2. Sub — deep sine with subtle FM
    V.sub = createLayer([
        { type: 'fm', freq: noteFreq(ch[0] - 24), modIndex: 0.3, harmonicity: 1 },
        { type: 'fm', freq: noteFreq(ch[0] - 24), modIndex: 0.2, harmonicity: 1, detune: 3 }
    ], 300);

    // 3. Pad — FM triangle triad, lush
    V.pad = createLayer(ch.map((n, i) => ({
        type: 'fm', freq: noteFreq(n - 12), carrier: 'triangle',
        modType: 'sine', modIndex: 1.8, harmonicity: 2, detune: (i - 1) * 10
    })), 1200);

    // 4. Strings — fat detuned saws, dreamy
    V.strings = createLayer(ch.map(n => ({
        type: 'fat', freq: noteFreq(n + 12), waveform: 'sawtooth', count: 3, spread: 25
    })), 2500);

    // 5. Brass — aggressive FM, power
    V.brass = createLayer([
        { type: 'fm', freq: noteFreq(ch[0] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 5, harmonicity: 3 },
        { type: 'fm', freq: noteFreq(ch[2] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 4, harmonicity: 3 }
    ], 1000);

    // 6. Choir — AM shimmer, ethereal
    V.choir = createLayer(ch.map(n => ({
        type: 'am', freq: noteFreq(n + 24), carrier: 'sine', modType: 'sine', harmonicity: 2.5
    })), 6000);
}

function glideChord(chord) {
    const t = 0.6;
    V.lead.oscs[0].frequency.rampTo(noteFreq(chord[0]), t);
    V.lead.oscs[1].frequency.rampTo(noteFreq(chord[0]), t);
    V.sub.oscs[0].frequency.rampTo(noteFreq(chord[0] - 24), t);
    V.sub.oscs[1].frequency.rampTo(noteFreq(chord[0] - 24), t);
    chord.forEach((n, i) => {
        if (V.pad.oscs[i]) V.pad.oscs[i].frequency.rampTo(noteFreq(n - 12), t);
        if (V.strings.oscs[i]) V.strings.oscs[i].frequency.rampTo(noteFreq(n + 12), t);
        if (V.choir.oscs[i]) V.choir.oscs[i].frequency.rampTo(noteFreq(n + 24), t);
    });
    if (V.brass.oscs[0]) V.brass.oscs[0].frequency.rampTo(noteFreq(chord[0] + 12), t);
    if (V.brass.oscs[1]) V.brass.oscs[1].frequency.rampTo(noteFreq(chord[2] + 12), t);
}

// ═══════════════════════════════════════════════════════════════════════════════
// DRUMS — Purdie shuffle with real synth drums
// ═══════════════════════════════════════════════════════════════════════════════

function createDrums() {
    DRUMS.kick = new Tone.MembraneSynth({
        pitchDecay: 0.05, octaves: 6,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.45, sustain: 0, release: 0.3 },
        volume: -4
    }).connect(FX.drumBus);

    DRUMS.snareBody = new Tone.MembraneSynth({
        pitchDecay: 0.008, octaves: 3,
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.04 },
        volume: -8
    }).connect(FX.drumBus);

    const sf = new Tone.Filter({ frequency: 3500, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.snareNoise = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.13, sustain: 0, release: 0.03 },
        volume: -6
    }).connect(sf);

    DRUMS.hat = new Tone.MetalSynth({
        frequency: 400,
        envelope: { attack: 0.001, decay: 0.04, release: 0.01 },
        harmonicity: 5.1, modulationIndex: 32,
        resonance: 5000, octaves: 1.5,
        volume: -16
    }).connect(FX.drumBus);
}

function runGroove() {
    if (!S.groovePlaying) return;

    const stepDur = (60 / S.bpm) / 4;
    const lookAhead = 0.1;
    const intensity = 0.5 + S.energy * 0.5;

    while (S.nextStepTime < Tone.now() + lookAhead) {
        const step = S.grooveStep;
        const jitter = (Math.random() - 0.5) * 0.006;
        const t = Math.max(Tone.now(), S.nextStepTime + jitter);

        if (K[step]) {
            DRUMS.kick.triggerAttackRelease('C1', '8n', t, K[step] * intensity);
            // Sidechain pump
            FX.sidechain.gain.cancelScheduledValues(t);
            FX.sidechain.gain.setValueAtTime(1, t);
            FX.sidechain.gain.linearRampToValueAtTime(0.3, t + 0.012);
            FX.sidechain.gain.linearRampToValueAtTime(1, t + 0.12);
        }
        if (SN[step]) {
            DRUMS.snareBody.triggerAttackRelease('D3', '16n', t, SN[step] * intensity);
            DRUMS.snareNoise.triggerAttackRelease('16n', t, SN[step] * intensity);
        }
        if (HH[step]) {
            DRUMS.hat.triggerAttackRelease('32n', t, HH[step] * intensity * 0.6);
        }

        const sw = step % 2 === 0 ? 1 + SWING : 1 - SWING;
        S.nextStepTime += stepDur * sw;
        S.grooveStep = (step + 1) % 16;
    }
}

function startGroove() {
    if (S.groovePlaying) return;
    S.groovePlaying = true;
    S.nextStepTime = Tone.now() + 0.05;
    S.grooveStep = 0;
    notify('GROOVE');
}

function stopGroove() {
    S.groovePlaying = false;
}

// ═══════════════════════════════════════════════════════════════════════════════
// MELODY — Touch-triggered FM notes
// ═══════════════════════════════════════════════════════════════════════════════

function createMelody() {
    MELODY = new Tone.PolySynth(Tone.FMSynth);
    MELODY.maxPolyphony = 8;
    MELODY.set({
        modulationIndex: 3, harmonicity: 2,
        oscillator: { type: 'sine' },
        modulation: { type: 'triangle' },
        envelope: { attack: 0.06, decay: 0.35, sustain: 0.12, release: 0.7 },
        modulationEnvelope: { attack: 0.08, decay: 0.2, sustain: 0.3, release: 0.4 },
        volume: -10
    });
    MELODY.connect(FX.melodySend);
}

function playNote(x, y, vel) {
    if (!MELODY) return;
    const scale = SCALES[S.weatherScale] || SCALES.minor;
    const chord = CHORDS[S.chordIndex % CHORDS.length];
    // Build playable notes from chord + scale across 3 octaves
    const notes = [];
    for (let oct = -1; oct <= 2; oct++) {
        scale.forEach(s => notes.push(s + oct * 12));
    }
    notes.sort((a, b) => a - b);

    const idx = Math.floor((1 - y) * notes.length);
    const note = notes[Math.max(0, Math.min(idx, notes.length - 1))];
    const freq = noteFreq(note);
    MELODY.triggerAttackRelease(freq, 0.25 + vel * 0.2, Tone.now(), Math.min(1, vel * 0.8));

    // Spawn particle
    S.particles.push({ x: x * window.innerWidth, y: y * window.innerHeight, birth: performance.now(), vel });
}

function triggerPhrase(type) {
    if (!MELODY) return;
    const chord = CHORDS[S.chordIndex % CHORDS.length];
    const base = chord[0];
    const now = Tone.now();

    if (type === 'SHAKE') {
        for (let i = 0; i < 8; i++) {
            const semi = i % 2 === 0 ? base : base + 3;
            MELODY.triggerAttackRelease(noteFreq(semi + (i < 4 ? 0 : 12)), 0.05, now + i * 0.06, 0.5);
        }
        notify('TRILL');
    } else if (type === 'SWIPE_UP') {
        chord.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + 12), 0.2, now + i * 0.1, 0.6 - i * 0.1);
        });
        // Extra octave note
        MELODY.triggerAttackRelease(noteFreq(chord[0] + 24), 0.3, now + chord.length * 0.1, 0.4);
        notify('RISE');
    } else if (type === 'SWIPE_DOWN') {
        const reversed = [...chord].reverse();
        reversed.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + 12), 0.2, now + i * 0.1, 0.6 - i * 0.1);
        });
        MELODY.triggerAttackRelease(noteFreq(chord[0] - 12), 0.4, now + reversed.length * 0.1, 0.4);
        notify('FALL');
    } else if (type === 'HOLD') {
        // Full chord swell
        chord.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n), 2.5, now + i * 0.04, 0.3);
            MELODY.triggerAttackRelease(noteFreq(n + 12), 2.5, now + i * 0.04 + 0.02, 0.2);
        });
        notify('SWELL');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICE SHAPING — Energy drives layers, tilt drives expression
// ═══════════════════════════════════════════════════════════════════════════════

function shapeVoices() {
    const e = S.energy;
    const tier = S.tier;
    const brightness = (S.tiltY + 1) * 0.5; // 0 to 1

    // Each layer: target volume, filter cutoff
    const layers = [
        { name: 'lead',    minVoices: 1, vol: 0.13, baseCut: 600,  maxCut: 4000 },
        { name: 'sub',     minVoices: 2, vol: 0.16, baseCut: 200,  maxCut: 600  },
        { name: 'pad',     minVoices: 3, vol: 0.07, baseCut: 400,  maxCut: 2500 },
        { name: 'strings', minVoices: 4, vol: 0.05, baseCut: 600,  maxCut: 4000 },
        { name: 'brass',   minVoices: 5, vol: 0.04, baseCut: 400,  maxCut: 2500 },
        { name: 'choir',   minVoices: 6, vol: 0.03, baseCut: 1000, maxCut: 7000 },
    ];

    layers.forEach(({ name, minVoices, vol, baseCut, maxCut }) => {
        const layer = V[name];
        if (!layer) return;

        let amp, cutoff;
        if (tier.voices < minVoices) {
            amp = 0;
            cutoff = baseCut;
        } else {
            // Smooth entry: ramp from 0 to full over the transition zone
            const headroom = Math.min(1, (e - (tier.e || 0)) * 5);
            amp = vol * headroom;
            cutoff = baseCut + (maxCut - baseCut) * brightness * headroom;

            // Breath modulation if detected
            if (S.breathPhase === 'inhale') {
                amp *= 0.3 + S.breathProgress * 0.7;
                cutoff *= 0.5 + S.breathProgress * 0.5;
            } else if (S.breathPhase === 'exhale') {
                const ease = 1 - S.breathProgress * S.breathProgress;
                amp *= Math.max(0.2, ease);
                cutoff *= Math.max(0.3, ease);
            } else if (S.breathPhase === 'peak') {
                // Full open
            }
        }

        // Mic influence
        if (S.micActive && S.micCentroid > 0.1) {
            cutoff += S.micCentroid * 600;
        }

        cutoff = Math.max(150, Math.min(8000, cutoff));
        layer.gain.gain.rampTo(amp, 0.12);
        layer.filter.frequency.rampTo(cutoff, 0.12);
    });

    // Lead pitch expression: tilt X bends pitch subtly
    if (V.lead && V.lead.oscs[0]) {
        V.lead.oscs[0].detune.rampTo(S.tiltX * 30, 0.15);
    }

    // Reverb evolves with energy
    const reverbWet = S.weatherReverb + e * 0.15;
    FX.reverb.wet.rampTo(Math.min(0.5, reverbWet), 0.3);

    // Dust filter opens with energy
    FX.dust.frequency.rampTo(5000 + e * 3000 + brightness * 2000, 0.2);
}

// ═══════════════════════════════════════════════════════════════════════════════
// TIER SYSTEM — Energy unlocks layers and groove
// ═══════════════════════════════════════════════════════════════════════════════

function updateTier() {
    let newTier = TIERS[0];
    for (const t of TIERS) {
        if (S.energy >= t.e) newTier = t;
    }

    if (newTier.name !== S.tier.name) {
        S.tier = newTier;
        document.getElementById('stageName').textContent = newTier.name;
        if (newTier.name !== 'SILENCE') notify(newTier.name);

        if (newTier.drums && !S.groovePlaying) startGroove();
        if (!newTier.drums && S.groovePlaying) stopGroove();
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// CHORD PROGRESSION — Auto-advances with time/energy
// ═══════════════════════════════════════════════════════════════════════════════

function advanceChord() {
    S.chordIndex++;
    glideChord(CHORDS[S.chordIndex % CHORDS.length]);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BREATH DETECTION — Bonus layer from accelerometer Z
// ═══════════════════════════════════════════════════════════════════════════════

function detectBreath() {
    const z = S.accelZ;
    const now = performance.now();

    S.azSmooth = S.azSmooth * 0.82 + z * 0.18;
    S.azHist.push({ z: S.azSmooth, t: now });
    if (S.azHist.length > 300) S.azHist = S.azHist.slice(-200);
    if (S.azHist.length < 30) return;

    const win = S.azHist.slice(-80);
    const vals = win.map(h => h.z);
    const lo = Math.min(...vals);
    const hi = Math.max(...vals);
    const range = hi - lo;
    const mid = (lo + hi) / 2;
    S.breathDepth = Math.min(1, range * 2.5);

    if (range < 0.08) { S.breathPhase = 'none'; return; }

    const tail = S.azHist.slice(-12);
    let trend = 0;
    for (let i = 1; i < tail.length; i++) trend += tail[i].z - tail[i - 1].z;
    trend /= tail.length;

    if (S.breathPhase === 'none' || S.breathPhase === 'valley') {
        if (trend > 0.004 && S.azSmooth > lo + range * 0.25) {
            S.breathPhase = 'inhale';
            S.breathStart = now;
        }
    } else if (S.breathPhase === 'inhale') {
        S.breathProgress = Math.min(1, (now - S.breathStart) / (S.breathDur * 0.4));
        if (trend < 0.001 && S.azSmooth > mid + range * 0.2) {
            S.breathPhase = 'peak';
            S.lastPeakTime = now;
        }
    } else if (S.breathPhase === 'peak') {
        if (trend < -0.003) S.breathPhase = 'exhale';
    } else if (S.breathPhase === 'exhale') {
        S.breathProgress = Math.min(1, (now - S.lastPeakTime) / (S.breathDur * 0.5));
        if (S.azSmooth < mid - range * 0.15 && trend > -0.002) {
            S.breathPhase = 'valley';
            // Learn duration
            const dur = now - S.breathStart;
            if (dur > 1500 && dur < 12000) {
                S.breathDurs.push(dur);
                if (S.breathDurs.length > 8) S.breathDurs.shift();
                S.breathDur = S.breathDurs.reduce((a, b) => a + b) / S.breathDurs.length;
            }
            // Breath also adds energy
            S.energy = Math.min(1, S.energy + 0.03 + S.breathDepth * 0.04);
            // Advance chord on deep breaths
            if (S.breathDepth > 0.3) advanceChord();
            // Ring
            S.rings.push({ birth: performance.now(), depth: S.breathDepth });
            if (S.rings.length > 40) S.rings.shift();
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// GESTURE DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

function detectGesture() {
    if (S.gestureCooldown > 0) { S.gestureCooldown--; return; }
    const buf = S.gestureBuffer;
    if (buf.length < 10) return;

    let totalSpeed = 0, dirChanges = 0, netX = 0, netY = 0;
    for (let i = 1; i < buf.length; i++) {
        const dx = buf[i].x - buf[i-1].x, dy = buf[i].y - buf[i-1].y;
        totalSpeed += Math.sqrt(dx*dx + dy*dy);
        netX += dx; netY += dy;
        if (i > 1) {
            if (dx * (buf[i-1].x - buf[i-2].x) < 0 || dy * (buf[i-1].y - buf[i-2].y) < 0) dirChanges++;
        }
    }
    const avg = totalSpeed / buf.length;

    if (avg > 0.03 && dirChanges >= 4) {
        triggerPhrase('SHAKE'); S.gestureCooldown = 30;
    } else if (avg > 0.02 && Math.abs(netY) > 0.2) {
        triggerPhrase(netY < 0 ? 'SWIPE_UP' : 'SWIPE_DOWN'); S.gestureCooldown = 20;
    } else if (avg < 0.003 && S.stillness > 80 && S.energy > 0.1) {
        triggerPhrase('HOLD'); S.gestureCooldown = 150;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// INPUT HANDLERS
// ═══════════════════════════════════════════════════════════════════════════════

async function requestSensors() {
    if (typeof DeviceMotionEvent !== 'undefined') {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            try {
                const r = await DeviceMotionEvent.requestPermission();
                if (r === 'granted') window.addEventListener('devicemotion', onMotion);
            } catch(e) {}
        } else { window.addEventListener('devicemotion', onMotion); }
    }
    if (typeof DeviceOrientationEvent !== 'undefined') {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const r = await DeviceOrientationEvent.requestPermission();
                if (r === 'granted') window.addEventListener('deviceorientation', onOrientation);
            } catch(e) {}
        } else { window.addEventListener('deviceorientation', onOrientation); }
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    S.accelX = a.x || 0; S.accelY = a.y || 0; S.accelZ = a.z || 0;
    const motion = Math.sqrt(S.accelX**2 + S.accelY**2 + S.accelZ**2);
    const deviation = Math.abs(motion - 9.8);
    S.speed = S.speed * 0.75 + Math.min(1, deviation * 0.4) * 0.25;
}

function onOrientation(e) {
    S.tiltX = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    S.tiltY = Math.max(-1, Math.min(1, ((e.beta || 45) - 45) / 45));
}

function setupTouch() {
    const onDown = (x, y) => {
        S.touching = true;
        S.touchX = x; S.touchY = y;
        S.tiltX = (x - 0.5) * 2;
        S.tiltY = (y - 0.5) * 2;
        playNote(x, y, 0.65);
        S.energy = Math.min(1, S.energy + 0.05);
    };

    const onMove = (x, y) => {
        if (!S.touching) return;
        const dist = Math.sqrt((x - S.touchX)**2 + (y - S.touchY)**2);
        if (dist > 0.012) {
            playNote(x, y, 0.3 + Math.min(1, dist * 5));
            S.energy = Math.min(1, S.energy + dist * 0.8);
            S.speed = S.speed * 0.6 + dist * 15 * 0.4;
        }
        S.touchX = x; S.touchY = y;
        S.tiltX = (x - 0.5) * 2;
        S.tiltY = (y - 0.5) * 2;
    };

    document.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const t = e.touches[0];
        onDown(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchend', (e) => { e.preventDefault(); S.touching = false; }, { passive: false });

    document.addEventListener('mousedown', (e) => {
        onDown(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });
    document.addEventListener('mousemove', (e) => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });
    document.addEventListener('mouseup', () => { S.touching = false; });
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT — Weather, Microphone, Light
// ═══════════════════════════════════════════════════════════════════════════════

function fetchWeather() {
    if (!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(async (pos) => {
        try {
            const { latitude, longitude } = pos.coords;
            const resp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,weathercode`);
            const data = await resp.json();
            const temp = data.current.temperature_2m;
            const code = data.current.weathercode;

            if (temp < 10) { S.weatherScale = 'minor'; S.bpm = 75; }
            else if (temp < 25) { S.weatherScale = 'mixolydian'; S.bpm = 85; }
            else { S.weatherScale = 'major'; S.bpm = 95; }

            if (code >= 51 && code <= 82) { S.weatherReverb = 0.35; S.weatherScale = 'minor'; }
            else if (code >= 71 && code <= 77) { S.weatherReverb = 0.4; S.weatherScale = 'dorian'; }
            else if (code >= 95) { S.weatherScale = 'phrygian'; }
            else if (code >= 45 && code <= 48) { S.weatherReverb = 0.38; S.weatherScale = 'dorian'; }

            FX.reverb.wet.rampTo(S.weatherReverb, 2);

            const cond = code === 0 ? 'clear' : code <= 3 ? 'cloudy' :
                code <= 48 ? 'fog' : code <= 67 ? 'rain' : code <= 77 ? 'snow' : 'storm';
            document.getElementById('weatherInfo').textContent = `${Math.round(temp)}° ${cond}`;
        } catch(e) {}
    }, () => {}, { timeout: 5000 });
}

async function initMicrophone() {
    if (S.micActive) return;
    try {
        MIC = new Tone.UserMedia();
        await MIC.open();
        const analyser = new Tone.Analyser('fft', 256);
        MIC.connect(analyser);
        S.micActive = true;
        document.getElementById('micBtn').classList.add('on');

        setInterval(() => {
            if (!S.micActive) return;
            const sp = analyser.getValue();
            let sum = 0, wSum = 0, tPow = 0;
            for (let i = 0; i < sp.length; i++) {
                const p = Math.pow(10, sp[i] / 20);
                sum += p; wSum += p * i; tPow += p;
            }
            S.micLevel = Math.min(1, sum / sp.length * 10);
            S.micCentroid = tPow > 0 ? (wSum / tPow) / sp.length : 0;
        }, 100);
    } catch(e) { console.log('Mic denied'); }
}

// ═══════════════════════════════════════════════════════════════════════════════
// VISUALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

let canvas, vc;

function initCanvas() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    onResize();
    window.addEventListener('resize', onResize);
}

function onResize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth, h = window.innerHeight;
    const now = performance.now();
    const cx = w / 2 + S.tiltX * w * 0.15;
    const cy = h / 2 + S.tiltY * h * 0.15;
    const e = S.energy;
    const tierIdx = TIERS.indexOf(S.tier);
    const hue = 210 + tierIdx * 12;

    // Fade
    vc.fillStyle = `rgba(2, 2, 4, ${0.08 + (1 - e) * 0.04})`;
    vc.fillRect(0, 0, w, h);

    // Breath rings
    S.rings.forEach(ring => {
        const age = (now - ring.birth) / 1000;
        if (age > 20) return;
        const r = 30 + age * 18;
        const alpha = Math.max(0, 0.15 - age * 0.008) * ring.depth;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue}, 30%, 55%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    });

    // Energy rings
    const numRings = Math.min(6, S.tier.voices);
    for (let i = 0; i < numRings; i++) {
        const r = 35 + i * 35 + Math.sin(now * 0.001 + i) * 5;
        const alpha = 0.04 + e * 0.12;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue + i * 18}, ${25 + e * 30}%, ${45 + e * 15}%, ${alpha})`;
        vc.lineWidth = 1 + e;
        vc.stroke();
    }

    // Core orb
    const coreR = 12 + e * 25 + S.speed * 30;
    const grad = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    grad.addColorStop(0, `hsla(${hue}, 50%, 65%, ${0.4 + e * 0.5})`);
    grad.addColorStop(0.6, `hsla(${hue}, 40%, 45%, ${0.15 + e * 0.2})`);
    grad.addColorStop(1, 'transparent');
    vc.fillStyle = grad;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, TAU);
    vc.fill();

    // Voice orbit dots
    for (let i = 0; i < numRings; i++) {
        const angle = (i / Math.max(1, numRings)) * TAU + now * 0.0006;
        const dist = 35 + i * 35;
        const vx = cx + Math.cos(angle) * dist;
        const vy = cy + Math.sin(angle) * dist;
        vc.beginPath();
        vc.arc(vx, vy, 2, 0, TAU);
        vc.fillStyle = `hsla(${hue + i * 18}, 50%, 70%, ${0.15 + e * 0.25})`;
        vc.fill();
    }

    // Touch particles
    S.particles = S.particles.filter(p => {
        const age = (now - p.birth) / 1000;
        if (age > 1.5) return false;
        const alpha = Math.max(0, 0.6 - age * 0.4) * p.vel;
        const r = 3 + age * 20;
        vc.beginPath();
        vc.arc(p.x, p.y, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue + 40}, 50%, 70%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
        return true;
    });

    // Speed trail
    if (S.speed > 0.06) {
        const len = S.speed * 80;
        vc.beginPath();
        vc.moveTo(cx, cy);
        vc.lineTo(cx - S.tiltX * len, cy - S.tiltY * len);
        vc.strokeStyle = `hsla(${hue}, 40%, 60%, ${S.speed * 0.4})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Edge glow at high tiers
    if (tierIdx >= 6) {
        const glow = vc.createRadialGradient(w/2, h/2, Math.min(w,h)*0.25, w/2, h/2, Math.min(w,h)*0.65);
        glow.addColorStop(0, 'transparent');
        glow.addColorStop(1, `hsla(${hue + 30}, 50%, 50%, ${(e - 0.6) * 0.15})`);
        vc.fillStyle = glow;
        vc.fillRect(0, 0, w, h);
    }

    // Energy bar
    document.getElementById('energyFill').style.width = (e * 100) + '%';
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════════

let lastFrame = 0;

function loop(ts) {
    if (!S.active) { requestAnimationFrame(loop); return; }

    const dt = Math.min(50, ts - lastFrame) / 1000;
    lastFrame = ts;

    // Energy: movement adds, time decays
    if (S.speed > 0.015) {
        S.energy = Math.min(1, S.energy + S.speed * 0.025);
        S.stillness = 0;
    } else {
        S.energy *= (1 - dt * 0.12); // Slow decay
        S.stillness += dt * 10;
    }

    // Touch adds energy
    if (S.touching) {
        S.energy = Math.min(1, S.energy + dt * 0.08);
    }

    S.peakEnergy = Math.max(S.peakEnergy, S.energy);

    // Chord auto-advance every ~8 seconds of activity
    S.chordTimer += dt * S.energy;
    if (S.chordTimer > 8) {
        S.chordTimer = 0;
        advanceChord();
    }

    // Gesture buffer
    S.gestureBuffer.push({ x: S.tiltX, y: S.tiltY, speed: S.speed, time: performance.now() });
    if (S.gestureBuffer.length > 30) S.gestureBuffer.shift();

    // Systems
    detectBreath();
    detectGesture();
    updateTier();
    shapeVoices();
    if (S.groovePlaying) runGroove();
    draw();

    requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════════════════════════════════════
// UTILITIES
// ═══════════════════════════════════════════════════════════════════════════════

let notifTimer = null;
function notify(text) {
    const el = document.getElementById('notif');
    el.textContent = text;
    el.classList.add('show');
    if (notifTimer) clearTimeout(notifTimer);
    notifTimer = setTimeout(() => el.classList.remove('show'), 1800);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BOOTSTRAP
// ═══════════════════════════════════════════════════════════════════════════════

async function begin() {
    try {
        await Tone.start();
        await requestSensors();
        await initAudio();
        initCanvas();
        setupTouch();

        document.getElementById('entry').classList.add('gone');
        document.getElementById('stageName').textContent = 'AWAKENING';

        setTimeout(() => { document.getElementById('micBtn').style.display = 'block'; }, 3000);
        fetchWeather();

        S.active = true;
        lastFrame = performance.now();
        requestAnimationFrame(loop);
    } catch(e) {
        console.error('Start failed:', e);
        document.getElementById('err').textContent = 'Error: ' + e.message;
        document.getElementById('err').style.display = 'flex';
    }
}

document.getElementById('micBtn').addEventListener('click', (e) => { e.stopPropagation(); initMicrophone(); });
document.getElementById('begin').addEventListener('click', begin);
document.getElementById('begin').addEventListener('touchstart', (e) => { e.preventDefault(); begin(); }, { passive: false });
document.addEventListener('contextmenu', (e) => e.preventDefault());

})();
</script>
</body>
</html>
