<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>GUMP</title>
    <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"
            onerror="document.getElementById('err').style.display='flex'"></script>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        html,body{width:100%;height:100%;background:#050505;overflow:hidden;touch-action:none;user-select:none;-webkit-user-select:none;font-family:-apple-system,sans-serif}
        #entry{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:100}
        #entry.gone{display:none}
        #entry h1{font-size:10px;font-weight:300;letter-spacing:8px;color:rgba(255,255,255,.15);margin-bottom:40px}
        #entry p{font-size:11px;color:rgba(255,255,255,.25);text-align:center;line-height:2.4;max-width:260px;margin-bottom:50px}
        #entry button{width:90px;height:90px;border-radius:50%;background:0;border:1px solid rgba(255,255,255,.08);color:rgba(255,255,255,.2);font-size:9px;letter-spacing:3px;cursor:pointer;transition:.6s}
        #entry button:hover{border-color:rgba(255,255,255,.2)}
        canvas{position:fixed;inset:0}
        .hud{position:fixed;pointer-events:none;font-size:9px;letter-spacing:2px;color:rgba(255,255,255,.12);z-index:5}
        #stageName{top:24px;left:24px}
        #sectionName{bottom:24px;right:24px;font-size:8px;letter-spacing:3px;color:rgba(255,255,255,.06)}
        #energyBar{bottom:0;left:0;right:0;height:2px;z-index:5}
        #energyFill{height:100%;width:0%;background:rgba(255,255,255,.15);transition:width .3s linear}
        #notif{position:fixed;top:50%;left:50%;transform:translate(-50%,-50%);font-size:11px;letter-spacing:5px;color:rgba(255,255,255,.5);opacity:0;transition:opacity .3s;pointer-events:none;z-index:10}
        #notif.show{opacity:1}
        #weatherInfo{top:24px;right:24px;font-size:8px;color:rgba(255,255,255,.06)}
        #micBtn{position:fixed;bottom:20px;left:20px;width:36px;height:36px;border-radius:50%;border:1px solid rgba(255,255,255,.08);background:0;color:rgba(255,255,255,.12);font-size:8px;cursor:pointer;z-index:10;display:none}
        #micBtn.on{border-color:rgba(200,100,100,.3);color:rgba(200,100,100,.3)}
        #err{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:#000;color:rgba(255,255,255,.3);font-size:11px;text-align:center;z-index:999;flex-direction:column}
    </style>
</head>
<body>
<div id="entry">
    <h1>GUMP</h1>
    <p>
        move to conduct<br>
        tilt for expression<br>
        touch to play<br>
        stillness to breathe
    </p>
    <button id="begin">AWAKEN</button>
</div>
<canvas id="c"></canvas>
<div class="hud" id="stageName"></div>
<div class="hud" id="sectionName"></div>
<div class="hud" id="weatherInfo"></div>
<div id="energyBar"><div id="energyFill"></div></div>
<div id="notif"></div>
<button id="micBtn">MIC</button>
<div id="err">Failed to load audio engine.<br>Check connection and reload.</div>

<script>
(function() {
'use strict';

const TAU = Math.PI * 2;
const A = 432;

// ═══════════════════════════════════════════════════════════════════════════════
// MUSICAL DNA
// ═══════════════════════════════════════════════════════════════════════════════

const PROGRESSIONS = {
    drift: [
        [0, 3, 7],     [7, 10, 14],   [5, 8, 12],    [0, 3, 7],
    ],
    wander: [
        [0, 3, 7],     [5, 9, 12],    [3, 7, 10],    [7, 11, 14],
        [0, 3, 7],     [8, 12, 15],   [3, 7, 10],    [10, 14, 17],
    ],
    ascend: [
        [3, 7, 10],    [10, 14, 17],  [0, 4, 7],     [5, 9, 12],
        [8, 12, 15],   [3, 7, 10],
    ],
    summit: [
        [3, 7, 10],    [10, 14, 17],  [0, 3, 7],     [8, 12, 15],
        [5, 9, 12],    [0, 4, 7],     [7, 11, 14],   [3, 6, 10],
    ],
    descend: [
        [5, 8, 12],    [10, 14, 17],  [3, 7, 10],    [8, 12, 15],
        [0, 3, 7],     [7, 11, 14],   [0, 3, 7],
    ],
};

const SCALES = {
    minor:      [0, 2, 3, 5, 7, 8, 10],
    major:      [0, 2, 4, 5, 7, 9, 11],
    dorian:     [0, 2, 3, 5, 7, 9, 10],
    mixolydian: [0, 2, 4, 5, 7, 9, 10],
    phrygian:   [0, 1, 3, 5, 7, 8, 10],
};

// Drum patterns
const DRUM_PATTERNS = {
    minimal: {
        K:  [1,0,0,0, 0,0,0,0, .6,0,0,0, 0,0,0,0],
        SN: [0,0,0,0, 1,0,0,0, 0,0,0,0, .8,0,0,0],
        HH: [.4,0,.2,0, .4,0,.2,0, .4,0,.2,0, .4,0,.2,0],
        OH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    },
    groove: {
        K:  [1,0,0,0, 0,0,.4,0, .8,0,0,0, 0,0,0,0],
        SN: [0,0,0,0, 1,0,.1,.15, 0,0,.1,0, 1,0,.15,.1],
        HH: [.6,.2,.4,.2, .6,.25,.4,.25, .6,.2,.4,.2, .6,.25,.4,.25],
        OH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,.25,0],
    },
    drive: {
        K:  [1,0,.2,0, 0,0,.5,0, .9,0,0,.2, 0,0,.4,0],
        SN: [0,0,0,0, 1,0,.2,.1, 0,0,.1,0, 1,.1,.2,.15],
        HH: [.7,.3,.5,.3, .7,.35,.5,.35, .7,.3,.5,.3, .7,.35,.5,.35],
        OH: [0,0,0,0, 0,0,0,.2, 0,0,0,0, 0,0,0,.25],
    },
    peak: {
        K:  [1,0,.3,0, 0,.15,.6,0, 1,0,.2,.1, 0,.15,.5,0],
        SN: [0,0,.08,0, 1,0,.2,.12, 0,.08,.12,0, 1,.08,.25,.15],
        HH: [.8,.35,.6,.35, .8,.4,.6,.4, .8,.35,.6,.35, .8,.4,.6,.4],
        OH: [0,0,0,.15, 0,0,0,.2, 0,0,0,.15, 0,0,0,.25],
    },
    fill: {
        K:  [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        SN: [0,.35,.35,.45, .55,.55,.65,.65, .75,.75,.85,.8, .95,.9,1,1],
        HH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        OH: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
    },
};

const BASS_PATTERNS = [
    [0, 7, 0, 7],     [0, 3, 7, 5],     [0, 7, 5, 3],
    [0, 5, 7, 10],    [0, 0, 7, 6],     [0, 3, 5, 7],
];

const ARP_PATTERNS = {
    up:      [0,1,2,3,4,5],
    down:    [5,4,3,2,1,0],
    updown:  [0,1,2,3,4,5,4,3,2,1],
    cascade: [0,2,1,3,2,4,3,5],
};

const SWING = 0.18;

// Sections
const SECTIONS = [
    { name: 'DRIFT',   scale: 'minor',      tr: 0,  tempoMul: 0.9,  threshold: 0,    holdTime: 0  },
    { name: 'WANDER',  scale: 'dorian',     tr: 0,  tempoMul: 1.0,  threshold: 0.35, holdTime: 30 },
    { name: 'ASCEND',  scale: 'mixolydian', tr: 2,  tempoMul: 1.05, threshold: 0.55, holdTime: 45 },
    { name: 'SUMMIT',  scale: 'major',      tr: 5,  tempoMul: 1.1,  threshold: 0.80, holdTime: 60 },
    { name: 'DESCEND', scale: 'minor',      tr: 0,  tempoMul: 0.85, threshold: -1,   holdTime: 25 },
];

// Tiers
const TIERS = [
    { name: 'SILENCE',    e: 0,    voices: 0, drums: false, pat: 'minimal' },
    { name: 'AWAKENING',  e: 0.05, voices: 1, drums: false, pat: 'minimal' },
    { name: 'PULSE',      e: 0.15, voices: 2, drums: false, pat: 'minimal' },
    { name: 'WARMTH',     e: 0.30, voices: 3, drums: false, pat: 'groove'  },
    { name: 'GROOVE',     e: 0.42, voices: 3, drums: true,  pat: 'groove'  },
    { name: 'SWELL',      e: 0.55, voices: 4, drums: true,  pat: 'groove'  },
    { name: 'SURGE',      e: 0.68, voices: 5, drums: true,  pat: 'drive'   },
    { name: 'RADIANCE',   e: 0.82, voices: 6, drums: true,  pat: 'peak'    },
    { name: 'BEYOND',     e: 0.94, voices: 6, drums: true,  pat: 'peak'    },
];

const PALETTES = {
    DRIFT:   { h: 220, s: 25, l: 45 },
    WANDER:  { h: 200, s: 30, l: 50 },
    ASCEND:  { h: 170, s: 35, l: 55 },
    SUMMIT:  { h: 35,  s: 45, l: 60 },
    DESCEND: { h: 260, s: 30, l: 45 },
};

function noteFreq(semi) { return A * Math.pow(2, semi / 12); }

// ═══════════════════════════════════════════════════════════════════════════════
// STATE
// ═══════════════════════════════════════════════════════════════════════════════

const S = {
    active: false,

    // Motion
    tiltX: 0, tiltY: 0,
    accelX: 0, accelY: 0, accelZ: 0,
    sensorsGranted: false,
    speed: 0, smoothSpeed: 0,
    energy: 0, peakEnergy: 0,
    stillness: 0,

    // Touch
    touching: false,
    touchX: 0.5, touchY: 0.5,
    touchActive: false,

    // Breath
    azSmooth: 0, azHist: [],
    breathPhase: 'none', breathProgress: 0, breathDepth: 0,
    breathStart: 0, breathDur: 4000, breathDurs: [], lastPeakTime: 0,

    // Gesture
    gestureBuffer: [], gestureCooldown: 0,

    // Musical
    tier: TIERS[0], prevTier: TIERS[0],
    section: SECTIONS[0], sectionIndex: 0,
    sectionHoldTimer: 0,
    chordIndex: 0,
    transpose: 0,
    bpm: 85, baseBpm: 85,
    activeScale: 'minor',

    // Groove
    groovePlaying: false,
    grooveStep: 0,
    nextStepTime: 0,
    fillCountdown: 0,

    // Bass — only plays when user is active
    bassPatIdx: 0,

    // Arp — driven by sustained touch
    arpStep: 0,
    arpPattern: 'up',

    // Environment
    weatherScale: null,
    weatherReverb: 0.25,
    weatherTempo: 0,
    micActive: false, micLevel: 0, micCentroid: 0,

    // Viz
    particles: [],
    rings: [],
};

let FX = {}, V = {}, DRUMS = {}, MELODY = null, BASS = null, ARP = null, MIC = null;

// ═══════════════════════════════════════════════════════════════════════════════
// AUDIO INIT
// ═══════════════════════════════════════════════════════════════════════════════

async function initAudio() {
    const master = new Tone.Gain(0.6).toDestination();
    const limiter = new Tone.Limiter(-2).connect(master);

    const comp = new Tone.Compressor({
        threshold: -18, ratio: 4, attack: 0.003, release: 0.15
    }).connect(limiter);

    const reverb = new Tone.Reverb({ decay: 4, wet: 0.22 });
    reverb.connect(comp);
    try { await reverb.generate(); } catch(e) {}

    const delay = new Tone.PingPongDelay({
        delayTime: 60 / S.bpm / 2,
        feedback: 0.22, wet: 0.08, maxDelay: 2
    }).connect(reverb);

    // DUST FILTER — tilt Y directly controls this (the key to expression)
    const dust = new Tone.Filter({ frequency: 4000, type: 'lowpass', Q: 0.5 }).connect(delay);

    const sat = new Tone.Distortion({ distortion: 0.1, wet: 0.12, oversample: '2x' }).connect(dust);
    const warmth = new Tone.EQ3({ low: 4, mid: -1, high: -3, lowFrequency: 300, highFrequency: 5000 }).connect(sat);
    const chorus = new Tone.Chorus({ frequency: 1.2, delayTime: 4, depth: 0.35, wet: 0.25 }).connect(warmth);
    chorus.start();

    const panner = new Tone.AutoPanner({ frequency: 0.07, depth: 0.3 }).connect(chorus);
    panner.start();

    const sidechain = new Tone.Gain(1).connect(chorus);
    const padBus = new Tone.Gain(1).connect(panner);

    // Drum chain — own compression + warmth
    const drumComp = new Tone.Compressor({
        threshold: -14, ratio: 6, attack: 0.001, release: 0.08
    }).connect(comp);
    const drumWarmth = new Tone.EQ3({ low: 3, mid: -2, high: -4, lowFrequency: 200, highFrequency: 6000 }).connect(drumComp);
    const drumSat = new Tone.Distortion({ distortion: 0.06, wet: 0.1 }).connect(drumWarmth);
    const drumBus = new Tone.Gain(0.55).connect(drumSat);

    const drumRoom = new Tone.Reverb({ decay: 0.8, wet: 0.06 });
    drumRoom.connect(drumComp);
    try { await drumRoom.generate(); } catch(e) {}
    const drumRoomSend = new Tone.Gain(0.4).connect(drumRoom);

    const melodySend = new Tone.Gain(0.75).connect(chorus);
    const bassBus = new Tone.Gain(0.85).connect(warmth);
    const arpBus = new Tone.Gain(0.6).connect(delay);

    FX = { master, limiter, comp, reverb, delay, dust, sat, warmth, chorus,
           panner, sidechain, padBus, drumBus, drumSat, drumComp, drumWarmth,
           drumRoom, drumRoomSend, melodySend, bassBus, arpBus };

    createVoices();
    createDrums();
    createMelody();
    createBass();
    createArp();
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICES
// ═══════════════════════════════════════════════════════════════════════════════

function makeOsc(cfg) {
    let osc;
    if (cfg.type === 'fm') {
        osc = new Tone.FMOscillator({
            frequency: cfg.freq,
            type: cfg.carrier || 'sine',
            modulationType: cfg.modType || 'sine',
            modulationIndex: cfg.modIndex || 2,
            harmonicity: cfg.harmonicity || 1.5
        });
    } else if (cfg.type === 'fat') {
        osc = new Tone.FatOscillator({
            frequency: cfg.freq,
            type: cfg.waveform || 'sawtooth',
            count: cfg.count || 3,
            spread: cfg.spread || 20
        });
    } else if (cfg.type === 'am') {
        osc = new Tone.AMOscillator({
            frequency: cfg.freq,
            type: cfg.carrier || 'sine',
            modulationType: cfg.modType || 'sine',
            harmonicity: cfg.harmonicity || 2
        });
    }
    if (cfg.detune) osc.detune.value = cfg.detune;
    return osc;
}

function createLayer(configs, filterFreq, dest) {
    const filter = new Tone.Filter({ frequency: filterFreq, type: 'lowpass', rolloff: -12, Q: 0.7 });
    const gain = new Tone.Gain(0);
    filter.connect(gain);
    gain.connect(dest || FX.sidechain);
    const oscs = configs.map(cfg => {
        const osc = makeOsc(cfg);
        osc.connect(filter);
        osc.start();
        return osc;
    });
    return { oscs, filter, gain };
}

function createVoices() {
    const ch = getChord();

    V.lead = createLayer([
        { type: 'fm', freq: noteFreq(ch[0]), modIndex: 1.2, harmonicity: 1.5 },
        { type: 'fm', freq: noteFreq(ch[0]), modIndex: 0.8, harmonicity: 2, detune: 7 }
    ], 600);

    V.sub = createLayer([
        { type: 'fm', freq: noteFreq(ch[0] - 24), modIndex: 0.3, harmonicity: 1 },
        { type: 'fm', freq: noteFreq(ch[0] - 24), modIndex: 0.2, harmonicity: 1, detune: 3 }
    ], 300);

    V.pad = createLayer(ch.map((n, i) => ({
        type: 'fm', freq: noteFreq(n - 12), carrier: 'triangle',
        modType: 'sine', modIndex: 1.8, harmonicity: 2, detune: (i - 1) * 10
    })), 1200, FX.padBus);

    V.strings = createLayer(ch.map(n => ({
        type: 'fat', freq: noteFreq(n + 12), waveform: 'sawtooth', count: 3, spread: 25
    })), 2500);

    V.brass = createLayer([
        { type: 'fm', freq: noteFreq(ch[0] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 5, harmonicity: 3 },
        { type: 'fm', freq: noteFreq(ch[2] + 12), carrier: 'sawtooth', modType: 'square', modIndex: 4, harmonicity: 3 }
    ], 1000);

    V.choir = createLayer(ch.map(n => ({
        type: 'am', freq: noteFreq(n + 24), carrier: 'sine', modType: 'sine', harmonicity: 2.5
    })), 6000);
}

function glideChord(chord, dur) {
    const t = dur || 0.6;
    const tr = S.transpose;
    V.lead.oscs[0].frequency.rampTo(noteFreq(chord[0] + tr), t);
    V.lead.oscs[1].frequency.rampTo(noteFreq(chord[0] + tr), t);
    V.sub.oscs[0].frequency.rampTo(noteFreq(chord[0] + tr - 24), t);
    V.sub.oscs[1].frequency.rampTo(noteFreq(chord[0] + tr - 24), t);
    chord.forEach((n, i) => {
        if (V.pad.oscs[i]) V.pad.oscs[i].frequency.rampTo(noteFreq(n + tr - 12), t);
        if (V.strings.oscs[i]) V.strings.oscs[i].frequency.rampTo(noteFreq(n + tr + 12), t);
        if (V.choir.oscs[i]) V.choir.oscs[i].frequency.rampTo(noteFreq(n + tr + 24), t);
    });
    if (V.brass.oscs[0]) V.brass.oscs[0].frequency.rampTo(noteFreq(chord[0] + tr + 12), t);
    if (V.brass.oscs[1]) V.brass.oscs[1].frequency.rampTo(noteFreq(chord[2] + tr + 12), t);
}

function getChord() {
    const progName = S.section.name.toLowerCase();
    const prog = PROGRESSIONS[progName] || PROGRESSIONS.drift;
    return prog[S.chordIndex % prog.length];
}

// ═══════════════════════════════════════════════════════════════════════════════
// DRUMS — Layered, noise-based
// ═══════════════════════════════════════════════════════════════════════════════

function createDrums() {
    DRUMS.kickBody = new Tone.MembraneSynth({
        pitchDecay: 0.07, octaves: 8,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.002, decay: 0.5, sustain: 0, release: 0.35 },
        volume: -6
    }).connect(FX.drumBus);

    DRUMS.kickSub = new Tone.Oscillator({ frequency: 50, type: 'sine' });
    DRUMS.kickSubGain = new Tone.Gain(0).connect(FX.drumBus);
    DRUMS.kickSub.connect(DRUMS.kickSubGain);
    DRUMS.kickSub.start();

    const kickClickF = new Tone.Filter({ frequency: 3000, type: 'bandpass', Q: 2 }).connect(FX.drumBus);
    DRUMS.kickClick = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.015, sustain: 0, release: 0.008 },
        volume: -14
    }).connect(kickClickF);

    DRUMS.snareBody = new Tone.MembraneSynth({
        pitchDecay: 0.01, octaves: 3.5,
        oscillator: { type: 'triangle' },
        envelope: { attack: 0.001, decay: 0.1, sustain: 0, release: 0.06 },
        volume: -9
    }).connect(FX.drumBus);

    const snareCrackF = new Tone.Filter({ frequency: 3500, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.snareCrack = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.08, sustain: 0, release: 0.03 },
        volume: -8
    }).connect(snareCrackF);

    const snareTailF = new Tone.Filter({ frequency: 2000, type: 'bandpass', Q: 1.5 }).connect(FX.drumBus);
    DRUMS.snareTail = new Tone.NoiseSynth({
        noise: { type: 'pink' },
        envelope: { attack: 0.001, decay: 0.18, sustain: 0, release: 0.06 },
        volume: -12
    }).connect(snareTailF);
    DRUMS.snareTail.connect(FX.drumRoomSend);

    const hatF = new Tone.Filter({ frequency: 9000, type: 'highpass' }).connect(FX.drumBus);
    const hatBP = new Tone.Filter({ frequency: 10000, type: 'bandpass', Q: 0.8 }).connect(hatF);
    DRUMS.hat = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.035, sustain: 0, release: 0.01 },
        volume: -14
    }).connect(hatBP);

    const openHatF = new Tone.Filter({ frequency: 7000, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.openHat = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.001, decay: 0.22, sustain: 0.02, release: 0.08 },
        volume: -16
    }).connect(openHatF);

    const crashF = new Tone.Filter({ frequency: 4000, type: 'highpass' }).connect(FX.drumBus);
    DRUMS.crash = new Tone.NoiseSynth({
        noise: { type: 'white' },
        envelope: { attack: 0.005, decay: 1.8, sustain: 0.01, release: 0.4 },
        volume: -18
    }).connect(crashF);
    DRUMS.crash.connect(FX.drumRoomSend);

    DRUMS.tom = new Tone.MembraneSynth({
        pitchDecay: 0.06, octaves: 4,
        oscillator: { type: 'sine' },
        envelope: { attack: 0.001, decay: 0.25, sustain: 0, release: 0.15 },
        volume: -10
    }).connect(FX.drumBus);
    DRUMS.tom.connect(FX.drumRoomSend);
}

function triggerKick(t, vel) {
    DRUMS.kickBody.triggerAttackRelease('C1', '8n', t, vel);
    DRUMS.kickClick.triggerAttackRelease('32n', t, vel * 0.7);
    DRUMS.kickSubGain.gain.cancelScheduledValues(t);
    DRUMS.kickSubGain.gain.setValueAtTime(vel * 0.12, t);
    DRUMS.kickSubGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
}

function triggerSnare(t, vel) {
    DRUMS.snareBody.triggerAttackRelease('E3', '16n', t, vel);
    DRUMS.snareCrack.triggerAttackRelease('16n', t, vel * 0.9);
    DRUMS.snareTail.triggerAttackRelease('16n', t, vel * 0.5);
}

// ═══════════════════════════════════════════════════════════════════════════════
// GROOVE ENGINE — Drums + bass + arp, all user-responsive
// ═══════════════════════════════════════════════════════════════════════════════

function runGroove() {
    if (!S.groovePlaying) return;

    const stepDur = (60 / S.bpm) / 4;
    const lookAhead = 0.1;
    const e = S.energy;
    // Intensity scales with energy — less energy = quieter drums
    const intensity = 0.3 + e * 0.7;
    const chord = getChord();
    const tierIdx = TIERS.indexOf(S.tier);
    // Movement flag — bass/arp only play when user is actually moving or touching
    const userActive = S.speed > 0.02 || S.touching;

    while (S.nextStepTime < Tone.now() + lookAhead) {
        const step = S.grooveStep;
        const now = Math.max(Tone.now(), S.nextStepTime);

        const isFill = S.fillCountdown > 0;
        const patName = isFill ? 'fill' : (S.tier.pat || 'groove');
        const pat = DRUM_PATTERNS[patName] || DRUM_PATTERNS.groove;

        // Humanize
        const jit = (Math.random() - 0.5) * 0.005;
        const vVar = 0.88 + Math.random() * 0.24;
        const t = now + jit;

        // ── DRUMS ──
        if (pat.K[step]) {
            triggerKick(t, pat.K[step] * intensity * vVar);
            FX.sidechain.gain.cancelScheduledValues(t);
            FX.sidechain.gain.setValueAtTime(1, t);
            FX.sidechain.gain.linearRampToValueAtTime(0.25, t + 0.015);
            FX.sidechain.gain.linearRampToValueAtTime(1, t + 0.12);
        }
        if (pat.SN[step]) {
            triggerSnare(t, pat.SN[step] * intensity * vVar);
        }
        if (pat.HH[step]) {
            DRUMS.hat.triggerAttackRelease('32n', t, pat.HH[step] * intensity * vVar * 0.7);
        }
        if (pat.OH && pat.OH[step]) {
            DRUMS.openHat.triggerAttackRelease('8n', t, pat.OH[step] * intensity * vVar);
        }

        // Tom fills
        if (isFill && step >= 8 && step % 2 === 0) {
            const tomNotes = ['G2', 'D2', 'A1', 'E1'];
            DRUMS.tom.triggerAttackRelease(tomNotes[Math.floor((step-8)/2) % 4], '16n', t, 0.5 + Math.random() * 0.3);
        }
        if (isFill) S.fillCountdown--;

        // ── WALKING BASS — only when user is active ──
        if (userActive && BASS && tierIdx >= 4 && step % 4 === 0) {
            const beatIdx = step / 4;
            const bassPat = BASS_PATTERNS[S.bassPatIdx % BASS_PATTERNS.length];
            const bassNote = chord[0] + S.transpose + bassPat[beatIdx % bassPat.length] - 24;
            BASS.triggerAttackRelease(noteFreq(bassNote), '4n', t, 0.45 + e * 0.35);
        }

        // ── ARP — only during sustained touch ──
        if (S.touchActive && ARP && tierIdx >= 5) {
            const arpRate = tierIdx >= 7 ? 1 : 2;
            if (step % arpRate === 0) {
                const patArr = ARP_PATTERNS[S.arpPattern] || ARP_PATTERNS.up;
                const spread = [];
                chord.forEach(n => { spread.push(n); spread.push(n + 12); });
                spread.sort((a, b) => a - b);
                const idx = patArr[S.arpStep % patArr.length] % spread.length;
                // Arp note pitch influenced by touch Y position
                const octShift = Math.floor((1 - S.touchY) * 2) * 12;
                const arpNote = spread[idx] + S.transpose + octShift;
                const accent = (S.arpStep % patArr.length === 0) ? 0.4 : 0.25;
                ARP.triggerAttackRelease(noteFreq(arpNote), arpRate === 1 ? '16n' : '8n', t, accent);
                S.arpStep++;
            }
        }

        const sw = step % 2 === 0 ? 1 + SWING : 1 - SWING;
        S.nextStepTime += stepDur * sw;
        S.grooveStep = (step + 1) % 16;
    }
}

function startGroove() {
    if (S.groovePlaying) return;
    S.groovePlaying = true;
    S.nextStepTime = Tone.now() + 0.05;
    S.grooveStep = 0;
    notify('GROOVE');
}

function stopGroove() { S.groovePlaying = false; }

function triggerFill() {
    S.fillCountdown = 16;
    DRUMS.crash.triggerAttackRelease('2n', Tone.now(), 0.3);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BASS + ARP SYNTHS
// ═══════════════════════════════════════════════════════════════════════════════

function createBass() {
    BASS = new Tone.FMSynth({
        harmonicity: 1, modulationIndex: 0.5,
        oscillator: { type: 'triangle' },
        modulation: { type: 'sine' },
        envelope: { attack: 0.01, decay: 0.3, sustain: 0.4, release: 0.12 },
        modulationEnvelope: { attack: 0.01, decay: 0.2, sustain: 0.3, release: 0.1 },
        volume: -10
    }).connect(FX.bassBus);
}

function createArp() {
    ARP = new Tone.PolySynth(Tone.FMSynth);
    ARP.maxPolyphony = 4;
    ARP.set({
        modulationIndex: 2.5, harmonicity: 3,
        oscillator: { type: 'sine' },
        modulation: { type: 'triangle' },
        envelope: { attack: 0.005, decay: 0.12, sustain: 0.04, release: 0.25 },
        modulationEnvelope: { attack: 0.01, decay: 0.08, sustain: 0.15, release: 0.15 },
        volume: -16
    });
    ARP.connect(FX.arpBus);
}

// ═══════════════════════════════════════════════════════════════════════════════
// MELODY — Touch-triggered
// ═══════════════════════════════════════════════════════════════════════════════

function createMelody() {
    MELODY = new Tone.PolySynth(Tone.FMSynth);
    MELODY.maxPolyphony = 8;
    MELODY.set({
        modulationIndex: 3, harmonicity: 2,
        oscillator: { type: 'sine' },
        modulation: { type: 'triangle' },
        envelope: { attack: 0.06, decay: 0.35, sustain: 0.12, release: 0.7 },
        modulationEnvelope: { attack: 0.08, decay: 0.2, sustain: 0.3, release: 0.4 },
        volume: -10
    });
    MELODY.connect(FX.melodySend);
}

function playNote(x, y, vel) {
    if (!MELODY) return;
    const scale = SCALES[S.activeScale] || SCALES.minor;
    const tr = S.transpose;
    const notes = [];
    for (let oct = -1; oct <= 2; oct++) {
        scale.forEach(s => notes.push(s + tr + oct * 12));
    }
    notes.sort((a, b) => a - b);

    const idx = Math.floor((1 - y) * notes.length);
    const note = notes[Math.max(0, Math.min(idx, notes.length - 1))];
    MELODY.triggerAttackRelease(noteFreq(note), 0.25 + vel * 0.2, Tone.now(), Math.min(1, vel * 0.8));
    S.particles.push({ x: x * window.innerWidth, y: y * window.innerHeight, birth: performance.now(), vel });
}

function triggerPhrase(type) {
    if (!MELODY) return;
    const chord = getChord();
    const base = chord[0] + S.transpose;
    const now = Tone.now();

    if (type === 'SHAKE') {
        for (let i = 0; i < 8; i++) {
            const semi = i % 2 === 0 ? base : base + 3;
            MELODY.triggerAttackRelease(noteFreq(semi + (i < 4 ? 0 : 12)), 0.05, now + i * 0.06, 0.5);
        }
        notify('TRILL');
    } else if (type === 'SWIPE_UP') {
        chord.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose + 12), 0.2, now + i * 0.1, 0.6 - i * 0.1);
        });
        MELODY.triggerAttackRelease(noteFreq(chord[0] + S.transpose + 24), 0.3, now + chord.length * 0.1, 0.4);
        // Swipe up advances chord
        advanceChord();
        notify('RISE');
    } else if (type === 'SWIPE_DOWN') {
        const rev = [...chord].reverse();
        rev.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose + 12), 0.2, now + i * 0.1, 0.6 - i * 0.1);
        });
        MELODY.triggerAttackRelease(noteFreq(chord[0] + S.transpose - 12), 0.4, now + rev.length * 0.1, 0.4);
        advanceChord();
        notify('FALL');
    } else if (type === 'HOLD') {
        chord.forEach((n, i) => {
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose), 2.5, now + i * 0.04, 0.3);
            MELODY.triggerAttackRelease(noteFreq(n + S.transpose + 12), 2.5, now + i * 0.04 + 0.02, 0.2);
        });
        advanceChord();
        notify('SWELL');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// SECTIONS
// ═══════════════════════════════════════════════════════════════════════════════

function updateSection(dt) {
    const e = S.energy;
    const idx = S.sectionIndex;

    if (S.section.name === 'SUMMIT' && e < 0.35) {
        S.sectionHoldTimer += dt;
        if (S.sectionHoldTimer > 20) changeSection(4);
    } else if (S.section.name === 'DESCEND' && e < 0.1) {
        S.sectionHoldTimer += dt;
        if (S.sectionHoldTimer > 15) changeSection(0);
    } else if (idx < 3) {
        const next = SECTIONS[idx + 1];
        if (e >= next.threshold) {
            S.sectionHoldTimer += dt;
            if (S.sectionHoldTimer > next.holdTime) changeSection(idx + 1);
        } else {
            // Decay the timer — you have to SUSTAIN the energy
            S.sectionHoldTimer = Math.max(0, S.sectionHoldTimer - dt * 3);
        }
    } else {
        S.sectionHoldTimer = Math.max(0, S.sectionHoldTimer - dt);
    }
}

function changeSection(idx) {
    if (idx === S.sectionIndex) return;
    S.sectionIndex = idx;
    S.section = SECTIONS[idx];
    S.sectionHoldTimer = 0;
    S.transpose = S.section.tr;
    S.chordIndex = 0;

    if (!S.weatherScale) S.activeScale = S.section.scale;

    S.bpm = Math.round(S.baseBpm * S.section.tempoMul + S.weatherTempo);
    FX.delay.delayTime.rampTo(60 / S.bpm / 2, 2);

    if (S.groovePlaying) triggerFill();
    glideChord(getChord(), 1.2);

    const arpKeys = Object.keys(ARP_PATTERNS);
    S.arpPattern = arpKeys[idx % arpKeys.length];
    S.bassPatIdx = idx;
    S.arpStep = 0;

    notify(S.section.name);
    document.getElementById('sectionName').textContent = S.section.name;
}

// ═══════════════════════════════════════════════════════════════════════════════
// VOICE SHAPING — Tilt = direct sonic control
// ═══════════════════════════════════════════════════════════════════════════════

function shapeVoices() {
    const e = S.energy;
    const tier = S.tier;
    // Tilt Y = brightness (0 to 1) — DIRECTLY controls the main filter
    const brightness = (S.tiltY + 1) * 0.5;
    const now = performance.now();

    // ── TILT = MASTER FILTER (the key relationship) ──
    // Tilt Y sweeps dust filter from 2000Hz (dark) to 12000Hz (bright)
    const dustFreq = 2000 + brightness * 10000 * (0.3 + e * 0.7);
    FX.dust.frequency.rampTo(Math.min(14000, dustFreq), 0.08);

    // Slow organic oscillations
    const breathe1 = Math.sin(now * 0.0008) * 0.5 + 0.5;
    const breathe2 = Math.sin(now * 0.0012 + 1.2) * 0.5 + 0.5;
    const breathe3 = Math.sin(now * 0.0005 + 2.4) * 0.5 + 0.5;

    const layers = [
        { name: 'lead',    minV: 1, vol: 0.13, bCut: 500,  mCut: 4500, mod: breathe1 * 0.1 },
        { name: 'sub',     minV: 2, vol: 0.14, bCut: 200,  mCut: 600,  mod: 0 },
        { name: 'pad',     minV: 3, vol: 0.07, bCut: 400,  mCut: 3000, mod: breathe2 * 0.12 },
        { name: 'strings', minV: 4, vol: 0.05, bCut: 600,  mCut: 5000, mod: breathe3 * 0.1 },
        { name: 'brass',   minV: 5, vol: 0.04, bCut: 400,  mCut: 3000, mod: breathe1 * 0.06 },
        { name: 'choir',   minV: 6, vol: 0.03, bCut: 1000, mCut: 7000, mod: breathe2 * 0.06 },
    ];

    layers.forEach(({ name, minV, vol, bCut, mCut, mod }) => {
        const layer = V[name];
        if (!layer) return;

        let amp, cutoff;
        if (tier.voices < minV) {
            amp = 0;
            cutoff = bCut;
        } else {
            const headroom = Math.min(1, (e - (tier.e || 0)) * 4);
            amp = (vol + mod) * headroom;
            // Per-voice filter also follows brightness
            cutoff = bCut + (mCut - bCut) * brightness * headroom;

            if (S.breathPhase === 'inhale') {
                amp *= 0.3 + S.breathProgress * 0.7;
                cutoff *= 0.5 + S.breathProgress * 0.5;
            } else if (S.breathPhase === 'exhale') {
                const ease = 1 - S.breathProgress * S.breathProgress;
                amp *= Math.max(0.2, ease);
                cutoff *= Math.max(0.3, ease);
            }
        }

        if (S.micActive && S.micCentroid > 0.1) cutoff += S.micCentroid * 800;

        cutoff = Math.max(150, Math.min(9000, cutoff));
        layer.gain.gain.rampTo(amp, 0.15);
        layer.filter.frequency.rampTo(cutoff, 0.15);
    });

    // Lead expression: tilt X = pitch bend + vibrato deepens with energy
    if (V.lead && V.lead.oscs[0]) {
        const vibrato = Math.sin(now * 0.028) * (2 + e * 10);
        V.lead.oscs[0].detune.rampTo(S.tiltX * 40 + vibrato, 0.05);
    }

    // Speed modulates FM modulation index — faster = more harmonic complexity
    if (V.lead && V.lead.oscs[0].modulationIndex) {
        const targetMod = 1.2 + S.smoothSpeed * 8;
        try { V.lead.oscs[0].modulationIndex.rampTo(targetMod, 0.2); } catch(e) {}
    }

    // Pad detuning widens with energy
    if (V.pad) {
        V.pad.oscs.forEach((osc, i) => {
            if (i > 0) osc.detune.rampTo((i - 1) * 10 + e * 8, 0.3);
        });
    }

    // Effects follow energy + section
    const revWet = S.weatherReverb + e * 0.08 + (S.sectionIndex >= 3 ? 0.05 : 0);
    FX.reverb.wet.rampTo(Math.min(0.4, revWet), 0.3);
    FX.delay.wet.rampTo(0.05 + S.sectionIndex * 0.02 + e * 0.03, 0.3);
    FX.chorus.depth = 0.2 + brightness * 0.3;
}

// ═══════════════════════════════════════════════════════════════════════════════
// TIER + CHORD
// ═══════════════════════════════════════════════════════════════════════════════

function updateTier() {
    let newTier = TIERS[0];
    for (const t of TIERS) {
        if (S.energy >= t.e) newTier = t;
    }
    if (newTier.name !== S.tier.name) {
        const prevIdx = TIERS.indexOf(S.tier);
        const newIdx = TIERS.indexOf(newTier);
        S.prevTier = S.tier;
        S.tier = newTier;
        document.getElementById('stageName').textContent = newTier.name;
        if (newTier.name !== 'SILENCE') notify(newTier.name);

        if (newTier.drums && !S.groovePlaying) startGroove();
        if (!newTier.drums && S.groovePlaying) stopGroove();

        if (newIdx > prevIdx && S.groovePlaying && newIdx >= 5) triggerFill();
        if (newIdx - prevIdx >= 2 && newIdx >= 4) {
            DRUMS.crash.triggerAttackRelease('2n', Tone.now(), 0.25);
        }
    }
}

function advanceChord() {
    S.chordIndex++;
    glideChord(getChord());
    if (S.chordIndex % 4 === 0) {
        S.bassPatIdx = (S.bassPatIdx + 1) % BASS_PATTERNS.length;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// BREATH DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

function detectBreath() {
    const z = S.accelZ;
    const now = performance.now();

    S.azSmooth = S.azSmooth * 0.82 + z * 0.18;
    S.azHist.push({ z: S.azSmooth, t: now });
    if (S.azHist.length > 300) S.azHist = S.azHist.slice(-200);
    if (S.azHist.length < 30) return;

    const win = S.azHist.slice(-80);
    const vals = win.map(h => h.z);
    const lo = Math.min(...vals), hi = Math.max(...vals);
    const range = hi - lo, mid = (lo + hi) / 2;
    S.breathDepth = Math.min(1, range * 2.5);

    if (range < 0.08) { S.breathPhase = 'none'; return; }

    const tail = S.azHist.slice(-12);
    let trend = 0;
    for (let i = 1; i < tail.length; i++) trend += tail[i].z - tail[i - 1].z;
    trend /= tail.length;

    if (S.breathPhase === 'none' || S.breathPhase === 'valley') {
        if (trend > 0.004 && S.azSmooth > lo + range * 0.25) {
            S.breathPhase = 'inhale';
            S.breathStart = now;
        }
    } else if (S.breathPhase === 'inhale') {
        S.breathProgress = Math.min(1, (now - S.breathStart) / (S.breathDur * 0.4));
        if (trend < 0.001 && S.azSmooth > mid + range * 0.2) {
            S.breathPhase = 'peak';
            S.lastPeakTime = now;
        }
    } else if (S.breathPhase === 'peak') {
        if (trend < -0.003) S.breathPhase = 'exhale';
    } else if (S.breathPhase === 'exhale') {
        S.breathProgress = Math.min(1, (now - S.lastPeakTime) / (S.breathDur * 0.5));
        if (S.azSmooth < mid - range * 0.15 && trend > -0.002) {
            S.breathPhase = 'valley';
            const dur = now - S.breathStart;
            if (dur > 1500 && dur < 12000) {
                S.breathDurs.push(dur);
                if (S.breathDurs.length > 8) S.breathDurs.shift();
                S.breathDur = S.breathDurs.reduce((a, b) => a + b) / S.breathDurs.length;
            }
            S.energy = Math.min(1, S.energy + 0.02 + S.breathDepth * 0.03);
            if (S.breathDepth > 0.3) advanceChord();
            S.rings.push({ birth: performance.now(), depth: S.breathDepth });
        }
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// GESTURE DETECTION
// ═══════════════════════════════════════════════════════════════════════════════

function detectGesture() {
    if (S.gestureCooldown > 0) { S.gestureCooldown--; return; }
    const buf = S.gestureBuffer;
    if (buf.length < 10) return;

    let totalSpeed = 0, dirChanges = 0, netX = 0, netY = 0;
    for (let i = 1; i < buf.length; i++) {
        const dx = buf[i].x - buf[i-1].x, dy = buf[i].y - buf[i-1].y;
        totalSpeed += Math.sqrt(dx*dx + dy*dy);
        netX += dx; netY += dy;
        if (i > 1 && (dx * (buf[i-1].x - buf[i-2].x) < 0 || dy * (buf[i-1].y - buf[i-2].y) < 0)) dirChanges++;
    }
    const avg = totalSpeed / buf.length;

    if (avg > 0.03 && dirChanges >= 4) {
        triggerPhrase('SHAKE'); S.gestureCooldown = 30;
    } else if (avg > 0.02 && Math.abs(netY) > 0.2) {
        triggerPhrase(netY < 0 ? 'SWIPE_UP' : 'SWIPE_DOWN'); S.gestureCooldown = 20;
    } else if (avg < 0.003 && S.stillness > 80 && S.energy > 0.1) {
        triggerPhrase('HOLD'); S.gestureCooldown = 150;
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// INPUT — Sensor permissions requested on FIRST TOUCH (iOS fix)
// ═══════════════════════════════════════════════════════════════════════════════

async function requestSensors() {
    if (S.sensorsGranted) return;
    S.sensorsGranted = true;

    if (typeof DeviceMotionEvent !== 'undefined') {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
            try {
                const r = await DeviceMotionEvent.requestPermission();
                if (r === 'granted') window.addEventListener('devicemotion', onMotion);
            } catch(e) {}
        } else { window.addEventListener('devicemotion', onMotion); }
    }
    if (typeof DeviceOrientationEvent !== 'undefined') {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            try {
                const r = await DeviceOrientationEvent.requestPermission();
                if (r === 'granted') window.addEventListener('deviceorientation', onOrientation);
            } catch(e) {}
        } else { window.addEventListener('deviceorientation', onOrientation); }
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    S.accelX = a.x || 0; S.accelY = a.y || 0; S.accelZ = a.z || 0;
    const motion = Math.sqrt(S.accelX**2 + S.accelY**2 + S.accelZ**2);
    const deviation = Math.abs(motion - 9.8);
    S.speed = S.speed * 0.8 + Math.min(1, deviation * 0.4) * 0.2;
}

function onOrientation(e) {
    S.tiltX = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    S.tiltY = Math.max(-1, Math.min(1, ((e.beta || 45) - 45) / 45));
}

function setupTouch() {
    const onDown = (x, y) => {
        // Request sensors on first touch (iOS needs fresh user gesture context)
        requestSensors();
        // Safety: resume AudioContext if it got suspended
        if (Tone.context.state !== 'running') {
            Tone.context.resume();
        }

        S.touching = true;
        S.touchActive = true;
        S.touchX = x; S.touchY = y;
        // Touch serves as tilt fallback
        S.tiltX = (x - 0.5) * 2;
        S.tiltY = (y - 0.5) * 2;
        playNote(x, y, 0.65);
        S.energy = Math.min(1, S.energy + 0.008);
    };

    const onMove = (x, y) => {
        if (!S.touching) return;
        const dist = Math.sqrt((x - S.touchX)**2 + (y - S.touchY)**2);
        if (dist > 0.015) {
            playNote(x, y, 0.3 + Math.min(1, dist * 4));
            S.energy = Math.min(1, S.energy + dist * 0.08);
            S.speed = S.speed * 0.7 + dist * 5 * 0.3;
        }
        S.touchX = x; S.touchY = y;
        S.tiltX = (x - 0.5) * 2;
        S.tiltY = (y - 0.5) * 2;
    };

    document.addEventListener('touchstart', (e) => {
        e.preventDefault();
        const t = e.touches[0];
        onDown(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchend', (e) => {
        e.preventDefault();
        S.touching = false;
        S.touchActive = false;
    }, { passive: false });

    document.addEventListener('mousedown', (e) => {
        onDown(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });
    document.addEventListener('mousemove', (e) => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });
    document.addEventListener('mouseup', () => { S.touching = false; S.touchActive = false; });
}

// ═══════════════════════════════════════════════════════════════════════════════
// ENVIRONMENT
// ═══════════════════════════════════════════════════════════════════════════════

function fetchWeather() {
    if (!navigator.geolocation) return;
    navigator.geolocation.getCurrentPosition(async (pos) => {
        try {
            const { latitude, longitude } = pos.coords;
            const resp = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current=temperature_2m,weathercode`);
            const data = await resp.json();
            const temp = data.current.temperature_2m;
            const code = data.current.weathercode;

            if (temp < 10) { S.weatherTempo = -10; S.baseBpm = 75; }
            else if (temp < 25) { S.weatherTempo = 0; S.baseBpm = 85; }
            else { S.weatherTempo = 10; S.baseBpm = 95; }

            S.bpm = Math.round(S.baseBpm * S.section.tempoMul + S.weatherTempo);
            FX.delay.delayTime.rampTo(60 / S.bpm / 2, 1);

            if (code >= 51 && code <= 67) { S.weatherReverb = 0.35; S.weatherScale = 'minor'; }
            else if (code >= 71 && code <= 77) { S.weatherReverb = 0.4; S.weatherScale = 'dorian'; }
            else if (code >= 95) { S.weatherScale = 'phrygian'; S.weatherReverb = 0.3; }
            else if (code >= 45 && code <= 48) { S.weatherReverb = 0.38; S.weatherScale = 'dorian'; }
            else { S.weatherScale = null; }

            if (S.weatherScale) S.activeScale = S.weatherScale;
            FX.reverb.wet.rampTo(S.weatherReverb, 2);

            const cond = code === 0 ? 'clear' : code <= 3 ? 'cloudy' :
                code <= 48 ? 'fog' : code <= 67 ? 'rain' : code <= 77 ? 'snow' : 'storm';
            document.getElementById('weatherInfo').textContent = `${Math.round(temp)}° ${cond}`;
        } catch(e) {}
    }, () => {}, { timeout: 5000 });
}

async function initMicrophone() {
    if (S.micActive) return;
    try {
        MIC = new Tone.UserMedia();
        await MIC.open();
        const analyser = new Tone.Analyser('fft', 256);
        MIC.connect(analyser);
        S.micActive = true;
        document.getElementById('micBtn').classList.add('on');

        setInterval(() => {
            if (!S.micActive) return;
            const sp = analyser.getValue();
            let sum = 0, wSum = 0, tPow = 0;
            for (let i = 0; i < sp.length; i++) {
                const p = Math.pow(10, sp[i] / 20);
                sum += p; wSum += p * i; tPow += p;
            }
            S.micLevel = Math.min(1, sum / sp.length * 10);
            S.micCentroid = tPow > 0 ? (wSum / tPow) / sp.length : 0;
        }, 100);
    } catch(e) {
        notify('MIC DENIED');
    }
}

// ═══════════════════════════════════════════════════════════════════════════════
// VISUALIZATION
// ═══════════════════════════════════════════════════════════════════════════════

let canvas, vc;

function initCanvas() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    onResize();
    window.addEventListener('resize', onResize);
}

function onResize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    canvas.style.width = window.innerWidth + 'px';
    canvas.style.height = window.innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth, h = window.innerHeight;
    const now = performance.now();
    const cx = w / 2 + S.tiltX * w * 0.2;
    const cy = h / 2 + S.tiltY * h * 0.2;
    const e = S.energy;
    const tierIdx = TIERS.indexOf(S.tier);
    const pal = PALETTES[S.section.name] || PALETTES.DRIFT;
    const hue = pal.h + tierIdx * 6;

    // Fade — slower clear = more trails at high energy
    vc.fillStyle = `rgba(5, 5, 5, ${0.08 + (1 - e) * 0.05})`;
    vc.fillRect(0, 0, w, h);

    // Section mood glow
    if (e > 0.15) {
        const bg = vc.createRadialGradient(cx, cy, 0, cx, cy, Math.min(w, h) * 0.6);
        bg.addColorStop(0, `hsla(${hue}, ${pal.s}%, ${pal.l * 0.3}%, ${e * 0.02})`);
        bg.addColorStop(1, 'transparent');
        vc.fillStyle = bg;
        vc.fillRect(0, 0, w, h);
    }

    // Breath rings
    for (let i = S.rings.length - 1; i >= 0; i--) {
        const ring = S.rings[i];
        const age = (now - ring.birth) / 1000;
        if (age > 20) { S.rings.splice(i, 1); continue; }
        const r = 30 + age * 18;
        const alpha = Math.max(0, 0.15 - age * 0.008) * ring.depth;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue}, ${pal.s}%, ${pal.l + 10}%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    }

    // Energy rings
    const numRings = Math.min(6, S.tier.voices);
    for (let i = 0; i < numRings; i++) {
        const r = 50 + i * 40 + Math.sin(now * 0.001 + i) * 5 + e * 25;
        const alpha = 0.05 + e * 0.15;
        vc.beginPath();
        vc.arc(cx, cy, r, 0, TAU);
        vc.strokeStyle = `hsla(${hue + i * 20}, ${pal.s + e * 20}%, ${pal.l + e * 10}%, ${alpha})`;
        vc.lineWidth = 1.5 + e;
        vc.stroke();
    }

    // Core orb
    const coreR = 15 + e * 25 + S.smoothSpeed * 25;
    const grad = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    grad.addColorStop(0, `hsla(${hue}, ${pal.s + 20}%, ${pal.l + 15}%, ${0.5 + e * 0.5})`);
    grad.addColorStop(0.5, `hsla(${hue}, ${pal.s}%, ${pal.l}%, ${0.2 + e * 0.25})`);
    grad.addColorStop(1, 'transparent');
    vc.fillStyle = grad;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, TAU);
    vc.fill();

    // Voice orbit dots
    for (let i = 0; i < numRings; i++) {
        const angle = (i / Math.max(1, numRings)) * TAU + now * 0.0005;
        const dist = 50 + i * 40;
        vc.beginPath();
        vc.arc(cx + Math.cos(angle) * dist, cy + Math.sin(angle) * dist, 2 + e, 0, TAU);
        vc.fillStyle = `hsla(${hue + i * 20}, ${pal.s + 10}%, ${pal.l + 15}%, ${0.1 + e * 0.2})`;
        vc.fill();
    }

    // Touch particles
    for (let i = S.particles.length - 1; i >= 0; i--) {
        const p = S.particles[i];
        const age = (now - p.birth) / 1000;
        if (age > 1.5) { S.particles.splice(i, 1); continue; }
        const alpha = Math.max(0, 0.6 - age * 0.4) * p.vel;
        vc.beginPath();
        vc.arc(p.x, p.y, 3 + age * 20, 0, TAU);
        vc.strokeStyle = `hsla(${hue + 40}, ${pal.s + 15}%, ${pal.l + 15}%, ${alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    }

    // Speed trail
    if (S.smoothSpeed > 0.05) {
        const len = S.smoothSpeed * 100;
        vc.beginPath();
        vc.moveTo(cx, cy);
        vc.lineTo(cx - S.tiltX * len, cy - S.tiltY * len);
        vc.strokeStyle = `hsla(${hue}, ${pal.s}%, ${pal.l + 10}%, ${S.smoothSpeed * 0.4})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Edge glow at high tiers
    if (tierIdx >= 6) {
        const glow = vc.createRadialGradient(w/2, h/2, Math.min(w,h)*0.25, w/2, h/2, Math.min(w,h)*0.65);
        glow.addColorStop(0, 'transparent');
        glow.addColorStop(1, `hsla(${hue + 30}, ${pal.s + 10}%, ${pal.l}%, ${(e - 0.6) * 0.1})`);
        vc.fillStyle = glow;
        vc.fillRect(0, 0, w, h);
    }

    document.getElementById('energyFill').style.width = (e * 100) + '%';
}

// ═══════════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════════

let lastFrame = 0;

function loop(ts) {
    if (!S.active) { requestAnimationFrame(loop); return; }

    const dt = Math.min(50, ts - lastFrame) / 1000;
    lastFrame = ts;

    // ── ENERGY — slow build, slow decay, the journey is EARNED ──
    if (S.speed > 0.02) {
        // Movement adds energy — slowly
        S.energy = Math.min(1, S.energy + S.speed * 0.008);
        S.stillness = 0;
    } else {
        // Slow decay per frame — matches gump-unified's 0.997 per-frame decay
        // At 60fps this takes ~40 seconds to go from 1.0 to 0.1
        S.energy *= 0.997;
        S.stillness += dt * 10;
    }

    // Touch adds energy — very gently
    if (S.touching) {
        S.energy = Math.min(1, S.energy + dt * 0.012);
    }

    S.smoothSpeed = S.smoothSpeed * 0.92 + S.speed * 0.08;
    S.peakEnergy = Math.max(S.peakEnergy, S.energy);

    // NO auto chord timer — chords only advance via gestures, breath, or phrases

    // Gesture buffer
    S.gestureBuffer.push({ x: S.tiltX, y: S.tiltY, speed: S.speed, time: performance.now() });
    if (S.gestureBuffer.length > 30) S.gestureBuffer.shift();

    // Systems
    detectBreath();
    detectGesture();
    updateTier();
    updateSection(dt);
    shapeVoices();
    if (S.groovePlaying) runGroove();
    draw();

    requestAnimationFrame(loop);
}

// ═══════════════════════════════════════════════════════════════════════════════
// BOOTSTRAP
// ═══════════════════════════════════════════════════════════════════════════════

let notifTimer = null;
function notify(text) {
    const el = document.getElementById('notif');
    el.textContent = text;
    el.classList.add('show');
    if (notifTimer) clearTimeout(notifTimer);
    notifTimer = setTimeout(() => el.classList.remove('show'), 1800);
}

async function begin() {
    try {
        // Tone.start() MUST be first — it needs the user gesture context on iOS
        // Do NOT call requestSensors() here — it shows permission dialogs that
        // consume the gesture context. Sensors are requested on first touch instead.
        await Tone.start();
        await initAudio();
        initCanvas();
        setupTouch();

        document.getElementById('entry').classList.add('gone');
        document.getElementById('sectionName').textContent = 'DRIFT';

        setTimeout(() => { document.getElementById('micBtn').style.display = 'block'; }, 3000);
        fetchWeather();

        S.active = true;
        lastFrame = performance.now();
        requestAnimationFrame(loop);
    } catch(e) {
        console.error('Start failed:', e);
        document.getElementById('err').textContent = 'Error: ' + e.message;
        document.getElementById('err').style.display = 'flex';
    }
}

document.getElementById('micBtn').addEventListener('click', (e) => { e.stopPropagation(); initMicrophone(); });
document.getElementById('begin').addEventListener('click', begin);
document.getElementById('begin').addEventListener('touchstart', (e) => { e.preventDefault(); begin(); }, { passive: false });
document.addEventListener('contextmenu', (e) => e.preventDefault());

})();
</script>
</body>
</html>
