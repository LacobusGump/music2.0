<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <script src="https://unpkg.com/@magenta/music@1.5.5"></script>
    <script src="https://unpkg.com/essentia.js@0.1.3/dist/essentia.js-core.js"></script>
    <script src="https://unpkg.com/soundtouch-js@0.0.3/soundtouch.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #111;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 2s ease;
        }
        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.1) 0%, transparent 70%);
            border: 2px solid rgba(255, 165, 0, 0.3);
            color: #ffa500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
            z-index: 100;
        }
        .start-btn:hover {
            border-color: rgba(255, 165, 0, 0.6);
            transform: scale(1.05);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 165, 0, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(255, 165, 0, 0.4); }
        }
        .orb {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.8) 0%, rgba(255, 165, 0, 0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
            opacity: 0;
        }
        .orb.active { opacity: 1; }
        .orb.recording {
            background: radial-gradient(circle, rgba(0, 255, 0, 0.8) 0%, rgba(0, 255, 0, 0.3) 50%, transparent 80%);
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
            animation: recordingPulse 1s ease-in-out infinite;
        }
        @keyframes recordingPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        .waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 2px;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .waveform.active { opacity: 1; }
        .wave-bar {
            width: 4px;
            height: 2px;
            background: rgba(255, 165, 0, 0.6);
            transition: height 0.1s ease;
            border-radius: 2px;
        }
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 165, 0, 0.4);
            animation: float 8s linear infinite;
        }
        @keyframes float {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(-20vh) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="startBtn" class="start-btn">GUMP</div>
    <div id="orb" class="orb"></div>
    <div id="waveform" class="waveform"></div>
    <div class="particles" id="particles"></div>

    <script>
        class RichLofiEngine {
            constructor() {
                this.mic = null;
                this.analyser = null;
                this.mixRecorder = null;
                this.isRecordingSample = false;
                this.lastSampleTime = 0;
                this.samples = { drums: [], bass: [], melody: [], pads: [] };
                this.samplers = {};
                this.effects = {};
                this.motion = 0;
                this.pos = { x: 0, y: 0, z: 0 };
                this.orientation = { alpha: 0, beta: 0, gamma: 0 };
                this.motionHistory = [];
                this.bpmHistory = [];
                this.elements = {
                    startBtn: document.getElementById('startBtn'),
                    orb: document.getElementById('orb'),
                    waveform: document.getElementById('waveform'),
                    particles: document.getElementById('particles')
                };
                this.waveBars = [];
                this.bpm = 85;
                this.key = 'Cminor';
                this.active = false;
                this.essentia = null;
                this.musicRNN = null;
                this.soundTouch = new SoundTouch();
                this.init();
            }

            init() {
                this.elements.startBtn.onclick = () => this.start();
                this.createWaveBars(64);
                this.setupMotion();
                this.setupOrientation();
            }

            async start() {
                try {
                    await Tone.start();
                    this.mic = new Tone.UserMedia();
                    await this.mic.open();
                    this.analyser = new Tone.Analyser('fft', 1024);
                    this.mic.connect(this.analyser);
                    this.mixRecorder = new Tone.Recorder();
                    Tone.Master.connect(this.mixRecorder);
                    this.essentia = new Essentia(EssentiaWASM);
                    this.musicRNN = new mm.MusicRNN('https://storage.googleapis.com/magentadata/js/checkpoints/music_rnn/basic_rnn');
                    await this.musicRNN.initialize();
                    this.setupEffects();
                    this.setupSamplers();
                    this.elements.startBtn.style.display = 'none';
                    this.elements.orb.classList.add('active');
                    this.elements.waveform.classList.add('active');
                    this.active = true;
                    this.startLoop();
                    this.startSequencer();
                    this.addVinylNoise();
                    this.addAmbientLayer();
                    setInterval(() => this.feedbackLoop(), 30000); // Every 30s analyze and evolve
                } catch (err) {
                    console.error('Error:', err);
                }
            }

            setupEffects() {
                this.effects.compressor = new Tone.Compressor(-20, 4);
                this.effects.eq = new Tone.EQ3(-2, 1, -3); // Warm mids
                this.effects.lowpass = new Tone.Filter(2800, 'lowpass');
                this.effects.bitcrush = new Tone.BitCrusher(10);
                this.effects.tape = new Tone.Distortion(0.08); // Tape saturation
                this.effects.reverb = new Tone.Reverb({ decay: 4, preDelay: 0.1 });
                this.effects.reverb.generate();
                this.effects.delay = new Tone.PingPongDelay({ delayTime: 0.3, feedback: 0.25, wet: 0.2 });
                this.effects.chorus = new Tone.Chorus(0.4, 3, 0.4);
                this.effects.width = new Tone.StereoWidener(0.6);

                this.masterChain = new Tone.Chain(
                    this.effects.chorus,
                    this.effects.delay,
                    this.effects.reverb,
                    this.effects.width,
                    this.effects.lowpass,
                    this.effects.bitcrush,
                    this.effects.tape,
                    this.effects.eq,
                    this.effects.compressor,
                    Tone.Master
                );
            }

            setupSamplers() {
                ['drums', 'bass', 'melody', 'pads'].forEach(layer => {
                    this.samplers[layer] = new Tone.Sampler({
                        attack: layer === 'pads' ? 1.2 : 0.02,
                        release: layer === 'pads' ? 2.5 : 0.2,
                        curve: 'exponential'
                    });
                    this.samplers[layer].panner = new Tone.Panner3D();
                    this.samplers[layer].connect(this.samplers[layer].panner);
                    this.samplers[layer].panner.connect(this.masterChain);
                });
            }

            addVinylNoise() {
                this.effects.vinyl = new Tone.Noise('brown');
                this.effects.vinyl.volume.value = -32;
                const vinylFilter = new Tone.Filter(3500, 'lowpass');
                const vinylComp = new Tone.Compressor(-30, 8);
                this.effects.vinyl.connect(vinylFilter).connect(vinylComp).connect(this.masterChain);
                this.effects.vinyl.start();
            }

            addAmbientLayer() {
                this.effects.ambient = new Tone.Noise('white');
                this.effects.ambient.volume.value = -35;
                const ambFilter = new Tone.Filter(600, 'lowpass');
                const ambReverb = new Tone.Reverb(6);
                const ambComp = new Tone.Compressor(-40, 4);
                this.effects.ambient.connect(ambFilter).connect(ambReverb).connect(ambComp).connect(this.masterChain);
                this.effects.ambient.start();
            }

            startLoop() {
                const loop = () => {
                    if (!this.active) return;
                    const fft = this.analyser.getValue();
                    this.updateViz(fft);
                    this.checkSample(fft);
                    this.updateParams();
                    this.updateBackground();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            async checkSample(fft) {
                const now = Date.now();
                if (now - this.lastSampleTime < 4000 || this.isRecordingSample) return;
                const rms = Tone.dbToGain(fft.reduce((a, b) => a + b, 0) / fft.length);
                if (rms > 0.06) {
                    this.isRecordingSample = true;
                    this.elements.orb.classList.add('recording');
                    const recorder = new Tone.Recorder();
                    this.mic.connect(recorder);
                    recorder.start();
                    const recordTime = 1500 + Math.random() * 2000;
                    setTimeout(async () => {
                        const recording = await recorder.stop();
                        const url = URL.createObjectURL(recording);
                        const buffer = await new Tone.Buffer(url);
                        await this.processAndIntegrateSample(buffer);
                        this.isRecordingSample = false;
                        this.elements.orb.classList.remove('recording');
                    }, recordTime);
                }
            }

            async processAndIntegrateSample(buffer) {
                // Onset detection for chopping
                const onsets = await this.essentia.OnsetDetection({ buffer: buffer.toArray(0) });
                const slices = [];
                let start = 0;
                onsets.onsetTimes.forEach(time => {
                    const end = time * buffer.duration;
                    if (end - start > 0.1) {
                        slices.push(buffer.slice(start, end));
                    }
                    start = end;
                });
                slices.push(buffer.slice(start));

                // Pitch detection and time-stretch
                const pitch = await this.essentia.PitchYin({ buffer: buffer.toArray(0) }).pitch;
                const targetPitch = this.snapToScale(pitch, this.key);
                const pitchRatio = targetPitch / pitch;

                // Time-stretch to fit tempo without initial pitch change
                const targetDur = 60 / this.bpm / (Math.random() < 0.5 ? 4 : 8); // Quarter or eighth notes
                const timeRatio = targetDur / buffer.duration;

                const stretchedSlices = await Promise.all(slices.map(slice => this.timeStretch(slice, timeRatio)));

                // Apply pitch shift after time stretch
                const tunedSlices = await Promise.all(stretchedSlices.map(slice => this.pitchShift(slice, pitchRatio)));

                // Categorize and add
                const energy = await this.essentia.Energy({ buffer: buffer.toArray(0) }).energy;
                const spectralCentroid = await this.essentia.SpectralCentroidTime({ buffer: buffer.toArray(0) }).spectralCentroid;
                let layer = 'pads';
                if (energy > 0.5 && spectralCentroid > 2000) layer = 'drums';
                else if (energy > 0.3 && spectralCentroid < 500) layer = 'bass';
                else if (spectralCentroid > 500 && spectralCentroid < 2000) layer = 'melody';

                tunedSlices.forEach((slice, idx) => {
                    this.samplers[layer].add(idx + Object.keys(this.samplers[layer]._buffers._buffers).length, slice);
                });

                this.lastSampleTime = Date.now();
            }

            async timeStretch(buffer, ratio) {
                return new Promise(resolve => {
                    const filter = new SimpleFilter(buffer.getChannelData(0), new this.soundTouch.Stretch(ratio));
                    const samples = new Float32Array(buffer.length * ratio);
                    filter.extract(samples, samples.length);
                    const newBuffer = new Tone.Buffer(samples);
                    resolve(newBuffer);
                });
            }

            pitchShift(buffer, ratio) {
                const shifter = new Tone.PitchShift(Math.log2(ratio) * 12);
                const offline = new Tone.Offline(buffer.duration);
                const player = new Tone.Player(buffer).connect(shifter);
                shifter.connect(offline.destination);
                player.start();
                return offline.render();
            }

            snapToScale(pitch, key) {
                // Simple scale for key, e.g. C minor
                const base = 130.81; // C3
                const scaleIntervals = [0, 2, 3, 5, 7, 8, 10, 12, 14, 15, 17, 19, 20, 22, 24]; // Minor scale over 2 octaves
                const scale = scaleIntervals.map(int => base * 2 ** (int / 12));
                return scale.reduce((prev, curr) => Math.abs(curr - pitch) < Math.abs(prev - pitch) ? curr : prev);
            }

            async feedbackLoop() {
                // Record 8 seconds of current mix
                this.mixRecorder.start();
                await Tone.sleep(8);
                const recording = await this.mixRecorder.stop();
                const url = URL.createObjectURL(recording);
                const buffer = await new Tone.Buffer(url);

                // Analyze with Essentia and Magenta
                const tempoInfo = await this.essentia.PercivalBpmEstimator({ buffer: buffer.toArray(0) });
                const keyInfo = await this.essentia.KeyExtractor({ buffer: buffer.toArray(0) });
                const rnnInput = mm.sequences.quantizeNoteSequence({
                    ticksPerQuarter: 220,
                    totalTime: buffer.duration,
                    quantizationInfo: {stepsPerQuarter: 4},
                    noteNames: ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'],
                    velocities: [80]
                }, 4);
                const continued = await this.musicRNN.continueSequence(rnnInput, 20, 1.0);

                // Update engine
                this.bpm = this.bpm * 0.7 + tempoInfo.bpm * 0.3;
                Tone.Transport.bpm.value = this.bpm;
                this.key = keyInfo.key + keyInfo.scale;

                // Evolve patterns using continued sequence
                this.evolvePatterns(continued);

                // Adjust effects based on analysis
                const loudness = await this.essentia.LoudnessEBUR128({ buffer: buffer.toArray(0) });
                this.effects.compressor.threshold.value = -24 + (loudness.integratedLoudness / -14 * 6); // Normalize to -14 LUFS
            }

            evolvePatterns(sequence) {
                // Use generated sequence to update sampler triggers
                // For simplicity, map notes to layers
                sequence.notes.forEach(note => {
                    const layer = this.mapNoteToLayer(note.pitch);
                    // Schedule trigger
                    Tone.Transport.scheduleOnce(time => {
                        this.samplers[layer].triggerAttackRelease(note.pitch, note.quantizedEndStep - note.quantizedStartStep / (this.bpm / 60 * 4), time, note.velocity / 127);
                    }, note.quantizedStartStep / (this.bpm / 60 * 4));
                });
            }

            mapNoteToLayer(pitch) {
                if (pitch < 48) return 'bass';
                if (pitch > 72) return 'melody';
                return 'pads';
            }

            startSequencer() {
                Tone.Transport.bpm.value = this.bpm;
                Tone.Loop(() => {
                    // Base loop, evolved by feedback
                    ['drums', 'bass'].forEach(layer => this.triggerLayer(layer));
                }, "4n").start(0);
                Tone.Loop(() => {
                    ['melody', 'pads'].forEach(layer => this.triggerLayer(layer));
                }, "2m").start(0);
                Tone.Transport.start();
            }

            triggerLayer(layer) {
                const notes = Object.keys(this.samplers[layer]._buffers._buffers);
                if (notes.length > 0) {
                    const note = notes[Math.floor(Math.random() * notes.length)];
                    const dur = layer === 'pads' ? '1m' : layer === 'melody' ? '4n' : '8n';
                    this.samplers[layer].triggerAttackRelease(note, dur);
                }
            }

            updateParams() {
                const avgMotion = this.motionHistory.reduce((a,b)=>a+b,0)/this.motionHistory.length || 0;
                this.effects.lowpass.frequency.value = 2200 + avgMotion * 800;
                this.effects.bitcrush.bits.value = 12 - Math.floor(avgMotion * 3);
                this.effects.reverb.wet.value = 0.25 + avgMotion * 0.15;
                this.effects.delay.wet.value = 0.15 + avgMotion * 0.1;
                this.effects.chorus.depth.value = 0.3 + avgMotion * 0.2;
                this.effects.width.width.value = 0.5 + avgMotion * 0.3;
            }

            updateBackground() {
                const intensity = Math.min(this.motion / 5, 1);
                const hue = 30 + intensity * 60;
                document.body.style.background = `radial-gradient(circle at 50% 50%, hsla(${hue}, 40%, 20%, 0.5) 0%, #111 70%)`;
            }
        }

        new RichLofiEngine();
    </script>
</body>
</html>
