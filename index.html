<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OMNI | Music 2.0</title>
    <style>
        :root {
            --bg: #050505;
            --surface: #0a0a0a;
            --accent: #00ffa3;
            --accent2: #ff006e;
            --accent3: #3a86ff;
            --text: #e8e8e8;
            --text-dim: #444;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
            height: 100vh;
            overflow: hidden;
        }

        #start {
            position: fixed;
            inset: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 40px;
            z-index: 100;
            background: var(--bg);
        }

        #start.hidden { display: none; }

        .title {
            font-size: 13px;
            letter-spacing: 8px;
            font-weight: 300;
            opacity: 0.7;
        }

        .start-btn {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            font-family: inherit;
            font-size: 10px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.4s ease;
        }

        .start-btn:hover {
            background: var(--accent);
            color: var(--bg);
            box-shadow: 0 0 60px rgba(0, 255, 163, 0.4);
        }

        #app {
            display: none;
            height: 100vh;
            flex-direction: column;
        }

        #app.active { display: flex; }

        .header {
            height: 40px;
            padding: 0 20px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid #111;
            font-size: 9px;
            letter-spacing: 2px;
            color: var(--text-dim);
        }

        .header span { color: var(--accent); }

        .viewport {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        .hud {
            position: absolute;
            padding: 15px;
            font-size: 9px;
            color: var(--text-dim);
            pointer-events: none;
        }

        .hud-tl { top: 0; left: 0; }
        .hud-tr { top: 0; right: 0; text-align: right; }
        .hud-bl { bottom: 0; left: 0; }
        .hud-br { bottom: 0; right: 0; text-align: right; }

        .hud-value { color: var(--text); font-size: 11px; }
        .hud-label { margin-bottom: 4px; letter-spacing: 1px; }

        .meter {
            width: 100px;
            height: 2px;
            background: #111;
            margin-top: 4px;
        }

        .meter-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.05s;
        }

        .stage-indicator {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .stage-name {
            font-size: 10px;
            letter-spacing: 4px;
            color: var(--accent);
            margin-bottom: 8px;
        }

        .stage-bar {
            width: 200px;
            height: 1px;
            background: #222;
        }

        .stage-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--accent), var(--accent2));
            width: 0%;
            transition: width 1s ease;
        }

        .log {
            position: absolute;
            bottom: 15px;
            left: 15px;
            width: 280px;
            height: 80px;
            overflow: hidden;
            font-size: 8px;
            opacity: 0.5;
        }

        .log-entry { margin-bottom: 2px; }
        .log-entry.accent { color: var(--accent); opacity: 1; }

        @media (max-width: 600px) {
            .hud, .log { display: none; }
        }
    </style>
</head>
<body>

<div id="start">
    <div class="title">OMNI // MUSIC 2.0</div>
    <button class="start-btn" id="startBtn">BEGIN</button>
</div>

<div id="app">
    <header class="header">
        <div>OMNI <span>ENGINE</span></div>
        <div>GRAINS: <span id="grainCount">0</span> | BUFFER: <span id="bufferTime">0.0</span>s</div>
    </header>
    <div class="viewport">
        <canvas id="viz"></canvas>

        <div class="hud hud-tl">
            <div class="hud-label">INPUT LEVEL</div>
            <div class="meter"><div class="meter-fill" id="inputMeter"></div></div>
            <div style="margin-top: 12px;">
                <div class="hud-label">CAPTURED</div>
                <div class="hud-value" id="capturedCount">0 samples</div>
            </div>
        </div>

        <div class="hud hud-tr">
            <div class="hud-label">DENSITY</div>
            <div class="hud-value" id="densityVal">0</div>
            <div style="margin-top: 12px;">
                <div class="hud-label">SPREAD</div>
                <div class="hud-value" id="spreadVal">0ms</div>
            </div>
        </div>

        <div class="hud hud-bl">
            <div class="hud-label">SPECTRAL CENTROID</div>
            <div class="hud-value" id="centroidVal">-- Hz</div>
        </div>

        <div class="stage-indicator">
            <div class="stage-name" id="stageName">LISTENING</div>
            <div class="stage-bar"><div class="stage-fill" id="stageFill"></div></div>
        </div>

        <div class="log" id="log"></div>
    </div>
</div>

<script>
// ============================================================================
// OMNI MUSIC 2.0 - GRANULAR ENVIRONMENTAL SYNTHESIS
// Inspired by Radiohead/Jonny Greenwood, Paulstretch, modern spectral techniques
// ============================================================================

const PHI = 1.618033988749;

// ============================================================================
// LOGGING
// ============================================================================
function log(msg, accent = false) {
    const el = document.getElementById('log');
    const div = document.createElement('div');
    div.className = 'log-entry' + (accent ? ' accent' : '');
    div.textContent = `${new Date().toLocaleTimeString().slice(0, 8)} ${msg}`;
    el.prepend(div);
    while (el.children.length > 12) el.removeChild(el.lastChild);
}

// ============================================================================
// AUDIO CONTEXT & NODES
// ============================================================================
let ctx, masterGain, compressor, convolver, analyser;
let micStream, micSource;

// Ring buffer for continuous capture
const BUFFER_SECONDS = 30;
const SAMPLE_RATE = 44100;
let ringBuffer = new Float32Array(BUFFER_SECONDS * SAMPLE_RATE);
let writeHead = 0;
let bufferFilled = 0;

// Analysis
let fftSize = 2048;
let freqData, timeData;

// ============================================================================
// GRAIN CLOUD ENGINE
// ============================================================================
class GrainCloud {
    constructor(audioCtx, destination) {
        this.ctx = audioCtx;
        this.destination = destination;
        this.grains = [];
        this.isActive = false;

        // Cloud parameters
        this.density = 8; // grains per second
        this.grainSize = 0.15; // seconds
        this.grainSizeRand = 0.1;
        this.pitch = 1.0;
        this.pitchRand = 0.1;
        this.spread = 2.0; // how far back in buffer to look (seconds)
        this.pan = 0;
        this.panRand = 0.5;
        this.reverse = 0.2; // probability of reverse
        this.attack = 0.02;
        this.release = 0.08;

        this.lastGrainTime = 0;
        this.activeGrainCount = 0;
    }

    setParams(params) {
        Object.assign(this, params);
    }

    update(currentTime) {
        if (!this.isActive) return;
        if (bufferFilled < SAMPLE_RATE) return; // need at least 1 second

        const interval = 1 / this.density;

        while (currentTime > this.lastGrainTime + interval) {
            this.spawnGrain();
            this.lastGrainTime += interval;
        }
    }

    spawnGrain() {
        if (this.activeGrainCount > 32) return; // limit polyphony

        const grainDur = this.grainSize + (Math.random() - 0.5) * this.grainSizeRand * 2;
        const grainSamples = Math.floor(grainDur * SAMPLE_RATE);

        // Pick random position in the captured buffer
        const maxOffset = Math.min(bufferFilled, this.spread * SAMPLE_RATE);
        const offset = Math.floor(Math.random() * maxOffset);
        let startPos = writeHead - offset;
        if (startPos < 0) startPos += ringBuffer.length;

        // Create grain buffer
        const grainBuffer = this.ctx.createBuffer(1, grainSamples, SAMPLE_RATE);
        const grainData = grainBuffer.getChannelData(0);

        // Copy from ring buffer with envelope
        const isReverse = Math.random() < this.reverse;
        for (let i = 0; i < grainSamples; i++) {
            const readIdx = isReverse ?
                (startPos + grainSamples - 1 - i) % ringBuffer.length :
                (startPos + i) % ringBuffer.length;

            // Hann window envelope
            const env = 0.5 * (1 - Math.cos(2 * Math.PI * i / grainSamples));
            grainData[i] = ringBuffer[readIdx] * env;
        }

        // Create grain nodes
        const source = this.ctx.createBufferSource();
        source.buffer = grainBuffer;

        // Pitch
        const pitchMod = this.pitch + (Math.random() - 0.5) * this.pitchRand * 2;
        source.playbackRate.value = Math.max(0.1, pitchMod);

        // Gain envelope
        const gainNode = this.ctx.createGain();
        const now = this.ctx.currentTime;
        gainNode.gain.setValueAtTime(0, now);
        gainNode.gain.linearRampToValueAtTime(0.3, now + this.attack);
        gainNode.gain.setValueAtTime(0.3, now + grainDur - this.release);
        gainNode.gain.linearRampToValueAtTime(0, now + grainDur);

        // Panner
        const panner = this.ctx.createStereoPanner();
        const panVal = this.pan + (Math.random() - 0.5) * this.panRand * 2;
        panner.pan.value = Math.max(-1, Math.min(1, panVal));

        // Filter - random filtering for texture
        const filter = this.ctx.createBiquadFilter();
        filter.type = Math.random() > 0.7 ? 'highpass' : 'lowpass';
        filter.frequency.value = 200 + Math.random() * 4000;
        filter.Q.value = 0.5 + Math.random() * 2;

        // Connect
        source.connect(filter);
        filter.connect(gainNode);
        gainNode.connect(panner);
        panner.connect(this.destination);

        // Start
        source.start(now);
        source.stop(now + grainDur / pitchMod + 0.1);

        this.activeGrainCount++;
        source.onended = () => this.activeGrainCount--;
    }

    start() {
        this.isActive = true;
        this.lastGrainTime = this.ctx.currentTime;
    }

    stop() {
        this.isActive = false;
    }
}

// ============================================================================
// STUTTER ENGINE - Radiohead style glitch
// ============================================================================
class StutterEngine {
    constructor(audioCtx, destination) {
        this.ctx = audioCtx;
        this.destination = destination;
        this.isActive = false;
        this.stutterBuffer = null;
        this.stutterLength = 0.05; // seconds
        this.probability = 0.02;
        this.isStuttering = false;
    }

    update() {
        if (!this.isActive || this.isStuttering) return;
        if (bufferFilled < SAMPLE_RATE * 2) return;

        if (Math.random() < this.probability) {
            this.triggerStutter();
        }
    }

    triggerStutter() {
        this.isStuttering = true;

        // Random stutter length
        const length = 0.03 + Math.random() * 0.15;
        const samples = Math.floor(length * SAMPLE_RATE);

        // Capture from recent buffer
        const offset = Math.floor(Math.random() * SAMPLE_RATE * 0.5);
        let startPos = writeHead - offset - samples;
        if (startPos < 0) startPos += ringBuffer.length;

        // Create stutter buffer
        const buffer = this.ctx.createBuffer(1, samples, SAMPLE_RATE);
        const data = buffer.getChannelData(0);

        for (let i = 0; i < samples; i++) {
            data[i] = ringBuffer[(startPos + i) % ringBuffer.length];
        }

        // Play multiple repeats
        const repeats = 2 + Math.floor(Math.random() * 6);
        const now = this.ctx.currentTime;

        for (let r = 0; r < repeats; r++) {
            const source = this.ctx.createBufferSource();
            source.buffer = buffer;

            // Pitch variation
            source.playbackRate.value = 0.8 + Math.random() * 0.4;

            const gain = this.ctx.createGain();
            gain.gain.value = 0.4 * (1 - r / repeats); // fade out

            const panner = this.ctx.createStereoPanner();
            panner.pan.value = (Math.random() - 0.5) * 0.8;

            source.connect(gain);
            gain.connect(panner);
            panner.connect(this.destination);

            source.start(now + r * length * 0.8);
        }

        // Reset after stutter completes
        setTimeout(() => {
            this.isStuttering = false;
        }, repeats * length * 1000);

        log('STUTTER', true);
    }

    start() { this.isActive = true; }
    stop() { this.isActive = false; }
}

// ============================================================================
// SPECTRAL FREEZE - Paulstretch-inspired
// ============================================================================
class SpectralFreeze {
    constructor(audioCtx, destination) {
        this.ctx = audioCtx;
        this.destination = destination;
        this.isActive = false;
        this.isFrozen = false;
    }

    freeze() {
        if (bufferFilled < SAMPLE_RATE * 2) return;

        this.isFrozen = true;

        // Capture a longer section
        const duration = 2 + Math.random() * 3;
        const samples = Math.floor(duration * SAMPLE_RATE);
        const fftSize = 4096;

        // Get recent audio
        let startPos = writeHead - samples;
        if (startPos < 0) startPos += ringBuffer.length;

        const inputData = new Float32Array(samples);
        for (let i = 0; i < samples; i++) {
            inputData[i] = ringBuffer[(startPos + i) % ringBuffer.length];
        }

        // Create stretched buffer (simplified paulstretch)
        const stretchFactor = 8;
        const outputLength = Math.floor(samples * stretchFactor);
        const outputBuffer = this.ctx.createBuffer(1, outputLength, SAMPLE_RATE);
        const outputData = outputBuffer.getChannelData(0);

        // Process in overlapping windows
        const hopSize = fftSize / 4;
        const window = new Float32Array(fftSize);
        for (let i = 0; i < fftSize; i++) {
            window[i] = 0.5 * (1 - Math.cos(2 * Math.PI * i / fftSize));
        }

        let outputPos = 0;
        for (let inputPos = 0; inputPos < samples - fftSize && outputPos < outputLength - fftSize; inputPos += hopSize / stretchFactor) {
            // Get windowed chunk
            const chunk = new Float32Array(fftSize);
            for (let i = 0; i < fftSize; i++) {
                const idx = Math.floor(inputPos) + i;
                chunk[i] = (idx < samples ? inputData[idx] : 0) * window[i];
            }

            // Randomize phase (simplified - just add random phase shifts)
            for (let i = 0; i < fftSize; i++) {
                chunk[i] *= Math.sin(Math.random() * Math.PI * 2) * 0.5 + 0.5;
            }

            // Overlap-add to output
            for (let i = 0; i < fftSize && outputPos + i < outputLength; i++) {
                outputData[outputPos + i] += chunk[i] * 0.1;
            }
            outputPos += hopSize;
        }

        // Normalize
        let maxVal = 0;
        for (let i = 0; i < outputLength; i++) {
            maxVal = Math.max(maxVal, Math.abs(outputData[i]));
        }
        if (maxVal > 0) {
            for (let i = 0; i < outputLength; i++) {
                outputData[i] /= maxVal;
            }
        }

        // Play the frozen texture
        const source = this.ctx.createBufferSource();
        source.buffer = outputBuffer;
        source.loop = true;

        const gain = this.ctx.createGain();
        gain.gain.value = 0;
        gain.gain.linearRampToValueAtTime(0.25, this.ctx.currentTime + 2);

        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 2000;

        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.destination);

        source.start();

        // Fade out after a while
        setTimeout(() => {
            gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 4);
            setTimeout(() => {
                source.stop();
                this.isFrozen = false;
            }, 4500);
        }, 8000 + Math.random() * 10000);

        log('SPECTRAL FREEZE', true);
    }

    update() {
        if (!this.isActive) return;
        if (!this.isFrozen && Math.random() < 0.001) {
            this.freeze();
        }
    }

    start() { this.isActive = true; }
    stop() { this.isActive = false; }
}

// ============================================================================
// CONVOLUTION REVERB
// ============================================================================
async function createReverb(audioCtx, decay = 4, wet = 0.4) {
    const sampleRate = audioCtx.sampleRate;
    const length = sampleRate * decay;
    const impulse = audioCtx.createBuffer(2, length, sampleRate);

    for (let channel = 0; channel < 2; channel++) {
        const channelData = impulse.getChannelData(channel);
        for (let i = 0; i < length; i++) {
            // Exponential decay with noise
            const decay = Math.exp(-3 * i / length);
            channelData[i] = (Math.random() * 2 - 1) * decay;
        }
    }

    const convolver = audioCtx.createConvolver();
    convolver.buffer = impulse;

    const wetGain = audioCtx.createGain();
    wetGain.gain.value = wet;

    const dryGain = audioCtx.createGain();
    dryGain.gain.value = 1 - wet * 0.5;

    return { convolver, wetGain, dryGain };
}

// ============================================================================
// ONSET & ANALYSIS
// ============================================================================
let prevEnergy = 0;
let onsetCooldown = 0;
let spectralCentroid = 0;

function analyze() {
    if (!analyser) return { energy: 0, onset: false };

    analyser.getFloatTimeDomainData(timeData);
    analyser.getFloatFrequencyData(freqData);

    // RMS Energy
    let sum = 0;
    for (let i = 0; i < timeData.length; i++) {
        sum += timeData[i] * timeData[i];
    }
    const energy = Math.sqrt(sum / timeData.length);

    // Onset detection
    const delta = energy - prevEnergy;
    let onset = false;
    if (onsetCooldown > 0) {
        onsetCooldown--;
    } else if (delta > 0.02 && energy > 0.01) {
        onset = true;
        onsetCooldown = 5;
    }
    prevEnergy = energy * 0.7 + prevEnergy * 0.3;

    // Spectral centroid
    let magSum = 0, weightedSum = 0;
    for (let i = 0; i < freqData.length; i++) {
        const mag = Math.pow(10, freqData[i] / 20);
        const freq = i * SAMPLE_RATE / fftSize;
        magSum += mag;
        weightedSum += mag * freq;
    }
    spectralCentroid = magSum > 0 ? weightedSum / magSum : 0;

    return { energy, onset };
}

// ============================================================================
// MAIN ENGINE
// ============================================================================
let grainClouds = [];
let stutterEngine, freezeEngine;
let stage = 'LISTENING';
let stageProgress = 0;
let capturedSamples = 0;
let isRunning = false;

async function init() {
    log('Initializing audio context...', true);

    ctx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: SAMPLE_RATE });

    // Master chain
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -6;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.25;
    compressor.connect(ctx.destination);

    // Reverb
    const { convolver: rev, wetGain, dryGain } = await createReverb(ctx, 5, 0.5);
    convolver = rev;

    masterGain = ctx.createGain();
    masterGain.gain.value = 0.8;

    // Routing: masterGain -> dry + wet(reverb) -> compressor
    masterGain.connect(dryGain);
    masterGain.connect(convolver);
    convolver.connect(wetGain);
    dryGain.connect(compressor);
    wetGain.connect(compressor);

    // Analyser
    analyser = ctx.createAnalyser();
    analyser.fftSize = fftSize;
    freqData = new Float32Array(analyser.frequencyBinCount);
    timeData = new Float32Array(fftSize);

    // Get microphone
    try {
        micStream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
        });
        micSource = ctx.createMediaStreamSource(micStream);
        micSource.connect(analyser);

        // Capture to ring buffer
        const processor = ctx.createScriptProcessor(2048, 1, 1);
        micSource.connect(processor);
        processor.connect(ctx.destination); // Required for it to run
        processor.onaudioprocess = (e) => {
            const input = e.inputBuffer.getChannelData(0);
            for (let i = 0; i < input.length; i++) {
                ringBuffer[writeHead] = input[i];
                writeHead = (writeHead + 1) % ringBuffer.length;
                bufferFilled = Math.min(bufferFilled + 1, ringBuffer.length);
            }
        };

        log('Microphone active', true);
    } catch (e) {
        log('Microphone denied: ' + e.message);
        throw e;
    }

    // Create grain clouds with different characters
    // Cloud 1: Dense, glitchy, high pitched
    const cloud1 = new GrainCloud(ctx, masterGain);
    cloud1.setParams({
        density: 15,
        grainSize: 0.05,
        grainSizeRand: 0.03,
        pitch: 1.5,
        pitchRand: 0.5,
        spread: 3,
        reverse: 0.3,
        pan: -0.3,
        panRand: 0.4
    });
    grainClouds.push(cloud1);

    // Cloud 2: Sparse, stretched, low
    const cloud2 = new GrainCloud(ctx, masterGain);
    cloud2.setParams({
        density: 3,
        grainSize: 0.4,
        grainSizeRand: 0.2,
        pitch: 0.5,
        pitchRand: 0.2,
        spread: 8,
        reverse: 0.5,
        pan: 0.3,
        panRand: 0.3
    });
    grainClouds.push(cloud2);

    // Cloud 3: Medium, rhythmic
    const cloud3 = new GrainCloud(ctx, masterGain);
    cloud3.setParams({
        density: 6,
        grainSize: 0.12,
        grainSizeRand: 0.05,
        pitch: 1.0,
        pitchRand: 0.15,
        spread: 2,
        reverse: 0.1,
        pan: 0,
        panRand: 0.8
    });
    grainClouds.push(cloud3);

    // Stutter engine
    stutterEngine = new StutterEngine(ctx, masterGain);

    // Spectral freeze engine
    freezeEngine = new SpectralFreeze(ctx, masterGain);

    log('Engines ready', true);
}

function evolve() {
    const bufferSeconds = bufferFilled / SAMPLE_RATE;

    // Stage progression based on buffer fill and activity
    if (stage === 'LISTENING' && bufferSeconds > 3) {
        stage = 'AWAKENING';
        grainClouds[0].start();
        log('STAGE: AWAKENING', true);
    }
    else if (stage === 'AWAKENING' && bufferSeconds > 8) {
        stage = 'GATHERING';
        grainClouds[1].start();
        stutterEngine.start();
        log('STAGE: GATHERING', true);
    }
    else if (stage === 'GATHERING' && bufferSeconds > 15) {
        stage = 'WEAVING';
        grainClouds[2].start();
        freezeEngine.start();
        log('STAGE: WEAVING', true);
    }
    else if (stage === 'WEAVING' && bufferSeconds > 25) {
        stage = 'COHESION';
        // Increase density and coherence
        grainClouds.forEach(c => {
            c.density *= 1.2;
            c.pitchRand *= 0.5; // More consistent pitch
            c.panRand *= 0.5;   // More focused stereo
        });
        stutterEngine.probability = 0.04;
        log('STAGE: COHESION', true);
    }

    // Dynamic parameter modulation based on spectral centroid
    const centroidNorm = Math.min(spectralCentroid / 4000, 1);
    grainClouds[0].pitch = 1.0 + centroidNorm * 0.8;
    grainClouds[1].pitch = 0.3 + centroidNorm * 0.4;

    // Update stage progress
    const stages = ['LISTENING', 'AWAKENING', 'GATHERING', 'WEAVING', 'COHESION'];
    const stageIdx = stages.indexOf(stage);
    stageProgress = (stageIdx / (stages.length - 1)) * 100;
}

function updateUI() {
    const { energy, onset } = analyze();

    document.getElementById('inputMeter').style.width = (energy * 500) + '%';
    document.getElementById('grainCount').textContent = grainClouds.reduce((sum, c) => sum + c.activeGrainCount, 0);
    document.getElementById('bufferTime').textContent = (bufferFilled / SAMPLE_RATE).toFixed(1);
    document.getElementById('capturedCount').textContent = Math.floor(bufferFilled / SAMPLE_RATE) + 's captured';
    document.getElementById('densityVal').textContent = grainClouds.reduce((sum, c) => sum + (c.isActive ? c.density : 0), 0).toFixed(1);
    document.getElementById('spreadVal').textContent = Math.round(grainClouds[0].spread * 1000) + 'ms';
    document.getElementById('centroidVal').textContent = Math.round(spectralCentroid) + ' Hz';
    document.getElementById('stageName').textContent = stage;
    document.getElementById('stageFill').style.width = stageProgress + '%';

    if (onset) {
        capturedSamples++;
    }
}

// ============================================================================
// VISUALIZATION
// ============================================================================
let vizCtx;
let particles = [];

function initViz() {
    const canvas = document.getElementById('viz');
    vizCtx = canvas.getContext('2d');
    resizeViz();
    window.addEventListener('resize', resizeViz);
}

function resizeViz() {
    const canvas = document.getElementById('viz');
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    vizCtx.scale(dpr, dpr);
}

function updateViz() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade
    vizCtx.fillStyle = 'rgba(5, 5, 5, 0.08)';
    vizCtx.fillRect(0, 0, w, h);

    // Spawn particles on grain activity
    const grainActivity = grainClouds.reduce((sum, c) => sum + c.activeGrainCount, 0);
    if (grainActivity > 0 && Math.random() < grainActivity * 0.05) {
        const angle = Math.random() * Math.PI * 2;
        const dist = 50 + Math.random() * 100;
        particles.push({
            x: w/2 + Math.cos(angle) * dist,
            y: h/2 + Math.sin(angle) * dist,
            vx: (Math.random() - 0.5) * 2,
            vy: (Math.random() - 0.5) * 2 - 0.5,
            size: 1 + Math.random() * 3,
            life: 1,
            hue: Math.random() > 0.5 ? 160 : 330 // cyan or magenta
        });
    }

    // Update particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.008;
        p.vy += 0.01;

        if (p.life <= 0) {
            particles.splice(i, 1);
            continue;
        }

        vizCtx.beginPath();
        vizCtx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
        vizCtx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life * 0.6})`;
        vizCtx.fill();
    }

    // Limit particles
    while (particles.length > 150) particles.shift();

    // Center orb
    const energy = prevEnergy * 200;
    const orbSize = 30 + energy * 50 + Math.sin(Date.now() * 0.002) * 5;

    const gradient = vizCtx.createRadialGradient(w/2, h/2, 0, w/2, h/2, orbSize);
    gradient.addColorStop(0, `rgba(0, 255, 163, ${0.3 + energy * 0.5})`);
    gradient.addColorStop(0.5, `rgba(0, 255, 163, ${0.1 + energy * 0.2})`);
    gradient.addColorStop(1, 'rgba(0, 255, 163, 0)');

    vizCtx.beginPath();
    vizCtx.arc(w/2, h/2, orbSize, 0, Math.PI * 2);
    vizCtx.fillStyle = gradient;
    vizCtx.fill();

    // Waveform ring
    if (timeData && stage !== 'LISTENING') {
        vizCtx.beginPath();
        for (let i = 0; i < timeData.length; i += 4) {
            const angle = (i / timeData.length) * Math.PI * 2;
            const amp = timeData[i] * 50;
            const r = orbSize + 20 + amp;
            const x = w/2 + Math.cos(angle) * r;
            const y = h/2 + Math.sin(angle) * r;
            if (i === 0) vizCtx.moveTo(x, y);
            else vizCtx.lineTo(x, y);
        }
        vizCtx.closePath();
        vizCtx.strokeStyle = 'rgba(0, 255, 163, 0.2)';
        vizCtx.lineWidth = 1;
        vizCtx.stroke();
    }
}

// ============================================================================
// MAIN LOOP
// ============================================================================
function run() {
    if (!isRunning) return;

    const now = ctx.currentTime;

    // Update engines
    grainClouds.forEach(cloud => cloud.update(now));
    stutterEngine.update();
    freezeEngine.update();

    // Evolution
    evolve();

    // UI & Viz
    updateUI();
    updateViz();

    requestAnimationFrame(run);
}

// ============================================================================
// START
// ============================================================================
document.getElementById('startBtn').addEventListener('click', async () => {
    document.getElementById('start').classList.add('hidden');
    document.getElementById('app').classList.add('active');

    await init();
    initViz();

    isRunning = true;
    log('OMNI Music 2.0 Active', true);
    log('Make sounds to feed the engine...');

    run();
});
</script>

</body>
</html>
