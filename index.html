<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Cinematic Void Engine - Bridged Evolution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,107,53,0.7);
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #4a90e2 0%, rgba(74,144,226,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(74,144,226,0.7);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(155,89,182,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }
    
    .production-status {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      letter-spacing: 1px;
      text-transform: uppercase;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">TECHNIQUE: <span id="technique">WAITING</span></div>
      <div class="metric">DYNAMICS: <span id="dynamics">PPP</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">HARMONIC TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="tensionBar"></div>
      </div>
      <div class="metric">PRODUCTION FIDELITY</div>
      <div class="bar">
        <div class="bar-fill" id="productionBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">60</span></div>
      <div class="metric">KEY: <span id="keyDisplay">D MIN</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
      <div class="metric">MASTERING: <span id="masteringDisplay">OFF</span></div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
    <div class="production-status" id="productionStatus">QUANTUM COMPOSITION ENGINE V2.1</div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>

  <script>
    class QuantumVoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Enhanced Musical Structure
        this.bpm = 60;
        this.step = 0;
        this.microStep = 0; // Sub-step timing for humanization
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        this.globalPhase = 0;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        
        // Enhanced Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.currentTechnique = 'waiting';
        this.productionQuality = 0;
        
        // Enhanced Cinematic Themes
        this.currentTheme = 'awakening';
        this.themes = {
          awakening: { mood: 'mysterious', colors: ['#1a1a1a', '#2a2a2a'], text: 'The Journey Begins' },
          adventure: { mood: 'heroic', colors: ['#ff6b35', '#1a1a1a'], text: 'Into the Unknown' },
          tension: { mood: 'suspenseful', colors: ['#4a90e2', '#1a1a1a'], text: 'Rising Storm' },
          triumph: { mood: 'epic', colors: ['#9b59b6', '#e74c3c'], text: 'Epic Triumph' },
          reflection: { mood: 'serene', colors: ['#f39c12', '#1a1a1a'], text: 'Eternal Reflection' },
          quantum: { mood: 'transcendent', colors: ['#00ffff', '#ff00ff'], text: 'Quantum Resonance' }
        };
        
        // ULTRA-ENHANCED AUDIO SYSTEM
        this.masterGain = null;
        this.limiter = null;
        this.multiband = {
          low: null,
          mid: null,
          high: null,
          presence: null
        };
        this.exciter = null;
        this.stereoEnhancer = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.layerCompressors = {};
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.shepardGain = null;
        this.ostinatoGain = null;
        
        // Mastering Chain
        this.masteringChain = {
          eq: null,
          compressor: null,
          enhancer: null,
          limiter: null,
          analyzer: null
        };
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Advanced Techniques
        this.shepardTones = []; 
        this.ostinatoPattern = [0, 2, 0, 5, 0, 3, 0, 7, 0, 1, 0, 6]; 
        this.ostinatoIndex = 0;
        this.shepardIntensity = 0;
        this.tensionBuildup = 0;
        this.harmonicComplexity = 1;
        
        // Enhanced Voice Pool
        this.voicePool = {
          kick: { max: 4, active: [] },
          sub: { max: 2, active: [] },
          bass: { max: 6, active: [] },
          hihat: { max: 8, active: [] },
          snare: { max: 4, active: [] },
          crash: { max: 2, active: [] },
          ostinato: { max: 12, active: [] },
          harmony: { max: 16, active: [] },
          lead: { max: 8, active: [] },
          pad: { max: 14, active: [] },
          atmosphere: { max: 10, active: [] },
          strings: { max: 24, active: [] }, 
          brass: { max: 12, active: [] },
          woodwinds: { max: 8, active: [] },
          choir: { max: 20, active: [] },
          percussion: { max: 16, active: [] },
          fx: { max: 12, active: [] },
          shepard: { max: 8, active: [] }
        };
        
        // Enhanced Layers
        this.layers = {
          kick: false, sub: false, bass: false, hihat: false, snare: false, crash: false,
          ostinato: false, harmony: false, lead: false, pad: false, atmosphere: false,
          strings: false, brass: false, woodwinds: false, choir: false, percussion: false,
          fx: false, shepard: false
        };
        
        // Enhanced Musical Elements
        this.key = 'D';
        this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
        this.modes = {
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10]
        };
        this.currentMode = 'aeolian';
        this.chordProgression = [
          [0, 3, 7, 10],    // i7
          [10, 2, 5, 8],    // VII7
          [5, 8, 0, 3],     // v7
          [7, 10, 2, 5],    // VI7
          [3, 7, 10, 0],    // III7
          [8, 0, 3, 5],     // iv7
          [2, 5, 8, 10],    // iiÂ°7
          [0, 3, 7, 10]     // i7
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 293.66;
        
        // Production Elements
        this.dynamicsLevel = 'ppp';
        this.dynamicsMap = {
          'ppp': 0.1, 'pp': 0.2, 'p': 0.3, 'mp': 0.4,
          'mf': 0.5, 'f': 0.7, 'ff': 0.85, 'fff': 1.0
        };
        
        // Procedural Systems
        this.noiseSource = null;
        this.noiseFilter = null;
        this.noiseGain = null;
        this.granularBuffer = null;
        this.grainScheduler = null;
        
        this.elements = {};
        this.spectrumBars = [];
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'dynamics', 'motionBar', 'tensionBar', 
         'productionBar', 'bpmDisplay', 'keyDisplay', 'voiceCount', 
         'masteringDisplay', 'cinematicOverlay', 'themeText', 'spectrumViz',
         'productionStatus']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupSpectrumVisualizer();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = (i * 12) + 'px';
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupOrientationDetection() {
        try {
          window.addEventListener('deviceorientation', e => {
            if (!this.active) return;
            if (e.alpha !== null) {
              this.orientation.alpha = e.alpha;
              this.orientation.beta = e.beta;
              this.orientation.gamma = e.gamma;
              this.updateListenerOrientation();
            } else {
              console.warn('Orientation data null - device may not support or permission issue');
            }
          });
        } catch (err) {
          console.error('Orientation detection setup failed:', err);
        }
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        this.listener.forwardX.value = forwardX;
        this.listener.forwardY.value = forwardY;
        this.listener.forwardZ.value = forwardZ;
        this.listener.upX.value = upX;
        this.listener.upY.value = upY;
        this.listener.upZ.value = upZ;
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              console.error('Motion permission denied');
              alert('Motion permission required for quantum unraveling');
              return;
            }
          }

          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              console.error('Orientation permission denied');
              alert('Orientation permission required for spatial transcendence');
              return;
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          if (this.ctx.state !== 'running') {
            throw new Error('AudioContext failed to resume after permission grant');
          }
          console.log('AudioContext running successfully');
          this.setupMasteringChain();
          this.setupAudioChain();
          this.setLayerPositions();

          // Setup event detection AFTER permissions and resume
          this.setupMotionDetection();
          this.setupOrientationDetection();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.startSequencer();
          this.animate();
          
        } catch (e) {
          console.error('Failed to initialize quantum engine:', e);
          alert('Failed to initialize. Check console for details and try again.');
        }
      }

      setupAudioChain() {
        // Enhanced analyzer
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 256;
        this.analyser.smoothingTimeConstant = 0.85;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        // Master limiter (brick wall)
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -0.3;
        this.limiter.knee.value = 0;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.001;
        this.limiter.release.value = 0.01;
        
        // Master gain
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.85;
        
        // Mix bus compressor (glue)
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -18;
        this.compressor.knee.value = 10;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.010;
        this.compressor.release.value = 0.100;
        
        // Spatial listener
        this.listener = this.ctx.listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        
        // Ultra-HD Convolution Reverb
        this.convolver = this.ctx.createConvolver();
        const reverbTime = 8;
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 2.5);
            const earlyReflections = i < data.length * 0.1 ? Math.sin(i * 0.01) * 0.3 : 0;
            data[i] = (Math.random() * 2 - 1) * decay * 0.15 + earlyReflections * decay;
          }
        }
        this.convolver.buffer = buffer;
        
        // Stereo delay network
        this.delay = this.ctx.createDelay(1.0);
        this.delay.delayTime.value = 0.375;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.4;
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.type = 'highpass';
        delayFilter.frequency.value = 200;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.3;
        
        this.delay.connect(delayFilter);
        delayFilter.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // Enhanced layer setup
        const layerNames = ['kick', 'sub', 'bass', 'hihat', 'snare', 'crash', 'ostinato', 
                          'harmony', 'lead', 'pad', 'atmosphere', 'strings', 'brass', 
                          'woodwinds', 'choir', 'percussion', 'fx', 'shepard'];
        const layerLevels = [0.6, 0.8, 0.4, 0.15, 0.35, 0.5, 0.3, 0.25, 0.4, 0.2, 0.15, 
                           0.35, 0.3, 0.25, 0.25, 0.35, 0.2, 0.2];
        
        layerNames.forEach((name, i) => {
          // Layer gain staging
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];

          // Layer compression
          this.layerCompressors[name] = this.ctx.createDynamicsCompressor();
          this.layerCompressors[name].threshold.value = -12;
          this.layerCompressors[name].knee.value = 4;
          this.layerCompressors[name].ratio.value = 3;
          this.layerCompressors[name].attack.value = 0.003;
          this.layerCompressors[name].release.value = 0.050;

          // 3D panning
          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';
          this.layerPanners[name].distanceModel = 'inverse';
          this.layerPanners[name].refDistance = 1;
          this.layerPanners[name].maxDistance = 10000;
          this.layerPanners[name].rolloffFactor = 1;

          // Signal flow
          this.layerGains[name].connect(this.layerCompressors[name]);
          this.layerCompressors[name].connect(this.layerPanners[name]);
          this.layerPanners[name].connect(this.compressor);

          // Send to reverb
          if (['strings', 'brass', 'woodwinds', 'choir', 'harmony', 'pad', 'atmosphere'].includes(name)) {
            const reverbSend = this.ctx.createGain();
            reverbSend.gain.value = 0.3;
            this.layerPanners[name].connect(reverbSend);
            reverbSend.connect(this.convolver);
          }
          
          // Send to delay
          if (['ostinato', 'strings', 'snare', 'lead', 'percussion'].includes(name)) {
            const delaySend = this.ctx.createGain();
            delaySend.gain.value = 0.2;
            this.layerPanners[name].connect(delaySend);
            delaySend.connect(this.delay);
          }
        });
        
        // Special gain controls
        this.shepardGain = this.ctx.createGain();
        this.shepardGain.gain.value = 0.2;
        this.ostinatoGain = this.ctx.createGain();
        this.ostinatoGain.gain.value = 0.3;
        
        // Master signal flow
        this.compressor.connect(this.masteringChain.eq);
        this.convolver.connect(this.masteringChain.eq);
        delayMix.connect(this.masteringChain.eq);
        
        // Setup Procedural Systems
        this.setupProceduralNoise();
        this.setupMultibandProcessing();
      }

      setupMasteringChain() {
        // 4-band parametric EQ
        this.masteringChain.eq = this.ctx.createBiquadFilter();
        this.masteringChain.eq.type = 'peaking';
        this.masteringChain.eq.frequency.value = 100;
        this.masteringChain.eq.Q.value = 0.7;
        this.masteringChain.eq.gain.value = 2;
        
        const eq2 = this.ctx.createBiquadFilter();
        eq2.type = 'peaking';
        eq2.frequency.value = 800;
        eq2.Q.value = 0.5;
        eq2.gain.value = -1;
        
        const eq3 = this.ctx.createBiquadFilter();
        eq3.type = 'peaking';
        eq3.frequency.value = 3000;
        eq3.Q.value = 0.8;
        eq3.gain.value = 1.5;
        
        const eq4 = this.ctx.createBiquadFilter();
        eq4.type = 'highshelf';
        eq4.frequency.value = 10000;
        eq4.gain.value = 3;
        
        // Mastering compressor
        this.masteringChain.compressor = this.ctx.createDynamicsCompressor();
        this.masteringChain.compressor.threshold.value = -6;
        this.masteringChain.compressor.knee.value = 2;
        this.masteringChain.compressor.ratio.value = 8;
        this.masteringChain.compressor.attack.value = 0.003;
        this.masteringChain.compressor.release.value = 0.050;
        
        // Harmonic exciter
        this.exciter = this.ctx.createWaveShaper();
        const curveLength = 4096;
        const exciterCurve = new Float32Array(curveLength);
        for (let i = 0; i < curveLength; i++) {
          const x = (i / curveLength) * 2 - 1;
          exciterCurve[i] = x + 0.05 * Math.sin(x * Math.PI * 3) + 0.02 * Math.sin(x * Math.PI * 5);
        }
        this.exciter.curve = exciterCurve;
        this.exciter.oversample = '4x';
        
        // Chain connection
        this.masteringChain.eq.connect(eq2);
        eq2.connect(eq3);
        eq3.connect(eq4);
        eq4.connect(this.masteringChain.compressor);
        this.masteringChain.compressor.connect(this.exciter);
        this.exciter.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      setupMultibandProcessing() {
        // Multiband splitter
        const lowpass = this.ctx.createBiquadFilter();
        lowpass.type = 'lowpass';
        lowpass.frequency.value = 200;
        
        const bandpass1 = this.ctx.createBiquadFilter();
        bandpass1.type = 'bandpass';
        bandpass1.frequency.value = 800;
        bandpass1.Q.value = 0.7;
        
        const bandpass2 = this.ctx.createBiquadFilter();
        bandpass2.type = 'bandpass';
        bandpass2.frequency.value = 3000;
        bandpass2.Q.value = 0.7;
        
        const highpass = this.ctx.createBiquadFilter();
        highpass.type = 'highpass';
        highpass.frequency.value = 8000;
        
        this.multiband.low = lowpass;
        this.multiband.mid = bandpass1;
        this.multiband.high = bandpass2;
        this.multiband.presence = highpass;
      }

      setupProceduralNoise() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        
        // Pink noise generation
        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0;
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          b0 = 0.99886 * b0 + white * 0.0555179;
          b1 = 0.99332 * b1 + white * 0.0750759;
          b2 = 0.96900 * b2 + white * 0.1538520;
          b3 = 0.86650 * b3 + white * 0.3104856;
          b4 = 0.55000 * b4 + white * 0.5329522;
          b5 = -0.7616 * b5 - white * 0.0168980;
          output[i] = (b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362) * 0.11;
          b6 = white * 0.115926;
        }

        this.noiseSource = this.ctx.createBufferSource();
        this.noiseSource.buffer = buffer;
        this.noiseSource.loop = true;

        this.noiseFilter = this.ctx.createBiquadFilter();
        this.noiseFilter.type = 'bandpass';
        this.noiseFilter.frequency.value = 1000;
        this.noiseFilter.Q.value = 15;

        this.noiseGain = this.ctx.createGain();
        this.noiseGain.gain.value = 0.02;

        this.noiseSource.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseGain);
        this.noiseGain.connect(this.layerPanners.atmosphere);
        this.noiseSource.start();
      }

      updateProceduralNoise(avgMotion, variance) {
        // Dynamic spectral shaping
        const centerFreq = 500 + avgMotion * 150 + variance * 100;
        const bandwidth = 5 + variance * 5 + this.tensionBuildup * 10;
        
        this.noiseFilter.frequency.exponentialRampToValueAtTime(
          centerFreq, 
          this.ctx.currentTime + 0.1
        );
        this.noiseFilter.Q.exponentialRampToValueAtTime(
          bandwidth, 
          this.ctx.currentTime + 0.1
        );
        
        const noiseLevel = 0.02 + (this.shepardIntensity * 0.08) + (this.releasePhase ? 0.05 : 0);
        this.noiseGain.gain.exponentialRampToValueAtTime(
          noiseLevel,
          this.ctx.currentTime + 0.2
        );
      }

      setLayerPositions() {
        // Enhanced 3D positioning for cinematic width
        this.layerPanners['kick'].setPosition(0, 0, -2);
        this.layerPanners['sub'].setPosition(0, -2, -3);
        this.layerPanners['bass'].setPosition(0, -1, -3);
        this.layerPanners['hihat'].setPosition(-3, 1, -4);
        this.layerPanners['snare'].setPosition(0, 0, -1);
        this.layerPanners['crash'].setPosition(0, 3, -5);
        this.layerPanners['ostinato'].setPosition(-4, 0, -5);
        this.layerPanners['harmony'].setPosition(4, 0, -5);
        this.layerPanners['lead'].setPosition(0, 0, 0);
        this.layerPanners['pad'].setPosition(0, 2, 5);
        this.layerPanners['atmosphere'].setPosition(0, 4, 12);
        this.layerPanners['strings'].setPosition(-6, 1, -7);
        this.layerPanners['brass'].setPosition(6, 1, -7);
        this.layerPanners['woodwinds'].setPosition(-3, 2, -4);
        this.layerPanners['choir'].setPosition(0, 3, 10);
        this.layerPanners['percussion'].setPosition(5, -1, -3);
        this.layerPanners['fx'].setPosition(0, 5, 15);
        this.layerPanners['shepard'].setPosition(0, 6, -12);
      }

      setupMotionDetection() {
        try {
          let lastMotionTime = 0;
          window.addEventListener('devicemotion', e => {
            const now = Date.now();
            if (now - lastMotionTime < 50) return; // Throttle to 20Hz
            lastMotionTime = now;

            if (!this.active) return;
            
            const acc = e.accelerationIncludingGravity;
            if (!acc || acc.x === null) {
              console.warn('Motion data null - falling back to mouse');
              return;
            }

            const dx = Math.abs(acc.x - this.lastAccel.x);
            const dy = Math.abs(acc.y - this.lastAccel.y);
            const dz = Math.abs(acc.z - this.lastAccel.z);
            
            const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.7;
            this.updateMotion(newMotion);
            
            this.velocity.x += acc.x * 0.018;
            this.velocity.y += acc.y * 0.018;
            this.updatePosition();
            
            this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
            
            if (newMotion > 4 && Date.now() - this.lastStepTime > 200) {
              this.stepCounter++;
              this.lastStepTime = Date.now();
              this.syncBPMToSteps();
            }
            
            this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
          });
        } catch (err) {
          console.error('Motion detection setup failed:', err);
        }

        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 100;
          const velocityY = (newY - lastMouse.y) / dt * 100;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.18;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          this.orientation.alpha = (newX / 100) * 360;
          this.orientation.beta = (newY - 50) * 1.8;
          this.orientation.gamma = 0;
          this.updateListenerOrientation();
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.75 + newMotion * 0.25;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 200) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        if (!this.firstMovement && this.motion > 1.2) {
          this.firstMovement = true;
          this.evolveToTribal();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        const variance = this.intensity;
        const recentHistory = this.motionHistory.slice(-50);
        const isRhythmic = recentHistory.filter(m => m > 2.5).length > 25 && variance < 2;
        const isErratic = variance > 3 && avgMotion > 2.5;
        const isSustained = avgMotion > 3 && variance < 1.5;
        const isChaotic = variance > 4 && avgMotion > 3.5;
        
        this.motionPattern = isChaotic ? 'chaotic' : isErratic ? 'erratic' : isRhythmic ? 'rhythmic' : isSustained ? 'sustained' : 'calm';
        
        this.updateTechniques(avgMotion, variance);
        this.updateEvolution();
        this.updateDynamics(avgMotion, variance);
        this.updateProductionQuality();
        
        // Update procedural noise
        this.updateProceduralNoise(avgMotion, variance);
      }

      updateTechniques(avgMotion, variance) {
        // Advanced technique selection
        if (avgMotion > 3 && variance > 2) {
          this.shepardIntensity = Math.min(this.shepardIntensity + 0.025, 1);
          this.tensionBuildup = Math.min(this.tensionBuildup + 0.015, 1);
          this.harmonicComplexity = Math.min(this.harmonicComplexity + 0.01, 3);
          this.currentTechnique = 'quantum-cascade';
        } else if (avgMotion > 2 && variance > 1.5) {
          this.shepardIntensity = Math.min(this.shepardIntensity + 0.02, 1);
          this.tensionBuildup = Math.min(this.tensionBuildup + 0.01, 1);
          this.currentTechnique = 'shepard-rising';
        } else if (avgMotion < 1 && this.totalMotion > 200) {
          this.shepardIntensity = Math.max(this.shepardIntensity - 0.015, 0);
          this.tensionBuildup = Math.max(this.tensionBuildup - 0.008, 0);
          this.currentTechnique = 'ethereal-decay';
        } else if (this.motionPattern === 'rhythmic') {
          this.currentTechnique = 'polyrhythmic-drive';
        } else {
          this.currentTechnique = 'ostinato-evolve';
        }
        
        this.buildPhase = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 2.5;
        this.releasePhase = this.motionPattern === 'calm' && this.totalMotion > 150 && avgMotion < 1.5;
        
        if (this.buildPhase) this.currentTechnique = 'cinematic-build';
        if (this.releasePhase) this.currentTechnique = 'quantum-release';
      }

      updateDynamics(avgMotion, variance) {
        // Musical dynamics based on motion
        let targetDynamic = 'ppp';
        if (avgMotion > 4 && variance > 3) targetDynamic = 'fff';
        else if (avgMotion > 3.5 && variance > 2.5) targetDynamic = 'ff';
        else if (avgMotion > 3) targetDynamic = 'f';
        else if (avgMotion > 2.5) targetDynamic = 'mf';
        else if (avgMotion > 2) targetDynamic = 'mp';
        else if (avgMotion > 1.5) targetDynamic = 'p';
        else if (avgMotion > 1) targetDynamic = 'pp';
        
        if (targetDynamic !== this.dynamicsLevel) {
          this.dynamicsLevel = targetDynamic;
          const targetGain = this.dynamicsMap[targetDynamic];
          this.masterGain.gain.linearRampToValueAtTime(targetGain * 0.85, this.ctx.currentTime + 0.5);
        }
      }

      updateProductionQuality() {
        // Progressive production enhancement
        this.productionQuality = Math.min(this.totalMotion / 1000, 1);
        
        // Adjust mastering based on evolution
        if (this.productionQuality > 0.3) {
          this.elements.masteringDisplay.textContent = 'ACTIVE';
          this.masteringChain.compressor.ratio.value = 4 + this.productionQuality * 4;
          this.exciter.curve = this.generateExciterCurve(this.productionQuality);
        } else {
          this.elements.masteringDisplay.textContent = 'WARMING';
        }
      }

      generateExciterCurve(intensity) {
        const curveLength = 4096;
        const curve = new Float32Array(curveLength);
        for (let i = 0; i < curveLength; i++) {
          const x = (i / curveLength) * 2 - 1;
          curve[i] = x + 
                    (0.05 * intensity) * Math.sin(x * Math.PI * 3) + 
                    (0.03 * intensity) * Math.sin(x * Math.PI * 5) +
                    (0.02 * intensity) * Math.sin(x * Math.PI * 7);
        }
        return curve;
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.88;
        this.velocity.y *= 0.88;
      }

      syncBPMToSteps() {
        if (this.stepCounter < 4) return;
        
        const stepInterval = (Date.now() - this.lastStepTime * (this.stepCounter - 1)) / (this.stepCounter - 1);
        const targetBPM = 60 / (stepInterval / 1000) * 1.5;
        
        this.bpm = this.bpm * 0.7 + targetBPM * 0.3;
        this.bpm = Math.max(40, Math.min(200, this.bpm));
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        // Enhanced layer activation with production consideration
        const activationThreshold = this.buildPhase ? 0.7 : 1.3;
        const deactivationThreshold = 0.5;
        
        this.layers.kick = avgMotion > activationThreshold || (this.layers.kick && avgMotion > deactivationThreshold);
        this.layers.sub = this.layers.kick && this.productionQuality > 0.2;
        this.layers.bass = (avgMotion > 1.5 || (this.layers.bass && avgMotion > 0.8)) && (this.motionPattern !== 'calm');
        this.layers.hihat = (avgMotion > 2 || this.intensity > 1.5 || this.motionPattern === 'rhythmic');
        this.layers.snare = (avgMotion > 2.5 && this.intensity > 2) || (this.motionPattern === 'erratic');
        this.layers.crash = this.step === 0 && this.phraseCount % 4 === 0 && avgMotion > 2;
        this.layers.ostinato = avgMotion > 1.2 && this.stage !== 'SILENCE';
        this.layers.harmony = (avgMotion > 2.5 || this.intensity > 2) && !this.releasePhase;
        this.layers.lead = this.stage !== 'SILENCE' && avgMotion > 3 && this.intensity > 2.5;
        this.layers.pad = avgMotion < 1.5 && this.totalMotion > 100 && this.releasePhase;
        this.layers.atmosphere = this.intensity < 1 && avgMotion < 1.5 && this.releasePhase;
        this.layers.strings = this.stage !== 'SILENCE' && avgMotion > 1.8;
        this.layers.brass = this.stage !== 'SILENCE' && this.intensity > 2.5 && this.buildPhase;
        this.layers.woodwinds = this.stage === 'ORCHESTRAL' && avgMotion > 1.5 && avgMotion < 3;
        this.layers.choir = this.stage === 'TRANSCENDENT' && avgMotion < 2 && this.releasePhase;
        this.layers.percussion = this.stage !== 'SILENCE' && this.motionPattern === 'rhythmic';
        this.layers.fx = this.tensionBuildup > 0.5 || this.shepardIntensity > 0.3;
        this.layers.shepard = this.shepardIntensity > 0.1;
        
        // Evolution progression
        this.evolutionProgress = Math.min(this.totalMotion / 1500, 3);
        this.subStage = Math.floor(this.evolutionProgress);
        
        if (this.stage === 'TRIBAL' && this.totalMotion > 400) {
          this.evolveToOrchestral();
        } else if (this.stage === 'ORCHESTRAL' && this.totalMotion > 900) {
          this.evolveToTranscendent();
        }
        
        // Dynamic BPM with production polish
        let baseBPM = 60 + (avgMotion * 10) + (this.intensity * 6);
        baseBPM += (this.subStage * 20);
        if (this.stage === 'TRIBAL') baseBPM += 30;
        else if (this.stage === 'ORCHESTRAL') baseBPM += 50;
        else if (this.stage === 'TRANSCENDENT') baseBPM += 80;
        
        if (this.buildPhase) baseBPM *= 1.15;
        if (this.releasePhase) baseBPM *= 0.85;
        if (this.motionPattern === 'chaotic') baseBPM *= 1.1;
        
        this.bpm = this.bpm * 0.9 + baseBPM * 0.1;
        this.bpm = Math.max(40, Math.min(200, this.bpm));
        
        // Mode changes for harmonic interest
        if (this.phraseCount % 8 === 0) {
          const modes = Object.keys(this.modes);
          this.currentMode = modes[Math.floor(Math.random() * modes.length)];
          this.scale = this.modes[this.currentMode];
        }
        
        this.updateCinematicTheme(avgMotion, this.intensity);
      }

      updateCinematicTheme(avgMotion, intensity) {
        let newTheme = 'awakening';
        if (this.stage === 'TRANSCENDENT' && avgMotion > 3) newTheme = 'quantum';
        else if (avgMotion > 4 && intensity > 3 && this.buildPhase) newTheme = 'triumph';
        else if (avgMotion > 2.5 && intensity > 2) newTheme = 'tension';
        else if (avgMotion > 1.5) newTheme = 'adventure';
        else if (avgMotion < 1.5 && this.totalMotion > 200 && this.releasePhase) newTheme = 'reflection';
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.elements.themeText.textContent = this.themes[newTheme].text;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 4000);
        }
      }

      evolveToTribal() {
        this.stage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.createParticles(50, '#ff6b35');
        console.log('ðŸ”¥ TRIBAL EVOLUTION: Rhythmic Awakening');
      }

      evolveToOrchestral() {
        this.stage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.createParticles(80, '#4a90e2');
        console.log('ðŸŒŠ ORCHESTRAL EVOLUTION: Symphonic Cascade');
      }

      evolveToTranscendent() {
        this.stage = 'TRANSCENDENT';
        this.elements.orb.className = 'orb transcendent';
        this.createParticles(120, '#9b59b6');
        this.elements.productionStatus.textContent = 'QUANTUM APOTHEOSIS ACHIEVED';
        console.log('âœ¨ TRANSCENDENT EVOLUTION: Quantum Singularity');
      }

      createParticles(count, color) {
        const existing = document.querySelector('.particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.background = color;
          particle.style.animationDelay = Math.random() * 12 + 's';
          particle.style.animationDuration = (6 + Math.random() * 8) + 's';
          container.appendChild(particle);
        }
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          // Humanization micro-timing
          this.microStep = Math.random() * 0.02 - 0.01;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.updateHarmony();
          }
          
          const interval = (60 / this.bpm) * 250;
          const humanizedInterval = interval + (interval * this.microStep);
          setTimeout(tick, humanizedInterval);
        };
        tick();
      }

      playStep() {
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
        }
        
        // Enhanced orchestration
        if (this.layers.kick && this.step % 8 === 0) this.playKick();
        if (this.layers.sub && this.step % 8 === 0) this.playSub();
        if (this.layers.bass && this.step % 4 === 0) this.playBass();
        if (this.layers.hihat && this.step % 2 === 1 && Math.random() < 0.8) this.playHihat();
        if (this.layers.snare && (this.step % 8 === 4 || (this.motionPattern === 'erratic' && this.step % 8 === 6 && Math.random() < 0.6))) this.playSnare();
        if (this.layers.crash && this.step === 0) this.playCrash();
        if (this.layers.ostinato && this.step % 2 === 0) this.playOstinato();
        if (this.layers.harmony && this.step % 16 === 0) this.playHarmony();
        if (this.layers.lead && (this.step % 4 === 0 || (this.buildPhase && this.step % 2 === 0))) this.playLead();
        if (this.layers.pad && this.step % 32 === 0 && this.releasePhase) this.playPad();
        if (this.layers.atmosphere && Math.random() < 0.05 && this.releasePhase) this.playAtmosphere();
        if (this.layers.strings && (this.step % 4 === 0 || this.buildPhase)) this.playStrings();
        if (this.layers.brass && this.step % 16 === 0 && this.buildPhase) this.playBrass();
        if (this.layers.woodwinds && this.step % 8 === 0) this.playWoodwinds();
        if (this.layers.choir && this.step % 32 === 0 && this.releasePhase) this.playChoir();
        if (this.layers.percussion && Math.random() < 0.3) this.playPercussion();
        if (this.layers.fx && Math.random() < 0.1) this.playFX();
        if (this.layers.shepard && this.step % 8 === 0) this.playShepardTone();
      }

      playKick() {
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const pitchEnv = this.ctx.createGain();
        
        if (!this.allocateVoice('kick', osc, gain, 0.8)) return;
        
        // Layered kick for punch
        osc.type = 'sine';
        osc2.type = 'square';
        
        // Pitch envelope
        pitchEnv.gain.setValueAtTime(200, this.ctx.currentTime);
        pitchEnv.gain.exponentialRampToValueAtTime(1, this.ctx.currentTime + 0.08);
        pitchEnv.connect(osc.frequency);
        pitchEnv.connect(osc2.frequency);
        
        osc.frequency.setValueAtTime(50 + this.intensity * 10, this.ctx.currentTime);
        osc2.frequency.setValueAtTime(60, this.ctx.currentTime);
        
        // Amplitude envelope
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.3, this.ctx.currentTime + 0.1);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        gain.gain.value = 1.0;
        
        osc.connect(env);
        osc2.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.kick);
        
        osc.start();
        osc2.start();
        osc.stop(this.ctx.currentTime + 0.8);
        osc2.stop(this.ctx.currentTime + 0.15);
      }

      playSub() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('sub', osc, gain, 1.2)) return;
        
        osc.type = 'sine';
        osc.frequency.value = 30 + (this.bassNote * 0.5);
        
        env.gain.setValueAtTime(0.8, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.2);
        
        gain.gain.value = 0.7;
        
        osc.connect(env).connect(gain).connect(this.layerGains.sub);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.2);
      }

      playBass() {
        const noteIndex = this.bassNote % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 1);
        
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const filterEnv = this.ctx.createGain();
        
        if (!this.allocateVoice('bass', osc, gain, 1.0)) return;
        
        // Dual oscillator bass
        osc.type = 'sawtooth';
        osc2.type = 'square';
        osc.frequency.value = freq;
        osc2.frequency.value = freq * 0.5;
        osc2.detune.value = 3;
        
        // Filter envelope
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        filter.Q.value = 5 + this.intensity * 2;
        
        filterEnv.gain.setValueAtTime(200 + this.motion * 100, this.ctx.currentTime);
        filterEnv.gain.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.2);
        filterEnv.connect(filter.frequency);
        
        env.gain.setValueAtTime(0.8, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.0);
        
        gain.gain.value = 0.7;
        
        osc.connect(filter);
        osc2.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.bass);
        
        osc.start();
        osc2.start();
        osc.stop(this.ctx.currentTime + 1.0);
        osc2.stop(this.ctx.currentTime + 1.0);
      }

      playHihat() {
        const bufferSize = this.ctx.sampleRate * 0.05;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          output[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / bufferSize, 2);
        }
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('hihat', source, gain, 0.2)) return;
        
        source.buffer = buffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 8000 + Math.random() * 4000 + this.intensity * 500;
        filter.Q.value = 1 + Math.random();
        
        env.gain.setValueAtTime(0.8, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        gain.gain.value = 0.3 + Math.random() * 0.1;
        
        source.connect(filter).connect(env).connect(gain).connect(this.layerGains.hihat);
        source.start();
      }

      playSnare() {
        // Noise component
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
        const noiseOutput = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseOutput.length; i++) {
          noiseOutput[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseOutput.length, 0.5);
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = noiseBuffer;
        
        // Tonal component
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('snare', noise, gain, 0.3)) return;
        
        osc1.type = 'triangle';
        osc1.frequency.value = 200 + this.intensity * 30;
        osc2.type = 'triangle';
        osc2.frequency.value = 300 + this.intensity * 40;
        
        filter.type = 'bandpass';
        filter.frequency.value = 3000 + this.motion * 500;
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        gain.gain.value = 0.7;
        
        noise.connect(filter);
        osc1.connect(env);
        osc2.connect(env);
        filter.connect(env);
        env.connect(gain).connect(this.layerGains.snare);
        
        noise.start();
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 0.15);
        osc2.stop(this.ctx.currentTime + 0.1);
      }

      playCrash() {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          const decay = Math.pow(1 - i / bufferSize, 0.3);
          output[i] = (Math.random() * 2 - 1) * decay;
        }
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('crash', source, gain, 2)) return;
        
        source.buffer = buffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 300;
        filter.Q.value = 0.5;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        gain.gain.value = 0.6;
        
        source.connect(filter).connect(env).connect(gain).connect(this.layerGains.crash);
        source.start();
      }

      playOstinato() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(this.scale[noteIndex % this.scale.length], 4);
        
        for (let v = 0; v < 2; v++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          const pan = this.ctx.createStereoPanner();
          
          if (!this.allocateVoice('ostinato', osc, gain, 1.0)) return;
          
          osc.type = v === 0 ? 'sawtooth' : 'square';
          osc.frequency.value = freq * (1 + v * 0.01);
          osc.detune.value = (v * 7) - 3.5;
          
          filter.type = 'lowpass';
          filter.frequency.value = 1000 + this.motion * 300 + this.intensity * 200;
          filter.Q.value = 4 + this.intensity;
          
          pan.pan.value = v === 0 ? -0.3 : 0.3;
          
          env.gain.setValueAtTime(this.buildPhase ? 0.2 : 0.8, this.ctx.currentTime);
          if (this.buildPhase) env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.15);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.0);
          
          gain.gain.value = 0.5;
          
          osc.connect(filter).connect(pan).connect(env).connect(gain).connect(this.layerGains.ostinato);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.0);
        }
        
        this.ostinatoIndex++;
      }

      playHarmony() {
        const chord = this.chordProgression[this.currentChordIndex];
        const duration = 6;
        const voices = 4;

        chord.forEach((interval, i) => {
          for (let v = 0; v < voices; v++) {
            const freq = this.noteToFreq(interval, 3 + (i % 2));
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const pan = this.ctx.createStereoPanner();
            
            if (!this.allocateVoice('harmony', osc, gain, duration)) return;
            
            osc.type = 'sine';
            osc.frequency.value = freq * (1 + v * 0.002);
            osc.detune.value = (v - voices/2) * 3;
            
            filter.type = 'lowpass';
            filter.frequency.value = 600 + this.motion * 150;
            filter.Q.value = 1;
            
            pan.pan.value = (i - chord.length/2) * 0.3;
            
            env.gain.setValueAtTime(0.1, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.8);
            env.gain.setValueAtTime(0.8, this.ctx.currentTime + duration - 1);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
            
            gain.gain.value = 0.2 / (chord.length * voices);
            
            osc.connect(filter).connect(pan).connect(env).connect(gain).connect(this.layerGains.harmony);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
          }
        });
      }

      playLead() {
        const scaleNote = this.scale[Math.floor(Math.random() * this.scale.length)];
        const octave = 5 + Math.floor(Math.random() * 2);
        const targetFreq = this.noteToFreq(scaleNote, octave);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const vibrato = this.ctx.createOscillator();
        const vibratoGain = this.ctx.createGain();
        
        if (!this.allocateVoice('lead', osc, gain, 1.5)) return;
        
        osc.type = 'sawtooth';
        
        // Portamento
        osc.frequency.setValueAtTime(this.lastLeadFreq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(targetFreq, this.ctx.currentTime + 0.05);
        this.lastLeadFreq = targetFreq;
        
        // Vibrato
        vibrato.frequency.value = 4 + this.intensity;
        vibratoGain.gain.value = 8;
        vibrato.connect(vibratoGain).connect(osc.frequency);
        
        filter.type = 'lowpass';
        filter.frequency.value = 2000 + this.motion * 500;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(0.6, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        gain.gain.value = 0.5;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.lead);
        vibrato.start();
        osc.start();
        vibrato.stop(this.ctx.currentTime + 1.5);
        osc.stop(this.ctx.currentTime + 1.5);
      }

      playStrings() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(this.scale[noteIndex % this.scale.length], 3);
        const voices = 8;
        
        for (let i = 0; i < voices; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          const pan = this.ctx.createStereoPanner();
          
          if (!this.allocateVoice('strings', osc, gain, 4)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.003);
          osc.detune.value = (i - voices/2) * 4;
          
          filter.type = 'lowpass';
          filter.frequency.value = 800 + this.motion * 200 + this.intensity * 150;
          filter.Q.value = 2;
          
          pan.pan.value = (i - voices/2) / voices * 0.8;
          
          const attackTime = 0.8 + (i * 0.05);
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + attackTime);
          env.gain.setValueAtTime(0.8, this.ctx.currentTime + 3);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          gain.gain.value = 0.15 / voices;
          
          osc.connect(filter).connect(pan).connect(env).connect(gain).connect(this.layerGains.strings);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
        }
      }

      playBrass() {
        const note = this.scale[Math.floor(this.scale.length / 2)];
        const freq = this.noteToFreq(note, 2);
        const voices = 4;
        
        for (let i = 0; i < voices; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('brass', osc, gain, 3)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.001);
          
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(200, this.ctx.currentTime);
          filter.frequency.exponentialRampToValueAtTime(1000 + this.intensity * 300, this.ctx.currentTime + 1.5);
          filter.Q.value = 5;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 1.2);
          env.gain.setValueAtTime(0.8, this.ctx.currentTime + 2);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
          
          gain.gain.value = 0.3 / voices;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.brass);
          osc.start();
          osc.stop(this.ctx.currentTime + 3);
        }
      }

      playWoodwinds() {
        const scaleNote = this.scale[Math.floor(Math.random() * this.scale.length)];
        const freq = this.noteToFreq(scaleNote, 4);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const breathNoise = this.ctx.createBufferSource();
        
        if (!this.allocateVoice('woodwinds', osc, gain, 2)) return;
        
        // Breath noise
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.05;
        }
        breathNoise.buffer = noiseBuffer;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 0.2);
        env.gain.setValueAtTime(0.6, this.ctx.currentTime + 1.5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter);
        breathNoise.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.woodwinds);
        
        osc.start();
        breathNoise.start();
        osc.stop(this.ctx.currentTime + 2);
      }

      playChoir() {
        const formants = [
          {freq: 700, q: 5, gain: 1},    // 'ah'
          {freq: 1100, q: 7, gain: 0.8},
          {freq: 2700, q: 8, gain: 0.6}
        ];
        
        this.chordProgression[this.currentChordIndex].forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 4 + (i % 2));
          const voices = 6;
          
          for (let v = 0; v < voices; v++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            
            if (!this.allocateVoice('choir', osc, gain, 20)) return;
            
            osc.type = 'sawtooth';
            osc.frequency.value = freq * (1 + v * 0.005);
            osc.detune.value = (v - voices/2) * 5;
            
            // Formant filters
            let lastNode = osc;
            formants.forEach(formant => {
              const filter = this.ctx.createBiquadFilter();
              filter.type = 'peaking';
              filter.frequency.value = formant.freq;
              filter.Q.value = formant.q;
              filter.gain.value = formant.gain * 10;
              lastNode.connect(filter);
              lastNode = filter;
            });
            
            env.gain.setValueAtTime(0, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 5);
            env.gain.setValueAtTime(0.5, this.ctx.currentTime + 15);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 20);
            
            gain.gain.value = 0.08 / (this.chordProgression[this.currentChordIndex].length * voices);
            
            lastNode.connect(env).connect(gain).connect(this.layerGains.choir);
            osc.start();
            osc.stop(this.ctx.currentTime + 20);
          }
        });
      }

      playPercussion() {
        const percType = Math.floor(Math.random() * 4);
        
        switch(percType) {
          case 0: // Shaker
            const shakerBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
            const shakerData = shakerBuffer.getChannelData(0);
            for (let i = 0; i < shakerData.length; i++) {
              shakerData[i] = (Math.random() * 2 - 1) * Math.sin(i / shakerData.length * Math.PI);
            }
            
            const shaker = this.ctx.createBufferSource();
            const shakerGain = this.ctx.createGain();
            const shakerFilter = this.ctx.createBiquadFilter();
            
            if (!this.allocateVoice('percussion', shaker, shakerGain, 0.1)) return;
            
            shaker.buffer = shakerBuffer;
            shakerFilter.type = 'highpass';
            shakerFilter.frequency.value = 5000;
            shakerGain.gain.value = 0.2;
            
            shaker.connect(shakerFilter).connect(shakerGain).connect(this.layerGains.percussion);
            shaker.start();
            break;
            
          case 1: // Conga
            const congaOsc = this.ctx.createOscillator();
            const congaGain = this.ctx.createGain();
            const congaEnv = this.ctx.createGain();
            
            if (!this.allocateVoice('percussion', congaOsc, congaGain, 0.2)) return;
            
            congaOsc.frequency.value = 150 + Math.random() * 50;
            congaEnv.gain.setValueAtTime(1, this.ctx.currentTime);
            congaEnv.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
            congaGain.gain.value = 0.4;
            
            congaOsc.connect(congaEnv).connect(congaGain).connect(this.layerGains.percussion);
            congaOsc.start();
            congaOsc.stop(this.ctx.currentTime + 0.2);
            break;
        }
      }

      playFX() {
        const fxType = Math.floor(Math.random() * 3);
        
        switch(fxType) {
          case 0: // Riser
            const riser = this.ctx.createOscillator();
            const riserGain = this.ctx.createGain();
            const riserFilter = this.ctx.createBiquadFilter();
            
            if (!this.allocateVoice('fx', riser, riserGain, 2)) return;
            
            riser.frequency.setValueAtTime(100, this.ctx.currentTime);
            riser.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 2);
            
            riserFilter.type = 'highpass';
            riserFilter.frequency.setValueAtTime(100, this.ctx.currentTime);
            riserFilter.frequency.exponentialRampToValueAtTime(1000, this.ctx.currentTime + 2);
            
            riserGain.gain.setValueAtTime(0, this.ctx.currentTime);
            riserGain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 2);
            
            riser.connect(riserFilter).connect(riserGain).connect(this.layerGains.fx);
            riser.start();
            riser.stop(this.ctx.currentTime + 2);
            break;
            
          case 1: // Impact
            const impact = this.ctx.createBufferSource();
            const impactBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
            const impactData = impactBuffer.getChannelData(0);
            
            for (let i = 0; i < impactData.length; i++) {
              const t = i / impactData.length;
              impactData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 5) * Math.cos(t * 100);
            }
            
            const impactGain = this.ctx.createGain();
            if (!this.allocateVoice('fx', impact, impactGain, 0.5)) return;
            
            impact.buffer = impactBuffer;
            impactGain.gain.value = 0.5;
            
            impact.connect(impactGain).connect(this.layerGains.fx);
            impact.start();
            break;
        }
      }

      playShepardTone() {
        const baseFreq = 110;
        const shepardLayers = 8;
        
        for (let i = 0; i < shepardLayers; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const pan = this.ctx.createStereoPanner();
          
          if (!this.allocateVoice('shepard', osc, gain, 6)) return;
          
          const octavePosition = i / shepardLayers;
          const freq = baseFreq * Math.pow(2, i + this.shepardIntensity);
          
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(freq * 2, this.ctx.currentTime + 6);
          
          // Gaussian amplitude envelope for seamless cycling
          const amplitude = Math.exp(-Math.pow((octavePosition - 0.5) * 4, 2)) * this.shepardIntensity;
          
          env.gain.setValueAtTime(amplitude * 0.1, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(amplitude, this.ctx.currentTime + 0.5);
          env.gain.setValueAtTime(amplitude, this.ctx.currentTime + 5);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
          
          // Spatial spread
          pan.pan.value = (i - shepardLayers/2) / shepardLayers * 0.8;
          
          gain.gain.value = 0.15;
          
          osc.connect(pan).connect(env).connect(gain).connect(this.layerGains.shepard);
          osc.start();
          osc.stop(this.ctx.currentTime + 6);
        }
      }

      playPad() {
        const chord = this.chordProgression[this.currentChordIndex];
        const voices = 5;
        
        chord.forEach((note, i) => {
          for (let v = 0; v < voices; v++) {
            const freq = this.noteToFreq(note, 2 + (i % 3));
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const lfo = this.ctx.createOscillator();
            const lfoGain = this.ctx.createGain();
            
            if (!this.allocateVoice('pad', osc, gain, 15)) return;
            
            osc.type = 'sine';
            osc.frequency.value = freq * (1 + v * 0.003);
            osc.detune.value = (v - voices/2) * 8;
            
            // LFO for movement
            lfo.frequency.value = 0.1 + v * 0.05;
            lfoGain.gain.value = 50;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            
            filter.type = 'lowpass';
            filter.frequency.value = 300 + this.motion * 100;
            filter.Q.value = 2;
            
            env.gain.setValueAtTime(0, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 4);
            env.gain.setValueAtTime(0.6, this.ctx.currentTime + 11);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 15);
            
            gain.gain.value = 0.1 / (chord.length * voices);
            
            osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.pad);
            lfo.start();
            osc.start();
            lfo.stop(this.ctx.currentTime + 15);
            osc.stop(this.ctx.currentTime + 15);
          }
        });
      }

      playAtmosphere() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 6 + Math.random());
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const delay = this.ctx.createDelay(0.5);
        const feedback = this.ctx.createGain();
        
        if (!this.allocateVoice('atmosphere', osc, gain, 25)) return;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = freq;
        filter.Q.value = 15 + this.intensity * 5;
        
        delay.delayTime.value = 0.2 + Math.random() * 0.3;
        feedback.gain.value = 0.6;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 5);
        env.gain.setValueAtTime(0.3, this.ctx.currentTime + 20);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 25);
        
        gain.gain.value = 0.15;
        
        osc.connect(filter);
        filter.connect(delay);
        delay.connect(feedback);
        feedback.connect(delay);
        filter.connect(env);
        delay.connect(env);
        env.connect(gain).connect(this.layerGains.atmosphere);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 25);
        
        // Modulate procedural noise
        this.noiseGain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 5);
        this.noiseGain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 20);
      }

      allocateVoice(layer, source, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) return false;
        
        // Clean up finished voices
        pool.active = pool.active.filter(voice => {
          if (this.ctx.currentTime > voice.endTime) {
            return false;
          }
          return true;
        });
        
        // Check if we can allocate
        if (pool.active.length >= pool.max) {
          // Steal oldest voice
          const oldest = pool.active.shift();
          if (oldest && oldest.gain) {
            oldest.gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
            if (oldest.source.stop) {
              oldest.source.stop(this.ctx.currentTime + 0.05);
            }
          }
        }
        
        // Add new voice
        const voice = { 
          source: source, 
          gain: gainNode, 
          startTime: this.ctx.currentTime,
          endTime: this.ctx.currentTime + duration
        };
        pool.active.push(voice);
        
        // Add onended handler for better cleanup
        if (source.onended) {
          source.onended = () => {
            pool.active = pool.active.filter(v => v.source !== source);
          };
        }
        
        return true;
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
        
        // Occasionally modulate
        if (Math.random() < 0.1 && this.buildPhase) {
          const modulation = [-2, -1, 1, 2][Math.floor(Math.random() * 4)];
          this.scale = this.scale.map(note => (note + modulation + 12) % 12);
        }
      }

      noteToFreq(note, octave = 4) {
        const baseFreq = 293.66; // D4
        return baseFreq * Math.pow(2, (note - 2) / 12 + (octave - 4));
      }

      updateUI() {
        this.elements.stageName.textContent = this.stage;
        this.elements.technique.textContent = this.currentTechnique.toUpperCase();
        this.elements.dynamics.textContent = this.dynamicsLevel.toUpperCase();
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = this.key + ' ' + this.currentMode.toUpperCase();
        
        const motionPercent = Math.min((this.motion + this.intensity) * 8, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        const tensionPercent = this.tensionBuildup * 100;
        this.elements.tensionBar.style.width = tensionPercent + '%';
        
        const productionPercent = this.productionQuality * 100;
        this.elements.productionBar.style.width = productionPercent + '%';
        
        const totalVoices = Object.values(this.voicePool).reduce((sum, pool) => sum + pool.active.length, 0);
        this.elements.voiceCount.textContent = totalVoices;
        
        // Update spectrum analyzer with enhanced visualization
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.dataArray);
          
          this.spectrumBars.forEach((bar, i) => {
            const dataIndex = Math.floor(i * this.dataArray.length / this.spectrumBars.length);
            const height = (this.dataArray[dataIndex] / 255) * 80;
            const smoothedHeight = parseFloat(bar.style.height) * 0.7 + height * 0.3;
            
            bar.style.height = smoothedHeight + 'px';
            
            // Color based on frequency and intensity
            const hue = 200 + (i / this.spectrumBars.length) * 60 + this.shepardIntensity * 30;
            const lightness = 50 + (smoothedHeight / 80) * 30;
            bar.style.background = `linear-gradient(0deg, 
              hsl(${hue}, 70%, ${lightness}%), 
              hsl(${hue}, 50%, ${lightness - 20}%))`;
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          // Update orb position with smoothing
          const targetX = this.pos.x;
          const targetY = this.pos.y;
          const currentX = parseFloat(this.elements.orb.style.left) || 50;
          const currentY = parseFloat(this.elements.orb.style.top) || 50;
          
          this.elements.orb.style.left = (currentX * 0.8 + targetX * 0.2) + '%';
          this.elements.orb.style.top = (currentY * 0.8 + targetY * 0.2) + '%';
          
          // Update UI periodically
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          // Enhanced cinematic background
          const theme = this.themes[this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 4, 1);
          const motionNorm = Math.min(this.motion / 6, 1);
          const productionNorm = this.productionQuality;
          
          let bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
          
          // Add quantum colors in transcendent mode
          if (this.stage === 'TRANSCENDENT' && this.currentTheme === 'quantum') {
            const quantumShift = Math.sin(Date.now() * 0.001) * 0.5 + 0.5;
            bg += `hsl(${180 + quantumShift * 180}, 100%, ${50 * intensityNorm}%) ${5 * motionNorm}%, `;
            bg += `hsl(${280 + quantumShift * 80}, 80%, ${30 * intensityNorm}%) ${20 * intensityNorm}%, `;
          } else {
            bg += `${theme.colors[0]} ${5 * motionNorm}%, `;
            if (theme.colors[1]) bg += `${theme.colors[1]} ${20 * intensityNorm}%, `;
          }
          
          bg += `rgba(10, 10, 10, ${1 - productionNorm * 0.2}) ${60 + 30 * intensityNorm}%`;
          bg += ')';
          
          // Add noise texture overlay for production depth
          if (productionNorm > 0.5) {
            bg += `, repeating-radial-gradient(circle at ${50 + Math.sin(Date.now() * 0.0005) * 20}% ${50 + Math.cos(Date.now() * 0.0007) * 20}%, 
                    transparent 0px, 
                    rgba(255,255,255,${0.02 * productionNorm}) 3px, 
                    transparent 6px)`;
          }
          
          document.body.style.background = bg;
          
          // Cinematic overlay management
          this.elements.cinematicOverlay.classList.toggle('active', 
            this.buildPhase || this.intensity > 2 || this.stage === 'TRANSCENDENT');
          
          // Production glow effect
          if (this.productionQuality > 0.7) {
            this.elements.orb.style.filter = `blur(0px) saturate(${1 + productionNorm}) brightness(${1 + productionNorm * 0.3})`;
          }
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    // Initialize the Quantum Void Engine
    new QuantumVoidEngine();
  </script>
</body>
</html>
