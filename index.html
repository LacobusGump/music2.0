<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 2s}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.25);transition:0.5s}
        #enter:hover div{border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.5)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// Life. Birth. Death. Memory. Time emerging from relationship.

const TAU = Math.PI * 2;
const PHI = 1.618033988749;

// ============ THE UNIVERSE ============

let ctx, master, verb, dly, sub;
let entities = [];
let ghosts = []; // Fading entities
let memory = []; // Pattern memory
let field = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    energy: 0,
    time: 0,
    pulse: 0,        // Emergent rhythm
    stillness: 0,    // Accumulated stillness
    gestureAngle: 0, // For detecting circles
    lastGesture: 0,
    breath: 0,       // Cosmic breath - slow oscillation
    breathPhase: 0,  // Phase of the breath cycle
    depth: 0,        // How deep into stillness we've gone
    constellations: [], // Stable harmonic formations
    // === PREDICTION SYSTEM ===
    px: 0.5, py: 0.5,           // Predicted position
    predictionError: 0,          // How wrong was our last prediction?
    predictionTension: 0,        // Musical tension from misprediction
    lastPredictedX: 0.5,
    lastPredictedY: 0.5,
    // === ENTRAINMENT SYSTEM ===
    userBPM: 90,                 // Detected user tempo (starts neutral)
    systemBPM: 90,               // Current system tempo (entrains to user)
    beatPhase: 0,                // Current phase in beat cycle (0-1)
    lastBeat: 0,                 // Time of last beat
    beatStrength: 0,             // How strong the current beat is
    onBeat: false                // True during beat window
};
let canvas, vc;
let running = false;

// ============ PREDICTION SYSTEM ============
// The system must know where you're going BEFORE you get there.

const PREDICTION_LOOKAHEAD = 0.12; // seconds into the future
const PREDICTION_SMOOTHING = 0.15; // how quickly prediction updates
const TENSION_DECAY = 0.92;        // how fast tension fades
const TENSION_THRESHOLD = 0.08;    // minimum error to create tension

function updatePrediction() {
    // Store what we predicted last frame
    field.lastPredictedX = field.px;
    field.lastPredictedY = field.py;

    // Simple momentum extrapolation: where will you be in LOOKAHEAD seconds?
    // velocity is per-frame (~16ms), so scale it
    const framesAhead = PREDICTION_LOOKAHEAD / 0.016;
    const rawPredictedX = field.x + field.vx * framesAhead;
    const rawPredictedY = field.y + field.vy * framesAhead;

    // Clamp to valid range
    const clampedX = Math.max(0.02, Math.min(0.98, rawPredictedX));
    const clampedY = Math.max(0.02, Math.min(0.98, rawPredictedY));

    // Smooth the prediction to avoid jitter
    field.px = field.px * (1 - PREDICTION_SMOOTHING) + clampedX * PREDICTION_SMOOTHING;
    field.py = field.py * (1 - PREDICTION_SMOOTHING) + clampedY * PREDICTION_SMOOTHING;

    // Calculate prediction error: how wrong was our LAST prediction?
    // Compare what we predicted vs where user actually went
    const errorX = field.lastPredictedX - field.x;
    const errorY = field.lastPredictedY - field.y;
    const error = Math.sqrt(errorX * errorX + errorY * errorY);

    // Smooth the error reading
    field.predictionError = field.predictionError * 0.7 + error * 0.3;

    // Tension builds when prediction is wrong (user changed direction)
    if (field.predictionError > TENSION_THRESHOLD) {
        // The bigger the error, the more tension
        const tensionBoost = Math.min(1, (field.predictionError - TENSION_THRESHOLD) * 5);
        field.predictionTension = Math.min(1, field.predictionTension + tensionBoost * 0.3);
    }

    // Tension decays over time
    field.predictionTension *= TENSION_DECAY;
}

// Get the predicted position for harmony selection
function getPredictedPosition() {
    return { x: field.px, y: field.py };
}

// ============ ENTRAINMENT SYSTEM ============
// The system listens to YOUR rhythm and syncs to it.
// You don't follow the beat - the beat follows YOU.

const ENTRAINMENT = {
    MIN_BPM: 40,
    MAX_BPM: 180,
    DEFAULT_BPM: 90,
    ENTRAIN_RATE: 0.08,         // How fast system BPM converges to user BPM
    BEAT_WINDOW: 0.15,          // Seconds around beat that count as "on beat"
    MIN_TAP_INTERVAL: 200,      // Minimum ms between tempo taps
    MAX_TAP_INTERVAL: 2000,     // Maximum ms to still count as tempo tap
    TAP_MEMORY: 8,              // Number of taps to average
    MOVEMENT_THRESHOLD: 0.02,   // Minimum velocity to count as movement event
    DIRECTION_CHANGE_WEIGHT: 2, // Direction changes are stronger tempo signals
};

// Circular buffer of movement event timestamps
let movementTaps = [];
let lastMovementTime = 0;
let lastMovementDirection = { x: 0, y: 0 };
let wasMoving = false;

// Detect user's natural tempo from movement patterns
function detectUserTempo(vx, vy) {
    const now = performance.now();
    const speed = Math.sqrt(vx * vx + vy * vy);
    const isMoving = speed > ENTRAINMENT.MOVEMENT_THRESHOLD;

    // Detect direction changes (strong tempo signal)
    const currentDir = { x: Math.sign(vx), y: Math.sign(vy) };
    const dirChanged = (currentDir.x !== 0 && currentDir.x !== lastMovementDirection.x) ||
                       (currentDir.y !== 0 && currentDir.y !== lastMovementDirection.y);

    // Movement start or direction change = potential tempo tap
    const tapEvent = (!wasMoving && isMoving) || (isMoving && dirChanged);

    if (tapEvent && now - lastMovementTime > ENTRAINMENT.MIN_TAP_INTERVAL) {
        const interval = now - lastMovementTime;

        if (interval < ENTRAINMENT.MAX_TAP_INTERVAL && lastMovementTime > 0) {
            // Weight direction changes more heavily
            const weight = dirChanged ? ENTRAINMENT.DIRECTION_CHANGE_WEIGHT : 1;
            for (let i = 0; i < weight; i++) {
                movementTaps.push(interval);
            }

            // Keep buffer size limited
            while (movementTaps.length > ENTRAINMENT.TAP_MEMORY * 2) {
                movementTaps.shift();
            }

            // Calculate average interval -> BPM
            if (movementTaps.length >= 3) {
                // Use median for robustness against outliers
                const sorted = [...movementTaps].sort((a, b) => a - b);
                const medianInterval = sorted[Math.floor(sorted.length / 2)];
                const detectedBPM = 60000 / medianInterval;

                // Clamp to valid range
                field.userBPM = Math.max(ENTRAINMENT.MIN_BPM,
                                  Math.min(ENTRAINMENT.MAX_BPM, detectedBPM));
            }
        }

        lastMovementTime = now;
    }

    lastMovementDirection = currentDir;
    wasMoving = isMoving;
}

// Entrain system BPM toward user BPM
function updateEntrainment(dt) {
    // Smoothly move system BPM toward user BPM
    const diff = field.userBPM - field.systemBPM;
    field.systemBPM += diff * ENTRAINMENT.ENTRAIN_RATE;

    // Update beat phase
    const beatsPerSecond = field.systemBPM / 60;
    field.beatPhase += dt * beatsPerSecond;

    // Detect beat crossing
    const prevOnBeat = field.onBeat;
    const phaseInBeat = field.beatPhase % 1;

    // On-beat window is centered around 0 (wraps from ~0.9 to ~0.1)
    field.onBeat = phaseInBeat < ENTRAINMENT.BEAT_WINDOW ||
                   phaseInBeat > (1 - ENTRAINMENT.BEAT_WINDOW);

    // Beat just started?
    if (field.onBeat && !prevOnBeat) {
        field.lastBeat = field.time;
        field.beatStrength = 1;
        triggerBeat();
    }

    // Beat strength decays
    field.beatStrength *= 0.85;
}

// Audio nodes for beat
let beatOsc = null;
let beatGain = null;
let beatFilter = null;

function createBeatAudio() {
    beatOsc = ctx.createOscillator();
    beatGain = ctx.createGain();
    beatFilter = ctx.createBiquadFilter();

    beatOsc.type = 'sine';
    beatOsc.frequency.value = BASE / 2; // Sub-bass frequency

    beatFilter.type = 'lowpass';
    beatFilter.frequency.value = 150;
    beatFilter.Q.value = 8;

    beatGain.gain.value = 0;

    beatOsc.connect(beatFilter);
    beatFilter.connect(beatGain);
    beatGain.connect(master);

    beatOsc.start();
}

// ============ POLYRHYTHMIC COUNTER-VOICE ============
// When you break YOUR pattern, a counter-voice emerges
// playing AGAINST your established rhythm

let counterOsc = null;
let counterGain = null;
let counterFilter = null;
let counterPhase = 0;
let counterActive = false;
let counterSubdivision = 1;
let lastCounterBeat = 0;

function createCounterAudio() {
    counterOsc = ctx.createOscillator();
    counterGain = ctx.createGain();
    counterFilter = ctx.createBiquadFilter();

    counterOsc.type = 'triangle';
    counterOsc.frequency.value = BASE * 2; // Higher than kick

    counterFilter.type = 'bandpass';
    counterFilter.frequency.value = 800;
    counterFilter.Q.value = 2;

    counterGain.gain.value = 0;

    counterOsc.connect(counterFilter);
    counterFilter.connect(counterGain);
    counterGain.connect(master);
    counterGain.connect(verb.input);

    counterOsc.start();
}

// Update counter-rhythm based on pattern state
function updateCounterRhythm(dt) {
    const pattern = getPatternState();

    // Counter-voice activates when there's an outlier
    if (pattern.isOutlier && pattern.confidence > 0.5) {
        counterActive = true;
        counterSubdivision = pattern.polyrhythm.subdivision;
    } else {
        // Fade out when pattern normalizes
        counterActive = counterActive && pattern.outlierScore > 1.0;
    }

    if (!counterActive || !counterGain || !ctx) return;

    // Counter phase runs at a different rate than main beat
    // This creates the polyrhythm
    const beatsPerSecond = field.systemBPM / 60;
    counterPhase += dt * beatsPerSecond * counterSubdivision;

    // Check for counter beat crossing
    const phaseInBeat = counterPhase % 1;
    const beatWindow = 0.1;

    if (phaseInBeat < beatWindow && (field.time - lastCounterBeat) > 0.1) {
        lastCounterBeat = field.time;
        triggerCounterBeat();
    }
}

// The counter-beat sound - distinct from the main kick
function triggerCounterBeat() {
    if (!counterGain || !ctx) return;

    const now = ctx.currentTime;
    const pattern = getPatternState();

    // Intensity based on how strong the outlier is
    const outlierIntensity = Math.min(1, (pattern.outlierScore - PATTERN.OUTLIER_THRESHOLD) / 2);
    const amp = 0.06 * outlierIntensity * (0.5 + pattern.confidence * 0.5);

    // Pitch based on outlier type
    let freq = BASE * 2;
    switch (pattern.outlierType) {
        case 'tempo':
            freq = BASE * 3;      // Higher - rhythmic deviation
            counterFilter.frequency.setValueAtTime(1200, now);
            break;
        case 'amplitude':
            freq = BASE * 2.5;    // Mid-high - energy deviation
            counterFilter.frequency.setValueAtTime(900, now);
            break;
        case 'direction':
            freq = BASE * 4;      // Highest - spatial deviation
            counterFilter.frequency.setValueAtTime(1500, now);
            break;
        default:
            freq = BASE * 2;
            counterFilter.frequency.setValueAtTime(800, now);
    }

    // Quick percussive envelope
    counterOsc.frequency.setValueAtTime(freq * 1.5, now);
    counterOsc.frequency.exponentialRampToValueAtTime(freq, now + 0.05);

    counterGain.gain.cancelScheduledValues(now);
    counterGain.gain.setValueAtTime(0, now);
    counterGain.gain.linearRampToValueAtTime(amp, now + 0.008);
    counterGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);
}

// Trigger the beat sound - soft kick that pulses with the user's rhythm
function triggerBeat() {
    if (!beatGain || !ctx) return;

    const now = ctx.currentTime;

    // Beat intensity scales with how active the user is
    const activityBoost = Math.min(1, field.energy * 3);
    const depthDampen = 1 - field.depth * 0.5; // Quieter in deep stillness
    const baseAmp = 0.15;
    const amp = baseAmp * (0.3 + activityBoost * 0.7) * depthDampen;

    // Pitch follows the harmonic center (lower when entities cluster low)
    let avgY = 0.5;
    let count = 0;
    for (const e of entities) {
        if (e.life > 0.3) {
            avgY += e.y;
            count++;
        }
    }
    if (count > 0) avgY /= count;
    const pitchMult = 0.8 + (1 - avgY) * 0.4; // Higher when entities are up
    const beatFreq = (BASE / 2) * pitchMult;

    // Soft kick envelope - quick attack, medium decay
    beatOsc.frequency.setValueAtTime(beatFreq * 2, now); // Start higher
    beatOsc.frequency.exponentialRampToValueAtTime(beatFreq, now + 0.08);

    beatGain.gain.cancelScheduledValues(now);
    beatGain.gain.setValueAtTime(0, now);
    beatGain.gain.linearRampToValueAtTime(amp, now + 0.01);
    beatGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25);

    // Filter sweep for punch
    beatFilter.frequency.setValueAtTime(300 + activityBoost * 200, now);
    beatFilter.frequency.exponentialRampToValueAtTime(80, now + 0.15);
}

// ============ PATTERN LEARNING SYSTEM ============
// The system learns YOUR movement pattern over time.
// Your deviations from YOUR norm create the music.

const PATTERN = {
    WINDOW_SIZE: 300,           // Samples to track (~5 seconds at 60fps)
    MIN_SAMPLES: 60,            // Minimum samples before pattern is valid
    OUTLIER_THRESHOLD: 2.0,     // Standard deviations to count as outlier
    MAJOR_OUTLIER: 3.0,         // Major break threshold
    DECAY_RATE: 0.998,          // How fast old samples fade
    UPDATE_INTERVAL: 3,         // Update stats every N frames (performance)
};

// ============ ORDER FROM CHAOS: CRYSTALLIZATION SYSTEM ============
// "A cell divides chaotically, but the result is order."
// Repetition crystallizes chaos into structure.

const CRYSTAL = {
    // Phase thresholds (based on repetition count)
    CHAOS_END: 5,               // Cycles before leaving pure chaos
    FORMING_END: 15,            // Cycles before crystallizing begins
    CRYSTAL_END: 30,            // Cycles before full lock
    MAX_REPS: 50,               // Maximum tracked repetitions

    // Behavior at each phase
    CHAOS_DETUNE: 30,           // Wide detune in chaos (cents)
    LOCKED_DETUNE: 1,           // Tight detune when locked (cents)

    // Entity merging
    MERGE_THRESHOLD: 0.7,       // Crystallization level to start merging
    MIN_ENTITIES_LOCKED: 2,     // Never merge below this

    // Entropy
    ENTROPY_RATE: 0.003,        // How fast crystallization decays with movement
    STILLNESS_PRESERVE: 0.5,    // Stillness slows entropy by this factor

    // The Drop
    DROP_THRESHOLD: 0.9,        // Crystallization level for "the drop"
    DROP_SILENCE_MS: 80,        // Silence before the drop (ms)
};

// Crystallization state
let crystalState = {
    repetitionCount: 0,         // How many pattern cycles completed
    crystallization: 0,         // 0-1, how crystallized the system is
    phase: 'chaos',             // 'chaos', 'forming', 'crystallizing', 'locked'
    entropy: 0,                 // Accumulated disorder from movement
    lastCycleTime: 0,           // When the last pattern cycle completed
    cycleDirection: 0,          // Direction at start of cycle
    dropTriggered: false,       // Whether we've hit "the drop"
    dropTime: 0,                // When the drop was triggered
    dominantRatio: 1,           // The ratio that's winning the crystallization
};

// Rolling statistics for pattern detection
let patternStats = {
    // Tempo (time between direction changes, in ms)
    tempoSamples: [],
    tempoMean: 500,         // Default ~120 BPM
    tempoStdDev: 100,

    // Amplitude (size of movements, 0-1 normalized)
    amplitudeSamples: [],
    amplitudeMean: 0.1,
    amplitudeStdDev: 0.05,

    // Direction histogram (8 directions, like a compass)
    directionHist: [0, 0, 0, 0, 0, 0, 0, 0], // N, NE, E, SE, S, SW, W, NW
    dominantDirection: -1,

    // Rhythm intervals (time between movement starts)
    rhythmSamples: [],
    rhythmMean: 400,
    rhythmStdDev: 100,

    // Is the pattern established?
    isValid: false,
    confidence: 0,           // 0-1, how confident we are in the pattern

    // Current outlier state
    outlierScore: 0,         // How much current behavior deviates
    outlierType: null,       // 'tempo', 'amplitude', 'direction', 'rhythm'
    outlierRatio: 1,         // Ratio of outlier to norm (for polyrhythm)
};

// Frame counter for update throttling
let patternFrameCount = 0;
let lastDirectionChangeTime = 0;
let lastMovementStartTime = 0;
let wasStationary = true;

// Quantize angle to 8 compass directions
function angleToDirection(angle) {
    // Normalize to 0-2π
    while (angle < 0) angle += Math.PI * 2;
    while (angle >= Math.PI * 2) angle -= Math.PI * 2;
    // 8 directions, each 45 degrees (π/4)
    return Math.floor((angle + Math.PI / 8) / (Math.PI / 4)) % 8;
}

// Calculate mean and standard deviation
function calcStats(samples) {
    if (samples.length < 3) return { mean: 0, stdDev: 1 };

    const mean = samples.reduce((a, b) => a + b, 0) / samples.length;
    const variance = samples.reduce((sum, val) => sum + (val - mean) ** 2, 0) / samples.length;
    const stdDev = Math.sqrt(variance);

    return { mean, stdDev: Math.max(stdDev, 0.001) }; // Avoid division by zero
}

// Add a tempo sample (time between direction changes)
function addTempoSample(intervalMs) {
    if (intervalMs < 100 || intervalMs > 3000) return; // Filter outliers

    patternStats.tempoSamples.push(intervalMs);
    while (patternStats.tempoSamples.length > PATTERN.WINDOW_SIZE) {
        patternStats.tempoSamples.shift();
    }
}

// Add an amplitude sample
function addAmplitudeSample(amplitude) {
    patternStats.amplitudeSamples.push(amplitude);
    while (patternStats.amplitudeSamples.length > PATTERN.WINDOW_SIZE) {
        patternStats.amplitudeSamples.shift();
    }
}

// Add a rhythm sample (time between movement onsets)
function addRhythmSample(intervalMs) {
    if (intervalMs < 50 || intervalMs > 5000) return;

    patternStats.rhythmSamples.push(intervalMs);
    while (patternStats.rhythmSamples.length > PATTERN.WINDOW_SIZE) {
        patternStats.rhythmSamples.shift();
    }
}

// Update direction histogram
function addDirectionSample(direction) {
    // Decay all bins slightly
    for (let i = 0; i < 8; i++) {
        patternStats.directionHist[i] *= PATTERN.DECAY_RATE;
    }
    // Add to current direction
    patternStats.directionHist[direction] += 1;

    // Find dominant direction
    let maxVal = 0;
    let maxDir = -1;
    for (let i = 0; i < 8; i++) {
        if (patternStats.directionHist[i] > maxVal) {
            maxVal = patternStats.directionHist[i];
            maxDir = i;
        }
    }
    patternStats.dominantDirection = maxDir;
}

// Update all pattern statistics
function updatePatternStats() {
    // Tempo stats
    if (patternStats.tempoSamples.length >= 5) {
        const stats = calcStats(patternStats.tempoSamples);
        patternStats.tempoMean = stats.mean;
        patternStats.tempoStdDev = stats.stdDev;
    }

    // Amplitude stats
    if (patternStats.amplitudeSamples.length >= 10) {
        const stats = calcStats(patternStats.amplitudeSamples);
        patternStats.amplitudeMean = stats.mean;
        patternStats.amplitudeStdDev = stats.stdDev;
    }

    // Rhythm stats
    if (patternStats.rhythmSamples.length >= 5) {
        const stats = calcStats(patternStats.rhythmSamples);
        patternStats.rhythmMean = stats.mean;
        patternStats.rhythmStdDev = stats.stdDev;
    }

    // Calculate confidence
    const sampleCount = Math.min(
        patternStats.tempoSamples.length,
        patternStats.amplitudeSamples.length
    );
    patternStats.confidence = Math.min(1, sampleCount / PATTERN.MIN_SAMPLES);
    patternStats.isValid = sampleCount >= PATTERN.MIN_SAMPLES;
}

// Detect outliers in current movement
function detectOutlier(currentTempo, currentAmplitude, currentDirection) {
    if (!patternStats.isValid) {
        patternStats.outlierScore = 0;
        patternStats.outlierType = null;
        patternStats.outlierRatio = 1;
        return;
    }

    let maxScore = 0;
    let outlierType = null;
    let outlierRatio = 1;

    // Check tempo outlier
    if (currentTempo > 0) {
        const tempoZ = Math.abs(currentTempo - patternStats.tempoMean) / patternStats.tempoStdDev;
        if (tempoZ > maxScore) {
            maxScore = tempoZ;
            outlierType = 'tempo';
            outlierRatio = currentTempo / patternStats.tempoMean;
        }
    }

    // Check amplitude outlier
    const ampZ = Math.abs(currentAmplitude - patternStats.amplitudeMean) / patternStats.amplitudeStdDev;
    if (ampZ > maxScore) {
        maxScore = ampZ;
        outlierType = 'amplitude';
        outlierRatio = currentAmplitude / Math.max(0.01, patternStats.amplitudeMean);
    }

    // Check direction outlier (going where you usually don't)
    if (currentDirection >= 0 && patternStats.dominantDirection >= 0) {
        const dirDiff = Math.abs(currentDirection - patternStats.dominantDirection);
        const normalizedDiff = Math.min(dirDiff, 8 - dirDiff) / 4; // 0-1
        const totalHist = patternStats.directionHist.reduce((a, b) => a + b, 0);
        const expectedProb = patternStats.directionHist[currentDirection] / Math.max(1, totalHist);

        // Low probability direction = outlier
        if (expectedProb < 0.1 && normalizedDiff > 0.5) {
            const dirScore = (1 - expectedProb) * 3 + normalizedDiff * 2;
            if (dirScore > maxScore) {
                maxScore = dirScore;
                outlierType = 'direction';
                outlierRatio = 1 + normalizedDiff; // Direction ratio is less meaningful
            }
        }
    }

    // Smooth the outlier score
    patternStats.outlierScore = patternStats.outlierScore * 0.7 + maxScore * 0.3;

    // Only update type if score is significant
    if (patternStats.outlierScore > PATTERN.OUTLIER_THRESHOLD) {
        patternStats.outlierType = outlierType;
        patternStats.outlierRatio = outlierRatio;
    } else {
        patternStats.outlierType = null;
        patternStats.outlierRatio = 1;
    }
}

// Quantize ratio to musical polyrhythm
function quantizeToPolyrhythm(ratio) {
    // Common polyrhythms and their ratios
    const polyrhythms = [
        { ratio: 1.0, name: '1:1', subdivision: 1 },
        { ratio: 1.5, name: '3:2', subdivision: 1.5 },
        { ratio: 1.333, name: '4:3', subdivision: 1.333 },
        { ratio: 1.25, name: '5:4', subdivision: 1.25 },
        { ratio: 1.2, name: '6:5', subdivision: 1.2 },
        { ratio: 2.0, name: '2:1', subdivision: 2 },
        { ratio: 0.667, name: '2:3', subdivision: 0.667 },
        { ratio: 0.75, name: '3:4', subdivision: 0.75 },
        { ratio: 0.8, name: '4:5', subdivision: 0.8 },
    ];

    // Find closest polyrhythm
    let closest = polyrhythms[0];
    let minDiff = Math.abs(ratio - closest.ratio);

    for (const p of polyrhythms) {
        const diff = Math.abs(ratio - p.ratio);
        if (diff < minDiff) {
            minDiff = diff;
            closest = p;
        }
    }

    return closest;
}

// Main pattern update function - called from input handlers
function updatePattern(vx, vy) {
    const now = performance.now();
    const speed = Math.sqrt(vx * vx + vy * vy);
    const isMoving = speed > 0.01;
    const amplitude = Math.min(1, speed * 10); // Normalize to 0-1

    // Track amplitude continuously
    addAmplitudeSample(amplitude);

    // Movement onset detection
    if (isMoving && wasStationary) {
        const interval = now - lastMovementStartTime;
        if (lastMovementStartTime > 0) {
            addRhythmSample(interval);
        }
        lastMovementStartTime = now;
    }
    wasStationary = !isMoving;

    // Direction tracking (only when moving)
    if (isMoving) {
        const angle = Math.atan2(vy, vx);
        const direction = angleToDirection(angle);
        addDirectionSample(direction);

        // Direction change detection for tempo
        const currentDir = { x: Math.sign(vx), y: Math.sign(vy) };
        if (lastMovementDirection.x !== 0 || lastMovementDirection.y !== 0) {
            const dirChanged =
                (currentDir.x !== 0 && currentDir.x !== lastMovementDirection.x) ||
                (currentDir.y !== 0 && currentDir.y !== lastMovementDirection.y);

            if (dirChanged) {
                const tempoInterval = now - lastDirectionChangeTime;
                if (lastDirectionChangeTime > 0) {
                    addTempoSample(tempoInterval);
                }
                lastDirectionChangeTime = now;

                // CRYSTALLIZATION: Track pattern cycles
                detectPatternCycle(direction);
            }
        }
    }

    // Throttled stats update
    patternFrameCount++;
    if (patternFrameCount >= PATTERN.UPDATE_INTERVAL) {
        patternFrameCount = 0;
        updatePatternStats();

        // Detect outliers
        const currentTempo = now - lastDirectionChangeTime;
        const direction = isMoving ? angleToDirection(Math.atan2(vy, vx)) : -1;
        detectOutlier(currentTempo, amplitude, direction);
    }
}

// Get pattern data for musical response
function getPatternState() {
    return {
        isValid: patternStats.isValid,
        confidence: patternStats.confidence,
        outlierScore: patternStats.outlierScore,
        outlierType: patternStats.outlierType,
        outlierRatio: patternStats.outlierRatio,
        isOutlier: patternStats.outlierScore > PATTERN.OUTLIER_THRESHOLD,
        isMajorOutlier: patternStats.outlierScore > PATTERN.MAJOR_OUTLIER,
        polyrhythm: quantizeToPolyrhythm(patternStats.outlierRatio),
        tempoMean: patternStats.tempoMean,
        amplitudeMean: patternStats.amplitudeMean,
        // Crystallization data
        crystallization: crystalState.crystallization,
        phase: crystalState.phase,
        repetitionCount: crystalState.repetitionCount,
        dropTriggered: crystalState.dropTriggered,
    };
}

// ============ CRYSTALLIZATION UPDATE ============
// Track repetition cycles and update crystallization state

function detectPatternCycle(direction) {
    const now = performance.now();

    // A cycle completes when we return to the starting direction
    // after having moved away from it
    if (crystalState.cycleDirection === -1) {
        // First direction - set as cycle start
        crystalState.cycleDirection = direction;
        crystalState.lastCycleTime = now;
        return;
    }

    // Check if we've returned to starting direction (opposite direction)
    const opposite = (crystalState.cycleDirection + 4) % 8;
    const isReturning = Math.abs(direction - opposite) <= 1 ||
                        Math.abs(direction - opposite) >= 7;

    if (isReturning && now - crystalState.lastCycleTime > 200) {
        // Cycle complete!
        crystalState.repetitionCount = Math.min(
            CRYSTAL.MAX_REPS,
            crystalState.repetitionCount + 1
        );
        crystalState.lastCycleTime = now;
        crystalState.cycleDirection = direction;

        // Find dominant ratio among entities
        updateDominantRatio();
    }
}

function updateDominantRatio() {
    // Find which ratio has the most entities with high life
    const ratioCounts = {};
    for (const e of entities) {
        if (e.life > 0.5) {
            const key = e.ratio.toFixed(3);
            ratioCounts[key] = (ratioCounts[key] || 0) + e.life;
        }
    }

    let maxCount = 0;
    let dominant = 1;
    for (const [ratio, count] of Object.entries(ratioCounts)) {
        if (count > maxCount) {
            maxCount = count;
            dominant = parseFloat(ratio);
        }
    }

    crystalState.dominantRatio = dominant;
}

function updateCrystallization(dt) {
    const speed = Math.sqrt(field.vx * field.vx + field.vy * field.vy);

    // Entropy builds with movement, slowed by stillness
    if (speed > 0.01) {
        const stillnessFactor = 1 - field.stillness * CRYSTAL.STILLNESS_PRESERVE;
        crystalState.entropy += speed * CRYSTAL.ENTROPY_RATE * stillnessFactor;
    } else {
        // Stillness slowly reduces entropy
        crystalState.entropy *= 0.995;
    }

    // Calculate crystallization from repetition count minus entropy
    const rawCrystal = crystalState.repetitionCount / CRYSTAL.CRYSTAL_END;
    crystalState.crystallization = Math.max(0, Math.min(1,
        rawCrystal - crystalState.entropy
    ));

    // Determine phase
    const reps = crystalState.repetitionCount;
    if (reps < CRYSTAL.CHAOS_END || crystalState.crystallization < 0.15) {
        crystalState.phase = 'chaos';
        crystalState.dropTriggered = false;
    } else if (reps < CRYSTAL.FORMING_END || crystalState.crystallization < 0.4) {
        crystalState.phase = 'forming';
        crystalState.dropTriggered = false;
    } else if (reps < CRYSTAL.CRYSTAL_END || crystalState.crystallization < 0.85) {
        crystalState.phase = 'crystallizing';
    } else {
        crystalState.phase = 'locked';

        // THE DROP - triggered once when hitting locked state
        if (!crystalState.dropTriggered && crystalState.crystallization >= CRYSTAL.DROP_THRESHOLD) {
            triggerTheDrop();
        }
    }

    // Entropy can reset the repetition count if it overwhelms
    if (crystalState.entropy > 0.8) {
        crystalState.repetitionCount = Math.max(0,
            crystalState.repetitionCount - 1
        );
        crystalState.entropy *= 0.9; // Consume entropy
    }
}

function triggerTheDrop() {
    if (!ctx) return;

    crystalState.dropTriggered = true;
    crystalState.dropTime = performance.now();

    const now = ctx.currentTime;

    // Brief silence before the drop
    // Reduce all gains momentarily
    master.gain.setValueAtTime(master.gain.value, now);
    master.gain.linearRampToValueAtTime(0.1, now + CRYSTAL.DROP_SILENCE_MS / 1000);

    // THE DROP - everything comes back HARD
    master.gain.linearRampToValueAtTime(0.9, now + CRYSTAL.DROP_SILENCE_MS / 1000 + 0.02);
    master.gain.linearRampToValueAtTime(0.7, now + 0.5);

    // Trigger a strong beat at the drop
    setTimeout(() => {
        if (beatGain && ctx) {
            const dropNow = ctx.currentTime;
            beatOsc.frequency.setValueAtTime(BASE, dropNow);
            beatOsc.frequency.exponentialRampToValueAtTime(BASE / 2, dropNow + 0.15);
            beatGain.gain.cancelScheduledValues(dropNow);
            beatGain.gain.setValueAtTime(0, dropNow);
            beatGain.gain.linearRampToValueAtTime(0.35, dropNow + 0.01);
            beatGain.gain.exponentialRampToValueAtTime(0.001, dropNow + 0.4);
        }
    }, CRYSTAL.DROP_SILENCE_MS);
}

// ============ GESTURE RECOGNITION ============

const GESTURE_BUFFER_MS = 500;
const GESTURE_SAMPLE_RATE = 60; // ~16ms per sample
const GESTURE_BUFFER_SIZE = Math.ceil(GESTURE_BUFFER_MS / (1000 / GESTURE_SAMPLE_RATE));

let gestureBuffer = [];
let lastGestureTime = 0;
let currentGesture = null;

// Gesture thresholds (tuned through experimentation)
const GESTURE_THRESHOLDS = {
    SHAKE_ENERGY: 0.15,      // Minimum energy for shake
    SHAKE_REVERSALS: 3,      // Minimum direction changes for shake
    SWIPE_VELOCITY: 0.08,    // Minimum velocity for swipe
    SWIPE_LINEARITY: 0.7,    // How straight the path must be (0-1)
    TAP_DURATION: 150,       // Max ms for a tap
    HOLD_DURATION: 400,      // Min ms for a hold
    CIRCLE_ROTATION: Math.PI * 1.5, // Min radians for circle
    COOLDOWN: 200            // Min ms between gesture detections
};

function addGestureSample(x, y, vx, vy, ax, ay) {
    const now = performance.now();

    gestureBuffer.push({
        time: now,
        x, y,
        vx, vy,
        ax, ay,
        energy: Math.sqrt(vx*vx + vy*vy),
        angle: Math.atan2(vy, vx)
    });

    // Trim old samples
    while (gestureBuffer.length > 0 &&
           now - gestureBuffer[0].time > GESTURE_BUFFER_MS) {
        gestureBuffer.shift();
    }
}

function detectGesture() {
    if (gestureBuffer.length < 5) return null;

    const now = performance.now();
    if (now - lastGestureTime < GESTURE_THRESHOLDS.COOLDOWN) return null;

    const buffer = gestureBuffer;
    const duration = buffer[buffer.length - 1].time - buffer[0].time;

    // Calculate aggregate metrics
    let totalEnergy = 0;
    let maxEnergy = 0;
    let directionReversals = 0;
    let totalRotation = 0;
    let prevAngle = buffer[0].angle;

    // Track start and end positions for swipe detection
    const startX = buffer[0].x;
    const startY = buffer[0].y;
    const endX = buffer[buffer.length - 1].x;
    const endY = buffer[buffer.length - 1].y;
    const displacement = Math.sqrt((endX - startX)**2 + (endY - startY)**2);

    // Track path length for linearity
    let pathLength = 0;

    for (let i = 1; i < buffer.length; i++) {
        const sample = buffer[i];
        const prev = buffer[i - 1];

        totalEnergy += sample.energy;
        maxEnergy = Math.max(maxEnergy, sample.energy);

        // Path length
        pathLength += Math.sqrt((sample.x - prev.x)**2 + (sample.y - prev.y)**2);

        // Direction reversals (for shake detection)
        const dotProduct = sample.vx * prev.vx + sample.vy * prev.vy;
        if (dotProduct < -0.001 && prev.energy > 0.02 && sample.energy > 0.02) {
            directionReversals++;
        }

        // Total rotation (for circle detection)
        let angleDiff = sample.angle - prevAngle;
        // Normalize to -PI to PI
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        totalRotation += angleDiff;
        prevAngle = sample.angle;
    }

    const avgEnergy = totalEnergy / buffer.length;
    const linearity = pathLength > 0.001 ? displacement / pathLength : 0;

    // ============ GESTURE CLASSIFICATION ============

    // SHAKE: High energy with multiple direction reversals
    if (avgEnergy > GESTURE_THRESHOLDS.SHAKE_ENERGY &&
        directionReversals >= GESTURE_THRESHOLDS.SHAKE_REVERSALS) {
        lastGestureTime = now;
        return {
            type: 'SHAKE',
            intensity: Math.min(1, avgEnergy / 0.3),
            reversals: directionReversals
        };
    }

    // CIRCLE: Accumulated rotation exceeds threshold
    if (Math.abs(totalRotation) > GESTURE_THRESHOLDS.CIRCLE_ROTATION &&
        avgEnergy > 0.02) {
        lastGestureTime = now;
        return {
            type: 'CIRCLE',
            direction: totalRotation > 0 ? 'CW' : 'CCW',
            rotations: Math.abs(totalRotation) / (2 * Math.PI)
        };
    }

    // SWIPE: Fast, linear movement
    if (avgEnergy > GESTURE_THRESHOLDS.SWIPE_VELOCITY &&
        linearity > GESTURE_THRESHOLDS.SWIPE_LINEARITY &&
        displacement > 0.1) {
        lastGestureTime = now;
        const angle = Math.atan2(endY - startY, endX - startX);
        let direction;
        if (angle > -Math.PI/4 && angle <= Math.PI/4) direction = 'RIGHT';
        else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) direction = 'DOWN';
        else if (angle > -3*Math.PI/4 && angle <= -Math.PI/4) direction = 'UP';
        else direction = 'LEFT';

        return {
            type: 'SWIPE',
            direction,
            velocity: avgEnergy,
            distance: displacement
        };
    }

    // HOLD: Low energy for extended duration
    if (avgEnergy < 0.01 && duration > GESTURE_THRESHOLDS.HOLD_DURATION) {
        // Only fire hold once per stillness period
        if (!currentGesture || currentGesture.type !== 'HOLD') {
            lastGestureTime = now;
            return {
                type: 'HOLD',
                duration: duration,
                position: { x: endX, y: endY }
            };
        }
    }

    return null;
}

function onGestureDetected(gesture) {
    // Store for external access
    currentGesture = gesture;
    field.lastGesture = field.time;

    // Visual feedback - pulse the cursor
    field.energy = Math.max(field.energy, gesture.intensity || 0.3);

    // ============ MUSICAL RESPONSES ============

    switch (gesture.type) {
        case 'SHAKE':
            // Tremolo/trill - rapid oscillation of nearby entities
            triggerShake(gesture.intensity);
            break;

        case 'SWIPE':
            // Quick melodic run in swipe direction
            triggerSwipe(gesture.direction, gesture.velocity);
            break;

        case 'CIRCLE':
            // Arpeggio pattern cycling through chord
            triggerCircle(gesture.direction, gesture.rotations);
            break;

        case 'HOLD':
            // Deepen reverb, let notes bloom and sustain
            triggerHold(gesture.duration);
            break;
    }
}

// ============ GESTURE MUSICAL RESPONSES ============

function triggerShake(intensity) {
    // Find entities near the cursor and make them tremble
    const now = ctx.currentTime;

    for (const e of entities) {
        const dx = field.x - e.x;
        const dy = field.y - e.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 0.25 && e.life > 0.3) {
            // Rapid pitch wobble - tremolo effect
            const wobbleDepth = intensity * e.freq * 0.03;
            const wobbleSpeed = 12 + intensity * 8; // 12-20 Hz tremolo

            // Schedule rapid oscillations over the next 300ms
            for (let t = 0; t < 0.3; t += 0.025) {
                const wobble = Math.sin(t * wobbleSpeed * TAU) * wobbleDepth;
                e.osc.frequency.setValueAtTime(e.freq + wobble, now + t);
                e.osc2.frequency.setValueAtTime(e.freq * 1.003 + wobble, now + t);
            }
            // Return to normal
            e.osc.frequency.linearRampToValueAtTime(e.freq, now + 0.35);
            e.osc2.frequency.linearRampToValueAtTime(e.freq * 1.003, now + 0.35);

            // Brief brightness boost
            e.brightness = Math.min(1, e.brightness + intensity * 0.5);
        }
    }
}

function triggerSwipe(direction, velocity) {
    // Quick melodic run - spawn temporary notes in the swipe direction
    const now = ctx.currentTime;

    // Find a nearby entity to base the run on
    let baseEntity = null;
    let minDist = Infinity;
    for (const e of entities) {
        const dx = field.x - e.x;
        const dy = field.y - e.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < minDist && e.life > 0.5) {
            minDist = dist;
            baseEntity = e;
        }
    }

    // Determine scale direction based on swipe
    const ascending = (direction === 'UP' || direction === 'RIGHT');

    // Use entity frequency if available, otherwise derive from field position
    let baseRatio;
    if (baseEntity) {
        baseRatio = baseEntity.ratio;
    } else {
        // Fallback: position-based root (Y controls octave, X controls mode)
        const octave = 1 + Math.floor((1 - field.y) * 3); // 1-4 based on Y
        const rootRatios = [1, 9/8, 5/4, 4/3, 3/2, 5/3, 15/8]; // Major scale
        const rootIndex = Math.floor(field.x * rootRatios.length);
        baseRatio = rootRatios[rootIndex] * octave;
    }

    // Simple pentatonic-ish intervals for the run
    const intervals = ascending
        ? [1, 9/8, 5/4, 3/2, 5/3]    // Ascending run
        : [1, 8/9, 4/5, 2/3, 3/5];   // Descending run

    // Play quick arpeggio using temporary oscillators
    const runSpeed = 0.06 / (0.5 + velocity); // Faster swipe = faster notes

    intervals.forEach((interval, i) => {
        const noteTime = now + i * runSpeed;
        const freq = BASE * baseRatio * interval;

        // Create a quick note
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = freq;
        gain.gain.value = 0;

        osc.connect(gain);
        gain.connect(master);
        gain.connect(verb.input);

        // Quick envelope
        gain.gain.setValueAtTime(0, noteTime);
        gain.gain.linearRampToValueAtTime(0.08 * (1 - i * 0.15), noteTime + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, noteTime + 0.15);

        osc.start(noteTime);
        osc.stop(noteTime + 0.2);
    });
}

function triggerCircle(direction, rotations) {
    // Arpeggio loop - cycle through chord tones of nearby entities
    const now = ctx.currentTime;

    // Gather frequencies of nearby, alive entities
    const nearbyFreqs = [];
    for (const e of entities) {
        const dx = field.x - e.x;
        const dy = field.y - e.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 0.3 && e.life > 0.4) {
            nearbyFreqs.push(e.freq);
        }
    }

    // Fallback: if only one entity nearby, pulse it rhythmically
    if (nearbyFreqs.length === 0) return;
    if (nearbyFreqs.length === 1) {
        // Single entity - create a rhythmic pulse on that one note
        const freq = nearbyFreqs[0];
        const noteCount = Math.min(4, Math.ceil(rotations * 2));
        const noteSpeed = 0.12;

        for (let i = 0; i < noteCount; i++) {
            const noteTime = now + i * noteSpeed;

            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = 'sine';
            osc.frequency.value = freq;
            gain.gain.value = 0;

            osc.connect(gain);
            gain.connect(master);
            gain.connect(verb.input);

            // Pulsing envelope
            gain.gain.setValueAtTime(0, noteTime);
            gain.gain.linearRampToValueAtTime(0.07, noteTime + 0.015);
            gain.gain.exponentialRampToValueAtTime(0.001, noteTime + 0.18);

            osc.start(noteTime);
            osc.stop(noteTime + 0.25);
        }
        return;
    }

    // Sort by frequency
    nearbyFreqs.sort((a, b) => a - b);

    // Direction determines arpeggio direction
    if (direction === 'CCW') nearbyFreqs.reverse();

    // Play arpeggio with number of notes based on rotations
    const noteCount = Math.min(nearbyFreqs.length * 2, Math.ceil(rotations * nearbyFreqs.length));
    const noteSpeed = 0.1;

    for (let i = 0; i < noteCount; i++) {
        const freq = nearbyFreqs[i % nearbyFreqs.length];
        const noteTime = now + i * noteSpeed;

        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.value = 0;

        osc.connect(gain);
        gain.connect(master);
        gain.connect(verb.input);
        gain.connect(dly.input);

        // Soft envelope
        gain.gain.setValueAtTime(0, noteTime);
        gain.gain.linearRampToValueAtTime(0.06, noteTime + 0.02);
        gain.gain.exponentialRampToValueAtTime(0.001, noteTime + 0.25);

        osc.start(noteTime);
        osc.stop(noteTime + 0.3);
    }
}

function triggerHold(duration) {
    // Deepen reverb and let existing notes sustain and bloom
    const now = ctx.currentTime;

    // Temporarily boost reverb
    const boostAmount = Math.min(0.3, duration / 2000);
    verb.output.gain.linearRampToValueAtTime(
        verb.baseGain + boostAmount + 0.15,
        now + 0.2
    );

    // Slowly return to normal over 2 seconds
    verb.output.gain.linearRampToValueAtTime(verb.baseGain, now + 2);

    // Give nearby entities a life and brightness boost
    for (const e of entities) {
        const dx = field.x - e.x;
        const dy = field.y - e.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        if (dist < 0.25) {
            e.life = Math.min(1, e.life + 0.2);
            e.lastVisit = field.time;

            // Open their filters for more harmonics
            e.filter.frequency.linearRampToValueAtTime(
                e.filter.frequency.value + 500,
                now + 0.3
            );
        }
    }

    // Boost stillness and depth
    field.stillness = Math.min(3, field.stillness + 0.5);
    field.depth = Math.min(1, field.depth + 0.1);
}

// All possible harmonic ratios - the DNA pool
const ALL_RATIOS = [
    1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8,
    2, 9/4, 12/5, 5/2, 8/3, 3, 16/5, 10/3, 15/4, 4, 9/2, 5, 6, 8
];

const BASE = 55;
const MAX_ENTITIES = 24;
const MIN_ENTITIES = 5;

// Consonance - the gravity of music
function consonance(r1, r2) {
    let ratio = r1 > r2 ? r1/r2 : r2/r1;
    // Normalize to one octave
    while (ratio > 2) ratio /= 2;

    if (Math.abs(ratio - 1) < 0.01) return 1;
    if (Math.abs(ratio - 2) < 0.01) return 0.95;
    if (Math.abs(ratio - 1.5) < 0.01) return 0.9;
    if (Math.abs(ratio - 4/3) < 0.02) return 0.85;
    if (Math.abs(ratio - 5/4) < 0.02) return 0.75;
    if (Math.abs(ratio - 6/5) < 0.02) return 0.7;
    if (Math.abs(ratio - 5/3) < 0.02) return 0.65;
    if (Math.abs(ratio - 8/5) < 0.02) return 0.6;
    return 0.3;
}

// Harmonic regions - different areas favor different modes
function getRegionalMode(x, y) {
    // Center = pure/Ionian, edges = more color
    const distFromCenter = Math.sqrt((x-0.5)**2 + (y-0.5)**2);
    const angle = Math.atan2(y - 0.5, x - 0.5);

    // Different corners = different modes
    // Top-right: Lydian (bright)
    // Bottom-right: Mixolydian (bluesy)
    // Bottom-left: Dorian (dark)
    // Top-left: Phrygian (exotic)

    const modeInfluence = Math.min(1, distFromCenter * 2);
    let ratioBonus = {};

    if (angle > 0 && angle < Math.PI/2) { // Top-right: Lydian
        ratioBonus = { [45/32]: 0.3, [15/8]: 0.2 }; // #4, maj7
    } else if (angle >= Math.PI/2) { // Top-left: Phrygian
        ratioBonus = { [16/15]: 0.3, [8/5]: 0.2 }; // b2, b6
    } else if (angle < -Math.PI/2) { // Bottom-left: Dorian
        ratioBonus = { [6/5]: 0.2, [9/5]: 0.2 }; // min3, min7
    } else { // Bottom-right: Mixolydian
        ratioBonus = { [9/5]: 0.3, [5/4]: 0.2 }; // b7, maj3
    }

    return { influence: modeInfluence, bonus: ratioBonus };
}

// ============ SUPERSAW CONFIGURATION ============
// When patterns lock in, the sound becomes MASSIVE

const SUPERSAW = {
    VOICES: 7,                    // Number of saw oscillators per entity
    MAX_DETUNE: 25,               // Maximum detune in cents when chaotic
    MIN_DETUNE: 3,                // Minimum detune when locked (tight)
    LOCK_THRESHOLD: 0.7,          // Pattern confidence to start locking
    FIFTH_THRESHOLD: 0.8,         // Pattern confidence to add 5th
    OCTAVE_THRESHOLD: 0.9,        // Pattern confidence to add octave
    LOCK_RATE: 0.05,              // How fast detune tightens (per frame)
    UNLOCK_RATE: 0.02,            // How fast detune loosens
    FIFTH_RATIO: 1.5,             // Perfect 5th
    OCTAVE_RATIO: 2.0,            // Octave
};

// ============ ENTITY - A LIVING HARMONIC ============

let entityId = 0;

class Entity {
    constructor(ratio, x, y) {
        this.id = entityId++;
        this.ratio = ratio;
        this.freq = BASE * ratio;

        this.x = x !== undefined ? x : 0.5 + (Math.random() - 0.5) * 0.4;
        this.y = y !== undefined ? y : 0.5 + (Math.random() - 0.5) * 0.4;
        this.vx = (Math.random() - 0.5) * 0.005;
        this.vy = (Math.random() - 0.5) * 0.005;

        this.mass = 1 / Math.sqrt(ratio);
        this.life = 1;
        this.age = 0;
        this.lastVisit = 0; // When cursor was last near
        this.brightness = 0;

        // Synchronization
        this.phase = Math.random() * TAU;
        this.syncPhase = 0;
        this.neighbors = [];

        // Audio nodes - SUPERSAW: multiple oscillators with variable detune
        this.sawOscs = [];        // Array of sawtooth oscillators
        this.sawDetunes = [];     // Base detune offsets for each saw
        this.fifthOsc = null;     // 5th harmonic oscillator
        this.octaveOsc = null;    // Octave oscillator
        this.fifthGain = null;    // 5th gain (fades in with pattern)
        this.octaveGain = null;   // Octave gain
        this.filter = null;
        this.gain = null;
        this.pan = null;
        this.mod = null;
        this.modGain = null;

        // Supersaw state
        this.currentDetune = SUPERSAW.MAX_DETUNE;  // Starts detuned (chaotic)
        this.lockedIn = false;                      // Whether this entity is "locked"

        // Visual
        this.trail = [];
        this.maxTrail = 40;
        this.hue = (180 - Math.log2(ratio) * 60 + 360) % 360;
        this.birthTime = field.time;
    }

    createAudio() {
        // ============ SUPERSAW: 7 detuned sawtooth oscillators ============
        // Detune spread: centered, symmetric distribution
        const detuneOffsets = [-1, -0.67, -0.33, 0, 0.33, 0.67, 1];

        for (let i = 0; i < SUPERSAW.VOICES; i++) {
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = this.freq;
            // Store base detune offset (will be scaled by currentDetune)
            this.sawDetunes.push(detuneOffsets[i]);
            this.sawOscs.push(osc);
        }

        // ============ STACKED 5THS: 5th and octave for massive chords ============
        this.fifthOsc = ctx.createOscillator();
        this.fifthOsc.type = 'sawtooth';
        this.fifthOsc.frequency.value = this.freq * SUPERSAW.FIFTH_RATIO;

        this.octaveOsc = ctx.createOscillator();
        this.octaveOsc.type = 'sawtooth';
        this.octaveOsc.frequency.value = this.freq * SUPERSAW.OCTAVE_RATIO;

        this.fifthGain = ctx.createGain();
        this.fifthGain.gain.value = 0;  // Starts silent, fades in with pattern

        this.octaveGain = ctx.createGain();
        this.octaveGain.gain.value = 0;

        this.fifthOsc.connect(this.fifthGain);
        this.octaveOsc.connect(this.octaveGain);

        // FM modulation for texture
        this.mod = ctx.createOscillator();
        this.modGain = ctx.createGain();
        this.mod.type = 'sine';
        this.mod.frequency.value = this.freq * PHI;
        this.modGain.gain.value = 0;
        this.mod.connect(this.modGain);

        // Connect modulator to all saw oscillators
        for (const osc of this.sawOscs) {
            this.modGain.connect(osc.frequency);
        }

        // Filter - lowpass to tame the brightness
        this.filter = ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 200;
        this.filter.Q.value = 1.5;  // Slightly more resonant for supersaws

        // Main gain
        this.gain = ctx.createGain();
        this.gain.gain.value = 0;

        // Stereo pan
        this.pan = ctx.createStereoPanner();

        // Connect all oscillators through filter
        for (const osc of this.sawOscs) {
            osc.connect(this.filter);
        }
        this.fifthGain.connect(this.filter);
        this.octaveGain.connect(this.filter);

        this.filter.connect(this.gain);
        this.gain.connect(this.pan);
        this.pan.connect(master);
        this.pan.connect(verb.input);
        this.pan.connect(dly.input);

        // Start all oscillators
        for (const osc of this.sawOscs) {
            osc.start();
        }
        this.fifthOsc.start();
        this.octaveOsc.start();
        this.mod.start();
    }

    destroy() {
        const now = ctx.currentTime;
        this.gain.gain.linearRampToValueAtTime(0, now + 0.5);
        setTimeout(() => {
            for (const osc of this.sawOscs) {
                osc.stop();
            }
            this.fifthOsc.stop();
            this.octaveOsc.stop();
            this.mod.stop();
        }, 600);
    }

    update(dt) {
        const now = ctx.currentTime;
        this.age += dt;

        // ============ LIFE AND DEATH ============

        const dx = field.x - this.x;
        const dy = field.y - this.y;
        const distToCursor = Math.sqrt(dx*dx + dy*dy);

        // Being near cursor sustains life
        if (distToCursor < 0.2) {
            this.lastVisit = field.time;
            this.life = Math.min(1, this.life + dt * 0.5);
        }

        // Neglect causes fading
        const timeSinceVisit = field.time - this.lastVisit;
        if (timeSinceVisit > 5) {
            this.life -= dt * 0.05 * (timeSinceVisit - 5);
        }

        // Young entities are fragile
        if (this.age < 2) {
            this.life = Math.min(this.life, this.age / 2);
        }

        // ============ PHYSICS ============

        const cursorForce = 0.0004 / (distToCursor + 0.1);
        this.vx += dx * cursorForce;
        this.vy += dy * cursorForce;

        // Inter-entity forces
        this.neighbors = [];
        for (const other of entities) {
            if (other === this || other.life <= 0) continue;

            const odx = other.x - this.x;
            const ody = other.y - this.y;
            const dist = Math.sqrt(odx*odx + ody*ody);
            if (dist < 0.01 || dist > 0.4) continue;

            const cons = consonance(this.ratio, other.ratio);
            const force = (cons - 0.35) * 0.00004 / (dist + 0.03);

            this.vx += odx * force;
            this.vy += ody * force;

            if (dist < 0.15 && cons > 0.6) {
                this.neighbors.push(other);
            }
        }

        // Center gravity
        this.vx += (0.5 - this.x) * 0.00015;
        this.vy += (0.5 - this.y) * 0.00015;

        // Angular momentum from cursor
        this.vx += -dy * field.vx * 0.015;
        this.vy += dx * field.vy * 0.015;

        // Regional mode influence on movement
        const mode = getRegionalMode(this.x, this.y);
        if (mode.bonus[this.ratio]) {
            // This entity belongs here - slow down, settle
            this.vx *= 0.98;
            this.vy *= 0.98;
        }

        this.vx *= 0.994;
        this.vy *= 0.994;

        this.x += this.vx;
        this.y += this.vy;

        // Soft boundaries
        if (this.x < 0.03) { this.x = 0.03; this.vx *= -0.5; }
        if (this.x > 0.97) { this.x = 0.97; this.vx *= -0.5; }
        if (this.y < 0.03) { this.y = 0.03; this.vy *= -0.5; }
        if (this.y > 0.97) { this.y = 0.97; this.vy *= -0.5; }

        // Trail
        this.trail.unshift({ x: this.x, y: this.y, life: this.life });
        if (this.trail.length > this.maxTrail) this.trail.pop();

        // ============ SYNCHRONIZATION ============

        // Phase advances based on frequency (creates natural rhythm)
        this.phase += dt * (this.freq / BASE) * 0.5;

        // Sync with neighbors
        if (this.neighbors.length > 0) {
            let avgPhase = 0;
            for (const n of this.neighbors) {
                avgPhase += n.phase;
            }
            avgPhase /= this.neighbors.length;

            // Gently pull toward average phase
            const phaseDiff = avgPhase - this.phase;
            this.phase += phaseDiff * 0.02;
        }

        this.syncPhase = (Math.sin(this.phase) + 1) / 2; // 0-1 pulse

        // ============ SOUND (uses PREDICTED position!) ============

        // THE KEY INSIGHT: Sound responds to where you're GOING, not where you ARE
        const pdx = field.px - this.x;  // Distance to PREDICTED cursor position
        const pdy = field.py - this.y;
        const distToPredicted = Math.sqrt(pdx*pdx + pdy*pdy);

        // Proximity based on PREDICTED position - this is the magic
        const predictedProximity = 1 - Math.min(1, distToPredicted * 2.5);
        // Also keep current proximity for blending
        const currentProximity = 1 - Math.min(1, distToCursor * 2.5);
        // Blend: mostly predicted, but current adds stability
        const proximity = predictedProximity * 0.7 + currentProximity * 0.3;

        const vel = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        this.brightness = this.brightness * 0.92 + vel * 8;

        // TENSION from misprediction creates FM modulation and filter movement
        const tensionFM = field.predictionTension * this.freq * 0.8;
        const tensionFilter = field.predictionTension * 800;

        // OUTLIER INFLUENCE - when user breaks their pattern, sound responds
        const pattern = getPatternState();
        const outlierInfluence = pattern.isOutlier ? Math.min(1, (pattern.outlierScore - PATTERN.OUTLIER_THRESHOLD) / 2) : 0;
        const outlierFM = outlierInfluence * this.freq * 0.5 * pattern.confidence;
        const outlierFilter = outlierInfluence * 600 * pattern.confidence;

        // ============ CRYSTALLIZATION-DRIVEN SOUND ============
        // Order from chaos: repetition crystallizes sound into focused power

        const patternLockStrength = pattern.isValid ? pattern.confidence : 0;
        const crystal = crystalState.crystallization;
        const phase = crystalState.phase;

        // Is this entity the dominant ratio (or consonant with it)?
        const isDominant = consonance(this.ratio, crystalState.dominantRatio) > 0.85;

        // Target detune based on CRYSTALLIZATION (not just pattern)
        // Chaos = wide, Locked = tight
        let targetDetune;
        if (phase === 'locked' && isDominant) {
            // Fully crystallized - extremely tight
            targetDetune = CRYSTAL.LOCKED_DETUNE;
            this.lockedIn = true;
        } else if (phase === 'crystallizing') {
            // Transitioning - interpolate based on crystallization
            targetDetune = CRYSTAL.CHAOS_DETUNE - crystal * (CRYSTAL.CHAOS_DETUNE - CRYSTAL.LOCKED_DETUNE * 2);
            this.lockedIn = crystal > 0.6 && isDominant;
        } else if (phase === 'forming') {
            // Starting to form - slight tightening
            targetDetune = CRYSTAL.CHAOS_DETUNE * (1 - crystal * 0.3);
            this.lockedIn = false;
        } else {
            // Pure chaos
            targetDetune = CRYSTAL.CHAOS_DETUNE;
            this.lockedIn = false;
        }

        // Non-dominant entities stay chaotic even when crystallizing
        if (!isDominant && phase !== 'chaos') {
            targetDetune = Math.max(targetDetune, CRYSTAL.CHAOS_DETUNE * 0.7);
        }

        // Smooth transition toward target detune
        const detuneRate = this.lockedIn ? 0.08 : 0.03;
        this.currentDetune += (targetDetune - this.currentDetune) * detuneRate;

        // ============ CRYSTALLIZATION AMPLITUDE ============
        // Dominant entities get LOUDER as crystallization increases
        // Non-dominant entities FADE

        let crystalAmpMod = 1;
        if (phase === 'crystallizing' || phase === 'locked') {
            if (isDominant) {
                // Dominant entities amplify
                crystalAmpMod = 1 + crystal * 0.8;
            } else {
                // Non-dominant entities fade
                crystalAmpMod = 1 - crystal * 0.6;
            }
        }

        // ============ STACKED 5THS - THE MASSIVE CHORD ============
        // Emerges during crystallization, not just pattern confidence

        let fifthAmp = 0;
        let octaveAmp = 0;

        // 5ths appear during crystallizing phase
        if (crystal > 0.5 && isDominant) {
            const fifthAmount = (crystal - 0.5) / 0.5;
            fifthAmp = fifthAmount * 0.35 * this.mass * this.life;
        }

        // Octave appears when locked
        if (phase === 'locked' && isDominant) {
            const octaveAmount = (crystal - 0.85) / 0.15;
            octaveAmp = Math.max(0, octaveAmount) * 0.25 * this.mass * this.life;
        }

        // Apply stacked 5ths gains
        this.fifthGain.gain.linearRampToValueAtTime(fifthAmp * proximity, now + 0.1);
        this.octaveGain.gain.linearRampToValueAtTime(octaveAmp * proximity, now + 0.1);

        // Amplitude: proximity + sync pulse + life + breath + crystallization
        const syncPulse = this.neighbors.length > 0 ? this.syncPhase * 0.3 : 0;
        const breathBonus = field.depth * field.breath * 0.02;
        const lockBonus = this.lockedIn ? 0.04 : 0;  // Louder when locked
        const baseAmp = (proximity * 0.035 + syncPulse * 0.02 + breathBonus + lockBonus) * this.mass * this.life * crystalAmpMod;

        this.gain.gain.linearRampToValueAtTime(baseAmp * (0.6 + this.brightness * 0.5), now + 0.06);

        // Filter - opens more in deep states, modulated by breath, tension, AND outliers
        // Also opens when locked in for brighter sound
        const depthFilter = field.depth * 400 * (0.5 + field.breath * 0.5);
        const lockFilter = this.lockedIn ? 600 * patternLockStrength : 0;  // Brighter when locked
        const filterFreq = 150 + proximity * 2500 + this.brightness * 2000 + this.syncPhase * 500 + depthFilter + tensionFilter + outlierFilter + lockFilter;
        this.filter.frequency.linearRampToValueAtTime(filterFreq * this.life, now + 0.08);

        // FM from energy, tension, AND outliers - outliers add harmonic richness
        const fmDepth = field.energy * this.freq * 0.4 + this.syncPhase * this.freq * 0.1 + tensionFM + outlierFM;
        this.modGain.gain.linearRampToValueAtTime(fmDepth, now + 0.05);

        // Pan - narrower in deep states for intimacy, also narrower when locked (focused)
        const panWidth = 1.6 - field.depth * 0.8 - (this.lockedIn ? 0.3 : 0);
        this.pan.pan.linearRampToValueAtTime((this.x - 0.5) * panWidth, now + 0.05);

        // ============ SUPERSAW PITCH: Apply bend + detune to all oscillators ============
        // Pitch bend toward PREDICTED cursor - this is where the magic happens
        const bendAmount = 0.015 * (1 - field.depth * 0.5);
        const tensionBend = field.predictionTension * 0.02;
        const bend = 1 + pdx * bendAmount + tensionBend * (Math.random() - 0.5);
        const bentFreq = this.freq * bend;

        // Update all supersaw oscillators with detune
        for (let i = 0; i < this.sawOscs.length; i++) {
            // Detune in cents: offset * currentDetune
            const detuneCents = this.sawDetunes[i] * this.currentDetune;
            // Convert cents to frequency multiplier: 2^(cents/1200)
            const detuneMultiplier = Math.pow(2, detuneCents / 1200);
            this.sawOscs[i].frequency.linearRampToValueAtTime(bentFreq * detuneMultiplier, now + 0.1);
        }

        // Update stacked 5ths with same bend
        this.fifthOsc.frequency.linearRampToValueAtTime(bentFreq * SUPERSAW.FIFTH_RATIO, now + 0.1);
        this.octaveOsc.frequency.linearRampToValueAtTime(bentFreq * SUPERSAW.OCTAVE_RATIO, now + 0.1);
    }

    draw() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const px = this.x * w;
        const py = this.y * h;

        if (this.life <= 0) return;

        const amp = this.gain.gain.value;
        const alpha = this.life;

        // Trail
        if (this.trail.length > 1 && amp > 0.001) {
            vc.beginPath();
            vc.moveTo(this.trail[0].x * w, this.trail[0].y * h);
            for (let i = 1; i < this.trail.length; i++) {
                vc.lineTo(this.trail[i].x * w, this.trail[i].y * h);
            }
            vc.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${amp * alpha * 0.4})`;
            vc.lineWidth = 1 + amp * 2;
            vc.stroke();
        }

        // Sync pulse ring
        if (this.neighbors.length > 0) {
            const pulseR = 10 + this.syncPhase * 30;
            vc.beginPath();
            vc.arc(px, py, pulseR, 0, TAU);
            vc.strokeStyle = `hsla(${this.hue}, 60%, 70%, ${this.syncPhase * amp * alpha * 0.5})`;
            vc.lineWidth = 2;
            vc.stroke();
        }

        // Core - larger and brighter when locked in
        const lockBonus = this.lockedIn ? 15 : 0;
        const r = 3 + amp * 35 + this.brightness * 15 + lockBonus;

        // When locked, shift hue toward white/gold and increase saturation
        const lockHue = this.lockedIn ? (this.hue + 30) % 360 : this.hue;
        const lockSat = this.lockedIn ? 70 : 85;
        const lockLight = this.lockedIn ? 85 + amp * 15 : 75 + amp * 20;

        const grad = vc.createRadialGradient(px, py, 0, px, py, r);
        grad.addColorStop(0, `hsla(${lockHue}, ${lockSat}%, ${lockLight}%, ${(0.9 + amp * 0.1) * alpha})`);
        grad.addColorStop(0.5, `hsla(${this.hue}, 70%, 50%, ${amp * 0.6 * alpha})`);
        grad.addColorStop(1, 'transparent');

        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(px, py, r, 0, TAU);
        vc.fill();

        // ============ SUPERSAW LOCK-IN GLOW ============
        // When pattern is strong and entity is locked, show a distinct visual
        if (this.lockedIn && amp > 0.01) {
            // Calculate how tight the detune is (0 = max chaos, 1 = fully locked)
            const lockTightness = 1 - (this.currentDetune - SUPERSAW.MIN_DETUNE) / (SUPERSAW.MAX_DETUNE - SUPERSAW.MIN_DETUNE);

            // Outer golden ring - the "clearing" moment visual
            const lockR = r + 10 + lockTightness * 25;
            const lockAlpha = lockTightness * amp * alpha * 0.6;

            vc.beginPath();
            vc.arc(px, py, lockR, 0, TAU);
            vc.strokeStyle = `hsla(45, 90%, 75%, ${lockAlpha})`;  // Golden
            vc.lineWidth = 2 + lockTightness * 3;
            vc.stroke();

            // Inner white flash when very tight
            if (lockTightness > 0.7) {
                const flashIntensity = (lockTightness - 0.7) / 0.3;
                const flashR = r * 0.6;
                const flashGrad = vc.createRadialGradient(px, py, 0, px, py, flashR);
                flashGrad.addColorStop(0, `rgba(255, 255, 255, ${flashIntensity * amp * 0.4})`);
                flashGrad.addColorStop(1, 'transparent');
                vc.fillStyle = flashGrad;
                vc.beginPath();
                vc.arc(px, py, flashR, 0, TAU);
                vc.fill();
            }

            // Stacked 5ths indicator - concentric rings when 5th/octave are active
            const pattern = getPatternState();
            if (pattern.confidence > SUPERSAW.FIFTH_THRESHOLD) {
                const fifthAlpha = ((pattern.confidence - SUPERSAW.FIFTH_THRESHOLD) / (1 - SUPERSAW.FIFTH_THRESHOLD)) * 0.3 * amp;
                vc.beginPath();
                vc.arc(px, py, lockR + 8, 0, TAU);
                vc.strokeStyle = `hsla(200, 80%, 70%, ${fifthAlpha})`;  // Blue for 5th
                vc.lineWidth = 1.5;
                vc.stroke();
            }

            if (pattern.confidence > SUPERSAW.OCTAVE_THRESHOLD) {
                const octaveAlpha = ((pattern.confidence - SUPERSAW.OCTAVE_THRESHOLD) / (1 - SUPERSAW.OCTAVE_THRESHOLD)) * 0.25 * amp;
                vc.beginPath();
                vc.arc(px, py, lockR + 14, 0, TAU);
                vc.strokeStyle = `hsla(280, 70%, 75%, ${octaveAlpha})`;  // Purple for octave
                vc.lineWidth = 1;
                vc.stroke();
            }
        }

        // Birth glow
        if (this.age < 1) {
            const birthGlow = (1 - this.age) * 0.5;
            const birthR = r + 20 * (1 - this.age);
            vc.beginPath();
            vc.arc(px, py, birthR, 0, TAU);
            vc.strokeStyle = `hsla(${this.hue}, 90%, 80%, ${birthGlow})`;
            vc.lineWidth = 3;
            vc.stroke();
        }

        // Ancestral glow - reborn souls carry a golden shimmer
        if (this.ancestralGlow && this.ancestralGlow > 0.1) {
            const ancestralR = r + 15;
            const shimmer = 0.5 + Math.sin(field.time * 3 + this.id) * 0.5;
            vc.beginPath();
            vc.arc(px, py, ancestralR, 0, TAU);
            vc.strokeStyle = `hsla(45, 80%, 70%, ${this.ancestralGlow * shimmer * alpha * 0.5})`;
            vc.lineWidth = 2;
            vc.stroke();

            // Fade the ancestral connection over time
            this.ancestralGlow *= 0.9995;
        }
    }
}

// ============ ANCESTRAL MEMORY ============

function findAncestor(x, y) {
    // Search recent deaths near this location
    for (let i = memory.length - 1; i >= 0; i--) {
        const m = memory[i];
        if (m.type !== 'death') continue;

        const dx = m.x - x;
        const dy = m.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const age = field.time - m.time;

        // Closer and more recent = stronger connection
        if (dist < 0.15 && age < 30) {
            return {
                ratio: m.ratio,
                strength: (1 - dist / 0.15) * (1 - age / 30),
                x: m.x,
                y: m.y
            };
        }
    }
    return null;
}

// ============ BIRTH ============

function birthEntity() {
    if (entities.length >= MAX_ENTITIES) return;

    // Choose ratio based on PREDICTED position's regional mode
    // This means harmonies shift BEFORE you arrive = telepathic feel
    const mode = getRegionalMode(field.px, field.py);

    // Check for ancestral influence at predicted position
    const ancestor = findAncestor(field.px, field.py);

    // Prefer ratios consonant with existing entities
    let bestRatio = ALL_RATIOS[Math.floor(Math.random() * ALL_RATIOS.length)];
    let bestScore = 0;

    for (const ratio of ALL_RATIOS) {
        let score = Math.random() * 0.3; // Base randomness

        // Bonus for regional mode
        if (mode.bonus[ratio]) {
            score += mode.bonus[ratio] * mode.influence;
        }

        // Bonus for consonance with existing
        for (const e of entities) {
            if (e.life > 0.5) {
                score += consonance(ratio, e.ratio) * 0.1;
            }
        }

        // Ancestral echo - favor harmonics of the departed
        if (ancestor) {
            const ancestralCons = consonance(ratio, ancestor.ratio);
            score += ancestralCons * ancestor.strength * 0.5;
            // Strong pull toward the exact same ratio
            if (Math.abs(ratio - ancestor.ratio) < 0.01) {
                score += ancestor.strength * 0.8;
            }
        }

        // Penalty for duplicates
        for (const e of entities) {
            if (Math.abs(e.ratio - ratio) < 0.01) {
                score -= 0.5;
            }
        }

        if (score > bestScore) {
            bestScore = score;
            bestRatio = ratio;
        }
    }

    // Spawn entity at PREDICTED position - entities appear where you're GOING
    // Blend between current and predicted based on energy (more movement = more prediction)
    const spawnBlend = Math.min(0.7, field.energy * 2);
    const spawnX = field.x * (1 - spawnBlend) + field.px * spawnBlend + (Math.random()-0.5)*0.08;
    const spawnY = field.y * (1 - spawnBlend) + field.py * spawnBlend + (Math.random()-0.5)*0.08;

    const entity = new Entity(bestRatio, spawnX, spawnY);
    entity.createAudio();
    entity.lastVisit = field.time;

    // Mark if this is a reborn soul
    if (ancestor && consonance(bestRatio, ancestor.ratio) > 0.8) {
        entity.ancestralGlow = ancestor.strength;
        entity.ancestorRatio = ancestor.ratio;
    }

    entities.push(entity);

    // Memory: record the birth
    memory.push({
        type: 'birth',
        ratio: bestRatio,
        x: field.x,
        y: field.y,
        time: field.time,
        hadAncestor: ancestor !== null
    });
    if (memory.length > 150) memory.shift();
}

// ============ DEATH ============

function processDeath() {
    for (let i = entities.length - 1; i >= 0; i--) {
        const e = entities[i];
        if (e.life <= 0) {
            e.destroy();

            // Create ghost for visual fade
            ghosts.push({
                x: e.x, y: e.y,
                hue: e.hue,
                alpha: 0.5,
                radius: 20
            });

            // Memory: record the death
            memory.push({
                type: 'death',
                ratio: e.ratio,
                x: e.x,
                y: e.y,
                time: field.time
            });

            entities.splice(i, 1);
        }
    }

    // Fade ghosts
    for (let i = ghosts.length - 1; i >= 0; i--) {
        ghosts[i].alpha -= 0.01;
        ghosts[i].radius += 0.5;
        if (ghosts[i].alpha <= 0) {
            ghosts.splice(i, 1);
        }
    }

    // Ensure minimum population
    if (entities.length < MIN_ENTITIES && field.time > 2) {
        birthEntity();
    }
}

// ============ CONNECTIONS ============

function drawConnections() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    for (let i = 0; i < entities.length; i++) {
        const a = entities[i];
        if (a.life <= 0) continue;

        for (let j = i + 1; j < entities.length; j++) {
            const b = entities[j];
            if (b.life <= 0) continue;

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 0.25) continue;

            const cons = consonance(a.ratio, b.ratio);
            if (cons < 0.65) continue;

            const amp = Math.min(a.gain.gain.value, b.gain.gain.value);
            const life = Math.min(a.life, b.life);
            const alpha = cons * amp * (1 - dist / 0.25) * life * 2;

            if (alpha < 0.02) continue;

            // Pulsing connection
            const pulse = (Math.sin((a.phase + b.phase) / 2) + 1) / 2;

            vc.beginPath();
            vc.moveTo(a.x * w, a.y * h);
            vc.lineTo(b.x * w, b.y * h);
            vc.strokeStyle = `rgba(255, 255, 255, ${alpha * (0.7 + pulse * 0.3)})`;
            vc.lineWidth = 1 + cons * pulse * 3;
            vc.stroke();
        }
    }
}

// ============ SUB BASS ============

function createSub() {
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.value = BASE / 2;
    osc2.type = 'sine';
    osc2.frequency.value = BASE / 2 * 1.002;

    filter.type = 'lowpass';
    filter.frequency.value = 80;
    gain.gain.value = 0;

    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    osc.start();
    osc2.start();

    sub = { osc, osc2, gain, filter };
}

function updateSub() {
    const now = ctx.currentTime;

    // Global pulse from synchronized entities
    let globalPulse = 0;
    let syncCount = 0;

    for (const e of entities) {
        if (e.neighbors.length > 0 && e.life > 0.5) {
            globalPulse += e.syncPhase;
            syncCount++;
        }
    }

    if (syncCount > 0) {
        globalPulse /= syncCount;
        field.pulse = field.pulse * 0.9 + globalPulse * 0.1;
    }

    // Sub amplitude - breathes with the cosmos in deep states
    const baseAmp = 0.12 + field.stillness * 0.08;
    const pulseAmp = field.pulse * 0.1;
    const breathAmp = field.depth * field.breath * 0.08;
    const constellationBonus = field.constellations.length * 0.02;
    sub.gain.gain.linearRampToValueAtTime(
        Math.min(0.35, baseAmp + pulseAmp + breathAmp + constellationBonus),
        now + 0.1
    );

    // Sub frequency follows center of mass
    let cx = 0, cy = 0, total = 0;
    for (const e of entities) {
        if (e.life > 0) {
            cx += e.x * e.mass;
            cy += e.y * e.mass;
            total += e.mass;
        }
    }
    if (total > 0) {
        cy /= total;
        // In deep states, the breath modulates the sub frequency
        const breathBend = 1 + field.depth * field.breath * 0.03;
        const subFreq = (BASE / 2) * (1 - (cy - 0.5) * 0.2) * breathBend;
        sub.osc.frequency.linearRampToValueAtTime(subFreq, now + 0.2);
        sub.osc2.frequency.linearRampToValueAtTime(subFreq * 1.002, now + 0.2);
    }

    // Filter opens in deep states
    const filterFreq = 80 + field.depth * 60 + field.breath * field.depth * 40;
    sub.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.15);
}

// ============ EFFECTS ============

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.35;
    const baseGain = 0.35;

    const times = [0.02, 0.05, 0.08, 0.13, 0.21, 0.34, 0.55, 0.89, 1.2, 1.6, 2.1, 2.8];
    times.forEach((t, i) => {
        const d = ctx.createDelay(4);
        d.delayTime.value = t + Math.random() * 0.015;
        const g = ctx.createGain();
        g.gain.value = 0.28 * Math.pow(0.77, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 5500 - i * 400;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
        if (i > 5) {
            const fb = ctx.createGain();
            fb.gain.value = 0.1;
            g.connect(fb);
            fb.connect(input);
        }
    });

    return { input, output, baseGain };
}

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.22;
    const baseGain = 0.22;

    const delayL = ctx.createDelay(2);
    const delayR = ctx.createDelay(2);
    delayL.delayTime.value = 0.333;
    delayR.delayTime.value = 0.5;

    const fbL = ctx.createGain();
    const fbR = ctx.createGain();
    fbL.gain.value = 0.32;
    fbR.gain.value = 0.28;

    const filterL = ctx.createBiquadFilter();
    const filterR = ctx.createBiquadFilter();
    filterL.type = filterR.type = 'lowpass';
    filterL.frequency.value = filterR.frequency.value = 2200;

    const panL = ctx.createStereoPanner();
    const panR = ctx.createStereoPanner();
    panL.pan.value = -0.8;
    panR.pan.value = 0.8;

    input.connect(delayL);
    delayL.connect(filterL);
    filterL.connect(fbL);
    fbL.connect(delayR);
    delayR.connect(filterR);
    filterR.connect(fbR);
    fbR.connect(delayL);

    filterL.connect(panL);
    filterR.connect(panR);
    panL.connect(output);
    panR.connect(output);

    return { input, output, delayL, delayR, fbL, fbR, baseGain };
}

function updateEffects() {
    const now = ctx.currentTime;

    // Reverb grows in deep states - more spacious, ethereal
    const verbGain = verb.baseGain + field.depth * 0.25 + field.breath * field.depth * 0.1;
    verb.output.gain.linearRampToValueAtTime(Math.min(0.7, verbGain), now + 0.1);

    // Delay grows subtly in deep states
    const dlyGain = dly.baseGain + field.depth * 0.15;
    dly.output.gain.linearRampToValueAtTime(Math.min(0.45, dlyGain), now + 0.1);

    // Feedback increases for longer tails in deep states
    const fbAmount = 0.32 + field.depth * 0.15;
    dly.fbL.gain.linearRampToValueAtTime(Math.min(0.55, fbAmount), now + 0.15);
    dly.fbR.gain.linearRampToValueAtTime(Math.min(0.5, fbAmount * 0.9), now + 0.15);
}

// ============ INIT ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master = ctx.createGain();
    master.gain.value = 0.7;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.ratio.value = 5;
    comp.attack.value = 0.003;
    comp.release.value = 0.2;

    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -2;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.1;

    verb = createVerb();
    dly = createDelay();

    master.connect(comp);
    comp.connect(limiter);
    limiter.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    createSub();
    createBeatAudio();
    createCounterAudio();

    // Birth initial entities - the primordial soup
    const initialRatios = [1, 5/4, 3/2, 2, 5/2, 3];
    for (const ratio of initialRatios) {
        const e = new Entity(ratio);
        e.createAudio();
        e.lastVisit = 0;
        entities.push(e);
    }

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

// ============ INPUT ============

function onMove(nx, ny) {
    nx = Math.max(0, Math.min(1, nx));
    ny = Math.max(0, Math.min(1, ny));

    const prevX = field.x;
    const prevY = field.y;
    const prevVx = field.vx;
    const prevVy = field.vy;

    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = field.x * 0.75 + nx * 0.25;
    field.y = field.y * 0.75 + ny * 0.25;

    // Calculate acceleration for gesture buffer
    const ax = field.vx - prevVx;
    const ay = field.vy - prevVy;

    // Add sample to gesture buffer
    addGestureSample(field.x, field.y, field.vx, field.vy, ax, ay);

    // Check for gestures
    const gesture = detectGesture();
    if (gesture) {
        onGestureDetected(gesture);
    }

    const speed = Math.sqrt(field.vx*field.vx + field.vy*field.vy);
    field.energy = field.energy * 0.9 + speed * 0.5;

    // ENTRAINMENT: Detect user tempo from movement
    detectUserTempo(field.vx, field.vy);

    // PATTERN LEARNING: Track user's movement patterns
    updatePattern(field.vx, field.vy);

    // Stillness
    if (speed < 0.005) {
        field.stillness = Math.min(3, field.stillness + 0.016);
    } else {
        field.stillness *= 0.95;
    }

    // Birth from energy
    if (field.energy > 0.15 && Math.random() < field.energy * 0.03) {
        birthEntity();
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const rawAx = (a.x || 0) / 8;
    const rawAy = (a.y || 0) / 8;

    const prevVx = field.vx;
    const prevVy = field.vy;

    field.vx = field.vx * 0.7 + rawAx * 0.3;
    field.vy = field.vy * 0.7 + rawAy * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.08));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.08));

    // Calculate acceleration change for gesture buffer
    const ax = field.vx - prevVx;
    const ay = field.vy - prevVy;

    // Add sample to gesture buffer
    addGestureSample(field.x, field.y, field.vx, field.vy, ax, ay);

    // Check for gestures
    const gesture = detectGesture();
    if (gesture) {
        onGestureDetected(gesture);
    }

    field.energy = field.energy * 0.9 + Math.sqrt(rawAx*rawAx + rawAy*rawAy) * 0.3;

    // ENTRAINMENT: Detect user tempo from motion
    detectUserTempo(field.vx, field.vy);

    // PATTERN LEARNING: Track user's movement patterns
    updatePattern(field.vx, field.vy);

    if (field.energy > 0.2 && Math.random() < field.energy * 0.02) {
        birthEntity();
    }
}

function onOrientation(e) {
    const gx = Math.max(-1, Math.min(1, (e.gamma || 0) / 40));
    const gy = Math.max(-1, Math.min(1, (e.beta || 0) / 40 - 1));
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ VISUALIZATION ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Set the canvas internal resolution (high DPI)
    canvas.width = w * dpr;
    canvas.height = h * dpr;

    // Set the display size (CSS pixels) - THIS WAS MISSING!
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';

    // Scale the context to account for DPI
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade - slower in deep stillness, creating trails
    const fadeAlpha = 0.06 + field.stillness * 0.02 - field.depth * 0.03;
    vc.fillStyle = `rgba(0, 0, 0, ${Math.max(0.02, fadeAlpha)})`;
    vc.fillRect(0, 0, w, h);

    // Deep stillness - the universe breathes with subtle color
    if (field.depth > 0.1) {
        const breathHue = 220 + field.breath * 40;
        const depthGrad = vc.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h)/2);
        depthGrad.addColorStop(0, `hsla(${breathHue}, 30%, 15%, ${field.depth * field.breath * 0.08})`);
        depthGrad.addColorStop(0.5, `hsla(${breathHue + 30}, 25%, 10%, ${field.depth * 0.05})`);
        depthGrad.addColorStop(1, 'transparent');
        vc.fillStyle = depthGrad;
        vc.fillRect(0, 0, w, h);
    }

    // Ghosts (fading dead entities)
    for (const g of ghosts) {
        vc.beginPath();
        vc.arc(g.x * w, g.y * h, g.radius, 0, TAU);
        vc.strokeStyle = `hsla(${g.hue}, 50%, 50%, ${g.alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    }

    // Regional mode visualization (subtle)
    const gradient = vc.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h)/2);
    gradient.addColorStop(0, 'transparent');
    gradient.addColorStop(1, `rgba(50, 50, 80, ${0.02 + field.stillness * 0.01})`);
    vc.fillStyle = gradient;
    vc.fillRect(0, 0, w, h);

    // Constellations (behind connections)
    drawConstellations();

    // Connections
    drawConnections();

    // Entities
    for (const e of entities) {
        e.draw();
    }

    // PREDICTED CURSOR - shows where system thinks you're going
    // This is VISIBLE FEEDBACK that prediction is working
    const px = field.px * w;
    const py = field.py * h;
    const predDist = Math.sqrt((field.px - field.x)**2 + (field.py - field.y)**2);

    // Only show prediction ghost when there's meaningful movement
    if (predDist > 0.02) {
        const predAlpha = Math.min(0.4, predDist * 2);
        const predR = 8 + field.energy * 20;

        // Line from cursor to predicted position
        vc.beginPath();
        vc.moveTo(field.x * w, field.y * h);
        vc.lineTo(px, py);
        vc.strokeStyle = `rgba(100, 200, 255, ${predAlpha * 0.5})`;
        vc.lineWidth = 1;
        vc.stroke();

        // Predicted position ghost
        const predGrad = vc.createRadialGradient(px, py, 0, px, py, predR);
        predGrad.addColorStop(0, `rgba(100, 200, 255, ${predAlpha})`);
        predGrad.addColorStop(1, 'transparent');
        vc.fillStyle = predGrad;
        vc.beginPath();
        vc.arc(px, py, predR, 0, TAU);
        vc.fill();
    }

    // TENSION visualization - red flash when prediction is wrong
    if (field.predictionTension > 0.1) {
        const tensionR = 30 + field.predictionTension * 60;
        const tensionAlpha = field.predictionTension * 0.3;
        vc.beginPath();
        vc.arc(field.x * w, field.y * h, tensionR, 0, TAU);
        vc.strokeStyle = `rgba(255, 100, 100, ${tensionAlpha})`;
        vc.lineWidth = 2 + field.predictionTension * 3;
        vc.stroke();
    }

    // Cursor (current position)
    const cx = field.x * w;
    const cy = field.y * h;
    const cursorR = 15 + field.energy * 50 + field.depth * 20 * field.breath;
    const cursorGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, cursorR);
    cursorGrad.addColorStop(0, `rgba(255, 255, 255, ${0.35 + field.energy * 0.4})`);
    cursorGrad.addColorStop(0.5, `rgba(200, 220, 255, ${0.1 + field.energy * 0.15 + field.depth * 0.1})`);
    cursorGrad.addColorStop(1, 'transparent');
    vc.fillStyle = cursorGrad;
    vc.beginPath();
    vc.arc(cx, cy, cursorR, 0, TAU);
    vc.fill();

    // Global pulse visualization
    if (field.pulse > 0.1) {
        const pulseR = 100 + field.pulse * 200;
        vc.beginPath();
        vc.arc(w/2, h/2, pulseR, 0, TAU);
        vc.strokeStyle = `rgba(255, 255, 255, ${field.pulse * 0.08})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Cosmic breath ring - visible in deep states
    if (field.depth > 0.3) {
        const breathR = 150 + field.breath * 100;
        vc.beginPath();
        vc.arc(w/2, h/2, breathR, 0, TAU);
        vc.strokeStyle = `hsla(240, 40%, 70%, ${field.depth * field.breath * 0.15})`;
        vc.lineWidth = 1 + field.breath * 3;
        vc.stroke();
    }

    // BEAT VISUALIZATION - pulse from center on each beat
    if (field.beatStrength > 0.1) {
        const beatR = 50 + (1 - field.beatStrength) * 300;
        const beatAlpha = field.beatStrength * 0.25;

        // Expanding ring from center
        vc.beginPath();
        vc.arc(w/2, h/2, beatR, 0, TAU);
        vc.strokeStyle = `rgba(255, 200, 150, ${beatAlpha})`;
        vc.lineWidth = 3 + field.beatStrength * 5;
        vc.stroke();

        // Inner glow at center
        const glowR = 30 + field.beatStrength * 50;
        const glowGrad = vc.createRadialGradient(w/2, h/2, 0, w/2, h/2, glowR);
        glowGrad.addColorStop(0, `rgba(255, 220, 180, ${field.beatStrength * 0.3})`);
        glowGrad.addColorStop(1, 'transparent');
        vc.fillStyle = glowGrad;
        vc.beginPath();
        vc.arc(w/2, h/2, glowR, 0, TAU);
        vc.fill();
    }

    // BPM indicator - subtle, bottom of screen
    if (field.energy > 0.02 || field.beatStrength > 0.05) {
        vc.fillStyle = `rgba(255, 255, 255, ${0.15 + field.beatStrength * 0.3})`;
        vc.font = '12px system-ui';
        vc.textAlign = 'center';
        vc.fillText(Math.round(field.systemBPM) + ' BPM', w/2, h - 20);
    }

    // PATTERN LEARNING VISUALIZATION
    const pattern = getPatternState();

    // ============ CRYSTALLIZATION VISUALIZATION ============
    // Show the phase and crystallization progress

    const barWidth = 60;
    const barHeight = 4;
    const barX = 20;
    const barY = 20;

    // Crystallization bar (replaces pattern confidence bar)
    if (pattern.crystallization > 0.05 || pattern.repetitionCount > 0) {
        // Background
        vc.fillStyle = 'rgba(255, 255, 255, 0.1)';
        vc.fillRect(barX, barY, barWidth, barHeight);

        // Phase-based color
        let phaseColor;
        switch (pattern.phase) {
            case 'chaos':
                phaseColor = 'rgba(255, 100, 100, 0.5)';
                break;
            case 'forming':
                phaseColor = 'rgba(255, 200, 100, 0.6)';
                break;
            case 'crystallizing':
                phaseColor = 'rgba(100, 200, 255, 0.7)';
                break;
            case 'locked':
                phaseColor = 'rgba(255, 255, 255, 0.9)';
                break;
            default:
                phaseColor = 'rgba(150, 150, 150, 0.4)';
        }

        vc.fillStyle = phaseColor;
        vc.fillRect(barX, barY, barWidth * pattern.crystallization, barHeight);

        // Phase label
        vc.fillStyle = `rgba(255, 255, 255, ${0.3 + pattern.crystallization * 0.4})`;
        vc.font = '9px system-ui';
        vc.textAlign = 'left';
        vc.fillText(pattern.phase.toUpperCase(), barX, barY + 14);

        // Repetition count (small)
        if (pattern.repetitionCount > 0) {
            vc.fillStyle = 'rgba(255, 255, 255, 0.2)';
            vc.font = '8px system-ui';
            vc.fillText(`×${pattern.repetitionCount}`, barX + barWidth + 5, barY + 4);
        }
    }

    // THE DROP flash - full screen white flash at the moment of crystallization
    if (pattern.dropTriggered && crystalState.dropTime > 0) {
        const timeSinceDrop = performance.now() - crystalState.dropTime;
        if (timeSinceDrop < 300) {
            const dropAlpha = Math.max(0, 0.6 - timeSinceDrop / 500);
            vc.fillStyle = `rgba(255, 255, 255, ${dropAlpha})`;
            vc.fillRect(0, 0, w, h);
        }
    }

    // Locked state: screen edges crystallize (white/ice effect)
    if (pattern.phase === 'locked') {
        const edgeSize = 40 + pattern.crystallization * 30;
        const edgeAlpha = (pattern.crystallization - 0.85) / 0.15 * 0.2;

        // Top edge
        const topGrad = vc.createLinearGradient(0, 0, 0, edgeSize);
        topGrad.addColorStop(0, `rgba(200, 220, 255, ${edgeAlpha})`);
        topGrad.addColorStop(1, 'transparent');
        vc.fillStyle = topGrad;
        vc.fillRect(0, 0, w, edgeSize);

        // Bottom edge
        const bottomGrad = vc.createLinearGradient(0, h, 0, h - edgeSize);
        bottomGrad.addColorStop(0, `rgba(200, 220, 255, ${edgeAlpha})`);
        bottomGrad.addColorStop(1, 'transparent');
        vc.fillStyle = bottomGrad;
        vc.fillRect(0, h - edgeSize, w, edgeSize);

        // Left edge
        const leftGrad = vc.createLinearGradient(0, 0, edgeSize, 0);
        leftGrad.addColorStop(0, `rgba(200, 220, 255, ${edgeAlpha * 0.7})`);
        leftGrad.addColorStop(1, 'transparent');
        vc.fillStyle = leftGrad;
        vc.fillRect(0, 0, edgeSize, h);

        // Right edge
        const rightGrad = vc.createLinearGradient(w, 0, w - edgeSize, 0);
        rightGrad.addColorStop(0, `rgba(200, 220, 255, ${edgeAlpha * 0.7})`);
        rightGrad.addColorStop(1, 'transparent');
        vc.fillStyle = rightGrad;
        vc.fillRect(w - edgeSize, 0, edgeSize, h);
    }

    // OUTLIER VISUALIZATION - dramatic feedback when you break pattern
    if (pattern.isOutlier && pattern.confidence > 0.5) {
        const outlierIntensity = Math.min(1, (pattern.outlierScore - PATTERN.OUTLIER_THRESHOLD) / 2);

        // Color based on outlier type
        let outlierHue = 30; // Orange default
        switch (pattern.outlierType) {
            case 'tempo': outlierHue = 280; break;     // Purple for tempo
            case 'amplitude': outlierHue = 60; break;   // Yellow for amplitude
            case 'direction': outlierHue = 180; break;  // Cyan for direction
        }

        // Pulsing ring at cursor - YOU broke the pattern
        const outlierR = 40 + outlierIntensity * 80;
        const outlierAlpha = outlierIntensity * 0.4;
        vc.beginPath();
        vc.arc(field.x * w, field.y * h, outlierR, 0, TAU);
        vc.strokeStyle = `hsla(${outlierHue}, 80%, 60%, ${outlierAlpha})`;
        vc.lineWidth = 2 + outlierIntensity * 4;
        vc.stroke();

        // Polyrhythm indicator
        if (pattern.polyrhythm && pattern.polyrhythm.name !== '1:1') {
            vc.fillStyle = `hsla(${outlierHue}, 70%, 70%, ${outlierIntensity * 0.6})`;
            vc.font = '14px system-ui';
            vc.textAlign = 'center';
            vc.fillText(pattern.polyrhythm.name, field.x * w, field.y * h - outlierR - 10);
        }

        // Flash at center when MAJOR outlier
        if (pattern.isMajorOutlier) {
            const flashR = 150 + outlierIntensity * 100;
            const flashGrad = vc.createRadialGradient(w/2, h/2, 0, w/2, h/2, flashR);
            flashGrad.addColorStop(0, `hsla(${outlierHue}, 60%, 50%, ${outlierIntensity * 0.2})`);
            flashGrad.addColorStop(1, 'transparent');
            vc.fillStyle = flashGrad;
            vc.beginPath();
            vc.arc(w/2, h/2, flashR, 0, TAU);
            vc.fill();
        }
    }

    // Counter-rhythm indicator - shows the polyrhythm is active
    if (counterActive && pattern.isOutlier) {
        const counterAlpha = 0.2 + Math.sin(counterPhase * Math.PI * 2) * 0.15;
        vc.fillStyle = `rgba(255, 180, 100, ${counterAlpha})`;
        vc.font = '10px system-ui';
        vc.textAlign = 'right';
        vc.fillText('COUNTER', w - 20, 24);
    }
}

// ============ BREATH OF THE UNIVERSE ============

function updateBreath(dt) {
    // Slow cosmic oscillation - about 8 breaths per minute
    field.breathPhase += dt * 0.14;

    // The breath itself - a gentle wave
    field.breath = (Math.sin(field.breathPhase) + 1) / 2;

    // Depth accumulates in stillness, fades with movement
    if (field.stillness > 1.5) {
        field.depth = Math.min(1, field.depth + dt * 0.02);
    } else {
        field.depth *= 0.995;
    }
}

// ============ CONSTELLATIONS ============

function findConstellations() {
    // Find stable triads - three entities mutually consonant and close
    const constellations = [];

    for (let i = 0; i < entities.length; i++) {
        const a = entities[i];
        if (a.life < 0.7 || a.age < 3) continue;

        for (let j = i + 1; j < entities.length; j++) {
            const b = entities[j];
            if (b.life < 0.7 || b.age < 3) continue;

            const abCons = consonance(a.ratio, b.ratio);
            if (abCons < 0.7) continue;

            const abDist = Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2);
            if (abDist > 0.25) continue;

            for (let k = j + 1; k < entities.length; k++) {
                const c = entities[k];
                if (c.life < 0.7 || c.age < 3) continue;

                const acCons = consonance(a.ratio, c.ratio);
                const bcCons = consonance(b.ratio, c.ratio);

                if (acCons < 0.7 || bcCons < 0.7) continue;

                const acDist = Math.sqrt((a.x-c.x)**2 + (a.y-c.y)**2);
                const bcDist = Math.sqrt((b.x-c.x)**2 + (b.y-c.y)**2);

                if (acDist > 0.25 || bcDist > 0.25) continue;

                // This is a constellation!
                const avgCons = (abCons + acCons + bcCons) / 3;
                const avgLife = (a.life + b.life + c.life) / 3;

                constellations.push({
                    entities: [a, b, c],
                    center: {
                        x: (a.x + b.x + c.x) / 3,
                        y: (a.y + b.y + c.y) / 3
                    },
                    consonance: avgCons,
                    strength: avgCons * avgLife
                });
            }
        }
    }

    field.constellations = constellations;
}

function drawConstellations() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    for (const c of field.constellations) {
        const [a, b, e3] = c.entities;
        const alpha = c.strength * 0.4 * (0.7 + field.breath * 0.3);

        // Triangle fill
        vc.beginPath();
        vc.moveTo(a.x * w, a.y * h);
        vc.lineTo(b.x * w, b.y * h);
        vc.lineTo(e3.x * w, e3.y * h);
        vc.closePath();

        // Average hue of the triad
        const avgHue = (a.hue + b.hue + e3.hue) / 3;
        vc.fillStyle = `hsla(${avgHue}, 40%, 50%, ${alpha * 0.15})`;
        vc.fill();

        // Glowing outline
        vc.strokeStyle = `hsla(${avgHue}, 60%, 70%, ${alpha * 0.6})`;
        vc.lineWidth = 1 + c.consonance * 2;
        vc.stroke();

        // Center point - the heart of the constellation
        const cx = c.center.x * w;
        const cy = c.center.y * h;
        const pulseR = 5 + field.breath * 10 * c.strength;

        const grad = vc.createRadialGradient(cx, cy, 0, cx, cy, pulseR);
        grad.addColorStop(0, `hsla(${avgHue}, 70%, 80%, ${alpha})`);
        grad.addColorStop(1, 'transparent');
        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(cx, cy, pulseR, 0, TAU);
        vc.fill();
    }
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    const dt = 0.016;
    field.time += dt;

    // UPDATE PREDICTION FIRST - before anything else uses position
    updatePrediction();

    // UPDATE ENTRAINMENT - beat syncs to user's rhythm
    updateEntrainment(dt);

    // UPDATE COUNTER-RHYTHM - outliers create polyrhythms
    updateCounterRhythm(dt);

    // UPDATE CRYSTALLIZATION - order from chaos through repetition
    updateCrystallization(dt);

    updateBreath(dt);

    for (const e of entities) {
        e.update(dt);
    }

    processDeath();
    findConstellations();
    updateSub();
    updateEffects();
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
