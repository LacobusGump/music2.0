<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: system-ui, sans-serif;
        }
        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            z-index: 100; cursor: pointer;
            background: #0a0a0f;
        }
        #enter.off { display: none; }
        #enter .circle {
            width: 120px; height: 120px;
            border-radius: 50%;
            border: 1px solid rgba(255,220,180,0.15);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        #enter:hover .circle { border-color: rgba(255,220,180,0.4); }
        #enter .inner {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(255,220,180,0.08);
        }
        #world {
            position: fixed; inset: 0;
            display: none;
            background: radial-gradient(ellipse at center, #12111a 0%, #0a0a0f 100%);
        }
        #world.on { display: block; }
        canvas { position: fixed; inset: 0; }
        #vibe {
            position: fixed; bottom: 40px; left: 0; right: 0;
            display: flex; justify-content: center; gap: 30px;
            z-index: 50;
        }
        .vibe-btn {
            font-size: 11px;
            color: rgba(255,220,180,0.25);
            background: none; border: none;
            padding: 12px 20px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .vibe-btn.on { color: rgba(255,220,180,0.9); }
        #status {
            position: fixed; top: 20px; left: 20px;
            font-size: 9px;
            color: rgba(255,220,180,0.4);
            letter-spacing: 1px;
            line-height: 1.8;
            font-family: monospace;
        }
        #mic-dot {
            position: fixed; top: 20px; right: 20px;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: rgba(255,100,100,0.3);
            transition: all 0.1s;
        }
        #mic-dot.on { background: rgba(100,255,150,0.8); box-shadow: 0 0 10px rgba(100,255,150,0.5); }
    </style>
</head>
<body>

<div id="enter"><div class="circle"><div class="inner"></div></div></div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="vibe">
        <button class="vibe-btn on" data-vibe="dream">DREAM</button>
        <button class="vibe-btn" data-vibe="pulse">PULSE</button>
        <button class="vibe-btn" data-vibe="deep">DEEP</button>
    </div>
    <div id="status"></div>
    <div id="mic-dot"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// GUMP v3 - RICH EVOLUTION
// ═══════════════════════════════════════════════════════════════════════════
// Architecture:
//   LAYER 1: Core music engine (always works)
//   LAYER 2: Input modulation (motion, mic)
//   LAYER 3: AI enhancement (optional, never gates)
//   LAYER 4: Evolution engine (develops into unknown territory)
// ═══════════════════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 1: GLOBAL STATE
// ═══════════════════════════════════════════════════════════════════════════

const world = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    energy: 0.3,
    stillness: 0,
    breath: 0,
    pulse: 0,
};

const music = {
    bar: 0,
    beat: 0,
    tick: 0,
    chord: 0,
    tension: 0.5,
    direction: 'float',
    lastKick: 0,
    lastSnare: 0,
    // Evolution state
    epoch: 0,              // Major section counter
    drift: 0,              // How far we've drifted from origin
    modeMorph: 0,          // Blend between scale modes
    chaosLevel: 0,         // Probability of strange choices
    memory: [],            // Recent note history for melodic development
};

const ai = {
    drumDensity: 0.5,
    bassActivity: 0.5,
    padOpenness: 0.5,
    leadProbability: 0.5,
    lastUpdate: 0,
};

const mic = {
    level: 0,
    low: 0, mid: 0, high: 0,
    onset: false,
    active: false,
    stream: null,
    gateOpen: true,        // Prevents feedback
    lastOnset: 0,
};

let vibe = 'dream';
let ctx, masterGain, reverbGain, compressor;
let canvas, vc;
let audioReady = false;
let samples = {};
let samplesLoaded = false;

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 2: VIBES - Three distinct musical worlds
// ═══════════════════════════════════════════════════════════════════════════

const VIBES = {
    dream: {
        bpm: 72,
        key: 0,
        scale: [0, 2, 4, 7, 9],              // Major pentatonic
        altScale: [0, 2, 3, 7, 9],           // Mix with minor feel
        chords: [[0,4,7], [5,9,12], [7,11,14], [2,5,9]],
        bassOctave: 1,
        swing: 0.15,
        reverbMix: 0.4,
        filterBase: 2000,
        character: 'warm'
    },
    pulse: {
        bpm: 118,
        key: 5,
        scale: [0, 3, 5, 7, 10],             // Minor pentatonic
        altScale: [0, 3, 5, 6, 10],          // Blues note injection
        chords: [[0,3,7], [5,8,12], [3,7,10], [7,10,14]],
        bassOctave: 2,
        swing: 0.05,
        reverbMix: 0.2,
        filterBase: 4000,
        character: 'driving'
    },
    deep: {
        bpm: 82,
        key: 7,
        scale: [0, 2, 3, 5, 7, 9, 10],       // Dorian
        altScale: [0, 1, 3, 5, 7, 8, 10],    // Phrygian for tension
        chords: [[0,3,7,10], [2,5,9], [5,9,12], [0,4,7]],
        bassOctave: 1,
        swing: 0.2,
        reverbMix: 0.5,
        filterBase: 1500,
        character: 'deep'
    }
};

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 3: AUDIO ENGINE SETUP
// ═══════════════════════════════════════════════════════════════════════════

let saturation, masterFilter, delayNode, delayGain, textureGain;
let subBass, subBassGain; // Rich sub frequencies

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // === Master chain ===
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.8;

    // Saturation for warmth (more aggressive for low end)
    saturation = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        // Warmer saturation curve with more even harmonics
        curve[i] = Math.tanh(x * 1.8) * 0.8 + Math.sin(x * Math.PI * 0.5) * 0.2;
    }
    saturation.curve = curve;
    saturation.oversample = '4x';

    // Master filter
    masterFilter = ctx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 8000;
    masterFilter.Q.value = 0.7;

    // Delay for space
    delayNode = ctx.createDelay(1.0);
    delayNode.delayTime.value = 0.33;
    const delayFeedback = ctx.createGain();
    delayFeedback.gain.value = 0.25;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2000;
    delayGain = ctx.createGain();
    delayGain.gain.value = 0.15;

    delayNode.connect(delayFilter);
    delayFilter.connect(delayFeedback);
    delayFeedback.connect(delayNode);
    delayNode.connect(delayGain);

    // Reverb
    const reverbBuffer = createReverb(3.5);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.3;

    // Compressor for glue (tighter for punch)
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -14;
    compressor.ratio.value = 5;
    compressor.attack.value = 0.002;
    compressor.release.value = 0.08;
    compressor.knee.value = 6;

    // Texture
    initTexture();

    // === Routing ===
    masterGain.connect(saturation);
    saturation.connect(masterFilter);
    masterFilter.connect(compressor);
    masterGain.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);
    masterGain.connect(delayNode);
    delayGain.connect(compressor);
    compressor.connect(ctx.destination);

    // Load samples
    await loadSamples();

    // Initialize instruments
    initBass();
    initPad();
    initLead();

    // Initialize mic (non-blocking, with error handling)
    initMic().catch(() => {});

    audioReady = true;
    console.log('Audio engine ready');
}

function createReverb(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / ctx.sampleRate;
            // More complex reverb with early reflections
            const early = i < ctx.sampleRate * 0.08 ? Math.random() * 0.3 : 0;
            const late = (Math.random() * 2 - 1) * Math.exp(-t / (duration * 0.35)) * 0.5;
            data[i] = early + late;
        }
    }
    return buffer;
}

function initTexture() {
    const buffer = ctx.createBuffer(2, ctx.sampleRate * 4, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
            const noise = (Math.random() * 2 - 1) * 0.012;
            const crackle = Math.random() < 0.0002 ? (Math.random() - 0.5) * 0.25 : 0;
            data[i] = noise + crackle;
        }
    }
    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;
    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 2500;
    filter.Q.value = 0.5;
    textureGain = ctx.createGain();
    textureGain.gain.value = 0.06;
    source.connect(filter);
    filter.connect(textureGain);
    textureGain.connect(masterGain);
    source.start();
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 4: DRUMS - Clean crisp samples + synthesized options
// ═══════════════════════════════════════════════════════════════════════════

const SAMPLE_URLS = {
    kick: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
    snare: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    hat: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',
    hatOpen: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',
    rim: 'https://cdn.freesound.org/previews/398/398712_183766-lq.mp3',
    perc: 'https://cdn.freesound.org/previews/250/250537_4486188-lq.mp3'
};

async function loadSamples() {
    const jobs = Object.entries(SAMPLE_URLS).map(async ([name, url]) => {
        try {
            const res = await fetch(url);
            const buf = await res.arrayBuffer();
            samples[name] = await ctx.decodeAudioData(buf);
        } catch (e) {
            console.warn(`Sample ${name} failed, using synth fallback`);
            samples[name] = createDrumSynth(name);
        }
    });
    await Promise.all(jobs);
    samplesLoaded = true;
}

// High quality synthesized drums as fallback
function createDrumSynth(name) {
    const sr = ctx.sampleRate;

    if (name === 'kick') {
        // Rich sub-heavy kick
        const len = sr * 0.5;
        const buf = ctx.createBuffer(2, len, sr);
        for (let ch = 0; ch < 2; ch++) {
            const d = buf.getChannelData(ch);
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                // Pitch envelope: 150Hz -> 45Hz
                const pitch = 45 + 105 * Math.exp(-t * 35);
                // Body
                const body = Math.sin(TAU * pitch * t) * Math.exp(-t * 8);
                // Sub
                const sub = Math.sin(TAU * 35 * t) * Math.exp(-t * 4) * 0.6;
                // Click
                const click = (Math.random() * 2 - 1) * Math.exp(-t * 200) * 0.3;
                d[i] = (body + sub + click) * 0.85;
            }
        }
        return buf;
    }

    if (name === 'snare') {
        // Clean crisp snare with body and wire
        const len = sr * 0.35;
        const buf = ctx.createBuffer(2, len, sr);
        for (let ch = 0; ch < 2; ch++) {
            const d = buf.getChannelData(ch);
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                // Body tone (pitched)
                const body = Math.sin(TAU * 185 * t) * Math.exp(-t * 20) * 0.5;
                // Snare wires (filtered noise with tight envelope)
                const noise = (Math.random() * 2 - 1);
                const wire = noise * Math.exp(-t * 18) * 0.6;
                // High transient click
                const click = noise * Math.exp(-t * 150) * 0.4;
                // Combine
                d[i] = body + wire + click;
            }
        }
        return buf;
    }

    if (name === 'hat' || name === 'hatOpen') {
        const len = sr * (name === 'hatOpen' ? 0.4 : 0.1);
        const decay = name === 'hatOpen' ? 8 : 40;
        const buf = ctx.createBuffer(2, len, sr);
        for (let ch = 0; ch < 2; ch++) {
            const d = buf.getChannelData(ch);
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                // Multiple metallic frequencies
                const f1 = Math.sin(TAU * 4500 * t) * 0.3;
                const f2 = Math.sin(TAU * 7200 * t) * 0.25;
                const f3 = Math.sin(TAU * 10500 * t) * 0.2;
                const noise = (Math.random() * 2 - 1) * 0.4;
                d[i] = (f1 + f2 + f3 + noise) * Math.exp(-t * decay);
            }
        }
        return buf;
    }

    // Default percussion
    const len = sr * 0.2;
    const buf = ctx.createBuffer(2, len, sr);
    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
            const t = i / sr;
            d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 30) * 0.5;
        }
    }
    return buf;
}

function playSample(name, vol = 1, pan = 0, rate = 1) {
    if (!samples[name] || !audioReady) return;
    const src = ctx.createBufferSource();
    src.buffer = samples[name];
    src.playbackRate.value = rate;

    const g = ctx.createGain();
    g.gain.value = vol;

    // High-pass for snare clarity
    let output = g;
    if (name === 'snare') {
        const hp = ctx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 120;
        hp.Q.value = 0.7;
        g.connect(hp);
        output = hp;
    }

    const p = ctx.createStereoPanner();
    p.pan.value = pan;

    src.connect(g);
    output.connect(p);
    p.connect(masterGain);
    src.start();
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 5: BASS SYNTH - Rich sub frequencies
// ═══════════════════════════════════════════════════════════════════════════

let bassOsc, bassOsc2, bassSub, bassGain, bassFilter, bassSaturation;

function initBass() {
    // Main oscillators
    bassOsc = ctx.createOscillator();
    bassOsc.type = 'sine';
    bassOsc.frequency.value = 55;

    bassOsc2 = ctx.createOscillator();
    bassOsc2.type = 'triangle';
    bassOsc2.frequency.value = 55;

    // SUB oscillator - pure low end
    bassSub = ctx.createOscillator();
    bassSub.type = 'sine';
    bassSub.frequency.value = 27.5; // One octave below

    // Bass-specific saturation for warmth
    bassSaturation = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        curve[i] = Math.tanh(x * 2) * 0.9;
    }
    bassSaturation.curve = curve;

    bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 280;
    bassFilter.Q.value = 2.5;

    bassGain = ctx.createGain();
    bassGain.gain.value = 0;

    const subGain = ctx.createGain();
    subGain.gain.value = 0.5;

    const mix = ctx.createGain();
    mix.gain.value = 0.4;

    // Routing
    bassOsc.connect(bassFilter);
    bassOsc2.connect(mix);
    mix.connect(bassFilter);
    bassSub.connect(subGain);
    subGain.connect(bassFilter);
    bassFilter.connect(bassSaturation);
    bassSaturation.connect(bassGain);
    bassGain.connect(masterGain);

    bassOsc.start();
    bassOsc2.start();
    bassSub.start();
}

function playBass(note, vel = 0.6, dur = 0.4) {
    if (!bassOsc || !audioReady) return;
    const v = VIBES[vibe];
    const freq = 55 * Math.pow(2, (v.key + note) / 12) * v.bassOctave;
    const subFreq = freq / 2; // One octave below for sub
    const now = ctx.currentTime;

    bassOsc.frequency.setTargetAtTime(freq, now, 0.012);
    bassOsc2.frequency.setTargetAtTime(freq * 1.003, now, 0.012);
    bassSub.frequency.setTargetAtTime(subFreq, now, 0.015);

    bassGain.gain.cancelScheduledValues(now);
    bassGain.gain.setValueAtTime(bassGain.gain.value, now);
    bassGain.gain.linearRampToValueAtTime(vel * 0.75, now + 0.006);
    bassGain.gain.linearRampToValueAtTime(vel * 0.55, now + dur * 0.35);
    bassGain.gain.linearRampToValueAtTime(0.001, now + dur);

    bassFilter.frequency.setTargetAtTime(200 + vel * 180, now, 0.008);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 6: PAD SYNTH
// ═══════════════════════════════════════════════════════════════════════════

let padOscs = [], padGain, padFilter;

function initPad() {
    padGain = ctx.createGain();
    padGain.gain.value = 0;

    padFilter = ctx.createBiquadFilter();
    padFilter.type = 'lowpass';
    padFilter.frequency.value = 600;
    padFilter.Q.value = 0.5;

    for (let i = 0; i < 5; i++) {
        const osc = ctx.createOscillator();
        osc.type = i < 3 ? 'sine' : 'triangle';
        osc.frequency.value = 220;
        osc.detune.value = (i - 2) * 6;
        const g = ctx.createGain();
        g.gain.value = 0.12;
        osc.connect(g);
        g.connect(padFilter);
        osc.start();
        padOscs.push({ osc, gain: g });
    }

    padFilter.connect(padGain);
    padGain.connect(masterGain);
}

function updatePad() {
    if (!padOscs.length || !audioReady) return;
    const v = VIBES[vibe];
    const chord = v.chords[music.chord % v.chords.length];
    const base = 110 * Math.pow(2, v.key / 12);
    const spread = ai.padOpenness;

    padOscs.forEach((p, i) => {
        let note = chord[i % chord.length];
        if (spread > 0.5 && i >= 3) note += 12;
        if (spread > 0.7 && i >= 4) note += 7;

        // Apply drift for evolution
        if (music.drift > 0.3 && i === 2) {
            note += music.drift > 0.6 ? 2 : 1;
        }

        const freq = base * Math.pow(2, note / 12);
        p.osc.frequency.setTargetAtTime(freq, ctx.currentTime, 0.4);
    });

    const targetVol = Math.min(0.25, world.stillness * v.reverbMix * 0.5);
    padGain.gain.setTargetAtTime(targetVol, ctx.currentTime, 0.5);
    padFilter.frequency.setTargetAtTime(400 + world.stillness * 1000, ctx.currentTime, 0.3);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 7: LEAD SYNTH
// ═══════════════════════════════════════════════════════════════════════════

let leadOsc, leadOsc2, leadGain, leadFilter;

function initLead() {
    leadOsc = ctx.createOscillator();
    leadOsc.type = 'triangle';
    leadOsc.frequency.value = 440;

    leadOsc2 = ctx.createOscillator();
    leadOsc2.type = 'sine';
    leadOsc2.frequency.value = 440;

    leadFilter = ctx.createBiquadFilter();
    leadFilter.type = 'lowpass';
    leadFilter.frequency.value = 2500;
    leadFilter.Q.value = 3;

    leadGain = ctx.createGain();
    leadGain.gain.value = 0;

    const mix = ctx.createGain();
    mix.gain.value = 0.3;

    leadOsc.connect(leadFilter);
    leadOsc2.connect(mix);
    mix.connect(leadFilter);
    leadFilter.connect(leadGain);
    leadGain.connect(masterGain);

    leadOsc.start();
    leadOsc2.start();
}

function playLead(note, vel = 0.4) {
    if (!leadOsc || !audioReady) return;
    const v = VIBES[vibe];
    const freq = 220 * Math.pow(2, (v.key + note) / 12);
    const now = ctx.currentTime;

    leadOsc.frequency.setTargetAtTime(freq, now, 0.015);
    leadOsc2.frequency.setTargetAtTime(freq * 2.01, now, 0.015);

    leadGain.gain.cancelScheduledValues(now);
    leadGain.gain.setValueAtTime(0.001, now);
    leadGain.gain.linearRampToValueAtTime(vel * 0.12, now + 0.008);
    leadGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

    leadFilter.frequency.setTargetAtTime(1200 + vel * 2500, now, 0.01);

    // Add to memory for melodic development
    music.memory.push(note);
    if (music.memory.length > 8) music.memory.shift();
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 8: MICROPHONE INPUT (with crash protection)
// ═══════════════════════════════════════════════════════════════════════════

let micAnalyser, micData, micSource;

async function initMic() {
    try {
        // Request mic with echo cancellation to prevent feedback
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
                echoCancellation: true,
                noiseSuppression: true,
                autoGainControl: false
            }
        });

        mic.stream = stream;
        micSource = ctx.createMediaStreamSource(stream);
        micAnalyser = ctx.createAnalyser();
        micAnalyser.fftSize = 512;
        micAnalyser.smoothingTimeConstant = 0.3;
        micData = new Uint8Array(micAnalyser.frequencyBinCount);

        // Only connect to analyser, NOT to output (prevents feedback)
        micSource.connect(micAnalyser);

        mic.active = true;
        console.log('Microphone active');
    } catch (e) {
        console.warn('Microphone unavailable:', e.message);
        mic.active = false;
    }
}

function updateMic() {
    if (!mic.active || !micAnalyser) return;

    try {
        micAnalyser.getByteFrequencyData(micData);
    } catch (e) {
        mic.active = false;
        return;
    }

    const bins = micData.length;
    const lowEnd = Math.floor(bins * 0.1);
    const midEnd = Math.floor(bins * 0.5);

    let lowSum = 0, midSum = 0, highSum = 0, total = 0;
    for (let i = 0; i < bins; i++) {
        const v = micData[i];
        total += v;
        if (i < lowEnd) lowSum += v;
        else if (i < midEnd) midSum += v;
        else highSum += v;
    }

    const prevLevel = mic.level;
    mic.low = lowSum / lowEnd / 255;
    mic.mid = midSum / (midEnd - lowEnd) / 255;
    mic.high = highSum / (bins - midEnd) / 255;
    mic.level = total / bins / 255;

    // Onset detection with gate to prevent feedback triggering
    const now = Date.now();
    const timeSinceLastOnset = now - mic.lastOnset;

    // Only detect onset if gate is open and enough time has passed
    if (timeSinceLastOnset > 100 && mic.level > prevLevel + 0.12 && mic.level > 0.08) {
        mic.onset = true;
        mic.lastOnset = now;
        // Close gate briefly after onset
        mic.gateOpen = false;
        setTimeout(() => { mic.gateOpen = true; }, 80);
    } else {
        mic.onset = false;
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 9: AI ENHANCEMENT (Groq)
// ═══════════════════════════════════════════════════════════════════════════

const GROQ_KEY = String.fromCharCode(...[103,115,107,95,82,113,89,116,105,48,70,116,116,76,117,51,113,88,54,69,97,84,88,77,87,71,100,121,98,51,70,89,90,75,54,53,89,49,100,54,122,97,72,122,117,70,76,87,57,90,107,55,87,109,87]);

async function updateAI() {
    const now = Date.now();
    if (now - ai.lastUpdate < 3000) return;
    ai.lastUpdate = now;

    const prompt = `You control a live jazz band. Current state:
- Energy: ${Math.round(world.energy * 100)}%
- Tension: ${Math.round(music.tension * 100)}%
- Stillness: ${Math.round(world.stillness * 100)}%
- Epoch: ${music.epoch}
- Chaos: ${Math.round(music.chaosLevel * 100)}%

Reply with exactly 4 numbers between 0-100, space-separated:
drumDensity bassActivity padOpenness leadProbability

Example: "60 45 70 55"`;

    try {
        const res = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${GROQ_KEY}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'llama-3.1-8b-instant',
                messages: [{ role: 'user', content: prompt }],
                max_tokens: 20,
                temperature: 0.5
            })
        });
        const data = await res.json();
        const answer = data.choices?.[0]?.message?.content?.trim();
        const nums = answer?.match(/\d+/g);
        if (nums && nums.length >= 4) {
            ai.drumDensity = Math.min(100, Math.max(0, parseInt(nums[0]))) / 100;
            ai.bassActivity = Math.min(100, Math.max(0, parseInt(nums[1]))) / 100;
            ai.padOpenness = Math.min(100, Math.max(0, parseInt(nums[2]))) / 100;
            ai.leadProbability = Math.min(100, Math.max(0, parseInt(nums[3]))) / 100;
        }
    } catch (e) {
        // AI failed - keep current values, music continues
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 10: EVOLUTION ENGINE - Develop into unknown territory
// ═══════════════════════════════════════════════════════════════════════════

function evolve() {
    const v = VIBES[vibe];

    // Every 8 bars, potentially shift
    if (music.bar > 0 && music.bar % 8 === 0 && music.tick % 16 === 0) {
        // Increase drift
        music.drift = Math.min(1, music.drift + 0.1 + Math.random() * 0.1);

        // Chance to enter new epoch
        if (Math.random() < 0.25) {
            music.epoch++;
            music.chaosLevel = Math.min(0.8, music.chaosLevel + 0.1);
        }
    }

    // Every 32 bars, consider major change
    if (music.bar > 0 && music.bar % 32 === 0 && music.tick % 16 === 0) {
        // Key modulation - shift by 5ths or 4ths
        if (Math.random() < 0.3 + music.drift * 0.3) {
            const shift = Math.random() < 0.5 ? 5 : 7;
            // This affects the next chord cycle
            music.chord = (music.chord + (Math.random() < 0.5 ? 1 : 3)) % v.chords.length;
        }

        // Reset some chaos after big change
        if (music.epoch > 2 && Math.random() < 0.2) {
            music.drift *= 0.5;
            music.chaosLevel *= 0.7;
            music.epoch = Math.max(0, music.epoch - 1);
        }
    }
}

// Get scale with evolution applied
function getEvolvedScale() {
    const v = VIBES[vibe];
    const scale = [...v.scale];
    const alt = v.altScale;

    // Blend scales based on tension and drift
    const blend = (music.tension + music.drift) / 2;

    if (blend > 0.4 && alt) {
        // Inject notes from alternate scale
        const numToReplace = Math.floor(blend * 2);
        for (let i = 0; i < numToReplace && i < scale.length; i++) {
            const idx = (i + music.epoch) % scale.length;
            if (alt[idx] !== scale[idx]) {
                scale[idx] = alt[idx];
            }
        }
    }

    // Chaos can add chromatic passing tones
    if (music.chaosLevel > 0.5 && Math.random() < music.chaosLevel * 0.3) {
        const chromatic = Math.floor(Math.random() * 12);
        if (!scale.includes(chromatic)) {
            scale.push(chromatic);
        }
    }

    return scale;
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 11: RHYTHM ENGINE
// ═══════════════════════════════════════════════════════════════════════════

const PATTERNS = {
    sparse: {
        kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hat:   [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
    },
    normal: {
        kick:  [1,0,0,0, 0,0,1,0, 0,0,0,0, 0,1,0,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hat:   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
        ghost: [0,0,0,1, 0,0,0,0, 0,0,0,1, 0,0,0,0],
    },
    busy: {
        kick:  [1,0,0,1, 0,0,1,0, 0,1,0,0, 0,0,1,0],
        snare: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,1],
        hat:   [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],
        ghost: [0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1],
        rim:   [0,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],
    },
    // New patterns for evolution
    broken: {
        kick:  [1,0,0,0, 0,0,0,1, 0,0,1,0, 0,0,0,0],
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 0,1,0,1],
        hat:   [1,0,1,1, 0,1,1,0, 1,0,1,1, 0,1,1,0],
        ghost: [0,0,1,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],
    },
    polyrhythm: {
        kick:  [1,0,0,1, 0,0,1,0, 0,1,0,0, 1,0,0,1],
        snare: [0,0,0,0, 1,0,0,0, 0,0,1,0, 0,0,0,1],
        hat:   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
        rim:   [0,0,0,1, 0,0,0,0, 0,0,0,1, 0,0,0,0],
    }
};

let lastTickTime = -1;

function getPattern() {
    const level = (ai.drumDensity + world.energy) / 2;

    // Evolution can unlock new patterns
    if (music.epoch >= 2 && music.chaosLevel > 0.4 && level > 0.5) {
        return Math.random() < 0.5 ? PATTERNS.broken : PATTERNS.polyrhythm;
    }

    if (level < 0.33) return PATTERNS.sparse;
    if (level < 0.66) return PATTERNS.normal;
    return PATTERNS.busy;
}

function getSwing(tickInBeat) {
    const v = VIBES[vibe];
    return (tickInBeat === 1 || tickInBeat === 3) ? v.swing * 0.04 : 0;
}

function onTick() {
    const v = VIBES[vibe];
    const tickInBar = music.tick % 16;
    const beatInBar = Math.floor(tickInBar / 4);
    const tickInBeat = tickInBar % 4;

    const baseVel = 0.5 + world.energy * 0.3 + mic.level * 0.2;
    const pat = getPattern();
    const scale = getEvolvedScale();

    // === DRUMS ===
    if (pat.kick?.[tickInBar]) {
        const kickVel = baseVel * (music.epoch > 1 ? 0.95 : 0.9);
        playSample('kick', kickVel, 0, 1);
        music.lastKick = music.tick;
    }

    if (pat.snare?.[tickInBar]) {
        const pan = (Math.random() - 0.5) * 0.12;
        // Crisp snare with slight pitch variation
        playSample('snare', baseVel * 0.8, pan, 0.98 + Math.random() * 0.04);
        music.lastSnare = music.tick;
    }

    if (pat.hat?.[tickInBar]) {
        const type = Math.random() < 0.08 ? 'hatOpen' : 'hat';
        const vel = baseVel * (tickInBeat === 0 ? 0.4 : 0.28);
        playSample(type, vel, 0.25, 0.92 + Math.random() * 0.16);
    }

    if (pat.ghost?.[tickInBar]) {
        playSample('snare', baseVel * 0.2, 0.1, 0.95);
    }

    if (pat.rim?.[tickInBar]) {
        playSample('rim', baseVel * 0.35, -0.2, 1);
    }

    // === BASS (always plays, evolves) ===
    const bassFrequency = ai.bassActivity < 0.3 ? 4 : ai.bassActivity < 0.6 ? 2 : 1;

    if (tickInBeat === 0 && beatInBar % bassFrequency === 0) {
        let bassNote = scale[0];

        if (ai.bassActivity > 0.4) {
            bassNote = scale[(beatInBar + music.bar) % scale.length];
        }
        if (ai.bassActivity > 0.7 && beatInBar === 2) {
            bassNote = scale[(beatInBar + music.bar + 1) % scale.length];
        }

        // Evolution: chromatic walk in high chaos
        if (music.chaosLevel > 0.6 && Math.random() < 0.2) {
            bassNote += (Math.random() < 0.5 ? 1 : -1);
        }

        const dur = (60 / v.bpm) * (4 / bassFrequency) * 0.9;
        playBass(bassNote, 0.6 + world.energy * 0.2, dur);
    }

    // === PAD ===
    if (tickInBar === 0) {
        if (music.bar % 4 === 0) {
            music.chord = (music.chord + 1) % v.chords.length;
        }
        updatePad();
    }

    // === LEAD (probability-based, melodically aware) ===
    const leadProb = (world.energy * 0.4 + mic.level * 0.3 + ai.leadProbability * 0.3);

    if (tickInBeat === 0 && Math.random() < leadProb) {
        let noteIdx = Math.floor(world.y * scale.length);
        let note = scale[noteIdx % scale.length];

        // Melodic memory - tend toward intervals from recent notes
        if (music.memory.length > 2 && Math.random() < 0.4) {
            const lastNote = music.memory[music.memory.length - 1];
            const interval = [2, 3, 4, 5, 7][Math.floor(Math.random() * 5)];
            note = lastNote + (Math.random() < 0.5 ? interval : -interval);
        }

        if (world.y > 0.7 || music.tension > 0.7) note += 12;
        if (world.y < 0.3 && music.tension < 0.3) note -= 0;

        playLead(note, 0.35 + world.energy * 0.3);
    }

    // Mic onset triggers
    if (mic.onset && mic.gateOpen && Math.random() < 0.6) {
        const note = scale[Math.floor(Math.random() * scale.length)];
        playLead(note + (mic.high > mic.low ? 12 : 0), mic.level * 0.8);
    }

    // Evolution
    evolve();

    // Update counters
    music.tick++;
    if (tickInBar === 15) {
        music.bar++;
        music.beat = 0;
    }
    if (tickInBeat === 3) {
        music.beat++;
    }
}

function updateRhythm() {
    if (!audioReady || !samplesLoaded) return;

    const v = VIBES[vibe];
    const tickDur = 60 / v.bpm / 4;
    const now = ctx.currentTime;

    if (lastTickTime < 0) {
        lastTickTime = now;
        return;
    }

    const swing = getSwing(music.tick % 4);
    if (now - lastTickTime >= tickDur + swing) {
        lastTickTime = now;
        onTick();
    }

    world.pulse = (now - lastTickTime) / tickDur;
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 12: INPUT HANDLING
// ═══════════════════════════════════════════════════════════════════════════

function onMove(nx, ny) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.vx = world.vx * 0.7 + dx * 0.3;
    world.vy = world.vy * 0.7 + dy * 0.3;
    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.85 + movement * 10);

    if (movement > 0.008) {
        world.stillness = Math.max(0, world.stillness - 0.15);
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    world.x = Math.max(0, Math.min(1, world.x + ax * 0.06));
    world.y = Math.max(0, Math.min(1, world.y - ay * 0.06));

    const movement = Math.sqrt(ax*ax + ay*ay);
    world.energy = Math.min(1, world.energy * 0.8 + movement * 0.5);

    if (movement > 0.03) {
        world.stillness = Math.max(0, world.stillness - 0.08);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 13: VISUALS
// ═══════════════════════════════════════════════════════════════════════════

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    vc.fillStyle = `rgba(10,10,15,${0.12 + world.energy * 0.08})`;
    vc.fillRect(0, 0, w, h);

    const breath = 50 + Math.sin(world.breath) * 12 + world.pulse * 25;

    // Epoch indicator
    const epochAlpha = 0.02 + music.epoch * 0.015;
    vc.strokeStyle = `rgba(255,220,180,${epochAlpha})`;
    vc.lineWidth = 1;
    for (let i = 0; i < music.epoch && i < 5; i++) {
        vc.beginPath();
        vc.arc(w/2, h/2, breath + 15 + i * 20, 0, TAU);
        vc.stroke();
    }

    vc.strokeStyle = `rgba(255,220,180,${0.04 + world.stillness * 0.06})`;
    vc.beginPath();
    vc.arc(w/2, h/2, breath, 0, TAU);
    vc.stroke();

    const tensionR = breath + 25 + music.tension * 50;
    const hue = music.direction === 'build' ? '255,180,100' :
                music.direction === 'release' ? '100,180,255' : '180,180,200';
    vc.strokeStyle = `rgba(${hue},${music.tension * 0.15})`;
    vc.beginPath();
    vc.arc(w/2, h/2, tensionR, 0, TAU);
    vc.stroke();

    if (world.energy > 0.1) {
        const energyR = breath + 60 + world.energy * 60;
        vc.strokeStyle = `rgba(255,220,180,${world.energy * 0.12})`;
        vc.beginPath();
        vc.arc(w/2, h/2, energyR, 0, TAU);
        vc.stroke();
    }

    if (mic.active && mic.level > 0.04) {
        const micR = breath + 100 + mic.level * 80;
        vc.strokeStyle = `rgba(100,255,150,${mic.level * 0.25})`;
        vc.lineWidth = 2;
        vc.beginPath();
        vc.arc(w/2, h/2, micR, 0, TAU);
        vc.stroke();
        vc.lineWidth = 1;
    }

    const px = world.x * w;
    const py = world.y * h;
    const ps = 5 + world.energy * 18;
    vc.fillStyle = `rgba(255,220,180,${0.35 + world.energy * 0.5})`;
    vc.beginPath();
    vc.arc(px, py, ps, 0, TAU);
    vc.fill();

    document.getElementById('mic-dot').classList.toggle('on', mic.active && mic.level > 0.08);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 14: MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════

function frame() {
    world.breath += 0.018;
    world.energy *= 0.992;
    world.stillness = Math.min(1, world.stillness + 0.004);

    if (world.energy > 0.5) {
        music.tension = Math.min(1, music.tension + 0.003);
        music.direction = 'build';
    } else if (world.energy < 0.2) {
        music.tension = Math.max(0, music.tension - 0.002);
        music.direction = 'release';
    } else {
        music.direction = 'float';
    }

    updateMic();
    updateRhythm();

    if (masterFilter) {
        const v = VIBES[vibe];
        const target = v.filterBase + world.energy * 6000;
        masterFilter.frequency.setTargetAtTime(target, ctx.currentTime, 0.1);
    }

    if (reverbGain) {
        const v = VIBES[vibe];
        reverbGain.gain.setTargetAtTime(v.reverbMix * 0.4, ctx.currentTime, 0.2);
    }

    updateAI();
    draw();

    const status = `${vibe} · bar ${music.bar + 1} · epoch ${music.epoch}
drift: ${Math.round(music.drift * 100)}%
chaos: ${Math.round(music.chaosLevel * 100)}%
tension: ${Math.round(music.tension * 100)}%`;
    document.getElementById('status').innerHTML = status.replace(/\n/g, '<br>');

    requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// SECTION 15: INITIALIZATION
// ═══════════════════════════════════════════════════════════════════════════

function initVibeButtons() {
    document.querySelectorAll('.vibe-btn').forEach(btn => {
        btn.addEventListener('click', e => {
            e.stopPropagation();
            document.querySelectorAll('.vibe-btn').forEach(b => b.classList.remove('on'));
            btn.classList.add('on');
            vibe = btn.dataset.vibe;
            music.tick = 0;
            music.bar = 0;
            music.chord = 0;
            // Keep evolution state across vibe changes
            lastTickTime = -1;
        });
    });
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    await initAudio();
    initVisuals();
    initVibeButtons();

    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();
    frame();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
