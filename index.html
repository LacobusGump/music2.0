<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #111;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 2s ease;
        }
        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.1) 0%, transparent 70%);
            border: 2px solid rgba(255, 165, 0, 0.3);
            color: #ffa500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
            z-index: 100;
        }
        .start-btn:hover {
            border-color: rgba(255, 165, 0, 0.6);
            transform: scale(1.05);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 165, 0, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(255, 165, 0, 0.4); }
        }
        .orb {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.8) 0%, rgba(255, 165, 0, 0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
            opacity: 0;
        }
        .orb.active { opacity: 1; }
        .orb.recording {
            background: radial-gradient(circle, rgba(0, 255, 0, 0.8) 0%, rgba(0, 255, 0, 0.3) 50%, transparent 80%);
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
            animation: recordingPulse 1s ease-in-out infinite;
        }
        @keyframes recordingPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        .waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 2px;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .waveform.active { opacity: 1; }
        .wave-bar {
            width: 4px;
            height: 2px;
            background: rgba(255, 165, 0, 0.6);
            transition: height 0.1s ease;
            border-radius: 2px;
        }
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 165, 0, 0.4);
            animation: float 8s linear infinite;
        }
        @keyframes float {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(-20vh) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="startBtn" class="start-btn">GUMP</div>
    <div id="orb" class="orb"></div>
    <div id="waveform" class="waveform"></div>
    <div class="particles" id="particles"></div>

    <script>
        class ProLofiUniverse {
            constructor() {
                this.mic = null;
                this.analyser = null;
                this.recorder = null;
                this.isRecording = false;
                this.lastSampleTime = 0;
                this.samples = { drums: [], bass: [], melody: [], pads: [] };
                this.samplers = {};
                this.effects = {};
                this.motion = 0;
                this.pos = { x: 0, y: 0, z: 0 };
                this.orientation = { alpha: 0, beta: 0, gamma: 0 };
                this.motionHistory = [];
                this.bpmHistory = [];
                this.elements = {
                    startBtn: document.getElementById('startBtn'),
                    orb: document.getElementById('orb'),
                    waveform: document.getElementById('waveform'),
                    particles: document.getElementById('particles')
                };
                this.waveBars = [];
                this.bpm = 85;
                this.active = false;
                this.init();
            }

            init() {
                this.elements.startBtn.onclick = () => this.start();
                this.createWaveBars(64);
                this.setupMotion();
                this.setupOrientation();
            }

            setupOrientation() {
                window.addEventListener('deviceorientation', e => {
                    if (!this.active) return;
                    this.orientation.alpha = e.alpha || 0;
                    this.orientation.beta = e.beta || 0;
                    this.orientation.gamma = e.gamma || 0;
                    Tone.Listener.setOrientation(
                        Math.cos(this.orientation.alpha * Math.PI / 180),
                        Math.sin(this.orientation.alpha * Math.PI / 180),
                        1,
                        Math.sin(this.orientation.beta * Math.PI / 180),
                        Math.cos(this.orientation.beta * Math.PI / 180),
                        Math.sin(this.orientation.gamma * Math.PI / 180)
                    );
                });
            }

            createWaveBars(count) {
                for (let i = 0; i < count; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    this.elements.waveform.appendChild(bar);
                    this.waveBars.push(bar);
                }
            }

            setupMotion() {
                let lastMouse = { x: 0, y: 0, time: 0 };
                document.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    const now = Date.now();
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const dt = now - lastMouse.time || 1;
                    const vel = Math.sqrt(dx*dx + dy*dy) / dt;
                    this.updateMotion(vel);
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                    this.pos.x = (e.clientX / window.innerWidth - 0.5) * 2;
                    this.pos.y = (e.clientY / window.innerHeight - 0.5) * 2;
                    this.updatePanners();
                });

                window.addEventListener('devicemotion', e => {
                    if (!this.active || !e.acceleration) return;
                    const acc = e.acceleration;
                    const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
                    this.updateMotion(mag * 0.05);
                    this.pos.x += acc.x * 0.01;
                    this.pos.y += acc.y * 0.01;
                    this.pos.z += acc.z * 0.01;
                    this.updatePanners();
                });
            }

            updateMotion(vel) {
                this.motion = this.motion * 0.8 + vel * 0.2;
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 60) this.motionHistory.shift();
                this.detectTempoFromMotion();
            }

            detectTempoFromMotion() {
                const threshold = 0.5;
                const now = performance.now();
                const peaks = this.motionHistory.filter((m, i) => m > threshold && (i === 0 || this.motionHistory[i-1] <= threshold));
                if (peaks.length < 4) return;
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i] - peaks[i-1]);
                }
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const targetBpm = 60 / (avgInterval / 1000) * 4; // Assuming 16th notes
                this.bpmHistory.push(targetBpm);
                if (this.bpmHistory.length > 5) this.bpmHistory.shift();
                const smoothedBpm = this.bpmHistory.reduce((a, b) => a + b, 0) / this.bpmHistory.length;
                this.bpm = this.bpm * 0.8 + smoothedBpm * 0.2;
                Tone.Transport.bpm.value = Math.max(60, Math.min(100, this.bpm));
            }

            updatePanners() {
                Object.values(this.samplers).forEach((sampler, i) => {
                    if (sampler.panner) {
                        sampler.panner.positionX.value = this.pos.x + Math.sin(i) * 2;
                        sampler.panner.positionY.value = this.pos.y + Math.cos(i) * 2;
                        sampler.panner.positionZ.value = this.pos.z - i;
                    }
                });
            }

            async start() {
                try {
                    await Tone.start();
                    this.mic = new Tone.UserMedia();
                    await this.mic.open();
                    this.analyser = new Tone.Analyser('fft', 1024);
                    this.mic.connect(this.analyser);
                    this.setupEffects();
                    this.setupSamplers();
                    this.elements.startBtn.style.display = 'none';
                    this.elements.orb.classList.add('active');
                    this.elements.waveform.classList.add('active');
                    this.active = true;
                    this.startLoop();
                    this.startSequencer();
                    this.addVinylNoise();
                    this.addAmbientLayer();
                } catch (err) {
                    console.error('Error:', err);
                }
            }

            setupEffects() {
                this.effects.compressor = new Tone.Compressor(-20, 4);
                this.effects.eq = new Tone.EQ3(-3, 0, -6); // Gentle rolloff
                this.effects.lowpass = new Tone.Filter(2500, 'lowpass');
                this.effects.bitcrush = new Tone.BitCrusher(12);
                this.effects.tape = new Tone.Distortion(0.05); // Soft saturation
                this.effects.reverb = new Tone.Reverb({ decay: 3, preDelay: 0.2 });
                this.effects.reverb.generate();
                this.effects.delay = new Tone.PingPongDelay({ delayTime: 0.25, feedback: 0.3 });
                this.effects.chorus = new Tone.Chorus(0.5, 2.5, 0.5);

                this.masterChain = new Tone.Chain(
                    this.effects.compressor,
                    this.effects.eq,
                    this.effects.chorus,
                    this.effects.delay,
                    this.effects.reverb,
                    this.effects.lowpass,
                    this.effects.bitcrush,
                    this.effects.tape,
                    Tone.Destination
                );
            }

            setupSamplers() {
                ['drums', 'bass', 'melody', 'pads'].forEach(layer => {
                    this.samplers[layer] = new Tone.Sampler({
                        attack: layer === 'pads' ? 1 : 0.05,
                        release: layer === 'pads' ? 2 : 0.3,
                        curve: 'linear'
                    });
                    this.samplers[layer].panner = new Tone.Panner3D();
                    this.samplers[layer].connect(this.samplers[layer].panner);
                    this.samplers[layer].panner.connect(this.masterChain);
                });
            }

            addVinylNoise() {
                this.effects.vinyl = new Tone.Noise('brown');
                this.effects.vinyl.volume.value = -28;
                const vinylFilter = new Tone.Filter(4000, 'lowpass');
                this.effects.vinyl.connect(vinylFilter).connect(this.masterChain);
                this.effects.vinyl.start();
            }

            addAmbientLayer() {
                this.effects.ambient = new Tone.Noise('white');
                this.effects.ambient.volume.value = -32;
                const ambFilter = new Tone.Filter(800, 'lowpass');
                const ambReverb = new Tone.Reverb(5);
                this.effects.ambient.connect(ambFilter).connect(ambReverb).connect(this.masterChain);
                this.effects.ambient.start();
            }

            startLoop() {
                const loop = () => {
                    if (!this.active) return;
                    const fft = this.analyser.getValue();
                    this.updateViz(fft);
                    this.checkSample(fft);
                    this.updateParams();
                    this.updateBackground();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            updateViz(fft) {
                const avg = fft.reduce((a, b) => a + Math.abs(b), 0) / fft.length / 128;
                this.elements.orb.style.transform = `translate(-50%, -50%) scale(${1 + avg * 0.5})`;
                this.waveBars.forEach((bar, i) => {
                    const val = Math.abs(fft[i * (fft.length / 64)]) / 128;
                    bar.style.height = `${val * 60}px`;
                });
                if (Math.random() < avg * 0.1) this.createParticles(3 + Math.floor(avg * 5));
            }

            createParticles(count) {
                for (let i = 0; i < count; i++) {
                    const p = document.createElement('div');
                    p.className = 'particle';
                    p.style.left = `${this.pos.x * window.innerWidth + (Math.random() - 0.5) * 20}px`;
                    p.style.top = `${this.pos.y * window.innerHeight + (Math.random() - 0.5) * 20}px`;
                    p.style.animationDelay = `${Math.random() * 2}s`;
                    this.elements.particles.appendChild(p);
                    setTimeout(() => p.remove(), 8000);
                }
            }

            checkSample(fft) {
                const now = Date.now();
                if (now - this.lastSampleTime < 3000 || this.isRecording) return;
                const avgLevel = fft.reduce((a, b) => a + Math.abs(b), 0) / fft.length / 128;
                if (avgLevel > 0.08) {
                    this.isRecording = true;
                    this.elements.orb.classList.add('recording');
                    this.recorder = new Tone.Recorder();
                    this.mic.connect(this.recorder);
                    this.recorder.start();
                    const recordTime = 1000 + Math.random() * 2000;
                    setTimeout(async () => await this.processSample(), recordTime);
                }
            }

            async processSample() {
                this.isRecording = false;
                this.elements.orb.classList.remove('recording');
                const recording = await this.recorder.stop();
                const url = URL.createObjectURL(recording);
                const buffer = await new Tone.Buffer(url);

                // Advanced processing for rich lo-fi
                const pitch = await this.detectPitch(buffer);
                const targetPitch = this.snapToScale(pitch);
                const shiftSemitones = Math.log2(targetPitch / pitch) * 12;

                // Offline processing chain
                const offline = await Tone.Offline(async (context) => {
                    const player = new Tone.Player(buffer).connect(context.destination);
                    const pitchShift = new Tone.PitchShift(shiftSemitones).connect(context.destination);
                    const vibrato = new Tone.Vibrato(0.5, 0.02).connect(pitchShift);
                    const eq = new Tone.EQ3(-2, 2, -4).connect(vibrato); // Boost mids for warmth
                    const comp = new Tone.Compressor(-25, 6).connect(eq);
                    const dist = new Tone.Distortion(0.1).connect(comp); // Gentle tape-like
                    player.connect(dist);
                    player.start();
                }, buffer.duration, 1);

                const processed = new Tone.Buffer(offline);

                // Chop
                const numSlices = 4 + Math.floor(Math.random() * 5);
                const sliceDur = processed.duration / numSlices;
                const slices = [];
                for (let i = 0; i < numSlices; i++) {
                    slices.push(processed.slice(i * sliceDur, (i+1) * sliceDur));
                }

                // Categorize
                const low = await this.getBandEnergy(processed, 0, 200);
                const mid = await this.getBandEnergy(processed, 200, 2000);
                const high = await this.getBandEnergy(processed, 2000, 11025);
                let layer = 'pads';
                if (high > mid * 1.2 && high > low) layer = 'drums';
                else if (low > mid * 1.2 && low > high) layer = 'bass';
                else if (mid > low && mid > high) layer = 'melody';

                // Add slices with variations
                slices.forEach((slice, idx) => {
                    const note = idx; // Use index as 'note'
                    this.samplers[layer].add(note, slice);
                });

                this.lastSampleTime = Date.now();
            }

            async detectPitch(buffer) {
                const offline = await Tone.Offline(() => {
                    const player = new Tone.Player(buffer).toDestination();
                    player.start();
                }, buffer.duration);
                const data = offline.toArray(0);
                let maxCorr = 0;
                let bestLag = 0;
                const minLag = Math.floor(offline.sampleRate / 1000);
                const maxLag = Math.floor(offline.sampleRate / 40);
                for (let lag = minLag; lag < maxLag; lag++) {
                    let corr = 0;
                    for (let i = 0; i < data.length - lag; i++) {
                        corr += data[i] * data[i + lag];
                    }
                    if (corr > maxCorr) {
                        maxCorr = corr;
                        bestLag = lag;
                    }
                }
                return offline.sampleRate / bestLag || 220;
            }

            snapToScale(pitch) {
                const scale = [130.81, 138.59, 146.83, 155.56, 164.81, 174.61, 185, 196, 207.65, 220, 233.08, 246.94]; // Aeolian mode from C3
                return scale.reduce((prev, curr) => Math.abs(curr - pitch) < Math.abs(prev - pitch) ? curr : prev);
            }

            async getBandEnergy(buffer, low, high) {
                const offline = await Tone.Offline(async (context) => {
                    const player = new Tone.Player(buffer).connect(context.destination);
                    const filter = new Tone.Filter({
                        type: 'bandpass',
                        frequency: (low + high) / 2,
                        Q: (high - low) / ((low + high) / 2)
                    }).connect(context.destination);
                    player.connect(filter);
                    player.start();
                }, buffer.duration);
                const data = offline.toArray(0);
                return data.reduce((sum, val) => sum + val ** 2, 0) / data.length;
            }

            startSequencer() {
                const layers = ['drums', 'bass', 'melody', 'pads'];
                new Tone.Loop(time => {
                    layers.forEach(layer => {
                        if (this.samplers[layer].loaded && Math.random() < this.getTriggerProb(layer)) {
                            const notes = Object.keys(this.samplers[layer]._buffers._buffers);
                            if (notes.length > 0) {
                                const note = notes[Math.floor(Math.random() * notes.length)];
                                const dur = layer === 'pads' ? '2m' : layer === 'melody' ? '4n' : '8n';
                                this.samplers[layer].triggerAttackRelease(note, dur, time);
                            }
                        }
                    });
                    Tone.Draw.schedule(() => {
                        this.elements.orb.classList.add('pulse');
                        setTimeout(() => this.elements.orb.classList.remove('pulse'), 100);
                    }, time);
                }, "4n").start(0);
                Tone.Transport.start();
            }

            getTriggerProb(layer) {
                switch(layer) {
                    case 'drums': return 0.8;
                    case 'bass': return 0.6;
                    case 'melody': return 0.4;
                    case 'pads': return 0.3;
                }
            }
        }

        new ProLofiUniverse();
    </script>
</body>
</html>
