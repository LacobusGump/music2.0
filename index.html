<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{display:none}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.2);display:flex;align-items:center;justify-content:center;font:10px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.4);transition:0.3s}
        #enter:hover div{border-color:rgba(255,255,255,0.5);color:rgba(255,255,255,0.7)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// You are the waveform. Movement is music. No gates. No unlock. Just you.

const TAU = Math.PI * 2;

// ============ THE FIELD ============
// A continuous harmonic space you move through.
// Your position IS the harmony. Your velocity IS the energy.

let ctx, master, verb, dly;
let field = { x: 0.5, y: 0.5, vx: 0, vy: 0, energy: 0 };
let voices = [];
let running = false;
let canvas, vc;

// Harmonic ratios - just intonation for natural beauty
const HARMONICS = [1, 1.5, 2, 2.5, 3, 4, 5, 6, 8];
const BASE = 55; // A1

// ============ INIT ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master with soft compression
    master = ctx.createGain();
    master.gain.value = 0.6;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -24;
    comp.ratio.value = 4;
    comp.attack.value = 0.01;
    comp.release.value = 0.3;

    // Deep reverb - the space itself
    verb = createVerb();

    // Delay - echoes of your movement
    dly = ctx.createDelay(2);
    dly.delayTime.value = 0.4;
    const dlyFb = ctx.createGain();
    dlyFb.gain.value = 0.3;
    const dlyFilt = ctx.createBiquadFilter();
    dlyFilt.type = 'lowpass';
    dlyFilt.frequency.value = 1500;
    dly.connect(dlyFilt);
    dlyFilt.connect(dlyFb);
    dlyFb.connect(dly);
    dly.connect(master);

    master.connect(comp);
    comp.connect(ctx.destination);
    verb.output.connect(master);

    // Create the harmonic field - always present, always responding
    createField();

    // Canvas
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.5;

    // Multiple delay lines for rich space
    [0.03, 0.07, 0.11, 0.17, 0.23, 0.31, 0.43, 0.59, 0.79].forEach((t, i) => {
        const d = ctx.createDelay(1);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = 0.4 * Math.pow(0.85, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 4000 - i * 400;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
    });

    return { input, output };
}

// ============ THE HARMONIC FIELD ============
// Not voices that unlock. A field that's always there.
// Your position modulates it. Your movement shapes it.

function createField() {
    HARMONICS.forEach((ratio, i) => {
        const voice = createVoice(BASE * ratio, i);
        voices.push(voice);
    });
}

function createVoice(freq, index) {
    // Each voice: osc -> filter -> gain -> destinations
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator(); // Slight detune for warmth
    const filter = ctx.createBiquadFilter();
    const gain = ctx.createGain();
    const pan = ctx.createStereoPanner();

    // Oscillators
    osc.type = 'sine';
    osc.frequency.value = freq;
    osc2.type = 'sine';
    osc2.frequency.value = freq * 1.002; // Gentle beating

    // Filter - position controls this
    filter.type = 'lowpass';
    filter.frequency.value = 200;
    filter.Q.value = 1;

    // Start silent
    gain.gain.value = 0;

    // Panning based on harmonic position
    pan.pan.value = (index / HARMONICS.length) * 2 - 1;

    // Connect
    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(pan);
    pan.connect(master);
    pan.connect(verb.input);
    pan.connect(dly);

    osc.start();
    osc2.start();

    return { osc, osc2, filter, gain, pan, baseFreq: freq, index };
}

// ============ THE SHAPING ============
// Your movement continuously shapes the field.
// No events. No triggers. Just continuous modulation.

function shapeField() {
    const now = ctx.currentTime;

    // Energy from velocity
    field.energy = field.energy * 0.95 + Math.sqrt(field.vx*field.vx + field.vy*field.vy) * 0.5;

    // Position maps to harmonic emphasis
    // X = which harmonics are loud (low to high across screen)
    // Y = filter openness (up = brighter)

    voices.forEach((v, i) => {
        // Which harmonics sing based on X position
        const harmonicPosition = i / voices.length;
        const distance = Math.abs(field.x - harmonicPosition);
        const presence = Math.max(0, 1 - distance * 2); // Closer = louder

        // Base amplitude from position + energy boost
        const amp = presence * 0.15 * (0.5 + field.energy);
        v.gain.gain.linearRampToValueAtTime(amp, now + 0.1);

        // Filter opens with Y position and energy
        const filterBase = 150 + field.y * 2000 + field.energy * 1500;
        v.filter.frequency.linearRampToValueAtTime(filterBase, now + 0.1);

        // Subtle pitch drift with movement
        const drift = 1 + (field.vx * 0.02 * (i - voices.length/2));
        v.osc.frequency.linearRampToValueAtTime(v.baseFreq * drift, now + 0.15);
        v.osc2.frequency.linearRampToValueAtTime(v.baseFreq * drift * 1.002, now + 0.15);

        // Pan follows movement direction slightly
        const panBase = (i / voices.length) * 1.6 - 0.8;
        const panMod = field.vx * 0.3;
        v.pan.pan.linearRampToValueAtTime(Math.max(-1, Math.min(1, panBase + panMod)), now + 0.1);
    });

    // Reverb amount increases with stillness (let it breathe)
    const stillness = 1 - Math.min(1, field.energy * 2);
    verb.output.gain.linearRampToValueAtTime(0.3 + stillness * 0.4, now + 0.3);

    // Delay feedback increases with energy (movement echoes)
    dly.delayTime.linearRampToValueAtTime(0.2 + field.energy * 0.4, now + 0.2);
}

// ============ INPUT ============
// Movement from anywhere: mouse, touch, device motion

function onMove(nx, ny) {
    // nx, ny are 0-1 normalized
    field.vx = field.vx * 0.7 + (nx - field.x) * 0.3;
    field.vy = field.vy * 0.7 + (ny - field.y) * 0.3;
    field.x = nx;
    field.y = ny;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    // Map acceleration to movement
    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    field.vx = field.vx * 0.8 + ax * 0.2;
    field.vy = field.vy * 0.8 + ay * 0.2;

    // Drift position based on tilt
    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.1));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.1));
}

function onOrientation(e) {
    // Use orientation for absolute position
    const gx = (e.gamma || 0) / 45; // -1 to 1
    const gy = (e.beta || 0) / 45 - 1; // -1 to 1

    const nx = (gx + 1) / 2; // 0 to 1
    const ny = 1 - (gy + 1) / 2; // 0 to 1

    onMove(nx, ny);
}

// ============ VISUALIZATION ============
// The field made visible. Not UI. Just the sound, shown.

function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade
    vc.fillStyle = `rgba(0, 0, 0, ${0.1 + (1 - field.energy) * 0.05})`;
    vc.fillRect(0, 0, w, h);

    const cx = field.x * w;
    const cy = (1 - field.y) * h;

    // Draw each voice as a ring at its harmonic position
    voices.forEach((v, i) => {
        const amp = v.gain.gain.value;
        if (amp < 0.005) return;

        const vx = (i / voices.length) * w;
        const vy = h / 2;

        // Connection to cursor
        const dist = Math.sqrt((cx - vx) ** 2 + (cy - vy) ** 2);
        const maxDist = w * 0.5;
        const conn = Math.max(0, 1 - dist / maxDist);

        if (conn > 0.1) {
            vc.beginPath();
            vc.moveTo(cx, cy);
            vc.lineTo(vx, vy);
            vc.strokeStyle = `rgba(255, 255, 255, ${conn * amp * 0.3})`;
            vc.lineWidth = 1;
            vc.stroke();
        }

        // Voice ring
        const r = 20 + amp * 100;
        vc.beginPath();
        vc.arc(vx, vy, r, 0, TAU);
        const hue = 200 + i * 20;
        vc.strokeStyle = `hsla(${hue}, 60%, ${50 + amp * 30}%, ${amp * 2})`;
        vc.lineWidth = 2 + amp * 4;
        vc.stroke();
    });

    // Cursor glow
    const glowR = 30 + field.energy * 50;
    const gr = vc.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    gr.addColorStop(0, `rgba(255, 255, 255, ${0.3 + field.energy * 0.4})`);
    gr.addColorStop(0.5, `rgba(200, 220, 255, ${0.1 + field.energy * 0.2})`);
    gr.addColorStop(1, 'transparent');
    vc.fillStyle = gr;
    vc.beginPath();
    vc.arc(cx, cy, glowR, 0, TAU);
    vc.fill();

    // Movement trail
    if (field.energy > 0.05) {
        const trailLen = field.energy * 80;
        vc.beginPath();
        vc.moveTo(cx, cy);
        vc.lineTo(cx - field.vx * trailLen * 10, cy + field.vy * trailLen * 10);
        vc.strokeStyle = `rgba(255, 255, 255, ${field.energy * 0.5})`;
        vc.lineWidth = 2;
        vc.stroke();
    }
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    shapeField();
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    // Request motion permissions (iOS)
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    // Input handlers
    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, 1 - e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') {
        await ctx.resume();
    }

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
