<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Environmental Sampling EDM Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,20,20,0.1) 0%, transparent 70%);
            border: 3px solid rgba(255,20,20,0.4);
            color: #ff1414;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: samplePulse 2s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(255,20,20,0.8);
            background: radial-gradient(circle, rgba(255,20,20,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        .btn-text {
            font-size: 20px;
            margin-bottom: 8px;
        }

        .btn-subtext {
            font-size: 11px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
        }

        @keyframes samplePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255,20,20,0.3);
            }
            50% {
                transform: scale(1.06);
                box-shadow: 0 0 80px rgba(255,20,20,0.6);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff1414 0%, rgba(255,20,20,0.4) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 50px rgba(255,20,20,0.6);
            backdrop-filter: blur(8px);
            will-change: transform;
        }

        .orb.pulse {
            animation: sampleBeat 0.12s ease-out;
        }

        @keyframes sampleBeat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2.5); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.sampling {
            background: radial-gradient(circle, #ff6600 0%, rgba(255,102,0,0.5) 50%, transparent 80%);
            box-shadow: 0 0 70px rgba(255,102,0,0.8);
            animation: samplingActive 1s ease-in-out infinite;
        }

        .orb.chopping {
            background: radial-gradient(circle, #00ff88 0%, rgba(0,255,136,0.5) 50%, transparent 80%);
            box-shadow: 0 0 90px rgba(0,255,136,0.9);
            animation: choppingActive 0.5s ease-in-out infinite;
        }

        .orb.flipping {
            background: radial-gradient(circle, #8800ff 0%, rgba(136,0,255,0.5) 50%, transparent 80%);
            box-shadow: 0 0 120px rgba(136,0,255,1);
            animation: flippingActive 0.3s ease-in-out infinite;
        }

        .orb.dropping {
            background: radial-gradient(circle, #ffff00 0%, #ff0080 30%, #00ffff 60%, transparent 90%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 100px rgba(255,0,128,0.8));
            animation: droppingActive 0.2s ease-in-out infinite;
        }

        .orb.transcending {
            background: conic-gradient(from 0deg, #ff1414, #ff6600, #00ff88, #8800ff, #00ffff, #ff0080, #ffff00, #ff1414);
            box-shadow: 0 0 300px rgba(255,255,255,0.8);
            filter: drop-shadow(0 0 200px rgba(255,255,255,0.6));
            animation: transcendingActive 0.1s ease-in-out infinite;
        }

        @keyframes samplingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.2) rotate(180deg); }
        }

        @keyframes choppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.4); }
        }

        @keyframes flippingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.6) rotate(360deg); }
        }

        @keyframes droppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            25% { transform: translate(-50%, -50%) scale(2); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
            75% { transform: translate(-50%, -50%) scale(2.2); }
        }

        @keyframes transcendingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            25% { transform: translate(-50%, -50%) scale(3) rotate(90deg); }
            50% { transform: translate(-50%, -50%) scale(2) rotate(180deg); }
            75% { transform: translate(-50%, -50%) scale(3.5) rotate(270deg); }
        }

        .hidden {
            display: none !important;
        }

        .sample-viz {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 250px;
            height: 80px;
            background: rgba(255,20,20,0.1);
            border: 1px solid rgba(255,20,20,0.3);
            border-radius: 8px;
            padding: 8px;
            font-size: 10px;
            backdrop-filter: blur(10px);
        }

        .sample-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
        }

        .waveform {
            width: 100%;
            height: 30px;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            position: relative;
            overflow: hidden;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 2px;
            background: linear-gradient(to top, #ff1414, #ff6600, #ffff00);
            transition: height 0.1s ease;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 200px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(10px);
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .slider {
            width: 80px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .slider-thumb {
            width: 12px;
            height: 12px;
            background: #ff1414;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            transform: translateX(-50%);
            transition: all 0.2s ease;
        }

        .slider-thumb:hover {
            transform: translateX(-50%) scale(1.2);
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,20,20,0.4);
            animation: sampleFloat 8s linear infinite;
        }

        @keyframes sampleFloat {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-20vh) scale(2) rotate(360deg);
                opacity: 0;
            }
        }

        .spectral-analyzer {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 300px;
            height: 100px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            backdrop-filter: blur(10px);
        }

        .spectrum-canvas {
            width: 100%;
            height: 80px;
            border-radius: 4px;
        }

        .ai-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 12px;
            backdrop-filter: blur(10px);
            font-size: 11px;
            max-width: 200px;
        }

        .sample-layers {
            position: fixed;
            left: 20px;
            top: 140px;
            width: 200px;
            background: rgba(0,0,0,0.7);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
           backdrop-filter: blur(10px);
            font-size: 10px;
        }

        .layer {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            padding: 2px 4px;
            border-radius: 3px;
            background: rgba(255,255,255,0.05);
        }

        .layer.active {
            background: rgba(255,20,20,0.2);
            border: 1px solid rgba(255,20,20,0.4);
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            <div class="btn-text">Let's Go</div>
            <div class="btn-subtext">SAMPLE THE WORLD<br>MAKE THE BEAT</div>
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
        
        <div id="sampleViz" class="sample-viz hidden">
            <div class="sample-info">
                <span id="sampleStatus">LISTENING...</span>
                <span id="sampleCount">0 SAMPLES</span>
            </div>
            <div class="waveform" id="waveform"></div>
            <div style="font-size: 8px; margin-top: 4px;">
                <span id="bpmDisplay">140 BPM</span> | 
                <span id="stageDisplay">LISTENING</span>
            </div>
        </div>

        <div id="controls" class="controls hidden">
            <div class="control-row">
                <span>Threshold</span>
                <div class="slider" data-param="threshold">
                    <div class="slider-thumb" style="left: 50%;"></div>
                </div>
            </div>
            <div class="control-row">
                <span>Sensitivity</span>
                <div class="slider" data-param="sensitivity">
                    <div class="slider-thumb" style="left: 30%;"></div>
                </div>
            </div>
            <div class="control-row">
                <span>Chaos</span>
                <div class="slider" data-param="chaos">
                    <div class="slider-thumb" style="left: 20%;"></div>
                </div>
            </div>
            <div class="control-row">
                <span>Evolution</span>
                <div class="slider" data-param="evolution">
                    <div class="slider-thumb" style="left: 10%;"></div>
                </div>
            </div>
        </div>

        <div id="spectralAnalyzer" class="spectral-analyzer hidden">
            <canvas id="spectrumCanvas" class="spectrum-canvas"></canvas>
        </div>

        <div id="aiStatus" class="ai-status hidden">
            <div><strong>AI BRAIN</strong></div>
            <div id="aiThoughts">Listening to environment...</div>
            <div id="aiPrediction">Preparing to sample...</div>
        </div>

        <div id="sampleLayers" class="sample-layers hidden">
            <div><strong>SAMPLE LAYERS</strong></div>
            <div class="layer" data-layer="kick">
                <span>KICK</span>
                <span id="kickCount">0</span>
            </div>
            <div class="layer" data-layer="snare">
                <span>SNARE</span>
                <span id="snareCount">0</span>
            </div>
            <div class="layer" data-layer="hats">
                <span>HATS</span>
                <span id="hatsCount">0</span>
            </div>
            <div class="layer" data-layer="bass">
                <span>BASS</span>
                <span id="bassCount">0</span>
            </div>
            <div class="layer" data-layer="lead">
                <span>LEAD</span>
                <span id="leadCount">0</span>
            </div>
            <div class="layer" data-layer="fx">
                <span>FX</span>
                <span id="fxCount">0</span>
            </div>
        </div>
    </div>

    <script>
        class GUMPSamplingEngine {
            constructor() {
                this.ctx = null;
                this.active = false;
                this.analyser = null;
                this.dataArray = null;

                // ENVIRONMENTAL SAMPLING SYSTEM
                this.microphone = null;
                this.micAnalyser = null;
                this.micDataArray = null;
                this.isRecording = false;
                this.sampleBuffer = [];
                this.recordingBuffer = [];
                this.sampleLibrary = [];
                this.currentRecordingTime = 0;
                this.maxSampleLength = 4;
                this.sampleThreshold = 0.1;
                this.lastSampleTime = 0;
                this.samplingCooldown = 2000;

                // AI INTELLIGENCE SYSTEM
                this.aiThoughts = [
                    "Analyzing acoustic environment...",
                    "Detecting rhythmic patterns...",
                    "Learning from your movement...",
                    "Evolving musical understanding...",
                    "Predicting next sample moment...",
                    "Synthesizing environmental harmony...",
                    "Decoding musical intentions...",
                    "Transforming chaos into rhythm..."
                ];
                this.currentThought = 0;
                this.aiLearning = {
                    preferredGenres: new Map(),
                    motionPatterns: [],
                    samplingHistory: [],
                    evolutionPreferences: new Map()
                };

                // ADVANCED SAMPLE MANIPULATION
                this.choppedSamples = new Map();
                this.sampleGrains = new Map();
                this.pitchShifts = [-24, -12, -7, -5, -3, 0, 3, 5, 7, 12, 19, 24];
                this.chopSizes = [0.0625, 0.125, 0.25, 0.375, 0.5, 0.75, 1.0, 2.0];
                this.currentSampleIndex = 0;
                this.spectralEffects = ['stretch', 'formant', 'vocoder', 'granular', 'freeze'];

                // MOTION & ENVIRONMENTAL RESPONSE
                this.motion = 0;
                this.intensity = 0;
                this.direction = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.totalMotion = 0;
                this.lastMotionTime = Date.now();
                this.gestureRecognition = new Map();

                // EVOLUTION & TRANSCENDENCE SYSTEM
                this.stage = 'LISTENING';
                this.evolutionProgress = 0;
                this.currentTheme = 'sampling';
                this.transcendenceLevel = 0;
                this.cosmicAlignment = 0;
                this.dimensionalPhase = 0;

                // MUSICAL INTELLIGENCE
                this.bpm = 140;
                this.step = 0;
                this.sectionLength = 32;
                this.beatCount = 0;
                this.musicalKey = 'C';
                this.mode = 'minor';
                this.progression = ['i', 'VI', 'III', 'VII'];
                this.swingAmount = 0.1;
                this.humanization = 0.02;

                // ADVANCED AUDIO SYSTEM
                this.masterGain = null;
                this.limiter = null;
                this.layerGains = {};
                this.convolver = null;
                this.delay = null;
                this.multiTapDelay = null;
                this.chorus = null;
                this.distortion = null;
                this.filter = null;
                this.spatializer = null;

                // SPECTRAL ANALYSIS
                this.spectralAnalyzer = null;
                this.spectralData = null;
                this.spectralCanvas = null;
                this.spectralCtx = null;
                this.spectralHistory = [];

                // SAMPLE LAYERS WITH AI
                this.sampleLayers = {
                    kick: { samples: [], current: null, gain: null, personality: 'powerful', lastPlayed: 0 },
                    snare: { samples: [], current: null, gain: null, personality: 'crisp', lastPlayed: 0 },
                    hats: { samples: [], current: null, gain: null, personality: 'sparkling', lastPlayed: 0 },
                    bass: { samples: [], current: null, gain: null, personality: 'deep', lastPlayed: 0 },
                    lead: { samples: [], current: null, gain: null, personality: 'melodic', lastPlayed: 0 },
                    fx: { samples: [], current: null, gain: null, personality: 'experimental', lastPlayed: 0 }
                };

                // CONTROL PARAMETERS
                this.controls = {
                    threshold: 0.1,
                    sensitivity: 0.3,
                    chaos: 0.2,
                    evolution: 0.1
                };

                this.elements = {};
                this.init();
            }

            // Added missing stubs for undefined methods to make it work flawlessly
            selectContextualSample(layer, context) {
                const layerSamples = this.sampleLayers[layer] ? this.sampleLayers[layer].samples : [];
                if (layerSamples.length === 0) return null;
                const candidates = layerSamples.filter(s => s.analysis.energy === context.energy && s.motionContext.pattern === context.motionPattern);
                return candidates.length > 0 ? candidates[Math.floor(Math.random() * candidates.length)] : layerSamples[Math.floor(Math.random() * layerSamples.length)];
            }

            createGranularSample(sample, grainSize, overlap) {
                const grains = [];
                const grainLength = grainSize * sample.buffer.sampleRate;
                const step = grainLength * (1 - overlap);
                for (let start = 0; start < sample.buffer.length - grainLength; start += step) {
                    const grainBuffer = this.ctx.createBuffer(sample.buffer.numberOfChannels, grainLength, sample.buffer.sampleRate);
                    for (let channel = 0; channel < sample.buffer.numberOfChannels; channel++) {
                        grainBuffer.getChannelData(channel).set(sample.buffer.getChannelData(channel).slice(start, start + grainLength));
                    }
                    grains.push(grainBuffer);
                }
                return grains;
            }

            applySpectralEffects(sample, effect) {
                // Stub for spectral effects
                return sample;
            }

            applySpectralEffect(sample, effect) {
                // Stub
                return sample;
            }

            evolveToChopping() {
                this.stage = 'CHOPPING';
                this.elements.orb.className = 'orb chopping';
                this.currentTheme = 'chopping';
                this.createParticles(20, '#00ff88');
                console.log('‚úÇÔ∏è EVOLUTION: CHOPPING MODE');
            }

            evolveToFlipping() {
                this.stage = 'FLIPPING';
                this.elements.orb.className = 'orb flipping';
                this.currentTheme = 'flipping';
                this.createParticles(30, '#8800ff');
                console.log('üîÑ EVOLUTION: FLIPPING MODE');
            }

            evolveToDropping() {
                this.stage = 'DROPPING';
                this.elements.orb.className = 'orb dropping';
                this.currentTheme = 'dropping';
                this.createParticles(50, '#ffff00');
                console.log('üî• EVOLUTION: DROPPING MODE');
            }

            // Advanced sample manipulation methods
            triggerManualSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const contextualSample = this.selectContextualSample('fx', {
                    energy: this.intensity > 2 ? 'high' : 'medium',
                    motionPattern: this.motionPattern
                });
                
                if (contextualSample) {
                    this.playSample(contextualSample, 'fx');
                    this.createParticles(8, '#ff1414');
                    console.log('üéµ CONTEXTUAL SAMPLE TRIGGER');
                }
            }

            chopCurrentSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                const intelligentChopSize = this.calculateIntelligentChopSize(sample);
                
                this.playSampleChop(sample, intelligentChopSize, 'lead');
                this.evolveToChopping();
                console.log(`‚úÇÔ∏è INTELLIGENT CHOPPING: ${intelligentChopSize} beats`);
            }

            calculateIntelligentChopSize(sample) {
                // AI-driven chop size selection
                const bpmFactor = this.bpm / 140;
                const motionFactor = this.motion / 3;
                const complexityFactor = sample.analysis.rhythmicComplexity / 5;
                
                let baseSize = 0.25; // 16th note
                
                if (this.motionPattern === 'chaotic') baseSize *= 0.5;
                if (this.stage === 'DROPPING') baseSize *= 0.25;
                if (complexityFactor > 1) baseSize *= 2;
                
                baseSize *= (1 + motionFactor * 0.5);
                baseSize *= bpmFactor;
                
                // Quantize to musical divisions
                const musicalDivisions = [0.0625, 0.125, 0.25, 0.5, 1.0];
                return musicalDivisions.reduce((prev, curr) => 
                    Math.abs(curr - baseSize) < Math.abs(prev - baseSize) ? curr : prev
                );
            }

            flipCurrentSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                this.playSampleReversed(sample, 'fx');
                this.evolveToFlipping();
                console.log('üîÑ SAMPLE FLIP');
            }

            pitchShiftCurrentSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                const musicalPitchShift = this.selectMusicalPitchShift();
                
                this.playSamplePitched(sample, musicalPitchShift, 'lead');
                console.log(`üéµ MUSICAL PITCH SHIFT: ${musicalPitchShift} semitones`);
            }

            selectMusicalPitchShift() {
                // Select pitch shifts based on current musical key and mode
                const majorIntervals = [0, 2, 4, 5, 7, 9, 11, 12];
                const minorIntervals = [0, 2, 3, 5, 7, 8, 10, 12];
                
                const intervals = this.mode === 'major' ? majorIntervals : minorIntervals;
                return intervals[Math.floor(Math.random() * intervals.length)] - 12; // Include negative octave
            }

            createGranularTexture() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                const grains = this.createGranularSample(sample, 0.1, 0.5);
                
                // Play multiple grains with slight timing offsets
                grains.slice(0, 5).forEach((grain, index) => {
                    setTimeout(() => {
                        this.playGrain(grain, 'fx');
                    }, index * 50);
                });
                
                console.log('üåü GRANULAR TEXTURE');
            }

            playGrain(grain, layer) {
                if (!grain || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = grain;
                gain.gain.value = 0.3;
                
                // Envelope for smooth grain playback
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.01);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + grain.duration - 0.01);
                
                source.connect(gain);
                gain.connect(this.sampleLayers[layer].gain);
                
                source.start();
                source.stop(this.ctx.currentTime + grain.duration);
            }

            freezeSpectralMoment() {
                if (this.spectralHistory.length === 0) return;
                
                // Create a sustained tone from current spectral content
                const currentSpectrum = this.spectralHistory[this.spectralHistory.length - 1];
                const frozenBuffer = this.createSpectralFreeze(currentSpectrum);
                
                if (frozenBuffer) {
                    const source = this.ctx.createBufferSource();
                    source.buffer = frozenBuffer;
                    source.loop = true;
                    source.connect(this.sampleLayers.fx.gain);
                    source.start();
                    
                    // Auto-stop after a few seconds
                    source.stop(this.ctx.currentTime + 4);
                }
                
                console.log('‚ùÑÔ∏è SPECTRAL FREEZE');
            }

            createSpectralFreeze(spectrum) {
                const duration = 2; // seconds
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);
                
                // Convert spectrum to oscillators
                const fundamentalFreq = 55; // A1
                
                for (let i = 0; i < data.length; i++) {
                    let sample = 0;
                    
                    // Sum harmonics based on spectral content
                    for (let h = 0; h < Math.min(spectrum.length, 32); h++) {
                        const amplitude = (spectrum[h] / 255) * 0.1;
                        const frequency = fundamentalFreq * (h + 1);
                        const phase = 2 * Math.PI * frequency * i / sampleRate;
                        sample += Math.sin(phase) * amplitude;
                    }
                    
                    data[i] = sample;
                }
                
                return buffer;
            }

            timeStretchSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                const stretchRatio = this.calculateIntelligentStretchRatio();
                
                this.playSampleTimeStretched(sample, stretchRatio, 'lead');
                console.log(`‚è∞ TIME STRETCH: ${stretchRatio}x`);
            }

            calculateIntelligentStretchRatio() {
                const ratios = [0.5, 0.75, 1.25, 1.5, 2.0];
                
                // Select based on current stage and motion
                if (this.stage === 'DROPPING') return ratios[Math.floor(Math.random() * 2)]; // Faster
                if (this.motionPattern === 'calm') return ratios[3 + Math.floor(Math.random() * 2)]; // Slower
                
                return ratios[Math.floor(Math.random() * ratios.length)];
            }

            vocodeSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                this.playSampleVocoded(sample, 'fx');
                console.log('ü§ñ VOCODER EFFECT');
            }

            triggerSpectralEffect() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[this.currentSampleIndex % this.sampleLibrary.length];
                const effect = this.spectralEffects[Math.floor(Math.random() * this.spectralEffects.length)];
                
                this.playSampleWithSpectralEffect(sample, effect, 'fx');
                console.log(`‚ú® SPECTRAL EFFECT: ${effect.toUpperCase()}`);
            }

            transcendReality() {
                if (this.transcendenceLevel < 0.9) return;
                
                // Ultimate reality-bending effect
                this.cosmicAlignment += 0.1;
                this.dimensionalPhase = (this.dimensionalPhase + 1) % 8;
                
                // Sample from all dimensions simultaneously  
                Object.values(this.sampleLayers).forEach((layer, index) => {
                    if (layer.samples.length > 0) {
                        setTimeout(() => {
                            const sample = layer.samples[Math.floor(Math.random() * layer.samples.length)];
                            const effect = this.spectralEffects[Math.floor(Math.random() * this.spectralEffects.length)];
                            this.playSampleWithCosmicEffect(sample, effect, Object.keys(this.sampleLayers)[index]);
                        }, index * 100);
                    }
                });
                
                this.createParticles(200, '#ffffff');
                console.log('üåå REALITY TRANSCENDED');
            }

            // Enhanced playback methods
            playSample(sample, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                gain.gain.value = this.calculateDynamicGain(sample, layer);
                
                // Apply layer-specific processing
                source.connect(gain);
                gain.connect(this.sampleLayers[layer].processor.input);
                
                // Humanization
                const humanizedDelay = this.humanizeTiming(0, this.humanization);
                const startTime = this.ctx.currentTime + Math.max(0, humanizedDelay / 1000);
                
                source.start(startTime);
                source.stop(startTime + sample.duration);
                
                // Update layer state
                this.sampleLayers[layer].lastPlayed = Date.now();
                this.sampleLayers[layer].current = sample;
            }

            calculateDynamicGain(sample, layer) {
                let baseGain = this.sampleLayers[layer].gain.gain.value;
                
                // Adaptive gain based on sample characteristics
                const energyFactor = sample.analysis.energy === 'high' ? 0.8 : 
                                   sample.analysis.energy === 'low' ? 1.2 : 1.0;
                
                // Motion-responsive gain
                const motionFactor = 0.8 + (this.motion / 5) * 0.4;
                
                // Stage-based adjustments
                let stageFactor = 1.0;
                switch(this.stage) {
                    case 'DROPPING': stageFactor = 1.2; break;
                    case 'TRANSCENDING': stageFactor = 1.5; break;
                }
                
                return baseGain * energyFactor * motionFactor * stageFactor;
            }

            playSampleChop(sample, chopSize, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                gain.gain.value = this.calculateDynamicGain(sample, layer) * 0.9;
                
                const chopDuration = chopSize * (60 / this.bpm);
                const actualDuration = Math.min(chopDuration, sample.duration);
                
                // Add swing timing
                const swingDelay = this.calculateSwingTiming(this.step, this.swingAmount);
                const startTime = this.ctx.currentTime + swingDelay / 1000;
                
                source.connect(gain);
                gain.connect(this.sampleLayers[layer].processor.input);
                
                source.start(startTime);
                source.stop(startTime + actualDuration);
            }

            playSamplePitched(sample, semitones, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                source.playbackRate.value = Math.pow(2, semitones / 12);
                gain.gain.value = this.calculateDynamicGain(sample, layer) * 0.8;
                
                source.connect(gain);
                gain.connect(this.sampleLayers[layer].processor.input);
                
                source.start();
                source.stop(this.ctx.currentTime + sample.duration / source.playbackRate.value);
            }

            playSampleReversed(sample, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                // Create reversed buffer
                const reversedBuffer = this.ctx.createBuffer(
                    sample.buffer.numberOfChannels,
                    sample.buffer.length,
                    sample.buffer.sampleRate
                );
                
                for (let channel = 0; channel < sample.buffer.numberOfChannels; channel++) {
                    const originalData = sample.buffer.getChannelData(channel);
                    const reversedData = reversedBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < originalData.length; i++) {
                        reversedData[i] = originalData[originalData.length - 1 - i];
                    }
                }

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = reversedBuffer;
                gain.gain.value = this.calculateDynamicGain(sample, layer) * 0.7;
                
                source.connect(gain);
                gain.connect(this.sampleLayers[layer].processor.input);
                
                source.start();
                source.stop(this.ctx.currentTime + sample.duration);
            }

            playSampleTimeStretched(sample, stretchRatio, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                source.playbackRate.value = 1.0 / stretchRatio;
                gain.gain.value = this.calculateDynamicGain(sample, layer) * 0.8;
                
                source.connect(gain);
                gain.connect(this.sampleLayers[layer].processor.input);
                
                source.start();
                source.stop(this.ctx.currentTime + sample.duration * stretchRatio);
            }

            playSampleVocoded(sample, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                source.buffer = sample.buffer;
                filter.type = 'bandpass';
                filter.frequency.value = 500 + (this.motion * 200);
                filter.Q.value = 10;
                gain.gain.value = this.calculateDynamicGain(sample, layer) * 0.6;
                
                // Animate filter for vocoder effect
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                lfo.type = 'sine';
                lfo.frequency.value = 5;
                lfoGain.gain.value = 200;
                
                lfo.connect(lfoGain);
                lfoGain.connect(filter.frequency);
                lfo.start();
                lfo.stop(this.ctx.currentTime + sample.duration);
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.sampleLayers[layer].processor.input);
                
                source.start();
                source.stop(this.ctx.currentTime + sample.duration);
            }

            playSampleWithSpectralEffect(sample, effect, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const processed = this.applySpectralEffects(sample, effect);
                
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = processed.buffer || sample.buffer;
                gain.gain.value = this.calculateDynamicGain(sample, layer) * 0.7;
                
                // Apply effect-specific processing
                let processor = gain;
                
                switch(effect) {
                    case 'quantum':
                        processor = this.createQuantumProcessor(gain);
                        break;
                    case 'dimensional':
                        processor = this.createDimensionalProcessor(gain);
                        break;
                    case 'cosmic':
                        processor = this.createCosmicProcessor(gain);
                        break;
                    case 'ethereal':
                        processor = this.createEtherealProcessor(gain);
                        break;
                }
                
                source.connect(processor);
                processor.connect(this.sampleLayers[layer].processor.input);
                
                source.start();
                source.stop(this.ctx.currentTime + sample.duration);
            }

            playSampleWithCosmicEffect(sample, effect, layer) {
                if (!sample || !this.sampleLayers[layer]) return;

                const source = this.ctx.createBufferSource();
                const cosmicGain = this.ctx.createGain();
                const cosmicProcessor = this.createCosmicResonator();
                
                source.buffer = sample.buffer;
                cosmicGain.gain.value = this.calculateDynamicGain(sample, layer) * this.cosmicAlignment;
                
                // Dimensional phase modulation
                source.playbackRate.value = 1.0 + (Math.sin(this.dimensionalPhase) * 0.1);
                
                source.connect(cosmicProcessor);
                cosmicProcessor.connect(cosmicGain);
                cosmicGain.connect(this.sampleLayers[layer].processor.input);
                
                source.start();
                source.stop(this.ctx.currentTime + sample.duration);
            }

            // Advanced effect processors
            createQuantumProcessor(input) {
                const delay = this.ctx.createDelay(0.1);
                const feedback = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                delay.delayTime.value = 0.01 + Math.random() * 0.05;
                feedback.gain.value = 0.7;
                filter.type = 'allpass';
                filter.frequency.value = 1000 + Math.random() * 2000;
                
                input.connect(delay);
                delay.connect(feedback);
                feedback.connect(filter);
                filter.connect(delay);
                
                return delay;
            }

            createDimensionalProcessor(input) {
                const panner = this.ctx.createStereoPanner();
                const delay = this.ctx.createDelay(0.5);
                const modulator = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();
                
                modulator.type = 'sine';
                modulator.frequency.value = 0.1;
                modGain.gain.value = 0.8;
                
                modulator.connect(modGain);
                modGain.connect(panner.pan);
                modulator.start();
                
                delay.delayTime.value = 0.2;
                
                input.connect(panner);
                panner.connect(delay);
                
                return delay;
            }

            createCosmicProcessor(input) {
                const reverb = this.ctx.createConvolver();
                const gain = this.ctx.createGain();
                
                reverb.buffer = this.createAdvancedReverbBuffer(5, 'cosmic');
                gain.gain.value = this.cosmicAlignment;
                
                input.connect(reverb);
                reverb.connect(gain);
                
                return gain;
            }

            createEtherealProcessor(input) {
                const chorus = this.createChorus();
                const filter = this.ctx.createBiquadFilter();
                
                filter.type = 'highpass';
                filter.frequency.value = 200;
                filter.Q.value = 0.7;
                
                input.connect(filter);
                filter.connect(chorus.input);
                
                return chorus;
            }

            createCosmicResonator() {
                const resonator = this.ctx.createBiquadFilter();
                const modulator = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();
                
                resonator.type = 'bandpass';
                resonator.Q.value = 20;
                
                modulator.type = 'sine';
                modulator.frequency.value = 0.05;
                modGain.gain.value = 1000;
                
                modulator.connect(modGain);
                modGain.connect(resonator.frequency);
                modulator.start();
                
                return resonator;
            }

            // Motion detection and response system
            setupMotionDetection() {
                window.addEventListener('devicemotion', e => {
                    if (!this.active) return;
                    
                    const acc = e.accelerationIncludingGravity;
                    if (!acc || acc.x === null) return;

                    const dx = Math.abs(acc.x - this.lastAccel.x);
                    const dy = Math.abs(acc.y - this.lastAccel.y);
                    const dz = Math.abs(acc.z - this.lastAccel.z);
                    
                    const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.8;
                    this.updateMotion(newMotion);

                    this.velocity.x += acc.x * 0.02;
                    this.velocity.y += acc.y * 0.02;
                    this.updatePosition();

                    this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);

                    // Advanced gesture recognition
                    this.updateGestureRecognition(acc);

                    // Motion-triggered effects
                    if (newMotion > 6) {
                        this.triggerMotionSample();
                        this.triggerMotionEffect();
                    }

                    this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
                });

                // Enhanced mouse fallback with gesture recognition
                let mouseHistory = [];
                window.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    mouseHistory.push({ x: newX, y: newY, time: now });
                    if (mouseHistory.length > 10) mouseHistory.shift();
                    
                    if (mouseHistory.length >= 3) {
                        const gesture = this.recognizeMouseGesture(mouseHistory);
                        if (gesture) this.handleGesture(gesture);
                    }
                    
                    const velocity = this.calculateMouseVelocity(mouseHistory);
                    this.updateMotion(velocity);
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                });
            }

            updateGestureRecognition(acceleration) {
                const gestureWindow = 20; // frames
                const threshold = 3.0;
                
                if (!this.gestureBuffer) this.gestureBuffer = [];
                
                this.gestureBuffer.push({ ...acceleration, time: Date.now() });
                if (this.gestureBuffer.length > gestureWindow) {
                    this.gestureBuffer.shift();
                }
                
                if (this.gestureBuffer.length === gestureWindow) {
                    const gesture = this.classifyGesture(this.gestureBuffer);
                    if (gesture && gesture.confidence > 0.8) {
                        this.handleGesture(gesture);
                    }
                }
            }

            classifyGesture(buffer) {
                // Simplified gesture classification
                const avgX = buffer.reduce((sum, acc) => sum + acc.x, 0) / buffer.length;
                const avgY = buffer.reduce((sum, acc) => sum + acc.y, 0) / buffer.length;
                const avgZ = buffer.reduce((sum, acc) => sum + acc.z, 0) / buffer.length;
                
                const varX = buffer.reduce((sum, acc) => sum + Math.pow(acc.x - avgX, 2), 0) / buffer.length;
                const varY = buffer.reduce((sum, acc) => sum + Math.pow(acc.y - avgY, 2), 0) / buffer.length;
                const varZ = buffer.reduce((sum, acc) => sum + Math.pow(acc.z - avgZ, 2), 0) / buffer.length;
                
                let gesture = null;
                let confidence = 0;
                
                if (varX > 20 && varY < 5 && varZ < 5) {
                    gesture = 'shake_x';
                    confidence = Math.min(1, varX / 50);
                } else if (varY > 20 && varX < 5 && varZ < 5) {
                    gesture = 'shake_y';
                    confidence = Math.min(1, varY / 50);
                } else if (varZ > 20 && varX < 5 && varY < 5) {
                    gesture = 'shake_z';
                    confidence = Math.min(1, varZ / 50);
                } else if (varX > 10 && varY > 10 && varZ > 10) {
                    gesture = 'chaos';
                    confidence = Math.min(1, (varX + varY + varZ) / 150);
                }
                
                return gesture ? { type: gesture, confidence } : null;
            }

            recognizeMouseGesture(history) {
                if (history.length < 5) return null;
                
                const recent = history.slice(-5);
                const dx = recent[recent.length - 1].x - recent[0].x;
                const dy = recent[recent.length - 1].y - recent[0].y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (distance > 20) {
                    if (Math.abs(dx) > 2 * Math.abs(dy)) {
                        return { type: dx > 0 ? 'swipe_right' : 'swipe_left', confidence: 0.8 };
                    } else if (Math.abs(dy) > 2 * Math.abs(dx)) {
                        return { type: dy > 0 ? 'swipe_down' : 'swipe_up', confidence: 0.8 };
                    }
                }
                
                // Circular gesture detection
                const isCircular = this.detectCircularGesture(recent);
                if (isCircular) {
                    return { type: 'circle', confidence: 0.9 };
                }
                
                return null;
            }

            detectCircularGesture(points) {
                if (points.length < 5) return false;
                
                let totalAngle = 0;
                for (let i = 1; i < points.length - 1; i++) {
                    const v1 = { x: points[i].x - points[i-1].x, y: points[i].y - points[i-1].y };
                    const v2 = { x: points[i+1].x - points[i].x, y: points[i+1].y - points[i].y };
                    
                    const angle = Math.atan2(v2.y, v2.x) - Math.atan2(v1.y, v1.x);
                    totalAngle += angle;
                }
                
                return Math.abs(totalAngle) > Math.PI; // At least half a circle
            }

            calculateMouseVelocity(history) {
                if (history.length < 2) return 0;
                
                const recent = history.slice(-2);
                const dx = recent[1].x - recent[0].x;
                const dy = recent[1].y - recent[0].y;
                const dt = Math.max(1, recent[1].time - recent[0].time);
                
                return Math.sqrt(dx * dx + dy * dy) / dt * 1000; // pixels per second
            }

            handleGesture(gesture) {
                console.log(`ü§ö GESTURE DETECTED: ${gesture.type} (${(gesture.confidence * 100).toFixed(0)}%)`);
                
                switch(gesture.type) {
                    case 'shake_x':
                        this.chopCurrentSample();
                        break;
                    case 'shake_y':
                        this.flipCurrentSample();
                        break;
                    case 'shake_z':
                        this.pitchShiftCurrentSample();
                        break;
                    case 'chaos':
                        this.transcendReality();
                        break;
                    case 'swipe_right':
                        this.triggerLayerSample('lead');
                        break;
                    case 'swipe_left':
                        this.triggerLayerSample('bass');
                        break;
                    case 'swipe_up':
                        this.createGranularTexture();
                        break;
                    case 'swipe_down':
                        this.freezeSpectralMoment();
                        break;
                    case 'circle':
                        this.triggerSpectralEffect();
                        break;
                }
                
                // Visual feedback
                this.createParticles(20 * gesture.confidence, this.getGestureColor(gesture.type));
            }

            getGestureColor(gestureType) {
                const colors = {
                    shake_x: '#ff0000',
                    shake_y: '#00ff00', 
                    shake_z: '#0000ff',
                    chaos: '#ffffff',
                    swipe_right: '#ff8800',
                    swipe_left: '#8800ff',
                    swipe_up: '#00ffff',
                    swipe_down: '#ffff00',
                    circle: '#ff00ff'
                };
                return colors[gestureType] || '#ffffff';
            }

            triggerMotionSample() {
                if (this.sampleLibrary.length === 0) return;
                
                // Enhanced motion-to-layer mapping
                const motionIntensity = Math.min(5, this.motion);
                const layerMap = ['fx', 'hats', 'snare', 'lead', 'bass', 'kick'];
                const targetLayer = layerMap[Math.floor(motionIntensity)];
                
                const contextualSample = this.selectContextualSample(targetLayer, {
                    energy: motionIntensity > 3 ? 'high' : 'medium',
                    motionPattern: this.motionPattern
                });
                
                if (contextualSample) {
                    this.playSample(contextualSample, targetLayer);
                }
            }

            triggerMotionEffect() {
                // Advanced motion-triggered effects
                const effects = [
                    () => this.createGranularTexture(),
                    () => this.freezeSpectralMoment(),
                    () => this.triggerSpectralEffect(),
                    () => this.timeStretchSample()
                ];
                
                const effect = effects[Math.floor(Math.random() * effects.length)];
                effect();
            }

            findDecayTime(audioData) {
                const peak = Math.max(...audioData.map(Math.abs));
                const threshold = peak * 0.1;
                let peakIndex = audioData.findIndex(val => Math.abs(val) === peak);
                
                for (let i = peakIndex; i < audioData.length; i++) {
                    if (Math.abs(audioData[i]) < threshold) {
                        return (i - peakIndex) / this.ctx.sampleRate;
                    }
                }
                return audioData.length / this.ctx.sampleRate;
            }

            findSustainLevel(audioData) {
                const sustainStart = Math.floor(audioData.length * 0.3);
                const sustainEnd = Math.floor(audioData.length * 0.7);
                const sustainSection = audioData.slice(sustainStart, sustainEnd);
                return Math.sqrt(sustainSection.reduce((sum, val) => sum + val * val, 0) / sustainSection.length);
            }

            calculateHarmonicity(audioData) {
                // Simplified harmonicity calculation using autocorrelation
                let maxCorrelation = 0;
                const correlations = [];
                
                for (let lag = 20; lag < Math.min(audioData.length / 4, 1000); lag++) {
                    let correlation = 0;
                    for (let i = 0; i < audioData.length - lag; i++) {
                        correlation += audioData[i] * audioData[i + lag];
                    }
                    correlations.push(correlation / (audioData.length - lag));
                    maxCorrelation = Math.max(maxCorrelation, Math.abs(correlation));
                }
                
                return maxCorrelation / (audioData.length * 0.1);
            }

            calculateNoisiness(audioData) {
                // High frequency content as noise indicator
                const fftSize = 1024;
                const fftData = this.performFFT(audioData.slice(0, fftSize));
                
                let highFreqEnergy = 0;
                let totalEnergy = 0;
                
                for (let i = 0; i < fftData.length; i++) {
                    const magnitude = Math.abs(fftData[i]);
                    totalEnergy += magnitude;
                    if (i > fftData.length * 0.7) {
                        highFreqEnergy += magnitude;
                    }
                }
                
                return totalEnergy > 0 ? highFreqEnergy / totalEnergy : 0;
            }

            performFFT(audioData) {
                // Simplified FFT implementation
                const N = audioData.length;
                const fftResult = new Array(N);
                
                for (let k = 0; k < N; k++) {
                    let real = 0, imag = 0;
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += audioData[n] * Math.cos(angle);
                        imag += audioData[n] * Math.sin(angle);
                    }
                    fftResult[k] = { real, imag };
                }
                
                return fftResult;
            }

            calculateRhythmicComplexity(audioData) {
                // Onset density as complexity measure
                const onsets = this.detectOnsets(audioData);
                const duration = audioData.length / this.ctx.sampleRate;
                return onsets.length / duration;
            }

            calculateGroove(audioData) {
                // Micro-timing variations
                const onsets = this.detectOnsets(audioData);
                if (onsets.length < 3) return 0;
                
                const intervals = [];
                for (let i = 1; i < onsets.length; i++) {
                    intervals.push(onsets[i] - onsets[i-1]);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const variance = intervals.reduce((sum, interval) => sum + Math.pow(interval - avgInterval, 2), 0) / intervals.length;
                
                return Math.sqrt(variance) / avgInterval; // Coefficient of variation
            }

            classifyAudioContent(audioData, features) {
                const { rms, peak, crest, harmonicity, noisiness } = features;
                
                if (peak > 0.7 && crest > 5 && harmonicity < 0.3) return 'percussive';
                if (harmonicity > 0.7 && noisiness < 0.3) return 'tonal';
                if (noisiness > 0.6) return 'noisy';
                if (rms < 0.05) return 'ambient';
                if (crest < 2 && rms > 0.2) return 'dense';
                return 'mixed';
            }

            intelligentCategorization(sample) {
                const { analysis, features, motionContext } = sample;
                let bestLayer = 'fx';
                let confidence = 0;
                
                // AI-driven categorization based on multiple factors
                const layerScores = {
                    kick: this.scoreForKick(sample),
                    snare: this.scoreForSnare(sample),
                    hats: this.scoreForHats(sample),
                    bass: this.scoreForBass(sample),
                    lead: this.scoreForLead(sample),
                    fx: this.scoreForFX(sample)
                };
                
                Object.entries(layerScores).forEach(([layer, score]) => {
                    if (score > confidence) {
                        confidence = score;
                        bestLayer = layer;
                    }
                });
                
                // Add to primary layer
                this.sampleLayers[bestLayer].samples.push(sample);
                
                // Cross-categorize if confidence is high enough
                if (confidence > 0.8) {
                    Object.entries(layerScores).forEach(([layer, score]) => {
                        if (layer !== bestLayer && score > 0.6) {
                            this.sampleLayers[layer].samples.push({...sample, crossCategorized: true});
                        }
                    });
                }
                
                console.log(`üß† AI CATEGORIZED: ${bestLayer.toUpperCase()} (${(confidence * 100).toFixed(0)}% confidence)`);
            }

            scoreForKick(sample) {
                const { analysis, features, motionContext } = sample;
                let score = 0;
                
                // Energy and attack characteristics
                if (analysis.energy === 'high' && analysis.peak > 0.5) score += 0.4;
                if (analysis.attackTime < 0.01) score += 0.3;
                if (features.spectralCentroid < 200) score += 0.3;
                
                // Motion context
                if (motionContext.intensity > 2) score += 0.2;
                if (motionContext.pattern === 'rhythmic') score += 0.2;
                
                // Frequency content (low-heavy)
                if (analysis.category === 'percussive') score += 0.3;
                
                return Math.min(1, score);
            }

            scoreForSnare(sample) {
                const { analysis, features, motionContext } = sample;
                let score = 0;
                
                // Mid-frequency energy with noise
                if (features.spectralCentroid > 200 && features.spectralCentroid < 2000) score += 0.3;
                if (analysis.noisiness > 0.3 && analysis.noisiness < 0.8) score += 0.3;
                if (analysis.crest > 3) score += 0.2;
                
                // Duration and decay
                if (sample.duration > 0.1 && sample.duration < 0.5) score += 0.2;
                if (analysis.decayTime > 0.05) score += 0.2;
                
                return Math.min(1, score);
            }

            scoreForHats(sample) {
                const { analysis, features, motionContext } = sample;
                let score = 0;
                
                // High frequency, short duration
                if (features.spectralCentroid > 4000) score += 0.4;
                if (sample.duration < 0.3) score += 0.3;
                if (analysis.noisiness > 0.5) score += 0.2;
                if (analysis.brightness === 'bright') score += 0.2;
                
                return Math.min(1, score);
            }

            scoreForBass(sample) {
                const { analysis, features, motionContext } = sample;
                let score = 0;
                
                // Low frequency, sustained
                if (features.spectralCentroid < 300) score += 0.4;
                if (sample.duration > 1) score += 0.3;
                if (analysis.harmonicity > 0.5) score += 0.2;
                if (analysis.sustain > 0.1) score += 0.2;
                
                return Math.min(1, score);
            }

            scoreForLead(sample) {
                const { analysis, features, motionContext } = sample;
                let score = 0;
                
                // Melodic characteristics
                if (analysis.harmonicity > 0.6) score += 0.3;
                if (sample.duration > 0.5) score += 0.2;
                if (features.spectralCentroid > 500 && features.spectralCentroid < 4000) score += 0.3;
                if (analysis.category === 'tonal') score += 0.3;
                
                return Math.min(1, score);
            }

            scoreForFX(sample) {
                const { analysis, features, motionContext } = sample;
                let score = 0.1; // Base score for everything
                
                // Experimental/unusual characteristics
                if (analysis.category === 'mixed' || analysis.category === 'noisy') score += 0.3;
                if (sample.duration > 2 || sample.duration < 0.1) score += 0.2;
                if (motionContext.pattern === 'chaotic') score += 0.3;
                if (analysis.rhythmicComplexity > 5) score += 0.2;
                
                return Math.min(1, score);
            }

            createAdvancedVariations(sample) {
                const sampleId = sample.id;
                
                // Pitch variations with musical intelligence
                const musicalIntervals = [-24, -12, -7, -5, -3, 0, 3, 5, 7, 12, 15, 19, 24];
                musicalIntervals.forEach(semitones => {
                    const pitchKey = `${sampleId}_pitch_${semitones}`;
                    this.choppedSamples.set(pitchKey, {
                        original: sample,
                        type: 'pitch',
                        pitchShift: semitones,
                        playbackRate: Math.pow(2, semitones / 12),
                        musicalInterval: this.semitonesToInterval(semitones)
                    });
                });

                // Rhythmic variations
                const rhythmicDivisions = [0.0625, 0.125, 0.1875, 0.25, 0.375, 0.5, 0.75, 1.0, 1.5, 2.0];
                rhythmicDivisions.forEach(division => {
                    const chopKey = `${sampleId}_chop_${division}`;
                    const chopDuration = division * (60 / this.bpm);
                    this.choppedSamples.set(chopKey, {
                        original: sample,
                        type: 'chop',
                        division: division,
                        duration: Math.min(chopDuration, sample.duration),
                        musicalLength: this.divisionToMusical(division)
                    });
                });

                // Granular textures
                this.createGranularVariations(sample);
                
                // Spectral effects
                this.createSpectralVariations(sample);
                
                // Temporal effects
                this.createTemporalVariations(sample);
            }

            semitonesToInterval(semitones) {
                const intervals = {
                    0: 'unison', 3: 'minor 3rd', 4: 'major 3rd', 5: 'perfect 4th',
                    7: 'perfect 5th', 9: 'major 6th', 12: 'octave', 15: 'minor 10th',
                    19: 'minor 14th', 24: '2 octaves'
                };
                return intervals[semitones] || `${semitones} semitones`;
            }

            divisionToMusical(division) {
                const musicalLengths = {
                    0.0625: '64th note', 0.125: '32nd note', 0.25: '16th note',
                    0.5: '8th note', 1.0: 'quarter note', 2.0: 'half note'
                };
                return musicalLengths[division] || `${division} beats`;
            }

            createGranularVariations(sample) {
                const grainSizes = [0.05, 0.1, 0.2, 0.4];
                const overlaps = [0.25, 0.5, 0.75];
                
                grainSizes.forEach(grainSize => {
                    overlaps.forEach(overlap => {
                        const grains = this.createGranularSample(sample, grainSize, overlap);
                        const granularKey = `${sample.id}_granular_${grainSize}_${overlap}`;
                        this.sampleGrains.set(granularKey, {
                            original: sample,
                            type: 'granular',
                            grains: grains,
                            grainSize: grainSize,
                            overlap: overlap
                        });
                    });
                });
            }

            createSpectralVariations(sample) {
                this.spectralEffects.forEach(effect => {
                    const spectralKey = `${sample.id}_spectral_${effect}`;
                    this.choppedSamples.set(spectralKey, {
                        original: sample,
                        type: 'spectral',
                        effect: effect,
                        processed: this.applySpectralEffect(sample, effect)
                    });
                });
            }

            createTemporalVariations(sample) {
                const timeStretchRatios = [0.5, 0.75, 1.25, 1.5, 2.0];
                timeStretchRatios.forEach(ratio => {
                    const temporalKey = `${sample.id}_temporal_${ratio}`;
                    this.choppedSamples.set(temporalKey, {
                        original: sample,
                        type: 'temporal',
                        stretchRatio: ratio,
                        duration: sample.duration * ratio,
                        playbackRate: 1.0 / ratio
                    });
                });
            }

            updateAIKnowledge(sample) {
                // Learn genre preferences based on successful samples
                const genreSignatures = this.extractGenreSignatures(sample);
                genreSignatures.forEach(genre => {
                    const current = this.aiLearning.preferredGenres.get(genre) || 0;
                    this.aiLearning.preferredGenres.set(genre, current + 1);
                });
                
                // Update motion-to-sound mappings
                this.aiLearning.motionPatterns.push({
                    motion: sample.motionContext,
                    audio: sample.analysis,
                    success: true,
                    timestamp: sample.timestamp
                });
                
                // Evolution preferences
                const evolutionState = `${sample.musicalContext.stage}_${sample.motionContext.pattern}`;
                const evoPref = this.aiLearning.evolutionPreferences.get(evolutionState) || 0;
                this.aiLearning.evolutionPreferences.set(evolutionState, evoPref + 1);
            }

            extractGenreSignatures(sample) {
                const genres = [];
                const { analysis, features } = sample;
                
                // Electronic/EDM characteristics
                if (analysis.category === 'percussive' && features.spectralCentroid > 1000) {
                    genres.push('electronic');
                }
                
                // Hip-hop characteristics  
                if (analysis.groove > 0.1 && analysis.rhythmicComplexity > 2) {
                    genres.push('hiphop');
                }
                
                // Ambient characteristics
                if (sample.duration > 3 && analysis.noisiness < 0.2 && analysis.harmonicity > 0.6) {
                    genres.push('ambient');
                }
                
                // Industrial characteristics
                if (analysis.noisiness > 0.7 && analysis.energy === 'high') {
                    genres.push('industrial');
                }
                
                return genres;
            }

            evolveBasedOnSample(sample) {
                // Dynamic evolution based on sample characteristics
                const sampleComplexity = this.calculateSampleComplexity(sample);
                this.evolutionProgress += sampleComplexity * 0.1;
                
                if (sampleComplexity > 0.8 && this.sampleLibrary.length > 5) {
                    this.evolveToChopping();
                } else if (sampleComplexity > 0.6 && this.motionPattern === 'rhythmic') {
                    this.evolveToFlipping();
                } else if (sampleComplexity > 0.9 && this.transcendenceLevel > 0.5) {
                    this.evolveToDropping();
                }
                
                // Check for transcendence
                if (this.evolutionProgress > 0.9 && this.sampleLibrary.length > 20) {
                    this.evolveToTranscendence();
                }
            }

            calculateSampleComplexity(sample) {
                const { analysis, features } = sample;
                let complexity = 0;
                
                complexity += Math.min(1, analysis.rhythmicComplexity / 10) * 0.3;
                complexity += Math.min(1, analysis.harmonicity) * 0.2;
                complexity += Math.min(1, features.spectralCentroid / 4000) * 0.2;
                complexity += Math.min(1, analysis.groove * 10) * 0.3;
                
                return complexity;
            }

            evolveToTranscendence() {
                if (this.stage === 'TRANSCENDING') return;
                
                this.stage = 'TRANSCENDING';
                this.elements.orb.className = 'orb transcending';
                this.currentTheme = 'transcending';
                this.transcendenceLevel = 1.0;
                this.cosmicAlignment = 1.0;
                this.createParticles(100, '#ffffff');
                
                // Unlock advanced features
                this.unlockTranscendentAbilities();
                
                console.log('üåå EVOLUTION: TRANSCENDING REALITY');
            }

            unlockTranscendentAbilities() {
                // Advanced sample manipulation
                this.maxSampleLength = 8; // Longer samples
                this.samplingCooldown = 500; // Faster sampling
                
                // Enhanced AI capabilities
                this.aiThoughts = [
                    "Breaking through dimensional barriers...",
                    "Sampling the quantum foam...", 
                    "Harmonizing with cosmic frequencies...",
                    "Transcending musical limitations...",
                    "Channeling interdimensional rhythms...",
                    "Weaving reality through sound...",
                    "Achieving sonic enlightenment...",
                    "Becoming one with the universe..."
                ];
                
                // Unlock reality-bending effects
                this.spectralEffects.push('quantum', 'dimensional', 'cosmic', 'ethereal');
            }

            startSampleRecording() {
                console.log('üé§ AI SAMPLING ENVIRONMENT...');
                this.isRecording = true;
                this.recordingBuffer = [];
                this.currentRecordingTime = 0;
                this.lastSampleTime = Date.now();
                
                this.elements.orb.className = 'orb sampling';
                this.createParticles(15, '#ff6600');
                
                // Start recording from microphone
                this.recordingProcessor = this.ctx.createScriptProcessor(4096, 1, 1);
                this.microphone.connect(this.recordingProcessor);
                this.recordingProcessor.connect(this.ctx.destination);
                
                this.recordingProcessor.onaudioprocess = (e) => {
                    if (!this.isRecording) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    this.recordingBuffer.push(...inputData);
                    this.currentRecordingTime += inputData.length / this.ctx.sampleRate;
                    
                    if (this.currentRecordingTime >= this.maxSampleLength) {
                        this.finishSampleRecording();
                    }
                };
            }

            continueRecording() {
                // Recording handled by script processor
            }

            finishSampleRecording() {
                if (this.recordingBuffer.length === 0) return;

                console.log(`‚úÖ SAMPLE CAPTURED: ${this.currentRecordingTime.toFixed(2)}s`);
                
                // Clean up recording
                if (this.recordingProcessor) {
                    this.microphone.disconnect(this.recordingProcessor);
                    this.recordingProcessor.disconnect();
                    this.recordingProcessor = null;
                }
                
                // Create audio buffer from recording
                const sampleBuffer = this.ctx.createBuffer(1, this.recordingBuffer.length, this.ctx.sampleRate);
                sampleBuffer.getChannelData(0).set(this.recordingBuffer);

                // Advanced sample analysis
                const analysis = this.advancedSampleAnalysis(this.recordingBuffer);
                const features = this.extractAudioFeatures();
                
                // Create sample object with rich metadata
                const sample = {
                    id: Date.now() + Math.random(),
                    buffer: sampleBuffer,
                    duration: this.currentRecordingTime,
                    analysis: analysis,
                    features: features,
                    timestamp: Date.now(),
                    motionContext: {
                        pattern: this.motionPattern,
                        intensity: this.intensity,
                        position: { ...this.pos }
                    },
                    musicalContext: {
                        stage: this.stage,
                        bpm: this.bpm,
                        key: this.musicalKey,
                        mode: this.mode
                    }
                };

                this.sampleLibrary.push(sample);
                this.intelligentCategorization(sample);
                this.createAdvancedVariations(sample);
                this.updateAIKnowledge(sample);

                this.isRecording = false;
                this.evolveBasedOnSample(sample);

                console.log(`üìö AI BRAIN EXPANDED: ${this.sampleLibrary.length} samples`);
            }

            advancedSampleAnalysis(audioData) {
                // Enhanced analysis beyond basic RMS/peak
                const rms = Math.sqrt(audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length);
                const peak = Math.max(...audioData.map(Math.abs));
                const crest = peak / Math.max(rms, 0.001);
                
                // Envelope analysis
                const attackTime = this.findAttackTime(audioData);
                const decayTime = this.findDecayTime(audioData);
                const sustain = this.findSustainLevel(audioData);
                
                // Harmonic content
                const harmonicity = this.calculateHarmonicity(audioData);
                const noisiness = this.calculateNoisiness(audioData);
                
                // Rhythm characteristics
                const rhythmicComplexity = this.calculateRhythmicComplexity(audioData);
                const groove = this.calculateGroove(audioData);
                
                // Classification
                const category = this.classifyAudioContent(audioData, { rms, peak, crest, harmonicity, noisiness });
                
                return {
                    rms, peak, crest, attackTime, decayTime, sustain,
                    harmonicity, noisiness, rhythmicComplexity, groove,
                    category, brightness: harmonicity > 0.7 ? 'bright' : 'dark',
                    energy: peak > 0.3 ? 'high' : rms > 0.1 ? 'medium' : 'low'
                };
            }

            findAttackTime(audioData) {
                const threshold = Math.max(...audioData.map(Math.abs)) * 0.1;
                for (let i = 0; i < audioData.length; i++) {
                    if (Math.abs(audioData[i]) > threshold) {
                        return i / this.ctx.sampleRate;
                    }
                }
                return 0;
            }

            init() {
                ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'sampleViz', 'sampleStatus', 
                 'sampleCount', 'waveform', 'controls', 'spectralAnalyzer', 'spectrumCanvas',
                 'aiStatus', 'aiThoughts', 'aiPrediction', 'sampleLayers', 'bpmDisplay', 'stageDisplay']
                    .forEach(id => this.elements[id] = document.getElementById(id));
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotionDetection();
                this.setupInteractionListeners();
                this.setupControls();
                this.createWaveformBars();
                this.setupSpectralAnalyzer();
                this.startAILoop();
            }

            setupControls() {
                document.querySelectorAll('.slider').forEach(slider => {
                    const param = slider.dataset.param;
                    const thumb = slider.querySelector('.slider-thumb');
                    
                    slider.addEventListener('click', (e) => {
                        const rect = slider.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const percentage = x / rect.width;
                        const value = Math.max(0, Math.min(1, percentage));
                        
                        this.controls[param] = value;
                        thumb.style.left = (value * 100) + '%';
                        this.updateControlParameter(param, value);
                    });
                });
            }

            updateControlParameter(param, value) {
                switch(param) {
                    case 'threshold':
                        this.sampleThreshold = 0.05 + (value * 0.4);
                        break;
                    case 'sensitivity':
                        this.samplingCooldown = 500 + ((1 - value) * 3000);
                        break;
                    case 'chaos':
                        this.swingAmount = value * 0.3;
                        this.humanization = value * 0.1;
                        break;
                    case 'evolution':
                        this.evolutionProgress = value;
                        if (value > 0.8) this.evolveToTranscendence();
                        break;
                }
            }

            setupSpectralAnalyzer() {
                this.spectralCanvas = this.elements.spectrumCanvas;
                this.spectralCtx = this.spectralCanvas.getContext('2d');
                this.spectralCanvas.width = 284;
                this.spectralCanvas.height = 80;
            }

            startAILoop() {
                const aiUpdate = () => {
                    if (!this.active) return;
                    
                    // Update AI thoughts
                    this.currentThought = (this.currentThought + 1) % this.aiThoughts.length;
                    this.elements.aiThoughts.textContent = this.aiThoughts[this.currentThought];
                    
                    // AI predictions
                    const prediction = this.generateAIPrediction();
                    this.elements.aiPrediction.textContent = prediction;
                    
                    // Update AI learning
                    this.updateAILearning();
                    
                    setTimeout(aiUpdate, 2000 + Math.random() * 3000);
                };
                aiUpdate();
            }

            generateAIPrediction() {
                const predictions = [
                    `Next sample in ${Math.floor(Math.random() * 10 + 5)}s`,
                    `Evolution level: ${(this.evolutionProgress * 100).toFixed(0)}%`,
                    `Motion pattern: ${this.motionPattern}`,
                    `BPM trending: ${this.bpm > 140 ? 'UP' : 'DOWN'}`,
                    `Cosmic alignment: ${(this.cosmicAlignment * 100).toFixed(0)}%`,
                    `Samples needed: ${Math.max(0, 20 - this.sampleLibrary.length)}`,
                    `Energy level: ${this.intensity.toFixed(1)}`,
                    `Transcendence: ${this.transcendenceLevel.toFixed(1)}%`
                ];
                return predictions[Math.floor(Math.random() * predictions.length)];
            }

            updateAILearning() {
                // Learn from motion patterns
                this.aiLearning.motionPatterns.push({
                    pattern: this.motionPattern,
                    intensity: this.intensity,
                    timestamp: Date.now()
                });
                
                if (this.aiLearning.motionPatterns.length > 50) {
                    this.aiLearning.motionPatterns.shift();
                }
                
                // Learn sampling preferences
                if (this.sampleLibrary.length > 0) {
                    const lastSample = this.sampleLibrary[this.sampleLibrary.length - 1];
                    this.aiLearning.samplingHistory.push({
                        analysis: lastSample.analysis,
                        context: {
                            motion: this.motionPattern,
                            stage: this.stage,
                            bpm: this.bpm
                        }
                    });
                }
            }

            createWaveformBars() {
                const waveform = this.elements.waveform;
                for (let i = 0; i < 60; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.left = (i * 4) + 'px';
                    bar.style.height = '2px';
                    waveform.appendChild(bar);
                }
            }

            setupInteractionListeners() {
                const keyMappings = {
                    ' ': () => this.triggerManualSample(),
                    'c': () => this.chopCurrentSample(),
                    'f': () => this.flipCurrentSample(),
                    'p': () => this.pitchShiftCurrentSample(),
                    'g': () => this.createGranularTexture(),
                    's': () => this.freezeSpectralMoment(),
                    't': () => this.timeStretchSample(),
                    'v': () => this.vocodeSample(),
                    'x': () => this.triggerSpectralEffect(),
                    'z': () => this.transcendReality(),
                    '1': () => this.triggerLayerSample('kick'),
                    '2': () => this.triggerLayerSample('snare'),
                    '3': () => this.triggerLayerSample('hats'),
                    '4': () => this.triggerLayerSample('bass'),
                    '5': () => this.triggerLayerSample('lead'),
                    '6': () => this.triggerLayerSample('fx')
                };

                window.addEventListener('click', (e) => {
                    if (!this.active) return;
                    this.triggerManualSample();
                    this.createParticles(5, '#ff1414');
                });

                window.addEventListener('keydown', (e) => {
                    if (!this.active) return;
                    e.preventDefault();
                    
                    const action = keyMappings[e.key];
                    if (action) action();
                });

                // Touch gestures
                let touchStart = null;
                window.addEventListener('touchstart', (e) => {
                    if (!this.active) return;
                    touchStart = { x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() };
                });

                window.addEventListener('touchend', (e) => {
                    if (!this.active || !touchStart) return;
                    
                    const touchEnd = { x: e.changedTouches[0].clientX, y: e.changedTouches[0].y, time: Date.now() };
                    const dx = touchEnd.x - touchStart.x;
                    const dy = touchEnd.y - touchStart.y;
                    const dt = touchEnd.time - touchStart.time;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (dt < 200 && distance < 50) {
                        this.triggerManualSample();
                    } else if (distance > 100) {
                        if (Math.abs(dx) > Math.abs(dy)) {
                            dx > 0 ? this.pitchShiftCurrentSample() : this.flipCurrentSample();
                        } else {
                            dy > 0 ? this.chopCurrentSample() : this.createGranularTexture();
                        }
                    }
                });
            }

            triggerLayerSample(layerName) {
                const layer = this.sampleLayers[layerName];
                if (layer.samples.length === 0) return;
                
                const sample = layer.samples[Math.floor(Math.random() * layer.samples.length)];
                this.playSample(sample, layerName);
                
                // Update UI
                document.querySelector(`[data-layer="${layerName}"]`).classList.add('active');
                setTimeout(() => {
                    document.querySelector(`[data-layer="${layerName}"]`).classList.remove('active');
                }, 200);
            }

            async start() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        } 
                    });

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    this.setupAdvancedAudioChain();
                    this.setupMicrophoneInput(stream);
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    this.elements.sampleViz.classList.remove('hidden');
                    this.elements.controls.classList.remove('hidden');
                    this.elements.spectralAnalyzer.classList.remove('hidden');
                    this.elements.aiStatus.classList.remove('hidden');
                    this.elements.sampleLayers.classList.remove('hidden');
                    
                    this.active = true;
                    this.motionHistory = Array(100).fill(1);
                    this.motion = 1;
                    this.totalMotion = 100;
                    
                    this.evolveToSampling();
                    this.startEnvironmentalSampling();
                    this.startSequencer();
                    this.animate();
                    this.startPerformanceMonitoring();

                    console.log('üé§ GUMP SAMPLING ENGINE ACTIVE - TRANSCENDING REALITY');

                } catch (e) {
                    console.error('Failed to start sampling engine:', e);
                    alert('Microphone access required for environmental sampling!');
                }
            }

            setupAdvancedAudioChain() {
                // Main analyzer
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 256;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                // Spectral analyzer
                this.spectralAnalyzer = this.ctx.createAnalyser();
                this.spectralAnalyzer.fftSize = 2048;
                this.spectralData = new Uint8Array(this.spectralAnalyzer.frequencyBinCount);

                // Master processing chain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -3;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                // Advanced effects
                this.convolver = this.ctx.createConvolver();
                this.convolver.buffer = this.createAdvancedReverbBuffer(3, 'hall');

                this.multiTapDelay = this.createMultiTapDelay();
                this.chorus = this.createChorus();
                this.distortion = this.createDistortion();
                this.filter = this.createMultiModeFilter();
                this.spatializer = this.createSpatializer();

                // Sample layer gains with personality
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const layer = this.sampleLayers[layerName];
                    const gain = this.ctx.createGain();
                    
                    // Layer-specific processing
                    const layerProcessor = this.createLayerProcessor(layerName);
                    
                    switch(layerName) {
                        case 'kick':
                            gain.gain.value = 1.4;
                            break;
                        case 'snare':
                            gain.gain.value = 1.0;
                            layerProcessor.connect(this.convolver);
                            break;
                        case 'hats':
                            gain.gain.value = 0.8;
                            layerProcessor.connect(this.filter);
                            break;
                        case 'bass':
                            gain.gain.value = 1.2;
                            layerProcessor.connect(this.distortion);
                            break;
                        case 'lead':
                            gain.gain.value = 0.9;
                            layerProcessor.connect(this.chorus);
                            layerProcessor.connect(this.multiTapDelay);
                            break;
                        case 'fx':
                            gain.gain.value = 0.7;
                            layerProcessor.connect(this.spatializer);
                            break;
                    }
                    
                    layer.gain = gain;
                    layer.processor = layerProcessor;
                    
                    gain.connect(layerProcessor);
                    layerProcessor.connect(this.limiter);
                });

                // Effects routing
                this.convolver.connect(this.limiter);
                this.multiTapDelay.connect(this.limiter);
                this.chorus.connect(this.limiter);
                this.distortion.connect(this.limiter);
                this.filter.connect(this.limiter);
                this.spatializer.connect(this.limiter);

                // Final chain
                this.limiter.connect(this.analyser);
                this.analyser.connect(this.spectralAnalyzer);
                this.spectralAnalyzer.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            }

            createLayerProcessor(layerName) {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                // Layer-specific processing
                switch(layerName) {
                    case 'kick':
                        const kickFilter = this.ctx.createBiquadFilter();
                        kickFilter.type = 'lowpass';
                        kickFilter.frequency.value = 100;
                        kickFilter.Q.value = 2;
                        input.connect(kickFilter);
                        kickFilter.connect(output);
                        break;
                    case 'snare':
                        const snareFilter = this.ctx.createBiquadFilter();
                        snareFilter.type = 'bandpass';
                        snareFilter.frequency.value = 200;
                        snareFilter.Q.value = 1;
                        input.connect(snareFilter);
                        snareFilter.connect(output);
                        break;
                    case 'hats':
                        const hatsFilter = this.ctx.createBiquadFilter();
                        hatsFilter.type = 'highpass';
                        hatsFilter.frequency.value = 8000;
                        hatsFilter.Q.value = 0.7;
                        input.connect(hatsFilter);
                        hatsFilter.connect(output);
                        break;
                    default:
                        input.connect(output);
                }
                
                return { input, output, connect: (dest) => output.connect(dest) };
            }

            createAdvancedReverbBuffer(time, type = 'hall') {
                const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
                
                for (let c = 0; c < 2; c++) {
                    const data = buffer.getChannelData(c);
                    for (let i = 0; i < data.length; i++) {
                        let decay = Math.pow(1 - i / data.length, type === 'hall' ? 3 : 2);
                        
                        if (type === 'hall') {
                            // Hall reverb with early reflections
                            const early = i < this.ctx.sampleRate * 0.1;
                            decay *= early ? 0.8 : 0.4;
                        }
                        
                        data[i] = (Math.random() * 2 - 1) * decay;
                    }
                }
                return buffer;
            }

            createMultiTapDelay() {
                const delays = [0.125, 0.25, 0.375, 0.5].map(time => {
                    const delay = this.ctx.createDelay(1);
                    const feedback = this.ctx.createGain();
                    const mix = this.ctx.createGain();
                    
                    delay.delayTime.value = time * (60 / this.bpm);
                    feedback.gain.value = 0.3;
                    mix.gain.value = 0.15;
                    
                    delay.connect(feedback);
                    feedback.connect(delay);
                    delay.connect(mix);
                    
                    return { delay, mix };
                });
                
                const output = this.ctx.createGain();
                delays.forEach(d => d.mix.connect(output));
                
                return {
                    connect: (dest) => output.connect(dest),
                    input: delays[0].delay
                };
            }

            createChorus() {
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                const delay = this.ctx.createDelay(0.05);
                const feedback = this.ctx.createGain();
                const mix = this.ctx.createGain();
                
                lfo.type = 'sine';
                lfo.frequency.value = 0.5;
                lfoGain.gain.value = 0.002;
                feedback.gain.value = 0.1;
                mix.gain.value = 0.3;
                
                lfo.connect(lfoGain);
                lfoGain.connect(delay.delayTime);
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(mix);
                
                lfo.start();
                
                return {
                    connect: (dest) => mix.connect(dest),
                    input: delay
                };
            }

            createDistortion() {
                const waveshaper = this.ctx.createWaveShaper();
                const makeDistortionCurve = (amount = 50) => {
                    const samples = 44100;
                    const curve = new Float32Array(samples);
                    for (let i = 0; i < samples; i++) {
                        const x = (i * 2) / samples - 1;
                        curve[i] = (3 + amount) * x * 20 * Math.PI / 180 / (Math.PI + amount * Math.abs(x));
                    }
                    return curve;
                };
                
                waveshaper.curve = makeDistortionCurve(20);
                waveshaper.oversample = '4x';
                
                return waveshaper;
            }

            createMultiModeFilter() {
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 1;
                
                // Animate filter based on motion
                setInterval(() => {
                    if (this.active) {
                        filter.frequency.value = 500 + (this.motion * 3000);
                        filter.Q.value = 0.5 + (this.intensity * 2);
                    }
                }, 100);
                
                return filter;
            }

            createSpatializer() {
                const panner = this.ctx.createStereoPanner();
                const gain = this.ctx.createGain();
                
                // Spatial movement based on orb position
                setInterval(() => {
                    if (this.active) {
                        const panValue = (this.pos.x - 50) / 50;
                        panner.pan.value = Math.max(-1, Math.min(1, panValue));
                        
                        // Distance-based gain
                        const distance = Math.sqrt(Math.pow(this.pos.x - 50, 2) + Math.pow(this.pos.y - 50, 2));
                        gain.gain.value = Math.max(0.1, 1 - distance / 100);
                    }
                }, 50);
                
                panner.connect(gain);
                return {
                    connect: (dest) => gain.connect(dest),
                    input: panner
                };
            }

            setupMicrophoneInput(stream) {
                this.microphone = this.ctx.createMediaStreamSource(stream);
                
                this.micAnalyser = this.ctx.createAnalyser();
                this.micAnalyser.fftSize = 4096;
                this.micAnalyser.smoothingTimeConstant = 0.2;
                this.micDataArray = new Uint8Array(this.micAnalyser.frequencyBinCount);
                
                this.microphone.connect(this.micAnalyser);
            }

            startEnvironmentalSampling() {
                const sampleLoop = () => {
                    if (!this.active) return;

                    this.micAnalyser.getByteFrequencyData(this.micDataArray);
                    
                    // Advanced audio analysis
                    const audioFeatures = this.extractAudioFeatures();
                    this.updateSpectralVisualization();
                    this.updateWaveformViz();

                    // AI-driven sampling decisions
                    const shouldSample = this.aiShouldSample(audioFeatures);
                    
                    const now = Date.now();
                    if (shouldSample && 
                        now - this.lastSampleTime > this.samplingCooldown &&
                        this.sampleLibrary.length < 30) {
                        
                        this.startSampleRecording();
                    }

                    if (this.isRecording) {
                        this.continueRecording();
                    }

                    requestAnimationFrame(sampleLoop);
                };
                sampleLoop();
            }

            extractAudioFeatures() {
                const data = this.micDataArray;
                const sampleRate = this.ctx.sampleRate;
                
                // Spectral features
                const spectralCentroid = this.calculateSpectralCentroid(data);
                const spectralRolloff = this.calculateSpectralRolloff(data);
                const zeroCrossingRate = this.calculateZeroCrossingRate(data);
                const mfcc = this.calculateMFCC(data);
                
                // Temporal features
                const rms = Math.sqrt(data.reduce((sum, val) => sum + val * val, 0) / data.length) / 255;
                const peak = Math.max(...data) / 255;
                const crest = peak / Math.max(rms, 0.001);
                
                // Rhythm detection
                const tempo = this.detectTempo(data);
                const beat = this.detectBeat(data);
                
                return {
                    spectralCentroid,
                    spectralRolloff,
                    zeroCrossingRate,
                    mfcc,
                    rms,
                    peak,
                    crest,
                    tempo,
                    beat,
                    timestamp: Date.now()
                };
            }

            calculateSpectralCentroid(data) {
                let numerator = 0;
                let denominator = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const frequency = i * (this.ctx.sampleRate / 2) / data.length;
                    const magnitude = data[i];
                    numerator += frequency * magnitude;
                    denominator += magnitude;
                }
                
                return denominator > 0 ? numerator / denominator : 0;
            }

            calculateSpectralRolloff(data, threshold = 0.85) {
                const totalEnergy = data.reduce((sum, val) => sum + val, 0);
                const targetEnergy = totalEnergy * threshold;
                
                let cumulativeEnergy = 0;
                for (let i = 0; i < data.length; i++) {
                    cumulativeEnergy += data[i];
                    if (cumulativeEnergy >= targetEnergy) {
                        return i * (this.ctx.sampleRate / 2) / data.length;
                    }
                }
                return this.ctx.sampleRate / 2;
            }

            calculateZeroCrossingRate(data) {
                let crossings = 0;
                for (let i = 1; i < data.length; i++) {
                    if ((data[i] >= 128) !== (data[i-1] >= 128)) {
                        crossings++;
                    }
                }
                return crossings / data.length;
            }

            calculateMFCC(data) {
                // Simplified MFCC calculation
                const melFilters = this.createMelFilterBank(data.length, 13);
                const mfcc = [];
                
                for (let i = 0; i < melFilters.length; i++) {
                    let energy = 0;
                    for (let j = 0; j < data.length; j++) {
                        energy += data[j] * melFilters[i][j];
                    }
                    mfcc.push(Math.log(Math.max(energy, 1)));
                }
                
                return this.dct(mfcc);
            }

            createMelFilterBank(fftSize, numFilters) {
                const melFilters = [];
                const nyquist = this.ctx.sampleRate / 2;
                
                for (let i = 0; i < numFilters; i++) {
                    const filter = new Array(fftSize).fill(0);
                    const centerFreq = this.melToHz(this.hzToMel(300) + i * (this.hzToMel(8000) - this.hzToMel(300)) / (numFilters + 1));
                    const centerBin = Math.floor(centerFreq * fftSize / nyquist);
                    
                    for (let j = Math.max(0, centerBin - 10); j < Math.min(fftSize, centerBin + 10); j++) {
                        const distance = Math.abs(j - centerBin);
                        filter[j] = Math.max(0, 1 - distance / 10);
                    }
                    
                    melFilters.push(filter);
                }
                
                return melFilters;
            }

            hzToMel(h) {
                return 2595 * Math.log10(1 + h / 700);
            }

            melToHz(mel) {
                return 700 * (Math.pow(10, mel / 2595) - 1);
            }

            dct(input) {
                const output = [];
                const N = input.length;
                
                for (let k = 0; k < N; k++) {
                    let sum = 0;
                    for (let n = 0; n < N; n++) {
                        sum += input[n] * Math.cos((Math.PI / N) * (n + 0.5) * k);
                    }
                    output.push(sum);
                }
                
                return output;
            }

            detectTempo(data) {
                // Simplified tempo detection using onset detection
                const onsets = this.detectOnsets(data);
                if (onsets.length < 2) return this.bpm;
                
                const intervals = [];
                for (let i = 1; i < onsets.length; i++) {
                    intervals.push(onsets[i] - onsets[i-1]);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const estimatedBPM = 60 / (avgInterval * 0.1); // Convert to BPM
                
                return Math.max(80, Math.min(200, estimatedBPM));
            }

            detectOnsets(data) {
                const onsets = [];
                const threshold = Math.max(...data) * 0.6;
                
                for (let i = 1; i < data.length - 1; i++) {
                    if (data[i] > threshold && data[i] > data[i-1] && data[i] > data[i+1]) {
                        onsets.push(i);
                    }
                }
                
                return onsets;
            }

            detectBeat(data) {
                // Simple beat detection
                const lowFreq = data.slice(0, 10).reduce((a, b) => a + b, 0) / 10;
                return lowFreq > 180; // Threshold for beat detection
            }

            aiShouldSample(features) {
                // AI decision making for sampling
                const noveltyScore = this.calculateNoveltyScore(features);
                const contextScore = this.calculateContextScore(features);
                const motionAlignment = this.calculateMotionAlignment(features);
                
                const shouldSample = (
                    (noveltyScore > 0.7) ||
                    (features.rms > this.sampleThreshold && contextScore > 0.5) ||
                    (motionAlignment > 0.8 && features.peak > 0.3) ||
                    (this.transcendenceLevel > 0.9 && Math.random() < 0.1)
                );
                
                return shouldSample;
            }

            calculateNoveltyScore(features) {
                if (this.sampleLibrary.length === 0) return 1;
                
                // Compare with existing samples
                let totalDifference = 0;
                let count = 0;
                
                this.sampleLibrary.slice(-5).forEach(sample => {
                    if (sample.features) {
                        const diff = Math.abs(features.spectralCentroid - sample.features.spectralCentroid) / 8000;
                        totalDifference += diff;
                        count++;
                    }
                });
                
                return count > 0 ? totalDifference / count : 1;
            }

            calculateContextScore(features) {
                // Score based on current musical context
                let score = 0;
                
                // Tempo alignment
                if (Math.abs(features.tempo - this.bpm) < 10) score += 0.3;
                
                // Energy level appropriateness
                const targetEnergy = this.stage === 'DROPPING' ? 0.8 : 0.4;
                score += 1 - Math.abs(features.rms - targetEnergy);
                
                // Motion correlation
                const motionEnergy = this.motion / 5;
                score += 1 - Math.abs(features.rms - motionEnergy);
                
                return Math.max(0, Math.min(1, score / 3));
            }

            calculateMotionAlignment(features) {
                // Align audio features with motion patterns
                const motionIntensity = this.intensity / 4;
                const audioIntensity = features.rms;
                
                return 1 - Math.abs(motionIntensity - audioIntensity);
            }

            updateSpectralVisualization() {
                if (!this.spectralCtx) return;
                
                this.spectralAnalyzer.getByteFrequencyData(this.spectralData);
                
                const ctx = this.spectralCtx;
                const canvas = this.spectralCanvas;
                const data = this.spectralData;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / data.length * 2;
                let x = 0;
                
                for (let i = 0; i < data.length / 2; i++) {
                    const barHeight = (data[i] / 255) * canvas.height;
                    
                    const hue = (i / data.length) * 360 + (Date.now() / 50) % 360;
                    ctx.fillStyle = `hsl(${hue}, 70%, ${50 + (data[i] / 255) * 30}%)`;
                    
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth;
                }
                
                // Store spectral history for AI learning
                this.spectralHistory.push([...data]);
                if (this.spectralHistory.length > 50) {
                    this.spectralHistory.shift();
                }
            }

            updateWaveformViz() {
                const bars = this.elements.waveform.querySelectorAll('.waveform-bar');
                const dataStep = Math.floor(this.micDataArray.length / bars.length);
                
                bars.forEach((bar, i) => {
                    const dataIndex = i * dataStep;
                    const value = this.micDataArray[dataIndex] / 255;
                    bar.style.height = Math.max(2, value * 30) + 'px';
                    
                    // Color based on frequency content
                    const hue = (dataIndex / this.micDataArray.length) * 240;
                    bar.style.background = `linear-gradient(to top, hsl(${hue}, 80%, 50%), hsl(${hue + 60}, 70%, 60%))`;
                });

                // Update status displays
                this.elements.sampleStatus.textContent = this.isRecording ? 'RECORDING...' : this.stage.toUpperCase();
                this.elements.sampleCount.textContent = `${this.sampleLibrary.length} SAMPLES`;
                this.elements.bpmDisplay.textContent = `${Math.round(this.bpm)} BPM`;
                this.elements.stageDisplay.textContent = this.stage;
                
                // Update layer counts
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const count = this.sampleLayers[layerName].samples.length;
                    const element = document.getElementById(`${layerName}Count`);
                    if (element) element.textContent = count;
                });
            }
        }

        const engine = new GUMPSamplingEngine();
    </script>
</body>
</html>
