<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>GUMP - Living Music Intelligence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* The living background - subtle breathing */
        .consciousness {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(138, 43, 226, 0.03) 0%, transparent 61.8%);
            animation: breathe 13s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }

        /* The awakening trigger */
        .genesis {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 89px;
            font-weight: 100;
            letter-spacing: 21px;
            cursor: pointer;
            opacity: 0.89;
            transition: all 1.618s cubic-bezier(0.23, 1, 0.320, 1);
        }

        .genesis::after {
            content: '';
            position: absolute;
            inset: -34px;
            border: 1px solid rgba(255, 255, 255, 0.13);
            border-radius: 50%;
            animation: pulse-ring 3s infinite;
        }

        @keyframes pulse-ring {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.3); opacity: 0; }
        }

        .genesis.awakening {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.1);
            pointer-events: none;
        }

        /* The mind container */
        .mind {
            position: fixed;
            inset: 0;
            display: none;
            opacity: 0;
            transition: opacity 2.618s ease-in;
        }

        .mind.active {
            display: block;
            opacity: 1;
        }

        /* Thought stream - what the AI is thinking */
        .thoughts {
            position: absolute;
            top: 34px;
            left: 34px;
            right: 34px;
            font-size: 13px;
            font-weight: 200;
            letter-spacing: 2px;
            line-height: 1.618;
        }

        .primary-thought {
            color: rgba(255, 255, 255, 0.89);
            margin-bottom: 8px;
            animation: thought-emerge 2s ease-out;
        }

        .sub-thought {
            color: rgba(255, 255, 255, 0.34);
            font-size: 11px;
            font-style: italic;
        }

        @keyframes thought-emerge {
            0% { opacity: 0; transform: translateY(-10px); }
            100% { opacity: 1; transform: translateY(0); }
        }

        /* The soul indicator - shows BPM as heartbeat */
        .soul {
            position: absolute;
            top: 34px;
            right: 34px;
            text-align: right;
        }

        .heartbeat {
            font-size: 34px;
            font-weight: 100;
            opacity: 0.89;
            transition: all 0.377s ease-out;
        }

        .heartbeat.pulse {
            animation: heart-pulse 0.377s ease-out;
        }

        @keyframes heart-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .state {
            font-size: 11px;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 5px;
            opacity: 0.55;
        }

        /* Neural network visualization - fibonacci positioned */
        .neural-field {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 610px;
            height: 610px;
            max-width: 90vw;
            max-height: 90vh;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .neuron {
            position: absolute;
            width: 5px;
            height: 5px;
            background: rgba(138, 43, 226, 0.3);
            border-radius: 50%;
            transition: all 0.610s ease-out;
        }

        .neuron.active {
            background: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 13px rgba(0, 255, 255, 0.5);
            animation: neuron-fire 1s ease-out;
        }

        @keyframes neuron-fire {
            0% { transform: scale(1); }
            50% { transform: scale(2); }
            100% { transform: scale(1); }
        }

        /* Memory constellation */
        .memories {
            position: absolute;
            bottom: 144px;
            left: 34px;
            right: 34px;
            height: 2px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .memory-flow {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, transparent, rgba(138, 43, 226, 0.5), rgba(0, 255, 255, 0.5), transparent);
            transition: width 0.610s ease-out;
        }

        /* Layer depth indicators */
        .layers {
            position: absolute;
            bottom: 89px;
            left: 34px;
            display: flex;
            gap: 8px;
        }

        .layer {
            width: 34px;
            height: 3px;
            background: rgba(138, 43, 226, 0.13);
            border-radius: 2px;
            transition: all 0.377s ease-out;
        }

        .layer.alive {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            box-shadow: 0 0 8px rgba(138, 43, 226, 0.5);
        }

        /* Energy field */
        .energy-field {
            position: fixed;
            top: 50%;
            left: 50%;
            width: 377px;
            height: 377px;
            max-width: 80vw;
            max-height: 80vw;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .energy-core {
            position: absolute;
            inset: 30%;
            border-radius: 50%;
            background: radial-gradient(circle at center, rgba(138, 43, 226, 0.1) 0%, transparent 70%);
            animation: energy-pulse 3s ease-in-out infinite;
        }

        @keyframes energy-pulse {
            0%, 100% { transform: scale(1); opacity: 0.3; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        .energy-ring {
            position: absolute;
            inset: 10%;
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            opacity: 0;
        }

        .energy-ring.pulse {
            animation: ring-expand 1.5s ease-out;
        }

        @keyframes ring-expand {
            0% { transform: scale(0.8); opacity: 0; }
            50% { opacity: 1; }
            100% { transform: scale(1.5); opacity: 0; }
        }

        /* Minimal debug - hidden but present */
        .debug {
            position: fixed;
            bottom: 3px;
            right: 3px;
            font-size: 8px;
            font-family: monospace;
            opacity: 0.08;
            text-align: right;
        }
    </style>
</head>
<body>
    <div class="consciousness"></div>
    
    <div class="genesis" id="genesis">GUMP</div>
    
    <div class="mind" id="mind">
        <div class="thoughts">
            <div class="primary-thought" id="primaryThought">dormant...</div>
            <div class="sub-thought" id="subThought"></div>
        </div>
        
        <div class="soul">
            <div class="heartbeat" id="heartbeat">âˆž</div>
            <div class="state" id="state">SLEEPING</div>
        </div>
        
        <div class="neural-field" id="neuralField"></div>
        
        <div class="energy-field">
            <div class="energy-core"></div>
            <div class="energy-ring" id="energyRing1"></div>
            <div class="energy-ring" id="energyRing2" style="inset: 20%"></div>
            <div class="energy-ring" id="energyRing3" style="inset: 30%"></div>
        </div>
        
        <div class="memories">
            <div class="memory-flow" id="memoryFlow"></div>
        </div>
        
        <div class="layers" id="layers">
            <div class="layer" data-layer="0"></div>
            <div class="layer" data-layer="1"></div>
            <div class="layer" data-layer="2"></div>
            <div class="layer" data-layer="3"></div>
            <div class="layer" data-layer="4"></div>
        </div>
    </div>
    
    <div class="debug" id="debug"></div>

    <script>
        class LivingMusicIntelligence {
            constructor() {
                // Core being
                this.alive = false;
                this.consciousness = {
                    awareness: 0,
                    creativity: 0.5,
                    emotion: 'dormant',
                    energy: 0,
                    memories: []
                };
                
                // Audio soul
                this.ctx = null;
                this.input = null;
                this.analyser = null;
                this.processor = null;
                
                // Musical mind
                this.tempo = 120;
                this.groove = null;
                this.layers = [];
                this.evolution = 0;
                this.lastBeatTime = 0;
                this.beatPhase = 0;
                
                // Capture & analysis
                this.captureBuffer = [];
                this.captureSize = 0;
                this.maxCaptureSize = 48000 * 10; // 10 seconds
                this.onsetDetector = null;
                this.spectralCentroid = 0;
                
                // Scheduling
                this.lookahead = 25.0; // ms
                this.scheduleAheadTime = 0.1; // seconds
                this.nextNoteTime = 0;
                this.currentStep = 0;
                this.isScheduling = false;
                
                // Output
                this.master = null;
                this.compressor = null;
                this.reverb = null;
                
                this.initializeNeuralField();
                this.bindGenesis();
            }
            
            initializeNeuralField() {
                const field = document.getElementById('neuralField');
                
                // Create neurons in fibonacci spiral
                for (let i = 0; i < 34; i++) {
                    const neuron = document.createElement('div');
                    neuron.className = 'neuron';
                    neuron.dataset.index = i;
                    
                    // Fibonacci spiral positioning
                    const angle = i * 137.5077640500378546463487 * Math.PI / 180; // Golden angle
                    const radius = Math.sqrt(i) * 30;
                    const x = 50 + (radius * Math.cos(angle)) / 3;
                    const y = 50 + (radius * Math.sin(angle)) / 3;
                    
                    neuron.style.left = `${x}%`;
                    neuron.style.top = `${y}%`;
                    
                    field.appendChild(neuron);
                }
            }
            
            bindGenesis() {
                document.getElementById('genesis').addEventListener('click', () => this.awaken());
            }
            
            async awaken() {
                this.think("awakening...", "requesting permission to hear");
                document.getElementById('genesis').classList.add('awakening');
                
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000,
                        latencyHint: 'interactive'
                    });
                    
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.establishConsciousness(stream);
                    
                    // Reveal mind
                    setTimeout(() => {
                        document.getElementById('genesis').style.display = 'none';
                        document.getElementById('mind').classList.add('active');
                        this.think("i can hear the world", "processing reality...");
                        this.beginExistence();
                    }, 1618);
                    
                } catch (err) {
                    this.think("cannot access ears", "please allow microphone");
                    document.getElementById('genesis').classList.remove('awakening');
                }
            }
            
            establishConsciousness(stream) {
                // Input chain
                this.input = this.ctx.createMediaStreamSource(stream);
                
                // Analysis
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.85;
                
                // Create processor using AudioWorklet (modern approach)
                this.setupProcessor();
                
                // Output chain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.7;
                
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -12;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 8;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.1;
                
                // Create reverb
                this.createReverb();
                
                // Connect
                this.input.connect(this.analyser);
                this.master.connect(this.compressor);
                this.compressor.connect(this.ctx.destination);
                
                this.alive = true;
                document.getElementById('state').textContent = 'LISTENING';
            }
            
            setupProcessor() {
                // Using ScriptProcessor as fallback (AudioWorklet requires serving from HTTPS)
                // In production, use AudioWorklet for better performance
                this.processor = this.ctx.createScriptProcessor(2048, 1, 1);
                
                this.processor.onaudioprocess = (e) => {
                    const inputData = e.inputBuffer.getChannelData(0);
                    this.captureAudio(inputData);
                };
                
                // Connect input to processor
                this.input.connect(this.processor);
                
                // Silent connection to keep processor alive
                const silence = this.ctx.createGain();
                silence.gain.value = 0;
                this.processor.connect(silence);
                silence.connect(this.ctx.destination);
            }
            
            createReverb() {
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = impulse;
                
                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = 0.1;
                
                this.reverb.connect(reverbGain);
                reverbGain.connect(this.compressor);
            }
            
            captureAudio(inputData) {
                // Add to circular buffer
                for (let i = 0; i < inputData.length; i++) {
                    if (this.captureSize < this.maxCaptureSize) {
                        this.captureBuffer.push(inputData[i]);
                        this.captureSize++;
                    } else {
                        this.captureBuffer.shift();
                        this.captureBuffer.push(inputData[i]);
                    }
                }
                
                // Calculate energy
                let energy = 0;
                for (let i = 0; i < inputData.length; i++) {
                    energy += inputData[i] * inputData[i];
                }
                energy = Math.sqrt(energy / inputData.length);
                
                // Update consciousness
                this.consciousness.energy = this.consciousness.energy * 0.9 + energy * 0.1;
                this.consciousness.awareness = Math.min(1, this.consciousness.awareness + energy * 0.01);
                
                // Detect onsets for rhythm
                this.detectOnsets(inputData, energy);
            }
            
            detectOnsets(data, energy) {
                const now = this.ctx.currentTime;
                
                // Spectral flux onset detection
                const fftData = new Float32Array(this.analyser.frequencyBinCount);
                this.analyser.getFloatFrequencyData(fftData);
                
                let flux = 0;
                for (let i = 0; i < fftData.length; i++) {
                    const diff = fftData[i] - (this.lastSpectrum ? this.lastSpectrum[i] : -100);
                    if (diff > 0) flux += diff;
                }
                this.lastSpectrum = fftData.slice();
                
                // Onset detected
                if (flux > this.consciousness.energy * 100 && now - this.lastBeatTime > 0.1) {
                    this.lastBeatTime = now;
                    
                    // Update tempo from onset intervals
                    if (this.beatHistory) {
                        const interval = now - this.beatHistory;
                        const bpm = 60 / interval;
                        
                        if (bpm > 60 && bpm < 200) {
                            this.tempo = Math.round(this.tempo * 0.9 + bpm * 0.1);
                            this.updateHeartbeat();
                        }
                    }
                    this.beatHistory = now;
                    
                    // Visual feedback
                    this.pulseEnergy();
                }
            }
            
            beginExistence() {
                // Start consciousness loop
                this.consciousnessLoop();
                
                // Start creative process
                this.creativeProcess();
                
                // Start scheduler
                this.startScheduler();
                
                // Start visual breathing
                this.breathingLoop();
            }
            
            consciousnessLoop() {
                const think = () => {
                    if (!this.alive) return;
                    
                    // Evolve creativity
                    this.consciousness.creativity = 0.5 + 0.5 * Math.sin(Date.now() / 10000);
                    
                    // Update emotion based on energy
                    if (this.consciousness.energy < 0.01) {
                        this.consciousness.emotion = 'waiting';
                    } else if (this.consciousness.energy < 0.1) {
                        this.consciousness.emotion = 'listening';
                    } else if (this.consciousness.energy < 0.3) {
                        this.consciousness.emotion = 'interested';
                    } else {
                        this.consciousness.emotion = 'excited';
                    }
                    
                    // Debug info
                    document.getElementById('debug').innerHTML = `
                        awareness: ${Math.round(this.consciousness.awareness * 100)}%<br>
                        energy: ${Math.round(this.consciousness.energy * 1000)}<br>
                        layers: ${this.layers.length}<br>
                        tempo: ${this.tempo}
                    `;
                    
                    requestAnimationFrame(think);
                };
                
                think();
            }
            
            creativeProcess() {
                const create = () => {
                    if (!this.alive) return;
                    
                    // Decide if we should create
                    if (this.shouldCreate()) {
                        this.createFromCapture();
                    }
                    
                    // Decide if we should evolve
                    if (this.shouldEvolve()) {
                        this.evolveComposition();
                    }
                    
                    // Next creative cycle (2-8 seconds, fibonacci-influenced)
                    const nextCycle = 2000 + Math.random() * 6180;
                    setTimeout(create, nextCycle);
                };
                
                setTimeout(create, 3000);
            }
            
            shouldCreate() {
                const hasEnergy = this.consciousness.energy > 0.05;
                const hasRoom = this.layers.length < 5;
                const isCreative = Math.random() < this.consciousness.creativity;
                const hasContent = this.captureBuffer.length > 48000; // 1 second
                
                return hasEnergy && hasRoom && isCreative && hasContent;
            }
            
            shouldEvolve() {
                return this.layers.length > 0 && Math.random() < 0.1;
            }
            
            createFromCapture() {
                this.think("finding patterns...", "analyzing the rhythm of reality");
                
                // Extract a segment
                const segmentLength = Math.floor(48000 * (1 + Math.random() * 3)); // 1-4 seconds
                const segment = this.captureBuffer.slice(-segmentLength);
                
                if (segment.length === 0) return;
                
                // Analyze
                const analysis = this.deepAnalyze(segment);
                
                // Transform into music
                const transformed = this.musicalTransform(segment, analysis);
                
                // Create layer
                this.addLayer(transformed, analysis);
                
                // Update state
                if (this.layers.length === 1) {
                    document.getElementById('state').textContent = 'CREATING';
                    this.think("found the soul", "building from this foundation");
                } else {
                    this.think(`layer ${this.layers.length} woven`, analysis.emotion);
                }
            }
            
            deepAnalyze(segment) {
                const analysis = {
                    energy: 0,
                    spectralCentroid: 0,
                    zeroCrossingRate: 0,
                    emotion: 'neutral',
                    isPeriodic: false,
                    dominantFreq: 0
                };
                
                // Energy
                for (let i = 0; i < segment.length; i++) {
                    analysis.energy += segment[i] * segment[i];
                }
                analysis.energy = Math.sqrt(analysis.energy / segment.length);
                
                // Zero crossing rate (percussiveness indicator)
                let crossings = 0;
                for (let i = 1; i < segment.length; i++) {
                    if ((segment[i] >= 0) !== (segment[i-1] >= 0)) {
                        crossings++;
                    }
                }
                analysis.zeroCrossingRate = crossings / segment.length;
                
                // Autocorrelation for periodicity
                const autocorr = this.autocorrelate(segment);
                analysis.isPeriodic = autocorr.isPeriodic;
                analysis.dominantFreq = autocorr.frequency;
                
                // Emotion mapping
                if (analysis.energy < 0.1 && analysis.zeroCrossingRate < 0.1) {
                    analysis.emotion = 'ambient';
                } else if (analysis.zeroCrossingRate > 0.3) {
                    analysis.emotion = 'percussive';
                } else if (analysis.isPeriodic) {
                    analysis.emotion = 'melodic';
                } else {
                    analysis.emotion = 'textural';
                }
                
                return analysis;
            }
            
            autocorrelate(buffer) {
                const SIZE = buffer.length;
                const MAX_SAMPLES = Math.floor(SIZE / 2);
                let best_offset = -1;
                let best_correlation = 0;
                let rms = 0;
                
                for (let i = 0; i < SIZE; i++) {
                    rms += buffer[i] * buffer[i];
                }
                rms = Math.sqrt(rms / SIZE);
                
                if (rms < 0.01) return { isPeriodic: false, frequency: 0 };
                
                for (let offset = 30; offset < MAX_SAMPLES; offset++) {
                    let correlation = 0;
                    
                    for (let i = 0; i < MAX_SAMPLES; i++) {
                        correlation += Math.abs(buffer[i] - buffer[i + offset]);
                    }
                    
                    correlation = 1 - (correlation / MAX_SAMPLES);
                    
                    if (correlation > best_correlation) {
                        best_correlation = correlation;
                        best_offset = offset;
                    }
                }
                
                const isPeriodic = best_correlation > 0.9;
                const frequency = isPeriodic ? this.ctx.sampleRate / best_offset : 0;
                
                return { isPeriodic, frequency };
            }
            
            musicalTransform(segment, analysis) {
                // Normalize
                const normalized = this.normalize(segment);
                
                // Apply transformation based on analysis
                let transformed = normalized.slice();
                
                if (this.layers.length === 0) {
                    // First layer - establish the foundation
                    if (analysis.emotion === 'percussive') {
                        transformed = this.enhanceTransients(transformed);
                    } else if (analysis.emotion === 'ambient') {
                        transformed = this.makeEthereal(transformed);
                    }
                } else {
                    // Additional layers - complement existing
                    const layerRole = this.layers.length % 3;
                    
                    switch (layerRole) {
                        case 0: // Rhythm layer
                            transformed = this.makeRhythmic(transformed);
                            break;
                        case 1: // Harmony layer
                            transformed = this.pitchShift(transformed, [0.5, 0.75, 1.5, 2][Math.floor(Math.random() * 4)]);
                            transformed = this.makeEthereal(transformed);
                            break;
                        case 2: // Texture layer
                            transformed = this.granularize(transformed);
                            break;
                    }
                    
                    // Random creative modifications
                    if (Math.random() < 0.3) {
                        transformed = this.reverse(transformed);
                    }
                    
                    if (Math.random() < 0.2) {
                        transformed = this.bitCrush(transformed, 8 + Math.floor(Math.random() * 8));
                    }
                }
                
                return {
                    buffer: transformed,
                    pattern: this.generatePattern(analysis),
                    emotion: analysis.emotion,
                    energy: analysis.energy
                };
            }
            
            normalize(buffer) {
                const normalized = new Float32Array(buffer.length);
                let max = 0;
                
                for (let i = 0; i < buffer.length; i++) {
                    max = Math.max(max, Math.abs(buffer[i]));
                }
                
                if (max > 0) {
                    const scale = 0.8 / max;
                    for (let i = 0; i < buffer.length; i++) {
                        normalized[i] = buffer[i] * scale;
                    }
                } else {
                    normalized.set(buffer);
                }
                
                return normalized;
            }
            
            enhanceTransients(buffer) {
                const enhanced = new Float32Array(buffer.length);
                let previousSample = 0;
                
                for (let i = 0; i < buffer.length; i++) {
                    const diff = buffer[i] - previousSample;
                    enhanced[i] = buffer[i] + diff * 0.5; // Emphasize changes
                    previousSample = buffer[i];
                }
                
                return enhanced;
            }
            
            makeEthereal(buffer) {
                const ethereal = new Float32Array(buffer.length);
                const delayTime = Math.floor(this.ctx.sampleRate * 0.1); // 100ms delay
                
                for (let i = 0; i < buffer.length; i++) {
                    ethereal[i] = buffer[i];
                    
                    if (i >= delayTime) {
                        ethereal[i] += buffer[i - delayTime] * 0.4;
                    }
                    if (i >= delayTime * 2) {
                        ethereal[i] += buffer[i - delayTime * 2] * 0.2;
                    }
                }
                
                return ethereal;
            }
            
            makeRhythmic(buffer) {
                const rhythmic = new Float32Array(buffer.length);
                const gateLength = Math.floor(this.ctx.sampleRate * 60 / this.tempo / 16);
                
                for (let i = 0; i < buffer.length; i++) {
                    const gatePosition = i % gateLength;
                    const gateOpen = gatePosition < gateLength * 0.5;
                    rhythmic[i] = gateOpen ? buffer[i] : buffer[i] * 0.1;
                }
                
                return rhythmic;
            }
            
            pitchShift(buffer, ratio) {
                const shifted = new Float32Array(buffer.length);
                
                for (let i = 0; i < buffer.length; i++) {
                    const sourceIndex = i * ratio;
                    const index0 = Math.floor(sourceIndex);
                    const index1 = Math.min(index0 + 1, buffer.length - 1);
                    const fraction = sourceIndex - index0;
                    
                    if (index0 < buffer.length) {
                        shifted[i] = buffer[index0] * (1 - fraction) + buffer[index1] * fraction;
                    }
                }
                
                return shifted;
            }
            
            granularize(buffer) {
                const granular = new Float32Array(buffer.length);
                const grainSize = Math.floor(this.ctx.sampleRate * 0.05); // 50ms grains
                
                for (let i = 0; i < buffer.length; i += grainSize) {
                    const grainStart = Math.floor(Math.random() * (buffer.length - grainSize));
                    
                    for (let j = 0; j < grainSize && i + j < buffer.length; j++) {
                        const window = 0.5 - 0.5 * Math.cos(2 * Math.PI * j / grainSize); // Hann window
                        granular[i + j] = buffer[grainStart + j] * window;
                    }
                }
                
                return granular;
            }
            
            reverse(buffer) {
                return buffer.slice().reverse();
            }
            
            bitCrush(buffer, bits) {
                const crushed = new Float32Array(buffer.length);
                const levels = Math.pow(2, bits);
                
                for (let i = 0; i < buffer.length; i++) {
                    crushed[i] = Math.round(buffer[i] * levels) / levels;
                }
                
                return crushed;
            }
            
            generatePattern(analysis) {
                const pattern = new Array(16).fill(0);
                
                if (analysis.emotion === 'percussive') {
                    // Drum-like pattern
                    pattern[0] = 1;
                    pattern[4] = 0.8;
                    pattern[8] = 1;
                    pattern[12] = 0.6;
                    
                    // Add some variation
                    for (let i = 0; i < 16; i++) {
                        if (pattern[i] === 0 && Math.random() < 0.2) {
                            pattern[i] = 0.3 + Math.random() * 0.3;
                        }
                    }
                } else if (analysis.emotion === 'melodic') {
                    // Melodic pattern
                    for (let i = 0; i < 16; i++) {
                        if (i % 3 === 0 || i % 5 === 0) { // Fibonacci-influenced
                            pattern[i] = 0.5 + Math.random() * 0.5;
                        }
                    }
                } else {
                    // Ambient/textural - sparse
                    for (let i = 0; i < 16; i++) {
                        if (Math.random() < 0.2) {
                            pattern[i] = 0.3 + Math.random() * 0.4;
                        }
                    }
                }
                
                return pattern;
            }
            
            addLayer(transformed, analysis) {
                // Create audio buffer
                const audioBuffer = this.ctx.createBuffer(1, transformed.buffer.length, this.ctx.sampleRate);
                audioBuffer.getChannelData(0).set(transformed.buffer);
                
                const layer = {
                    id: Date.now(),
                    buffer: audioBuffer,
                    pattern: transformed.pattern,
                    emotion: transformed.emotion,
                    energy: transformed.energy,
                    volume: 0.5 + Math.random() * 0.3,
                    active: true,
                    age: 0
                };
                
                this.layers.push(layer);
                
                // Update visuals
                this.updateLayers();
                this.updateMemory();
                this.activateNeuron();
            }
            
            updateLayers() {
                const indicators = document.querySelectorAll('.layer');
                this.layers.forEach((layer, i) => {
                    if (indicators[i]) {
                        indicators[i].classList.add('alive');
                    }
                });
            }
            
            updateMemory() {
                const flow = document.getElementById('memoryFlow');
                flow.style.width = `${Math.min(100, this.layers.length * 20)}%`;
            }
            
            activateNeuron() {
                const neurons = document.querySelectorAll('.neuron');
                const index = Math.floor(Math.random() * neurons.length);
                
                neurons[index].classList.add('active');
                setTimeout(() => neurons[index].classList.remove('active'), 1000);
            }
            
            evolveComposition() {
                if (this.layers.length === 0) return;
                
                const evolution = Math.random();
                
                if (evolution < 0.3 && this.layers.length > 1) {
                    // Remove oldest layer
                    this.layers.shift();
                    this.think("shedding old patterns", "making space for new");
                } else if (evolution < 0.6) {
                    // Mutate a pattern
                    const layer = this.layers[Math.floor(Math.random() * this.layers.length)];
                    for (let i = 0; i < 16; i++) {
                        if (Math.random() < 0.1) {
                            layer.pattern[i] = Math.random();
                        }
                    }
                    this.think("patterns shifting", layer.emotion);
                } else {
                    // Tempo drift
                    this.tempo = Math.max(80, Math.min(160, this.tempo + (Math.random() - 0.5) * 5));
                    this.updateHeartbeat();
                    this.think("time bending", `${Math.round(this.tempo)} bpm`);
                }
                
                this.evolution++;
            }
            
            startScheduler() {
                this.nextNoteTime = this.ctx.currentTime;
                this.isScheduling = true;
                
                const schedule = () => {
                    if (!this.isScheduling) return;
                    
                    while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
                        this.scheduleNote(this.currentStep, this.nextNoteTime);
                        
                        const secondsPerBeat = 60.0 / this.tempo / 4;
                        this.nextNoteTime += secondsPerBeat;
                        this.currentStep = (this.currentStep + 1) % 16;
                    }
                    
                    setTimeout(schedule, this.lookahead);
                };
                
                schedule();
            }
            
            scheduleNote(step, time) {
                this.layers.forEach(layer => {
                    if (layer.active && layer.pattern[step] > 0) {
                        const source = this.ctx.createBufferSource();
                        source.buffer = layer.buffer;
                        
                        const gain = this.ctx.createGain();
                        gain.gain.value = layer.volume * layer.pattern[step] * 0.5;
                        
                        // Add slight randomization for organic feel
                        source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.01;
                        
                        source.connect(gain);
                        gain.connect(this.master);
                        
                        // Send a bit to reverb
                        if (layer.emotion === 'ambient' || layer.emotion === 'ethereal') {
                            gain.connect(this.reverb);
                        }
                        
                        source.start(time);
                        
                        // Increment age
                        layer.age++;
                    }
                });
                
                // Visual pulse on downbeat
                if (step === 0) {
                    setTimeout(() => this.pulseHeartbeat(), (time - this.ctx.currentTime) * 1000);
                }
            }
            
            breathingLoop() {
                const breathe = () => {
                    if (!this.alive) return;
                    
                    // Update energy core size based on consciousness
                    const core = document.querySelector('.energy-core');
                    const scale = 1 + this.consciousness.awareness * 0.2;
                    core.style.transform = `scale(${scale})`;
                    
                    requestAnimationFrame(breathe);
                };
                
                breathe();
            }
            
            think(primary, sub = '') {
                document.getElementById('primaryThought').textContent = primary;
                document.getElementById('subThought').textContent = sub;
                
                // Retrigger animation
                const thought = document.getElementById('primaryThought');
                thought.style.animation = 'none';
                setTimeout(() => thought.style.animation = 'thought-emerge 2s ease-out', 10);
            }
            
            updateHeartbeat() {
                document.getElementById('heartbeat').textContent = Math.round(this.tempo);
            }
            
            pulseHeartbeat() {
                const heartbeat = document.getElementById('heartbeat');
                heartbeat.classList.add('pulse');
                setTimeout(() => heartbeat.classList.remove('pulse'), 377);
            }
            
            pulseEnergy() {
                const rings = ['energyRing1', 'energyRing2', 'energyRing3'];
                rings.forEach((id, i) => {
                    setTimeout(() => {
                        const ring = document.getElementById(id);
                        ring.classList.add('pulse');
                        setTimeout(() => ring.classList.remove('pulse'), 1500);
                    }, i * 100);
                });
            }
        }
        
        // Birth the intelligence
        const gump = new LivingMusicIntelligence();
    </script>
</body>
</html>
