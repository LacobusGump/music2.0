<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GUMP ∴ Grand Unified Music Project</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<style>
  :root {
    --φ: 1.6180339887498948482; /* Golden ratio */
    --φ2: 2.6180339887498948482;
  }
  * { margin:0; padding:0; box-sizing:border-box; }
  html,body { height:100%; overflow:hidden; touch-action:none; background:#000; color:#fff; font-family:'Courier New',monospace; }
  body { display:grid; place-items:center; }
  canvas { position:absolute; inset:0; }

  #ui {
    position:fixed; inset:0; pointer-events:none; z-index:10;
    display:grid; grid-template-columns:1fr 1fr 1fr; grid-template-rows:1fr 1fr 1fr;
    font-size:clamp(10px,2vw,14px); letter-spacing:1px;
  }
  .corner {
    padding:12px; opacity:0.7;
    backdrop-filter:blur(8px);
  }
  .tl { grid-area:1/1; text-align:left; }
  .tr { grid-area:1/3; text-align:right; }
  .bl { grid-area:3/1; text-align:left; }
  .br { grid-area:3/3; text-align:right; color:#0f8; }

  #start {
    position:fixed; inset:0; display:grid; place-items:center; background:rgba(0,0,0,0.9); z-index:100;
    backdrop-filter:blur(20px);
  }
  #startBtn {
    width:33vh; height:33vh; border-radius:50%;
    background:radial-gradient(circle at 38% 38%, #fff2, transparent 50%);
    border:1px solid #fff4; box-shadow:0 0 80px #fff4;
    display:grid; place-items:center; font-size:5vh; font-weight:900;
    animation:pulse 4s infinite ease-in-out;
    text-shadow:0 0 30px #fff;
  }
  @keyframes pulse { 0%,100%{transform:scale(1)} 50%{transform:scale(1.13)} }

  .bar { height:4px; background:#fff2; border-radius:2px; overflow:hidden; margin:4px 0; }
  .fill { height:100%; background:linear-gradient(90deg,#0ff,#f0f,#ff0); width:0%; transition:width .2s; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="ui">
  <div class="corner tl">
    <div>GUMP ∴ <span id="stage">AWAITING SIGNAL</span></div>
    <div>BPM <span id="bpm">—</span> | KEY <span id="key">—</span></div>
  </div>
  <div class="corner tr">
    <div>LAYERS <span id="layers">0</span></div>
    <div>ENTROPY <div class="bar"><div class="fill" id="entropy"></div></div></div>
  </div>
  <div class="corner bl">
    <div>GESTURE <span id="gesture">—</span></div>
    <div>ENERGY <div class="bar"><div class="fill" id="energy"></div></div></div>
  </div>
  <div class="corner br" id="br">∴ FIBONACCI RESONANCE ACTIVE</div>
</div>

<div id="start"><div id="startBtn">TOUCH<br>THE<br>VOID</div></div>

<script>
// █████████████████████████████████████████████████████████████
//   GUMP — Grand Unified Music Project (Alien Breakthrough Edition)
//   Single-file, zero-dependency, golden-ratio everything, 2025
// █████████████████████████████████████████████████████████████

const φ = 1.6180339887498948482;
const τ = Math.PI * 2;
let ctx, W, H, t = 0;
let audio, master, analyser, data;
let orb = {x:0.5, y:0.5, vx:0, vy:0};
let motion = 0, energy = 0, entropy = 0;
let bpm = 89; // Fibonacci number
let keyRoot = 220 * Math.pow(2, 3/12); // A = 220Hz Just Intonation base
let scale = [0,2,4,7,9]; // Pentatonic → infinite golden
let voices = [];
let activeGestures = new Map();
let trail = [];

const stages = ["AWAITING SIGNAL","FIBONACCI AWAKENING","GOLDEN RESONANCE","CHAOS ATTRACTOR","SHEPARD ASCENT","PLANETARY RESONANCE","ETERNAL FLOW"];
let stage = 0;

async function init() {
  document.getElementById('start').onclick = start;
}
function start() {
  document.getElementById('start').remove();
  audio = new (window.AudioContext||webkitAudioContext)();
  master = audio.createGain();
  master.gain.value = 0.7;
  analyser = audio.createAnalyser();
  analyser.fftSize = 2048;
  data = new Uint8Array(analyser.frequencyBinCount);
  master.connect(analyser).connect(audio.destination);

  // HRTF spatialisation
  const listener = audio.listener;
  if (listener.forwardX) {
    listener.forwardX.value = 0; listener.forwardY.value = 0; listener.forwardZ.value = -1;
    listener.upX.value = 0; listener.upY.value = 1; listener.upZ.value = 0;
  }

  canvas = document.getElementById('c');
  ctx = canvas.getContext('2d');
  resize();
  window.onresize = resize;

  requestPermissionAndGo();
}

async function requestPermissionAndGo() {
  if (DeviceMotionEvent?.requestPermission) await DeviceMotionEvent.requestPermission();
  if (DeviceOrientationEvent?.requestPermission) await DeviceOrientationEvent.requestPermission();
  audio.resume();
  loop();
  motionLoop();
}

function resize() {
  W = canvas.width = innerWidth * devicePixelRatio;
  H = canvas.height = innerHeight * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
}

function note(n, oct=4) {
  return keyRoot * Math.pow(2, oct-4) * Math.pow(2, scale[n%scale.length]/12);
}

// Golden-ratio tuned Shepard–Risset glissando (infinite staircase)
class Shepard {
  constructor() {
    this.oscs = [];
    for (let i=0;i<12;i++) {
      let o = audio.createOscillator();
      let g = audio.createGain();
      o.type = 'sine';
      o.frequency.value = note(0, 2 + i);
      g.gain.value = 0;
      o.connect(g).connect(master);
      o.start();
      this.oscs.push({o,g});
    }
    this.pos = 0;
  }
  update(energy) {
    this.pos = (this.pos + energy*0.0003) % 1;
    this.oscs.forEach((v,i)=>{
      let phase = (i/12 + this.pos) % 1;
      let dist = Math.min(phase, 1-phase)*2;
      v.gain.gain.value = Math.sin(dist*Math.PI) * 0.15 * energy;
      v.o.frequency.value = note(0, 2 + i + Math.floor(this.pos+10));
    });
  }
}
let shepard = new Shepard();

// Voice with golden decay (1/φ^n envelope)
class Voice {
  constructor(freq, pan=0) {
    this.o = audio.createOscillator();
    this.g = audio.createGain();
    this.p = audio.createPanner();
    this.p.panningModel = 'HRTF';
    this.p.setPosition(pan, 0, 1-Math.abs(pan));
    this.o.frequency.value = freq;
    this.o.connect(this.g).connect(this.p).connect(master);
    this.o.start();
    this.g.gain.setValueAtTime(0.001, audio.currentTime);
    this.g.gain.exponentialRampToValueAtTime(0.8, audio.currentTime+0.02);
    this.g.gain.exponentialRampToValue(0.001, audio.currentTime + 0.02/φ/φ);
    voices.push(this);
    setTimeout(()=>this.kill(), 8000/φ); // golden decay
  }
  kill() {
    if (this.o) this.o.stop();
    voices = voices.filter(v=>v!==this);
  }
}

// Fractal gesture detection using golden-angle polar mapping
let history = [];
let lastPos = null;
function handleMotion(e) {
  let a = e.accelerationIncludingGravity;
  if (!a) return;
  let acc = Math.hypot(a.x, a.y, a.z)-9.81;
  motion = motion*0.9 + Math.abs(acc)*0.1;
  history.push(acc);
  if (history.length>144) history.shift(); // Fibonacci frame window

  // Detect golden spiral (137.5° golden angle)
  if (e.rotationRate) {
    let angle = (e.rotationRate.alpha + e.rotationRate.beta + e.rotationRate.gamma) * 0.017; // deg→rad approx
    if (Math.abs(angle % (Math.PI*2 * 0.618)) < 0.2 && motion>2) {
      stage = Math.max(stage, 3);
      bpm *= φ;
      document.getElementById('br').textContent = "GOLDEN SPIRAL DETECTED";
    }
  }

  energy = motion * φ;
  entropy = history.reduce((s,v,i,a)=>s+Math.abs(v-a[(i+13)%a.length]),0)/history.length;
  document.getElementById('energy').style.width = (motion*8).toFixed(1)+'%';
  document.getElementById('entropy').style.width = (entropy*5).toFixed(1)+'%';
}

// Orientation → spatialisation
window.addEventListener('deviceorientation', e=>{
  if (!e.gamma) return;
  let tiltX = e.gamma/90; // -1..1 left-right
  orb.vx += tiltX * 0.003;
  orb.vy += (e.beta/90) * 0.003;
});

function motionLoop() {
  window.addEventListener('devicemotion', handleMotion);
  // Fallback mouse/touch trail
  canvas.onpointermove = e=>{
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX/innerWidth, y = e.clientY/innerHeight;
    orb.vx += (x-orb.x)*0.02;
    orb.vy += (y-orb.y)*0.02;
    trail.push({x:e.clientX,y:e.clientY});
    if (trail.length>89) trail.shift();
  };
  requestAnimationFrame(frame);
}

function spawnVoice() {
  let n = Math.floor(t * φ) % scale.length;
  let oct = 2 + Math.floor(t/8);
  let freq = note(n, oct);
  let pan = Math.sin(t * φ) * 0.8;
  new Voice(freq, pan);
  // Golden chord bursts on Fibonacci beats
  if (Math.floor(t*φ)%13===0) {
    [0,2,4,7,9].forEach(i=> new Voice(note(i, oct), Math.sin(i)*0.7));
  }
}

let lastBeat = 0;
function frame() {
  t += 0.016;

  // BPM from motion using Fibonacci averaging
  if (motion>2 && performance.now()-lastBeat>300) {
    bpm = performance.now();
    let interval = now - lastBeat;
    bpm = bpm*0.9 + (60000/interval)*0.1;
  }

  // Stage evolution
  let totalEnergy = voices.length + motion*10;
  stage = Math.min(stages.length-1, Math.floor(totalEnergy/34)); // 34 = Fibonacci
  document.getElementById('stage').textContent = stages[stage];
  document.getElementById('bpm').textContent = bpm.toFixed(0);
  document.getElementById('layers').textContent = voices.length;
  document.getElementById('key').textContent = ['A','B♭','B','C','D♭','D','E♭','E','F','G♭','G','A♭'][Math.floor(t*φ)%12] + " PENTATONIC";

  // Spawn voices on golden beats
  if (Math.floor(t * φ * φ) % 21 === 0) spawnVoice();

  // Shepard infinite rise
  shepard.update(energy);

  // Orb physics with golden damping
  orb.x += orb.vx;
  orb.y += orb.vy;
  orb.vx *= 0.92; // 1/φ² ≈ 0.382 damping → 0.92 complement
  orb.vy *= 0.92;
  orb.x = Math.max(0.1, Math.min(0.9, orb.x));
  orb.y = Math.max(0.1, Math.min(0.9, orb.y));

  // Rendering — pure golden-ratio fractal beauty
  ctx.fillStyle = 'rgba(0,0,0,0.07)';
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // Golden spiral trail
  trail.forEach((p,i)=>{
    let alpha = i/trail.length;
    ctx.fillStyle = `hsla(${t*30+i*10},100%,60%,${alpha})`;
    let r = alpha * 30 * φ;
    ctx.fillRect(p.x-r/2, p.y-r/2, r, r);
  });

  // Central orb — breathes with energy
  let pulse = 1 + Math.sin(t*3)*energy*0.1;
  let hue = t*20 % 360;
  ctx.fillStyle = `hsla(${hue},100%,60%,0.8)`;
  let orbPx = orb.x * innerWidth;
  let orbPy = orb.y * innerHeight;
  ctx.beginPath();
  for (let i=0;i<144;i++) {
    let a = i * Math.PI * 2 / 144 * φ; // golden angle
    let r = (i/144) * 100 * pulse * φ;
    ctx.lineTo(orbPx + Math.cos(a)*r, orbPy + Math.sin(a)*r);
  }
  ctx.fill();

  // Frequency visualiser at bottom
  analyser.getByteFrequencyData(data);
  let bw = innerWidth / data.length * 8;
  for (let i=0;i<data.length/8;i++) {
    let h = data[i]*0.8;
    ctx.fillStyle = `hsla(${i*360/data.length + t*50},100%,60%,0.8)`;
    ctx.fillRect(i*bw, innerHeight-h, bw-2, h);
  }

  requestAnimationFrame(frame);
}

init();
</script>
</body>
</html>
