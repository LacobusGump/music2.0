<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>BYTROPIX // WORLD SAMPLER</title>
<style>
  :root {
    --bg: #050505;
    --text: #a0a0a0;
    --accent: #ff3300;
    --grid: #1a1a1a;
  }
  
  * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; user-select: none; }
  
  body {
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    font-family: 'Courier New', monospace;
    height: 100vh;
    width: 100vw;
    position: fixed;
    display: flex;
    flex-direction: column;
  }

  /* CRT Scanline Effect */
  body::after {
    content: " ";
    display: block;
    position: absolute;
    top: 0; left: 0; bottom: 0; right: 0;
    background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
    z-index: 1000;
    background-size: 100% 2px, 3px 100%;
    pointer-events: none;
  }

  .start-screen {
    position: absolute;
    inset: 0;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg);
    z-index: 2000;
    transition: opacity 0.8s ease-in-out;
  }
  
  .start-screen.hidden { opacity: 0; pointer-events: none; }
  
  .glitch-title {
    font-size: 24px;
    letter-spacing: 6px;
    margin-bottom: 30px;
    text-shadow: 2px 0 var(--accent);
    animation: glitch 3s infinite alternate;
  }
  
  @keyframes glitch {
    0% { transform: skew(0deg); }
    20% { transform: skew(-2deg); }
    21% { transform: skew(2deg); }
    22% { transform: skew(0deg); }
    100% { transform: skew(0deg); }
  }

  .btn {
    padding: 15px 40px;
    border: 1px solid var(--text);
    background: transparent;
    color: var(--text);
    font-family: inherit;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.2s;
    letter-spacing: 2px;
  }
  
  .btn:active { background: var(--text); color: var(--bg); }

  .hud {
    position: absolute;
    padding: 20px;
    width: 100%;
    pointer-events: none;
    z-index: 10;
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    opacity: 0;
    transition: opacity 1s;
  }
  
  .hud.active { opacity: 1; }
  
  .data-col { display: flex; flex-direction: column; gap: 5px; }
  .label { color: #555; margin-right: 5px; }
  .val { color: var(--accent); }

  #visualizer {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    z-index: 1;
  }

  .mode-indicator {
    position: absolute;
    bottom: 30px;
    width: 100%;
    text-align: center;
    font-size: 12px;
    letter-spacing: 3px;
    opacity: 0;
    transition: opacity 1s;
    z-index: 10;
  }

  .status-dot {
    display: inline-block;
    width: 8px;
    height: 8px;
    background: #333;
    border-radius: 50%;
    margin-right: 10px;
  }
  
  .status-dot.rec { background: var(--accent); box-shadow: 0 0 10px var(--accent); animation: pulse 1s infinite; }
  
  @keyframes pulse { 0% { opacity: 1; } 50% { opacity: 0.3; } 100% { opacity: 1; } }

</style>
</head>
<body>

<div class="start-screen" id="startScreen">
  <div class="glitch-title">HYPER//SAMPLER</div>
  <button class="btn" id="startBtn">INITIALIZE</button>
</div>

<div class="hud" id="hud">
  <div class="data-col">
    <div><span class="label">ENTROPY</span><span class="val" id="entropyVal">0.00</span></div>
    <div><span class="label">FLUX</span><span class="val" id="fluxVal">0.00</span></div>
    <div><span class="label">GRAINS</span><span class="val" id="grainVal">0</span></div>
  </div>
  <div class="data-col" style="text-align: right;">
    <div><span class="status-dot" id="recDot"></span><span id="stateText">IDLE</span></div>
    <div><span class="label">MEM</span><span class="val" id="memVal">0%</span></div>
  </div>
</div>

<canvas id="visualizer"></canvas>

<div class="mode-indicator" id="modeInfo">
  MOVE TO REORGANIZE
</div>

<script>
'use strict';

// --- MATH UTILS (Inspired by Bytropix) ---
const tanh = Math.tanh;
const PI = Math.PI;
const clamp = (v, min, max) => Math.min(Math.max(v, min), max);
const lerp = (a, b, t) => a + (b - a) * t;

// --- AUDIO ENGINE ---
class HyperSampler {
  constructor() {
    this.ctx = null;
    this.master = null;
    this.compressor = null;
    
    // State
    this.isActive = false;
    this.isRecording = false;
    this.buffer = []; // Raw float arrays
    this.slices = []; // Identified "events" in audio
    
    // Motion Data
    this.tiltX = 0; // Controls Grain Size / Density
    this.tiltY = 0; // Controls Pitch / Hyperbolic folding
    this.motionEnergy = 0; // Controls trigger probability
    
    // Config
    this.maxRecordingTime = 4; // Seconds of memory
    this.recStartTime = 0;
    
    // Visuals
    this.canvas = document.getElementById('visualizer');
    this.drawCtx = this.canvas.getContext('2d');
    this.analyser = null;
    this.visData = null;
    
    this.setupEvents();
  }

  async init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    await this.ctx.resume();
    
    // Master Chain
    this.compressor = this.ctx.createDynamicsCompressor();
    this.compressor.threshold.value = -10;
    this.compressor.ratio.value = 12;
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.9;
    
    this.compressor.connect(this.master);
    this.master.connect(this.ctx.destination);
    
    // Input
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    this.input = this.ctx.createMediaStreamSource(stream);
    
    // Analyzer
    this.analyser = this.ctx.createAnalyser();
    this.analyser.fftSize = 2048;
    this.visData = new Uint8Array(this.analyser.frequencyBinCount);
    this.master.connect(this.analyser); // Visualize Output
    
    // Recorder Node (ScriptProcessor for simplicity in single file)
    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
    this.input.connect(this.recorder);
    this.recorder.connect(this.ctx.destination); // Keep chain alive
    
    this.recorder.onaudioprocess = (e) => {
      if (!this.isRecording) return;
      const data = e.inputBuffer.getChannelData(0);
      this.buffer.push(new Float32Array(data));
      
      // Auto-stop
      if (Date.now() - this.recStartTime > this.maxRecordingTime * 1000) {
        this.stopRecording();
      }
    };

    // UI Updates
    document.getElementById('startScreen').classList.add('hidden');
    document.getElementById('hud').classList.add('active');
    document.getElementById('modeInfo').style.opacity = 1;
    
    this.isActive = true;
    this.loop();
    this.startClock();
    
    // Initial auto-record to get buffer
    setTimeout(() => this.startRecording(), 1000);
  }

  setupEvents() {
    window.addEventListener('resize', () => this.resize());
    this.resize();
    
    // Motion Permissions
    document.getElementById('startBtn').addEventListener('click', async () => {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        await DeviceOrientationEvent.requestPermission();
      }
      this.init();
    });

    window.addEventListener('deviceorientation', (e) => {
      // Normalize -90 to 90 into -1 to 1
      this.tiltX = clamp(e.gamma / 45, -1, 1); 
      this.tiltY = clamp(e.beta / 45, -1, 1);
      
      document.getElementById('fluxVal').innerText = this.tiltY.toFixed(2);
      document.getElementById('entropyVal').innerText = this.tiltX.toFixed(2);
    });
    
    window.addEventListener('devicemotion', (e) => {
       const acc = e.acceleration;
       if(acc) {
         const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
         this.motionEnergy = this.motionEnergy * 0.9 + mag * 0.1;
         
         // Trigger record on sudden hard shake
         if (this.motionEnergy > 25 && !this.isRecording) {
           this.startRecording();
         }
       }
    });
    
    // Touch to force record
    document.addEventListener('touchstart', () => {
      if(this.isActive && !this.isRecording) this.startRecording();
    });
    document.addEventListener('touchend', () => {
      if(this.isRecording) this.stopRecording();
    });
  }

  startRecording() {
    this.isRecording = true;
    this.buffer = [];
    this.slices = [];
    this.recStartTime = Date.now();
    document.getElementById('recDot').classList.add('rec');
    document.getElementById('stateText').innerText = "SAMPLING REALITY";
  }

  stopRecording() {
    this.isRecording = false;
    document.getElementById('recDot').classList.remove('rec');
    document.getElementById('stateText').innerText = "PROCESSING";
    this.analyzeBuffer();
  }

  // --- THE "INNERMOST" LOGIC: Find music in noise ---
  analyzeBuffer() {
    if (this.buffer.length === 0) return;
    
    // Flatten buffer
    const len = this.buffer.length * 4096;
    const fullBuffer = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
    const data = fullBuffer.getChannelData(0);
    let offset = 0;
    for(let chunk of this.buffer) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    
    this.activeBuffer = fullBuffer;
    
    // Transient Detection (Simple)
    this.slices = [];
    const threshold = 0.05;
    let silence = true;
    
    for(let i=0; i < len; i+=256) {
       const amp = Math.abs(data[i]);
       if (amp > threshold && silence) {
         this.slices.push(i / this.ctx.sampleRate); // Store start time in seconds
         silence = false;
       } else if (amp < threshold * 0.5) {
         silence = true;
       }
    }
    
    // Fallback if no transients found (just divide evenly)
    if (this.slices.length === 0) {
      for(let i=0; i<8; i++) this.slices.push((fullBuffer.duration / 8) * i);
    }
    
    document.getElementById('memVal').innerText = this.slices.length + " SEEDS";
    document.getElementById('stateText').innerText = "REORGANIZING";
  }

  // --- THE "BYTROPIX" ENGINE: Hyperbolic Sequencing ---
  startClock() {
    // A recursive scheduler that bends time based on motion
    const schedule = () => {
      if (this.activeBuffer && this.slices.length > 0) {
        
        // Probability of playing based on entropy (Tilt X)
        // 0 = sparse, 1 = chaotic/full
        const entropy = Math.abs(this.tiltX); 
        const density = lerp(0.2, 1.0, entropy); 
        
        if (Math.random() < density) {
          this.playGrain();
        }
      }
      
      // Calculate next tick. 
      // Tilt Y affects speed (Hyperbolic curve)
      // High tilt = extremely fast (granular), Low tilt = slow (ambient)
      const speed = Math.abs(this.tiltY); 
      // Using tanh to curve the tempo response
      const nextTime = lerp(200, 40, tanh(speed * 3)); 
      
      setTimeout(schedule, nextTime);
    };
    schedule();
  }

  playGrain() {
    const src = this.ctx.createBufferSource();
    src.buffer = this.activeBuffer;
    
    // Select a slice based on "World" reorganization
    // We don't pick random; we pick based on a cursor that moves through time
    const sliceIndex = Math.floor(Math.random() * this.slices.length);
    const startTime = this.slices[sliceIndex];
    
    // Grain Duration
    const duration = lerp(0.1, 0.5, 1 - Math.abs(this.tiltX));
    
    // Pitch Logic (Hyperbolic Math)
    // We quantify pitch to octaves or fifths based on tilt
    const baseRate = 1.0;
    const shift = Math.floor(this.tiltY * 4); // -4 to +4
    // 2^(n/12) for semitones, but lets do octaves/fifths for Bytropix feel
    // 1.5 is a fifth, 2.0 is an octave
    const harmonic = Math.pow(1.5, shift); 
    
    src.playbackRate.value = harmonic;
    
    // Enveloping to prevent clicks
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, this.ctx.currentTime);
    gain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
    
    src.connect(gain);
    gain.connect(this.master);
    
    src.start(this.ctx.currentTime, startTime, duration);
    
    // Trigger visual
    this.visualizeTrigger();
  }

  // --- VISUALS ---
  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }
  
  visualizeTrigger() {
    // Add a visual "grain" to the array (implemented simply below)
    document.getElementById('grainVal').innerText = (Math.random()*100).toFixed(0);
  }

  loop() {
    requestAnimationFrame(() => this.loop());
    
    this.drawCtx.fillStyle = 'rgba(5, 5, 5, 0.2)'; // Trails
    this.drawCtx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    if (!this.analyser) return;
    
    this.analyser.getByteTimeDomainData(this.visData);
    
    const cx = this.canvas.width / 2;
    const cy = this.canvas.height / 2;
    const radius = Math.min(cx, cy) * 0.4; // Base radius
    
    this.drawCtx.beginPath();
    this.drawCtx.strokeStyle = '#ff3300';
    this.drawCtx.lineWidth = 2;
    
    // Draw Radial Waveform (The "Nest")
    for (let i = 0; i < this.visData.length; i++) {
      const v = (this.visData[i] / 128.0) - 1; // -1 to 1
      
      // Angle
      const angle = (i / this.visData.length) * Math.PI * 2;
      
      // Radius modification based on audio amplitude + Tilt (Hyperbolic)
      // This makes the circle "breathe" and distort
      const r = radius + (v * 100) + (this.tiltX * 50 * Math.sin(i * 0.1));
      
      const x = cx + Math.cos(angle) * r;
      const y = cy + Math.sin(angle) * r;
      
      if (i === 0) this.drawCtx.moveTo(x, y);
      else this.drawCtx.lineTo(x, y);
    }
    
    this.drawCtx.closePath();
    this.drawCtx.stroke();
    
    // Draw Recording Indicator Ring
    if (this.isRecording) {
      this.drawCtx.beginPath();
      this.drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
      this.drawCtx.arc(cx, cy, radius * 1.5, 0, Math.PI*2);
      this.drawCtx.stroke();
    }
  }
}

const app = new HyperSampler();

</script>
</body>
</html>
