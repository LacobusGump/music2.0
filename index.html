<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP - Unified Motion Sampler</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: all 2s ease;
        }
        .start-screen {
            text-align: center;
            z-index: 100;
        }
        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border: 2px solid rgba(255,255,255,0.3);
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 4s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
            50% { transform: scale(1.05); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
        }
        .evolution-space {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }
        .evolution-space.active { opacity: 1; }
        .orb {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 40px rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 10;
        }
        .orb.pulse { animation: beat 0.15s ease-out; }
        @keyframes beat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,0,0,0.7);
        }
        .orb.processing {
            background: radial-gradient(circle, rgba(100,100,255,0.8) 0%, rgba(0,0,255,0.3) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(0,0,255,0.7);
        }
        .orb.void {
            background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(147,112,219,0.4);
            animation: voidBreathe 3s ease-in-out infinite;
        }
        @keyframes voidBreathe {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }
        .ui-corner {
            position: fixed;
            font-size: 11px;
            color: rgba(255,255,255,0.8);
            font-weight: normal;
            letter-spacing: 1px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
        }
        .ui-corner.top-left { top: 20px; left: 20px; }
        .ui-corner.bottom-left { bottom: 20px; left: 20px; }
        .ui-corner.top-right { top: 20px; right: 20px; }
        .stage-name {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
            margin-bottom: 8px;
            font-weight: bold;
        }
        .metric {
            margin: 3px 0;
            font-size: 10px;
        }
        .bar {
            width: 80px;
            height: 3px;
            background: rgba(255,255,255,0.2);
            margin: 3px 0;
            border-radius: 2px;
            overflow: hidden;
        }
        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #9b59b6);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }
        .sample-indicator {
            position: fixed;
            bottom: 30px;
            right: 30px;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .sample-indicator.visible { opacity: 1; }
        .instruction {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            text-align: center;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 2s ease;
            margin-top: 80px;
        }
        .instruction.show { opacity: 1; }
        .particles {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            animation: float 10s linear infinite;
        }
        @keyframes float {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(-20vh) scale(1.5); opacity: 0; }
        }
        .spectrum-viz {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            pointer-events: none;
            z-index: 3;
        }
        .spectrum-bar {
            position: absolute;
            bottom: 0;
            width: 6px;
            background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
            border-radius: 3px 3px 0 0;
            transition: height 0.1s ease;
        }
        .hidden { display: none !important; }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-btn" id="startBtn">AWAKEN</div>
    </div>
    <div class="evolution-space" id="evolutionSpace">
        <div class="orb" id="orb"></div>
        <div class="instruction" id="instruction">MOVE TO SAMPLE THE WORLD</div>
        <div class="ui-corner top-left">
            <div class="stage-name" id="stageName">SILENCE</div>
            <div class="metric">MODE: <span id="mode">WAITING</span></div>
            <div class="metric">SAMPLES: <span id="sampleCount">0</span></div>
        </div>
        <div class="ui-corner bottom-left">
            <div class="metric">MOTION ENERGY</div>
            <div class="bar"><div class="bar-fill" id="motionBar"></div></div>
            <div class="metric">EVOLUTION</div>
            <div class="bar"><div class="bar-fill" id="evolutionBar"></div></div>
        </div>
        <div class="ui-corner top-right">
            <div class="metric">BPM: <span id="bpmDisplay">75</span></div>
            <div class="metric">ACTIVE: <span id="activeDisplay">0</span></div>
        </div>
        <div class="spectrum-viz" id="spectrumViz"></div>
    </div>
    <div class="sample-indicator" id="sampleIndicator"></div>
    <script>
        'use strict';

        // Constants
        const SAMPLE_RATE = 44100;
        const PRE_BUFFER_SIZE = SAMPLE_RATE * 2;
        const MAX_SAMPLES = 6;
        const VOID_TIMEOUT = 8000;
        const SPECTRUM_BARS = 48;
        const MOTION_HISTORY_SIZE = 150;
        
        // Audio node pool for reuse
        const nodePool = {
            gains: [],
            filters: [],
            oscillators: []
        };

        // Optimized Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.active = false;
                this.nodes = {};
                this.elements = {};
                
                // Motion
                this.motion = 0;
                this.intensity = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = new Float32Array(MOTION_HISTORY_SIZE);
                this.motionIndex = 0;
                this.motionPattern = 'calm';
                this.lastMotionTime = Date.now();
                this.voidPhase = false;
                this.totalMotion = 0;
                
                // Sampling
                this.recording = false;
                this.preBuffer = new Float32Array(PRE_BUFFER_SIZE);
                this.preBufferIndex = 0;
                this.buffer = [];
                this.samples = new Map();
                this.activeSamples = new Map();
                this.sampleQueue = [];
                
                // Music
                this.bpm = 75;
                this.seq = { step: 0 };
                this.evolution = { complexity: 0, energy: 0.5 };
                this.basslineActive = false;
                
                // Visual
                this.analyser = null;
                this.dataArray = null;
                this.spectrumBars = [];
                this.stage = 'SILENCE';
                
                // Performance optimizations
                this.frameSkip = 0;
                this.lastUIUpdate = 0;
                
                this.init();
            }

            init() {
                // Cache DOM elements
                this.elements = {
                    startScreen: document.getElementById('startScreen'),
                    startBtn: document.getElementById('startBtn'),
                    evolutionSpace: document.getElementById('evolutionSpace'),
                    orb: document.getElementById('orb'),
                    instruction: document.getElementById('instruction'),
                    stageName: document.getElementById('stageName'),
                    mode: document.getElementById('mode'),
                    sampleCount: document.getElementById('sampleCount'),
                    motionBar: document.getElementById('motionBar'),
                    evolutionBar: document.getElementById('evolutionBar'),
                    bpmDisplay: document.getElementById('bpmDisplay'),
                    activeDisplay: document.getElementById('activeDisplay'),
                    spectrumViz: document.getElementById('spectrumViz'),
                    sampleIndicator: document.getElementById('sampleIndicator')
                };
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotion();
                this.setupSpectrum();
            }

            setupMotion() {
                // Device motion
                if ('DeviceMotionEvent' in window) {
                    window.addEventListener('devicemotion', this.handleMotion.bind(this), { passive: true });
                }
                
                // Mouse fallback
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    
                    const now = performance.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    const vx = (newX - lastMouse.x) / dt * 100;
                    const vy = (newY - lastMouse.y) / dt * 100;
                    const mouseMotion = Math.sqrt(vx * vx + vy * vy) * 0.15;
                    
                    this.updateMotion(mouseMotion);
                    this.pos.x = newX;
                    this.pos.y = newY;
                    
                    lastMouse = { x: newX, y: newY, time: now };
                }, { passive: true });
            }

            handleMotion(e) {
                if (!this.active) return;
                
                const acc = e.accelerationIncludingGravity;
                if (!acc || acc.x === null) return;
                
                const dx = acc.x - this.lastAccel.x;
                const dy = acc.y - this.lastAccel.y;
                const dz = acc.z - this.lastAccel.z;
                const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;
                
                this.updateMotion(newMotion);
                this.velocity.x += acc.x * 0.015;
                this.velocity.y += acc.y * 0.015;
                this.updatePosition();
                
                this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
            }

            updateMotion(newMotion) {
                this.motion = this.motion * 0.8 + newMotion * 0.2;
                this.motionHistory[this.motionIndex] = this.motion;
                this.motionIndex = (this.motionIndex + 1) % MOTION_HISTORY_SIZE;
                this.totalMotion += this.motion;
                
                if (this.motion > 0.5) {
                    this.lastMotionTime = Date.now();
                    if (this.voidPhase) this.exitVoid();
                }
                
                if (Date.now() - this.lastMotionTime > VOID_TIMEOUT && !this.voidPhase && this.active) {
                    this.enterVoid();
                }
                
                // Calculate patterns efficiently
                let sum = 0, peaks = 0;
                for (let i = 0; i < MOTION_HISTORY_SIZE; i++) {
                    sum += this.motionHistory[i];
                    if (this.motionHistory[i] > 2.5) peaks++;
                }
                
                const avg = sum / MOTION_HISTORY_SIZE;
                const variance = this.calculateVariance(avg);
                
                this.intensity = variance;
                this.motionPattern = this.detectPattern(avg, variance, peaks);
                this.updateEvolution(avg);
            }

            calculateVariance(avg) {
                let variance = 0;
                for (let i = 0; i < MOTION_HISTORY_SIZE; i++) {
                    variance += Math.abs(this.motionHistory[i] - avg);
                }
                return variance / MOTION_HISTORY_SIZE;
            }

            detectPattern(avg, variance, peaks) {
                if (variance > 4 && avg > 4) return 'chaotic';
                if (variance > 2.5 && avg > 2) return 'erratic';
                if (peaks > 20 && variance < 2) return 'rhythmic';
                if (avg > 2.5 && variance < 1.5) return 'sustained';
                return 'calm';
            }

            updateEvolution(avgMotion) {
                const target = Math.min(3, avgMotion / 2 + this.intensity / 3);
                this.evolution.complexity = this.evolution.complexity * 0.95 + target * 0.05;
                this.evolution.energy = 0.5 + Math.sin(Date.now() * 0.0001) * 0.3;
                
                let targetBPM = 75 + avgMotion * 5 + this.intensity * 3 + this.evolution.complexity * 10;
                if (this.motionPattern === 'rhythmic') targetBPM *= 1.1;
                if (this.motionPattern === 'chaotic') targetBPM *= 1.3;
                
                this.bpm = this.bpm * 0.9 + targetBPM * 0.1;
                this.bpm = Math.max(60, Math.min(140, this.bpm));
                
                // Update stage
                if (this.totalMotion < 100) this.stage = 'AWAKENING';
                else if (this.totalMotion < 300) this.stage = 'EXPLORING';
                else if (this.totalMotion < 600) this.stage = 'BUILDING';
                else if (this.totalMotion < 1000) this.stage = 'FLOWING';
                else this.stage = 'TRANSCENDENT';
            }

            updatePosition() {
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;
                
                if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
                if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
                
                this.pos.x = Math.max(5, Math.min(95, this.pos.x));
                this.pos.y = Math.max(5, Math.min(95, this.pos.y));
                
                this.velocity.x *= 0.9;
                this.velocity.y *= 0.9;
            }

            enterVoid() {
                this.voidPhase = true;
                this.elements.orb.className = 'orb void';
                this.elements.mode.textContent = 'VOID';
                
                // Stop all samples
                this.activeSamples.forEach(src => {
                    try { src.stop(); } catch (e) {}
                });
                this.activeSamples.clear();
                this.sampleQueue = [];
                this.samples.get('sample').length = 0;
                
                this.playVoidAmbience();
            }

            exitVoid() {
                this.voidPhase = false;
                this.elements.orb.className = 'orb';
                this.elements.mode.textContent = 'ACTIVE';
                this.evolution.complexity = 0;
            }

            playVoidAmbience() {
                const duration = 10;
                const baseFreq = 110;
                
                for (let i = 0; i < 3; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * Math.pow(2, i / 4);
                    
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 3);
                    gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);
                    
                    osc.connect(gain).connect(this.ctx.destination);
                    osc.start();
                    osc.stop(this.ctx.currentTime + duration);
                }
            }

            setupSpectrum() {
                const viz = this.elements.spectrumViz;
                const fragment = document.createDocumentFragment();
                
                for (let i = 0; i < SPECTRUM_BARS; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'spectrum-bar';
                    bar.style.left = `${i * (100 / SPECTRUM_BARS)}%`;
                    fragment.appendChild(bar);
                    this.spectrumBars.push(bar);
                }
                
                viz.appendChild(fragment);
            }

            async start() {
                try {
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({ 
                        sampleRate: SAMPLE_RATE, 
                        latencyHint: 'interactive' 
                    });
                    
                    this.setupAudio();
                    await this.setupMic();
                    this.createDrums();
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    setTimeout(() => {
                        this.elements.instruction.classList.add('show');
                        setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
                    }, 1000);

                    this.active = true;
                    this.startSequencer();
                    this.startAutoSampler();
                    requestAnimationFrame(this.animate.bind(this));
                    
                    document.onkeydown = e => {
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.toggleRecording();
                        }
                    };
                } catch (e) {
                    console.error('Init error:', e);
                    alert('Failed to initialize. Please try again.');
                }
            }

            setupAudio() {
                // Analysis
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 128;
                this.analyser.smoothingTimeConstant = 0.8;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                
                // Master chain
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.8;
                
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -3;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.01;
                
                this.nodes.warmth = this.ctx.createBiquadFilter();
                this.nodes.warmth.type = 'lowshelf';
                this.nodes.warmth.frequency.value = 200;
                this.nodes.warmth.gain.value = 3;
                
                // Reverb
                this.nodes.reverb = this.ctx.createConvolver();
                this.nodes.reverb.buffer = this.createReverbIR();
                this.nodes.reverbSend = this.ctx.createGain();
                this.nodes.reverbSend.gain.value = 0.3;
                
                // Layers
                ['kick', 'bass', 'hat', 'sample', 'vinyl', 'bassline'].forEach(name => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = { kick: 0.9, bass: 0.8, hat: 0.3, sample: 0.6, vinyl: 0.1, bassline: 0.7 }[name];
                    this.nodes[name].connect(this.nodes.master);
                    this.samples.set(name, []);
                });
                
                // Connect
                this.nodes.master.connect(this.nodes.warmth);
                this.nodes.warmth.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                this.nodes.reverbSend.connect(this.nodes.reverb);
                this.nodes.reverb.connect(this.nodes.limiter);
            }

            createReverbIR() {
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const data = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                return impulse;
            }

            async setupMic() {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                this.nodes.preRec = this.ctx.createScriptProcessor(2048, 1, 1);
                
                this.nodes.preRec.onaudioprocess = e => {
                    const input = e.inputBuffer.getChannelData(0);
                    
                    // Rolling buffer
                    for (let i = 0; i < input.length; i++) {
                        this.preBuffer[this.preBufferIndex] = input[i];
                        this.preBufferIndex = (this.preBufferIndex + 1) % PRE_BUFFER_SIZE;
                    }
                    
                    if (this.recording) {
                        this.buffer.push(...input);
                        if (this.buffer.length > this.ctx.sampleRate * 4) {
                            this.stopRecording();
                        }
                    }
                };
                
                this.nodes.mic.connect(this.nodes.preRec);
                this.nodes.preRec.connect(this.ctx.destination);
            }

            createDrums() {
                const sr = this.ctx.sampleRate;
                
                // Kick
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.pow(1 - t * 2, 3);
                    const pitch = 55 * Math.exp(-35 * t);
                    kd[i] = Math.sin(2 * Math.PI * pitch * t) * env;
                }
                
                // Hat
                const hat = this.ctx.createBuffer(1, sr * 0.03, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    hd[i] = (Math.random() * 2 - 1) * Math.exp(-200 * i / sr);
                }
                
                // Vinyl
                const vinyl = this.ctx.createBuffer(2, sr * 10, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const vd = vinyl.getChannelData(ch);
                    for (let i = 0; i < vd.length; i++) {
                        vd[i] = (Math.random() - 0.5) * 0.02;
                        if (Math.random() < 0.0001) vd[i] = (Math.random() - 0.5) * 0.2;
                    }
                }
                
                this.samples.get('kick').push({ buffer: kick });
                this.samples.get('hat').push({ buffer: hat });
                
                // Start vinyl
                const vinylSrc = this.ctx.createBufferSource();
                vinylSrc.buffer = vinyl;
                vinylSrc.loop = true;
                vinylSrc.connect(this.nodes.vinyl);
                vinylSrc.start();
            }

            toggleRecording() {
                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                this.buffer = [];
                
                // Include pre-buffer
                const preCapture = this.ctx.sampleRate * 0.5;
                const startIdx = (this.preBufferIndex - preCapture + PRE_BUFFER_SIZE) % PRE_BUFFER_SIZE;
                
                for (let i = 0; i < preCapture; i++) {
                    const idx = (startIdx + i) % PRE_BUFFER_SIZE;
                    this.buffer.push(this.preBuffer[idx]);
                }
                
                this.recording = true;
                this.elements.orb.classList.add('recording');
                this.showIndicator('RECORDING...');
            }

            stopRecording() {
                this.recording = false;
                this.elements.orb.classList.remove('recording');
                this.elements.orb.classList.add('processing');
                this.showIndicator('PROCESSING...');
                
                setTimeout(() => this.processSample(), 10);
            }

            processSample() {
                if (this.buffer.length < this.ctx.sampleRate * 0.2) {
                    this.elements.orb.classList.remove('processing');
                    return;
                }
                
                const processed = this.processBuffer(this.buffer);
                const stretch = this.quantizeDuration(processed.duration);
                const pitch = [0.5, 0.667, 1, 1.5, 2][Math.floor(Math.random() * 5)];
                
                this.sampleQueue.push({
                    buffer: processed,
                    rate: stretch * pitch,
                    evolution: 0
                });
                
                this.elements.orb.classList.remove('processing');
                this.showIndicator('SAMPLE QUEUED');
            }

            processBuffer(input) {
                // Create buffer
                const buffer = this.ctx.createBuffer(1, input.length, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Process with gate, normalize, and trim
                let gateOpen = false;
                const gateThreshold = 0.02;
                let maxVal = 0;
                let startIdx = 0;
                let endIdx = input.length - 1;
                
                // First pass - gate and find bounds
                for (let i = 0; i < input.length; i++) {
                    let sample = input[i];
                    
                    if (Math.abs(sample) > gateThreshold) {
                        gateOpen = true;
                        if (startIdx === 0) startIdx = i;
                        endIdx = i;
                    } else if (gateOpen && Math.abs(sample) < gateThreshold * 0.5) {
                        gateOpen = false;
                    }
                    
                    if (gateOpen) {
                        sample = Math.tanh(sample * 1.5); // Soft clip
                        maxVal = Math.max(maxVal, Math.abs(sample));
                    } else {
                        sample = 0;
                    }
                    
                    data[i] = sample;
                }
                
                // Normalize
                if (maxVal > 0) {
                    const gain = 0.9 / maxVal;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= gain;
                    }
                }
                
                // Create trimmed buffer
                const trimmedLength = endIdx - startIdx;
                if (trimmedLength <= 0) return buffer;
                
                const trimmed = this.ctx.createBuffer(1, trimmedLength, this.ctx.sampleRate);
                const trimmedData = trimmed.getChannelData(0);
                
                for (let i = 0; i < trimmedLength; i++) {
                    trimmedData[i] = data[startIdx + i];
                }
                
                return trimmed;
            }

            quantizeDuration(duration) {
                const beatLength = 60 / this.bpm;
                const bars = [0.25, 0.5, 1, 2, 4];
                
                for (const bar of bars) {
                    const target = beatLength * bar;
                    if (Math.abs(duration - target) < beatLength * 0.25) {
                        return target / duration;
                    }
                }
                
                return (beatLength * 2) / duration;
            }

            startSequencer() {
                let nextTime = this.ctx.currentTime;
                const schedule = () => {
                    const currentTime = this.ctx.currentTime;
                    const beatLength = 60 / this.bpm / 4;
                    
                    while (nextTime < currentTime + 0.1) {
                        const step = this.seq.step;
                        
                        // Add queued samples on downbeat
                        if (step % 16 === 0 && this.sampleQueue.length > 0 && !this.voidPhase) {
                            const sample = this.sampleQueue.shift();
                            this.addSample(sample);
                        }
                        
                        // Play patterns
                        const patterns = this.getPatterns();
                        
                        if (patterns.kick[step % 16]) {
                            this.playDrum('kick', nextTime);
                        }
                        
                        if (patterns.hat[step % 16]) {
                            this.playDrum('hat', nextTime);
                        }
                        
                        // Bassline after 2 samples
                        if (this.samples.get('sample').length >= 2 && !this.voidPhase) {
                            this.playBassline(step, nextTime);
                        }
                        
                        // Visual pulse
                        if (step % 4 === 0) {
                            setTimeout(() => {
                                this.elements.orb.classList.add('pulse');
                                setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                            }, (nextTime - currentTime) * 1000);
                        }
                        
                        this.seq.step = (step + 1) % 32;
                        nextTime += beatLength;
                    }
                    
                    setTimeout(schedule, 25);
                };
                
                schedule();
            }

            getPatterns() {
                const idx = Math.floor(this.evolution.complexity);
                const patterns = {
                    kick: [
                        [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,1, 0,0,1,0, 1,0,0,0, 0,0,1,0],
                        [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0]
                    ],
                    hat: [
                        [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                        [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
                        [1,1,1,0, 1,0,1,1, 1,0,1,0, 1,1,1,0],
                        [1,1,1,1, 1,0,1,1, 1,1,1,0, 1,1,1,1]
                    ]
                };
                
                return {
                    kick: patterns.kick[idx] || patterns.kick[0],
                    hat: patterns.hat[idx] || patterns.hat[0]
                };
            }

            addSample(sample) {
                const samples = this.samples.get('sample');
                
                if (samples.length >= 4) {
                    const oldest = samples.shift();
                    if (this.activeSamples.has(oldest)) {
                        this.activeSamples.get(oldest).stop();
                        this.activeSamples.delete(oldest);
                    }
                }
                
                samples.push(sample);
                this.playSampleLoop(sample);
                
                // Schedule evolution
                setTimeout(() => { sample.evolution = 1; }, 8000);
                setTimeout(() => { sample.evolution = 2; }, 16000);
                
                this.showIndicator('SAMPLE ADDED');
            }

            playSampleLoop(sample) {
                if (this.activeSamples.has(sample)) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                const compressor = this.ctx.createDynamicsCompressor();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                
                // Sync loop
                const beatLength = 60 / this.bpm;
                src.loopEnd = Math.min(sample.buffer.duration, beatLength * 4);
                
                // Production chain
                filter.type = 'lowpass';
                filter.frequency.value = 20000 - (sample.evolution * 5000);
                filter.Q.value = 1 + sample.evolution;
                
                compressor.threshold.value = -12;
                compressor.knee.value = 6;
                compressor.ratio.value = 4;
                compressor.attack.value = 0.003;
                compressor.release.value = 0.1;
                
                const sampleCount = this.samples.get('sample').length;
                gain.gain.value = 0.6 / Math.sqrt(sampleCount);
                
                // Connect
                src.connect(filter);
                filter.connect(compressor);
                compressor.connect(gain);
                gain.connect(this.nodes.sample);
                gain.connect(this.nodes.reverbSend);
                
                // Start on next bar
                const nextBar = Math.ceil(this.ctx.currentTime / (beatLength * 4)) * (beatLength * 4);
                src.start(nextBar);
                
                this.activeSamples.set(sample, src);
                
                // Automation
                const automate = () => {
                    if (!this.activeSamples.has(sample)) return;
                    
                    const now = this.ctx.currentTime;
                    const mod = 5000 + Math.sin(now * 0.2) * 3000 * (1 - sample.evolution * 0.3);
                    filter.frequency.linearRampToValueAtTime(mod, now + 0.1);
                    
                    // Sidechain
                    if (this.seq.step % 4 === 0) {
                        gain.gain.setValueAtTime(gain.gain.value * 0.3, now);
                        gain.gain.linearRampToValueAtTime(0.6 / Math.sqrt(sampleCount), now + 0.1);
                    }
                    
                    requestAnimationFrame(automate);
                };
                automate();
            }

            playDrum(type, time) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                const src = this.ctx.createBufferSource();
                src.buffer = samples[0].buffer;
                src.connect(this.nodes[type]);
                src.start(time);
            }

            playBassline(step, time) {
                const patterns = [
                    { steps: [0, 4, 8, 12], notes: [0, 0, 3, 5] },
                    { steps: [0, 2, 4, 6, 8, 10, 12, 14], notes: [0, 2, 3, 5, 0, -2, -3, -5] },
                    { steps: [0, 3, 4, 7, 8, 11, 12, 15], notes: [0, 7, 5, 3, 0, -4, -5, -7] },
                    { steps: [0, 1, 3, 4, 6, 8, 9, 11, 12, 14], notes: [0, 0, 7, 5, 3, 0, 0, -4, -5, -7] }
                ];
                
                const idx = Math.floor(this.evolution.complexity);
                const pattern = patterns[idx] || patterns[0];
                const stepIdx = pattern.steps.indexOf(step % 16);
                
                if (stepIdx === -1) return;
                
                const note = pattern.notes[stepIdx];
                const freq = 55 * Math.pow(2, (40 + note) / 12);
                
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const sub = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc1.type = 'sawtooth';
                osc1.frequency.value = freq;
                
                osc2.type = 'square';
                osc2.frequency.value = freq * 1.01;
                osc2.detune.value = -5;
                
                sub.type = 'sine';
                sub.frequency.value = freq / 2;
                
                filter.type = 'lowpass';
                filter.frequency.value = 800 + this.evolution.energy * 400;
                filter.Q.value = 8;
                
                const duration = 60 / this.bpm * 2;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.7, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.1, time + duration);
                
                osc1.connect(filter);
                osc2.connect(filter);
                sub.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.bassline);
                
                [osc1, osc2, sub].forEach(osc => {
                    osc.start(time);
                    osc.stop(time + duration);
                });
            }

            startAutoSampler() {
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                let threshold = 0.1;
                
                const detect = () => {
                    if (this.recording || cooldown > 0 || this.voidPhase) {
                        cooldown--;
                        requestAnimationFrame(detect);
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    let sum = 0, peaks = 0;
                    for (let i = 4; i < 200; i++) {
                        sum += data[i];
                        if (data[i] > 150) peaks++;
                    }
                    
                    const avg = sum / 196;
                    threshold = threshold * 0.95 + avg * 0.05;
                    
                    const detectionThreshold = this.motionPattern === 'calm' ? 1.5 : 2;
                    
                    if (peaks > 10 && avg > threshold * detectionThreshold) {
                        this.startRecording();
                        cooldown = 150;
                    }
                    
                    requestAnimationFrame(detect);
                };
                
                detect();
            }

            showIndicator(text) {
                this.elements.sampleIndicator.textContent = text;
                this.elements.sampleIndicator.classList.add('visible');
                setTimeout(() => {
                    this.elements.sampleIndicator.classList.remove('visible');
                }, 2000);
            }

            updateUI() {
                this.elements.stageName.textContent = this.voidPhase ? 'VOID' : this.stage;
                this.elements.mode.textContent = this.motionPattern.toUpperCase();
                this.elements.sampleCount.textContent = this.samples.get('sample').length;
                this.elements.bpmDisplay.textContent = Math.round(this.bpm);
                this.elements.activeDisplay.textContent = this.activeSamples.size;
                
                this.elements.motionBar.style.width = Math.min(this.motion * 15, 100) + '%';
                this.elements.evolutionBar.style.width = (this.evolution.complexity / 3) * 100 + '%';
                
                // Update spectrum
                if (this.analyser && this.frameSkip % 2 === 0) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    for (let i = 0; i < SPECTRUM_BARS; i++) {
                        const height = (this.dataArray[i] / 255) * 60;
                        this.spectrumBars[i].style.height = height + 'px';
                        
                        if (this.voidPhase) {
                            this.spectrumBars[i].style.background = `linear-gradient(0deg, rgba(147,112,219,0.8), rgba(147,112,219,0.2))`;
                        } else {
                            const hue = this.stage === 'TRANSCENDENT' ? (Date.now() / 20 + i * 5) % 360 : 200;
                            this.spectrumBars[i].style.background = `linear-gradient(0deg, hsla(${hue}, 70%, 50%, 0.8), hsla(${hue}, 70%, 70%, 0.2))`;
                        }
                    }
                }
            }

            animate() {
                if (!this.active) return;
                
                // Update orb position
                this.elements.orb.style.left = this.pos.x + '%';
                this.elements.orb.style.top = this.pos.y + '%';
                
                // Update UI less frequently
                if (Date.now() - this.lastUIUpdate > 50) {
                    this.updateUI();
                    this.lastUIUpdate = Date.now();
                }
                
                // Background
                const intensity = Math.min(this.intensity / 4, 1);
                const motion = Math.min(this.motion / 6, 1);
                
                if (this.voidPhase) {
                    const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
                    document.body.style.background = `radial-gradient(circle at 50% 50%, rgba(147, 112, 219, ${0.1 + breathe * 0.1}) 5%, #000 60%)`;
                } else {
                    const r = Math.floor(100 * intensity);
                    const g = Math.floor(100 * motion);
                    const b = Math.floor(100 * (1 - intensity));
                    document.body.style.background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgb(${r}, ${g}, ${b}) ${5 + motion * 20}%, #000 70%)`;
                }
                
                this.frameSkip++;
                requestAnimationFrame(this.animate.bind(this));
            }
        }

        // Start
        new Engine();
    </script>
</body>
</html>
