<!DOCTYPE html>
<html lang="en">
<head>
Â  <meta charset="UTF-8">
Â  <meta name="viewport" content="width=device-width, initial-scale=1.0">
Â  <title>GUMP: Grand Unified Music Project</title>
Â  <style>
Â  Â  * { margin: 0; padding: 0; box-sizing: border-box; }
Â  Â  body {
Â  Â  Â  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
Â  Â  Â  background: radial-gradient(circle at 40% 60%, #0a0a1a 0%, #1a1a2e 40%, #16213e 100%);
Â  Â  Â  color: #00ffaa;
Â  Â  Â  overflow: hidden;
Â  Â  Â  touch-action: none;
Â  Â  Â  height: 100vh;
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: center;
Â  Â  Â  transition: all 1s ease;
Â  Â  }
Â  Â  
Â  Â  body.transcendent {
Â  Â  Â  background: radial-gradient(circle at 60% 40%, #080012 0%, #1a0a2e 25%, #2a1a3e 50%, #3a2a4e 75%, #1a0a2e 100%);
Â  Â  Â  color: #ff88cc;
Â  Â  Â  filter: blur(0.5px) brightness(1.2);
Â  Â  }
Â  Â  
Â  Â  .app {
Â  Â  Â  width: 100%;
Â  Â  Â  max-width: 450px;
Â  Â  Â  padding: 25px;
Â  Â  Â  text-align: center;
Â  Â  Â  backdrop-filter: blur(5px) saturate(180%);
Â  Â  Â  border-radius: 20px;
Â  Â  Â  background: rgba(10, 10, 20, 0.1);
Â  Â  }
Â  Â  
Â  Â  .logo {
Â  Â  Â  font-size: clamp(3.5rem, 14vw, 7rem);
Â  Â  Â  font-weight: 900;
Â  Â  Â  background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
Â  Â  Â  -webkit-background-clip: text;
Â  Â  Â  -webkit-text-fill-color: transparent;
Â  Â  Â  background-clip: text;
Â  Â  Â  margin-bottom: 0.7rem;
Â  Â  Â  animation: pulse 3s ease-in-out infinite;
Â  Â  Â  cursor: pointer;
Â  Â  }
Â  Â  
Â  Â  @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
Â  Â  
Â  Â  .tagline { 
Â  Â  Â  font-size: clamp(1.2rem, 5vw, 1.5rem); 
Â  Â  Â  opacity: 0.85; 
Â  Â  Â  margin-bottom: 3.5rem; 
Â  Â  Â  font-weight: 300;
Â  Â  Â  transition: all 0.3s ease;
Â  Â  }
Â  Â  
Â  Â  .start-btn {
Â  Â  Â  padding: 22px 45px;
Â  Â  Â  background: linear-gradient(45deg, #00ffaa, #4ecdc4);
Â  Â  Â  color: #000;
Â  Â  Â  border: none;
Â  Â  Â  border-radius: 35px;
Â  Â  Â  font-size: 1.3rem;
Â  Â  Â  font-weight: 800;
Â  Â  Â  cursor: pointer;
Â  Â  Â  transition: all 0.4s ease;
Â  Â  Â  box-shadow: 0 12px 35px rgba(0, 255, 170, 0.4);
Â  Â  Â  margin-bottom: 2.5rem;
Â  Â  }
Â  Â  
Â  Â  .start-btn:hover { transform: translateY(-4px); box-shadow: 0 18px 50px rgba(0, 255, 170, 0.6); }
Â  Â  
Â  Â  .spatial-viz {
Â  Â  Â  width: 100%;
Â  Â  Â  height: 300px;
Â  Â  Â  border: 3px solid rgba(0, 255, 170, 0.3);
Â  Â  Â  border-radius: 25px;
Â  Â  Â  position: relative;
Â  Â  Â  overflow: hidden;
Â  Â  Â  background: radial-gradient(circle, rgba(0, 255, 170, 0.05) 0%, rgba(0, 20, 40, 0.05) 100%);
Â  Â  Â  margin-bottom: 2.5rem;
Â  Â  Â  transition: all 1s ease;
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: center;
Â  Â  }
Â  Â  
Â  Â  .spatial-viz.transcendent { border-color: rgba(255, 136, 204, 0.5); background: rgba(255, 136, 204, 0.08); }
Â  Â  
Â  Â  .waveform {
Â  Â  Â  position: absolute;
Â  Â  Â  width: 90%;
Â  Â  Â  height: 70%;
Â  Â  Â  background: rgba(0, 255, 170, 0.2);
Â  Â  Â  border-radius: 10px;
Â  Â  Â  overflow: hidden;
Â  Â  Â  display: flex;
Â  Â  Â  align-items: flex-end;
Â  Â  Â  justify-content: space-around;
Â  Â  }
Â  Â  
Â  Â  .waveform.transcendent { background: rgba(255, 136, 204, 0.3); }
Â  Â  
Â  Â  .wave-bar {
Â  Â  Â  width: 4px;
Â  Â  Â  background: linear-gradient(to top, #00ffaa, #4ecdc4);
Â  Â  Â  border-radius: 2px;
Â  Â  Â  transition: height 0.1s ease;
Â  Â  }
Â  Â  
Â  Â  .orb {
Â  Â  Â  position: absolute;
Â  Â  Â  width: 80px;
Â  Â  Â  height: 80px;
Â  Â  Â  border-radius: 50%;
Â  Â  Â  background: radial-gradient(circle, #00ffaa, transparent);
Â  Â  Â  top: 50%;
Â  Â  Â  left: 50%;
Â  Â  Â  transform: translate(-50%, -50%);
Â  Â  Â  transition: all 0.25s ease;
Â  Â  Â  box-shadow: 0 0 40px rgba(0, 255, 170, 0.6);
Â  Â  Â  will-change: transform;
Â  Â  }
Â  Â  
Â  Â  .orb.transcendent { background: radial-gradient(circle, #ff88cc, transparent); box-shadow: 0 0 80px rgba(255, 136, 204, 0.8); }
Â  Â  
Â  Â  .stats { 
Â  Â  Â  display: grid; 
Â  Â  Â  grid-template-columns: repeat(4, 1fr); 
Â  Â  Â  gap: 15px; 
Â  Â  Â  margin-bottom: 2.5rem; 
Â  Â  }
Â  Â  
Â  Â  .stat { 
Â  Â  Â  background: rgba(0, 255, 170, 0.15); 
Â  Â  Â  padding: 15px; 
Â  Â  Â  border-radius: 15px; 
Â  Â  Â  border: 2px solid rgba(0, 255, 170, 0.3);
Â  Â  Â  transition: all 0.3s ease;
Â  Â  }
Â  Â  
Â  Â  .stat:hover { background: rgba(0, 255, 170, 0.25); transform: translateY(-2px); }
Â  Â  
Â  Â  .stat-value { font-size: 1.4rem; font-weight: 800; color: #00ffaa; }
Â  Â  .stat-label { font-size: 0.8rem; opacity: 0.75; margin-top: 4px; }
Â  Â  
Â  Â  .controls {
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  gap: 15px;
Â  Â  Â  margin-bottom: 2.5rem;
Â  Â  }
Â  Â  
Â  Â  .control-group {
Â  Â  Â  display: flex;
Â  Â  Â  align-items: center;
Â  Â  Â  justify-content: space-between;
Â  Â  Â  padding: 10px 15px;
Â  Â  Â  background: rgba(0, 255, 170, 0.1);
Â  Â  Â  border-radius: 15px;
Â  Â  Â  border: 1px solid rgba(0, 255, 170, 0.2);
Â  Â  }
Â  Â  
Â  Â  .control-label {
Â  Â  Â  font-size: 0.9rem;
Â  Â  Â  font-weight: 600;
Â  Â  Â  opacity: 0.8;
Â  Â  }
Â  Â  
Â  Â  .autonomy-slider {
Â  Â  Â  width: 120px;
Â  Â  Â  -webkit-appearance: none;
Â  Â  Â  appearance: none;
Â  Â  Â  height: 8px;
Â  Â  Â  background: rgba(0, 255, 170, 0.3);
Â  Â  Â  outline: none;
Â  Â  Â  border-radius: 4px;
Â  Â  Â  opacity: 0.8;
Â  Â  Â  transition: opacity 0.2s;
Â  Â  }
Â  Â  
Â  Â  .autonomy-slider:hover { opacity: 1; }
Â  Â  
Â  Â  .autonomy-slider::-webkit-slider-thumb {
Â  Â  Â  -webkit-appearance: none;
Â  Â  Â  appearance: none;
Â  Â  Â  width: 18px;
Â  Â  Â  height: 18px;
Â  Â  Â  background: #00ffaa;
Â  Â  Â  border-radius: 50%;
Â  Â  Â  cursor: pointer;
Â  Â  Â  box-shadow: 0 0 10px rgba(0, 255, 170, 0.6);
Â  Â  }
Â  Â  
Â  Â  .evolution-display {
Â  Â  Â  display: flex;
Â  Â  Â  flex-direction: column;
Â  Â  Â  gap: 8px;
Â  Â  Â  margin-bottom: 2rem;
Â  Â  }
Â  Â  
Â  Â  .evolution-bar {
Â  Â  Â  height: 6px;
Â  Â  Â  background: rgba(0, 255, 170, 0.2);
Â  Â  Â  border-radius: 3px;
Â  Â  Â  overflow: hidden;
Â  Â  }
Â  Â  
Â  Â  .evolution-progress {
Â  Â  Â  height: 100%;
Â  Â  Â  background: linear-gradient(90deg, #00ffaa, #4ecdc4);
Â  Â  Â  border-radius: 3px;
Â  Â  Â  transition: width 0.5s ease;
Â  Â  }
Â  Â  
Â  Â  .evolution-label {
Â  Â  Â  font-size: 0.75rem;
Â  Â  Â  opacity: 0.7;
Â  Â  Â  text-transform: uppercase;
Â  Â  Â  letter-spacing: 0.5px;
Â  Â  }
Â  Â  
Â  Â  .status { 
Â  Â  Â  font-size: 1rem; 
Â  Â  Â  color: #4ecdc4; 
Â  Â  Â  opacity: 0.85; 
Â  Â  Â  animation: statusBreathe 2.5s ease-in-out infinite;
Â  Â  Â  margin-bottom: 1rem;
Â  Â  }
Â  Â  
Â  Â  @keyframes statusBreathe { 0%, 100% { opacity: 0.85; } 50% { opacity: 1.1; } }
Â  Â  
Â  Â  .particles { 
Â  Â  Â  position: fixed; 
Â  Â  Â  top: 0; 
Â  Â  Â  left: 0; 
Â  Â  Â  width: 100%; 
Â  Â  Â  height: 100%; 
Â  Â  Â  pointer-events: none; 
Â  Â  Â  z-index: -1; 
Â  Â  Â  opacity: 0; 
Â  Â  Â  transition: opacity 0.5s ease; 
Â  Â  }
Â  Â  
Â  Â  .particles.active { opacity: 0.7; }
Â  Â  
Â  Â  .particle { 
Â  Â  Â  position: absolute; 
Â  Â  Â  width: 4px; 
Â  Â  Â  height: 4px; 
Â  Â  Â  background: radial-gradient(circle, #ff88cc, transparent); 
Â  Â  Â  border-radius: 50%; 
Â  Â  Â  animation: float 7s linear infinite; 
Â  Â  }
Â  Â  
Â  Â  @keyframes float { 
Â  Â  Â  0% { transform: translateY(110vh) scale(0); opacity: 0; } 
Â  Â  Â  10% { opacity: 0.8; } 
Â  Â  Â  90% { opacity: 0.8; } 
Â  Â  Â  100% { transform: translateY(-30vh) scale(1.5); opacity: 0; } 
Â  Â  }
Â  Â  
Â  Â  .neural-network {
Â  Â  Â  position: absolute;
Â  Â  Â  top: 0;
Â  Â  Â  left: 0;
Â  Â  Â  width: 100%;
Â  Â  Â  height: 100%;
Â  Â  Â  pointer-events: none;
Â  Â  Â  opacity: 0.3;
Â  Â  }
Â  Â  
Â  Â  .neural-node {
Â  Â  Â  position: absolute;
Â  Â  Â  width: 8px;
Â  Â  Â  height: 8px;
Â  Â  Â  background: #00ffaa;
Â  Â  Â  border-radius: 50%;
Â  Â  Â  box-shadow: 0 0 10px rgba(0, 255, 170, 0.5);
Â  Â  Â  animation: pulse 2s ease-in-out infinite;
Â  Â  }
Â  Â  
Â  Â  .neural-connection {
Â  Â  Â  position: absolute;
Â  Â  Â  height: 1px;
Â  Â  Â  background: linear-gradient(90deg, transparent, #00ffaa, transparent);
Â  Â  Â  opacity: 0.4;
Â  Â  Â  animation: flow 3s ease-in-out infinite;
Â  Â  }
Â  Â  
Â  Â  @keyframes flow {
Â  Â  Â  0%, 100% { opacity: 0.2; }
Â  Â  Â  50% { opacity: 0.6; }
Â  Â  }
Â  Â  
Â  Â  .hidden { display: none !important; }
Â  Â  .error { 
Â  Â  Â  background: rgba(255, 107, 107, 0.15); 
Â  Â  Â  border: 2px solid rgba(255, 107, 107, 0.4); 
Â  Â  Â  border-radius: 20px; 
Â  Â  Â  padding: 25px; 
Â  Â  Â  color: #ff6b6b; 
Â  Â  Â  margin-top: 25px; 
Â  Â  }
Â  Â  
Â  Â  .debug-panel {
Â  Â  Â  position: fixed;
Â  Â  Â  top: 20px;
Â  Â  Â  right: 20px;
Â  Â  Â  background: rgba(0, 0, 0, 0.8);
Â  Â  Â  padding: 15px;
Â  Â  Â  border-radius: 10px;
Â  Â  Â  font-family: monospace;
Â  Â  Â  font-size: 0.8rem;
Â  Â  Â  color: #00ffaa;
Â  Â  Â  opacity: 0;
Â  Â  Â  transition: opacity 0.3s ease;
Â  Â  Â  max-width: 300px;
Â  Â  Â  z-index: 1000;
Â  Â  }
Â  Â  
Â  Â  .debug-panel.active { opacity: 1; }
Â  Â  
Â  Â  .debug-line {
Â  Â  Â  margin: 2px 0;
Â  Â  Â  padding: 2px 5px;
Â  Â  Â  border-radius: 3px;
Â  Â  Â  background: rgba(0, 255, 170, 0.1);
Â  Â  }
Â  </style>
</head>
<body>
Â  <div class="particles" id="particles"></div>
Â Â 
Â  <div class="app">
Â  Â  <div class="logo" id="logo" onclick="gumpApp.toggleDebug()">GUMP</div>
Â  Â  <div class="tagline" id="tagline">Grand Unified Music Project</div>
Â  Â Â 
Â  Â  <button class="start-btn" id="start">ðŸŽµ Start Spatial Audio</button>
Â  Â Â 
Â  Â  <div class="spatial-viz hidden" id="viz">
Â  Â  Â  <div class="neural-network" id="neuralNetwork"></div>
Â  Â  Â  <div class="waveform" id="waveform"></div>
Â  Â  Â  <div class="orb" id="orb"></div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="stats hidden" id="stats">
Â  Â  Â  <div class="stat"><div class="stat-value" id="motion">0</div><div class="stat-label">Motion</div></div>
Â  Â  Â  <div class="stat"><div class="stat-value" id="bpm">95</div><div class="stat-label">BPM</div></div>
Â  Â  Â  <div class="stat"><div class="stat-value" id="groove">CHILL</div><div class="stat-label">State</div></div>
Â  Â  Â  <div class="stat"><div class="stat-value" id="generation">1</div><div class="stat-label">Gen</div></div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="controls hidden" id="controls">
Â  Â  Â  <div class="control-group">
Â  Â  Â  Â  <span class="control-label">Autonomy</span>
Â  Â  Â  Â  <input type="range" min="0" max="100" value="50" class="autonomy-slider" id="autonomy">
Â  Â  Â  </div>
Â  Â  Â  <div class="control-group">
Â  Â  Â  Â  <span class="control-label">Learning Rate</span>
Â  Â  Â  Â  <input type="range" min="1" max="10" value="5" class="autonomy-slider" id="learningRate">
Â  Â  Â  </div>
Â  Â  Â  <div class="control-group">
Â  Â  Â  Â  <span class="control-label">Mutation Rate</span>
Â  Â  Â  Â  <input type="range" min="1" max="20" value="5" class="autonomy-slider" id="mutationRate">
Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="evolution-display hidden" id="evolutionDisplay">
Â  Â  Â  <div>
Â  Â  Â  Â  <div class="evolution-label">Pattern Evolution</div>
Â  Â  Â  Â  <div class="evolution-bar">
Â  Â  Â  Â  Â  <div class="evolution-progress" id="patternEvolution" style="width: 0%"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div>
Â  Â  Â  Â  <div class="evolution-label">Harmonic Evolution</div>
Â  Â  Â  Â  <div class="evolution-bar">
Â  Â  Â  Â  Â  <div class="evolution-progress" id="harmonicEvolution" style="width: 0%"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  Â  <div>
Â  Â  Â  Â  <div class="evolution-label">Temporal Evolution</div>
Â  Â  Â  Â  <div class="evolution-bar">
Â  Â  Â  Â  Â  <div class="evolution-progress" id="temporalEvolution" style="width: 0%"></div>
Â  Â  Â  Â  </div>
Â  Â  Â  </div>
Â  Â  </div>
Â  Â Â 
Â  Â  <div class="status hidden" id="status">ðŸŽµ Initializing neural patterns...</div>
Â  Â  <div class="error hidden" id="error"></div>
Â  </div>
Â Â 
Â  <div class="debug-panel" id="debugPanel">
Â  Â  <div class="debug-line">Neural Activity: <span id="neuralActivity">0</span></div>
Â  Â  <div class="debug-line">Active Genes: <span id="activeGenes">0</span></div>
Â  Â  <div class="debug-line">Fitness Score: <span id="fitnessScore">0</span></div>
Â  Â  <div class="debug-line">Last Mutation: <span id="lastMutation">None</span></div>
Â  Â  <div class="debug-line">Performance: <span id="performance">0ms</span></div>
Â  </div>

Â  <script>
Â  Â  // Advanced AI and Evolution Classes
Â  Â  class NeuralNetwork {
Â  Â  Â  constructor(inputSize, hiddenSize, outputSize) {
Â  Â  Â  Â  this.inputSize = inputSize;
Â  Â  Â  Â  this.hiddenSize = hiddenSize;
Â  Â  Â  Â  this.outputSize = outputSize;
Â  Â  Â  Â  this.learningRate = 0.1;
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.weightsIH = this.randomMatrix(hiddenSize, inputSize);
Â  Â  Â  Â  this.weightsHO = this.randomMatrix(outputSize, hiddenSize);
Â  Â  Â  Â  this.biasH = this.randomMatrix(hiddenSize, 1);
Â  Â  Â  Â  this.biasO = this.randomMatrix(outputSize, 1);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  randomMatrix(rows, cols) {
Â  Â  Â  Â  const matrix = [];
Â  Â  Â  Â  for (let i = 0; i < rows; i++) {
Â  Â  Â  Â  Â  matrix[i] = [];
Â  Â  Â  Â  Â  for (let j = 0; j < cols; j++) {
Â  Â  Â  Â  Â  Â  matrix[i][j] = Math.random() * 2 - 1;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return matrix;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  sigmoid(x) {
Â  Â  Â  Â  return 1 / (1 + Math.exp(-x));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  predict(inputs) {
Â  Â  Â  Â  const hidden = this.matrixMultiply(this.weightsIH, inputs);
Â  Â  Â  Â  const hiddenActivated = hidden.map(row => row.map(x => this.sigmoid(x)));
Â  Â  Â  Â  const output = this.matrixMultiply(this.weightsHO, hiddenActivated);
Â  Â  Â  Â  return output.map(row => row.map(x => this.sigmoid(x)));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  matrixMultiply(a, b) {
Â  Â  Â  Â  const result = [];
Â  Â  Â  Â  for (let i = 0; i < a.length; i++) {
Â  Â  Â  Â  Â  result[i] = [];
Â  Â  Â  Â  Â  for (let j = 0; j < b[0].length; j++) {
Â  Â  Â  Â  Â  Â  result[i][j] = 0;
Â  Â  Â  Â  Â  Â  for (let k = 0; k < b.length; k++) {
Â  Â  Â  Â  Â  Â  Â  result[i][j] += a[i][k] * b[k][j];
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return result;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setLearningRate(rate) {
Â  Â  Â  Â  this.learningRate = rate;
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class EvolutionEngine {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.mutationRate = 0.05;
Â  Â  Â  Â  this.generations = [];
Â  Â  Â  Â  this.currentGeneration = 0;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evolve(population, fitnessScores) {
Â  Â  Â  Â  const newPopulation = [];
Â  Â  Â  Â  const sortedIndices = fitnessScores
Â  Â  Â  Â  Â  .map((score, index) => ({ score, index }))
Â  Â  Â  Â  Â  .sort((a, b) => b.score - a.score);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Keep best performers
Â  Â  Â  Â  for (let i = 0; i < Math.floor(population.length * 0.2); i++) {
Â  Â  Â  Â  Â  newPopulation.push(population[sortedIndices[i].index]);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Generate offspring
Â  Â  Â  Â  while (newPopulation.length < population.length) {
Â  Â  Â  Â  Â  const parent1 = this.selectParent(population, fitnessScores);
Â  Â  Â  Â  Â  const parent2 = this.selectParent(population, fitnessScores);
Â  Â  Â  Â  Â  const offspring = this.crossover(parent1, parent2);
Â  Â  Â  Â  Â  this.mutate(offspring);
Â  Â  Â  Â  Â  newPopulation.push(offspring);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.currentGeneration++;
Â  Â  Â  Â  return newPopulation;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  selectParent(population, fitnessScores) {
Â  Â  Â  Â  const totalFitness = fitnessScores.reduce((sum, score) => sum + score, 0);
Â  Â  Â  Â  let random = Math.random() * totalFitness;
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let i = 0; i < population.length; i++) {
Â  Â  Â  Â  Â  random -= fitnessScores[i];
Â  Â  Â  Â  Â  if (random <= 0) return population[i];
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  return population[population.length - 1];
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  crossover(parent1, parent2) {
Â  Â  Â  Â  const offspring = {};
Â  Â  Â  Â  Object.keys(parent1).forEach(key => {
Â  Â  Â  Â  Â  offspring[key] = Math.random() < 0.5 ? parent1[key] : parent2[key];
Â  Â  Â  Â  });
Â  Â  Â  Â  return offspring;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  mutate(individual) {
Â  Â  Â  Â  Object.keys(individual).forEach(key => {
Â  Â  Â  Â  Â  if (Math.random() < this.mutationRate) {
Â  Â  Â  Â  Â  Â  if (typeof individual[key] === 'number') {
Â  Â  Â  Â  Â  Â  Â  individual[key] += (Math.random() - 0.5) * 0.1;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setMutationRate(rate) {
Â  Â  Â  Â  this.mutationRate = rate;
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class PatternGenome {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.patterns = this.generateInitialPatterns();
Â  Â  Â  Â  this.evolutionProgress = 0;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  generateInitialPatterns() {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  kick: [1, 0, 0, 0, 1, 0, 0, 0],
Â  Â  Â  Â  Â  snare: [0, 0, 1, 0, 0, 0, 1, 0],
Â  Â  Â  Â  Â  hihat: [1, 1, 0, 1, 1, 1, 0, 1],
Â  Â  Â  Â  Â  bass: [1, 0, 0, 1, 0, 0, 1, 0]
Â  Â  Â  Â  };
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evolvePattern(type, rhythm, variance) {
Â  Â  Â  Â  const pattern = this.patterns[type];
Â  Â  Â  Â  for (let i = 0; i < pattern.length; i++) {
Â  Â  Â  Â  Â  if (Math.random() < variance / 100) {
Â  Â  Â  Â  Â  Â  pattern[i] = Math.random() < rhythm ? 1 : 0;
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  this.evolutionProgress = Math.min(100, this.evolutionProgress + 1);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  getPattern(type) {
Â  Â  Â  Â  return this.patterns[type] || this.patterns.kick;
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class HarmonicGenome {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.harmonies = this.generateInitialHarmonies();
Â  Â  Â  Â  this.evolutionProgress = 0;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  generateInitialHarmonies() {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  major: [0, 2, 4, 5, 7, 9, 11],
Â  Â  Â  Â  Â  minor: [0, 2, 3, 5, 7, 8, 10],
Â  Â  Â  Â  Â  dorian: [0, 2, 3, 5, 7, 9, 10],
Â  Â  Â  Â  Â  phrygian: [0, 1, 3, 5, 7, 8, 10]
Â  Â  Â  Â  };
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evolveHarmony(emotion, energy) {
Â  Â  Â  Â  const harmony = this.harmonies.major;
Â  Â  Â  Â  if (Math.random() < energy / 100) {
Â  Â  Â  Â  Â  const index = Math.floor(Math.random() * harmony.length);
Â  Â  Â  Â  Â  harmony[index] = Math.max(0, Math.min(11, harmony[index] + (Math.random() - 0.5) * 2));
Â  Â  Â  Â  }
Â  Â  Â  Â  this.evolutionProgress = Math.min(100, this.evolutionProgress + 0.5);
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class TemporalGenome {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.timings = this.generateInitialTimings();
Â  Â  Â  Â  this.evolutionProgress = 0;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  generateInitialTimings() {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  subdivision: 16,
Â  Â  Â  Â  Â  swing: 0.1,
Â  Â  Â  Â  Â  groove: 0.05,
Â  Â  Â  Â  Â  humanization: 0.02
Â  Â  Â  Â  };
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evolveTiming(motion, bpm) {
Â  Â  Â  Â  if (Math.random() < 0.1) {
Â  Â  Â  Â  Â  this.timings.swing += (Math.random() - 0.5) * 0.02;
Â  Â  Â  Â  Â  this.timings.groove += (Math.random() - 0.5) * 0.01;
Â  Â  Â  Â  Â  this.timings.swing = Math.max(0, Math.min(0.3, this.timings.swing));
Â  Â  Â  Â  Â  this.timings.groove = Math.max(0, Math.min(0.1, this.timings.groove));
Â  Â  Â  Â  }
Â  Â  Â  Â  this.evolutionProgress = Math.min(100, this.evolutionProgress + 0.3);
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class FitnessEvaluator {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.history = [];
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evaluate(motion, bpm, harmony, pattern) {
Â  Â  Â  Â  const motionFitness = this.evaluateMotion(motion);
Â  Â  Â  Â  const rhythmFitness = this.evaluateRhythm(bpm);
Â  Â  Â  Â  const harmonyFitness = this.evaluateHarmony(harmony);
Â  Â  Â  Â  const patternFitness = this.evaluatePattern(pattern);
Â  Â  Â  Â Â 
Â  Â  Â  Â  const fitness = (motionFitness + rhythmFitness + harmonyFitness + patternFitness) / 4;
Â  Â  Â  Â  this.history.push(fitness);
Â  Â  Â  Â Â 
Â  Â  Â  Â  return fitness;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evaluateMotion(motion) {
Â  Â  Â  Â  return Math.min(100, motion * 2);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evaluateRhythm(bpm) {
Â  Â  Â  Â  return Math.max(0, 100 - Math.abs(bpm - 120));
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evaluateHarmony(harmony) {
Â  Â  Â  Â  return Math.random() * 100; // Placeholder
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  evaluatePattern(pattern) {
Â  Â  Â  Â  return Math.random() * 100; // Placeholder
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class CircularBuffer {
Â  Â  Â  constructor(size) {
Â  Â  Â  Â  this.size = size;
Â  Â  Â  Â  this.buffer = [];
Â  Â  Â  Â  this.index = 0;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  push(value) {
Â  Â  Â  Â  this.buffer[this.index] = value;
Â  Â  Â  Â  this.index = (this.index + 1) % this.size;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  getRecent(count) {
Â  Â  Â  Â  const recent = [];
Â  Â  Â  Â  for (let i = 0; i < Math.min(count, this.buffer.length); i++) {
Â  Â  Â  Â  Â  const idx = (this.index - 1 - i + this.size) % this.size;
Â  Â  Â  Â  Â  if (this.buffer[idx] !== undefined) {
Â  Â  Â  Â  Â  Â  recent.push(this.buffer[idx]);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â  return recent;
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class BacterialColony {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.bacteria = [];
Â  Â  Â  Â  this.plasmids = [];
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  conjugate() {
Â  Â  Â  Â  // Simulate bacterial conjugation for pattern exchange
Â  Â  Â  Â  if (this.bacteria.length >= 2) {
Â  Â  Â  Â  Â  const donor = this.bacteria[Math.floor(Math.random() * this.bacteria.length)];
Â  Â  Â  Â  Â  const recipient = this.bacteria[Math.floor(Math.random() * this.bacteria.length)];
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (donor !== recipient) {
Â  Â  Â  Â  Â  Â  // Exchange genetic material
Â  Â  Â  Â  Â  Â  const plasmid = this.createPlasmid(donor);
Â  Â  Â  Â  Â  Â  this.transferPlasmid(plasmid, recipient);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  createPlasmid(bacterium) {
Â  Â  Â  Â  return {
Â  Â  Â  Â  Â  pattern: bacterium.pattern,
Â  Â  Â  Â  Â  harmony: bacterium.harmony,
Â  Â  Â  Â  Â  fitness: bacterium.fitness
Â  Â  Â  Â  };
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  transferPlasmid(plasmid, recipient) {
Â  Â  Â  Â  recipient.receivePlasmid(plasmid);
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  class PerformanceMonitor {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.frameCount = 0;
Â  Â  Â  Â  this.lastTime = performance.now();
Â  Â  Â  Â  this.fps = 0;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  update() {
Â  Â  Â  Â  this.frameCount++;
Â  Â  Â  Â  const currentTime = performance.now();
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (currentTime - this.lastTime >= 1000) {
Â  Â  Â  Â  Â  this.fps = Math.round((this.frameCount * 1000) / (currentTime - this.lastTime));
Â  Â  Â  Â  Â  this.frameCount = 0;
Â  Â  Â  Â  Â  this.lastTime = currentTime;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  getFPS() {
Â  Â  Â  Â  return this.fps;
Â  Â  Â  }
Â  Â  }
Â  Â  
Â  Â  // SoundAgent Class - Represents an individual sound-producing entity
Â  Â  class SoundAgent {
Â  Â  Â  constructor(audioContext, type, frequency, position, panner) {
Â  Â  Â  Â  this.ctx = audioContext;
Â  Â  Â  Â  this.oscillator = this.ctx.createOscillator();
Â  Â  Â  Â  this.gainNode = this.ctx.createGain();
Â  Â  Â  Â  this.panner = panner; // Use the provided panner
Â  Â  Â  Â  this.type = type;
Â  Â  Â  Â  this.frequency = frequency;
Â  Â  Â  Â  this.position = position; // {x, y, z} coordinates
Â  Â  Â  Â  this.isPlaying = false;
Â  Â  Â  Â  this.envelope = {
Â  Â  Â  Â  Â  attack: 0.01,
Â  Â  Â  Â  Â  decay: 0.1,
Â  Â  Â  Â  Â  sustain: 0.5,
Â  Â  Â  Â  Â  release: 0.5
Â  Â  Â  Â  };
Â  Â  Â  Â  this.setup();
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setup() {
Â  Â  Â  Â  this.oscillator.type = 'sine'; // Default type
Â  Â  Â  Â  this.oscillator.frequency.setValueAtTime(this.frequency, this.ctx.currentTime);
Â  Â  Â  Â  this.gainNode.gain.setValueAtTime(0, this.ctx.currentTime); // Start silent
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.oscillator.connect(this.gainNode);
Â  Â  Â  Â  this.gainNode.connect(this.panner); // Connect to the shared panner
Â  Â  Â  Â  this.oscillator.start(0);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  play(velocity = 1) {
Â  Â  Â  Â  const now = this.ctx.currentTime;
Â  Â  Â  Â  this.gainNode.gain.cancelScheduledValues(now);
Â  Â  Â  Â  this.gainNode.gain.setValueAtTime(0, now);
Â  Â  Â  Â  this.gainNode.gain.linearRampToValueAtTime(velocity * 0.7, now + this.envelope.attack);
Â  Â  Â  Â  this.gainNode.gain.linearRampToValueAtTime(velocity * this.envelope.sustain * 0.5, now + this.envelope.attack + this.envelope.decay);
Â  Â  Â  Â  this.isPlaying = true;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  stop() {
Â  Â  Â  Â  const now = this.ctx.currentTime;
Â  Â  Â  Â  this.gainNode.gain.cancelScheduledValues(now);
Â  Â  Â  Â  this.gainNode.gain.setValueAtTime(this.gainNode.gain.value, now);
Â  Â  Â  Â  this.gainNode.gain.linearRampToValueAtTime(0, now + this.envelope.release);
Â  Â  Â  Â  this.isPlaying = false;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setFrequency(freq) {
Â  Â  Â  Â  this.frequency = freq;
Â  Â  Â  Â  this.oscillator.frequency.setValueAtTime(freq, this.ctx.currentTime);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setType(type) {
Â  Â  Â  Â  this.oscillator.type = type;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setPosition(x, y, z) {
Â  Â  Â  Â  this.panner.positionX.setValueAtTime(x, this.ctx.currentTime);
Â  Â  Â  Â  this.panner.positionY.setValueAtTime(y, this.ctx.currentTime);
Â  Â  Â  Â  this.panner.positionZ.setValueAtTime(z, this.ctx.currentTime);
Â  Â  Â  Â  this.position = {x, y, z};
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  // Main GUMP Class
Â  Â  class QuantumGUMP {
Â  Â  Â  constructor() {
Â  Â  Â  Â  this.ctx = null;
Â  Â  Â  Â  this.motion = 0;
Â  Â  Â  Â  this.bpm = 95;
Â  Â  Â  Â  this.pos = { x: 0, y: 0, z: 0 }; // Orb's spatial position
Â  Â  Â  Â  this.velocity = { x: 0, y: 0, z: 0 };
Â  Â  Â  Â  this.acceleration = { x: 0, y: 0, z: 0 };
Â  Â  Â  Â  this.last = { x: 0, y: 0, z: 0 }; // Last gyroscope/accelerometer reading
Â  Â  Â  Â  this.active = false;
Â  Â  Â  Â  this.step = 0;
Â  Â  Â  Â  this.state = 'CHILL'; // Musical state: CHILL, GROOVE, TRANSCENDENT
Â  Â  Â  Â  this.transcendent = false;
Â  Â  Â  Â  this.transcendentIntensity = 0; // 0-100
Â  Â  Â  Â  this.lastMotionTime = Date.now();
Â  Â  Â  Â  this.reverb = null;
Â  Â  Â  Â  this.songSection = 'A1'; // Current musical section
Â  Â  Â  Â  this.layerProgress = 0; // Progress through current song layer
Â  Â  Â  Â  this.lastStrideTime = 0;
Â  Â  Â  Â  this.strideInterval = 400; // ms per beat
Â  Â  Â  Â  this.envDensity = 0; // Environmental density affecting audio
Â  Â  Â  Â  this.oscillators = new Map(); // Map to store active oscillators
Â  Â  Â  Â  this.soundAgents = new Map(); // Map to store SoundAgent instances
Â  Â  Â  Â  this.lastUpdateTime = 0;
Â  Â  Â  Â  this.frameCount = 0;
Â  Â  Â  Â  this.autonomyLevel = 50; // User control vs. AI control (0-100)
Â  Â  Â  Â  this.learningRate = 5; // AI learning rate
Â  Â  Â  Â  this.mutationRate = 5; // Genetic algorithm mutation rate
Â  Â  Â  Â  this.generation = 1; // Evolution generation
Â  Â  Â  Â  this.debugMode = false;
Â  Â  Â  Â  this.panner = null; // Global PannerNode
Â  Â  Â  Â  this.gainNode = null; // Global GainNode
Â  Â  Â  Â Â 
Â  Â  Â  Â  // DOM Elements
Â  Â  Â  Â  this.elements = {
Â  Â  Â  Â  Â  app: document.querySelector('.app'),
Â  Â  Â  Â  Â  logo: document.getElementById('logo'),
Â  Â  Â  Â  Â  tagline: document.getElementById('tagline'),
Â  Â  Â  Â  Â  startBtn: document.getElementById('start'),
Â  Â  Â  Â  Â  viz: document.getElementById('viz'),
Â  Â  Â  Â  Â  waveform: document.getElementById('waveform'),
Â  Â  Â  Â  Â  orb: document.getElementById('orb'),
Â  Â  Â  Â  Â  stats: document.getElementById('stats'),
Â  Â  Â  Â  Â  motionStat: document.getElementById('motion'),
Â  Â  Â  Â  Â  bpmStat: document.getElementById('bpm'),
Â  Â  Â  Â  Â  grooveStat: document.getElementById('groove'),
Â  Â  Â  Â  Â  generationStat: document.getElementById('generation'),
Â  Â  Â  Â  Â  controls: document.getElementById('controls'),
Â  Â  Â  Â  Â  autonomySlider: document.getElementById('autonomy'),
Â  Â  Â  Â  Â  learningRateSlider: document.getElementById('learningRate'),
Â  Â  Â  Â  Â  mutationRateSlider: document.getElementById('mutationRate'),
Â  Â  Â  Â  Â  evolutionDisplay: document.getElementById('evolutionDisplay'),
Â  Â  Â  Â  Â  patternEvolution: document.getElementById('patternEvolution'),
Â  Â  Â  Â  Â  harmonicEvolution: document.getElementById('harmonicEvolution'),
Â  Â  Â  Â  Â  temporalEvolution: document.getElementById('temporalEvolution'),
Â  Â  Â  Â  Â  status: document.getElementById('status'),
Â  Â  Â  Â  Â  error: document.getElementById('error'),
Â  Â  Â  Â  Â  particles: document.getElementById('particles'),
Â  Â  Â  Â  Â  debugPanel: document.getElementById('debugPanel'),
Â  Â  Â  Â  Â  neuralActivityDebug: document.getElementById('neuralActivity'),
Â  Â  Â  Â  Â  activeGenesDebug: document.getElementById('activeGenes'),
Â  Â  Â  Â  Â  fitnessScoreDebug: document.getElementById('fitnessScore'),
Â  Â  Â  Â  Â  lastMutationDebug: document.getElementById('lastMutation'),
Â  Â  Â  Â  Â  performanceDebug: document.getElementById('performance')
Â  Â  Â  Â  };
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Advanced AI Systems
Â  Â  Â  Â  this.neuralNetwork = new NeuralNetwork(12, 8, 6); // Input: motion, bpm, evolution progress, etc. Output: musical parameters
Â  Â  Â  Â  this.evolutionEngine = new EvolutionEngine();
Â  Â  Â  Â  this.patternGenome = new PatternGenome();
Â  Â  Â  Â  this.harmonicGenome = new HarmonicGenome();
Â  Â  Â  Â  this.temporalGenome = new TemporalGenome();
Â  Â  Â  Â  this.fitnessEvaluator = new FitnessEvaluator();
Â  Â  Â  Â  this.performanceMonitor = new PerformanceMonitor();
Â  Â  Â  Â  this.bacterialColony = new BacterialColony();
Â  Â  Â  Â  this.conjugationEvents = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Musical Elements
Â  Â  Â  Â  this.baseFrequency = 220; // A3
Â  Â  Â  Â  this.scale = [0, 2, 4, 5, 7, 9, 11, 12]; // Major scale semitone intervals
Â  Â  Â  Â  this.modes = {
Â  Â  Â  Â  Â  dorian: [0, 2, 3, 5, 7, 9, 10],
Â  Â  Â  Â  Â  phrygian: [0, 1, 3, 5, 7, 8, 10],
Â  Â  Â  Â  Â  lydian: [0, 2, 4, 6, 7, 9, 11],
Â  Â  Â  Â  Â  mixolydian: [0, 2, 4, 5, 7, 9, 10]
Â  Â  Â  Â  };
Â  Â  Â  Â  this.currentMode = 'major';
Â  Â  Â  Â  this.harmonyProgression = ['major', 'minor', 'dorian', 'mixolydian']; // Example progression
Â  Â  Â  Â  this.currentHarmonyIndex = 0;
Â  Â  Â  Â  this.init();
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  init() {
Â  Â  Â  Â  this.setupEventListeners();
Â  Â  Â  Â  this.updateStatus('ðŸŽµ Ready to generate music. Click Start!');
Â  Â  Â  Â  this.createParticles();
Â  Â  Â  Â  this.startNeuralVisualization(); // Start neural network visualization early
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  setupEventListeners() {
Â  Â  Â  Â  this.elements.startBtn.addEventListener('click', () => this.start());
Â  Â  Â  Â  this.elements.autonomySlider.addEventListener('input', (e) => {
Â  Â  Â  Â  Â  this.autonomyLevel = parseInt(e.target.value);
Â  Â  Â  Â  Â  this.updateDebugPanel();
Â  Â  Â  Â  });
Â  Â  Â  Â  this.elements.learningRateSlider.addEventListener('input', (e) => {
Â  Â  Â  Â  Â  this.learningRate = parseInt(e.target.value);
Â  Â  Â  Â  Â  this.neuralNetwork.setLearningRate(this.learningRate / 100);
Â  Â  Â  Â  Â  this.updateDebugPanel();
Â  Â  Â  Â  });
Â  Â  Â  Â  this.elements.mutationRateSlider.addEventListener('input', (e) => {
Â  Â  Â  Â  Â  this.mutationRate = parseInt(e.target.value);
Â  Â  Â  Â  Â  this.evolutionEngine.setMutationRate(this.mutationRate / 100);
Â  Â  Â  Â  Â  this.updateDebugPanel();
Â  Â  Â  Â  });
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (window.DeviceMotionEvent) {
Â  Â  Â  Â  Â  window.addEventListener('devicemotion', (e) => this.handleDeviceMotion(e));
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  this.showError("DeviceMotionEvent not supported. Motion sensing will be simulated.");
Â  Â  Â  Â  Â  this.simulateMotion();
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  async start() {
Â  Â  Â  Â  if (this.active) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  this.ctx = new (window.AudioContext || window.webkitAudioContext)();
Â  Â  Â  Â  Â  if (this.ctx.state === 'suspended') {
Â  Â  Â  Â  Â  Â  await this.ctx.resume();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  this.panner = this.ctx.createPanner();
Â  Â  Â  Â  Â  this.panner.panningModel = 'HRTF';
Â  Â  Â  Â  Â  this.panner.distanceModel = 'inverse';
Â  Â  Â  Â  Â  this.panner.refDistance = 1;
Â  Â  Â  Â  Â  this.panner.maxDistance = 10000;
Â  Â  Â  Â  Â  this.panner.rolloffFactor = 1;
Â  Â  Â  Â  Â  this.panner.coneInnerAngle = 360;
Â  Â  Â  Â  Â  this.panner.coneOuterAngle = 0;
Â  Â  Â  Â  Â  this.panner.coneOuterGain = 0;
Â  Â  Â  Â  Â  this.panner.connect(this.ctx.destination);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  this.gainNode = this.ctx.createGain();
Â  Â  Â  Â  Â  this.gainNode.gain.value = 0.7;
Â  Â  Â  Â  Â  this.panner.connect(this.gainNode);
Â  Â  Â  Â  Â  this.gainNode.connect(this.ctx.destination);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  this.reverb = this.ctx.createConvolver();
Â  Â  Â  Â  Â  // Load impulse response for reverb (placeholder)
Â  Â  Â  Â  Â  const impulseResponseUrl = 'https://webaudio.github.io/web-audio-api/samples/audio/impulse-responses/small-room-3.wav';
Â  Â  Â  Â  Â  const response = await fetch(impulseResponseUrl);
Â  Â  Â  Â  Â  const arrayBuffer = await response.arrayBuffer();
Â  Â  Â  Â  Â  this.reverb.buffer = await this.ctx.decodeAudioData(arrayBuffer);
Â  Â  Â  Â  Â  this.panner.connect(this.reverb);
Â  Â  Â  Â  Â  this.reverb.connect(this.gainNode);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  this.elements.startBtn.classList.add('hidden');
Â  Â  Â  Â  Â  this.elements.tagline.classList.add('hidden');
Â  Â  Â  Â  Â  this.elements.viz.classList.remove('hidden');
Â  Â  Â  Â  Â  this.elements.stats.classList.remove('hidden');
Â  Â  Â  Â  Â  this.elements.controls.classList.remove('hidden');
Â  Â  Â  Â  Â  this.elements.evolutionDisplay.classList.remove('hidden');
Â  Â  Â  Â  Â  this.elements.status.classList.remove('hidden');
Â  Â  Â  Â  Â  this.elements.particles.classList.add('active');
Â  Â  Â  Â  Â  this.active = true;
Â  Â  Â  Â  Â  this.updateStatus('ðŸš€ GUMP Activated. Sensing motion...');
Â  Â  Â  Â  Â  this.startQuantumGroove();
Â  Â  Â  Â  Â  this.animate();
Â  Â  Â  Â  Â  this.startSensors();
Â  Â  Â  Â  } catch (e) {
Â  Â  Â  Â  Â  this.showError('AudioContext error: ' + e.message);
Â  Â  Â  Â  Â  console.error(e);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  startSensors() {
Â  Â  Â  Â  // Start gyroscope/accelerometer or simulated motion
Â  Â  Â  Â  // The event listener is already set up in init, this just ensures updates.
Â  Â  Â  Â  setInterval(() => {
Â  Â  Â  Â  Â  this.reflect();
Â  Â  Â  Â  Â  this.updateDebugPanel();
Â  Â  Â  Â  }, 100); // AI reflection interval
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  handleDeviceMotion(event) {
Â  Â  Â  Â  const acc = event.accelerationIncludingGravity;
Â  Â  Â  Â  if (!acc || (acc.x === null && acc.y === null && acc.z === null)) {
Â  Â  Â  Â  Â  // Sometimes device motion fires but with null values, ignore these
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  const currentX = acc.x || 0;
Â  Â  Â  Â  const currentY = acc.y || 0;
Â  Â  Â  Â  const currentZ = acc.z || 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const deltaX = Math.abs(currentX - this.last.x);
Â  Â  Â  Â  const deltaY = Math.abs(currentY - this.last.y);
Â  Â  Â  Â  const deltaZ = Math.abs(currentZ - this.last.z);
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.motion = (deltaX + deltaY + deltaZ) * 5; // Scale motion for more impact
Â  Â  Â  Â  this.motion = Math.min(100, this.motion); // Cap motion value
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.last.x = currentX;
Â  Â  Â  Â  this.last.y = currentY;
Â  Â  Â  Â  this.last.z = currentZ;
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.lastMotionTime = Date.now();
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  simulateMotion() {
Â  Â  Â  Â  setInterval(() => {
Â  Â  Â  Â  Â  if (this.active) {
Â  Â  Â  Â  Â  Â  this.motion = Math.sin(Date.now() * 0.001) * 50 + 50; // Simple sine wave motion
Â  Â  Â  Â  Â  Â  this.motion = Math.max(0, Math.min(100, this.motion));
Â  Â  Â  Â  Â  Â  this.lastMotionTime = Date.now();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 100);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  updateOrbPosition() {
Â  Â  Â  Â  // Map motion to a 3D position for the orb and panner
Â  Â  Â  Â  const maxX = 2; // Max spatial X
Â  Â  Â  Â  const maxY = 2; // Max spatial Y
Â  Â  Â  Â  const maxZ = 2; // Max spatial Z
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Simple mapping: motion influences Z, and subtle X/Y based on time
Â  Â  Â  Â  this.pos.x = maxX * (Math.sin(Date.now() * 0.0005) * 0.5 + 0.5);
Â  Â  Â  Â  this.pos.y = maxY * (Math.cos(Date.now() * 0.0007) * 0.5 + 0.5);
Â  Â  Â  Â  this.pos.z = maxZ * (this.motion / 100);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (this.panner) {
Â  Â  Â  Â  Â  this.panner.positionX.setValueAtTime(this.pos.x, this.ctx.currentTime);
Â  Â  Â  Â  Â  this.panner.positionY.setValueAtTime(this.pos.y, this.ctx.currentTime);
Â  Â  Â  Â  Â  this.panner.positionZ.setValueAtTime(this.pos.z, this.ctx.currentTime);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.elements.orb.style.transform = `translate(-50%, -50%) translate3d(${this.pos.x * 50}px, ${this.pos.y * 50}px, 0)`;
Â  Â  Â  Â  this.elements.orb.style.width = `${80 + this.motion * 0.5}px`;
Â  Â  Â  Â  this.elements.orb.style.height = `${80 + this.motion * 0.5}px`;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  updateWaveform() {
Â  Â  Â  Â  const waveformDiv = this.elements.waveform;
Â  Â  Â  Â  if (waveformDiv.children.length === 0) {
Â  Â  Â  Â  Â  for (let i = 0; i < 30; i++) {
Â  Â  Â  Â  Â  Â  const bar = document.createElement('div');
Â  Â  Â  Â  Â  Â  bar.classList.add('wave-bar');
Â  Â  Â  Â  Â  Â  waveformDiv.appendChild(bar);
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  Array.from(waveformDiv.children).forEach(bar => {
Â  Â  Â  Â  Â  const height = (Math.sin(Date.now() * 0.005 + Math.random() * 5) * 0.5 + 0.5) * (50 + this.motion * 0.5) + 10;
Â  Â  Â  Â  Â  bar.style.height = `${height}%`;
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  animate() {
Â  Â  Â  Â  if (!this.active) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.performanceMonitor.update();
Â  Â  Â  Â  this.updateOrbPosition();
Â  Â  Â  Â  this.updateWaveform();
Â  Â  Â  Â  this.updateDebugPanel();
Â  Â  Â  Â Â 
Â  Â  Â  Â  requestAnimationFrame(() => this.animate());
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  updateStatus(message, isError = false) {
Â  Â  Â  Â  const statusEl = this.elements.status;
Â  Â  Â  Â  const errorEl = this.elements.error;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (isError) {
Â  Â  Â  Â  Â  statusEl.classList.add('hidden');
Â  Â  Â  Â  Â  errorEl.classList.remove('hidden');
Â  Â  Â  Â  Â  errorEl.textContent = `Error: ${message}`;
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  errorEl.classList.add('hidden');
Â  Â  Â  Â  Â  statusEl.classList.remove('hidden');
Â  Â  Â  Â  Â  statusEl.textContent = message;
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  showError(message) {
Â  Â  Â  Â  this.updateStatus(message, true);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  toggleDebug() {
Â  Â  Â  Â  this.debugMode = !this.debugMode;
Â  Â  Â  Â  this.elements.debugPanel.classList.toggle('active', this.debugMode);
Â  Â  Â  Â  this.updateStatus(`Debug mode: ${this.debugMode ? 'ON' : 'OFF'}`);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  updateDebugPanel() {
Â  Â  Â  Â  if (!this.debugMode) return;
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.elements.neuralActivityDebug.textContent = this.motion.toFixed(2); // Using motion as a proxy for neural activity
Â  Â  Â  Â  this.elements.activeGenesDebug.textContent = `${this.patternGenome.evolutionProgress.toFixed(0)}% | ${this.harmonicGenome.evolutionProgress.toFixed(0)}% | ${this.temporalGenome.evolutionProgress.toFixed(0)}%`;
Â  Â  Â  Â  this.elements.fitnessScoreDebug.textContent = this.fitnessEvaluator.history.length > 0 ? this.fitnessEvaluator.history[this.fitnessEvaluator.history.length - 1].toFixed(2) : 'N/A';
Â  Â  Â  Â  this.elements.lastMutationDebug.textContent = this.evolutionEngine.currentGeneration > 0 ? `Gen ${this.evolutionEngine.currentGeneration}` : 'None';
Â  Â  Â  Â  this.elements.performanceDebug.textContent = `${this.performanceMonitor.getFPS()} FPS`;
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  startQuantumGroove() {
Â  Â  Â  Â  if (!this.ctx) {
Â  Â  Â  Â  Â  this.showError("AudioContext not initialized. Cannot start groove.");
Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Initialize sound agents for different parts
Â  Â  Â  Â  this.soundAgents.set('kick', new SoundAgent(this.ctx, 'sine', 60, {x: -1, y: 0, z: 0}, this.panner));
Â  Â  Â  Â  this.soundAgents.set('snare', new SoundAgent(this.ctx, 'triangle', 200, {x: 1, y: 0, z: 0}, this.panner));
Â  Â  Â  Â  this.soundAgents.set('hihat', new SoundAgent(this.ctx, 'sawtooth', 800, {x: 0, y: 1, z: 0}, this.panner));
Â  Â  Â  Â  this.soundAgents.set('bass', new SoundAgent(this.ctx, 'square', 80, {x: 0, y: -1, z: 0}, this.panner));
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Main musical loop
Â  Â  Â  Â  setInterval(() => {
Â  Â  Â  Â  Â  if (!this.active) return;
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const currentBeatTime = this.ctx.currentTime;
Â  Â  Â  Â  Â  const beatsPerMeasure = 8; // Assuming 4/4 time, 8 steps for a typical pattern
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Update BPM based on motion (simple mapping for now)
Â  Â  Â  Â  Â  this.bpm = 95 + (this.motion * 0.5); // Range 95-145
Â  Â  Â  Â  Â  this.strideInterval = (60 / this.bpm) * 1000 / (this.temporalGenome.timings.subdivision / 4); // ms per step
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  if (currentBeatTime * 1000 - this.lastStrideTime >= this.strideInterval) {
Â  Â  Â  Â  Â  Â  this.lastStrideTime = currentBeatTime * 1000;
Â  Â  Â  Â  Â  Â  this.step = (this.step + 1) % beatsPerMeasure;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  this.elements.bpmStat.textContent = this.bpm.toFixed(0);
Â  Â  Â  Â  Â  Â  this.elements.motionStat.textContent = this.motion.toFixed(0);
Â  Â  Â  Â  Â  Â  this.elements.grooveStat.textContent = this.state;
Â  Â  Â  Â  Â  Â  this.elements.generationStat.textContent = this.evolutionEngine.currentGeneration;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  this.triggerMusicalEvents();
Â  Â  Â  Â  Â  Â  this.checkTranscendentState();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }, 50); // Check for step update every 50ms
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  triggerMusicalEvents() {
Â  Â  Â  Â  const kickPattern = this.patternGenome.getPattern('kick');
Â  Â  Â  Â  const snarePattern = this.patternGenome.getPattern('snare');
Â  Â  Â  Â  const hihatPattern = this.patternGenome.getPattern('hihat');
Â  Â  Â  Â  const bassPattern = this.patternGenome.getPattern('bass');
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Play sounds based on patterns
Â  Â  Â  Â  if (kickPattern[this.step] === 1) this.soundAgents.get('kick').play(1);
Â  Â  Â  Â  if (snarePattern[this.step] === 1) this.soundAgents.get('snare').play(0.8);
Â  Â  Â  Â  if (hihatPattern[this.step] === 1) this.soundAgents.get('hihat').play(0.6);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Bassline logic
Â  Â  Â  Â  if (bassPattern[this.step] === 1) {
Â  Â  Â  Â  Â  const currentHarmony = this.harmonicGenome.harmonies[this.currentMode];
Â  Â  Â  Â  Â  const noteIndex = Math.floor(Math.random() * currentHarmony.length);
Â  Â  Â  Â  Â  const frequency = this.baseFrequency * Math.pow(2, (currentHarmony[noteIndex] + 12 * Math.floor(Math.random() * 2)) / 12); // Add some octave variation
Â  Â  Â  Â  Â  this.soundAgents.get('bass').setFrequency(frequency);
Â  Â  Â  Â  Â  this.soundAgents.get('bass').play(0.9);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Transcendent effects
Â  Â  Â  Â  if (this.transcendent) {
Â  Â  Â  Â  Â  this.transcendentIntensity = Math.min(100, this.transcendentIntensity + 1);
Â  Â  Â  Â  Â  if (this.step % 4 === 0) { // Every 4 steps in transcendent mode
Â  Â  Â  Â  Â  Â  this.etherealKick();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  this.elements.orb.classList.add('transcendent');
Â  Â  Â  Â  Â  this.elements.spatialViz.classList.add('transcendent');
Â  Â  Â  Â  Â  this.elements.waveform.classList.add('transcendent');
Â  Â  Â  Â  Â  document.body.classList.add('transcendent');
Â  Â  Â  Â  Â  if (this.gainNode) this.gainNode.gain.setValueAtTime(0.9, this.ctx.currentTime); // Increase overall volume
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  this.transcendentIntensity = Math.max(0, this.transcendentIntensity - 2);
Â  Â  Â  Â  Â  this.elements.orb.classList.remove('transcendent');
Â  Â  Â  Â  Â  this.elements.spatialViz.classList.remove('transcendent');
Â  Â  Â  Â  Â  this.elements.waveform.classList.remove('transcendent');
Â  Â  Â  Â  Â  document.body.classList.remove('transcendent');
Â  Â  Â  Â  Â  if (this.gainNode) this.gainNode.gain.setValueAtTime(0.7, this.ctx.currentTime); // Normal volume
Â  Â  Â  Â  Â  if (this.step % 8 === 0 && Math.random() < 0.2) { // Occasional unison drop
Â  Â  Â  Â  Â  Â  this.unisonDrop();
Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  checkTranscendentState() {
Â  Â  Â  Â  const currentMotion = this.motion;
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (currentMotion > 80 && !this.transcendent) {
Â  Â  Â  Â  Â  this.transcendent = true;
Â  Â  Â  Â  Â  this.updateStatus('âœ¨ Entering Transcendent State! âœ¨');
Â  Â  Â  Â  Â  this.state = 'TRANSCENDENT';
Â  Â  Â  Â  Â  this.resetEvolution(); // Reset evolution on state change for new dynamics
Â  Â  Â  Â  } else if (currentMotion < 60 && this.transcendent) {
Â  Â  Â  Â  Â  this.transcendent = false;
Â  Â  Â  Â  Â  this.updateStatus('ðŸŽµ Returning to Groove...');
Â  Â  Â  Â  Â  this.state = 'GROOVE';
Â  Â  Â  Â  Â  this.resetEvolution();
Â  Â  Â  Â  } else if (currentMotion > 30 && !this.transcendent) {
Â  Â  Â  Â  Â  this.state = 'GROOVE';
Â  Â  Â  Â  } else {
Â  Â  Â  Â  Â  this.state = 'CHILL';
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  etherealKick() {
Â  Â  Â  Â  if (!this.ctx) return;
Â  Â  Â  Â  const now = this.ctx.currentTime;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const osc = this.ctx.createOscillator();
Â  Â  Â  Â  const gain = this.ctx.createGain();
Â  Â  Â  Â  osc.connect(gain);
Â  Â  Â  Â  gain.connect(this.gainNode); // Connect to main output after panner
Â  Â  Â  Â Â 
Â  Â  Â  Â  osc.type = 'triangle';
Â  Â  Â  Â  osc.frequency.setValueAtTime(100 + Math.random() * 50, now);
Â  Â  Â  Â  gain.gain.setValueAtTime(0, now);
Â  Â  Â  Â  gain.gain.linearRampToValueAtTime(0.7, now + 0.01);
Â  Â  Â  Â  gain.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
Â  Â  Â  Â  osc.start(now);
Â  Â  Â  Â  osc.stop(now + 1.5);
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  unisonDrop() {
Â  Â  Â  Â  if (!this.ctx) return;
Â  Â  Â  Â  const now = this.ctx.currentTime;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const frequencies = [this.baseFrequency, this.baseFrequency * 1.5, this.baseFrequency * 2]; // Octave and fifth
Â  Â  Â  Â  frequencies.forEach(freq => {
Â  Â  Â  Â  Â  const osc = this.ctx.createOscillator();
Â  Â  Â  Â  Â  const gain = this.ctx.createGain();
Â  Â  Â  Â  Â  osc.connect(gain);
Â  Â  Â  Â  Â  gain.connect(this.gainNode);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  osc.type = 'sawtooth';
Â  Â  Â  Â  Â  osc.frequency.setValueAtTime(freq, now);
Â  Â  Â  Â  Â  gain.gain.setValueAtTime(0, now);
Â  Â  Â  Â  Â  gain.gain.linearRampToValueAtTime(0.6, now + 0.02);
Â  Â  Â  Â  Â  gain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);
Â  Â  Â  Â  Â  osc.start(now);
Â  Â  Â  Â  Â  osc.stop(now + 0.8);
Â  Â  Â  Â  });
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  reflect() {
Â  Â  Â  Â  // This is the AI's "thinking" cycle
Â  Â  Â  Â  const fitness = this.fitnessEvaluator.evaluate(
Â  Â  Â  Â  Â  this.motion,
Â  Â  Â  Â  Â  this.bpm,
Â  Â  Â  Â  Â  this.harmonicGenome.evolutionProgress,
Â  Â  Â  Â  Â  this.patternGenome.evolutionProgress
Â  Â  Â  Â  );
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Neural Network input: motion, bpm, current evolution progress, autonomy level
Â  Â  Â  Â  const inputs = [[this.motion / 100], [this.bpm / 200], [this.patternGenome.evolutionProgress / 100],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [this.harmonicGenome.evolutionProgress / 100], [this.temporalGenome.evolutionProgress / 100],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [this.autonomyLevel / 100], [this.transcendent ? 1 : 0], [this.transcendentIntensity / 100],
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  [this.envDensity], [this.songSection === 'A1' ? 1 : 0], [this.songSection === 'B1' ? 1 : 0], [this.layerProgress / 100]
Â  Â  Â  Â  ];
Â  Â  Â  Â  const outputs = this.neuralNetwork.predict(inputs);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Map NN outputs to control parameters for genomes
Â  Â  Â  Â  const patternRhythm = outputs[0][0]; // Between 0 and 1
Â  Â  Â  Â  const patternVariance = outputs[1][0] * 20; // 0-20
Â  Â  Â  Â  const harmonyEmotion = outputs[2][0] * 100; // 0-100
Â  Â  Â  Â  const harmonyEnergy = outputs[3][0] * 100; // 0-100
Â  Â  Â  Â  const temporalMotionInfluence = outputs[4][0]; // 0-1
Â  Â  Â  Â  const temporalBPMInfluence = outputs[5][0]; // 0-1
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Autonomy control: Blend AI output with fixed values based on autonomyLevel
Â  Â  Â  Â  const autonomyFactor = this.autonomyLevel / 100;
Â  Â  Â  Â Â 
Â  Â  Â  Â  const effectivePatternRhythm = (patternRhythm * autonomyFactor) + (0.5 * (1 - autonomyFactor));
Â  Â  Â  Â  const effectivePatternVariance = (patternVariance * autonomyFactor) + (5 * (1 - autonomyFactor));
Â  Â  Â  Â  const effectiveHarmonyEmotion = (harmonyEmotion * autonomyFactor) + (50 * (1 - autonomyFactor));
Â  Â  Â  Â  const effectiveHarmonyEnergy = (harmonyEnergy * autonomyFactor) + (50 * (1 - autonomyFactor));
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.patternGenome.evolvePattern('kick', effectivePatternRhythm, effectivePatternVariance);
Â  Â  Â  Â  this.patternGenome.evolvePattern('snare', effectivePatternRhythm, effectivePatternVariance);
Â  Â  Â  Â  this.patternGenome.evolvePattern('hihat', effectivePatternRhythm * 1.2, effectivePatternVariance * 0.8);
Â  Â  Â  Â  this.patternGenome.evolvePattern('bass', effectivePatternRhythm * 0.8, effectivePatternVariance * 1.5);
Â  Â  Â  Â Â 
Â  Â  Â  Â  this.harmonicGenome.evolveHarmony(effectiveHarmonyEmotion, effectiveHarmonyEnergy);
Â  Â  Â  Â  this.temporalGenome.evolveTiming(this.motion * temporalMotionInfluence, this.bpm * temporalBPMInfluence);
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Update evolution progress bars
Â  Â  Â  Â  this.elements.patternEvolution.style.width = `${this.patternGenome.evolutionProgress}%`;
Â  Â  Â  Â  this.elements.harmonicEvolution.style.width = `${this.harmonicGenome.evolutionProgress}%`;
Â  Â  Â  Â  this.elements.temporalEvolution.style.width = `${this.temporalGenome.evolutionProgress}%`;
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Genetic algorithm evolution (on certain intervals or conditions)
Â  Â  Â  Â  if (this.evolutionEngine.currentGeneration % 10 === 0 && this.motion > 50) {
Â  Â  Â  Â  Â  // Example: evolve population of pattern genomes
Â  Â  Â  Â  Â  const population = [this.patternGenome.patterns, this.harmonicGenome.harmonies, this.temporalGenome.timings];
Â  Â  Â  Â  Â  const fitnesses = [
Â  Â  Â  Â  Â  Â  this.fitnessEvaluator.evaluatePattern(this.patternGenome.patterns),
Â  Â  Â  Â  Â  Â  this.fitnessEvaluator.evaluateHarmony(this.harmonicGenome.harmonies),
Â  Â  Â  Â  Â  Â  this.fitnessEvaluator.evaluateRhythm(this.temporalGenome.timings)
Â  Â  Â  Â  Â  ];
Â  Â  Â  Â  Â  const newPopulation = this.evolutionEngine.evolve(population, fitnesses);
Â  Â  Â  Â  Â  // Reassign evolved genomes (simplified for example)
Â  Â  Â  Â  Â  this.patternGenome.patterns = newPopulation[0];
Â  Â  Â  Â  Â  this.harmonicGenome.harmonies = newPopulation[1];
Â  Â  Â  Â  Â  this.temporalGenome.timings = newPopulation[2];
Â  Â  Â  Â  Â  this.generation = this.evolutionEngine.currentGeneration;
Â  Â  Â  Â  Â  this.updateStatus(`ðŸ§¬ Generation ${this.generation} evolved!`);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Bacterial conjugation (for cross-genome influence)
Â  Â  Â  Â  if (Math.random() < 0.05 && this.conjugationEvents < 10) { // Limited conjugation events
Â  Â  Â  Â  Â  this.bacterialColony.bacteria.push(
Â  Â  Â  Â  Â  Â  { pattern: this.patternGenome.patterns, harmony: this.harmonicGenome.harmonies, fitness: fitness }
Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  this.bacterialColony.conjugate();
Â  Â  Â  Â  Â  this.conjugationEvents++;
Â  Â  Â  Â  Â  this.updateStatus(`ðŸ¦  Bacterial Conjugation Event! Total: ${this.conjugationEvents}`);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  resetEvolution() {
Â  Â  Â  Â  this.patternGenome.evolutionProgress = 0;
Â  Â  Â  Â  this.harmonicGenome.evolutionProgress = 0;
Â  Â  Â  Â  this.temporalGenome.evolutionProgress = 0;
Â  Â  Â  Â  this.evolutionEngine.currentGeneration = 0;
Â  Â  Â  Â  this.elements.patternEvolution.style.width = '0%';
Â  Â  Â  Â  this.elements.harmonicEvolution.style.width = '0%';
Â  Â  Â  Â  this.elements.temporalEvolution.style.width = '0%';
Â  Â  Â  Â  this.conjugationEvents = 0;
Â  Â  Â  Â  this.updateStatus('ðŸ”„ Evolution reset for new sonic journey!');
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  createParticles() {
Â  Â  Â  Â  const particlesContainer = this.elements.particles;
Â  Â  Â  Â  for (let i = 0; i < 50; i++) {
Â  Â  Â  Â  Â  const particle = document.createElement('div');
Â  Â  Â  Â  Â  particle.classList.add('particle');
Â  Â  Â  Â  Â  particle.style.left = `${Math.random() * 100}vw`;
Â  Â  Â  Â  Â  particle.style.animationDuration = `${5 + Math.random() * 5}s`;
Â  Â  Â  Â  Â  particle.style.animationDelay = `${Math.random() * 7}s`;
Â  Â  Â  Â  Â  particlesContainer.appendChild(particle);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  Â Â 
Â  Â  Â  startNeuralVisualization() {
Â  Â  Â  Â  const neuralNetworkDiv = document.getElementById('neuralNetwork');
Â  Â  Â  Â  const numNodes = 15; // Total nodes for visualization
Â  Â  Â  Â  const nodes = [];
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (let i = 0; i < numNodes; i++) {
Â  Â  Â  Â  Â  const node = document.createElement('div');
Â  Â  Â  Â  Â  node.classList.add('neural-node');
Â  Â  Â  Â  Â  node.style.left = `${Math.random() * 100}%`;
Â  Â  Â  Â  Â  node.style.top = `${Math.random() * 100}%`;
Â  Â  Â  Â  Â  node.style.animationDelay = `${Math.random() * 2}s`;
Â  Â  Â  Â  Â  neuralNetworkDiv.appendChild(node);
Â  Â  Â  Â  Â  nodes.push(node);
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Create some connections
Â  Â  Â  Â  for (let i = 0; i < numNodes / 2; i++) {
Â  Â  Â  Â  Â  const node1 = nodes[Math.floor(Math.random() * numNodes)];
Â  Â  Â  Â  Â  const node2 = nodes[Math.floor(Math.random() * numNodes)];
Â  Â  Â  Â  Â  if (node1 === node2) continue;
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  const connection = document.createElement('div');
Â  Â  Â  Â  Â  connection.classList.add('neural-connection');
Â  Â  Â  Â  Â  neuralNetworkDiv.appendChild(connection);
Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  // Position connections dynamically (simplified for visual effect)
Â  Â  Â  Â  Â  const updateConnection = () => {
Â  Â  Â  Â  Â  Â  const rect1 = node1.getBoundingClientRect();
Â  Â  Â  Â  Â  Â  const rect2 = node2.getBoundingClientRect();
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const x1 = rect1.left + rect1.width / 2;
Â  Â  Â  Â  Â  Â  const y1 = rect1.top + rect1.height / 2;
Â  Â  Â  Â  Â  Â  const x2 = rect2.left + rect2.width / 2;
Â  Â  Â  Â  Â  Â  const y2 = rect2.top + rect2.height / 2;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  const length = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
Â  Â  Â  Â  Â  Â  const angle = Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI;
Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  connection.style.width = `${length}px`;
Â  Â  Â  Â  Â  Â  connection.style.transform = `translate(${x1}px, ${y1}px) rotate(${angle}deg)`;
Â  Â  Â  Â  Â  };
Â  Â  Â  Â  Â  updateConnection();
Â  Â  Â  Â  Â  // Update connections if window resizes or nodes move
Â  Â  Â  Â  Â  new ResizeObserver(updateConnection).observe(neuralNetworkDiv);
Â  Â  Â  Â  }
Â  Â  Â  }
Â  Â  }
Â  Â Â 
Â  Â  // Instantiate GUMP when the DOM is ready
Â  Â  document.addEventListener('DOMContentLoaded', () => {
Â  Â  Â  window.gumpApp = new QuantumGUMP();
Â  Â  });
Â  </script>
</body>
</html>
