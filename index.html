<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0, minimum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-fullscreen">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            position: fixed;
            background: #000;
        }

        body {
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(ellipse at center, #111 0%, #000 70%);
            touch-action: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            color: #fff;
        }

        .dot {
            position: absolute;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.95) 0%, rgba(255,255,255,0.5) 60%, transparent 100%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 40px rgba(255,255,255,0.6), inset 0 0 10px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 20;
            will-change: transform, box-shadow, background;
            transition: all 0.15s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .dot.pulse {
            animation: pulse 0.6s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .dot.sampling {
            background: radial-gradient(circle, rgba(255,80,80,0.95) 0%, rgba(255,40,40,0.5) 60%, transparent 100%);
            box-shadow: 0 0 50px rgba(255,80,80,0.8), inset 0 0 15px rgba(255,100,100,0.4);
            animation: sample 1.8s ease-in-out infinite;
        }

        @keyframes pulse {
            0% { 
                transform: translate(-50%, -50%) scale(1); 
                box-shadow: 0 0 40px rgba(255,255,255,0.6), inset 0 0 10px rgba(255,255,255,0.3);
            }
            50% { 
                transform: translate(-50%, -50%) scale(6); 
                box-shadow: 0 0 80px rgba(255,255,255,0.9), inset 0 0 20px rgba(255,255,255,0.6);
            }
            100% { 
                transform: translate(-50%, -50%) scale(1); 
                box-shadow: 0 0 40px rgba(255,255,255,0.6), inset 0 0 10px rgba(255,255,255,0.3);
            }
        }

        @keyframes sample {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.5); 
                box-shadow: 0 0 60px rgba(255,80,80,1), inset 0 0 20px rgba(255,120,120,0.6);
            }
        }

        .particle {
            position: absolute;
            width: 1px;
            height: 1px;
            background: rgba(255,255,255,0.7);
            border-radius: 50%;
            pointer-events: none;
            will-change: transform, opacity;
        }

        .start-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.98);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            backdrop-filter: blur(20px);
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        .start-screen.hidden {
            opacity: 0;
            visibility: hidden;
        }

        .start-btn {
            padding: 24px 48px;
            background: rgba(255,255,255,0.08);
            border: 2px solid rgba(255,255,255,0.25);
            border-radius: 60px;
            color: rgba(255,255,255,0.95);
            font-size: 20px;
            font-weight: 600;
            letter-spacing: 2px;
            cursor: pointer;
            transition: all 0.25s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            text-transform: uppercase;
        }

        .start-btn:active {
            transform: scale(0.94);
            background: rgba(255,255,255,0.15);
            border-color: rgba(255,255,255,0.4);
            box-shadow: 0 0 40px rgba(255,255,255,0.3);
        }

        .start-hint {
            margin-top: 40px;
            font-size: 15px;
            opacity: 0.6;
            text-align: center;
            line-height: 1.6;
            max-width: 280px;
        }

        .evolution-rings {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: 10;
        }

        .ring {
            position: absolute;
            border: 1px solid rgba(255,255,255,0.03);
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0;
            transition: all 3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            will-change: opacity, transform;
        }

        .ring.active {
            opacity: 0.25;
            border-color: rgba(255,255,255,0.08);
        }

        .audio-viz {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 70%;
            height: 3px;
            background: rgba(255,255,255,0.03);
            border-radius: 2px;
            overflow: hidden;
        }

        .viz-bar {
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(255,80,80,0.8) 0%, 
                rgba(255,160,80,0.8) 25%, 
                rgba(80,255,160,0.8) 50%, 
                rgba(80,160,255,0.8) 75%,
                rgba(160,80,255,0.8) 100%);
            width: 0%;
            transition: width 0.08s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: width;
            border-radius: 2px;
        }

        .ripple {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 60px;
            height: 60px;
            border: 2px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform, opacity;
            z-index: 15;
        }

        .ripple.active {
            opacity: 0.8;
            transform: translate(-50%, -50%) scale(4);
            border-color: rgba(255,255,255,0.02);
        }

        @media (max-width: 375px) {
            .dot { width: 18px; height: 18px; }
            .start-btn { padding: 20px 40px; font-size: 18px; }
            .audio-viz { width: 80%; }
        }

        @media (max-height: 667px) {
            .start-hint { font-size: 14px; margin-top: 30px; }
            .audio-viz { bottom: 20px; }
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-btn" id="startBtn">Let's Go</div>
        <div class="start-hint">Move to shape the rhythm<br>Let your world become music</div>
    </div>

    <div class="dot" id="dot"></div>
    
    <div class="evolution-rings">
        <div class="ring" style="width: 100px; height: 100px;"></div>
        <div class="ring" style="width: 200px; height: 200px;"></div>
        <div class="ring" style="width: 300px; height: 300px;"></div>
        <div class="ring" style="width: 400px; height: 400px;"></div>
    </div>

    <div class="ripple" id="ripple"></div>

    <div class="audio-viz">
        <div class="viz-bar" id="vizBar"></div>
    </div>

    <script>
        'use strict';

        // High-performance object pool for particles
        class ParticlePool {
            constructor(size = 15) {
                this.pool = [];
                this.active = [];
                this.size = size;
                this.init();
            }

            init() {
                for (let i = 0; i < this.size; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    document.body.appendChild(particle);
                    
                    this.pool.push({
                        element: particle,
                        x: 0, y: 0, vx: 0, vy: 0,
                        life: 0, maxLife: 1,
                        active: false
                    });
                }
            }

            spawn(x, y, vx, vy) {
                const particle = this.pool.find(p => !p.active);
                if (!particle) return null;

                particle.active = true;
                particle.x = x;
                particle.y = y;
                particle.vx = vx;
                particle.vy = vy;
                particle.life = particle.maxLife;
                
                this.active.push(particle);
                return particle;
            }

            update(deltaTime, audioData, motionData) {
                const width = window.innerWidth;
                const height = window.innerHeight;

                for (let i = this.active.length - 1; i >= 0; i--) {
                    const p = this.active[i];
                    
                    // Physics
                    p.x += p.vx * deltaTime;
                    p.y += p.vy * deltaTime;
                    
                    // Audio influence
                    const audioForce = audioData.overall * 50;
                    p.vx += (Math.random() - 0.5) * audioForce * deltaTime;
                    p.vy += (Math.random() - 0.5) * audioForce * deltaTime;
                    
                    // Motion influence
                    if (motionData) {
                        p.vx += motionData.x * 0.1 * deltaTime;
                        p.vy += motionData.y * 0.1 * deltaTime;
                    }
                    
                    // Friction
                    p.vx *= 0.98;
                    p.vy *= 0.98;
                    
                    // Boundaries
                    if (p.x < 0 || p.x > width) p.vx *= -0.8;
                    if (p.y < 0 || p.y > height) p.vy *= -0.8;
                    p.x = Math.max(0, Math.min(width, p.x));
                    p.y = Math.max(0, Math.min(height, p.y));
                    
                    // Life
                    p.life -= deltaTime;
                    if (p.life <= 0) {
                        p.active = false;
                        this.active.splice(i, 1);
                        continue;
                    }
                    
                    // Render
                    const opacity = Math.min(1, p.life * (0.4 + audioData.high * 0.6));
                    const size = 1 + audioData.bass * 3;
                    
                    p.element.style.transform = `translate(${p.x}px, ${p.y}px)`;
                    p.element.style.opacity = opacity;
                    p.element.style.width = size + 'px';
                    p.element.style.height = size + 'px';
                }
            }

            destroy() {
                this.pool.forEach(p => p.element.remove());
                this.pool = [];
                this.active = [];
            }
        }

        // Optimized motion detector
        class MotionDetector {
            constructor() {
                this.data = { x: 0, y: 0, z: 0, intensity: 0, tilt: 0 };
                this.calibrated = { x: 0, y: 0, z: 9.8 };
                this.smoothing = 0.85;
                this.sensitivity = 1.2;
                this.isActive = false;
                this.permissionGranted = false;
            }

            async requestPermission() {
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    try {
                        const response = await DeviceMotionEvent.requestPermission();
                        this.permissionGranted = response === 'granted';
                        return this.permissionGranted;
                    } catch (error) {
                        console.warn('Motion permission error:', error);
                        return false;
                    }
                } else if ('DeviceMotionEvent' in window) {
                    this.permissionGranted = true;
                    return true;
                }
                return false;
            }

            start() {
                if (!this.permissionGranted || this.isActive) return;
                
                this.isActive = true;
                
                window.addEventListener('devicemotion', (event) => {
                    if (!event.accelerationIncludingGravity) return;
                    
                    const acc = event.accelerationIncludingGravity;
                    const rawX = (acc.x || 0) - this.calibrated.x;
                    const rawY = (acc.y || 0) - this.calibrated.y;
                    const rawZ = (acc.z || 0) - this.calibrated.z;
                    
                    // Smooth the data
                    this.data.x = this.data.x * this.smoothing + rawX * (1 - this.smoothing);
                    this.data.y = this.data.y * this.smoothing + rawY * (1 - this.smoothing);
                    this.data.z = this.data.z * this.smoothing + rawZ * (1 - this.smoothing);
                    
                    // Calculate intensity and tilt
                    this.data.intensity = Math.min(1, Math.sqrt(
                        this.data.x * this.data.x +
                        this.data.y * this.data.y +
                        this.data.z * this.data.z
                    ) * this.sensitivity / 10);
                    
                    this.data.tilt = Math.atan2(this.data.x, this.data.y);
                    
                }, { passive: true });
                
                // Calibration period
                setTimeout(() => {
                    this.calibrated.x = this.data.x;
                    this.calibrated.y = this.data.y;
                    this.calibrated.z = this.data.z;
                }, 1000);
            }

            getInfluence() {
                const intensity = Math.max(0.1, this.data.intensity);
                return {
                    tempo: 0.7 + intensity * 0.8,
                    complexity: Math.min(1, intensity * 1.5),
                    swing: Math.abs(Math.sin(this.data.tilt)) * 0.25,
                    filter: 1000 + intensity * 4000
                };
            }
        }

        // Smart audio sampler with advanced detection
        class SmartSampler {
            constructor(audioContext, analyser) {
                this.ctx = audioContext;
                this.analyser = analyser;
                this.samples = [];
                this.maxSamples = 6;
                this.isRecording = false;
                this.buffer = [];
                this.lastSampleTime = 0;
                this.minGapMs = 1500;
                this.activityThreshold = 4000;
                this.harmonicThreshold = 15;
                this.pitchRatios = [0.5, 0.67, 0.75, 1, 1.25, 1.5, 2];
                this.setupRecorder();
            }

            setupRecorder() {
                this.recorder = this.ctx.createScriptProcessor(2048, 1, 1);
                this.recorder.onaudioprocess = (event) => {
                    if (this.isRecording) {
                        const input = event.inputBuffer.getChannelData(0);
                        this.buffer.push(...input);
                        
                        // Auto-stop if too long
                        if (this.buffer.length > this.ctx.sampleRate * 4) {
                            this.stopRecording();
                        }
                    }
                };
            }

            connectMicrophone(micNode) {
                this.micNode = micNode;
                micNode.connect(this.analyser);
                this.startMonitoring();
            }

            startMonitoring() {
                const monitor = () => {
                    if (!this.isRecording && Date.now() - this.lastSampleTime > this.minGapMs) {
                        if (this.detectInterestingAudio()) {
                            this.startRecording();
                        }
                    }
                    
                    if (this.ctx.state === 'running') {
                        setTimeout(monitor, 200);
                    }
                };
                monitor();
            }

            detectInterestingAudio() {
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                
                let totalEnergy = 0;
                let peakCount = 0;
                let harmonicContent = 0;
                
                // Analyze frequency spectrum
                for (let i = 0; i < freqData.length; i++) {
                    totalEnergy += freqData[i];
                    if (freqData[i] > 100) peakCount++;
                    if (i > 5 && i < freqData.length * 0.7 && freqData[i] > 80) {
                        harmonicContent++;
                    }
                }
                
                // Check for interesting patterns
                const hasEnoughEnergy = totalEnergy > this.activityThreshold;
                const hasHarmonics = harmonicContent > this.harmonicThreshold;
                const hasVariation = peakCount > 8 && peakCount < freqData.length * 0.8;
                
                return hasEnoughEnergy && (hasHarmonics || hasVariation);
            }

            startRecording() {
                if (this.isRecording) return;
                
                this.isRecording = true;
                this.buffer = [];
                this.micNode.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
                
                // Visual feedback
                document.getElementById('dot').classList.add('sampling');
                this.triggerRipple();
                
                // Auto-stop after random duration
                setTimeout(() => {
                    if (this.isRecording) this.stopRecording();
                }, 500 + Math.random() * 2000);
            }

            stopRecording() {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                this.micNode.disconnect(this.recorder);
                this.recorder.disconnect();
                this.lastSampleTime = Date.now();
                
                document.getElementById('dot').classList.remove('sampling');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.15) {
                    this.processSample();
                }
                
                this.buffer = [];
            }

            processSample() {
                try {
                    const audioBuffer = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    audioBuffer.getChannelData(0).set(this.buffer);
                    
                    // Analyze sample characteristics
                    const energy = this.calculateEnergy(audioBuffer);
                    const pitch = this.pitchRatios[Math.floor(Math.random() * this.pitchRatios.length)];
                    const stretch = this.calculateOptimalStretch(audioBuffer);
                    
                    const sample = {
                        buffer: audioBuffer,
                        pitch,
                        stretch,
                        energy,
                        timestamp: Date.now(),
                        playbackRate: pitch * stretch
                    };
                    
                    // Add to collection
                    this.samples.push(sample);
                    
                    // Keep only best samples
                    if (this.samples.length > this.maxSamples) {
                        this.samples.sort((a, b) => b.energy - a.energy);
                        this.samples = this.samples.slice(0, this.maxSamples);
                    }
                    
                } catch (error) {
                    console.warn('Sample processing failed:', error);
                }
            }

            calculateEnergy(buffer) {
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i += 8) {
                    sum += data[i] * data[i];
                }
                return Math.sqrt(sum / (data.length / 8));
            }

            calculateOptimalStretch(buffer) {
                // Simple tempo matching
                const bpm = 75; // Base BPM
                const beatDuration = 60 / bpm;
                const sampleDuration = buffer.duration;
                
                // Find best fit to musical divisions
                const divisions = [0.25, 0.5, 1, 2, 4];
                let bestStretch = 1;
                let minError = Infinity;
                
                for (const div of divisions) {
                    const targetDuration = beatDuration * div;
                    const stretch = targetDuration / sampleDuration;
                    const error = Math.abs(1 - stretch);
                    
                    if (error < minError && stretch >= 0.5 && stretch <= 2) {
                        minError = error;
                        bestStretch = stretch;
                    }
                }
                
                return bestStretch;
            }

            triggerRipple() {
                const ripple = document.getElementById('ripple');
                ripple.classList.add('active');
                setTimeout(() => ripple.classList.remove('active'), 400);
            }

            getRandomSample() {
                if (this.samples.length === 0) return null;
                return this.samples[Math.floor(Math.random() * this.samples.length)];
            }

            getBestSample() {
                if (this.samples.length === 0) return null;
                return this.samples.reduce((best, current) => 
                    current.energy > best.energy ? current : best
                );
            }

            getSampleCount() {
                return this.samples.length;
            }
        }

        // Main audio engine
        class AudioEngine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.motionDetector = new MotionDetector();
                this.sampler = null;
                this.particles = null;
                this.sequencer = { step: 0, lastTime: 0, bpm: 75, swing: 0.1 };
                this.evolution = { stage: 0, complexity: 0 };
                this.audioData = { bass: 0, mid: 0, high: 0, overall: 0 };
                this.isRunning = false;
                this.frameId = null;
                this.lastFrameTime = 0;
                this.drums = {};
                
                this.initializeUI();
            }

            initializeUI() {
                this.dot = document.getElementById('dot');
                this.startScreen = document.getElementById('startScreen');
                this.startBtn = document.getElementById('startBtn');
                this.vizBar = document.getElementById('vizBar');
                
                this.startBtn.addEventListener('touchstart', this.handleStart.bind(this), { passive: false });
                this.startBtn.addEventListener('click', this.handleStart.bind(this));
                
                // Prevent unwanted behaviors
                document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
                document.addEventListener('contextmenu', e => e.preventDefault());
                
                // Handle app lifecycle
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pause();
                    } else if (this.isRunning) {
                        this.resume();
                    }
                });
            }

            async handleStart(event) {
                event.preventDefault();
                this.vibrate([100]);
                
                try {
                    await this.initialize();
                    this.start();
                } catch (error) {
                    console.error('Failed to start:', error);
                    this.startBtn.textContent = 'Try Again';
                    this.startBtn.style.color = '#ff4444';
                    this.vibrate([200, 100, 200]);
                }
            }

            async initialize() {
                // Request motion permission first
                await this.motionDetector.requestPermission();
                
                // Initialize audio context
                this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 44100,
                    latencyHint: 'interactive'
                });
                
                await this.ctx.resume();
                
                // Setup audio chain
                await this.setupAudioChain();
                await this.setupMicrophone();
                await this.createDrums();
                
                // Initialize systems
                this.particles = new ParticlePool(15);
                this.sampler = new SmartSampler(this.ctx, this.analyser);
                this.sampler.connectMicrophone(this.nodes.mic);
            }

            async setupAudioChain() {
                // Optimized audio chain for mobile
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.85;
                
                this.nodes.compressor = this.ctx.createDynamicsCompressor();
                this.nodes.compressor.threshold.value = -12;
                this.nodes.compressor.knee.value = 4;
                this.nodes.compressor.ratio.value = 4;
                this.nodes.compressor.attack.value = 0.003;
                this.nodes.compressor.release.value = 0.08;
                
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -1;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.01;
                
                // Connect chain
                this.nodes.master.connect(this.nodes.compressor);
                this.nodes.compressor.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);
                
                // Analyzer
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 128;
                this.analyser.smoothingTimeConstant = 0.8;
                this.nodes.limiter.connect(this.analyser);
                
                // Audio layers
                const layers = { kick: 0.9, snare: 0.7, hats: 0.4, samples: 0.8 };
                Object.entries(layers).forEach(([name, volume]) => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = volume;
                    this.nodes[name].connect(this.nodes.master);
                });
            }

            async setupMicrophone() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100,
                        channelCount: 1
                    }
                });
                
                this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                this.nodes.mic.connect(this.analyser);
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // Kick
                this.drums.kick = this.ctx.createBuffer(1, Math.floor(sr * 0.2), sr);
                const kickData = this.drums.kick.getChannelData(0);
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-12 * t);
                    const freq = 65 * Math.exp(-35 * t);
                    kickData[i] = Math.sin(2 * Math.PI * freq * t) * env;
                }
                
                // Snare
                this.drums.snare = this.ctx.createBuffer(1, Math.floor(sr * 0.08), sr);
                const snareData = this.drums.snare.getChannelData(0);
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-40 * t);
                    const noise = (Math.random() * 2 - 1) * 0.8;
                    const tone = Math.sin(2 * Math.PI * 220 * t) * 0.15;
                    snareData[i] = (noise + tone) * env;
                }
                
                // Hi-hat
                this.drums.hat = this.ctx.createBuffer(1, Math.floor(sr * 0.02), sr);
                const hatData = this.drums.hat.getChannelData(0);
                for (let i = 0; i < hatData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-120 * t);
                    hatData[i] = (Math.random() * 2 - 1) * env * 0.4;
                }
            }

            start() {
                this.isRunning = true;
                this.sequencer.lastTime = this.ctx.currentTime;
                this.motionDetector.start();
                
                // Hide start screen
                this.startScreen.classList.add('hidden');
                this.vibrate([50, 30, 100]);
                
                // Start main loop
                this.loop();
            }

            loop() {
                if (!this.isRunning) return;
                
                const now = performance.now();
                const deltaTime = (now - this.lastFrameTime) / 1000;
                this.lastFrameTime = now;
                
                // Update audio analysis
                this.updateAudioAnalysis();
                
                // Update motion influence
                const motionInfluence = this.motionDetector.getInfluence();
                this.sequencer.bpm = 75 * motionInfluence.tempo;
                this.sequencer.swing = motionInfluence.swing;
                this.evolution.complexity = motionInfluence.complexity;
                
                // Update evolution stage
                this.updateEvolution();
                
                // Update particles
                if (this.particles) {
                    this.particles.update(deltaTime, this.audioData, this.motionDetector.data);
                }
                
                // Spawn new particles occasionally
                if (Math.random() < 0.02 && this.audioData.overall > 0.1) {
                    const centerX = window.innerWidth / 2;
                    const centerY = window.innerHeight / 2;
                    const angle = Math.random() * Math.PI * 2;
                    const speed = 20 + this.audioData.bass * 50;
                    this.particles.spawn(
                        centerX + (Math.random() - 0.5) * 100,
                        centerY + (Math.random() - 0.5) * 100,
                        Math.cos(angle) * speed,
                        Math.sin(angle) * speed
                    );
                }
                
                // Update sequencer
                this.updateSequencer();
                
                this.frameId = requestAnimationFrame(() => this.loop());
            }

            updateAudioAnalysis() {
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                
                const third = Math.floor(freqData.length / 3);
                let bass = 0, mid = 0, high = 0;
                
                // Calculate frequency bands
                for (let i = 0; i < third; i++) bass += freqData[i];
                for (let i = third; i < third * 2; i++) mid += freqData[i];
                for (let i = third * 2; i < freqData.length; i++) high += freqData[i];
                
                // Normalize
                this.audioData.bass = bass / (third * 255);
                this.audioData.mid = mid / (third * 255);
                this.audioData.high = high / (third * 255);
                this.audioData.overall = (bass + mid + high) / (freqData.length * 255);
                
                // Update visualization
                this.vizBar.style.width = (this.audioData.overall * 100) + '%';
            }

            updateEvolution() {
                const newStage = Math.floor(this.evolution.complexity * 4);
                if (newStage !== this.evolution.stage) {
                    this.evolution.stage = newStage;
                    this.updateEvolutionRings();
                }
            }

            updateEvolutionRings() {
                const rings = document.querySelectorAll('.ring');
                rings.forEach((ring, index) => {
                    if (index <= this.evolution.stage) {
                        ring.classList.add('active');
                    } else {
                        ring.classList.remove('active');
                    }
                });
            }

            updateSequencer() {
                const now = this.ctx.currentTime;
                const beatDuration = 60 / this.sequencer.bpm / 4;
                const swingOffset = this.sequencer.step % 2 === 1 ? 
                    beatDuration * this.sequencer.swing : 
                    -beatDuration * this.sequencer.swing * 0.5;
                
                if (now >= this.sequencer.lastTime + beatDuration + swingOffset) {
                    this.sequencer.lastTime = now;
                    this.processStep();
                    this.sequencer.step = (this.sequencer.step + 1) % 32;
                }
            }

            processStep() {
                const step = this.sequencer.step;
                const complexity = this.evolution.complexity;
                
                // Visual pulse on strong beats
                if (step % 4 === 0) {
                    this.dot.classList.add('pulse');
                    setTimeout(() => this.dot.classList.remove('pulse'), 600);
                }
                
                // Play drum patterns
                this.playDrumPatterns(step, complexity);
                
                // Play samples
                this.playSamples(step, complexity);
            }

            playDrumPatterns(step, complexity) {
                // Kick pattern - always solid
                if (step === 0 || (step === 16 && complexity > 0.4)) {
                    this.playDrum('kick', 1.0);
                }
                
                // Snare pattern
                if (step === 8 || (step === 24 && complexity > 0.3)) {
                    this.playDrum('snare', 0.8);
                }
                
                // Hi-hat pattern - evolves with complexity
                const hatPattern = complexity > 0.6 ? 
                    [2, 6, 10, 12, 14, 18, 20, 22, 26, 28, 30] :
                    complexity > 0.3 ?
                    [2, 6, 10, 14, 18, 22, 26, 30] :
                    [6, 14, 22, 30];
                
                if (hatPattern.includes(step)) {
                    const velocity = 0.3 + Math.random() * 0.3 + (complexity * 0.2);
                    this.playDrum('hats', velocity);
                }
            }

            playDrum(drumName, velocity) {
                try {
                    const source = this.ctx.createBufferSource();
                    const gain = this.ctx.createGain();
                    
                    source.buffer = this.drums[drumName];
                    gain.gain.value = velocity;
                    
                    // Motion-influenced pitch variation
                    const motionPitch = 1 + (this.motionDetector.data.intensity - 0.5) * 0.15;
                    source.playbackRate.value = Math.max(0.7, Math.min(1.4, motionPitch));
                    
                    source.connect(gain);
                    gain.connect(this.nodes[drumName === 'hat' ? 'hats' : drumName]);
                    source.start();
                    
                } catch (error) {
                    console.warn('Drum play error:', error);
                }
            }

            playSamples(step, complexity) {
                if (!this.sampler || this.sampler.getSampleCount() === 0) return;
                
                // Sample trigger logic based on evolution
                const triggers = [
                    [], // Stage 0: no samples
                    [0], // Stage 1: simple
                    [0, 16], // Stage 2: more frequent
                    [0, 8, 16, 24], // Stage 3: complex
                    [0, 4, 8, 12, 16, 20, 24, 28] // Stage 4: very active
                ];
                
                const currentTriggers = triggers[Math.min(this.evolution.stage, triggers.length - 1)];
                
                if (currentTriggers.includes(step)) {
                    const sample = Math.random() < 0.7 ? 
                        this.sampler.getRandomSample() : 
                        this.sampler.getBestSample();
                    
                    if (sample) {
                        this.playSample(sample, complexity);
                    }
                }
            }

            playSample(sample, complexity) {
                try {
                    const source = this.ctx.createBufferSource();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    source.buffer = sample.buffer;
                    source.playbackRate.value = sample.playbackRate;
                    
                    // Motion-reactive filtering
                    const motionInfluence = this.motionDetector.getInfluence();
                    filter.type = 'lowpass';
                    filter.frequency.value = motionInfluence.filter;
                    filter.Q.value = 0.5 + complexity * 1.5;
                    
                    // Dynamic volume
                    const baseVolume = 0.6;
                    const motionVolume = this.motionDetector.data.intensity * 0.3;
                    const audioVolume = this.audioData.overall * 0.2;
                    gain.gain.value = Math.min(1, baseVolume + motionVolume + audioVolume);
                    
                    // Sidechain compression on kick hits
                    if (this.sequencer.step === 0 || this.sequencer.step === 16) {
                        gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(gain.gain.value, this.ctx.currentTime + 0.12);
                    }
                    
                    source.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.nodes.samples);
                    
                    source.start();
                    source.stop(this.ctx.currentTime + Math.min(sample.buffer.duration, 3));
                    
                } catch (error) {
                    console.warn('Sample play error:', error);
                }
            }

            pause() {
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                    this.frameId = null;
                }
                
                if (this.ctx && this.ctx.state === 'running') {
                    this.ctx.suspend();
                }
            }

            resume() {
                if (this.ctx && this.ctx.state === 'suspended') {
                    this.ctx.resume().then(() => {
                        if (this.isRunning) {
                            this.loop();
                        }
                    });
                }
            }

            vibrate(pattern) {
                if ('vibrate' in navigator) {
                    navigator.vibrate(pattern);
                }
            }

            destroy() {
                this.isRunning = false;
                
                if (this.frameId) {
                    cancelAnimationFrame(this.frameId);
                }
                
                if (this.particles) {
                    this.particles.destroy();
                }
                
                if (this.ctx && this.ctx.state !== 'closed') {
                    this.ctx.close();
                }
            }
        }

        // Initialize and handle page lifecycle
        const engine = new AudioEngine();
        
        window.addEventListener('beforeunload', () => engine.destroy());
        window.addEventListener('pagehide', () => engine.destroy());
        
        // Handle iOS audio context suspension
        document.addEventListener('touchstart', () => {
            if (engine.ctx && engine.ctx.state === 'suspended') {
                engine.ctx.resume();
            }
        }, { once: true });
        
        // Prevent context menu and text selection
        document.addEventListener('selectstart', e => e.preventDefault());
        document.addEventListener('dragstart', e => e.preventDefault());
        
        // Handle orientation changes
        window.addEventListener('orientationchange', () => {
            setTimeout(() => {
                if (engine.particles) {
                    engine.particles.destroy();
                    engine.particles = new ParticlePool(15);
                }
            }, 300);
        });
    </script>
</body>
</html>
