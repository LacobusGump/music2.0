<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Cinematic Void Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 3px;
      backdrop-filter: blur(15px);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
      transform: scale(1.1);
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.4) 40%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 60px rgba(255,255,255,0.6);
      backdrop-filter: blur(8px);
      filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));
    }
    
    .orb.pulse {
      transform: translate(-50%, -50%) scale(1.5);
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff4500 0%, rgba(255,69,0,0.5) 40%, transparent 80%);
      box-shadow: 0 0 80px rgba(255,69,0,0.8);
      filter: drop-shadow(0 0 30px rgba(255,69,0,0.4));
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #1e90ff 0%, rgba(30,144,255,0.5) 40%, transparent 80%);
      box-shadow: 0 0 100px rgba(30,144,255,0.8);
      filter: drop-shadow(0 0 40px rgba(30,144,255,0.4));
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #8a2be2 0%, #ff1493 30%, #ffd700 60%, transparent 90%);
      box-shadow: 0 0 140px rgba(138,43,226,0.9);
      filter: drop-shadow(0 0 50px rgba(255,20,147,0.6));
    }
    
    .orb.dimensional {
      background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, #ffff00 50%, #00ff00 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(0,255,255,1);
      filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
    }
    
    .orb.void {
      background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(147,112,219,0.4);
      filter: drop-shadow(0 0 20px rgba(147,112,219,0.2));
      animation: voidBreathe 3s ease-in-out infinite;
    }
    
    @keyframes voidBreathe {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .ui-minimal {
      position: fixed;
      top: 15px;
      left: 15px;
      font-size: 9px;
      color: rgba(255,255,255,0.6);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.2);
      padding: 8px 12px;
      border-radius: 4px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .ui-minimal:hover {
      color: rgba(255,255,255,0.9);
      background: rgba(0,0,0,0.4);
    }
    
    .stage-name {
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 4px;
      font-weight: bold;
    }
    
    .metric {
      margin: 2px 0;
      font-size: 8px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: normal;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.7) 100%);
      opacity: 0;
      transition: opacity 4s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.4);
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: normal;
    }
    
    .theme-text.visible { opacity: 1; }

    .waveform {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
      pointer-events: none;
      z-index: 3;
      opacity: 0.6;
    }
    
    .wave-bar {
      position: absolute;
      bottom: 0;
      width: 16px;
      background: linear-gradient(0deg, rgba(255,255,255,0.6), rgba(255,255,255,0.1));
      border-radius: 2px 2px 0 0;
      transition: height 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }

    .orb::after {
      content: '';
      position: absolute;
      top: -100px;
      left: -100px;
      width: 235px;
      height: 235px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%);
      opacity: 0.5;
      transition: opacity 0.5s ease, transform 0.5s ease;
    }

    .orb.pulse::after {
      opacity: 0.8;
      transform: scale(1.2);
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-minimal" id="uiMinimal">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">BPM: <span id="bpmDisplay">60</span> | VOICES: <span id="voiceCount">0</span></div>
      <div class="metric">INTENSITY: <span id="intensityDisplay">0%</span></div>
    </div>
    
    <div class="waveform" id="waveform"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class VoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        this.bpm = 60;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        this.microRhythm = 0;
        
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0, z: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        this.stage = 'VOID';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.voidPhase = true;
        this.currentTechnique = 'waiting';
        this.lastEvolutionTime = 0;
        this.lastMotionTime = Date.now();
        this.voidCycleTime = 0;
        
        this.currentTheme = 'void';
        this.themes = {
          awakening: { mood: 'mysterious', colors: ['#0a0a0a', '#1a1a1a'], text: 'The Void Stirs', intensity: 0.2 },
          adventure: { mood: 'heroic', colors: ['#ff4500', '#0a0a0a'], text: 'Into the Fire', intensity: 0.5 },
          tension: { mood: 'suspenseful', colors: ['#1e90ff', '#0a0a0a'], text: 'Storm Rising', intensity: 0.7 },
          triumph: { mood: 'epic', colors: ['#8a2be2', '#ff1493'], text: 'Epic Triumph', intensity: 0.9 },
          reflection: { mood: 'serene', colors: ['#ffd700', '#0a0a0a'], text: 'Eternal Peace', intensity: 0.3 },
          chaos: { mood: 'chaotic', colors: ['#ff0000', '#000000'], text: 'Reality Fractures', intensity: 1.0 },
          dimensional: { mood: 'transcendent', colors: ['#00ffff', '#ff00ff'], text: 'Beyond Existence', intensity: 1.2 },
          void: { mood: 'healing', colors: ['#9370db', '#0a0a0a'], text: 'Healing Frequencies', intensity: 0.1 }
        };
        
        // Enhanced audio chain components
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.layerFilters = {};
        this.layerEQs = {};
        this.layerCompressors = {};
        this.layerSaturators = {};
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.masterEQ = null;
        this.masterSaturator = null;
        this.sidechain = null;
        this.sidechainGain = null;
        
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        this.spatialMapping = { x: 0, y: 0, z: 0 };
        
        this.shepardTones = []; 
        this.ostinatoPattern = [0, 2, 0, 5, 0, 3, 0, 7, 1, 4, 1, 6]; 
        this.ostinatoIndex = 0;
        this.shepardIntensity = 0;
        this.shepardRising = true;
        this.tensionBuildup = 0;
        this.glitchProbability = 0;
        this.harmonicTension = 0;
        
        // Enhanced voice pool with better limits
        this.voicePool = {
          kick: { max: 1, active: [] },
          bass: { max: 2, active: [] },
          hihat: { max: 3, active: [] },
          snare: { max: 1, active: [] },
          percussion: { max: 4, active: [] },
          ostinato: { max: 4, active: [] },
          harmony: { max: 6, active: [] },
          lead: { max: 3, active: [] },
          pad: { max: 4, active: [] },
          atmosphere: { max: 3, active: [] },
          texture: { max: 6, active: [] },
          strings: { max: 8, active: [] }, 
          brass: { max: 5, active: [] },
          woodwinds: { max: 4, active: [] },
          choir: { max: 6, active: [] },
          shepard: { max: 3, active: [] },
          granular: { max: 8, active: [] },
          glitch: { max: 3, active: [] },
          risers: { max: 2, active: [] },
          impacts: { max: 1, active: [] }
        };
        
        this.layers = {
          kick: false, bass: false, hihat: false, snare: false, percussion: false,
          ostinato: false, harmony: false, lead: false,
          pad: false, atmosphere: false, texture: false,
          strings: false, brass: false, woodwinds: false, choir: false,
          shepard: false, granular: false, glitch: false, risers: false, impacts: false
        };
        
        this.key = 'D';
        this.keyOffsets = {'C':0, 'Db':1, 'D':2, 'Eb':3, 'E':4, 'F':5, 'Gb':6, 'G':7, 'Ab':8, 'A':9, 'Bb':10, 'B':11};
        this.mode = 'minor';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          pentatonic: [0, 2, 4, 7, 9],
          blues: [0, 3, 5, 6, 7, 10],
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          wholeTone: [0, 2, 4, 6, 8, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [0, 3, 7],    // i
          [10, 2, 5],   // VII
          [5, 8, 0],    // iv
          [7, 10, 2],   // V
          [3, 7, 10],   // III
          [8, 0, 3],    // vi
          [2, 5, 8],    // ii°
          [5, 9, 0]     // iv (add6)
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 293.66;
        
        this.elements = {};
        this.waveBars = [];
        
        this.granularBuffer = null;
        
        this.easterEggs = {
          konamiSequence: [],
          goldenRatio: false,
          perfectCircle: false,
          chaosAttractor: false,
          fibonacciSpiral: false,
          shepardInfinity: false,
          harmonicWave: false
        };
        this.specialEvents = {
          glitchStorm: 0,
          timeDilation: 0,
          dimensionalRift: 0,
          harmonicResonance: 0
        };
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'bpmDisplay', 'voiceCount', 'intensityDisplay', 'uiMinimal',
         'cinematicOverlay', 'themeText', 'waveform', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupWaveformVisualizer();
        this.setupInteractionListeners();
      }

      setupWaveformVisualizer() {
        for (let i = 0; i < 16; i++) {
          const bar = document.createElement('div');
          bar.className = 'wave-bar';
          bar.style.left = (i * 64) + 'px';
          bar.style.height = '0px';
          this.elements.waveform.appendChild(bar);
          this.waveBars.push(bar);
        }
      }

      setupInteractionListeners() {
        let touchSequence = [];
        
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.clientX, y: e.clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        setInterval(() => {
          const now = Date.now();
          touchSequence = touchSequence.filter(touch => now - touch.time < 5000);
        }, 2000);

        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;
        
        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              this.triggerKonamiEasterEgg();
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
      }

      analyzeGesture(sequence) {
        if (sequence.length < 3) return;
        
        const recent = sequence.slice(-10);
        const distances = [];
        const angles = [];
        
        for (let i = 1; i < recent.length; i++) {
          const dx = recent[i].x - recent[i-1].x;
          const dy = recent[i].y - recent[i-1].y;
          distances.push(Math.sqrt(dx*dx + dy*dy));
          angles.push(Math.atan2(dy, dx));
        }
        
        let angleSum = 0;
        for (let i = 1; i < angles.length; i++) {
          let diff = angles[i] - angles[i-1];
          if (diff > Math.PI) diff -= 2 * Math.PI;
          if (diff < -Math.PI) diff += 2 * Math.PI;
          angleSum += diff;
        }
        
        if (Math.abs(angleSum) > Math.PI * 2) {
          this.gestureRecognition.spiral += 0.3;
          if (this.gestureRecognition.spiral > 1 && !this.easterEggs.fibonacciSpiral) {
            this.triggerFibonacciSpiral();
          }
        }
        
        if (distances.length > 5) {
          const avgDistance = distances.reduce((a, b) => a + b, 0) / distances.length;
          const variance = distances.reduce((sum, d) => sum + Math.pow(d - avgDistance, 2), 0) / distances.length;
          
          if (variance < 100 && Math.abs(angleSum) > Math.PI * 1.8) {
            this.easterEggs.perfectCircle = true;
            this.triggerPerfectCircleEasterEgg();
          }
        }
        
        let waveScore = 0;
        for (let i = 2; i < angles.length; i++) {
          const angleDiff = angles[i] - angles[i-2];
          if (Math.abs(angleDiff) > Math.PI / 2 && Math.abs(angleDiff) < Math.PI * 1.5) {
            waveScore += 0.2;
          }
        }
        if (waveScore > 1 && sequence.length > 8) {
          this.gestureRecognition.wave += waveScore / sequence.length;
          if (this.gestureRecognition.wave > 1 && !this.easterEggs.harmonicWave) {
            this.triggerHarmonicWaveEasterEgg();
          }
        }
        
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.01);
        });
      }

      triggerKonamiEasterEgg() {
        console.log('🎮 KONAMI CODE ACTIVATED: God Mode Engaged');
        this.specialEvents.dimensionalRift = 2;
        this.glitchProbability = 0.5;
        this.bpm *= 1.5;
        this.layers.glitch = true;
        this.currentTheme = 'chaos';
        this.evolveToDimensional();
        this.flashImpact();
      }

      triggerFibonacciSpiral() {
        console.log('🌀 FIBONACCI SPIRAL DETECTED: Golden Ratio Harmony');
        this.easterEggs.fibonacciSpiral = true;
        this.layers.shepard = true;
        this.shepardIntensity = 1;
        this.playGoldenRatioChord();
      }

      triggerPerfectCircleEasterEgg() {
        console.log('⭕ PERFECT CIRCLE: Infinite Loop Activated');
        this.easterEggs.perfectCircle = true;
        this.specialEvents.timeDilation = 1.5;
        this.layers.shepard = true;
        this.shepardIntensity = 1;
        this.playInfiniteLoop();
      }

      triggerHarmonicWaveEasterEgg() {
        console.log('🌊 HARMONIC WAVE DETECTED: Serene Resonance Flows');
        this.easterEggs.harmonicWave = true;
        this.layers.atmosphere = true;
        this.layers.pad = true;
        this.intensity = Math.max(0, this.intensity - 1);
        this.playSereneResonance();
        this.currentTheme = 'reflection';
      }

      flashImpact() {
        this.elements.impactFlash.style.opacity = 1;
        setTimeout(() => this.elements.impactFlash.style.opacity = 0, 150);
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active || e.alpha === null) return;
          this.orientation.alpha = e.alpha;
          this.orientation.beta = e.beta;
          this.orientation.gamma = e.gamma;
          this.updateListenerOrientation();
          this.updateSpatialMapping();
        });
      }

      updateSpatialMapping() {
        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;
        
        this.spatialMapping.x = Math.sin(alphaRad) * Math.cos(betaRad);
        this.spatialMapping.y = Math.sin(betaRad);
        this.spatialMapping.z = Math.cos(alphaRad) * Math.cos(betaRad);
        
        this.updateSpatialProcessors();
      }

      updateSpatialProcessors() {
        Object.keys(this.layerPanners).forEach(layer => {
          if (this.layerPanners[layer]) {
            const x = this.spatialMapping.x * 10 + (this.pos.x - 50) * 0.2;
            const y = this.spatialMapping.y * 5 + (this.pos.y - 50) * 0.1;
            const z = this.spatialMapping.z * 8 - 5;
            
            // Smooth parameter changes to prevent zipper noise
            const currentTime = this.ctx.currentTime;
            this.layerPanners[layer].positionX.linearRampToValueAtTime(x, currentTime + 0.05);
            this.layerPanners[layer].positionY.linearRampToValueAtTime(y, currentTime + 0.05);
            this.layerPanners[layer].positionZ.linearRampToValueAtTime(z, currentTime + 0.05);
          }
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        const currentTime = this.ctx.currentTime;
        this.listener.forwardX.linearRampToValueAtTime(forwardX, currentTime + 0.05);
        this.listener.forwardY.linearRampToValueAtTime(forwardY, currentTime + 0.05);
        this.listener.forwardZ.linearRampToValueAtTime(forwardZ, currentTime + 0.05);
        this.listener.upX.linearRampToValueAtTime(upX, currentTime + 0.05);
        this.listener.upY.linearRampToValueAtTime(upY, currentTime + 0.05);
        this.listener.upZ.linearRampToValueAtTime(upZ, currentTime + 0.05);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission().catch(() => 'denied');
            if (motionPermission !== 'granted') {
              console.log('Motion permission not granted');
            }
          }

          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission().catch(() => 'denied');
            if (orientationPermission !== 'granted') {
              console.log('Orientation permission not granted');
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setLayerPositions();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'BE STILL OR MOVE TO AWAKEN';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 5000);
          }, 1500);

          this.active = true;
          this.startSequencer();
          this.animate();
          
          // Start in void state
          setTimeout(() => {
            this.enterVoidState();
          }, 500);
          
        } catch (e) {
          console.error('Failed to start engine:', e);
          alert('Failed to initialize. Please try again.');
        }
      }

      // Enhanced reverb with richer sound
      createReverbBuffer(time) {
        const length = this.ctx.sampleRate * time;
        const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, 2.5);
            const noise = (Math.random() * 2 - 1) * decay;
            
            // Add early reflections
            if (i < this.ctx.sampleRate * 0.05) {
              data[i] = noise * (1 + Math.sin(i * 0.02) * 0.3);
            } else if (i < this.ctx.sampleRate * 0.1) {
              data[i] = noise * 0.8;
            } else {
              // Diffuse late reflections with modulation
              const mod = Math.sin(i * 0.0001) * 0.2 + 1;
              data[i] = noise * 0.5 * mod;
            }
          }
        }
        return buffer;
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 64;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        // Sub-bass control with high-pass filter
        this.subBassFilter = this.ctx.createBiquadFilter();
        this.subBassFilter.type = 'highpass';
        this.subBassFilter.frequency.value = 30;
        this.subBassFilter.Q.value = 0.7;
        
        // Master limiter with softer settings
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -6;
        this.limiter.knee.value = 8;
        this.limiter.ratio.value = 12;
        this.limiter.attack.value = 0.002;
        this.limiter.release.value = 0.15;
        
        // Master gain - increased for louder music
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.45; 
        
        // Master compressor with musical settings
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -28;
        this.compressor.knee.value = 15;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.006;
        this.compressor.release.value = 0.25;
        
        // Master EQ
        this.masterEQ = this.createMultibandEQ();
        
        // Master saturator for warmth
        this.masterSaturator = this.ctx.createWaveShaper();
        this.masterSaturator.curve = this.createSaturationCurve(0.15);
        this.masterSaturator.oversample = '4x';
        
        this.listener = this.ctx.listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        
        // Enhanced reverb
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(2);
        const reverbGain = this.ctx.createGain();
        reverbGain.gain.value = 0.1; // Reduced reverb wet level
        
        // Enhanced delay with feedback filter
        this.delay = this.ctx.createDelay(1.0);
        this.delay.delayTime.value = 0.375;
        
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.3; // Reduced feedback to prevent buildup
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.type = 'highshelf';
        delayFilter.frequency.value = 3500;
        delayFilter.gain.value = -8;
        
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.15; // Reduced delay wet level
        
        this.delay.connect(delayFilter);
        delayFilter.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // Sidechain setup
        this.setupSidechain();
        
        const layerNames = [
          'kick', 'bass', 'hihat', 'snare', 'percussion',
          'ostinato', 'harmony', 'lead',
          'pad', 'atmosphere', 'texture',
          'strings', 'brass', 'woodwinds', 'choir',
          'shepard', 'granular', 'glitch', 'risers', 'impacts'
        ];
        
        // Adjusted layer levels for better mix
        const layerLevels = [
          0.25,   // kick
          0.2,    // bass
          0.08,   // hihat
          0.15,   // snare
          0.1,    // percussion
          0.12,   // ostinato
          0.1,    // harmony
          0.15,   // lead
          0.08,   // pad
          0.05,   // atmosphere
          0.08,   // texture
          0.12,   // strings
          0.12,   // brass
          0.1,    // woodwinds
          0.1,    // choir
          0.08,   // shepard
          0.12,   // granular
          0.15,   // glitch
          0.2,    // risers
          0.3     // impacts
        ];
        
        layerNames.forEach((name, i) => {
          // Layer gain
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];

          // Layer compressor
          this.layerCompressors[name] = this.ctx.createDynamicsCompressor();
          this.setupLayerCompressor(name);

          // Layer EQ
          this.layerEQs[name] = this.createLayerEQ(name);

          // Layer saturator
          this.layerSaturators[name] = this.ctx.createWaveShaper();
          this.layerSaturators[name].curve = this.createSaturationCurve(0.15);
          this.layerSaturators[name].oversample = '2x';

          // Spatial panner
          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';
          this.layerPanners[name].distanceModel = 'inverse';
          this.layerPanners[name].refDistance = 1;
          this.layerPanners[name].maxDistance = 10000;
          this.layerPanners[name].rolloffFactor = 1;
          this.layerPanners[name].coneInnerAngle = 360;
          this.layerPanners[name].coneOuterAngle = 0;
          this.layerPanners[name].coneOuterGain = 0;

          // Layer filter
          this.layerFilters[name] = this.ctx.createBiquadFilter();
          this.layerFilters[name].type = 'lowpass';
          this.layerFilters[name].frequency.value = 20000;
          this.layerFilters[name].Q.value = 1;

          // Connect chain: gain -> compressor -> EQ -> saturator -> filter -> panner
          this.layerGains[name].connect(this.layerCompressors[name]);
          this.layerCompressors[name].connect(this.layerEQs[name]);
          this.layerEQs[name].connect(this.layerSaturators[name]);
          this.layerSaturators[name].connect(this.layerFilters[name]);
          this.layerFilters[name].connect(this.layerPanners[name]);
          
          // Route to appropriate bus
          if (['kick', 'bass', 'snare', 'percussion'].includes(name)) {
            this.layerPanners[name].connect(this.sidechainGain);
          } else {
            this.layerPanners[name].connect(this.compressor);
          }

          // Send to reverb
          if (['strings', 'brass', 'choir', 'harmony', 'pad', 'atmosphere', 'woodwinds'].includes(name)) {
            const sendGain = this.ctx.createGain();
            sendGain.gain.value = 0.15; // Reduced
            this.layerPanners[name].connect(sendGain);
            sendGain.connect(this.convolver);
          }
          
          // Send to delay
          if (['lead', 'ostinato', 'woodwinds', 'texture'].includes(name)) {
            const sendGain = this.ctx.createGain();
            sendGain.gain.value = 0.1; // Reduced
            this.layerPanners[name].connect(sendGain);
            sendGain.connect(this.delay);
          }
        });
        
        // Master chain: sidechain -> compressor -> subBassFilter -> EQ -> saturator -> limiter -> analyser -> gain -> out
        this.sidechainGain.connect(this.compressor);
        this.compressor.connect(this.subBassFilter);
        this.subBassFilter.connect(this.masterEQ);
        this.masterEQ.connect(this.masterSaturator);
        this.masterSaturator.connect(this.limiter);
        this.convolver.connect(reverbGain);
        reverbGain.connect(this.limiter);
        delayMix.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.setupProceduralSystems();
      }

      setupSidechain() {
        this.sidechain = this.ctx.createOscillator();
        this.sidechain.frequency.value = 50;
        this.sidechain.start();
        
        this.sidechainGain = this.ctx.createGain();
        this.sidechainGain.gain.value = 1;
      }

      triggerSidechainDuck() {
        const now = this.ctx.currentTime;
        this.sidechainGain.gain.cancelScheduledValues(now);
        this.sidechainGain.gain.setValueAtTime(1, now);
        this.sidechainGain.gain.linearRampToValueAtTime(0.7, now + 0.01);
        this.sidechainGain.gain.linearRampToValueAtTime(1, now + 0.2);
      }

      setupLayerCompressor(layer) {
        const comp = this.layerCompressors[layer];
        
        switch(layer) {
          case 'kick':
            comp.threshold.value = -15;
            comp.knee.value = 4;
            comp.ratio.value = 10;
            comp.attack.value = 0.001;
            comp.release.value = 0.12;
            break;
          case 'bass':
            comp.threshold.value = -18;
            comp.knee.value = 6;
            comp.ratio.value = 8;
            comp.attack.value = 0.002;
            comp.release.value = 0.18;
            break;
          case 'snare':
            comp.threshold.value = -12;
            comp.knee.value = 3;
            comp.ratio.value = 8;
            comp.attack.value = 0.001;
            comp.release.value = 0.1;
            break;
          default:
            comp.threshold.value = -24;
            comp.knee.value = 8;
            comp.ratio.value = 4;
            comp.attack.value = 0.002;
            comp.release.value = 0.15;
        }
      }

      createLayerEQ(layer) {
        const input = this.ctx.createGain();
        const output = this.ctx.createGain();
        
        const low = this.ctx.createBiquadFilter();
        const mid = this.ctx.createBiquadFilter();
        const high = this.ctx.createBiquadFilter();
        
        low.type = 'lowshelf';
        low.frequency.value = 150;
        mid.type = 'peaking';
        mid.frequency.value = 1000;
        mid.Q.value = 0.7;
        high.type = 'highshelf';
        high.frequency.value = 8000;
        
        // EQ settings per layer
        switch(layer) {
          case 'kick':
            low.gain.value = 1; // Reduced
            mid.gain.value = -4;
            high.gain.value = -8;
            break;
          case 'bass':
            low.gain.value = 0.5; // Reduced
            mid.gain.value = -1;
            high.gain.value = -10;
            break;
          case 'hihat':
            low.gain.value = -12;
            mid.gain.value = -4;
            high.gain.value = 2;
            break;
          case 'lead':
            low.gain.value = -4;
            mid.gain.value = 1;
            high.gain.value = 0;
            break;
          case 'pad':
          case 'atmosphere':
            low.gain.value = -8;
            mid.gain.value = -1;
            high.gain.value = 1;
            break;
          default:
            low.gain.value = 0;
            mid.gain.value = 0;
            high.gain.value = 0;
        }
        
        input.connect(low);
        low.connect(mid);
        mid.connect(high);
        high.connect(output);
        
        input.connect = (destination) => {
          output.disconnect();
          output.connect(destination);
        };
        
        return input;
      }

      createMultibandEQ() {
        const input = this.ctx.createGain();
        const output = this.ctx.createGain();
        
        const low = this.ctx.createBiquadFilter();
        const lowMid = this.ctx.createBiquadFilter();
        const highMid = this.ctx.createBiquadFilter();
        const high = this.ctx.createBiquadFilter();
        const air = this.ctx.createBiquadFilter();
        
        low.type = 'lowshelf';
        low.frequency.value = 80;
        low.gain.value = -3; // More cut
        
        lowMid.type = 'peaking';
        lowMid.frequency.value = 300;
        lowMid.Q.value = 0.7;
        lowMid.gain.value = -3; // More cut
        
        highMid.type = 'peaking';
        highMid.frequency.value = 2000;
        highMid.Q.value = 0.7;
        highMid.gain.value = -1; // Slight cut
        
        high.type = 'peaking';
        high.frequency.value = 8000;
        high.Q.value = 0.7;
        high.gain.value = 0;
        
        air.type = 'highshelf';
        air.frequency.value = 12000;
        air.gain.value = 1; // Less boost
        
        input.connect(low);
        low.connect(lowMid);
        lowMid.connect(highMid);
        highMid.connect(high);
        high.connect(air);
        air.connect(output);
        
        input.connect = (destination) => {
          output.disconnect();
          output.connect(destination);
        };
        
        return input;
      }

      createSaturationCurve(amount) {
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        
        for (let i = 0; i < samples; i++) {
          const x = (i * 2) / samples - 1;
          
          // Soft saturation algorithm
          if (Math.abs(x) < amount) {
            curve[i] = x;
          } else {
            const sign = x > 0 ? 1 : -1;
            const y = amount + (1 - amount) * Math.tanh((Math.abs(x) - amount) / (1 - amount));
            curve[i] = sign * y * 0.85; // Reduced further
          }
        }
        
        return curve;
      }

      setupProceduralSystems() {
        const bufferSize = 1 * this.ctx.sampleRate;
        this.granularBuffer = this.ctx.createBuffer(2, bufferSize, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = this.granularBuffer.getChannelData(c);
          for (let i = 0; i < bufferSize; i++) {
            const t = i / this.ctx.sampleRate;
            let sample = 0;
            
            // Rich harmonic content
            for (let h = 1; h <= 8; h++) {
              const harmonic = Math.sin(2 * Math.PI * 220 * h * t) / (h * 1.5);
              sample += harmonic * (1 - h * 0.1);
            }
            
            // Apply envelope
            const envelope = Math.pow(1 - (i / bufferSize), 2.5);
            data[i] = sample * 0.08 * envelope; // Reduced volume
          }
        }
      }

      setLayerPositions() {
        const positions = {
          kick: { x: 0, y: -1, z: -2 },
          bass: { x: 0, y: -2, z: -3 },
          snare: { x: 0, y: 0, z: -1 },
          hihat: { x: 1, y: 1, z: -2 },
          percussion: { x: -1, y: 1, z: -2 },
          ostinato: { x: -3, y: 0, z: -4 },
          harmony: { x: 3, y: 0, z: -4 },
          lead: { x: 0, y: 1, z: -3 },
          pad: { x: 0, y: 3, z: 8 },
          atmosphere: { x: 0, y: 5, z: 15 },
          texture: { x: 0, y: 2, z: 6 },
          strings: { x: -6, y: 0, z: -8 },
          brass: { x: 6, y: 0, z: -8 },
          woodwinds: { x: -4, y: 1, z: -6 },
          choir: { x: 0, y: 4, z: 12 },
          shepard: { x: 0, y: 8, z: -15 },
          granular: { x: -8, y: 2, z: -10 },
          glitch: { x: 8, y: -2, z: -5 },
          risers: { x: 0, y: 6, z: -20 },
          impacts: { x: 0, y: -3, z: -1 }
        };
        
        Object.entries(positions).forEach(([layer, pos]) => {
          if (this.layerPanners[layer]) {
            this.layerPanners[layer].positionX.value = pos.x;
            this.layerPanners[layer].positionY.value = pos.y;
            this.layerPanners[layer].positionZ.value = pos.z;
          }
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.7;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.018;
          this.velocity.y += acc.y * 0.018;
          this.updatePosition();
          
          this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
          
          if (newMotion > 5 && Date.now() - this.lastStepTime > 200) {
            this.stepCounter++;
            this.lastStepTime = Date.now();
            this.syncBPMToSteps();
            this.gestureRecognition.tap += 0.5;
            this.triggerImpactEffects();
          }
          
          if (newMotion > 8) {
            this.gestureRecognition.shake += 0.3;
            if (this.gestureRecognition.shake > 2) {
              this.triggerShakeEffects();
            }
          }
          
          if (newMotion > 12) {
            this.gestureRecognition.chaos += 0.4;
            if (this.gestureRecognition.chaos > 1.5) {
              this.triggerChaosMode();
            }
          }
          
          if (Math.abs(dy) > Math.abs(dx) * 1.5 && newMotion > 3 && newMotion < 7) {
            this.gestureRecognition.wave += 0.1;
          }
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 150;
          const velocityY = (newY - lastMouse.y) / dt * 150;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.2;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          this.orientation.alpha = (newX / 100) * 360;
          this.orientation.beta = (newY - 50) * 2.0;
          this.orientation.gamma = 0;
          this.updateListenerOrientation();
          this.updateSpatialMapping();
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.75 + newMotion * 0.25;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 50) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        // Track last motion time for void state
        if (this.motion > 0.5) {
          this.lastMotionTime = Date.now();
          this.voidPhase = false;
        }
        
        // Enter void state after 3 seconds of no motion
        if (Date.now() - this.lastMotionTime > 3000 && !this.voidPhase) {
          this.enterVoidState();
        }
        
        if (!this.firstMovement && this.motion > 2) {
          this.firstMovement = true;
          this.evolveToTribal();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        const variance = this.intensity;
        const recentHistory = this.motionHistory.slice(-25);
        const isRhythmic = recentHistory.filter(m => m > 3).length > 12 && variance < 2.5;
        const isErratic = variance > 3 && avgMotion > 2.5;
        const isSustained = avgMotion > 3 && variance < 2;
        const isChaotic = variance > 4 && avgMotion > 4;
        const isWavy = this.gestureRecognition.wave > 0.5 && avgMotion > 2 && variance < 3;
        
        if (isChaotic) this.motionPattern = 'chaotic';
        else if (isErratic) this.motionPattern = 'erratic';
        else if (isRhythmic) this.motionPattern = 'rhythmic';
        else if (isSustained) this.motionPattern = 'sustained';
        else if (isWavy) this.motionPattern = 'wavy';
        else this.motionPattern = 'calm';
        
        this.updateTechniques(avgMotion, variance);
        this.updateEvolution();
        this.updateProceduralSystems(avgMotion, variance);
      }

      enterVoidState() {
        console.log('🌌 ENTERING VOID STATE: Healing Frequencies Activated');
        this.voidPhase = true;
        this.stage = 'VOID';
        this.elements.orb.className = 'orb void';
        this.currentTheme = 'void';
        
        // Disable all active layers
        Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
        
        // Start void cycle
        this.voidCycleTime = 0;
        
        // Start heavenly soundscape
        this.playHeavenlySoundscape();
        
        // Show theme text
        this.elements.themeText.textContent = this.themes.void.text;
        this.elements.themeText.classList.add('visible');
        setTimeout(() => this.elements.themeText.classList.remove('visible'), 5000);
      }

      playHeavenlySoundscape() {
        this.playHeavenlyPad();
        this.playHeavenlyChimes();
        setTimeout(() => {
          if (this.voidPhase && this.active) {
            this.playHeavenlySoundscape();
          }
        }, 20000); // Loop every 20 seconds with overlap
      }

      playHeavenlyPad() {
        const now = this.ctx.currentTime;
        const duration = 25;
        
        // Multiple layers for richness
        for (let layer = 0; layer < 3; layer++) {
          const baseFreq = 110 * Math.pow(2, layer / 3);
          for (let i = 0; i < 4; i++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const lfo = this.ctx.createOscillator();
            const lfoGain = this.ctx.createGain();
            
            osc.type = 'sine';
            osc.frequency.value = baseFreq * Math.pow(2, i / 12);
            osc.detune.value = (i - 2) * 5;
            
            filter.type = 'lowpass';
            filter.frequency.value = 400;
            filter.Q.value = 0.3;
            
            lfo.type = 'sine';
            lfo.frequency.value = 0.1 + layer * 0.05;
            lfoGain.gain.value = 50;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            
            // Slow fade
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.012, now + 8); 
            gain.gain.setValueAtTime(0.012, now + duration - 8);
            gain.gain.linearRampToValueAtTime(0, now + duration);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(this.convolver);
            gain.connect(this.masterGain);
            
            lfo.start(now);
            osc.start(now);
            lfo.stop(now + duration);
            osc.stop(now + duration);
          }
        }
      }

      playHeavenlyChimes() {
        const now = this.ctx.currentTime;
        const chimes = 3 + Math.floor(Math.random() * 3);
        
        for (let c = 0; c < chimes; c++) {
          setTimeout(() => {
            const freq = 880 + Math.random() * 440;
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            
            filter.type = 'highpass';
            filter.frequency.value = 2000;
            filter.Q.value = 1;
            
            env.gain.setValueAtTime(0, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.05);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 5);
            
            gain.gain.value = 0.08;
            
            osc.connect(filter);
            filter.connect(env);
            env.connect(gain);
            gain.connect(this.convolver);
            gain.connect(this.masterGain);
            
            osc.start(this.ctx.currentTime);
            osc.stop(this.ctx.currentTime + 5);
          }, Math.random() * 10000);
        }
      }

      updateTechniques(avgMotion, variance) {
        if (avgMotion > 3 && variance > 2) {
          this.shepardIntensity = Math.min(this.shepardIntensity + 0.03, 1.2);
          this.tensionBuildup = Math.min(this.tensionBuildup + 0.015, 1.5);
          this.currentTechnique = 'shepard-rising';
        } else if (avgMotion < 1.5) {
          this.shepardIntensity = Math.max(this.shepardIntensity - 0.02, 0);
          this.tensionBuildup = Math.max(this.tensionBuildup - 0.01, 0);
          this.currentTechnique = 'ostinato-calm';
        }
        
        this.buildPhase = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 2.5;
        this.releasePhase = this.motionPattern === 'calm' && this.totalMotion > 150;
        this.climaxPhase = this.motionPattern === 'chaotic' && variance > 4;
        this.dimensionalPhase = this.specialEvents.dimensionalRift > 0 || this.easterEggs.fibonacciSpiral;
        
        if (this.climaxPhase) this.currentTechnique = 'climax';
        else if (this.buildPhase) this.currentTechnique = 'build';
        else if (this.releasePhase) this.currentTechnique = 'release';
        else if (this.dimensionalPhase) this.currentTechnique = 'dimensional';
        
        this.glitchProbability = Math.min(variance / 10, 0.3);
        if (this.motionPattern === 'chaotic') this.glitchProbability += 0.2;
        
        this.harmonicTension = Math.min(avgMotion / 8 + variance / 6, 1);
        
        if (this.motionPattern === 'wavy') {
          this.currentTechnique = 'resonance-flow';
          this.harmonicTension = Math.min(this.harmonicTension * 0.8, 0.6);
          this.shepardIntensity = Math.max(this.shepardIntensity - 0.01, 0.2);
        }
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) {
          this.velocity.x *= -0.6;
          this.triggerBoundaryEffect(this.pos.x < 5 ? 'left' : 'right');
        }
        if (this.pos.y < 5 || this.pos.y > 95) {
          this.velocity.y *= -0.6;
          this.triggerBoundaryEffect(this.pos.y < 5 ? 'top' : 'bottom');
        }
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= (this.easterEggs.goldenRatio ? 0.618 : 0.88);
        this.velocity.y *= (this.easterEggs.goldenRatio ? 0.618 : 0.88);
      }

      triggerBoundaryEffect(side) {
        // Soft ethereal boundary effect instead of harsh tone
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        // Use healing frequencies
        const freq = side === 'left' ? 174 : side === 'right' ? 285 : 
                    side === 'top' ? 396 : 528; // Solfeggio frequencies
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 0.5;
        
        // Very soft, brief touch
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.04, now + 0.05); // Reduced
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start(now);
        osc.stop(now + 0.3);
      }

      // Enhanced sound generators with better quality
      playKick() {
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const highpass = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('kick', osc, gain, 0.8)) return;
        
        // Main oscillator
        osc.type = 'sine';
        const baseFreq = 55 + this.intensity * 5; // Higher base frequency
        const now = this.ctx.currentTime;
        
        osc.frequency.setValueAtTime(baseFreq * 1.5, now);
        osc.frequency.exponentialRampToValueAtTime(baseFreq, now + 0.02);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.3);
        
        // Click oscillator for punch
        osc2.type = 'sine';
        osc2.frequency.value = 150;
        
        // High-pass to remove extreme subs
        highpass.type = 'highpass';
        highpass.frequency.value = 35;
        highpass.Q.value = 0.7;
        
        // Low-pass for character
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(baseFreq * 6, now);
        filter.frequency.exponentialRampToValueAtTime(baseFreq * 2, now + 0.15);
        filter.Q.value = 1;
        
        // Tighter envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.003); // Reduced
        env.gain.exponentialRampToValueAtTime(0.2, now + 0.05); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        
        gain.gain.value = 0.5; // Reduced
        
        // Connect chain
        osc.connect(highpass);
        osc2.connect(highpass);
        highpass.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.kick);
        
        osc.start(now);
        osc2.start(now);
        osc.stop(now + 0.5);
        osc2.stop(now + 0.05);
        
        // Trigger sidechain
        this.triggerSidechainDuck();
      }

      playBass() {
        const noteIndex = this.bassNote % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 1);
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const filter2 = this.ctx.createBiquadFilter();
        const highpass = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('bass', osc1, gain, 1.0)) return;
        
        const now = this.ctx.currentTime;
        
        // Dual oscillators for richness
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc1.detune.value = -5;
        
        osc2.type = 'square';
        osc2.frequency.value = freq * 0.5;
        osc2.detune.value = 5;
        
        // High-pass to clean up subs
        highpass.type = 'highpass';
        highpass.frequency.value = 40;
        highpass.Q.value = 0.5;
        
        // Filter sweep
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(80, now);
        filter.frequency.exponentialRampToValueAtTime(120 + this.motion * 40 + this.intensity * 20, now + 0.15);
        filter.frequency.exponentialRampToValueAtTime(100, now + 0.8);
        filter.Q.value = 2 + this.intensity * 0.5;
        
        // Second filter for character
        filter2.type = 'peaking';
        filter2.frequency.value = freq * 2;
        filter2.Q.value = 2;
        filter2.gain.value = 2;
        
        // Smooth envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.01); // Reduced
        env.gain.exponentialRampToValueAtTime(0.3, now + 0.1); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
        
        gain.gain.value = 0.4; // Reduced
        
        // Mix oscillators
        const oscMix = this.ctx.createGain();
        osc1.connect(oscMix);
        osc2.connect(oscMix);
        osc2.connect(oscMix).gain.value = 0.15; // Reduced
        
        oscMix.connect(highpass);
        highpass.connect(filter);
        filter.connect(filter2);
        filter2.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.bass);
        
        osc1.start(now);
        osc2.start(now);
        osc1.stop(now + 1.0);
        osc2.stop(now + 1.0);
      }

      playHihat() {
        const now = this.ctx.currentTime;
        
        // Create noise source
        const bufferSize = 0.05 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Generate metallic noise
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.sin(i * 0.1);
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter1 = this.ctx.createBiquadFilter();
        const filter2 = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('hihat', noise, gain, 0.2)) return;
        
        // Dual filters for realistic hihat
        filter1.type = 'highpass';
        filter1.frequency.value = 5000 + this.motion * 1000;
        filter1.Q.value = 1;
        
        filter2.type = 'bandpass';
        filter2.frequency.value = 8000 + Math.random() * 2000;
        filter2.Q.value = 2;
        
        // Sharp envelope
        const isOpen = Math.random() < 0.2 && this.motionPattern === 'rhythmic';
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.6, now + 0.003); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + (isOpen ? 0.3 : 0.05));
        
        gain.gain.value = 0.2; // Reduced
        
        noise.connect(filter1);
        filter1.connect(filter2);
        filter2.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.hihat);
        
        noise.start(now);
        noise.stop(now + 0.3);
      }

      playSnare() {
        const now = this.ctx.currentTime;
        
        // Tonal component
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        
        // Noise component
        const bufferSize = 0.1 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const toneEnv = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const toneFilter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('snare', osc1, gain, 0.4)) return;
        
        // Tonal setup
        osc1.type = 'triangle';
        osc1.frequency.value = 200 + this.intensity * 20;
        osc2.type = 'triangle';
        osc2.frequency.value = 300 + this.intensity * 30;
        
        toneFilter.type = 'bandpass';
        toneFilter.frequency.value = 250;
        toneFilter.Q.value = 5;
        
        // Noise filter
        filter.type = 'bandpass';
        filter.frequency.value = 3000 + this.intensity * 1000;
        filter.Q.value = 2;
        
        // Tonal envelope
        toneEnv.gain.setValueAtTime(0, now);
        toneEnv.gain.linearRampToValueAtTime(0.4, now + 0.005); // Reduced
        toneEnv.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        // Noise envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.003); // Reduced
        env.gain.exponentialRampToValueAtTime(0.15, now + 0.03); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
        
        gain.gain.value = 0.3; // Reduced
        
        // Mix components
        const mixer = this.ctx.createGain();
        
        osc1.connect(toneFilter);
        osc2.connect(toneFilter);
        toneFilter.connect(toneEnv);
        toneEnv.connect(mixer);
        
        noise.connect(filter);
        filter.connect(env);
        env.connect(mixer);
        
        mixer.connect(gain);
        gain.connect(this.layerGains.snare);
        
        osc1.start(now);
        osc2.start(now);
        noise.start(now);
        osc1.stop(now + 0.4);
        osc2.stop(now + 0.4);
        noise.stop(now + 0.4);
        
        // Light sidechain
        this.triggerSidechainDuck();
      }

      playPercussion() {
        const now = this.ctx.currentTime;
        const percType = Math.floor(Math.random() * 3);
        
        switch(percType) {
          case 0: // Conga
            this.playPercussionConga();
            break;
          case 1: // Shaker
            this.playPercussionShaker();
            break;
          case 2: // Woodblock
            this.playPercussionWoodblock();
            break;
        }
      }

      playPercussionConga() {
        const now = this.ctx.currentTime;
        const freq = 180 + Math.random() * 120;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('percussion', osc, gain, 0.3)) return;
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(freq * 1.5, now); // Adjusted
        osc.frequency.exponentialRampToValueAtTime(freq, now + 0.02);
        
        filter.type = 'bandpass';
        filter.frequency.value = freq * 1.5;
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.005); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        gain.gain.value = 0.3; // Reduced
        
        osc.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.percussion);
        
        osc.start(now);
        osc.stop(now + 0.3);
      }

      playPercussionShaker() {
        const now = this.ctx.currentTime;
        
        const bufferSize = 0.05 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.cos(i * 0.5);
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('percussion', noise, gain, 0.1)) return;
        
        filter.type = 'bandpass';
        filter.frequency.value = 6000 + Math.random() * 2000;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.3, now + 0.01); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
        
        gain.gain.value = 0.2; // Reduced
        
        noise.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.percussion);
        
        noise.start(now);
        noise.stop(now + 0.1);
      }

      playPercussionWoodblock() {
        const now = this.ctx.currentTime;
        const freq = 800 + Math.random() * 400;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('percussion', osc, gain, 0.15)) return;
        
        osc.type = 'square';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = freq;
        filter.Q.value = 15;
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.6, now + 0.002); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
        
        gain.gain.value = 0.25; // Reduced
        
        osc.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.percussion);
        
        osc.start(now);
        osc.stop(now + 0.15);
      }

      playOstinato() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(noteIndex, 4);
        const now = this.ctx.currentTime;
        
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('ostinato', osc, gain, 1.0)) return;
        
        // Dual oscillators for movement
        osc.type = this.stage === 'DIMENSIONAL' ? 'triangle' : 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = -2;
        
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2;
        osc2.detune.value = 2;
        
        // Dynamic filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(500, now);
        filter.frequency.exponentialRampToValueAtTime(1500 + this.motion * 200 + this.intensity * 100, now + 0.2);
        filter.frequency.exponentialRampToValueAtTime(800, now + 0.8);
        filter.Q.value = 2 + this.intensity * 0.5;
        
        // Smooth envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.6, now + 0.05); // Reduced
        env.gain.exponentialRampToValueAtTime(0.15, now + 0.3); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
        
        gain.gain.value = 0.2; // Reduced
        
        // Mix
        const mixer = this.ctx.createGain();
        osc.connect(mixer);
        osc2.connect(mixer);
        osc2.connect(mixer).gain.value = 0.15; // Reduced
        
        mixer.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.ostinato);
        
        osc.start(now);
        osc2.start(now);
        osc.stop(now + 1.0);
        osc2.stop(now + 1.0);
        
        this.ostinatoIndex = (this.ostinatoIndex + 1) % this.ostinatoPattern.length;
      }

      playHarmony() {
        const chord = this.chordProgression[this.currentChordIndex];
        const duration = 5 + this.intensity;
        const baseGain = 0.1 / chord.length; // Reduced
        const now = this.ctx.currentTime;

        chord.forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 3 + (i % 2));
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('harmony', osc, gain, duration)) return;
          
          // Warm sine waves
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          // Gentle filter movement
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(400, now);
          filter.frequency.exponentialRampToValueAtTime(800 + this.motion * 200, now + 2);
          filter.frequency.exponentialRampToValueAtTime(400, now + duration);
          filter.Q.value = 1;
          
          // Long, smooth envelope
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.6, now + 1.5); // Reduced
          env.gain.setValueAtTime(0.6, now + duration - 2);
          env.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          gain.gain.value = baseGain;
          
          osc.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.harmony);
          
          osc.start(now);
          osc.stop(now + duration);
        });
      }

      playLead() {
        const scale = this.scale;
        const noteIndex = Math.floor(Math.random() * scale.length);
        const freq = this.noteToFreq(scale[noteIndex], 5);
        const now = this.ctx.currentTime;
        
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const vibrato = this.ctx.createOscillator();
        const vibratoGain = this.ctx.createGain();
        
        if (!this.allocateVoice('lead', osc, gain, 2.0)) return;
        
        // Lead with vibrato
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        osc2.type = 'square';
        osc2.frequency.value = freq * 0.99;
        
        // Vibrato
        vibrato.type = 'sine';
        vibrato.frequency.value = 5;
        vibratoGain.gain.value = 8;
        
        vibrato.connect(vibratoGain);
        vibratoGain.connect(osc.frequency);
        vibratoGain.connect(osc2.frequency);
        
        // Dynamic filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq, now);
        filter.frequency.exponentialRampToValueAtTime(freq * 4, now + 0.5);
        filter.frequency.exponentialRampToValueAtTime(freq * 2, now + 1.5);
        filter.Q.value = 3 + this.intensity;
        
        // Expressive envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.05); // Reduced
        env.gain.setValueAtTime(0.5, now + 0.5);
        env.gain.exponentialRampToValueAtTime(0.2, now + 1.0); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 2.0);
        
        gain.gain.value = 0.25; // Reduced
        
        // Mix
        const mixer = this.ctx.createGain();
        osc.connect(mixer);
        osc2.connect(mixer);
        osc2.connect(mixer).gain.value = 0.2; // Reduced
        
        mixer.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.lead);
        
        vibrato.start(now);
        osc.start(now);
        osc2.start(now);
        vibrato.stop(now + 2);
        osc.stop(now + 2);
        osc2.stop(now + 2);
        
        this.lastLeadFreq = freq;
      }

      playPad() {
        const chord = this.chordProgression[this.currentChordIndex];
        const duration = 12 + this.intensity * 3;
        const now = this.ctx.currentTime;
        
        chord.forEach((note, i) => {
          const freq = this.noteToFreq(note, 2 + (i % 3));
          
          // Multiple detuned oscillators for lushness
          for (let d = 0; d < 3; d++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            if (!this.allocateVoice('pad', osc, gain, duration)) return;
            
            osc.type = 'sine';
            osc.frequency.value = freq;
            osc.detune.value = (d - 1) * 15;
            
            // Subtle filter movement
            filter.type = 'lowpass';
            filter.frequency.setValueAtTime(200, now);
            filter.frequency.exponentialRampToValueAtTime(400 + this.motion * 100, now + 4);
            filter.frequency.exponentialRampToValueAtTime(200, now + duration);
            filter.Q.value = 0.5;
            
            // Very slow attack
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.4, now + 4); // Reduced
            env.gain.setValueAtTime(0.4, now + duration - 4);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            gain.gain.value = 0.04; // Reduced
            
            osc.connect(filter);
            filter.connect(env);
            env.connect(gain);
            gain.connect(this.layerGains.pad);
            
            osc.start(now);
            osc.stop(now + duration);
          }
        });
      }

      playAtmosphere() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 6 + Math.random() * 2);
        const now = this.ctx.currentTime;
        const duration = 25;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        if (!this.allocateVoice('atmosphere', osc, gain, duration)) return;
        
        // High, ethereal tone
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        // LFO for movement
        lfo.type = 'sine';
        lfo.frequency.value = 0.2 + Math.random() * 0.3;
        lfoGain.gain.value = 50;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        
        // Lowpass instead of bandpass to avoid feedback
        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 0.5; // Low Q for smooth sound
        
        // Very slow envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.3, now + 8); // Reduced
        env.gain.setValueAtTime(0.3, now + duration - 8);
        env.gain.exponentialRampToValueAtTime(0.001, now + duration);
        
        gain.gain.value = 0.03; // Reduced
        
        osc.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.atmosphere);
        
        lfo.start(now);
        osc.start(now);
        lfo.stop(now + duration);
        osc.stop(now + duration);
      }

      playTexture() {
        const now = this.ctx.currentTime;
        const textureType = Math.floor(Math.random() * 3);
        
        switch(textureType) {
          case 0: // Granular texture
            this.playTextureGranular();
            break;
          case 1: // Harmonic texture
            this.playTextureHarmonic();
            break;
          case 2: // Noise texture
            this.playTextureNoise();
            break;
        }
      }

      playTextureGranular() {
        const now = this.ctx.currentTime;
        const grains = 3 + Math.floor(Math.random() * 4);
        
        for (let i = 0; i < grains; i++) {
          setTimeout(() => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const panner = this.ctx.createStereoPanner();
            
            if (!this.allocateVoice('texture', osc, gain, 0.1)) return;
            
            osc.type = 'sine';
            osc.frequency.value = 200 + Math.random() * 800;
            
            filter.type = 'bandpass';
            filter.frequency.value = 1000 + Math.random() * 2000;
            filter.Q.value = 10 + Math.random() * 10;
            
            panner.pan.value = Math.random() * 2 - 1;
            
            const grainNow = this.ctx.currentTime;
            env.gain.setValueAtTime(0, grainNow);
            env.gain.linearRampToValueAtTime(0.2, grainNow + 0.01); // Reduced
            env.gain.exponentialRampToValueAtTime(0.001, grainNow + 0.1);
            
            gain.gain.value = 0.15; // Reduced
            
            osc.connect(filter);
            filter.connect(panner);
            panner.connect(env);
            env.connect(gain);
            gain.connect(this.layerGains.texture);
            
            osc.start(grainNow);
            osc.stop(grainNow + 0.1);
          }, i * 20);
        }
      }

      playTextureHarmonic() {
        const now = this.ctx.currentTime;
        const fundamental = 100 + Math.random() * 200;
        const harmonics = 4 + Math.floor(Math.random() * 4);
        
        for (let h = 1; h <= harmonics; h++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('texture', osc, gain, 1.5)) return;
          
          osc.type = 'sine';
          osc.frequency.value = fundamental * h;
          
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.15 / h, now + 0.3); // Reduced
          env.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
          
          gain.gain.value = 0.12; // Reduced
          
          osc.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.texture);
          
          osc.start(now);
          osc.stop(now + 1.5);
        }
      }

      playTextureNoise() {
        const now = this.ctx.currentTime;
        const bufferSize = 0.5 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Filtered noise
        let lastSample = 0;
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          data[i] = lastSample * 0.9 + white * 0.1;
          lastSample = data[i];
        }
        
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('texture', noise, gain, 2)) return;
        
        // Change to lowpass to avoid resonance
        filter.type = 'lowpass';
        filter.frequency.value = 1000 + Math.random() * 2000;
        filter.Q.value = 0.5; // Low Q
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.12, now + 0.5); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 2);
        
        gain.gain.value = 0.15; // Reduced
        
        noise.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.texture);
        
        noise.start(now);
        noise.stop(now + 2);
      }

      playStrings() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(noteIndex, 3);
        const voices = this.stage === 'DIMENSIONAL' ? 4 : 3;
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < voices; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          const vibrato = this.ctx.createOscillator();
          const vibratoGain = this.ctx.createGain();
          
          if (!this.allocateVoice('strings', osc, gain, 4)) return;
          
          // String-like sawtooth
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.003);
          osc.detune.value = (i - voices/2) * 8;
          
          // Subtle vibrato
          vibrato.type = 'sine';
          vibrato.frequency.value = 4 + i * 0.5;
          vibratoGain.gain.value = 2;
          
          vibrato.connect(vibratoGain);
          vibratoGain.connect(osc.frequency);
          
          // Warm filter
          filter.type = 'lowpass';
          filter.frequency.value = 1000 + this.motion * 300 + this.intensity * 200;
          filter.Q.value = 1;
          
          // String-like envelope
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.5, now + 0.1); // Reduced
          env.gain.exponentialRampToValueAtTime(0.3, now + 1); // Reduced
          env.gain.exponentialRampToValueAtTime(0.001, now + 4);
          
          gain.gain.value = 0.06; // Reduced
          
          osc.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.strings);
          
          vibrato.start(now);
          osc.start(now);
          vibrato.stop(now + 4);
          osc.stop(now + 4);
        }
      }

      playBrass() {
        const note = this.scale[Math.floor(this.scale.length / 2)];
        const freq = this.noteToFreq(note, 3);
        const sections = ['trumpet', 'horn'];
        const now = this.ctx.currentTime;
        
        sections.forEach((section, i) => {
          const osc = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('brass', osc, gain, 4)) return;
          
          const sectionFreq = freq * Math.pow(2, -i * 0.5);
          
          // Brass-like sound with dual oscillators
          osc.type = 'sawtooth';
          osc.frequency.value = sectionFreq;
          
          osc2.type = 'square';
          osc2.frequency.value = sectionFreq * 0.99;
          
          // Brass filter
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(sectionFreq, now);
          filter.frequency.exponentialRampToValueAtTime(sectionFreq * 4 + this.intensity * 500, now + 0.2);
          filter.frequency.exponentialRampToValueAtTime(sectionFreq * 2, now + 2);
          filter.Q.value = 3 + this.intensity;
          
          // Brass envelope
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.6, now + 0.15); // Reduced
          env.gain.exponentialRampToValueAtTime(0.4, now + 1); // Reduced
          env.gain.exponentialRampToValueAtTime(0.001, now + 4);
          
          gain.gain.value = 0.15; // Reduced
          
          // Mix
          const mixer = this.ctx.createGain();
          osc.connect(mixer);
          osc2.connect(mixer);
          osc2.connect(mixer).gain.value = 0.2; // Reduced
          
          mixer.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.brass);
          
          osc.start(now);
          osc2.start(now);
          osc.stop(now + 4);
          osc2.stop(now + 4);
        });
      }

      playWoodwinds() {
        const note = this.scale[Math.floor(Math.random() * this.scale.length)];
        const freq = this.noteToFreq(note, 4 + Math.random());
        const now = this.ctx.currentTime;
        
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const breathNoise = this.ctx.createBufferSource();
        
        if (!this.allocateVoice('woodwinds', osc, gain, 3)) return;
        
        // Woodwind tone
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        osc2.type = 'sine';
        osc2.frequency.value = freq * 3;
        
        // Breath noise
        const noiseBuffer = this.ctx.createBuffer(1, 0.1 * this.ctx.sampleRate, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.04; // Reduced
        }
        breathNoise.buffer = noiseBuffer;
        breathNoise.loop = true;
        
        // Resonant filter - reduced Q
        filter.type = 'bandpass';
        filter.frequency.value = freq * 1.5;
        filter.Q.value = 2; // Reduced from 5
        
        // Woodwind envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.4, now + 0.1); // Reduced
        env.gain.exponentialRampToValueAtTime(0.2, now + 1); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 3);
        
        gain.gain.value = 0.15; // Reduced
        
        // Mix
        const mixer = this.ctx.createGain();
        osc.connect(mixer);
        osc2.connect(mixer);
        osc2.connect(mixer).gain.value = 0.08; // Reduced
        breathNoise.connect(mixer);
        breathNoise.connect(mixer).gain.value = 0.2; // Reduced
        
        mixer.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.woodwinds);
        
        osc.start(now);
        osc2.start(now);
        breathNoise.start(now);
        osc.stop(now + 3);
        osc2.stop(now + 3);
        breathNoise.stop(now + 3);
      }

      playChoir() {
        const vowelFormants = {
          'a': [730, 1090, 2440],
          'e': [270, 2290, 3010],
          'i': [390, 1990, 2550],
          'o': [570, 840, 2410],
          'u': [440, 1020, 2240]
        };
        
        const vowels = Object.keys(vowelFormants);
        const currentVowel = vowels[Math.floor(Date.now() / 5000) % vowels.length];
        const formants = vowelFormants[currentVowel];
        const now = this.ctx.currentTime;
        const duration = 18;
        
        this.chordProgression[this.currentChordIndex].forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 4 + (i % 2));
          
          // Multiple voices per note
          for (let v = 0; v < 2; v++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            
            const formantFilters = formants.map(formantFreq => {
              const filter = this.ctx.createBiquadFilter();
              filter.type = 'bandpass';
              filter.frequency.value = formantFreq;
              filter.Q.value = 8;
              return filter;
            });
            
            if (!this.allocateVoice('choir', osc, gain, duration)) return;
            
            osc.type = 'triangle';
            osc.frequency.value = freq;
            osc.detune.value = (v - 0.5) * 10;
            
            // Very slow attack for choir
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.3, now + 6); // Reduced
            env.gain.setValueAtTime(0.3, now + duration - 6);
            env.gain.exponentialRampToValueAtTime(0.001, now + duration);
            
            gain.gain.value = 0.04; // Reduced
            
            // Connect through formant filters
            let source = osc;
            formantFilters.forEach(filter => {
              source.connect(filter);
              source = filter;
            });
            source.connect(env);
            env.connect(gain);
            gain.connect(this.layerGains.choir);
            
            osc.start(now);
            osc.stop(now + duration);
          }
        });
      }

      playShepardTone() {
        const baseFreq = 220 * Math.pow(2, this.shepardIntensity * 0.5);
        const layers = this.dimensionalPhase ? 4 : 3;
        const now = this.ctx.currentTime;
        const duration = 6;
        
        for (let i = 0; i < layers; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('shepard', osc, gain, duration)) return;
          
          const freq = baseFreq * Math.pow(2, i);
          osc.type = 'sine';
          
          // Shepard tone pitch sweep
          if (this.shepardRising) {
            osc.frequency.setValueAtTime(freq, now);
            osc.frequency.exponentialRampToValueAtTime(freq * 2, now + duration);
          } else {
            osc.frequency.setValueAtTime(freq * 2, now);
            osc.frequency.exponentialRampToValueAtTime(freq, now + duration);
          }
          
          // Amplitude based on position in spectrum
          const amplitude = Math.sin((i / layers) * Math.PI) * this.shepardIntensity * 0.6; // Reduced
          
          filter.type = 'bandpass';
          filter.frequency.value = freq * 1.5;
          filter.Q.value = 2;
          
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(amplitude, now + 1);
          env.gain.setValueAtTime(amplitude, now + duration - 1);
          env.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          gain.gain.value = 0.12; // Reduced
          
          osc.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.shepard);
          
          osc.start(now);
          osc.stop(now + duration);
        }
        
        if (Math.random() < 0.1) {
          this.shepardRising = !this.shepardRising;
        }
      }

      playGranular() {
        if (!this.granularBuffer) return;
        
        const grains = 3 + Math.floor(this.intensity * 2);
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < grains; i++) {
          const source = this.ctx.createBufferSource();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          const panner = this.ctx.createStereoPanner();
          
          if (!this.allocateVoice('granular', source, gain, 0.4)) return;
          
          source.buffer = this.granularBuffer;
          source.playbackRate.value = 0.5 + Math.random() * 1.5;
          
          const startTime = Math.random() * (this.granularBuffer.duration - 0.1);
          const grainDuration = 0.05 + Math.random() * 0.3;
          
          filter.type = 'bandpass';
          filter.frequency.value = 500 + Math.random() * 3000;
          filter.Q.value = 3 + Math.random() * 5;
          
          panner.pan.value = Math.random() * 2 - 1;
          
          // Smooth grain envelope
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.2, now + grainDuration * 0.3); // Reduced
          env.gain.linearRampToValueAtTime(0, now + grainDuration);
          
          gain.gain.value = 0.2; // Reduced
          
          source.connect(filter);
          filter.connect(panner);
          panner.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.granular);
          
          source.start(now, startTime, grainDuration);
        }
      }

      playGlitch() {
        const glitchTypes = ['bitcrush', 'stutter', 'reverse', 'slice'];
        const type = glitchTypes[Math.floor(Math.random() * glitchTypes.length)];
        
        switch (type) {
          case 'bitcrush':
            this.playBitcrush();
            break;
          case 'stutter':
            this.playStutter();
            break;
          case 'reverse':
            this.playReverse();
            break;
          case 'slice':
            this.playSlice();
            break;
        }
      }

      playBitcrush() {
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const crusher = this.ctx.createWaveShaper();
        
        if (!this.allocateVoice('glitch', osc, gain, 0.5)) return;
        
        osc.type = 'square';
        osc.frequency.value = 440 + Math.random() * 880;
        
        // Bitcrusher curve
        const bits = 3 + Math.floor(this.intensity * 3);
        const curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          const x = (i - 128) / 128;
          const step = 2 / Math.pow(2, bits);
          curve[i] = Math.round(x / step) * step;
        }
        crusher.curve = curve;
        crusher.oversample = 'none';
        
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.01); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        
        gain.gain.value = 0.25; // Reduced
        
        osc.connect(crusher);
        crusher.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.glitch);
        
        osc.start(now);
        osc.stop(now + 0.5);
      }

      playStutter() {
        const freq = 200 + Math.random() * 400;
        const stutters = 3 + Math.floor(Math.random() * 3);
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < stutters; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('glitch', osc, gain, 0.1)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.1);
          
          const stutterTime = now + i * 0.05;
          env.gain.setValueAtTime(0, stutterTime);
          env.gain.linearRampToValueAtTime(0.4, stutterTime + 0.005); // Reduced
          env.gain.exponentialRampToValueAtTime(0.001, stutterTime + 0.04);
          
          gain.gain.value = 0.25; // Reduced
          
          osc.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.glitch);
          
          osc.start(stutterTime);
          osc.stop(stutterTime + 0.1);
        }
      }

      playReverse() {
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('glitch', osc, gain, 1)) return;
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(1000, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 1);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(4000, now);
        filter.frequency.exponentialRampToValueAtTime(200, now + 1);
        filter.Q.value = 8;
        
        // Reverse envelope
        env.gain.setValueAtTime(0.001, now);
        env.gain.exponentialRampToValueAtTime(0.5, now + 0.8); // Reduced
        env.gain.linearRampToValueAtTime(0, now + 1);
        
        gain.gain.value = 0.25; // Reduced
        
        osc.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.glitch);
        
        osc.start(now);
        osc.stop(now + 1);
      }

      playSlice() {
        const slices = 4 + Math.floor(Math.random() * 3);
        const baseFreq = 300 + Math.random() * 600;
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < slices; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('glitch', osc, gain, 0.05)) return;
          
          osc.type = 'square';
          osc.frequency.value = baseFreq * Math.pow(1.5, i);
          
          const sliceTime = now + i * 0.025;
          env.gain.setValueAtTime(0, sliceTime);
          env.gain.linearRampToValueAtTime(0.4, sliceTime + 0.003); // Reduced
          env.gain.exponentialRampToValueAtTime(0.001, sliceTime + 0.02);
          
          gain.gain.value = 0.2; // Reduced
          
          osc.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.glitch);
          
          osc.start(sliceTime);
          osc.stop(sliceTime + 0.05);
        }
      }

      playRiser() {
        const duration = 4 + this.intensity * 2;
        const now = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('risers', osc, gain, duration)) return;
        
        // Dual oscillators for thickness
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(50, now);
        osc.frequency.exponentialRampToValueAtTime(2000, now + duration);
        
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(100, now);
        osc2.frequency.exponentialRampToValueAtTime(1000, now + duration);
        
        // Filter sweep
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(100, now);
        filter.frequency.exponentialRampToValueAtTime(10000, now + duration);
        filter.Q.value = 5;
        
        // Rising envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.6, now + duration); // Reduced
        
        gain.gain.value = 0.3; // Reduced
        
        // Mix
        const mixer = this.ctx.createGain();
        osc.connect(mixer);
        osc2.connect(mixer);
        osc2.connect(mixer).gain.value = 0.2; // Reduced
        
        mixer.connect(filter);
        filter.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.risers);
        
        osc.start(now);
        osc2.start(now);
        osc.stop(now + duration);
        osc2.stop(now + duration);
      }

      playImpact(x = 0.5, y = 0.5) {
        const freq = 50 + (1 - y) * 40; // Higher base frequency
        const stereoPos = (x - 0.5) * 2;
        const now = this.ctx.currentTime;
        
        // Sub impact
        const osc1 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const panner = this.ctx.createStereoPanner();
        const highpass = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('impacts', osc1, gain, 1.5)) return;
        
        // Deep sub with highpass
        osc1.type = 'sine';
        osc1.frequency.setValueAtTime(freq * 1.5, now);
        osc1.frequency.exponentialRampToValueAtTime(freq * 0.5, now + 1.0);
        
        // Remove extreme lows
        highpass.type = 'highpass';
        highpass.frequency.value = 40;
        highpass.Q.value = 0.5;
        
        // Impact filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 8, now);
        filter.frequency.exponentialRampToValueAtTime(freq * 2, now + 0.3);
        filter.Q.value = 2;
        
        panner.pan.value = stereoPos;
        
        // Softer envelope
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.01); // Reduced
        env.gain.exponentialRampToValueAtTime(0.15, now + 0.08); // Reduced
        env.gain.exponentialRampToValueAtTime(0.001, now + 1.0);
        
        gain.gain.value = 0.4; // Reduced
        
        osc1.connect(highpass);
        highpass.connect(filter);
        filter.connect(panner);
        panner.connect(env);
        env.connect(gain);
        gain.connect(this.layerGains.impacts);
        
        osc1.start(now);
        osc1.stop(now + 1.5);
        
        // Trigger visual flash
        this.flashImpact();
      }

      playGoldenRatioChord() {
        console.log('✨ GOLDEN RATIO CHORD: Divine Harmony');
        const phi = 1.618033988749;
        const baseFreq = 220;
        const now = this.ctx.currentTime;
        const duration = 12;
        
        const ratios = [1, phi, phi * phi, 1 / phi];
        
        ratios.forEach((ratio, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('shepard', osc, gain, duration)) return;
          
          osc.type = 'sine';
          osc.frequency.value = baseFreq * ratio;
          
          filter.type = 'bandpass';
          filter.frequency.value = baseFreq * ratio;
          filter.Q.value = 20;
          
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.3, now + 3); // Reduced
          env.gain.setValueAtTime(0.3, now + duration - 3);
          env.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          gain.gain.value = 0.15; // Reduced
          
          osc.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.shepard);
          
          osc.start(now);
          osc.stop(now + duration);
        });
        
        this.easterEggs.goldenRatio = true;
      }

      playInfiniteLoop() {
        console.log('∞ INFINITE LOOP: Shepard\'s Dream');
        const layers = 6;
        const duration = 20;
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < layers; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('shepard', osc, gain, duration)) return;
          
          const baseFreq = 55 * Math.pow(2, i / 6);
          
          osc.type = 'sine';
          osc.frequency.setValueAtTime(baseFreq, now);
          osc.frequency.exponentialRampToValueAtTime(baseFreq * 4, now + duration / 2);
          osc.frequency.exponentialRampToValueAtTime(baseFreq, now + duration);
          
          const amplitude = Math.sin((i / layers) * Math.PI * 2) * 0.5 + 0.5;
          
          filter.type = 'bandpass';
          filter.frequency.value = baseFreq * 2;
          filter.Q.value = 6;
          
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(amplitude * 0.25, now + 2); // Reduced
          env.gain.setValueAtTime(amplitude * 0.25, now + duration - 2);
          env.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          gain.gain.value = 0.2; // Reduced
          
          osc.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.shepard);
          
          osc.start(now);
          osc.stop(now + duration);
        }
        
        this.easterEggs.shepardInfinity = true;
      }

      playSereneResonance() {
        const baseFreq = 110;
        const duration = 15;
        const layers = 3;
        const now = this.ctx.currentTime;

        for (let i = 0; i < layers; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('atmosphere', osc, gain, duration)) return;
          
          osc.type = 'sine';
          osc.frequency.value = baseFreq * (1 + i * 0.5);
          
          filter.type = 'lowpass';
          filter.frequency.setValueAtTime(200, now);
          filter.frequency.exponentialRampToValueAtTime(800, now + duration / 2);
          filter.frequency.exponentialRampToValueAtTime(200, now + duration);
          filter.Q.value = 1;
          
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.25, now + 4); // Reduced
          env.gain.setValueAtTime(0.25, now + duration - 4);
          env.gain.exponentialRampToValueAtTime(0.001, now + duration);
          
          gain.gain.value = 0.1; // Reduced
          
          osc.connect(filter);
          filter.connect(env);
          env.connect(gain);
          gain.connect(this.layerGains.atmosphere);
          
          osc.start(now);
          osc.stop(now + duration);
        }
      }

      allocateVoice(layer, osc, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) return false;
        
        // Clean up finished voices
        const now = this.ctx.currentTime;
        pool.active = pool.active.filter(voice => now <= voice.startTime + voice.duration + 0.1);
        
        // Check if at limit
        if (pool.active.length >= pool.max) {
          // Kill oldest voice smoothly
          const oldest = pool.active.shift();
          if (oldest && oldest.osc && oldest.gain) {
            oldest.gain.gain.cancelScheduledValues(now);
            oldest.gain.gain.linearRampToValueAtTime(0, now + 0.02);
            
            if (oldest.osc.stop) {
              oldest.osc.stop(now + 0.03);
            }
          }
        }
        
        const voice = { osc, gain: gainNode, startTime: now, duration };
        pool.active.push(voice);
        
        return true;
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
        
        const dissonantChords = [1, 6];
        this.harmonicTension = dissonantChords.includes(this.currentChordIndex) ? 0.8 : 0.3;
      }

      noteToFreq(note, octave = 4) {
        const semitones = this.keyOffsets[this.key] + note;
        return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
      }

      updateUI() {
        this.elements.stageName.textContent = this.voidPhase ? 'VOID STATE' : this.stage;
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        
        const totalVoices = Object.values(this.voicePool).reduce((sum, pool) => sum + pool.active.length, 0);
        this.elements.voiceCount.textContent = totalVoices;
        
        const intensityPercent = Math.min(this.intensity * 25, 100);
        this.elements.intensityDisplay.textContent = Math.round(intensityPercent) + '%';
        
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.dataArray);
          this.waveBars.forEach((bar, i) => {
            const dataIndex = Math.floor(i * (this.dataArray.length / 16));
            const height = (this.dataArray[dataIndex] / 255) * 50;
            bar.style.height = height + 'px';
              
            let color = 'rgba(255,255,255,0.6)';
            if (this.voidPhase) color = 'rgba(147,112,219,0.4)'; // Soft purple for void
            else if (this.stage === 'TRIBAL') color = 'rgba(255,69,0,0.8)';
            else if (this.stage === 'ORCHESTRAL') color = 'rgba(30,144,255,0.8)';
            else if (this.stage === 'TRANSCENDENT') color = 'rgba(138,43,226,0.8)';
            else if (this.stage === 'DIMENSIONAL') color = 'linear-gradient(0deg, rgba(0,255,255,0.8), rgba(255,0,255,0.8))';
              
            bar.style.background = color;
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          if (this.step % 16 === 0) {
            this.updateUI();
          }
          
          const theme = this.themes[this.voidPhase ? 'void' : this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 5, 1);
          
          let bg;
          if (this.voidPhase) {
            // Soft, breathing gradient for void state
            const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
            bg = `radial-gradient(circle at 50% 50%, rgba(147, 112, 219, ${0.1 + breathe * 0.1}) 5%, rgba(75, 0, 130, ${0.05 + breathe * 0.05}) 20%, #000000 60%)`;
          } else if (this.dimensionalPhase) {
            const hue = (Date.now() / 20 % 360);
            bg = `radial-gradient(circle at 50% 50%, hsl(${hue}, 70%, ${20 + intensityNorm * 30}%) 5%, hsl(${(hue + 120) % 360}, 70%, ${15 + intensityNorm * 20}%) 20%, #000000 60%)`;
          } else {
            bg = `radial-gradient(circle at 50% 50%, ${theme.colors[0]} 5%, ${theme.colors[1] || '#050505'} 20%, #050505 60%)`;
          }
          
          document.body.style.background = bg;
          
          this.elements.cinematicOverlay.classList.toggle('active', this.buildPhase || this.climaxPhase || this.intensity > 3);
          
          const uiOpacity = Math.max(0.3, 1 - this.intensity * 0.1);
          this.elements.uiMinimal.style.opacity = uiOpacity;
          
          if (this.gestureRecognition.wave > 0.5) {
            this.elements.orb.style.filter = `drop-shadow(0 0 ${20 + this.gestureRecognition.wave * 10}px rgba(255,255,255,0.3))`;
          }
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        // If in void phase, maintain peaceful state
        if (this.voidPhase) {
          this.layers = Object.fromEntries(Object.keys(this.layers).map(k => [k, false]));
          return;
        }
        
        const activationThreshold = this.buildPhase ? 0.8 : this.climaxPhase ? 0.5 : 1.2;
        const deactivationThreshold = 0.7;
        
        this.layers.kick = avgMotion > activationThreshold || (this.layers.kick && avgMotion > deactivationThreshold);
        this.layers.bass = (avgMotion > 1.2 || (this.layers.bass && avgMotion > 0.6)) && (this.motionPattern !== 'calm');
        this.layers.hihat = (avgMotion > 1.8 || this.intensity > 1.2 || this.motionPattern === 'rhythmic');
        this.layers.snare = (avgMotion > 2.2 && this.intensity > 1.8) || (this.motionPattern === 'erratic');
        this.layers.percussion = this.motionPattern === 'rhythmic' && avgMotion > 2;
        
        this.layers.ostinato = avgMotion > 1 && this.stage !== 'SILENCE';
        this.layers.harmony = (avgMotion > 2.5 || this.intensity > 2) && !this.releasePhase;
        this.layers.lead = this.stage !== 'SILENCE' && avgMotion > 2.5 && this.buildPhase;
        
        this.layers.pad = avgMotion < 2 && this.totalMotion > 100 && this.releasePhase;
        this.layers.atmosphere = this.intensity < 1.5 && avgMotion < 2 && (this.releasePhase || this.stage === 'SILENCE');
        this.layers.texture = this.intensity > 1.5 && this.motionPattern !== 'calm';
        
        this.layers.strings = this.stage !== 'SILENCE' && avgMotion > 1.5;
        this.layers.brass = this.stage !== 'SILENCE' && this.intensity > 2 && (this.buildPhase || this.climaxPhase);
        this.layers.woodwinds = this.stage === 'ORCHESTRAL' && avgMotion > 1 && avgMotion < 3;
        this.layers.choir = (this.stage === 'TRANSCENDENT' || this.stage === 'DIMENSIONAL') && avgMotion < 2.5 && this.releasePhase;
        
        this.layers.shepard = this.shepardIntensity > 0.1;
        this.layers.granular = this.stage !== 'SILENCE' && this.intensity > 2;
        this.layers.glitch = this.glitchProbability > 0.1 || this.motionPattern === 'chaotic';
        this.layers.risers = this.buildPhase && this.intensity > 2.5;
        this.layers.impacts = this.gestureRecognition.tap > 0.5;
        
        if (this.motionPattern === 'wavy') {
          this.layers.atmosphere = true;
          this.layers.pad = true;
        }
        
        this.evolutionProgress = Math.min(this.totalMotion / 1500, 4);
        this.subStage = Math.floor(this.evolutionProgress);
        
        const now = Date.now();
        if (this.stage === 'TRIBAL' && this.totalMotion > 400 && now - this.lastEvolutionTime > 10000) {
          this.evolveToOrchestral();
          this.lastEvolutionTime = now;
        } else if (this.stage === 'ORCHESTRAL' && this.totalMotion > 800 && now - this.lastEvolutionTime > 15000) {
          this.evolveToTranscendent();
          this.lastEvolutionTime = now;
        } else if (this.stage === 'TRANSCENDENT' && this.totalMotion > 1200 && this.specialEvents.dimensionalRift > 0) {
          this.evolveToDimensional();
          this.lastEvolutionTime = now;
        }
        
        let baseBPM = 60 + (avgMotion * 10) + (this.intensity * 8);
        baseBPM += (this.subStage * 20);
        
        if (this.stage === 'TRIBAL') baseBPM += 30;
        else if (this.stage === 'ORCHESTRAL') baseBPM += 50;
        else if (this.stage === 'TRANSCENDENT') baseBPM += 80;
        else if (this.stage === 'DIMENSIONAL') baseBPM += 120;
        
        if (this.buildPhase) baseBPM *= 1.3;
        if (this.climaxPhase) baseBPM *= 1.5;
        if (this.releasePhase) baseBPM *= 0.7;
        if (this.dimensionalPhase) baseBPM *= (1 + Math.sin(Date.now() * 0.001) * 0.3);
        
        this.bpm = this.bpm * 0.8 + baseBPM * 0.2;
        this.bpm = Math.max(40, Math.min(220, this.bpm));
        
        this.updateCinematicTheme(avgMotion, this.intensity);
      }

      updateCinematicTheme(avgMotion, intensity) {
        let newTheme = 'awakening';
        
        if (this.voidPhase) {
          newTheme = 'void';
          this.bpm = 40; // Slow BPM for void state
        } else if (this.dimensionalPhase) newTheme = 'dimensional';
        else if (this.motionPattern === 'chaotic' || intensity > 4) newTheme = 'chaos';
        else if (avgMotion > 5 && intensity > 3.5 && (this.buildPhase || this.climaxPhase)) newTheme = 'triumph';
        else if (avgMotion > 3 && intensity > 2.5) newTheme = 'tension';
        else if (avgMotion > 2) newTheme = 'adventure';
        else if (avgMotion < 2 && this.totalMotion > 200 && this.releasePhase) newTheme = 'reflection';
        else if (this.motionPattern === 'wavy') newTheme = 'reflection';
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.elements.themeText.textContent = this.themes[newTheme].text;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 5000);
        }
      }

      updateProceduralSystems(avgMotion, variance) {
        const now = this.ctx.currentTime;
        
        // Update layer filters smoothly
        Object.keys(this.layerFilters).forEach(layer => {
          if (this.layerFilters[layer] && this.layers[layer]) {
            const baseFreq = this.getLayerBaseFrequency(layer);
            const modulation = avgMotion * 100 + variance * 50 + Math.sin(Date.now() * 0.001 + this.getLayerPhase(layer)) * 200;
            const targetFreq = Math.min(baseFreq + modulation, 20000);
            
            this.layerFilters[layer].frequency.linearRampToValueAtTime(targetFreq, now + 0.05);
            this.layerFilters[layer].Q.linearRampToValueAtTime(1 + this.intensity * 0.5, now + 0.05);
          }
        });
        
        this.updateDynamicSpatialPositioning(avgMotion, variance);
      }

      getLayerBaseFrequency(layer) {
        const frequencies = {
          kick: 100, bass: 200, hihat: 8000, snare: 2000, percussion: 1500,
          ostinato: 1000, harmony: 800, lead: 1200,
          pad: 500, atmosphere: 300, texture: 1500,
          strings: 1000, brass: 800, woodwinds: 1200, choir: 600,
          shepard: 2000, granular: 1800, glitch: 5000, risers: 500, impacts: 150
        };
        return frequencies[layer] || 1000;
      }

      getLayerPhase(layer) {
        const phases = {
          kick: 0, bass: 0.5, hihat: 1.2, snare: 0.8, percussion: 1.5,
          ostinato: 2, harmony: 2.5, lead: 3,
          pad: 4, atmosphere: 4.5, texture: 5,
          strings: 6, brass: 6.5, woodwinds: 7, choir: 7.5,
          shepard: 8, granular: 8.5, glitch: 9, risers: 9.5, impacts: 10
        };
        return phases[layer] || 0;
      }

      updateDynamicSpatialPositioning(avgMotion, variance) {
        const time = Date.now() * 0.001;
        const now = this.ctx.currentTime;
        
        Object.keys(this.layerPanners).forEach(layer => {
          if (this.layerPanners[layer] && this.layers[layer]) {
            const basePos = this.getLayerBasePosition(layer);
            
            const motionX = Math.sin(time * 0.5 + basePos.phase) * avgMotion * 0.5;
            const motionY = Math.cos(time * 0.3 + basePos.phase) * variance * 0.3;
            const motionZ = Math.sin(time * 0.7 + basePos.phase) * this.intensity * 0.2;
            
            if (this.dimensionalPhase) {
              const dimX = Math.sin(time * 2 + basePos.phase) * 5;
              const dimY = Math.cos(time * 1.5 + basePos.phase) * 3;
              const dimZ = Math.sin(time * 3 + basePos.phase) * 8;
              
              this.layerPanners[layer].positionX.linearRampToValueAtTime(basePos.x + motionX + dimX, now + 0.1);
              this.layerPanners[layer].positionY.linearRampToValueAtTime(basePos.y + motionY + dimY, now + 0.1);
              this.layerPanners[layer].positionZ.linearRampToValueAtTime(basePos.z + motionZ + dimZ, now + 0.1);
            } else {
              this.layerPanners[layer].positionX.linearRampToValueAtTime(basePos.x + motionX, now + 0.1);
              this.layerPanners[layer].positionY.linearRampToValueAtTime(basePos.y + motionY, now + 0.1);
              this.layerPanners[layer].positionZ.linearRampToValueAtTime(basePos.z + motionZ, now + 0.1);
            }
          }
        });
      }

      getLayerBasePosition(layer) {
        const positions = {
          kick: { x: 0, y: -1, z: -2, phase: 0 },
          bass: { x: 0, y: -2, z: -3, phase: 0.5 },
          hihat: { x: 1, y: 1, z: -2, phase: 1 },
          snare: { x: 0, y: 0, z: -1, phase: 1.5 },
          percussion: { x: -1, y: 1, z: -2, phase: 2 },
          ostinato: { x: -3, y: 0, z: -4, phase: 2.5 },
          harmony: { x: 3, y: 0, z: -4, phase: 3 },
          lead: { x: 0, y: 1, z: -3, phase: 3.5 },
          pad: { x: 0, y: 3, z: 8, phase: 4.5 },
          atmosphere: { x: 0, y: 5, z: 15, phase: 5 },
          texture: { x: 0, y: 2, z: 6, phase: 5.5 },
          strings: { x: -6, y: 0, z: -8, phase: 6 },
          brass: { x: 6, y: 0, z: -8, phase: 6.5 },
          woodwinds: { x: -4, y: 1, z: -6, phase: 7 },
          choir: { x: 0, y: 4, z: 12, phase: 7.5 },
          shepard: { x: 0, y: 8, z: -15, phase: 8 },
          granular: { x: -8, y: 2, z: -10, phase: 8.5 },
          glitch: { x: 8, y: -2, z: -5, phase: 9 },
          risers: { x: 0, y: 6, z: -20, phase: 9.5 },
          impacts: { x: 0, y: -3, z: -1, phase: 10 }
        };
        return positions[layer] || { x: 0, y: 0, z: 0, phase: 0 };
      }

      triggerShakeEffects() {
        console.log('🌪️ SHAKE DETECTED: Chaos Unleashed');
        this.gestureRecognition.shake = 0;
        this.specialEvents.glitchStorm = 2;
        this.glitchProbability += 0.3;
        this.layers.glitch = true;
        this.layers.impacts = true;
        this.bpm += 20;
        this.flashImpact();
      }

      triggerChaosMode() {
        console.log('🔥 CHAOS MODE: Reality Breaks Down');
        this.gestureRecognition.chaos = 0;
        this.currentTheme = 'chaos';
        this.specialEvents.glitchStorm = 3;
        this.specialEvents.harmonicResonance = 2;
        this.glitchProbability = 0.6;
        this.layers.glitch = true;
        this.scale = this.scales.chromatic;
      }

      triggerImpactEffects() {
        this.layers.impacts = true;
        setTimeout(() => this.layers.impacts = false, 200);
      }

      evolveToTribal() {
        this.voidPhase = false;
        this.stage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.mode = 'pentatonic';
        this.scale = this.scales.pentatonic;
        console.log('🔥 TRIBAL EVOLUTION: Primal Fire Awakens');
      }

      evolveToOrchestral() {
        this.stage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.mode = 'dorian';
        this.scale = this.scales.dorian;
        console.log('🌊 ORCHESTRAL EVOLUTION: Symphonic Depths');
      }

      evolveToTranscendent() {
        this.stage = 'TRANSCENDENT';
        this.elements.orb.className = 'orb transcendent';
        this.mode = 'lydian';
        this.scale = this.scales.lydian;
        this.layers.choir = true;
        console.log('✨ TRANSCENDENT EVOLUTION: Beyond Mortal Sound');
      }

      evolveToDimensional() {
        this.stage = 'DIMENSIONAL';
        this.elements.orb.className = 'orb dimensional';
        this.mode = 'wholeTone';
        this.scale = this.scales.wholeTone;
        this.dimensionalPhase = true;
        this.specialEvents.dimensionalRift = 3;
        console.log('🌌 DIMENSIONAL EVOLUTION: Reality Transcended');
      }

      syncBPMToSteps() {
        if (this.stepCounter < 4) return;
        
        const stepInterval = (Date.now() - this.lastStepTime * (this.stepCounter - 1)) / (this.stepCounter - 1);
        const targetBPM = 60 / (stepInterval / 1000) * 1.8;
        
        this.bpm = this.bpm * 0.5 + targetBPM * 0.5;
        this.bpm = Math.max(40, Math.min(220, this.bpm));
        
        if (this.specialEvents.timeDilation > 0) {
          this.bpm *= this.specialEvents.timeDilation;
        }
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          this.microRhythm = (this.microRhythm + 1) % 4;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.updateHarmony();
          }
          
          const baseInterval = (60 / this.bpm) * 250;
          const swingFactor = this.motionPattern === 'rhythmic' ? 1.1 : 1;
          const microTiming = this.microRhythm % 2 === 1 ? swingFactor : 1;
          const chaosOffset = this.motionPattern === 'chaotic' ? (Math.random() - 0.5) * 50 : 0;
          
          const interval = baseInterval * microTiming + chaosOffset;
          setTimeout(tick, Math.max(50, interval));
        };
        tick();
      }

      playStep() {
        // Skip all playback during void phase
        if (this.voidPhase) return;
        
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 120);
        }
        
        if (this.layers.kick && this.step % 8 === 0) this.playKick();
        if (this.layers.bass && this.step % 4 === 0) this.playBass();
        if (this.layers.hihat && this.step % 2 === 1 && Math.random() < 0.8) this.playHihat();
        if (this.layers.snare && (this.step % 8 === 4 || (this.motionPattern === 'erratic' && this.step % 8 === 6 && Math.random() < 0.6))) this.playSnare();
        if (this.layers.percussion && this.step % 3 === 0 && Math.random() < 0.7) this.playPercussion();
        
        if (this.layers.ostinato && this.step % 2 === 0) this.playOstinato();
        if (this.layers.harmony && this.step % 16 === 0) this.playHarmony();
        if (this.layers.lead && this.step % 8 === 0 && Math.random() < 0.8) this.playLead();
        
        if (this.layers.pad && this.step % 32 === 0 && this.releasePhase) this.playPad();
        if (this.layers.atmosphere && Math.random() < 0.02 && this.releasePhase) this.playAtmosphere();
        if (this.layers.texture && Math.random() < 0.1) this.playTexture();
        
        if (this.layers.strings && (this.step % 4 === 0 || this.buildPhase)) this.playStrings();
        if (this.layers.brass && this.step % 16 === 0 && this.buildPhase) this.playBrass();
        if (this.layers.woodwinds && this.step % 12 === 0) this.playWoodwinds();
        if (this.layers.choir && this.step % 32 === 0 && this.releasePhase) this.playChoir();
        
        if (this.layers.shepard && this.step % 8 === 0) this.playShepardTone();
        if (this.layers.granular && Math.random() < 0.15) this.playGranular();
        if (this.layers.glitch && Math.random() < this.glitchProbability) this.playGlitch();
        if (this.layers.risers && this.step % 64 === 0) this.playRiser();
        if (this.layers.impacts && Math.random() < 0.3) this.playImpact();
        
        Object.keys(this.specialEvents).forEach(event => {
          this.specialEvents[event] = Math.max(0, this.specialEvents[event] - 0.01);
        });
      }
    }

    new VoidEngine();
  </script>
</body>
</html>
