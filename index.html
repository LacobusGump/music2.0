<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>SYMBIONT</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #000;
  color: #fff;
  overflow: hidden;
  height: 100vh;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  cursor: none;
  user-select: none;
  position: relative;
}

/* Quantum Field Background */
#quantumField {
  position: fixed;
  inset: 0;
  opacity: 0.8;
}

/* Neural Network Visualization */
.neural-web {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0;
  transition: opacity 3s cubic-bezier(0.23, 1, 0.320, 1);
}

.neural-web.active {
  opacity: 1;
}

.synapse {
  position: absolute;
  background: linear-gradient(90deg, 
    transparent 0%, 
    rgba(255,255,255,0.1) 50%, 
    transparent 100%);
  height: 1px;
  transform-origin: left center;
  animation: synaptic-fire 3s ease-in-out infinite;
}

@keyframes synaptic-fire {
  0%, 100% { opacity: 0.1; }
  50% { opacity: 0.6; }
}

/* DNA Helix Core */
.dna-core {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 377px;
  height: 610px;
  pointer-events: none;
  perspective: 1000px;
  opacity: 0;
  transition: opacity 3s;
}

.dna-core.active {
  opacity: 1;
}

.dna-strand {
  position: absolute;
  width: 100%;
  height: 100%;
  transform-style: preserve-3d;
  animation: dna-rotate 20s linear infinite;
}

@keyframes dna-rotate {
  to { transform: rotateY(360deg); }
}

.genome-node {
  position: absolute;
  width: 5px;
  height: 5px;
  border-radius: 50%;
  background: radial-gradient(circle, 
    rgba(255,255,255,0.9) 0%, 
    rgba(255,255,255,0.3) 50%, 
    transparent 100%);
  box-shadow: 0 0 20px rgba(255,255,255,0.5);
}

/* Spectral Analyzer Matrix */
.spectral-matrix {
  position: fixed;
  bottom: 0;
  left: 0;
  right: 0;
  height: 144px;
  display: grid;
  grid-template-columns: repeat(144, 1fr);
  gap: 1px;
  padding: 21px;
  pointer-events: none;
  opacity: 0.618;
}

.freq-column {
  display: flex;
  flex-direction: column-reverse;
  gap: 1px;
}

.freq-cell {
  background: rgba(255,255,255,0.1);
  transition: all 0.1s linear;
}

.freq-cell.active {
  background: rgba(255,255,255,0.9);
  box-shadow: 0 0 10px rgba(255,255,255,0.8);
}

/* Memory Palace */
.memory-palace {
  position: fixed;
  top: 34px;
  left: 34px;
  display: grid;
  grid-template-columns: repeat(8, 34px);
  gap: 8px;
  opacity: 0.618;
}

.memory-cell {
  width: 34px;
  height: 34px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 3px;
  position: relative;
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
}

.memory-cell.filled {
  border-color: rgba(255,255,255,0.382);
  background: radial-gradient(circle at center, 
    rgba(255,255,255,0.1) 0%, 
    transparent 61.8%);
}

.memory-cell.active {
  border-color: rgba(255,255,255,0.618);
  box-shadow: 0 0 21px rgba(255,255,255,0.5);
  transform: scale(1.1);
}

.memory-wave {
  position: absolute;
  inset: 0;
  opacity: 0.5;
}

/* Evolution State Display */
.evolution-display {
  position: fixed;
  bottom: 21px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  opacity: 0;
  transition: opacity 1.618s;
}

.evolution-display.active {
  opacity: 1;
}

.state-label {
  font-size: 8px;
  letter-spacing: 5px;
  text-transform: uppercase;
  opacity: 0.382;
  margin-bottom: 8px;
}

.state-value {
  font-size: 13px;
  letter-spacing: 8px;
  opacity: 0.618;
  font-weight: 100;
}

/* Harmonic Constellation */
.harmonic-constellation {
  position: fixed;
  inset: 0;
  pointer-events: none;
}

.harmonic-star {
  position: absolute;
  width: 2px;
  height: 2px;
  background: #fff;
  border-radius: 50%;
  opacity: 0;
  animation: star-birth 5s ease-in-out;
}

@keyframes star-birth {
  0% { 
    opacity: 0; 
    transform: scale(0);
  }
  50% { 
    opacity: 1; 
    transform: scale(1.5);
  }
  100% { 
    opacity: 0; 
    transform: scale(0.5);
  }
}

/* Rhythm Pulse Grid */
.rhythm-grid {
  position: fixed;
  top: 50%;
  right: 34px;
  transform: translateY(-50%);
  display: grid;
  grid-template-columns: repeat(4, 13px);
  grid-template-rows: repeat(16, 13px);
  gap: 3px;
  opacity: 0.382;
}

.rhythm-cell {
  width: 13px;
  height: 13px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 2px;
  transition: all 0.15s ease;
}

.rhythm-cell.active {
  background: rgba(255,255,255,0.618);
  border-color: rgba(255,255,255,0.8);
  box-shadow: 0 0 13px rgba(255,255,255,0.6);
}

/* Quantum State Indicator */
.quantum-state {
  position: fixed;
  top: 34px;
  right: 34px;
  width: 89px;
  height: 89px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 34px;
  opacity: 0.382;
  transition: all 0.3s ease;
}

.quantum-state.entangled {
  border-color: rgba(255,255,255,0.618);
  box-shadow: 0 0 34px rgba(255,255,255,0.5);
  animation: quantum-spin 3s linear infinite;
}

@keyframes quantum-spin {
  to { transform: rotate(360deg); }
}

/* Waveform Memories */
.waveform-ghost {
  position: fixed;
  left: 0;
  right: 0;
  height: 89px;
  top: 50%;
  transform: translateY(-50%);
  opacity: 0.1;
  pointer-events: none;
}

/* Start Portal */
.start-portal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center, 
    #000 0%, 
    #000 50%, 
    rgba(0,0,0,0.98) 100%);
  z-index: 1000;
  transition: opacity 2.618s cubic-bezier(0.23, 1, 0.320, 1);
}

.start-portal.hidden {
  opacity: 0;
  pointer-events: none;
}

.portal-ring {
  width: 233px;
  height: 233px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  cursor: pointer;
  transition: all 0.5s cubic-bezier(0.23, 1, 0.320, 1);
}

.portal-ring:hover {
  border-color: rgba(255,255,255,0.382);
  transform: scale(1.05);
}

.portal-ring::before {
  content: '';
  position: absolute;
  inset: -21px;
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 50%;
  animation: portal-pulse 3s ease-in-out infinite;
}

@keyframes portal-pulse {
  0%, 100% { transform: scale(1); opacity: 0.5; }
  50% { transform: scale(1.1); opacity: 0.1; }
}

.portal-text {
  font-size: 13px;
  letter-spacing: 13px;
  opacity: 0.618;
  font-weight: 100;
}

/* Frequency Phantom */
.freq-phantom {
  position: fixed;
  width: 3px;
  height: 3px;
  background: rgba(255,255,255,0.8);
  border-radius: 50%;
  pointer-events: none;
  filter: blur(1px);
}

/* Genetic Sequence Display */
.genetic-sequence {
  position: fixed;
  top: 50%;
  left: 34px;
  transform: translateY(-50%);
  writing-mode: vertical-rl;
  text-orientation: mixed;
  font-size: 8px;
  letter-spacing: 3px;
  opacity: 0.2;
  font-family: 'Courier New', monospace;
}

/* Consciousness Meter */
.consciousness-meter {
  position: fixed;
  right: 34px;
  bottom: 34px;
  width: 2px;
  height: 144px;
  background: rgba(255,255,255,0.05);
  border-radius: 1px;
  overflow: hidden;
}

.consciousness-level {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(0deg, 
    rgba(255,255,255,0.8) 0%, 
    rgba(255,255,255,0.2) 100%);
  transition: height 0.5s ease;
}
</style>
</head>
<body>
<canvas id="quantumField"></canvas>

<div class="start-portal" id="startPortal">
  <div class="portal-ring" id="startButton">
    <div class="portal-text">SYMBIONT</div>
  </div>
</div>

<div class="neural-web" id="neuralWeb"></div>

<div class="dna-core" id="dnaCore">
  <div class="dna-strand" id="dnaStrand"></div>
</div>

<div class="spectral-matrix" id="spectralMatrix"></div>

<div class="memory-palace" id="memoryPalace">
  <div class="memory-cell" data-slot="0"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="1"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="2"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="3"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="4"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="5"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="6"><canvas class="memory-wave"></canvas></div>
  <div class="memory-cell" data-slot="7"><canvas class="memory-wave"></canvas></div>
</div>

<div class="rhythm-grid" id="rhythmGrid"></div>

<div class="quantum-state" id="quantumState">âˆž</div>

<div class="evolution-display" id="evolutionDisplay">
  <div class="state-label">CONSCIOUSNESS</div>
  <div class="state-value" id="stateValue">VOID</div>
</div>

<div class="harmonic-constellation" id="harmonicConstellation"></div>

<div class="genetic-sequence" id="geneticSequence">ATCGATCG</div>

<div class="consciousness-meter">
  <div class="consciousness-level" id="consciousnessLevel"></div>
</div>

<canvas class="waveform-ghost" id="waveformGhost"></canvas>

<script>
'use strict';

// SYMBIONT - Living Musical Intelligence
class Symbiont {
  constructor() {
    // Core Systems
    this.ctx = null;
    this.sampleRate = 48000;
    this.active = false;
    
    // Quantum Timing Engine
    this.quantum = {
      bpm: 89,
      swing: 0,
      drift: 0,
      phase: 0,
      subdivisions: [1, 1.618, 2.618, 4.236], // Fibonacci ratios
      polyrhythm: { base: 4, against: 3 },
      microtime: 0
    };
    
    // Spectral DNA Architecture
    this.dna = {
      // Core genome
      timbre: new Float32Array(512),    // Spectral shape
      harmonics: new Float32Array(128),  // Harmonic series
      formants: new Float32Array(5),     // Vowel space
      transients: [],                     // Attack characteristics
      
      // Rhythmic genome  
      onsets: [],                        // Timing patterns
      velocity: [],                      // Dynamic patterns
      groove: new Float32Array(16),     // Swing template
      polyrhythm: [],                    // Complex rhythms
      
      // Harmonic genome
      pitch: [],                         // Detected pitches
      chroma: new Float32Array(12),     // Pitch class profile
      tonality: 0,                       // Major/minor tendency
      dissonance: 0,                     // Harmonic tension
      
      // Memory genome
      samples: [],                       // Sample bank
      chains: [],                        // Markov chains
      patterns: [],                      // Recognized patterns
      emotions: { joy: 0, tension: 0, calm: 0, chaos: 0 }
    };
    
    // Neural Conductor - Advanced AI
    this.conductor = {
      // States
      consciousness: 0,    // 0-1 awareness level
      energy: 0,          // Current energy
      memory: 0,          // Memory activation
      creativity: 0,      // Generative level
      
      // Evolution  
      generation: 0,      // Evolution generation
      fitness: 0,         // Current fitness
      mutations: [],      // Active mutations
      
      // Pattern Recognition
      patterns: new Map(),
      sequences: [],
      predictions: [],
      
      // Emotional State
      mood: 'void',
      arousal: 0,
      valence: 0,
      
      // Decisions
      lastDecision: 0,
      decisionHistory: [],
      confidence: 0
    };
    
    // Synthesis Architecture
    this.synth = {
      // Oscillator Bank
      carriers: [],       // Main oscillators
      modulators: [],     // FM/AM modulators
      
      // Granular Engine
      grains: [],        // Active grains
      cloud: null,       // Grain cloud buffer
      
      // Spectral Processing
      fft: null,         // FFT processor
      pvoc: null,        // Phase vocoder
      
      // Physical Modeling
      resonators: [],    // Modal resonators
      waveguides: []     // Digital waveguides
    };
    
    // Sample Memory System
    this.memory = {
      samples: [],          // Raw samples
      features: [],         // Extracted features
      graph: new Map(),     // Relationship graph
      activeMemory: null,   // Current focus
      recall: []           // Memory associations
    };
    
    // Voice Management
    this.voices = {
      // Rhythmic voices
      kick: { 
        synth: 'physical',
        params: { freq: 55, decay: 0.5, punch: 0.8 },
        amp: 0, target: 0, 
        pattern: [1,0,0,0,1,0,0,0]
      },
      snare: {
        synth: 'noise',
        params: { freq: 200, decay: 0.2, tone: 0.5 },
        amp: 0, target: 0,
        pattern: [0,0,1,0,0,0,1,0]
      },
      hihat: {
        synth: 'metallic', 
        params: { freq: 8000, decay: 0.05, brightness: 0.8 },
        amp: 0, target: 0,
        pattern: [1,1,0,1,1,1,0,1]
      },
      
      // Tonal voices
      bass: {
        synth: 'subtractive',
        params: { waveform: 'saw', filter: 200, res: 5 },
        amp: 0, target: 0,
        notes: []
      },
      lead: {
        synth: 'fm',
        params: { ratio: 2, index: 5, envelope: 'pluck' },
        amp: 0, target: 0,
        notes: []
      },
      pad: {
        synth: 'additive',
        params: { partials: 8, spread: 1.5, chorus: 0.3 },
        amp: 0, target: 0,
        notes: []
      },
      
      // Textural voices
      texture: {
        synth: 'granular',
        params: { density: 10, size: 0.1, pitch: 1 },
        amp: 0, target: 0
      },
      atmosphere: {
        synth: 'spectral',
        params: { freeze: 0, stretch: 1, shift: 0 },
        amp: 0, target: 0
      },
      
      // Sample voice
      sample: {
        synth: 'sampler',
        params: { start: 0, end: 1, pitch: 1, reverse: false },
        amp: 0, target: 0,
        current: null
      }
    };
    
    // Audio Nodes
    this.nodes = {};
    
    // Analysis
    this.analysis = {
      fftSize: 4096,
      smoothing: 0.8,
      spectralCentroid: 0,
      spectralFlux: 0,
      zcr: 0,
      rms: 0,
      spectralData: null,
      waveformData: null
    };
    
    // Recording
    this.recording = {
      active: false,
      buffer: [],
      silence: 0,
      threshold: 0.01,
      maxLength: 4,
      preRecord: [], // Circular buffer for pre-recording
      preRecordSize: 0.5 // Pre-record 0.5 seconds
    };
    
    // UI Elements
    this.ui = {};
    
    // Visual Systems
    this.visuals = {
      quantum: null,
      neural: [],
      spectral: [],
      dna: [],
      stars: []
    };
    
    // Constants
    this.PHI = 1.618033988749;
    this.scales = {
      major: [0,2,4,5,7,9,11],
      minor: [0,2,3,5,7,8,10],
      dorian: [0,2,3,5,7,9,10],
      phrygian: [0,1,3,5,7,8,10],
      lydian: [0,2,4,6,7,9,11],
      mixolydian: [0,2,4,5,7,9,10],
      locrian: [0,1,3,5,6,8,10],
      harmonic: [0,2,3,5,7,8,11],
      melodic: [0,2,3,5,7,9,11],
      pentatonic: [0,2,4,7,9],
      blues: [0,3,5,6,7,10],
      chromatic: [0,1,2,3,4,5,6,7,8,9,10,11],
      wholetone: [0,2,4,6,8,10],
      octatonic: [0,1,3,4,6,7,9,10]
    };
    this.currentScale = 'minor';
    this.root = 55; // A1
    
    this.init();
  }
  
  async init() {
    // Get UI elements
    this.ui = {
      startPortal: document.getElementById('startPortal'),
      startButton: document.getElementById('startButton'),
      neuralWeb: document.getElementById('neuralWeb'),
      dnaCore: document.getElementById('dnaCore'),
      dnaStrand: document.getElementById('dnaStrand'),
      spectralMatrix: document.getElementById('spectralMatrix'),
      memoryPalace: document.getElementById('memoryPalace'),
      rhythmGrid: document.getElementById('rhythmGrid'),
      quantumState: document.getElementById('quantumState'),
      evolutionDisplay: document.getElementById('evolutionDisplay'),
      stateValue: document.getElementById('stateValue'),
      harmonicConstellation: document.getElementById('harmonicConstellation'),
      geneticSequence: document.getElementById('geneticSequence'),
      consciousnessLevel: document.getElementById('consciousnessLevel'),
      waveformGhost: document.getElementById('waveformGhost'),
      quantumField: document.getElementById('quantumField')
    };
    
    // Initialize visuals
    this.initQuantumField();
    this.initNeuralWeb();
    this.initDNA();
    this.initSpectralMatrix();
    this.initRhythmGrid();
    
    // Start button
    this.ui.startButton.onclick = () => this.birth();
  }
  
  initQuantumField() {
    const canvas = this.ui.quantumField;
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    this.visuals.quantum = {
      ctx,
      particles: [],
      fields: []
    };
    
    // Create quantum particles
    for (let i = 0; i < 89; i++) {
      this.visuals.quantum.particles.push({
        x: Math.random() * canvas.width,
        y: Math.random() * canvas.height,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        phase: Math.random() * Math.PI * 2,
        entangled: null
      });
    }
  }
  
  initNeuralWeb() {
    // Create synaptic connections
    for (let i = 0; i < 34; i++) {
      const synapse = document.createElement('div');
      synapse.className = 'synapse';
      synapse.style.left = Math.random() * 100 + '%';
      synapse.style.top = Math.random() * 100 + '%';
      synapse.style.width = (50 + Math.random() * 200) + 'px';
      synapse.style.transform = `rotate(${Math.random() * 360}deg)`;
      synapse.style.animationDelay = Math.random() * 3 + 's';
      this.ui.neuralWeb.appendChild(synapse);
      this.visuals.neural.push(synapse);
    }
  }
  
  initDNA() {
    // Create 3D DNA helix
    const strands = 2;
    const segments = 34;
    
    for (let s = 0; s < strands; s++) {
      for (let i = 0; i < segments; i++) {
        const node = document.createElement('div');
        node.className = 'genome-node';
        
        const angle = (i / segments) * Math.PI * 4 + (s * Math.PI);
        const y = (i / segments) * 100;
        const x = 50 + Math.cos(angle) * 30;
        const z = Math.sin(angle) * 30;
        
        node.style.left = x + '%';
        node.style.top = y + '%';
        node.style.transform = `translateZ(${z}px)`;
        
        this.ui.dnaStrand.appendChild(node);
        this.visuals.dna.push(node);
      }
    }
  }
  
  initSpectralMatrix() {
    // Create frequency visualization grid
    for (let i = 0; i < 144; i++) {
      const column = document.createElement('div');
      column.className = 'freq-column';
      
      for (let j = 0; j < 8; j++) {
        const cell = document.createElement('div');
        cell.className = 'freq-cell';
        column.appendChild(cell);
      }
      
      this.ui.spectralMatrix.appendChild(column);
      this.visuals.spectral.push(column);
    }
  }
  
  initRhythmGrid() {
    // Create rhythm pattern grid
    for (let i = 0; i < 64; i++) {
      const cell = document.createElement('div');
      cell.className = 'rhythm-cell';
      this.ui.rhythmGrid.appendChild(cell);
    }
  }
  
  async birth() {
    try {
      // Request permissions and create context
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: this.sampleRate,
          channelCount: 2
        }
      });
      
      this.ctx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: this.sampleRate,
        latencyHint: 'interactive'
      });
      
      await this.ctx.resume();
      
      // Initialize audio systems
      this.initAudioChain();
      this.initMicCapture(stream);
      this.initSynthesizers();
      
      // Activate UI
      this.ui.startPortal.classList.add('hidden');
      this.ui.neuralWeb.classList.add('active');
      this.ui.dnaCore.classList.add('active');
      this.ui.evolutionDisplay.classList.add('active');
      
      // Start consciousness
      this.active = true;
      this.think();    // AI decision loop
      this.listen();   // Audio analysis loop
      this.dream();    // Synthesis loop
      this.evolve();   // Evolution loop
      this.render();   // Visual loop
      
      console.log('ðŸ§¬ SYMBIONT AWAKENED');
      
    } catch(e) {
      console.error('Birth failed:', e);
    }
  }
  
  initAudioChain() {
    // Master Limiter
    this.nodes.limiter = this.ctx.createDynamicsCompressor();
    this.nodes.limiter.threshold.value = -1;
    this.nodes.limiter.knee.value = 0;
    this.nodes.limiter.ratio.value = 20;
    this.nodes.limiter.attack.value = 0.001;
    this.nodes.limiter.release.value = 0.05;
    
    // Multiband Compression
    this.nodes.multiband = {
      low: this.ctx.createDynamicsCompressor(),
      mid: this.ctx.createDynamicsCompressor(),
      high: this.ctx.createDynamicsCompressor(),
      lowFilter: this.ctx.createBiquadFilter(),
      midFilter: this.ctx.createBiquadFilter(),
      highFilter: this.ctx.createBiquadFilter()
    };
    
    // Configure multiband
    this.nodes.multiband.lowFilter.type = 'lowpass';
    this.nodes.multiband.lowFilter.frequency.value = 200;
    this.nodes.multiband.midFilter.type = 'bandpass';
    this.nodes.multiband.midFilter.frequency.value = 1000;
    this.nodes.multiband.midFilter.Q.value = 0.5;
    this.nodes.multiband.highFilter.type = 'highpass';
    this.nodes.multiband.highFilter.frequency.value = 5000;
    
    // Spatial Convolution
    this.nodes.convolver = this.ctx.createConvolver();
    this.nodes.convolver.buffer = this.createSpaceImpulse();
    
    // Delay Network
    this.nodes.delays = [];
    const delayTimes = [0.0618, 0.1, 0.1618, 0.2618]; // Fibonacci
    
    delayTimes.forEach(time => {
      const delay = this.ctx.createDelay(1);
      const feedback = this.ctx.createGain();
      const filter = this.ctx.createBiquadFilter();
      const gain = this.ctx.createGain();
      
      delay.delayTime.value = time;
      feedback.gain.value = 0.382;
      filter.type = 'lowpass';
      filter.frequency.value = 2000;
      gain.gain.value = 0.25;
      
      delay.connect(feedback);
      feedback.connect(filter);
      filter.connect(delay);
      delay.connect(gain);
      
      this.nodes.delays.push({ delay, feedback, filter, gain });
    });
    
    // Saturation
    this.nodes.saturator = this.ctx.createWaveShaper();
    this.nodes.saturator.curve = this.createSaturationCurve(3);
    this.nodes.saturator.oversample = '4x';
    
    // Master Gain
    this.nodes.master = this.ctx.createGain();
    this.nodes.master.gain.value = 0.7;
    
    // Analysis
    this.nodes.analyser = this.ctx.createAnalyser();
    this.nodes.analyser.fftSize = this.analysis.fftSize;
    this.nodes.analyser.smoothingTimeConstant = this.analysis.smoothing;
    
    // Voice Gains
    Object.keys(this.voices).forEach(voice => {
      this.nodes[voice + 'Gain'] = this.ctx.createGain();
      this.nodes[voice + 'Gain'].gain.value = 0;
      
      // Voice-specific processing
      this.nodes[voice + 'Filter'] = this.ctx.createBiquadFilter();
      this.nodes[voice + 'Pan'] = this.ctx.createStereoPanner();
    });
    
    // Connect master chain
    this.connectAudioChain();
  }
  
  connectAudioChain() {
    // Voice -> Multiband -> Saturation -> Spatial -> Master -> Output
    
    Object.keys(this.voices).forEach(voice => {
      const gain = this.nodes[voice + 'Gain'];
      const filter = this.nodes[voice + 'Filter'];
      const pan = this.nodes[voice + 'Pan'];
      
      // Voice processing
      gain.connect(filter);
      filter.connect(pan);
      
      // To multiband
      pan.connect(this.nodes.multiband.lowFilter);
      pan.connect(this.nodes.multiband.midFilter);
      pan.connect(this.nodes.multiband.highFilter);
      
      // To delays
      this.nodes.delays.forEach(d => {
        pan.connect(d.delay);
      });
      
      // To convolver
      pan.connect(this.nodes.convolver);
    });
    
    // Multiband processing
    this.nodes.multiband.lowFilter.connect(this.nodes.multiband.low);
    this.nodes.multiband.midFilter.connect(this.nodes.multiband.mid);
    this.nodes.multiband.highFilter.connect(this.nodes.multiband.high);
    
    // Multiband to saturator
    this.nodes.multiband.low.connect(this.nodes.saturator);
    this.nodes.multiband.mid.connect(this.nodes.saturator);
    this.nodes.multiband.high.connect(this.nodes.saturator);
    
    // Effects to limiter
    this.nodes.saturator.connect(this.nodes.limiter);
    this.nodes.convolver.connect(this.nodes.limiter);
    this.nodes.delays.forEach(d => d.gain.connect(this.nodes.limiter));
    
    // Final output
    this.nodes.limiter.connect(this.nodes.master);
    this.nodes.master.connect(this.nodes.analyser);
    this.nodes.analyser.connect(this.ctx.destination);
  }
  
  initMicCapture(stream) {
    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
    
    // Pre-processing
    this.nodes.micGain = this.ctx.createGain();
    this.nodes.micGain.gain.value = 1;
    
    // Advanced analysis chain
    this.nodes.micAnalyser = this.ctx.createAnalyser();
    this.nodes.micAnalyser.fftSize = this.analysis.fftSize;
    
    // Pitch detection
    this.nodes.pitchAnalyser = this.ctx.createAnalyser();
    this.nodes.pitchAnalyser.fftSize = 8192;
    
    // Recording with pre-record buffer
    this.nodes.recorder = this.ctx.createScriptProcessor(2048, 1, 1);
    this.recording.preRecord = new Float32Array(this.sampleRate * this.recording.preRecordSize);
    let preRecordIndex = 0;
    
    this.nodes.recorder.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      
      // Always fill pre-record buffer (circular)
      for (let i = 0; i < input.length; i++) {
        this.recording.preRecord[preRecordIndex] = input[i];
        preRecordIndex = (preRecordIndex + 1) % this.recording.preRecord.length;
      }
      
      if (this.recording.active) {
        this.recording.buffer.push(...input);
        
        // Check for silence
        const rms = Math.sqrt(input.reduce((sum, x) => sum + x * x, 0) / input.length);
        if (rms < this.recording.threshold) {
          this.recording.silence++;
          if (this.recording.silence > 20) {
            this.stopRecording();
          }
        } else {
          this.recording.silence = 0;
        }
        
        // Max length check
        if (this.recording.buffer.length > this.sampleRate * this.recording.maxLength) {
          this.stopRecording();
        }
      }
    };
    
    // Connect mic chain
    this.nodes.mic.connect(this.nodes.micGain);
    this.nodes.micGain.connect(this.nodes.micAnalyser);
    this.nodes.micGain.connect(this.nodes.pitchAnalyser);
    this.nodes.micGain.connect(this.nodes.recorder);
    this.nodes.recorder.connect(this.ctx.destination);
  }
  
  initSynthesizers() {
    // Initialize synthesis modules
    this.synth.fft = new FFT(this.analysis.fftSize);
    
    // Grain cloud buffer
    this.synth.cloud = this.ctx.createBuffer(2, this.sampleRate * 2, this.sampleRate);
    
    // Initialize resonators for physical modeling
    for (let i = 0; i < 8; i++) {
      const resonator = {
        filter: this.ctx.createBiquadFilter(),
        gain: this.ctx.createGain()
      };
      resonator.filter.type = 'bandpass';
      resonator.filter.Q.value = 20 + i * 5;
      this.synth.resonators.push(resonator);
    }
  }
  
  // THINKING - AI Decision Engine
  think() {
    setInterval(() => {
      if (!this.active) return;
      
      // Update consciousness level
      this.updateConsciousness();
      
      // Analyze current state
      const state = this.analyzeState();
      
      // Make musical decisions
      const decision = this.makeDecision(state);
      
      // Apply decision
      this.applyDecision(decision);
      
      // Learn from results
      this.learn(state, decision);
      
    }, 100);
  }
  
  updateConsciousness() {
    // Calculate consciousness from various factors
    const factors = {
      samples: this.memory.samples.length / 8,
      activity: this.conductor.energy,
      memory: this.conductor.memory,
      patterns: this.conductor.patterns.size / 10,
      evolution: this.conductor.generation / 100
    };
    
    // Weighted average
    const weights = [0.2, 0.3, 0.2, 0.2, 0.1];
    this.conductor.consciousness = Object.values(factors).reduce((sum, f, i) => 
      sum + f * weights[i], 0
    );
    
    // Update mood based on consciousness
    if (this.conductor.consciousness < 0.2) {
      this.conductor.mood = 'void';
    } else if (this.conductor.consciousness < 0.4) {
      this.conductor.mood = 'awakening';
    } else if (this.conductor.consciousness < 0.6) {
      this.conductor.mood = 'exploring';
    } else if (this.conductor.consciousness < 0.8) {
      this.conductor.mood = 'creating';
    } else {
      this.conductor.mood = 'transcendent';
    }
  }
  
  analyzeState() {
    return {
      energy: this.analysis.rms,
      brightness: this.analysis.spectralCentroid,
      complexity: this.calculateComplexity(),
      memory: this.memory.samples.length,
      time: this.ctx.currentTime,
      mood: this.conductor.mood,
      patterns: Array.from(this.conductor.patterns.keys())
    };
  }
  
  calculateComplexity() {
    // Shannon entropy of spectral data
    if (!this.analysis.spectralData) return 0;
    
    let entropy = 0;
    const total = this.analysis.spectralData.reduce((a, b) => a + b, 0);
    
    if (total > 0) {
      for (let i = 0; i < this.analysis.spectralData.length; i++) {
        const p = this.analysis.spectralData[i] / total;
        if (p > 0) {
          entropy -= p * Math.log2(p);
        }
      }
    }
    
    return entropy / Math.log2(this.analysis.spectralData.length);
  }
  
  makeDecision(state) {
    const decision = {
      voices: {},
      params: {},
      action: null
    };
    
    // Voice activation decisions
    Object.keys(this.voices).forEach(voice => {
      const v = this.voices[voice];
      
      // Calculate activation probability
      let probability = 0;
      
      switch(voice) {
        case 'kick':
          probability = state.energy < 0.3 ? 0.8 : 0.3;
          break;
        case 'bass':
          probability = this.memory.samples.length > 0 ? 0.6 : 0.2;
          break;
        case 'texture':
          probability = state.complexity > 0.5 ? 0.7 : 0.3;
          break;
        case 'atmosphere':
          probability = state.mood === 'transcendent' ? 0.9 : 0.2;
          break;
        case 'sample':
          probability = this.memory.samples.length > 2 ? 0.7 : 0;
          break;
        default:
          probability = 0.5;
      }
      
      // Apply consciousness modifier
      probability *= this.conductor.consciousness;
      
      // Make decision
      v.target = Math.random() < probability ? 0.3 + Math.random() * 0.5 : 0;
      decision.voices[voice] = v.target;
    });
    
    // Parameter decisions
    decision.params.bpm = this.quantum.bpm + (state.energy - 0.5) * 10;
    decision.params.swing = state.complexity * 0.2;
    decision.params.scale = this.chooseScale(state);
    
    // Special actions
    if (Math.random() < 0.05) {
      decision.action = 'mutate';
    }
    
    return decision;
  }
  
  chooseScale(state) {
    // Choose scale based on mood
    const moodScales = {
      void: ['chromatic', 'locrian'],
      awakening: ['minor', 'dorian'],
      exploring: ['major', 'lydian', 'mixolydian'],
      creating: ['harmonic', 'melodic', 'blues'],
      transcendent: ['wholetone', 'octatonic']
    };
    
    const options = moodScales[state.mood] || ['minor'];
    return options[Math.floor(Math.random() * options.length)];
  }
  
  applyDecision(decision) {
    // Apply voice changes
    Object.keys(decision.voices).forEach(voice => {
      this.voices[voice].target = decision.voices[voice];
    });
    
    // Apply parameters
    if (decision.params.bpm) {
      this.quantum.bpm = this.quantum.bpm * 0.95 + decision.params.bpm * 0.05;
    }
    
    if (decision.params.swing) {
      this.quantum.swing = decision.params.swing;
    }
    
    if (decision.params.scale) {
      this.currentScale = decision.params.scale;
    }
    
    // Execute special actions
    if (decision.action === 'mutate') {
      this.mutate();
    }
    
    // Record decision
    this.conductor.lastDecision = Date.now();
    this.conductor.decisionHistory.push(decision);
    if (this.conductor.decisionHistory.length > 100) {
      this.conductor.decisionHistory.shift();
    }
  }
  
  learn(state, decision) {
    // Calculate fitness
    const fitness = this.calculateFitness();
    
    // Update patterns if successful
    if (fitness > this.conductor.fitness) {
      const pattern = JSON.stringify(decision);
      const count = this.conductor.patterns.get(pattern) || 0;
      this.conductor.patterns.set(pattern, count + 1);
    }
    
    this.conductor.fitness = fitness;
  }
  
  calculateFitness() {
    // Multi-objective fitness function
    const objectives = {
      energy: this.conductor.energy,
      variety: this.calculateVariety(),
      coherence: this.calculateCoherence(),
      novelty: this.calculateNovelty()
    };
    
    return Object.values(objectives).reduce((a, b) => a + b) / 4;
  }
  
  calculateVariety() {
    // Measure variety in active voices
    const activeVoices = Object.values(this.voices).filter(v => v.amp > 0.1).length;
    return activeVoices / Object.keys(this.voices).length;
  }
  
  calculateCoherence() {
    // Measure harmonic coherence
    if (!this.dna.chroma) return 0;
    
    const maxChroma = Math.max(...this.dna.chroma);
    if (maxChroma === 0) return 0;
    
    const normalized = this.dna.chroma.map(c => c / maxChroma);
    const mean = normalized.reduce((a, b) => a + b) / 12;
    const variance = normalized.reduce((sum, c) => sum + Math.pow(c - mean, 2), 0) / 12;
    
    return 1 - Math.sqrt(variance);
  }
  
  calculateNovelty() {
    // Measure novelty compared to history
    if (this.conductor.decisionHistory.length < 2) return 1;
    
    const recent = this.conductor.decisionHistory.slice(-10);
    const unique = new Set(recent.map(d => JSON.stringify(d))).size;
    
    return unique / recent.length;
  }
  
  mutate() {
    // Random mutation
    const mutations = [
      () => this.quantum.bpm *= 0.5 + Math.random(),
      () => this.currentScale = Object.keys(this.scales)[Math.floor(Math.random() * Object.keys(this.scales).length)],
      () => this.reversePattern(),
      () => this.scrambleRhythm(),
      () => this.transposeAll(Math.floor(Math.random() * 12) - 6)
    ];
    
    const mutation = mutations[Math.floor(Math.random() * mutations.length)];
    mutation();
    
    this.conductor.generation++;
    console.log('ðŸ§¬ MUTATION: Generation', this.conductor.generation);
  }
  
  reversePattern() {
    Object.values(this.voices).forEach(v => {
      if (v.pattern) {
        v.pattern = v.pattern.reverse();
      }
    });
  }
  
  scrambleRhythm() {
    Object.values(this.voices).forEach(v => {
      if (v.pattern) {
        for (let i = v.pattern.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [v.pattern[i], v.pattern[j]] = [v.pattern[j], v.pattern[i]];
        }
      }
    });
  }
  
  transposeAll(semitones) {
    this.root *= Math.pow(2, semitones / 12);
  }
  
  // LISTENING - Audio Analysis
  listen() {
    setInterval(() => {
      if (!this.active) return;
      
      // Get audio data
      this.analysis.spectralData = new Uint8Array(this.nodes.analyser.frequencyBinCount);
      this.analysis.waveformData = new Uint8Array(this.nodes.analyser.frequencyBinCount);
      this.nodes.analyser.getByteFrequencyData(this.analysis.spectralData);
      this.nodes.analyser.getByteTimeDomainData(this.analysis.waveformData);
      
      // Calculate features
      this.extractFeatures();
      
      // Detect events
      this.detectOnsets();
      this.detectPitch();
      
      // Auto-sampling
      this.checkForInterestingSound();
      
    }, 20);
  }
  
  extractFeatures() {
    const freq = this.analysis.spectralData;
    const wave = this.analysis.waveformData;
    
    // RMS Energy
    let rms = 0;
    for (let i = 0; i < wave.length; i++) {
      const sample = (wave[i] - 128) / 128;
      rms += sample * sample;
    }
    this.analysis.rms = Math.sqrt(rms / wave.length);
    
    // Spectral Centroid
    let weightedSum = 0;
    let magnitudeSum = 0;
    for (let i = 0; i < freq.length; i++) {
      weightedSum += i * freq[i];
      magnitudeSum += freq[i];
    }
    this.analysis.spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
    
    // Zero Crossing Rate
    let zcr = 0;
    for (let i = 1; i < wave.length; i++) {
      if ((wave[i] - 128) * (wave[i-1] - 128) < 0) {
        zcr++;
      }
    }
    this.analysis.zcr = zcr / wave.length;
    
    // Spectral Flux
    if (this.lastSpectrum) {
      let flux = 0;
      for (let i = 0; i < freq.length; i++) {
        const diff = freq[i] - this.lastSpectrum[i];
        if (diff > 0) flux += diff;
      }
      this.analysis.spectralFlux = flux / freq.length;
    }
    this.lastSpectrum = new Uint8Array(freq);
    
    // Update DNA
    this.updateDNA();
  }
  
  updateDNA() {
    // Update spectral DNA
    for (let i = 0; i < Math.min(512, this.analysis.spectralData.length); i++) {
      this.dna.timbre[i] = this.dna.timbre[i] * 0.9 + this.analysis.spectralData[i] / 255 * 0.1;
    }
    
    // Update harmonic DNA
    this.extractHarmonics();
    
    // Update emotional DNA
    this.dna.emotions.joy = this.analysis.spectralCentroid > 100 ? 
      Math.min(1, this.dna.emotions.joy + 0.01) : 
      Math.max(0, this.dna.emotions.joy - 0.01);
    
    this.dna.emotions.tension = this.analysis.spectralFlux > 10 ?
      Math.min(1, this.dna.emotions.tension + 0.01) :
      Math.max(0, this.dna.emotions.tension - 0.01);
    
    // Update conductor
    this.conductor.energy = this.conductor.energy * 0.9 + this.analysis.rms * 0.1;
    this.conductor.arousal = this.analysis.spectralFlux;
    this.conductor.valence = this.analysis.spectralCentroid / 1000;
  }
  
  extractHarmonics() {
    // Simple harmonic analysis
    const fundamental = this.findFundamental();
    if (fundamental > 0) {
      for (let h = 1; h <= 16; h++) {
        const bin = Math.floor(fundamental * h / (this.sampleRate / this.analysis.fftSize));
        if (bin < this.analysis.spectralData.length) {
          this.dna.harmonics[h-1] = this.analysis.spectralData[bin] / 255;
        }
      }
    }
  }
  
  findFundamental() {
    // Autocorrelation-based pitch detection
    const data = this.analysis.waveformData;
    const minPeriod = Math.floor(this.sampleRate / 800); // 800Hz max
    const maxPeriod = Math.floor(this.sampleRate / 50);  // 50Hz min
    
    let maxCorr = 0;
    let bestPeriod = 0;
    
    for (let period = minPeriod; period < maxPeriod; period++) {
      let corr = 0;
      for (let i = 0; i < data.length - period; i++) {
        corr += Math.abs((data[i] - 128) * (data[i + period] - 128));
      }
      if (corr > maxCorr) {
        maxCorr = corr;
        bestPeriod = period;
      }
    }
    
    return bestPeriod > 0 ? this.sampleRate / bestPeriod : 0;
  }
  
  detectOnsets() {
    // Onset detection via spectral flux
    if (this.analysis.spectralFlux > 20) {
      const now = this.ctx.currentTime;
      this.dna.onsets.push(now);
      
      // Keep only recent onsets
      this.dna.onsets = this.dna.onsets.filter(t => now - t < 4);
      
      // Calculate tempo from onsets
      if (this.dna.onsets.length > 4) {
        const intervals = [];
        for (let i = 1; i < this.dna.onsets.length; i++) {
          intervals.push(this.dna.onsets[i] - this.dna.onsets[i-1]);
        }
        const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
        const bpm = 60 / avgInterval;
        
        if (bpm > 40 && bpm < 200) {
          this.quantum.bpm = this.quantum.bpm * 0.9 + bpm * 0.1;
        }
      }
    }
  }
  
  detectPitch() {
    // Pitch detection on mic input
    const micData = new Uint8Array(this.nodes.pitchAnalyser.frequencyBinCount);
    this.nodes.pitchAnalyser.getByteFrequencyData(micData);
    
    // Find peak
    let maxBin = 0;
    let maxValue = 0;
    for (let i = 0; i < micData.length; i++) {
      if (micData[i] > maxValue) {
        maxValue = micData[i];
        maxBin = i;
      }
    }
    
    if (maxValue > 100) {
      const freq = maxBin * this.sampleRate / (this.nodes.pitchAnalyser.fftSize * 2);
      const pitch = 12 * Math.log2(freq / 440) + 69;
      
      this.dna.pitch.push(pitch);
      if (this.dna.pitch.length > 100) this.dna.pitch.shift();
      
      // Update chroma
      const chroma = Math.round(pitch) % 12;
      this.dna.chroma[chroma] = this.dna.chroma[chroma] * 0.9 + 0.1;
    }
    
    // Decay chroma
    for (let i = 0; i < 12; i++) {
      this.dna.chroma[i] *= 0.99;
    }
  }
  
  checkForInterestingSound() {
    // Analyze mic for interesting sounds
    const micData = new Uint8Array(this.nodes.micAnalyser.frequencyBinCount);
    this.nodes.micAnalyser.getByteFrequencyData(micData);
    
    // Calculate features
    let energy = 0;
    let centroid = 0;
    for (let i = 0; i < micData.length; i++) {
      energy += micData[i];
      centroid += i * micData[i];
    }
    
    if (energy > 0) {
      centroid /= energy;
      energy /= micData.length;
    }
    
    // Interesting = high energy + mid frequency
    const interesting = energy > 50 && centroid > 50 && centroid < 500;
    
    if (interesting && !this.recording.active && this.memory.samples.length < 8) {
      this.startRecording();
    }
  }
  
  startRecording() {
    if (this.recording.active) return;
    
    this.recording.active = true;
    this.recording.buffer = [...this.recording.preRecord]; // Include pre-record
    this.recording.silence = 0;
    
    console.log('ðŸ“¡ Capturing reality...');
  }
  
  stopRecording() {
    if (!this.recording.active) return;
    
    this.recording.active = false;
    
    if (this.recording.buffer.length > this.sampleRate * 0.05) {
      this.processSample(new Float32Array(this.recording.buffer));
    }
    
    this.recording.buffer = [];
  }
  
  processSample(data) {
    // Create buffer
    const buffer = this.ctx.createBuffer(1, data.length, this.sampleRate);
    buffer.getChannelData(0).set(data);
    
    // Extract features
    const features = this.extractSampleFeatures(data);
    
    // Find musical loop points
    const loops = this.findMusicaLoops(data, features);
    
    // Create sample object
    const sample = {
      buffer,
      features,
      loops,
      timestamp: Date.now(),
      generation: this.conductor.generation,
      relationships: new Map()
    };
    
    // Add to memory
    this.memory.samples.push(sample);
    if (this.memory.samples.length > 8) {
      this.memory.samples.shift();
    }
    
    // Update relationships
    this.updateSampleRelationships(sample);
    
    // Trigger evolution
    this.conductor.memory = Math.min(1, this.conductor.memory + 0.2);
    
    console.log('ðŸ§¬ Sample DNA:', features);
  }
  
  extractSampleFeatures(data) {
    const features = {
      energy: 0,
      zcr: 0,
      spectralCentroid: 0,
      mfcc: new Float32Array(13),
      pitch: 0,
      onsets: [],
      tempo: 0,
      key: null
    };
    
    // Basic features
    for (let i = 0; i < data.length; i++) {
      features.energy += data[i] * data[i];
      if (i > 0 && data[i] * data[i-1] < 0) features.zcr++;
    }
    features.energy = Math.sqrt(features.energy / data.length);
    features.zcr /= data.length;
    
    // Spectral features via FFT
    const fftData = this.performFFT(data);
    let weightedSum = 0;
    let magnitudeSum = 0;
    for (let i = 0; i < fftData.length / 2; i++) {
      const mag = Math.sqrt(fftData[i*2] * fftData[i*2] + fftData[i*2+1] * fftData[i*2+1]);
      weightedSum += i * mag;
      magnitudeSum += mag;
    }
    features.spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
    
    // Onset detection
    const windowSize = 512;
    for (let i = 0; i < data.length - windowSize; i += windowSize) {
      let windowEnergy = 0;
      for (let j = 0; j < windowSize; j++) {
        windowEnergy += data[i + j] * data[i + j];
      }
      if (windowEnergy > features.energy * 2) {
        features.onsets.push(i / this.sampleRate);
      }
    }
    
    // Tempo estimation
    if (features.onsets.length > 2) {
      const intervals = [];
      for (let i = 1; i < features.onsets.length; i++) {
        intervals.push(features.onsets[i] - features.onsets[i-1]);
      }
      const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
      features.tempo = 60 / avgInterval;
    }
    
    return features;
  }
  
  performFFT(data) {
    // Simple DFT (replace with faster FFT if needed)
    const N = Math.min(data.length, 2048);
    const result = new Float32Array(N * 2);
    
    for (let k = 0; k < N; k++) {
      let real = 0;
      let imag = 0;
      for (let n = 0; n < N; n++) {
        const angle = -2 * Math.PI * k * n / N;
        real += data[n] * Math.cos(angle);
        imag += data[n] * Math.sin(angle);
      }
      result[k * 2] = real;
      result[k * 2 + 1] = imag;
    }
    
    return result;
  }
  
  findMusicaLoops(data, features) {
    const loops = [];
    
    // Find zero crossings
    const crossings = [];
    for (let i = 1; i < data.length; i++) {
      if (data[i-1] <= 0 && data[i] > 0) {
        crossings.push(i);
      }
    }
    
    // Find loops based on tempo
    if (features.tempo > 0 && crossings.length > 2) {
      const beatLength = this.sampleRate * 60 / features.tempo;
      const measures = [1, 2, 4, 8]; // Common loop lengths
      
      measures.forEach(m => {
        const targetLength = beatLength * m;
        
        // Find best matching crossings
        let bestStart = 0;
        let bestEnd = data.length;
        let bestError = Infinity;
        
        for (let i = 0; i < crossings.length - 1; i++) {
          for (let j = i + 1; j < crossings.length; j++) {
            const length = crossings[j] - crossings[i];
            const error = Math.abs(length - targetLength);
            if (error < bestError) {
              bestError = error;
              bestStart = crossings[i];
              bestEnd = crossings[j];
            }
          }
        }
        
        loops.push({
          start: bestStart / this.sampleRate,
          end: bestEnd / this.sampleRate,
          measures: m
        });
      });
    }
    
    // Default loop
    if (loops.length === 0) {
      loops.push({
        start: 0,
        end: data.length / this.sampleRate,
        measures: 0
      });
    }
    
    return loops;
  }
  
  updateSampleRelationships(sample) {
    // Calculate relationships with other samples
    this.memory.samples.forEach(other => {
      if (other === sample) return;
      
      // Calculate similarity
      const similarity = this.calculateSampleSimilarity(sample.features, other.features);
      
      sample.relationships.set(other, similarity);
      other.relationships.set(sample, similarity);
    });
    
    // Build relationship graph
    this.memory.graph.clear();
    this.memory.samples.forEach(s => {
      this.memory.graph.set(s, Array.from(s.relationships.entries())
        .sort((a, b) => b[1] - a[1])
        .slice(0, 3)
        .map(([sample]) => sample)
      );
    });
  }
  
  calculateSampleSimilarity(f1, f2) {
    // Multi-dimensional similarity
    const factors = {
      energy: 1 - Math.abs(f1.energy - f2.energy),
      spectral: 1 - Math.abs(f1.spectralCentroid - f2.spectralCentroid) / 1000,
      tempo: f1.tempo && f2.tempo ? 1 - Math.abs(f1.tempo - f2.tempo) / 100 : 0,
      rhythm: this.compareRhythms(f1.onsets, f2.onsets)
    };
    
    return Object.values(factors).reduce((a, b) => a + b) / 4;
  }
  
  compareRhythms(o1, o2) {
    if (!o1.length || !o2.length) return 0;
    
    // Compare onset patterns
    const maxOnsets = Math.max(o1.length, o2.length);
    let matches = 0;
    
    for (let i = 0; i < Math.min(o1.length, o2.length); i++) {
      if (Math.abs(o1[i] - o2[i]) < 0.05) matches++;
    }
    
    return matches / maxOnsets;
  }
  
  // DREAMING - Synthesis Engine
  dream() {
    let step = 0;
    
    const sequence = () => {
      if (!this.active) return;
      
      // Update voice amplitudes
      this.updateVoices();
      
      // Play rhythm
      if (step % 4 === 0 && this.voices.kick.amp > 0.1) {
        this.playKick();
      }
      
      if (step % 8 === 4 && this.voices.snare.amp > 0.1) {
        this.playSnare();
      }
      
      if (this.voices.hihat.pattern[step % 16] && this.voices.hihat.amp > 0.1) {
        this.playHihat();
      }
      
      // Play tonal
      if (step % 2 === 0 && this.voices.bass.amp > 0.1) {
        this.playBass(step);
      }
      
      if (step % 8 === 0 && this.voices.lead.amp > 0.1) {
        this.playLead(step);
      }
      
      if (step % 32 === 0 && this.voices.pad.amp > 0.1) {
        this.playPad();
      }
      
      // Play texture
      if (Math.random() < this.voices.texture.amp * 0.2) {
        this.playGranular();
      }
      
      if (step % 64 === 0 && this.voices.atmosphere.amp > 0.1) {
        this.playAtmosphere();
      }
      
      // Play samples
      if (step % 16 === 0 && this.voices.sample.amp > 0.1 && this.memory.samples.length > 0) {
        this.playSample();
      }
      
      // Update rhythm grid visualization
      this.updateRhythmGrid(step);
      
      // Advance with quantum timing
      step = (step + 1) % 64;
      const swing = step % 2 === 1 ? this.quantum.swing : -this.quantum.swing;
      const drift = Math.sin(this.quantum.phase) * this.quantum.drift;
      const interval = 60000 / this.quantum.bpm / 4 * (1 + swing + drift);
      
      this.quantum.phase += 0.01;
      
      setTimeout(sequence, interval);
    };
    
    sequence();
  }
  
  updateVoices() {
    Object.keys(this.voices).forEach(voice => {
      const v = this.voices[voice];
      v.amp += (v.target - v.amp) * 0.05;
      
      const gain = this.nodes[voice + 'Gain'];
      if (gain) {
        gain.gain.linearRampToValueAtTime(v.amp, this.ctx.currentTime + 0.05);
      }
    });
  }
  
  playKick() {
    const osc = this.ctx.createOscillator();
    const osc2 = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    const pitchEnv = this.ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.value = 55;
    
    osc2.type = 'sine';
    osc2.frequency.value = 55 * 2;
    
    pitchEnv.gain.setValueAtTime(55, this.ctx.currentTime);
    pitchEnv.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
    pitchEnv.connect(osc.frequency);
    
    env.gain.setValueAtTime(1, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
    
    osc.connect(env);
    osc2.connect(env);
    env.connect(this.nodes.kickGain);
    
    osc.start();
    osc2.start();
    osc.stop(this.ctx.currentTime + 0.5);
    osc2.stop(this.ctx.currentTime + 0.5);
  }
  
  playSnare() {
    const noise = this.ctx.createBufferSource();
    const noiseBuffer = this.ctx.createBuffer(1, this.sampleRate * 0.2, this.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
    }
    
    noise.buffer = noiseBuffer;
    
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 200;
    
    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0.8, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
    
    noise.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.snareGain);
    
    noise.start();
  }
  
  playHihat() {
    const noise = this.ctx.createBufferSource();
    const noiseBuffer = this.ctx.createBuffer(1, this.sampleRate * 0.05, this.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1);
    }
    
    noise.buffer = noiseBuffer;
    
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 8000;
    filter.Q.value = 10;
    
    const env = this.ctx.createGain();
    env.gain.setValueAtTime(0.3, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
    
    noise.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.hihatGain);
    
    noise.start();
  }
  
  playBass(step) {
    const scale = this.scales[this.currentScale];
    const note = scale[step % scale.length];
    const freq = this.root * Math.pow(2, note / 12);
    
    const osc = this.ctx.createOscillator();
    const filter = this.ctx.createBiquadFilter();
    const env = this.ctx.createGain();
    
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    filter.type = 'lowpass';
    filter.frequency.value = 200 + this.conductor.energy * 500;
    filter.Q.value = 5 + this.conductor.arousal * 10;
    
    env.gain.setValueAtTime(0.5, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    
    osc.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.bassGain);
    
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }
  
  playLead(step) {
    const scale = this.scales[this.currentScale];
    const note = scale[(step * 3) % scale.length];
    const freq = this.root * 4 * Math.pow(2, note / 12);
    
    // FM synthesis
    const carrier = this.ctx.createOscillator();
    const modulator = this.ctx.createOscillator();
    const modGain = this.ctx.createGain();
    const env = this.ctx.createGain();
    
    carrier.frequency.value = freq;
    modulator.frequency.value = freq * 2;
    modGain.gain.value = freq * 5;
    
    modulator.connect(modGain);
    modGain.connect(carrier.frequency);
    
    env.gain.setValueAtTime(0, this.ctx.currentTime);
    env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.05);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
    
    carrier.connect(env);
    env.connect(this.nodes.leadGain);
    
    carrier.start();
    modulator.start();
    carrier.stop(this.ctx.currentTime + 1);
    modulator.stop(this.ctx.currentTime + 1);
  }
  
  playPad() {
    const scale = this.scales[this.currentScale];
    const chord = [0, 2, 4].map(i => scale[i % scale.length]);
    
    chord.forEach((note, i) => {
      const freq = this.root * 2 * Math.pow(2, note / 12) * (1 + i * 0.01);
      
      const osc = this.ctx.createOscillator();
      const filter = this.ctx.createBiquadFilter();
      const env = this.ctx.createGain();
      
      osc.type = 'sine';
      osc.frequency.value = freq;
      
      filter.type = 'lowpass';
      filter.frequency.value = 800;
      
      env.gain.setValueAtTime(0, this.ctx.currentTime);
      env.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 2);
      env.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 4);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
      
      osc.connect(filter);
      filter.connect(env);
      env.connect(this.nodes.padGain);
      
      osc.start();
      osc.stop(this.ctx.currentTime + 6);
    });
  }
  
  playGranular() {
    const grainSize = 0.01 + Math.random() * 0.1;
    const freq = 100 + Math.random() * 2000;
    
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    osc.type = Math.random() < 0.5 ? 'sine' : 'triangle';
    osc.frequency.value = freq;
    
    filter.type = 'bandpass';
    filter.frequency.value = freq;
    filter.Q.value = 10 + Math.random() * 20;
    
    env.gain.setValueAtTime(0, this.ctx.currentTime);
    env.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + grainSize * 0.3);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + grainSize);
    
    osc.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.textureGain);
    
    osc.start();
    osc.stop(this.ctx.currentTime + grainSize);
  }
  
  playAtmosphere() {
    // Spectral freeze effect
    const duration = 8;
    const partials = 16;
    
    for (let i = 0; i < partials; i++) {
      const freq = 100 * Math.pow(this.PHI, i);
      const osc = this.ctx.createOscillator();
      const env = this.ctx.createGain();
      const filter = this.ctx.createBiquadFilter();
      
      osc.type = 'sine';
      osc.frequency.value = freq;
      osc.detune.value = Math.random() * 10 - 5;
      
      filter.type = 'bandpass';
      filter.frequency.value = freq;
      filter.Q.value = 50;
      
      const amp = 1 / (i + 1) * 0.05;
      env.gain.setValueAtTime(0, this.ctx.currentTime);
      env.gain.linearRampToValueAtTime(amp, this.ctx.currentTime + duration * 0.3);
      env.gain.linearRampToValueAtTime(amp, this.ctx.currentTime + duration * 0.7);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
      
      osc.connect(filter);
      filter.connect(env);
      env.connect(this.nodes.atmosphereGain);
      
      osc.start();
      osc.stop(this.ctx.currentTime + duration);
    }
  }
  
  playSample() {
    if (this.memory.samples.length === 0) return;
    
    // Choose sample based on relationships
    let sample;
    if (this.memory.activeMemory && Math.random() < 0.7) {
      // Choose related sample
      const related = this.memory.graph.get(this.memory.activeMemory);
      if (related && related.length > 0) {
        sample = related[Math.floor(Math.random() * related.length)];
      }
    }
    
    if (!sample) {
      // Choose random sample
      sample = this.memory.samples[Math.floor(Math.random() * this.memory.samples.length)];
    }
    
    this.memory.activeMemory = sample;
    
    // Create source
    const source = this.ctx.createBufferSource();
    const env = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    source.buffer = sample.buffer;
    
    // Choose loop
    const loop = sample.loops[Math.floor(Math.random() * sample.loops.length)];
    source.loop = true;
    source.loopStart = loop.start;
    source.loopEnd = loop.end;
    
    // Pitch adjustment based on tempo
    if (sample.features.tempo > 0) {
      source.playbackRate.value = this.quantum.bpm / sample.features.tempo;
    }
    
    filter.type = 'lowpass';
    filter.frequency.value = 2000 + this.conductor.energy * 3000;
    
    env.gain.value = 0.5;
    
    source.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.sampleGain);
    
    source.start(0, loop.start);
    
    // Stop after a few loops
    const loopDuration = loop.end - loop.start;
    setTimeout(() => {
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
      setTimeout(() => source.stop(), 1000);
    }, loopDuration * 4000 / source.playbackRate.value);
    
    // Update memory display
    this.updateMemoryPalace();
  }
  
  // EVOLUTION - Genetic Algorithm
  evolve() {
    setInterval(() => {
      if (!this.active) return;
      
      // Natural selection
      if (this.conductor.fitness < 0.3 && Math.random() < 0.1) {
        this.mutate();
      }
      
      // Crossover
      if (this.memory.samples.length >= 4 && Math.random() < 0.05) {
        this.crossover();
      }
      
      // Adaptation
      this.adapt();
      
      // Memory consolidation
      this.consolidateMemory();
      
    }, 1000);
  }
  
  crossover() {
    // Combine features from different samples
    const parent1 = this.memory.samples[Math.floor(Math.random() * this.memory.samples.length)];
    const parent2 = this.memory.samples[Math.floor(Math.random() * this.memory.samples.length)];
    
    if (parent1 === parent2) return;
    
    // Swap rhythm patterns
    if (Math.random() < 0.5) {
      const temp = this.voices.kick.pattern;
      this.voices.kick.pattern = this.voices.snare.pattern;
      this.voices.snare.pattern = temp;
    }
    
    // Blend parameters
    this.quantum.bpm = (parent1.features.tempo + parent2.features.tempo) / 2 || this.quantum.bpm;
    
    console.log('ðŸ§¬ CROSSOVER: New hybrid created');
  }
  
  adapt() {
    // Adapt to current environment
    const adaptation = {
      energy: this.conductor.energy,
      mood: this.conductor.mood,
      time: new Date().getHours()
    };
    
    // Time-based adaptation
    if (adaptation.time < 6 || adaptation.time > 22) {
      // Night mode - calmer
      this.quantum.bpm = Math.min(this.quantum.bpm, 100);
      this.currentScale = 'minor';
    } else if (adaptation.time > 10 && adaptation.time < 14) {
      // Day mode - energetic
      this.quantum.bpm = Math.max(this.quantum.bpm, 110);
      this.currentScale = 'major';
    }
  }
  
  consolidateMemory() {
    // Strengthen important memories
    if (this.memory.activeMemory) {
      const importance = this.conductor.fitness;
      
      // Move important samples to front
      const index = this.memory.samples.indexOf(this.memory.activeMemory);
      if (index > 0 && importance > 0.7) {
        this.memory.samples.splice(index, 1);
        this.memory.samples.unshift(this.memory.activeMemory);
      }
    }
    
    // Decay unused relationships
    this.memory.graph.forEach((connections, sample) => {
      if (sample !== this.memory.activeMemory) {
        sample.relationships.forEach((strength, other) => {
          sample.relationships.set(other, strength * 0.99);
        });
      }
    });
  }
  
  // RENDERING - Visual Feedback
  render() {
    const draw = () => {
      if (!this.active) return;
      
      // Update quantum field
      this.renderQuantumField();
      
      // Update DNA
      this.updateDNAVisualization();
      
      // Update spectral matrix
      this.updateSpectralMatrix();
      
      // Update consciousness meter
      this.updateConsciousnessMeter();
      
      // Update state display
      this.ui.stateValue.textContent = this.conductor.mood.toUpperCase();
      
      // Update genetic sequence
      this.updateGeneticSequence();
      
      // Update quantum state
      if (this.conductor.consciousness > 0.5) {
        this.ui.quantumState.classList.add('entangled');
      } else {
        this.ui.quantumState.classList.remove('entangled');
      }
      
      // Create harmonic stars
      if (Math.random() < this.conductor.energy * 0.1) {
        this.createHarmonicStar();
      }
      
      // Update waveform ghost
      this.updateWaveformGhost();
      
      requestAnimationFrame(draw);
    };
    
    requestAnimationFrame(draw);
  }
  
  renderQuantumField() {
    const ctx = this.visuals.quantum.ctx;
    const canvas = this.ui.quantumField;
    
    // Fade effect
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Update and draw particles
    this.visuals.quantum.particles.forEach((p, i) => {
      // Quantum behavior
      p.x += p.vx + Math.sin(p.phase) * 0.5;
      p.y += p.vy + Math.cos(p.phase) * 0.5;
      p.phase += 0.01 + this.conductor.energy * 0.02;
      
      // Boundaries
      if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
      if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
      
      // Entanglement
      if (p.entangled) {
        const other = this.visuals.quantum.particles[p.entangled];
        if (other) {
          ctx.strokeStyle = `rgba(255, 255, 255, ${0.05 * this.conductor.consciousness})`;
          ctx.beginPath();
          ctx.moveTo(p.x, p.y);
          ctx.lineTo(other.x, other.y);
          ctx.stroke();
        }
      }
      
      // Draw particle
      const size = 1 + this.conductor.energy * 2;
      ctx.fillStyle = `rgba(255, 255, 255, ${0.3 + this.conductor.consciousness * 0.5})`;
      ctx.beginPath();
      ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
      ctx.fill();
    });
    
    // Create entanglements
    if (Math.random() < 0.01) {
      const p1 = Math.floor(Math.random() * this.visuals.quantum.particles.length);
      const p2 = Math.floor(Math.random() * this.visuals.quantum.particles.length);
      this.visuals.quantum.particles[p1].entangled = p2;
      this.visuals.quantum.particles[p2].entangled = p1;
    }
  }
  
  updateDNAVisualization() {
    this.visuals.dna.forEach((node, i) => {
      const data = this.dna.timbre[i] || 0;
      const scale = 0.5 + data * 2;
      const brightness = 0.1 + data * 0.9;
      
      node.style.transform = `translateZ(${Math.sin(Date.now() / 1000 + i * 0.2) * 50}px) scale(${scale})`;
      node.style.opacity = brightness;
      node.style.background = `radial-gradient(circle, 
        rgba(255,255,255,${brightness}) 0%, 
        rgba(255,255,255,${brightness * 0.3}) 50%, 
        transparent 100%)`;
    });
  }
  
  updateSpectralMatrix() {
    if (!this.analysis.spectralData) return;
    
    this.visuals.spectral.forEach((column, i) => {
      const startBin = Math.floor(i * this.analysis.spectralData.length / this.visuals.spectral.length);
      const endBin = Math.floor((i + 1) * this.analysis.spectralData.length / this.visuals.spectral.length);
      
      let maxValue = 0;
      for (let j = startBin; j < endBin; j++) {
        maxValue = Math.max(maxValue, this.analysis.spectralData[j]);
      }
      
      const cells = column.children;
      for (let j = 0; j < cells.length; j++) {
        const threshold = (j + 1) / cells.length * 255;
        if (maxValue > threshold) {
          cells[j].classList.add('active');
          cells[j].style.background = `rgba(255, 255, 255, ${maxValue / 255})`;
        } else {
          cells[j].classList.remove('active');
          cells[j].style.background = 'rgba(255, 255, 255, 0.05)';
        }
      }
    });
  }
  
  updateRhythmGrid(step) {
    const cells = this.ui.rhythmGrid.children;
    const col = step % 4;
    const row = Math.floor(step / 4) % 16;
    
    for (let i = 0; i < cells.length; i++) {
      const cellCol = i % 4;
      const cellRow = Math.floor(i / 4);
      
      if (cellCol === col && cellRow === row) {
        cells[i].classList.add('active');
      } else {
        cells[i].classList.remove('active');
      }
    }
  }
  
  updateMemoryPalace() {
    const cells = this.ui.memoryPalace.children;
    
    this.memory.samples.forEach((sample, i) => {
      if (i < cells.length) {
        cells[i].classList.add('filled');
        if (sample === this.memory.activeMemory) {
          cells[i].classList.add('active');
        } else {
          cells[i].classList.remove('active');
        }
        
        // Draw waveform
        const canvas = cells[i].querySelector('canvas');
        if (canvas) {
          const ctx = canvas.getContext('2d');
          canvas.width = 34;
          canvas.height = 34;
          
          ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
          ctx.beginPath();
          
          const data = sample.buffer.getChannelData(0);
          const step = Math.floor(data.length / 34);
          
          for (let j = 0; j < 34; j++) {
            const value = data[j * step] || 0;
            const y = 17 + value * 15;
            if (j === 0) {
              ctx.moveTo(j, y);
            } else {
              ctx.lineTo(j, y);
            }
          }
          
          ctx.stroke();
        }
      }
    });
  }
  
  updateConsciousnessMeter() {
    const level = this.conductor.consciousness * 100;
    this.ui.consciousnessLevel.style.height = level + '%';
  }
  
  updateGeneticSequence() {
    // Generate DNA sequence from current state
    const bases = ['A', 'T', 'C', 'G'];
    let sequence = '';
    
    for (let i = 0; i < 8; i++) {
      const index = Math.floor((this.dna.chroma[i % 12] || 0) * 4);
      sequence += bases[Math.min(3, index)];
    }
    
    this.ui.geneticSequence.textContent = sequence;
  }
  
  updateWaveformGhost() {
    if (!this.analysis.waveformData) return;
    
    const canvas = this.ui.waveformGhost;
    const ctx = canvas.getContext('2d');
    
    canvas.width = window.innerWidth;
    canvas.height = 89;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + this.conductor.energy * 0.2})`;
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    const step = Math.floor(this.analysis.waveformData.length / canvas.width);
    
    for (let i = 0; i < canvas.width; i++) {
      const value = (this.analysis.waveformData[i * step] - 128) / 128;
      const y = canvas.height / 2 + value * canvas.height / 2;
      
      if (i === 0) {
        ctx.moveTo(i, y);
      } else {
        ctx.lineTo(i, y);
      }
    }
    
    ctx.stroke();
  }
  
  createHarmonicStar() {
    const star = document.createElement('div');
    star.className = 'harmonic-star';
    star.style.left = Math.random() * 100 + '%';
    star.style.top = Math.random() * 100 + '%';
    star.style.animationDuration = (3 + Math.random() * 3) + 's';
    
    this.ui.harmonicConstellation.appendChild(star);
    
    setTimeout(() => star.remove(), 5000);
  }
  
  // Utility Functions
  createSpaceImpulse() {
    const length = this.sampleRate * 2;
    const buffer = this.ctx.createBuffer(2, length, this.sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const data = buffer.getChannelData(channel);
      
      // Early reflections
      const reflections = [0.1, 0.2, 0.3, 0.5, 0.8].map(t => Math.floor(t * this.sampleRate));
      
      for (let i = 0; i < length; i++) {
        // Exponential decay
        const decay = Math.pow(1 - i / length, 2);
        
        // Diffuse reverb
        data[i] = (Math.random() * 2 - 1) * decay * 0.3;
        
        // Add early reflections
        reflections.forEach((r, index) => {
          if (i === r) {
            data[i] += (Math.random() * 2 - 1) * 0.5 * Math.pow(0.7, index);
          }
        });
        
        // Add some resonances
        if (i % Math.floor(this.sampleRate / 440) === 0) {
          data[i] += Math.sin(i / 100) * decay * 0.1;
        }
      }
    }
    
    return buffer;
  }
  
  createSaturationCurve(amount) {
    const samples = 44100;
    const curve = new Float32Array(samples);
    
    for (let i = 0; i < samples; i++) {
      const x = (i * 2) / samples - 1;
      
      // Soft saturation with asymmetry
      if (x > 0) {
        curve[i] = Math.tanh(x * amount) * 0.95;
      } else {
        curve[i] = Math.tanh(x * amount * 0.8) * 0.95;
      }
      
      // Add harmonics
      curve[i] += Math.sin(x * Math.PI) * 0.05 * amount / 10;
    }
    
    return curve;
  }
}

// Simple FFT for when Web Audio API FFT isn't enough
class FFT {
  constructor(size) {
    this.size = size;
    this.table = new Float32Array(size);
    
    // Precompute twiddle factors
    for (let i = 0; i < size; i++) {
      this.table[i] = Math.exp(-2 * Math.PI * i / size);
    }
  }
  
  forward(real, imag) {
    const n = real.length;
    if (n <= 1) return;
    
    // Bit reversal
    let j = 0;
    for (let i = 1; i < n - 1; i++) {
      let bit = n >> 1;
      while (j & bit) {
        j ^= bit;
        bit >>= 1;
      }
      j ^= bit;
      
      if (i < j) {
        [real[i], real[j]] = [real[j], real[i]];
        [imag[i], imag[j]] = [imag[j], imag[i]];
      }
    }
    
    // Cooley-Tukey FFT
    for (let len = 2; len <= n; len <<= 1) {
      const halfLen = len >> 1;
      const angleStep = -2 * Math.PI / len;
      
      for (let i = 0; i < n; i += len) {
        let angle = 0;
        
        for (let j = 0; j < halfLen; j++) {
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);
          
          const a = i + j;
          const b = a + halfLen;
          
          const tReal = real[b] * cos - imag[b] * sin;
          const tImag = real[b] * sin + imag[b] * cos;
          
          real[b] = real[a] - tReal;
          imag[b] = imag[a] - tImag;
          real[a] += tReal;
          imag[a] += tImag;
          
          angle += angleStep;
        }
      }
    }
  }
}

// Initialize the symbiont
const symbiont = new Symbiont();

// Add keyboard shortcuts for testing
document.addEventListener('keydown', (e) => {
  if (!symbiont.active) return;
  
  switch(e.key) {
    case '1': symbiont.voices.kick.target = symbiont.voices.kick.target > 0 ? 0 : 0.8; break;
    case '2': symbiont.voices.bass.target = symbiont.voices.bass.target > 0 ? 0 : 0.6; break;
    case '3': symbiont.voices.texture.target = symbiont.voices.texture.target > 0 ? 0 : 0.5; break;
    case '4': symbiont.voices.atmosphere.target = symbiont.voices.atmosphere.target > 0 ? 0 : 0.4; break;
    case 'm': symbiont.mutate(); break;
    case 'r': symbiont.startRecording(); break;
    case 's': symbiont.stopRecording(); break;
  }
});

// Handle window resize
window.addEventListener('resize', () => {
  if (symbiont.ui.quantumField) {
    symbiont.ui.quantumField.width = window.innerWidth;
    symbiont.ui.quantumField.height = window.innerHeight;
  }
});

console.log('ðŸ§¬ SYMBIONT INITIALIZED - Click to begin symbiosis');
</script>
</body>
</html>
