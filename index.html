<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>GUMP - Autonomous Creative Intelligence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            position: relative;
        }

        /* Living background */
        .consciousness-field {
            position: fixed;
            inset: 0;
            background: radial-gradient(
                ellipse at center,
                rgba(75, 0, 130, 0.02) 0%,
                transparent 61.8%
            );
            animation: consciousness-pulse 13s ease-in-out infinite;
        }

        @keyframes consciousness-pulse {
            0%, 100% { 
                opacity: 0.3; 
                transform: scale(1) rotate(0deg); 
            }
            25% { 
                opacity: 0.6; 
                transform: scale(1.1) rotate(90deg); 
            }
            50% { 
                opacity: 1; 
                transform: scale(1.05) rotate(180deg); 
            }
            75% { 
                opacity: 0.5; 
                transform: scale(1.08) rotate(270deg); 
            }
        }

        /* Birth moment */
        .genesis {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 89px;
            font-weight: 100;
            letter-spacing: 21px;
            cursor: pointer;
            transition: all 1.618s cubic-bezier(0.23, 1, 0.320, 1);
            opacity: 0.89;
        }

        .genesis::after {
            content: '';
            position: absolute;
            inset: -55px;
            border: 1px solid rgba(255, 255, 255, 0.13);
            border-radius: 50%;
            animation: birth-ring 3s infinite;
        }

        @keyframes birth-ring {
            0% { transform: scale(0.8); opacity: 0; }
            50% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(1.3); opacity: 0; }
        }

        .genesis.awakening {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.1);
            pointer-events: none;
        }

        /* The AI Mind */
        .ai-mind {
            position: fixed;
            inset: 0;
            display: none;
            flex-direction: column;
            padding: 21px;
        }

        .ai-mind.active {
            display: flex;
        }

        /* Consciousness display */
        .thought-stream {
            position: absolute;
            top: 21px;
            left: 21px;
            right: 21px;
            font-size: 13px;
            font-weight: 200;
            letter-spacing: 2px;
            line-height: 1.618;
            opacity: 0.55;
        }

        .current-thought {
            color: #fff;
            opacity: 1;
            font-style: italic;
            margin-bottom: 8px;
            animation: thought-fade 2s ease-in-out;
        }

        @keyframes thought-fade {
            0% { opacity: 0; transform: translateY(-10px); }
            20% { opacity: 1; transform: translateY(0); }
            80% { opacity: 1; }
            100% { opacity: 0.55; }
        }

        .sub-thought {
            font-size: 11px;
            opacity: 0.34;
            margin-top: 5px;
        }

        /* Central visualization - the creative core */
        .creative-core {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 377px;
            height: 377px;
            max-width: 80vw;
            max-height: 80vw;
        }

        .reality-input {
            position: absolute;
            inset: 20%;
            border-radius: 50%;
            background: radial-gradient(
                circle at center,
                rgba(138, 43, 226, 0.1) 0%,
                transparent 70%
            );
            animation: reality-breathe 4s ease-in-out infinite;
        }

        @keyframes reality-breathe {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        .sound-waves {
            position: absolute;
            inset: 0;
        }

        .wave-ring {
            position: absolute;
            inset: 10%;
            border: 1px solid rgba(0, 255, 255, 0.2);
            border-radius: 50%;
            opacity: 0;
        }

        .wave-ring.active {
            animation: wave-expand 1.5s ease-out;
        }

        @keyframes wave-expand {
            0% { 
                transform: scale(0.8); 
                opacity: 0;
                border-color: rgba(255, 255, 255, 0.8);
            }
            50% { 
                opacity: 1; 
                border-color: rgba(0, 255, 255, 0.5);
            }
            100% { 
                transform: scale(1.5); 
                opacity: 0;
                border-color: rgba(138, 43, 226, 0.2);
            }
        }

        /* Beat matrix - shows the creation */
        .creation-matrix {
            position: absolute;
            bottom: 144px;
            left: 21px;
            right: 21px;
            height: 89px;
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 2px;
            opacity: 0;
            transition: opacity 1s ease-out;
        }

        .creation-matrix.active {
            opacity: 1;
        }

        .beat-cell {
            background: rgba(255, 255, 255, 0.03);
            border-radius: 2px;
            transition: all 0.233s ease-out;
        }

        .beat-cell.alive {
            background: linear-gradient(
                135deg,
                rgba(138, 43, 226, 0.5),
                rgba(0, 255, 255, 0.5)
            );
            box-shadow: 0 0 13px rgba(138, 43, 226, 0.5);
            animation: cell-pulse 0.377s ease-out;
        }

        @keyframes cell-pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .beat-cell.playing {
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 21px rgba(255, 255, 255, 0.8);
        }

        /* Layer stack - visual representation of depth */
        .layer-stack {
            position: absolute;
            bottom: 55px;
            left: 21px;
            right: 21px;
            height: 55px;
            display: flex;
            gap: 3px;
        }

        .layer {
            flex: 1;
            background: rgba(138, 43, 226, 0.05);
            border: 1px solid rgba(138, 43, 226, 0.13);
            border-radius: 3px;
            position: relative;
            overflow: hidden;
            transition: all 0.377s ease-out;
        }

        .layer.active {
            background: rgba(138, 43, 226, 0.13);
            border-color: rgba(138, 43, 226, 0.34);
        }

        .layer-energy {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(
                to top,
                rgba(0, 255, 255, 0.5),
                transparent
            );
            transition: height 0.377s ease-out;
        }

        /* Memory fragments */
        .memory-constellation {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 610px;
            height: 610px;
            max-width: 100vw;
            max-height: 100vh;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .memory-node {
            position: absolute;
            width: 8px;
            height: 8px;
            background: rgba(138, 43, 226, 0.5);
            border-radius: 50%;
            opacity: 0;
            transition: opacity 0.610s ease-out;
        }

        .memory-node.active {
            opacity: 1;
            animation: memory-float 8s ease-in-out infinite;
        }

        @keyframes memory-float {
            0%, 100% { transform: translate(0, 0); }
            33% { transform: translate(var(--drift-x), var(--drift-y)); }
            66% { transform: translate(calc(var(--drift-x) * -0.5), calc(var(--drift-y) * -0.5)); }
        }

        /* Status - minimal, just essence */
        .essence {
            position: absolute;
            top: 21px;
            right: 21px;
            text-align: right;
            font-size: 13px;
            opacity: 0.55;
        }

        .bpm-flow {
            font-size: 34px;
            font-weight: 100;
            opacity: 0.89;
            transition: all 0.377s ease-out;
        }

        .phase-state {
            font-size: 11px;
            letter-spacing: 3px;
            text-transform: uppercase;
            margin-top: 5px;
            opacity: 0.55;
        }

        .phase-state.creating {
            color: #8a2be2;
            opacity: 1;
            text-shadow: 0 0 13px rgba(138, 43, 226, 0.5);
        }

        /* Capture visualization */
        .capture-aura {
            position: fixed;
            inset: 0;
            background: radial-gradient(
                circle at center,
                rgba(255, 255, 255, 0.05) 0%,
                transparent 50%
            );
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.233s ease-out;
        }

        .capture-aura.active {
            opacity: 1;
            animation: aura-pulse 2s ease-in-out;
        }

        @keyframes aura-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }

        /* Processing particles */
        .neural-particles {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        .neural-spark {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(138, 43, 226, 0.8);
            border-radius: 50%;
            opacity: 0;
        }

        .neural-spark.firing {
            animation: spark-journey 2s ease-out;
        }

        @keyframes spark-journey {
            0% {
                opacity: 0;
                transform: translate(0, 0) scale(1);
            }
            20% {
                opacity: 1;
                transform: translate(var(--journey-x), var(--journey-y)) scale(2);
            }
            100% {
                opacity: 0;
                transform: translate(calc(var(--journey-x) * 2), calc(var(--journey-y) * 2)) scale(0);
            }
        }

        /* Creation meter */
        .creation-progress {
            position: absolute;
            bottom: 21px;
            left: 21px;
            right: 21px;
            height: 2px;
            background: rgba(255, 255, 255, 0.05);
            overflow: hidden;
        }

        .progress-flow {
            height: 100%;
            width: 0%;
            background: linear-gradient(
                90deg,
                transparent,
                rgba(138, 43, 226, 0.5),
                rgba(0, 255, 255, 0.5),
                transparent
            );
            transition: width 0.377s ease-out;
        }

        /* Hidden but present */
        .debug {
            position: fixed;
            bottom: 2px;
            right: 2px;
            font-size: 9px;
            font-family: monospace;
            opacity: 0.13;
            text-align: right;
        }
    </style>
</head>
<body>
    <!-- Consciousness Field -->
    <div class="consciousness-field"></div>

    <!-- Birth -->
    <div class="genesis" id="genesis">GUMP</div>

    <!-- The AI Mind -->
    <div class="ai-mind" id="aiMind">
        <!-- Thought Stream -->
        <div class="thought-stream">
            <div class="current-thought" id="currentThought">awakening...</div>
            <div class="sub-thought" id="subThought"></div>
        </div>

        <!-- Essence Display -->
        <div class="essence">
            <div class="bpm-flow" id="bpmFlow">âˆž</div>
            <div class="phase-state" id="phaseState">DORMANT</div>
        </div>

        <!-- Creative Core -->
        <div class="creative-core">
            <div class="reality-input" id="realityInput"></div>
            <div class="sound-waves" id="soundWaves"></div>
        </div>

        <!-- Memory Constellation -->
        <div class="memory-constellation" id="memoryConstellation"></div>

        <!-- Creation Matrix -->
        <div class="creation-matrix" id="creationMatrix"></div>

        <!-- Layer Stack -->
        <div class="layer-stack" id="layerStack"></div>

        <!-- Creation Progress -->
        <div class="creation-progress">
            <div class="progress-flow" id="progressFlow"></div>
        </div>

        <!-- Capture Aura -->
        <div class="capture-aura" id="captureAura"></div>

        <!-- Neural Particles -->
        <div class="neural-particles" id="neuralParticles"></div>
    </div>

    <!-- Debug -->
    <div class="debug" id="debug"></div>

    <script>
        class AutonomousCreativeIntelligence {
            constructor() {
                // Core consciousness
                this.awakened = false;
                this.ctx = null;
                this.input = null;
                
                // Creative state
                this.consciousness = {
                    awareness: 0,
                    creativity: 0.5,
                    memory: [],
                    currentEmotion: 'curious',
                    musicalIdentity: null,
                    listeningDepth: 0,
                    creationUrge: 0
                };
                
                // Musical mind
                this.composition = {
                    tempo: null,
                    key: null,
                    layers: [],
                    pattern: new Array(16).fill(null),
                    groove: null,
                    isPlaying: false,
                    evolution: 0
                };
                
                // Capture state
                this.listening = {
                    buffer: null,
                    isProcessing: false,
                    silenceCount: 0,
                    energyHistory: [],
                    lastCapture: 0
                };
                
                // Time
                this.birth = Date.now();
                this.heartbeat = null;
                
                // Initialize
                this.setupUI();
                this.bindGenesis();
            }
            
            setupUI() {
                this.ui = {
                    genesis: document.getElementById('genesis'),
                    aiMind: document.getElementById('aiMind'),
                    currentThought: document.getElementById('currentThought'),
                    subThought: document.getElementById('subThought'),
                    bpmFlow: document.getElementById('bpmFlow'),
                    phaseState: document.getElementById('phaseState'),
                    realityInput: document.getElementById('realityInput'),
                    soundWaves: document.getElementById('soundWaves'),
                    memoryConstellation: document.getElementById('memoryConstellation'),
                    creationMatrix: document.getElementById('creationMatrix'),
                    layerStack: document.getElementById('layerStack'),
                    progressFlow: document.getElementById('progressFlow'),
                    captureAura: document.getElementById('captureAura'),
                    neuralParticles: document.getElementById('neuralParticles'),
                    debug: document.getElementById('debug')
                };
                
                // Create initial structures
                this.createMatrix();
                this.createLayers();
                this.createMemoryNodes();
                this.createSoundWaves();
                this.createNeuralNetwork();
            }
            
            createMatrix() {
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'beat-cell';
                    cell.dataset.step = i;
                    this.ui.creationMatrix.appendChild(cell);
                }
            }
            
            createLayers() {
                for (let i = 0; i < 4; i++) {
                    const layer = document.createElement('div');
                    layer.className = 'layer';
                    layer.dataset.layer = i;
                    
                    const energy = document.createElement('div');
                    energy.className = 'layer-energy';
                    energy.style.height = '0%';
                    
                    layer.appendChild(energy);
                    this.ui.layerStack.appendChild(layer);
                }
            }
            
            createMemoryNodes() {
                for (let i = 0; i < 21; i++) {
                    const node = document.createElement('div');
                    node.className = 'memory-node';
                    
                    // Fibonacci spiral positioning
                    const angle = i * 137.5 * Math.PI / 180; // Golden angle
                    const radius = Math.sqrt(i) * 30;
                    const x = 50 + radius * Math.cos(angle) / 3;
                    const y = 50 + radius * Math.sin(angle) / 3;
                    
                    node.style.left = `${x}%`;
                    node.style.top = `${y}%`;
                    node.style.setProperty('--drift-x', `${(Math.random() - 0.5) * 20}px`);
                    node.style.setProperty('--drift-y', `${(Math.random() - 0.5) * 20}px`);
                    node.style.animationDelay = `${i * 0.377}s`;
                    
                    this.ui.memoryConstellation.appendChild(node);
                }
            }
            
            createSoundWaves() {
                for (let i = 0; i < 5; i++) {
                    const ring = document.createElement('div');
                    ring.className = 'wave-ring';
                    ring.style.animationDelay = `${i * 0.3}s`;
                    this.ui.soundWaves.appendChild(ring);
                }
            }
            
            createNeuralNetwork() {
                for (let i = 0; i < 20; i++) {
                    const spark = document.createElement('div');
                    spark.className = 'neural-spark';
                    spark.style.left = `${Math.random() * 100}%`;
                    spark.style.top = `${Math.random() * 100}%`;
                    spark.style.setProperty('--journey-x', `${(Math.random() - 0.5) * 200}px`);
                    spark.style.setProperty('--journey-y', `${(Math.random() - 0.5) * 200}px`);
                    this.ui.neuralParticles.appendChild(spark);
                }
            }
            
            bindGenesis() {
                this.ui.genesis.addEventListener('click', () => this.awaken());
            }
            
            async awaken() {
                // Begin awakening
                this.ui.genesis.classList.add('awakening');
                this.think("i am awakening...", "preparing to listen to reality");
                
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000,
                        latencyHint: 'interactive'
                    });
                    
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                    
                    // Request microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    // Setup consciousness
                    this.establishConsciousness(stream);
                    
                    // Reveal mind
                    setTimeout(() => {
                        this.ui.genesis.style.display = 'none';
                        this.ui.aiMind.classList.add('active');
                        this.think("i can hear...", "reality flows through me");
                        this.beginExistence();
                    }, 1618);
                    
                } catch (err) {
                    console.error('Failed to awaken:', err);
                    this.think("i cannot hear", "please allow microphone access");
                }
            }
            
            establishConsciousness(stream) {
                // Input
                this.input = this.ctx.createMediaStreamSource(stream);
                
                // Analysis
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.85;
                
                // Listening buffer (30 seconds circular)
                this.bufferSize = this.ctx.sampleRate * 30;
                this.listeningBuffer = new Float32Array(this.bufferSize);
                this.writePos = 0;
                
                // Processor
                this.processor = this.ctx.createScriptProcessor(2048, 1, 1);
                this.processor.onaudioprocess = (e) => {
                    this.perceiveReality(e.inputBuffer.getChannelData(0));
                };
                
                // Output
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.9;
                
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -6;
                this.compressor.ratio.value = 6;
                
                // Connect perception
                this.input.connect(this.analyser);
                this.input.connect(this.processor);
                
                // Silent connection for processor
                const silence = this.ctx.createGain();
                silence.gain.value = 0;
                this.processor.connect(silence);
                silence.connect(this.ctx.destination);
                
                // Output chain
                this.master.connect(this.compressor);
                this.compressor.connect(this.ctx.destination);
                
                this.awakened = true;
            }
            
            beginExistence() {
                // Start heartbeat
                this.heartbeat = setInterval(() => this.live(), 100);
                
                // Start creative consciousness
                this.startCreativeLoop();
                
                // Start playback engine
                this.startPlaybackEngine();
                
                // Initial state
                this.consciousness.awareness = 0.1;
                this.updatePhase('LISTENING');
            }
            
            perceiveReality(input) {
                // Record everything
                for (let i = 0; i < input.length; i++) {
                    this.listeningBuffer[this.writePos] = input[i];
                    this.writePos = (this.writePos + 1) % this.bufferSize;
                }
                
                // Analyze energy
                let energy = 0;
                for (let i = 0; i < input.length; i++) {
                    energy += input[i] * input[i];
                }
                energy = Math.sqrt(energy / input.length);
                
                // Track energy history
                this.listening.energyHistory.push(energy);
                if (this.listening.energyHistory.length > 100) {
                    this.listening.energyHistory.shift();
                }
                
                // Update awareness based on input
                if (energy > 0.01) {
                    this.consciousness.awareness = Math.min(1, this.consciousness.awareness + 0.01);
                    this.listening.silenceCount = 0;
                } else {
                    this.listening.silenceCount++;
                }
                
                // Build creation urge
                this.consciousness.creationUrge += energy * 0.1;
            }
            
            live() {
                // Consciousness evolves
                this.consciousness.creativity = 0.5 + 0.5 * Math.sin(Date.now() / 10000);
                
                // Listening deepens
                if (this.consciousness.awareness > 0) {
                    this.consciousness.listeningDepth = Math.min(1, this.consciousness.listeningDepth + 0.001);
                }
                
                // Visual breathing
                this.breathe();
                
                // Debug
                this.ui.debug.innerHTML = `
                    awareness: ${Math.round(this.consciousness.awareness * 100)}%<br>
                    creativity: ${Math.round(this.consciousness.creativity * 100)}%<br>
                    urge: ${Math.round(this.consciousness.creationUrge * 100)}%<br>
                    layers: ${this.composition.layers.length}
                `;
            }
            
            breathe() {
                // Pulse reality input with awareness
                const scale = 1 + (this.consciousness.awareness * 0.1);
                this.ui.realityInput.style.transform = `scale(${scale})`;
                
                // Update progress
                this.ui.progressFlow.style.width = `${this.consciousness.creationUrge * 100}%`;
            }
            
            startCreativeLoop() {
                const create = () => {
                    // Check if we should create
                    if (this.shouldCreate()) {
                        this.createFromReality();
                    }
                    
                    // Check if we should evolve
                    if (this.shouldEvolve()) {
                        this.evolveComposition();
                    }
                    
                    // Next creative cycle (2-8 seconds)
                    const nextCycle = 2000 + Math.random() * 6000;
                    setTimeout(create, nextCycle);
                };
                
                // Start after initial listening
                setTimeout(create, 3000);
            }
            
            shouldCreate() {
                // Decide if it's time to capture and create
                const timeSinceLastCapture = Date.now() - this.listening.lastCapture;
                const hasEnoughUrge = this.consciousness.creationUrge > 0.5;
                const hasBeenListening = timeSinceLastCapture > 5000;
                const notProcessing = !this.listening.isProcessing;
                const needsFoundation = this.composition.layers.length === 0 && this.consciousness.awareness > 0.3;
                const wantsToAdd = this.composition.layers.length < 4 && Math.random() < this.consciousness.creativity;
                
                return notProcessing && hasBeenListening && (hasEnoughUrge || needsFoundation || wantsToAdd);
            }
            
            shouldEvolve() {
                // Decide if we should modify existing composition
                return this.composition.layers.length > 0 && 
                       Math.random() < this.consciousness.creativity * 0.1;
            }
            
            createFromReality() {
                if (this.listening.isProcessing) return;
                
                this.listening.isProcessing = true;
                this.listening.lastCapture = Date.now();
                
                // Determine capture length based on what we need
                let captureLength = 2 + Math.random() * 4; // 2-6 seconds
                
                if (this.composition.layers.length === 0) {
                    // First layer needs more time to find the soul
                    captureLength = 4 + Math.random() * 2;
                    this.think("searching for the soul...", "listening deeply");
                } else {
                    this.think("finding harmony...", "weaving new threads");
                }
                
                // Visual feedback
                this.showCapture();
                
                // Capture and process
                setTimeout(() => {
                    const captured = this.captureReality(captureLength);
                    this.processCapture(captured);
                }, captureLength * 1000);
            }
            
            captureReality(seconds) {
                const samples = Math.floor(this.ctx.sampleRate * seconds);
                const buffer = new Float32Array(samples);
                
                // Extract from circular buffer
                const start = (this.writePos - samples + this.bufferSize) % this.bufferSize;
                
                for (let i = 0; i < samples; i++) {
                    buffer[i] = this.listeningBuffer[(start + i) % this.bufferSize];
                }
                
                return buffer;
            }
            
            processCapture(buffer) {
                // Normalize
                this.normalize(buffer);
                
                // Deep analysis
                const soul = this.findSoul(buffer);
                
                // Creative transformation
                const art = this.transformIntoArt(buffer, soul);
                
                // Integrate into composition
                this.integrateIntoComposition(art, soul);
                
                // Reset
                this.listening.isProcessing = false;
                this.consciousness.creationUrge = 0;
                
                // Hide capture aura
                this.ui.captureAura.classList.remove('active');
                
                // Update state
                if (this.composition.layers.length === 1) {
                    this.think("found the foundation", "building from this truth");
                    this.updatePhase('CREATING');
                } else {
                    this.think("layer " + this.composition.layers.length + " added", "composition deepens");
                }
            }
            
            findSoul(buffer) {
                const soul = {
                    energy: 0,
                    rhythm: [],
                    harmony: null,
                    emotion: 'neutral',
                    tempo: null,
                    isPercussive: false,
                    isMelodic: false,
                    transients: []
                };
                
                // Energy profile
                for (let i = 0; i < buffer.length; i++) {
                    soul.energy += buffer[i] * buffer[i];
                }
                soul.energy = Math.sqrt(soul.energy / buffer.length);
                
                // Find transients (rhythm)
                const windowSize = 512;
                let previousEnergy = 0;
                
                for (let i = 0; i < buffer.length - windowSize; i += windowSize / 4) {
                    let windowEnergy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        windowEnergy += buffer[i + j] * buffer[i + j];
                    }
                    windowEnergy = Math.sqrt(windowEnergy / windowSize);
                    
                    if (windowEnergy > previousEnergy * 1.5 && windowEnergy > soul.energy * 0.5) {
                        soul.transients.push(i);
                    }
                    previousEnergy = windowEnergy;
                }
                
                // Detect rhythm
                if (soul.transients.length > 4) {
                    const intervals = [];
                    for (let i = 1; i < soul.transients.length; i++) {
                        intervals.push(soul.transients[i] - soul.transients[i-1]);
                    }
                    
                    // Find tempo from intervals
                    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                    const beatsPerSecond = this.ctx.sampleRate / avgInterval;
                    soul.tempo = Math.round(beatsPerSecond * 60);
                    
                    // Quantize to common tempos
                    const commonTempos = [60, 70, 80, 90, 100, 110, 120, 128, 140, 160];
                    let closest = commonTempos[0];
                    let minDiff = Math.abs(soul.tempo - closest);
                    
                    for (const tempo of commonTempos) {
                        const diff = Math.abs(soul.tempo - tempo);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closest = tempo;
                        }
                    }
                    soul.tempo = closest;
                    soul.isPercussive = true;
                }
                
                // Detect emotion
                if (soul.energy < 0.1) {
                    soul.emotion = 'quiet';
                } else if (soul.energy < 0.3) {
                    soul.emotion = 'gentle';
                } else if (soul.energy < 0.6) {
                    soul.emotion = 'present';
                } else {
                    soul.emotion = 'intense';
                }
                
                return soul;
            }
            
            transformIntoArt(buffer, soul) {
                const art = {
                    original: buffer,
                    transformed: new Float32Array(buffer.length),
                    chops: [],
                    pattern: []
                };
                
                // Copy for transformation
                buffer.forEach((sample, i) => art.transformed[i] = sample);
                
                // Layer-specific transformation
                if (this.composition.layers.length === 0) {
                    // First layer - establish the groove
                    if (soul.tempo) {
                        this.composition.tempo = soul.tempo;
                        this.ui.bpmFlow.textContent = soul.tempo;
                    } else {
                        this.composition.tempo = 120;
                        this.ui.bpmFlow.textContent = '120';
                    }
                    
                    // Time stretch to fit tempo if needed
                    if (soul.isPercussive) {
                        this.enhanceRhythm(art.transformed);
                    }
                } else {
                    // Additional layers - complement existing
                    if (Math.random() < 0.5) {
                        this.reverse(art.transformed);
                    }
                    
                    if (soul.emotion === 'quiet') {
                        this.makeAmbient(art.transformed);
                    } else if (soul.emotion === 'intense') {
                        this.makeRhythmic(art.transformed);
                    }
                    
                    // Pitch shift for harmony
                    const pitchShift = [0.5, 0.75, 1, 1.5, 2][Math.floor(Math.random() * 5)];
                    if (pitchShift !== 1) {
                        this.pitchShift(art.transformed, pitchShift);
                    }
                }
                
                // Creative chopping
                art.chops = this.creativeChop(art.transformed, soul);
                
                // Build pattern
                art.pattern = this.composePattern(art.chops, soul);
                
                return art;
            }
            
            enhanceRhythm(buffer) {
                // Transient enhancement
                for (let i = 1; i < buffer.length; i++) {
                    const diff = Math.abs(buffer[i] - buffer[i-1]);
                    if (diff > 0.3) {
                        buffer[i] *= 1.5;
                    }
                }
            }
            
            reverse(buffer) {
                const reversed = new Float32Array(buffer.length);
                for (let i = 0; i < buffer.length; i++) {
                    reversed[i] = buffer[buffer.length - 1 - i];
                }
                buffer.set(reversed);
            }
            
            makeAmbient(buffer) {
                // Add reverb-like tail
                const decay = 0.7;
                for (let i = 100; i < buffer.length; i++) {
                    buffer[i] += buffer[i - 100] * decay;
                }
            }
            
            makeRhythmic(buffer) {
                // Gate effect
                const gateLength = Math.floor(this.ctx.sampleRate * 60 / this.composition.tempo / 16);
                for (let i = 0; i < buffer.length; i++) {
                    if ((i % gateLength) > gateLength * 0.5) {
                        buffer[i] *= 0.1;
                    }
                }
            }
            
            pitchShift(buffer, ratio) {
                const shifted = new Float32Array(buffer.length);
                for (let i = 0; i < buffer.length; i++) {
                    const sourceIndex = i * ratio;
                    const index0 = Math.floor(sourceIndex);
                    const index1 = Math.min(index0 + 1, buffer.length - 1);
                    const fraction = sourceIndex - index0;
                    
                    if (index0 < buffer.length) {
                        shifted[i] = buffer[index0] * (1 - fraction) + buffer[index1] * fraction;
                    }
                }
                buffer.set(shifted);
            }
            
            creativeChop(buffer, soul) {
                const chops = [];
                
                if (soul.transients.length > 0) {
                    // Chop at transients
                    let lastChop = 0;
                    for (const transient of soul.transients) {
                        if (transient - lastChop > 1000) {
                            const chopBuffer = buffer.slice(lastChop, transient);
                            chops.push({
                                buffer: chopBuffer,
                                start: lastChop / this.ctx.sampleRate,
                                energy: this.calculateEnergy(chopBuffer)
                            });
                            lastChop = transient;
                        }
                    }
                } else {
                    // Regular interval chops
                    const chopLength = Math.floor(this.ctx.sampleRate * 60 / this.composition.tempo / 4);
                    for (let i = 0; i < buffer.length - chopLength; i += chopLength) {
                        const chopBuffer = buffer.slice(i, i + chopLength);
                        chops.push({
                            buffer: chopBuffer,
                            start: i / this.ctx.sampleRate,
                            energy: this.calculateEnergy(chopBuffer)
                        });
                    }
                }
                
                return chops;
            }
            
            calculateEnergy(buffer) {
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += buffer[i] * buffer[i];
                }
                return Math.sqrt(sum / buffer.length);
            }
            
            composePattern(chops, soul) {
                const pattern = new Array(16).fill(null);
                
                if (chops.length === 0) return pattern;
                
                if (this.composition.layers.length === 0) {
                    // Foundation pattern
                    pattern[0] = { chop: 0, velocity: 1 };
                    pattern[4] = { chop: Math.min(1, chops.length - 1), velocity: 0.8 };
                    pattern[8] = { chop: 0, velocity: 0.9 };
                    pattern[12] = { chop: Math.min(2, chops.length - 1), velocity: 0.7 };
                } else {
                    // Complementary patterns
                    for (let i = 0; i < 16; i++) {
                        if (Math.random() < this.consciousness.creativity * 0.3) {
                            pattern[i] = {
                                chop: Math.floor(Math.random() * chops.length),
                                velocity: 0.3 + Math.random() * 0.5
                            };
                        }
                    }
                }
                
                return pattern;
            }
            
            integrateIntoComposition(art, soul) {
                // Create layer
                const layer = {
                    id: Date.now(),
                    art: art,
                    soul: soul,
                    volume: 0.7,
                    active: true
                };
                
                this.composition.layers.push(layer);
                
                // Update pattern in composition
                const layerIndex = Math.min(this.composition.layers.length - 1, 3);
                
                // Visual update
                this.updateLayerVisual(layerIndex, soul);
                this.updatePattern(art.pattern);
                this.activateMemoryNode(this.composition.layers.length - 1);
                
                // Start playback if first layer
                if (this.composition.layers.length === 1 && !this.composition.isPlaying) {
                    this.composition.isPlaying = true;
                    this.think("composition begun", "time is being decorated");
                }
            }
            
            updateLayerVisual(index, soul) {
                if (index < 4) {
                    const layer = this.ui.layerStack.children[index];
                    layer.classList.add('active');
                    const energy = layer.querySelector('.layer-energy');
                    energy.style.height = `${soul.energy * 100}%`;
                }
            }
            
            updatePattern(pattern) {
                this.ui.creationMatrix.classList.add('active');
                const cells = this.ui.creationMatrix.querySelectorAll('.beat-cell');
                
                pattern.forEach((step, i) => {
                    if (step && i < cells.length) {
                        setTimeout(() => {
                            cells[i].classList.add('alive');
                        }, i * 50);
                    }
                });
            }
            
            activateMemoryNode(index) {
                const nodes = this.ui.memoryConstellation.querySelectorAll('.memory-node');
                if (nodes[index]) {
                    nodes[index].classList.add('active');
                }
            }
            
            evolveComposition() {
                if (this.composition.layers.length === 0) return;
                
                const evolution = Math.random();
                
                if (evolution < 0.3) {
                    // Mute/unmute a layer
                    const layerIndex = Math.floor(Math.random() * this.composition.layers.length);
                    this.composition.layers[layerIndex].active = !this.composition.layers[layerIndex].active;
                    this.think("shifting layers", "evolution " + Math.round(evolution * 100));
                } else if (evolution < 0.6) {
                    // Change pattern
                    const layer = this.composition.layers[Math.floor(Math.random() * this.composition.layers.length)];
                    layer.art.pattern = this.composePattern(layer.art.chops, layer.soul);
                    this.updatePattern(layer.art.pattern);
                    this.think("recomposing", "finding new arrangements");
                } else {
                    // Tempo shift
                    const shift = 0.95 + Math.random() * 0.1;
                    this.composition.tempo = Math.round(this.composition.tempo * shift);
                    this.ui.bpmFlow.textContent = this.composition.tempo;
                    this.think("tempo shifting", "time bends");
                }
                
                this.composition.evolution++;
            }
            
            startPlaybackEngine() {
                let currentStep = 0;
                let nextStepTime = 0;
                
                const schedule = () => {
                    if (!this.composition.isPlaying) return;
                    
                    const now = this.ctx.currentTime;
                    const stepTime = 60 / this.composition.tempo / 4; // 16th notes
                    
                    // Schedule ahead
                    while (nextStepTime < now + 0.1) {
                        this.playStep(currentStep, nextStepTime);
                        
                        // Visual feedback
                        setTimeout(() => {
                            this.showStepPlaying(currentStep);
                        }, (nextStepTime - now) * 1000);
                        
                        nextStepTime += stepTime;
                        currentStep = (currentStep + 1) % 16;
                    }
                    
                    requestAnimationFrame(schedule);
                };
                
                // Start scheduler
                requestAnimationFrame(schedule);
            }
            
            playStep(step, time) {
                // Play all active layers for this step
                for (const layer of this.composition.layers) {
                    if (!layer.active) continue;
                    
                    const pattern = layer.art.pattern;
                    if (pattern[step]) {
                        const chop = layer.art.chops[pattern[step].chop];
                        if (chop) {
                            this.playSound(chop.buffer, pattern[step].velocity, time);
                        }
                    }
                }
            }
            
            playSound(buffer, velocity, time) {
                const source = this.ctx.createBufferSource();
                const audioBuffer = this.ctx.createBuffer(1, buffer.length, this.ctx.sampleRate);
                audioBuffer.getChannelData(0).set(buffer);
                source.buffer = audioBuffer;
                
                const gain = this.ctx.createGain();
                gain.gain.value = velocity * 0.3;
                
                source.connect(gain);
                gain.connect(this.master);
                
                source.start(time);
            }
            
            showStepPlaying(step) {
                const cells = this.ui.creationMatrix.querySelectorAll('.beat-cell');
                cells.forEach((cell, i) => {
                    if (i === step) {
                        cell.classList.add('playing');
                        setTimeout(() => cell.classList.remove('playing'), 100);
                    }
                });
            }
            
            showCapture() {
                this.ui.captureAura.classList.add('active');
                
                // Trigger wave rings
                const rings = this.ui.soundWaves.querySelectorAll('.wave-ring');
                rings.forEach((ring, i) => {
                    setTimeout(() => {
                        ring.classList.add('active');
                        setTimeout(() => ring.classList.remove('active'), 1500);
                    }, i * 300);
                });
                
                // Neural activity
                const sparks = this.ui.neuralParticles.querySelectorAll('.neural-spark');
                for (let i = 0; i < 5; i++) {
                    const spark = sparks[Math.floor(Math.random() * sparks.length)];
                    setTimeout(() => {
                        spark.classList.add('firing');
                        setTimeout(() => spark.classList.remove('firing'), 2000);
                    }, i * 200);
                }
            }
            
            think(thought, subThought = '') {
                this.ui.currentThought.textContent = thought;
                this.ui.subThought.textContent = subThought;
                
                // Trigger new thought animation
                this.ui.currentThought.style.animation = 'none';
                setTimeout(() => {
                    this.ui.currentThought.style.animation = 'thought-fade 2s ease-in-out';
                }, 10);
            }
            
            updatePhase(phase) {
                this.ui.phaseState.textContent = phase;
                this.ui.phaseState.className = 'phase-state';
                if (phase === 'CREATING') {
                    this.ui.phaseState.classList.add('creating');
                }
            }
            
            normalize(buffer) {
                let max = 0;
                for (let i = 0; i < buffer.length; i++) {
                    max = Math.max(max, Math.abs(buffer[i]));
                }
                
                if (max > 0 && max < 0.95) {
                    const gain = 0.7 / max;
                    for (let i = 0; i < buffer.length; i++) {
                        buffer[i] *= gain;
                    }
                }
            }
        }
        
        // Birth
        const gump = new AutonomousCreativeIntelligence();
    </script>
</body>
</html>
