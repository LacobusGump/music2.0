<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Primal Music Evolution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
      font-family: 'Courier New', monospace;
    }
    
    body.expansion {
      animation: bigBang 4s ease-out forwards;
    }
    @keyframes bigBang {
      0% { 
        background: black; 
        transform: scale(0.001); 
      }
      20% { 
        background: radial-gradient(circle, white 0%, #ff6b6b 20%, #4ecdc4 40%, #45b7d1 60%, black 100%); 
        transform: scale(0.1); 
      }
      50% { 
        background: radial-gradient(circle, #fff 0%, #ff9f43 15%, #ee5a24 30%, #0984e3 45%, #6c5ce7 60%, black 100%); 
        transform: scale(3); 
      }
      100% { 
        background: black; 
        transform: scale(1); 
      }
    }
    
    .start-btn {
      padding: 30px 60px;
      background: radial-gradient(circle, white 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
      color: white;
      border: 2px solid rgba(255,255,255,0.5);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 30px white, inset 0 0 20px rgba(255,255,255,0.2);
      animation: primordialPulse 3s ease-in-out infinite;
      font-size: 14px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
    }
    
    @keyframes primordialPulse { 
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px white; } 
      50% { transform: scale(1.3); box-shadow: 0 0 60px #ff6b6b, 0 0 90px #4ecdc4; } 
    }
    
    .orb {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: radial-gradient(circle, white, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
      box-shadow: 0 0 20px white;
      will-change: transform;
    }
    
    .orb.tribal { 
      background: radial-gradient(circle, #ff6b6b, #ff9f43, transparent);
      box-shadow: 0 0 40px #ff6b6b;
      width: 12px; height: 12px;
    }
    
    .orb.orchestral { 
      background: radial-gradient(circle, #4ecdc4, #45b7d1, transparent);
      box-shadow: 0 0 60px #4ecdc4;
      width: 16px; height: 16px;
    }
    
    .orb.heaven { 
      background: radial-gradient(circle, #6c5ce7, #a29bfe, #fd79a8, transparent);
      box-shadow: 0 0 100px #6c5ce7, 0 0 150px #fd79a8;
      width: 24px; height: 24px;
      animation: heavenPulse 2s ease-in-out infinite;
    }
    
    .orb.pulse {
      animation: beatPulse 0.3s ease-out;
    }
    
    @keyframes heavenPulse { 
      0%, 100% { transform: translate(-50%, -50%) scale(1); } 
      50% { transform: translate(-50%, -50%) scale(1.4); } 
    }
    @keyframes beatPulse { 
      0% { transform: translate(-50%, -50%) scale(1); } 
      50% { transform: translate(-50%, -50%) scale(1.6); } 
      100% { transform: translate(-50%, -50%) scale(1); } 
    }
    
    .message {
      position: absolute;
      top: 20%;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 18px;
      font-weight: bold;
      text-align: center;
      opacity: 0;
      transition: all 1s ease;
      text-shadow: 0 0 10px rgba(255,255,255,0.8);
    }
    
    .message.show { opacity: 1; }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      border-radius: 50%;
      animation: particleFloat 6s infinite ease-in-out;
    }
    
    .particle.tribal {
      width: 3px; height: 3px;
      background: #ff6b6b;
      box-shadow: 0 0 6px #ff6b6b;
    }
    
    .particle.orchestral {
      width: 4px; height: 4px;
      background: #4ecdc4;
      box-shadow: 0 0 8px #4ecdc4;
    }
    
    .particle.heaven {
      width: 6px; height: 6px;
      background: #6c5ce7;
      box-shadow: 0 0 12px #6c5ce7, 0 0 20px #fd79a8;
    }
    
    @keyframes particleFloat {
      0% { transform: translateY(100vh) scale(0); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-20vh) scale(1.5); opacity: 0; }
    }
    
    .progress-indicator {
      position: absolute;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.7);
      font-size: 12px;
      text-align: center;
    }
    
    .evolution-stage {
      font-weight: bold;
      margin-bottom: 5px;
    }
  </style>
</head>
<body>
  <button class="start-btn" id="start">BEGIN<br/>EVOLUTION</button>
  
  <div class="spatial-viz hidden" id="viz">
    <div class="orb" id="orb"></div>
    <div class="message" id="message">NOW MOVE</div>
    <div class="progress-indicator" id="progress">
      <div class="evolution-stage" id="stage">PRIMORDIAL</div>
      <div id="substage">Awaiting first steps...</div>
    </div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 60; // Start very slow, primal
        this.swing = 0.05;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.reverb = null;
        this.delay = null;
        this.compressor = null;
        
        // Evolution stages
        this.evolutionStage = 'PRIMORDIAL'; // PRIMORDIAL -> TRIBAL -> ORCHESTRAL -> HEAVEN
        this.stageProgress = 0;
        this.totalSteps = 0;
        this.firstMovement = false;
        
        // Advanced musical concepts
        this.circleOfFifths = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5]; // C, G, D, A, E, B, F#, C#, G#, D#, A#, F
        this.currentFifthPosition = 0;
        this.chordProgressions = {
          tribal: [[0, 3, 7], [7, 10, 2], [5, 8, 0]], // Simple triads
          orchestral: [[0, 4, 7, 11], [5, 9, 0, 4], [7, 11, 2, 5], [2, 6, 9, 0]], // 7th chords
          heaven: [[0, 4, 7, 11, 2], [7, 11, 2, 6, 9], [4, 8, 11, 3, 6], [9, 1, 4, 8, 11]] // Extended harmonies
        };
        
        // Frequency mappings (Hz)
        this.noteFreqs = {
          0: 130.81, 1: 138.59, 2: 146.83, 3: 155.56, 4: 164.81, 5: 174.61,
          6: 185.00, 7: 196.00, 8: 207.65, 9: 220.00, 10: 233.08, 11: 246.94
        };
        
        this.oscillators = new Set();
        this.scheduledEvents = [];
        this.masterGain = null;
        
        // Rhythmic patterns that evolve
        this.patterns = {
          tribal: {
            kick: [1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0], // Irregular, primal
            perc: [0,1,0,0,1,0,1,0,0,1,0,1,0,0,1,0],
            vocal: [0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0]
          },
          orchestral: {
            kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], // Structured 4/4
            snare: [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],
            strings: [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],
            brass: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0]
          },
          heaven: {
            kick: [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0], // Sparse, ethereal
            pad: [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1], // Constant heaven
            arp: [1,0,1,1,0,1,0,1,1,0,1,1,0,1,0,1],
            choir: [0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0]
          }
        };
        
        this.elements = {};
        this.motionHistory = [];
        this.lastReflectionTime = 0;
        
        this.init();
      }

      init() {
        const ids = ['start', 'viz', 'orb', 'message', 'progress', 'stage', 'substage'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.start.onclick = () => this.start();
      }

      async start() {
        try {
          // Request permissions
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') {
              alert('Motion permission required for this primal experience');
              return;
            }
          }

          // Create advanced audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();

          // BIG BANG ANIMATION
          document.body.classList.add('expansion');
          
          setTimeout(() => {
            document.body.classList.remove('expansion');
            this.elements.start.classList.add('hidden');
            this.elements.viz.classList.remove('hidden');
            
            // Show "NOW MOVE" message
            setTimeout(() => {
              this.elements.message.classList.add('show');
              setTimeout(() => this.elements.message.classList.remove('show'), 3000);
            }, 500);
            
            this.active = true;
            this.lastMotionTime = Date.now();
            this.startSensors();
            this.startEvolutionEngine();
            this.animate();
            this.monitorTranscendence();
          }, 4000);
          
        } catch (e) {
          console.error('Evolution failed to begin:', e);
          alert('Failed to start the primal experience. Try again.');
        }
      }

      setupAudioChain() {
        // Master gain
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        this.masterGain.connect(this.ctx.destination);
        
        // Reverb (cathedral-like)
        this.reverb = this.ctx.createConvolver();
        const reverbTime = 4;
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 1.5);
          }
        }
        this.reverb.buffer = buffer;
        this.reverb.connect(this.masterGain);
        
        // Delay for rhythmic echoes
        this.delay = this.ctx.createDelay(0.5);
        this.delay.delayTime.value = 0.125; // 8th note delay
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.3;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.2;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        delayMix.connect(this.masterGain);
        
        // Compressor for professional sound
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 30;
        this.compressor.ratio.value = 12;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        this.compressor.connect(this.masterGain);
      }

      startSensors() {
        let motionBuffer = [];
        const bufferSize = 10;
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);
          
          const rawMotion = Math.sqrt(dx * dx + dy * dy + dz * dz);
          motionBuffer.push(rawMotion);
          if (motionBuffer.length > bufferSize) motionBuffer.shift();
          
          this.motion = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length;
          this.motionHistory.push(this.motion);
          if (this.motionHistory.length > 100) this.motionHistory.shift();

          // First movement detection
          if (!this.firstMovement && this.motion > 2) {
            this.firstMovement = true;
            this.evolveToTribal();
          }

          if (this.motion > 2) {
            this.lastMotionTime = Date.now();
            this.totalSteps++;
          }

          // Physics for orb
          this.velocity.x += acc.x * 0.01;
          this.velocity.y += acc.y * 0.01;
          this.pos.x += this.velocity.x;
          this.pos.y += this.velocity.y;
          
          // Boundaries with bounce
          if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.8;
          if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.8;
          
          this.pos.x = Math.max(5, Math.min(95, this.pos.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y));
          
          // Friction
          this.velocity.x *= 0.98;
          this.velocity.y *= 0.98;

          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.updateEvolution();
        }, { passive: true });

        // Desktop fallback
        let mouseVel = { x: 0, y: 0 };
        let lastMouse = { x: 0, y: 0 };
        
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          mouseVel.x = newX - lastMouse.x;
          mouseVel.y = newY - lastMouse.y;
          
          this.motion = Math.sqrt(mouseVel.x * mouseVel.x + mouseVel.y * mouseVel.y) * 0.5;
          this.pos.x = newX;
          this.pos.y = newY;
          
          if (!this.firstMovement && this.motion > 1) {
            this.firstMovement = true;
            this.evolveToTribal();
          }
          
          if (this.motion > 1) {
            this.lastMotionTime = Date.now();
            this.totalSteps++;
          }
          
          lastMouse = { x: newX, y: newY };
          this.updateEvolution();
        });
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.length > 0 ? 
          this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length : 0;
        
        // Evolution triggers
        if (this.evolutionStage === 'TRIBAL' && this.totalSteps > 50 && avgMotion > 3) {
          this.evolveToOrchestral();
        } else if (this.evolutionStage === 'ORCHESTRAL' && this.totalSteps > 150 && avgMotion > 5) {
          this.evolveToHeaven();
        }
        
        // Dynamic BPM based on motion and evolution
        let targetBPM = 60;
        switch(this.evolutionStage) {
          case 'TRIBAL': targetBPM = 80 + (avgMotion * 8); break;
          case 'ORCHESTRAL': targetBPM = 110 + (avgMotion * 6); break;
          case 'HEAVEN': targetBPM = 140 + (avgMotion * 4); break;
        }
        
        this.bpm = this.bpm * 0.95 + targetBPM * 0.05;
        this.updateUI();
      }

      evolveToTribal() {
        this.evolutionStage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.createParticles('tribal');
        this.elements.stage.textContent = 'TRIBAL';
        this.elements.substage.textContent = 'Primal rhythms awakening...';
        console.log('🔥 EVOLVED TO TRIBAL');
      }

      evolveToOrchestral() {
        this.evolutionStage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.createParticles('orchestral');
        this.elements.stage.textContent = 'ORCHESTRAL';
        this.elements.substage.textContent = 'Complex harmonies emerging...';
        console.log('🎼 EVOLVED TO ORCHESTRAL');
      }

      evolveToHeaven() {
        this.evolutionStage = 'HEAVEN';
        this.elements.orb.className = 'orb heaven';
        this.createParticles('heaven');
        this.elements.stage.textContent = 'HEAVEN';
        this.elements.substage.textContent = 'Transcendental synthesis...';
        console.log('✨ EVOLVED TO HEAVEN');
      }

      createParticles(type) {
        // Clear existing particles
        const existing = document.getElementById('particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.id = 'particles';
        container.className = 'particles';
        document.body.appendChild(container);
        
        const count = type === 'heaven' ? 40 : type === 'orchestral' ? 25 : 15;
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = `particle ${type}`;
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 6 + 's';
          particle.style.animationDuration = (4 + Math.random() * 4) + 's';
          container.appendChild(particle);
        }
      }

      startEvolutionEngine() {
        const tick = () => {
          if (!this.active) return;

          const interval = 60000 / this.bpm / 4; // 16th notes
          const swingFactor = (this.step % 2 === 1) ? 1 + this.swing : 1;

          this.playCurrentPattern();
          
          this.step = (this.step + 1) % 16;
          
          // Chord progression advancement
          if (this.step === 0) {
            this.currentFifthPosition = (this.currentFifthPosition + 1) % this.circleOfFifths.length;
            this.updateHarmony();
          }

          setTimeout(tick, interval * swingFactor);
        };
        tick();
      }

      playCurrentPattern() {
        const patterns = this.patterns[this.evolutionStage.toLowerCase()];
        if (!patterns) return;

        // Beat pulse visual
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 300);
        }

        // Play patterns based on evolution stage
        Object.keys(patterns).forEach(instrument => {
          if (patterns[instrument][this.step]) {
            this.playInstrument(instrument);
          }
        });
      }

      playInstrument(instrument) {
        if (this.oscillators.size > 20) return; // Limit for performance

        switch(instrument) {
          case 'kick': this.playKick(); break;
          case 'snare': this.playSnare(); break;
          case 'perc': this.playPerc(); break;
          case 'vocal': this.playVocal(); break;
          case 'strings': this.playStrings(); break;
          case 'brass': this.playBrass(); break;
          case 'pad': this.playPad(); break;
          case 'arp': this.playArp(); break;
          case 'choir': this.playChoir(); break;
        }
      }

      // TRIBAL SOUNDS
      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.3);
        
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        osc.connect(gain).connect(this.compressor);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 300);
      }

      playPerc() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'triangle';
        osc.frequency.value = 200 + Math.random() * 400;
        filter.type = 'bandpass';
        filter.frequency.value = 800 + this.motion * 50;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0.6, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        osc.connect(filter).connect(gain).connect(this.delay);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 200);
      }

      playVocal() {
        const freq = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 2;
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'sawtooth';
        osc2.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 1.01; // Slight detune
        
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + this.motion * 100;
        filter.Q.value = 3;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.reverb);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 1.5);
        osc2.stop(this.ctx.currentTime + 1.5);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => {
          this.oscillators.delete(osc1);
          this.oscillators.delete(osc2);
        }, 1500);
      }

      // ORCHESTRAL SOUNDS
      playSnare() {
        const noise = this.ctx.createBufferSource();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        noise.buffer = buffer;
        
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        filter.type = 'bandpass';
        filter.frequency.value = 400;
        filter.Q.value = 1;
        
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
        
        noise.connect(filter).connect(gain).connect(this.compressor);
        noise.start();
        
        this.oscillators.add(noise);
        setTimeout(() => this.oscillators.delete(noise), 150);
      }

      playStrings() {
        const chord = this.chordProgressions.orchestral[this.step % 4];
        
        chord.forEach((note, i) => {
          const freq = this.noteFreqs[note] * (0.5 + i * 0.125); // Different octaves
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 800 + this.motion * 200;
          filter.Q.value = 2;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.15 / chord.length, this.ctx.currentTime + 0.1);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 2000);
        });
      }

      playBrass() {
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const freq = this.noteFreqs[rootNote] * 1.5;
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const osc3 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'sawtooth';
        osc2.type = 'square';
        osc3.type = 'triangle';
        
        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 1.5; // Perfect fifth
        osc3.frequency.value = freq * 2; // Octave
        
        filter.type = 'bandpass';
        filter.frequency.value = 1200 + this.motion * 300;
        filter.Q.value = 4;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.05);
        gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.2);
        
        osc1.connect(filter);
        osc2.connect(filter);
        osc3.connect(filter);
        filter.connect(gain).connect(this.reverb);
        
        osc1.start();
        osc2.start();
        osc3.start();
        osc1.stop(this.ctx.currentTime + 1.2);
        osc2.stop(this.ctx.currentTime + 1.2);
        osc3.stop(this.ctx.currentTime + 1.2);
        
        [osc1, osc2, osc3].forEach(osc => {
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1200);
        });
      }

      // HEAVEN SOUNDS - Modern 2025 Circle of Fifths Synthesis
      playPad() {
        const chord = this.chordProgressions.heaven[this.step % 4];
        
        chord.forEach((note, i) => {
          const freq = this.noteFreqs[note] * 0.25; // Sub-bass frequencies
          
          // Multiple oscillators for thick pad sound
          for (let j = 0; j < 3; j++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const lfo = this.ctx.createOscillator();
            const lfoGain = this.ctx.createGain();
            
            osc.type = j === 0 ? 'sine' : j === 1 ? 'sawtooth' : 'triangle';
            osc.frequency.value = freq * (1 + j * 0.005); // Slight detune
            
            // LFO for filter modulation
            lfo.type = 'sine';
            lfo.frequency.value = 0.2 + Math.random() * 0.3;
            lfoGain.gain.value = 200 + this.motion * 100;
            
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            
            filter.type = 'lowpass';
            filter.frequency.value = 400 + this.transcendentIntensity * 800;
            filter.Q.value = 8;
            
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.08 / chord.length, this.ctx.currentTime + 1);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
            
            osc.connect(filter).connect(gain).connect(this.reverb);
            lfo.start();
            osc.start();
            osc.stop(this.ctx.currentTime + 8);
            lfo.stop(this.ctx.currentTime + 8);
            
            this.oscillators.add(osc);
            this.oscillators.add(lfo);
            setTimeout(() => {
              this.oscillators.delete(osc);
              this.oscillators.delete(lfo);
            }, 8000);
          }
        });
      }

      playArp() {
        const progression = this.chordProgressions.heaven[this.currentFifthPosition % 4];
        const noteIndex = this.step % progression.length;
        const freq = this.noteFreqs[progression[noteIndex]] * (2 + Math.floor(this.step / 4));
        
        // Modern chopped synthesis
        const bufferSize = this.ctx.sampleRate * 0.1; // 100ms buffer
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Generate complex waveform
        for (let i = 0; i < bufferSize; i++) {
          const t = i / this.ctx.sampleRate;
          const fundamental = Math.sin(2 * Math.PI * freq * t);
          const harmonic2 = Math.sin(2 * Math.PI * freq * 2 * t) * 0.5;
          const harmonic3 = Math.sin(2 * Math.PI * freq * 3 * t) * 0.25;
          const noise = (Math.random() * 2 - 1) * 0.05;
          
          data[i] = (fundamental + harmonic2 + harmonic3 + noise) * 0.25;
        }
        
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const bitCrusher = this.ctx.createWaveShaper();
        
        // Bit crushing for modern effect
        const curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          const x = (i - 128) / 128;
          curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.5);
        }
        bitCrusher.curve = curve;
        
        filter.type = 'bandpass';
        filter.frequency.value = freq * 2 + this.motion * 200;
        filter.Q.value = 12;
        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        
        source.connect(bitCrusher).connect(filter).connect(gain).connect(this.delay);
        source.start();
        source.stop(this.ctx.currentTime + 0.4);
        
        this.oscillators.add(source);
        setTimeout(() => this.oscillators.delete(source), 400);
      }

      playChoir() {
        // Ethereal vocal synthesis using formant filtering
        const chord = this.chordProgressions.heaven[this.currentFifthPosition % 4];
        
        chord.forEach((note, i) => {
          const freq = this.noteFreqs[note] * 4; // Higher register
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          // Multiple formant filters for vocal quality
          const formant1 = this.ctx.createBiquadFilter();
          const formant2 = this.ctx.createBiquadFilter();
          const formant3 = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          // Vowel formants (roughly "ahh" sound)
          formant1.type = 'bandpass';
          formant1.frequency.value = 730;
          formant1.Q.value = 5;
          
          formant2.type = 'bandpass';
          formant2.frequency.value = 1090;
          formant2.Q.value = 5;
          
          formant3.type = 'bandpass';
          formant3.frequency.value = 2440;
          formant3.Q.value = 5;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.1 / chord.length, this.ctx.currentTime + 0.5);
          gain.gain.linearRampToValueAtTime(0.08 / chord.length, this.ctx.currentTime + 3);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
          
          osc.connect(formant1);
          formant1.connect(formant2);
          formant2.connect(formant3);
          formant3.connect(gain);
          gain.connect(this.reverb);
          
          osc.start();
          osc.stop(this.ctx.currentTime + 6);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 6000);
        });
      }

      updateHarmony() {
        // Advanced circle of fifths progression
        if (this.evolutionStage === 'HEAVEN') {
          // Modulate to distant keys for modern harmony
          const progression = [0, 7, 3, 10, 6, 1, 9, 4]; // Complex movement
          this.currentFifthPosition = progression[Math.floor(this.step / 2) % progression.length];
        }
        
        // Update delay time based on harmony
        if (this.delay) {
          const delayRatio = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] / this.noteFreqs[0];
          this.delay.delayTime.setValueAtTime(0.125 / delayRatio, this.ctx.currentTime + 0.1);
        }
      }

      monitorTranscendence() {
        const check = () => {
          if (!this.active) return;
          
          const now = Date.now();
          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 1000;

          if (shouldTranscend && !this.transcendent) {
            this.enterTranscendence();
          } else if (!shouldTranscend && this.transcendent) {
            this.exitTranscendence();
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 1000) / 2000);
            this.deepenTranscendence();
          }

          setTimeout(check, 100);
        };
        check();
      }

      enterTranscendence() {
        this.transcendent = true;
        this.elements.substage.textContent = 'Entering void state...';
        document.body.style.background = 'radial-gradient(circle, #0a0a0a 0%, #000 100%)';
        
        // Slow down everything
        this.bpm *= 0.7;
        this.swing = 0.3;
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        document.body.style.background = 'black';
        this.updateUI();
      }

      deepenTranscendence() {
        // Add ethereal layers during stillness
        if (Math.random() < 0.02 * this.transcendentIntensity) {
          this.playCosmicDrone();
        }
        
        if (Math.random() < 0.01 * this.transcendentIntensity) {
          this.playVoidBell();
        }
      }

      playCosmicDrone() {
        if (this.oscillators.size > 25) return;
        
        const freq = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 0.125;
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.value = freq;
        osc2.frequency.value = freq * 1.001; // Beating
        
        filter.type = 'lowpass';
        filter.frequency.value = 200 + this.transcendentIntensity * 300;
        filter.Q.value = 10;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2 * this.transcendentIntensity, this.ctx.currentTime + 2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 12);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.reverb);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 12);
        osc2.stop(this.ctx.currentTime + 12);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => {
          this.oscillators.delete(osc1);
          this.oscillators.delete(osc2);
        }, 12000);
      }

      playVoidBell() {
        const freq = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 8;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity, this.ctx.currentTime + 0.1);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 8);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 8000);
      }

      updateUI() {
        let stageText = this.evolutionStage;
        let substageText = '';
        
        switch(this.evolutionStage) {
          case 'PRIMORDIAL':
            substageText = 'Waiting for first movement...';
            break;
          case 'TRIBAL':
            substageText = `Steps: ${this.totalSteps} • BPM: ${Math.round(this.bpm)} • Primal beats`;
            break;
          case 'ORCHESTRAL':
            substageText = `Steps: ${this.totalSteps} • BPM: ${Math.round(this.bpm)} • Complex harmonies`;
            break;
          case 'HEAVEN':
            substageText = `Steps: ${this.totalSteps} • BPM: ${Math.round(this.bpm)} • Transcendental synthesis`;
            break;
        }
        
        if (this.transcendent) {
          substageText += ' • VOID STATE';
        }
        
        this.elements.stage.textContent = stageText;
        this.elements.substage.textContent = substageText;
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.frameCount++;
          
          // Update orb position
          this.elements.orb.style.left = `${this.pos.x}%`;
          this.elements.orb.style.top = `${this.pos.y}%`;
          
          // Update UI periodically
          if (this.frameCount % 30 === 0) {
            this.updateUI();
          }
          
          // Dynamic background based on evolution
          if (this.frameCount % 60 === 0 && !this.transcendent) {
            let bgColor = 'black';
            if (this.evolutionStage === 'TRIBAL') {
              bgColor = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, #1a0f0f 0%, black 70%)`;
            } else if (this.evolutionStage === 'ORCHESTRAL') {
              bgColor = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, #0f1a1a 0%, black 70%)`;
            } else if (this.evolutionStage === 'HEAVEN') {
              bgColor = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, #1a0f1a 0%, #0a0a1a 50%, black 100%)`;
            }
            document.body.style.background = bgColor;
          }

          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    // Initialize the evolution
    const gump = new GUMP();
  </script>
</body>
</html>
