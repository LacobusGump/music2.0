<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Environmental Sampling EDM Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,20,20,0.1) 0%, transparent 70%);
            border: 3px solid rgba(255,20,20,0.4);
            color: #ff1414;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: samplePulse 2s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(255,20,20,0.8);
            background: radial-gradient(circle, rgba(255,20,20,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        .btn-text {
            font-size: 20px;
            margin-bottom: 8px;
        }

        .btn-subtext {
            font-size: 11px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
        }

        @keyframes samplePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255,20,20,0.3);
            }
            50% {
                transform: scale(1.06);
                box-shadow: 0 0 80px rgba(255,20,20,0.6);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff1414 0%, rgba(255,20,20,0.4) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 50px rgba(255,20,20,0.6);
            backdrop-filter: blur(8px);
            will-change: transform;
            z-index: 10;
        }

        .orb.pulse {
            animation: sampleBeat 0.15s ease-out;
        }

        @keyframes sampleBeat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.8); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.sampling {
            background: radial-gradient(circle, #ff6600 0%, rgba(255,102,0,0.5) 50%, transparent 80%);
            box-shadow: 0 0 70px rgba(255,102,0,0.8);
            animation: samplingActive 0.8s ease-in-out infinite;
        }

        .orb.chopping {
            background: radial-gradient(circle, #00ff88 0%, rgba(0,255,136,0.5) 50%, transparent 80%);
            box-shadow: 0 0 90px rgba(0,255,136,0.9);
            animation: choppingActive 0.4s ease-in-out infinite;
        }

        .orb.flipping {
            background: radial-gradient(circle, #8800ff 0%, rgba(136,0,255,0.5) 50%, transparent 80%);
            box-shadow: 0 0 120px rgba(136,0,255,1);
            animation: flippingActive 0.25s ease-in-out infinite;
        }

        .orb.dropping {
            background: radial-gradient(circle, #ffff00 0%, #ff0080 30%, #00ffff 60%, transparent 90%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 100px rgba(255,0,128,0.8));
            animation: droppingActive 0.15s ease-in-out infinite;
        }

        @keyframes samplingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.3) rotate(180deg); }
        }

        @keyframes choppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
        }

        @keyframes flippingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.7) rotate(360deg); }
        }

        @keyframes droppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            25% { transform: translate(-50%, -50%) scale(2.2); }
            50% { transform: translate(-50%, -50%) scale(1.6); }
            75% { transform: translate(-50%, -50%) scale(2.5); }
        }

        .hidden {
            display: none !important;
        }

        .sample-viz {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 280px;
            height: 100px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,20,20,0.3);
            border-radius: 12px;
            padding: 12px;
            font-size: 11px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .sample-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .sample-details {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .waveform {
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,20,20,0.2);
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #ff1414, #ff6600, #ffff00);
            transition: height 0.08s ease;
            border-radius: 1px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .control-section {
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 10px;
            color: #ff6600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .slider {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff1414, #ff6600);
            border-radius: 3px;
            transition: width 0.2s ease;
        }

        .slider-thumb {
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            transform: translateX(-50%);
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        .slider-thumb:hover {
            transform: translateX(-50%) scale(1.2);
            cursor: grabbing;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,20,20,0.6);
            animation: particleFloat 6s linear infinite;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-10vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .layer-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            z-index: 100;
        }

        .layer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            min-width: 140px;
        }

        .layer.active {
            background: rgba(255,20,20,0.2);
            border: 1px solid rgba(255,20,20,0.4);
            animation: layerPulse 0.3s ease;
        }

        @keyframes layerPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .layer-name {
            font-weight: bold;
            color: #ff6600;
        }

        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            max-width: 200px;
            z-index: 100;
        }

        .instruction-group {
            margin-bottom: 8px;
        }

        .instruction-title {
            color: #ff6600;
            font-weight: bold;
            margin-bottom: 4px;
        }

        kbd {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            margin-right: 4px;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            <div class="btn-text">START ENGINE</div>
            <div class="btn-subtext">SAMPLE THE WORLD<br>BUILD THE BEAT</div>
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
        
        <div id="sampleViz" class="sample-viz hidden">
            <div class="sample-info">
                <span id="sampleStatus">LISTENING...</span>
                <span id="sampleCount">0 SAMPLES</span>
            </div>
            <div class="sample-details">
                <span id="bpmDisplay">140 BPM</span>
                <span id="stageDisplay">LISTENING</span>
                <span id="motionDisplay">CALM</span>
            </div>
            <div class="waveform" id="waveform"></div>
        </div>

        <div id="controls" class="controls hidden">
            <div class="control-section">
                <div class="control-label">Sampling</div>
                <div class="control-row">
                    <span>Threshold</span>
                    <div class="slider" data-param="threshold">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Sensitivity</span>
                    <div class="slider" data-param="sensitivity">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
            <div class="control-section">
                <div class="control-label">Evolution</div>
                <div class="control-row">
                    <span>Chaos</span>
                    <div class="slider" data-param="chaos">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Speed</span>
                    <div class="slider" data-param="speed">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="layerStatus" class="layer-status hidden">
            <div style="font-weight: bold; margin-bottom: 8px; color: #ff6600;">SAMPLE LAYERS</div>
            <div class="layer" data-layer="kick">
                <span class="layer-name">KICK</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="snare">
                <span class="layer-name">SNARE</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="hats">
                <span class="layer-name">HATS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="bass">
                <span class="layer-name">BASS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="lead">
                <span class="layer-name">LEAD</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="fx">
                <span class="layer-name">FX</span>
                <span class="layer-count">0</span>
            </div>
        </div>

        <div id="instructions" class="instructions hidden">
            <div class="instruction-group">
                <div class="instruction-title">Controls</div>
                <div><kbd>SPACE</kbd> Sample</div>
                <div><kbd>C</kbd> Chop</div>
                <div><kbd>F</kbd> Flip</div>
                <div><kbd>P</kbd> Pitch</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Layers</div>
                <div><kbd>1-6</kbd> Trigger</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Motion</div>
                <div>Move device or mouse</div>
            </div>
        </div>
    </div>

    <script>
        class GUMPEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.active = false;
                this.masterGain = null;
                this.analyser = null;
                this.dataArray = null;

                // Microphone
                this.microphone = null;
                this.micAnalyser = null;
                this.micDataArray = null;

                // Sampling
                this.isRecording = false;
                this.recordingData = [];
                this.sampleLibrary = [];
                this.sampleThreshold = 0.1;
                this.samplingCooldown = 2000;
                this.lastSampleTime = 0;
                this.maxSampleLength = 3;

                // Sample layers
                this.sampleLayers = {
                    kick: { samples: [], gain: null },
                    snare: { samples: [], gain: null },
                    hats: { samples: [], gain: null },
                    bass: { samples: [], gain: null },
                    lead: { samples: [], gain: null },
                    fx: { samples: [], gain: null }
                };

                // Motion tracking
                this.motion = 0;
                this.intensity = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';

                // Music system
                this.bpm = 140;
                this.step = 0;
                this.beatCount = 0;
                this.stage = 'LISTENING';
                this.isPlaying = false;

                // Controls
                this.controls = {
                    threshold: 0.15,
                    sensitivity: 0.5,
                    chaos: 0.2,
                    speed: 0.5
                };

                // Effects
                this.reverb = null;
                this.delay = null;
                this.filter = null;

                this.elements = {};
                this.init();
            }

            init() {
                // Get DOM elements
                const elementIds = [
                    'startScreen', 'startBtn', 'evolutionSpace', 'orb', 'sampleViz',
                    'sampleStatus', 'sampleCount', 'bpmDisplay', 'stageDisplay', 
                    'motionDisplay', 'waveform', 'controls', 'layerStatus', 'instructions'
                ];
                
                elementIds.forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });

                // Setup event listeners
                this.elements.startBtn.addEventListener('click', () => this.start());
                this.setupControls();
                this.setupKeyboardControls();
                this.setupMotionTracking();
                this.createWaveformBars();

                console.log('🎵 GUMP ENGINE INITIALIZED');
            }

            setupControls() {
                const sliders = document.querySelectorAll('.slider');
                
                sliders.forEach(slider => {
                    const param = slider.dataset.param;
                    const fill = slider.querySelector('.slider-fill');
                    const thumb = slider.querySelector('.slider-thumb');
                    
                    // Set initial positions
                    const initialValue = this.controls[param] || 0.5;
                    const percentage = initialValue * 100;
                    fill.style.width = percentage + '%';
                    thumb.style.left = percentage + '%';
                    
                    // Mouse events
                    slider.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const rect = slider.getBoundingClientRect();
                        const updateSlider = (clientX) => {
                            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                            const percentage = (x / rect.width) * 100;
                            const value = x / rect.width;
                            
                            fill.style.width = percentage + '%';
                            thumb.style.left = percentage + '%';
                            this.controls[param] = value;
                            this.updateControlParameter(param, value);
                        };
                        
                        updateSlider(e.clientX);
                        
                        const handleMouseMove = (e) => updateSlider(e.clientX);
                        const handleMouseUp = () => {
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                        };
                        
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    });
                });
            }

            updateControlParameter(param, value) {
                switch(param) {
                    case 'threshold':
                        this.sampleThreshold = 0.05 + (value * 0.3);
                        break;
                    case 'sensitivity':
                        this.samplingCooldown = 500 + ((1 - value) * 3000);
                        break;
                    case 'chaos':
                        // Affects randomness in sample playback
                        break;
                    case 'speed':
                        this.bpm = 100 + (value * 100);
                        break;
                }
            }

            setupKeyboardControls() {
                const keyMap = {
                    ' ': () => this.triggerSample(),
                    'c': () => this.chopSample(),
                    'f': () => this.flipSample(),
                    'p': () => this.pitchSample(),
                    '1': () => this.triggerLayer('kick'),
                    '2': () => this.triggerLayer('snare'),
                    '3': () => this.triggerLayer('hats'),
                    '4': () => this.triggerLayer('bass'),
                    '5': () => this.triggerLayer('lead'),
                    '6': () => this.triggerLayer('fx')
                };

                document.addEventListener('keydown', (e) => {
                    if (!this.active) return;
                    
                    const handler = keyMap[e.key.toLowerCase()];
                    if (handler) {
                        e.preventDefault();
                        handler();
                    }
                });

                // Click to sample
                document.addEventListener('click', (e) => {
                    if (!this.active || e.target.closest('.controls, .layer-status, .instructions')) return;
                    this.triggerSample();
                });
            }

            setupMotionTracking() {
                // Device motion
                window.addEventListener('devicemotion', (e) => {
                    if (!this.active || !e.accelerationIncludingGravity) return;
                    
                    const acc = e.accelerationIncludingGravity;
                    const magnitude = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
                    this.updateMotion(magnitude * 0.1);
                });

                // Mouse movement fallback
                let lastMouse = { x: 0, y: 0, time: 0 };
                document.addEventListener('mousemove', (e) => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    if (lastMouse.time > 0) {
                        const dt = now - lastMouse.time;
                        const dx = newX - lastMouse.x;
                        const dy = newY - lastMouse.y;
                        const velocity = Math.sqrt(dx*dx + dy*dy) / Math.max(dt, 16) * 1000;
                        this.updateMotion(velocity * 0.01);
                    }
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    lastMouse = { x: newX, y: newY, time: now };
                });
            }

            updateMotion(newMotion) {
                this.motion = this.motion * 0.8 + newMotion * 0.2;
                
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 60) {
                    this.motionHistory.shift();
                }
                
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = avgMotion;
                
                // Determine motion pattern
                if (avgMotion > 3) this.motionPattern = 'chaotic';
                else if (avgMotion > 1.5) this.motionPattern = 'active';
                else if (avgMotion > 0.5) this.motionPattern = 'rhythmic';
                else this.motionPattern = 'calm';
                
                // Update stage based on motion and samples
                this.updateStage();
            }

            updateStage() {
                const sampleCount = this.sampleLibrary.length;
                
                if (sampleCount === 0) {
                    this.stage = 'LISTENING';
                } else if (sampleCount < 3) {
                    this.stage = 'SAMPLING';
                } else if (sampleCount < 8 && this.motionPattern !== 'calm') {
                    this.stage = 'CHOPPING';
                } else if (sampleCount < 15 && this.intensity > 1) {
                    this.stage = 'FLIPPING';
                } else if (sampleCount >= 15 || this.intensity > 2.5) {
                    this.stage = 'DROPPING';
                }
                
                this.updateOrbVisual();
            }

            updateOrbVisual() {
                const orb = this.elements.orb;
                orb.className = 'orb ' + this.stage.toLowerCase();
                
                // Update position
                orb.style.left = this.pos.x + '%';
                orb.style.top = this.pos.y + '%';
            }

            createWaveformBars() {
                const waveform = this.elements.waveform;
                const barCount = 80;
                
                for (let i = 0; i < barCount; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.left = (i * (100 / barCount)) + '%';
                    bar.style.width = (100 / barCount * 0.8) + '%';
                    bar.style.height = '2px';
                    waveform.appendChild(bar);
                }
            }

            async start() {
                try {
                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();

                    this.setupAudioChain();
                    this.setupMicrophone(stream);

                    // Show interface
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    this.elements.sampleViz.classList.remove('hidden');
                    this.elements.controls.classList.remove('hidden');
                    this.elements.layerStatus.classList.remove('hidden');
                    this.elements.instructions.classList.remove('hidden');

                    this.active = true;
                    this.motionHistory = new Array(60).fill(0.1);
                    
                    this.startSamplingLoop();
                    this.startSequencer();
                    this.startAnimationLoop();

                    console.log('🎵 GUMP ENGINE STARTED');
                    
                } catch (error) {
                    console.error('Failed to start engine:', error);
                    alert('Microphone access required!');
                }
            }

            setupAudioChain() {
                // Master chain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;

                // Main analyser
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 256;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                // Effects
                this.reverb = this.createReverb();
                this.delay = this.createDelay();
                this.filter = this.createFilter();

                // Sample layer gains
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const gain = this.ctx.createGain();
                    gain.gain.value = this.getLayerGain(layerName);
                    gain.connect(this.masterGain);
                    this.sampleLayers[layerName].gain = gain;
                });

                // Connect effects
                this.reverb.connect(this.masterGain);
                this.delay.connect(this.masterGain);

                // Final chain
                this.masterGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
            }

            getLayerGain(layerName) {
                const gains = {
                    kick: 1.2,
                    snare: 1.0,
                    hats: 0.8,
                    bass: 1.1,
                    lead: 0.9,
                    fx: 0.7
                };
                return gains[layerName] || 1.0;
            }

            createReverb() {
                const convolver = this.ctx.createConvolver();
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.3;
                    }
                }
                
                convolver.buffer = impulse;
                return convolver;
            }

            createDelay() {
                const delay = this.ctx.createDelay(1);
                const feedback = this.ctx.createGain();
                const mix = this.ctx.createGain();
                
                delay.delayTime.value = 0.25;
                feedback.gain.value = 0.3;
                mix.gain.value = 0.2;
                
                delay.connect(feedback);
                feedback.connect(delay);
                delay.connect(mix);
                
                return mix;
            }

            createFilter() {
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2000;
                filter.Q.value = 1;
                return filter;
            }

            setupMicrophone(stream) {
                this.microphone = this.ctx.createMediaStreamSource(stream);
                
                this.micAnalyser = this.ctx.createAnalyser();
                this.micAnalyser.fftSize = 2048;
                this.micAnalyser.smoothingTimeConstant = 0.3;
                this.micDataArray = new Uint8Array(this.micAnalyser.frequencyBinCount);
                
                this.microphone.connect(this.micAnalyser);
                // Don't connect to output to avoid feedback
            }

            startSamplingLoop() {
                const loop = () => {
                    if (!this.active) return;

                    this.micAnalyser.getByteFrequencyData(this.micDataArray);
                    this.updateVisualization();

                    // Check for sampling trigger
                    const avgLevel = this.micDataArray.reduce((sum, val) => sum + val) / this.micDataArray.length;
                    const normalizedLevel = avgLevel / 255;

                    const now = Date.now();
                    const canSample = now - this.lastSampleTime > this.samplingCooldown;
                    const shouldSample = normalizedLevel > this.sampleThreshold && canSample;

                    if (shouldSample && this.sampleLibrary.length < 25) {
                        this.startRecording();
                    }

                    if (this.isRecording) {
                        this.continueRecording();
                    }

                    requestAnimationFrame(loop);
                };
                loop();
            }

            updateVisualization() {
                // Update waveform bars
                const bars = this.elements.waveform.querySelectorAll('.waveform-bar');
                const dataStep = Math.floor(this.micDataArray.length / bars.length);
                
                bars.forEach((bar, i) => {
                    const dataIndex = i * dataStep;
                    const value = this.micDataArray[dataIndex] / 255;
                    const height = Math.max(2, value * 40);
                    bar.style.height = height + 'px';
                });

                // Update status displays
                this.elements.sampleStatus.textContent = this.isRecording ? 'RECORDING...' : this.stage;
                this.elements.sampleCount.textContent = `${this.sampleLibrary.length} SAMPLES`;
                this.elements.bpmDisplay.textContent = `${Math.round(this.bpm)} BPM`;
                this.elements.stageDisplay.textContent = this.stage;
                this.elements.motionDisplay.textContent = this.motionPattern.toUpperCase();

                // Update layer counts
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const count = this.sampleLayers[layerName].samples.length;
                    const layerEl = document.querySelector(`[data-layer="${layerName}"] .layer-count`);
                    if (layerEl) layerEl.textContent = count;
                });
            }

            startRecording() {
                console.log('🎤 RECORDING SAMPLE...');
                this.isRecording = true;
                this.recordingData = [];
                this.recordingStartTime = this.ctx.currentTime;
                this.lastSampleTime = Date.now();

                // Create script processor for recording
                this.processor = this.ctx.createScriptProcessor(4096, 1, 1);
                this.microphone.connect(this.processor);
                this.processor.connect(this.ctx.destination);

                this.processor.onaudioprocess = (e) => {
                    if (!this.isRecording) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    this.recordingData.push(...inputData);
                    
                    const duration = this.recordingData.length / this.ctx.sampleRate;
                    if (duration >= this.maxSampleLength) {
                        this.finishRecording();
                    }
                };

                this.updateOrbVisual();
            }

            continueRecording() {
                // Recording handled by processor
            }

            finishRecording() {
                if (!this.isRecording || this.recordingData.length === 0) return;

                console.log('✅ SAMPLE RECORDED');
                this.isRecording = false;

                // Clean up processor
                if (this.processor) {
                    this.microphone.disconnect(this.processor);
                    this.processor.disconnect();
                    this.processor = null;
                }

                // Create audio buffer
                const duration = this.recordingData.length / this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, this.recordingData.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordingData);

                // Analyze sample
                const analysis = this.analyzeSample(this.recordingData);
                
                // Create sample object
                const sample = {
                    id: Date.now(),
                    buffer: buffer,
                    duration: duration,
                    analysis: analysis,
                    timestamp: Date.now()
                };

                this.sampleLibrary.push(sample);
                this.categorizeSample(sample);
                this.updateStage();

                console.log(`📚 LIBRARY: ${this.sampleLibrary.length} samples`);
            }

            analyzeSample(audioData) {
                const rms = Math.sqrt(audioData.reduce((sum, val) => sum + val * val, 0) / audioData.length);
                const peak = Math.max(...audioData.map(Math.abs));
                const crest = peak / Math.max(rms, 0.001);

                // Simple frequency analysis
                const lowFreq = this.analyzeFrequencyBand(audioData, 0, 200);
                const midFreq = this.analyzeFrequencyBand(audioData, 200, 2000);
                const highFreq = this.analyzeFrequencyBand(audioData, 2000, 8000);

                return {
                    rms,
                    peak,
                    crest,
                    lowFreq,
                    midFreq,
                    highFreq,
                    energy: peak > 0.3 ? 'high' : rms > 0.1 ? 'medium' : 'low',
                    brightness: highFreq > midFreq ? 'bright' : 'dark'
                };
            }

            analyzeFrequencyBand(audioData, lowFreq, highFreq) {
                // Simplified frequency analysis
                const sampleRate = this.ctx.sampleRate;
                const nyquist = sampleRate / 2;
                const lowBin = Math.floor(lowFreq / nyquist * audioData.length);
                const highBin = Math.floor(highFreq / nyquist * audioData.length);
                
                let energy = 0;
                for (let i = lowBin; i < Math.min(highBin, audioData.length); i++) {
                    energy += audioData[i] * audioData[i];
                }
                
                return Math.sqrt(energy / Math.max(1, highBin - lowBin));
            }

            categorizeSample(sample) {
                const { analysis } = sample;
                let bestLayer = 'fx';
                let bestScore = 0;

                // Score each layer
                const layerScores = {
                    kick: this.scoreKick(analysis),
                    snare: this.scoreSnare(analysis),
                    hats: this.scoreHats(analysis),
                    bass: this.scoreBass(analysis),
                    lead: this.scoreLead(analysis),
                    fx: 0.1 // Base score for FX
                };

                Object.entries(layerScores).forEach(([layer, score]) => {
                    if (score > bestScore) {
                        bestScore = score;
                        bestLayer = layer;
                    }
                });

                this.sampleLayers[bestLayer].samples.push(sample);
                console.log(`🎯 CATEGORIZED: ${bestLayer.toUpperCase()} (${(bestScore * 100).toFixed(0)}%)`);
            }

            scoreKick(analysis) {
                let score = 0;
                if (analysis.energy === 'high' && analysis.peak > 0.4) score += 0.4;
                if (analysis.lowFreq > analysis.midFreq) score += 0.3;
                if (analysis.crest > 3) score += 0.2;
                return Math.min(1, score);
            }

            scoreSnare(analysis) {
                let score = 0;
                if (analysis.midFreq > analysis.lowFreq && analysis.midFreq > analysis.highFreq) score += 0.4;
                if (analysis.brightness === 'bright') score += 0.2;
                if (analysis.crest > 2 && analysis.crest < 8) score += 0.3;
                return Math.min(1, score);
            }

            scoreHats(analysis) {
                let score = 0;
                if (analysis.brightness === 'bright') score += 0.4;
                if (analysis.highFreq > analysis.midFreq) score += 0.3;
                if (analysis.peak < 0.3) score += 0.2;
                return Math.min(1, score);
            }

            scoreBass(analysis) {
                let score = 0;
                if (analysis.lowFreq > analysis.midFreq * 1.5) score += 0.5;
                if (analysis.energy !== 'low') score += 0.2;
                if (analysis.brightness === 'dark') score += 0.2;
                return Math.min(1, score);
            }

            scoreLead(analysis) {
                let score = 0;
                if (analysis.midFreq > 0.1) score += 0.3;
                if (analysis.energy === 'medium') score += 0.2;
                if (analysis.crest > 1 && analysis.crest < 5) score += 0.3;
                return Math.min(1, score);
            }

            startSequencer() {
                if (this.isPlaying) return;
                this.isPlaying = true;

                const tick = () => {
                    if (!this.active || !this.isPlaying) return;

                    this.playStep();
                    this.step = (this.step + 1) % 32;
                    this.beatCount++;

                    const interval = (60 / this.bpm) * 250; // 16th notes
                    setTimeout(tick, interval);
                };

                tick();
            }

            playStep() {
                // Beat pulse on kick
                if (this.step % 4 === 0) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }

                // Play patterns based on stage
                switch (this.stage) {
                    case 'SAMPLING':
                        this.playSamplingPattern();
                        break;
                    case 'CHOPPING':
                        this.playChoppingPattern();
                        break;
                    case 'FLIPPING':
                        this.playFlippingPattern();
                        break;
                    case 'DROPPING':
                        this.playDroppingPattern();
                        break;
                }
            }

            playSamplingPattern() {
                // Simple kick pattern
                if (this.step % 4 === 0 && this.sampleLayers.kick.samples.length > 0) {
                    this.playLayerSample('kick');
                }
            }

            playChoppingPattern() {
                // Kick and snare
                if (this.step % 4 === 0 && this.sampleLayers.kick.samples.length > 0) {
                    this.playLayerSample('kick');
                }
                if (this.step % 8 === 4 && this.sampleLayers.snare.samples.length > 0) {
                    this.playLayerSample('snare');
                }
                // Occasional hats
                if (this.step % 2 === 0 && Math.random() < 0.3 && this.sampleLayers.hats.samples.length > 0) {
                    this.playLayerSample('hats');
                }
            }

            playFlippingPattern() {
                this.playChoppingPattern();
                
                // Add bass
                if (this.step % 4 === 0 && this.sampleLayers.bass.samples.length > 0) {
                    this.playLayerSample('bass');
                }
                // Lead melody
                if (this.step % 16 === 0 && this.sampleLayers.lead.samples.length > 0) {
                    this.playLayerSample('lead');
                }
            }

            playDroppingPattern() {
                this.playFlippingPattern();
                
                // Chaos mode - random FX
                if (Math.random() < 0.1 && this.sampleLayers.fx.samples.length > 0) {
                    this.playLayerSample('fx');
                }
                // Double kick
                if (this.step % 8 === 2 && Math.random() < 0.5 && this.sampleLayers.kick.samples.length > 0) {
                    this.playLayerSample('kick');
                }
            }

            playLayerSample(layerName) {
                const layer = this.sampleLayers[layerName];
                if (!layer || layer.samples.length === 0) return;

                const sample = layer.samples[Math.floor(Math.random() * layer.samples.length)];
                this.playSample(sample, layerName);
                
                // Visual feedback
                const layerEl = document.querySelector(`[data-layer="${layerName}"]`);
                if (layerEl) {
                    layerEl.classList.add('active');
                    setTimeout(() => layerEl.classList.remove('active'), 200);
                }
            }

            playSample(sample, layerName) {
                if (!sample || !this.sampleLayers[layerName]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                gain.gain.value = 0.8;

                source.connect(gain);
                gain.connect(this.sampleLayers[layerName].gain);

                source.start();
                source.stop(this.ctx.currentTime + sample.duration);
            }

            // Manual trigger methods
            triggerSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                this.playSample(sample, 'fx');
                this.createParticles(5, '#ff1414');
                console.log('🎵 MANUAL TRIGGER');
            }

            chopSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                this.playSampleChopped(sample, 'lead');
                this.createParticles(8, '#00ff88');
                console.log('✂️ CHOP SAMPLE');
            }

            flipSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                this.playSampleReversed(sample, 'fx');
                this.createParticles(10, '#8800ff');
                console.log('🔄 FLIP SAMPLE');
            }

            pitchSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                const pitchShift = [-12, -7, -5, 0, 3, 5, 7, 12][Math.floor(Math.random() * 8)];
                this.playSamplePitched(sample, pitchShift, 'lead');
                this.createParticles(12, '#ffff00');
                console.log(`🎵 PITCH: ${pitchShift > 0 ? '+' : ''}${pitchShift}`);
            }

            triggerLayer(layerName) {
                this.playLayerSample(layerName);
                this.createParticles(6, this.getLayerColor(layerName));
            }

            getLayerColor(layerName) {
                const colors = {
                    kick: '#ff0000',
                    snare: '#ff8800',
                    hats: '#ffff00',
                    bass: '#8800ff',
                    lead: '#00ff88',
                    fx: '#00ffff'
                };
                return colors[layerName] || '#ffffff';
            }

            playSampleChopped(sample, layerName) {
                if (!sample || !this.sampleLayers[layerName]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                gain.gain.value = 0.7;

                // Chop to quarter of original length
                const chopDuration = Math.min(sample.duration * 0.25, 0.5);

                source.connect(gain);
                gain.connect(this.sampleLayers[layerName].gain);

                source.start();
                source.stop(this.ctx.currentTime + chopDuration);
            }

            playSampleReversed(sample, layerName) {
                if (!sample || !this.sampleLayers[layerName]) return;

                // Create reversed buffer
                const reversedBuffer = this.ctx.createBuffer(1, sample.buffer.length, sample.buffer.sampleRate);
                const originalData = sample.buffer.getChannelData(0);
                const reversedData = reversedBuffer.getChannelData(0);

                for (let i = 0; i < originalData.length; i++) {
                    reversedData[i] = originalData[originalData.length - 1 - i];
                }

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = reversedBuffer;
                gain.gain.value = 0.6;

                source.connect(gain);
                gain.connect(this.sampleLayers[layerName].gain);

                source.start();
                source.stop(this.ctx.currentTime + sample.duration);
            }

            playSamplePitched(sample, semitones, layerName) {
                if (!sample || !this.sampleLayers[layerName]) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                source.playbackRate.value = Math.pow(2, semitones / 12);
                gain.gain.value = 0.7;

                source.connect(gain);
                gain.connect(this.sampleLayers[layerName].gain);

                source.start();
                source.stop(this.ctx.currentTime + sample.duration / source.playbackRate.value);
            }

            createParticles(count, color) {
                const container = document.querySelector('.particles') || document.createElement('div');
                if (!container.parentNode) {
                    container.className = 'particles';
                    document.body.appendChild(container);
                }

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = (this.pos.x + (Math.random() - 0.5) * 10) + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = (Math.random() * 0.5) + 's';
                    particle.style.animationDuration = (3 + Math.random() * 3) + 's';
                    
                    container.appendChild(particle);
                    
                    setTimeout(() => {
                        if (particle.parentNode) {
                            particle.parentNode.removeChild(particle);
                        }
                    }, 6000);
                }
            }

            startAnimationLoop() {
                const loop = () => {
                    if (!this.active) return;

                    // Update orb position
                    this.updateOrbVisual();

                    // Update background based on stage and motion
                    this.updateBackground();

                    // Get audio data for visual effects
                    if (this.analyser) {
                        this.analyser.getByteFrequencyData(this.dataArray);
                    }

                    requestAnimationFrame(loop);
                };
                loop();
            }

            updateBackground() {
                const intensity = Math.min(this.intensity / 3, 1);
                const sampleIntensity = Math.min(this.sampleLibrary.length / 20, 1);

                let background;
                switch (this.stage) {
                    case 'LISTENING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(255,20,20,${0.1 + intensity * 0.2}) 20%, 
                                    #000000 60%)`;
                        break;
                    case 'SAMPLING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(255,102,0,${0.2 + intensity * 0.3}) 15%, 
                                    rgba(255,20,20,${0.1 + sampleIntensity * 0.2}) 35%, 
                                    #000000 70%)`;
                        break;
                    case 'CHOPPING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(0,255,136,${0.3 + intensity * 0.4}) 12%, 
                                    rgba(255,102,0,${0.15 + sampleIntensity * 0.25}) 30%, 
                                    #000000 60%)`;
                        break;
                    case 'FLIPPING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(136,0,255,${0.4 + intensity * 0.4}) 10%, 
                                    rgba(0,255,136,${0.2 + sampleIntensity * 0.3}) 25%, 
                                    #000000 50%)`;
                        break;
                    case 'DROPPING':
                        const hue = (Date.now() / 100) % 360;
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    hsl(${hue}, 80%, ${60 + intensity * 30}%) 8%, 
                                    hsl(${(hue + 120) % 360}, 70%, ${40 + sampleIntensity * 30}%) 20%, 
                                    hsl(${(hue + 240) % 360}, 60%, 20%) 40%, 
                                    #000000 70%)`;
                        break;
                    default:
                        background = '#000000';
                }

                document.body.style.background = background;
            }
        }

        // Initialize the engine
        const engine = new GUMPEngine();

        // Error handling
        window.addEventListener('error', (e) => {
            console.error('GUMP Engine Error:', e.error);
        });

        window.addEventListener('unhandledrejection', (e) => {
            console.error('GUMP Promise Rejection:', e.reason);
        });

        console.log('🎵 GUMP ENGINE LOADED - Ready to sample the world!');
    </script>
</body>
</html>
