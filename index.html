<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<title>Spatial AI Music Layer</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
}

body {
  background: #000;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'SF Mono', monospace;
  overflow: hidden;
  height: 100vh;
  width: 100vw;
  position: fixed;
  touch-action: none;
}

/* Spatial Grid Overlay */
#spatialGrid {
  position: fixed;
  inset: 0;
  pointer-events: none;
  background: 
    repeating-linear-gradient(0deg, transparent, transparent 49px, rgba(0,255,255,0.1) 49px, rgba(0,255,255,0.1) 50px),
    repeating-linear-gradient(90deg, transparent, transparent 49px, rgba(0,255,255,0.1) 49px, rgba(0,255,255,0.1) 50px);
  opacity: 0.3;
}

/* Audio Zones */
.audio-zone {
  position: absolute;
  border: 2px solid rgba(0,255,255,0.5);
  border-radius: 50%;
  pointer-events: none;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  font-weight: bold;
  text-shadow: 0 0 10px #000;
}

.audio-zone.active {
  border-color: #0ff;
  box-shadow: 0 0 30px rgba(0,255,255,0.8), inset 0 0 30px rgba(0,255,255,0.3);
  animation: pulse-zone 1s ease-in-out infinite;
}

@keyframes pulse-zone {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

/* User Position Indicator */
#userPosition {
  position: absolute;
  width: 30px;
  height: 30px;
  background: radial-gradient(circle, #f0f, #f0f 40%, transparent 70%);
  border: 2px solid #fff;
  border-radius: 50%;
  transform: translate(-50%, -50%);
  box-shadow: 0 0 20px #f0f;
  z-index: 100;
  pointer-events: none;
  transition: all 0.1s ease;
}

#userPosition::before {
  content: '';
  position: absolute;
  inset: -10px;
  border: 1px solid rgba(255,0,255,0.3);
  border-radius: 50%;
  animation: ripple 2s ease-out infinite;
}

@keyframes ripple {
  0% { transform: scale(0.8); opacity: 1; }
  100% { transform: scale(2); opacity: 0; }
}

/* Start Screen */
#startScreen {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center, #001a1a 0%, #000 100%);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  transition: opacity 0.5s ease;
  padding: 20px;
}

#startScreen.hidden {
  opacity: 0;
  pointer-events: none;
}

.start-title {
  font-size: 32px;
  font-weight: bold;
  margin-bottom: 10px;
  background: linear-gradient(90deg, #0ff, #f0f, #0ff);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: gradient-shift 3s ease infinite;
}

@keyframes gradient-shift {
  0%, 100% { filter: hue-rotate(0deg); }
  50% { filter: hue-rotate(30deg); }
}

.start-subtitle {
  font-size: 14px;
  opacity: 0.7;
  text-align: center;
  margin-bottom: 40px;
  max-width: 300px;
}

#startButton {
  padding: 20px 40px;
  font-size: 18px;
  font-weight: bold;
  background: linear-gradient(135deg, #0ff, #f0f);
  border: none;
  border-radius: 50px;
  color: #000;
  cursor: pointer;
  box-shadow: 0 0 30px rgba(0,255,255,0.5);
  transition: all 0.3s ease;
  font-family: inherit;
}

#startButton:active {
  transform: scale(0.95);
  box-shadow: 0 0 50px rgba(0,255,255,0.8);
}

.permission-status {
  margin-top: 30px;
  font-size: 12px;
  opacity: 0.6;
  text-align: center;
}

.permission-item {
  margin: 5px 0;
}

.permission-item.granted {
  color: #0f0;
}

.permission-item.denied {
  color: #f00;
}

/* Status Bar */
#statusBar {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  padding: 15px;
  background: rgba(0,0,0,0.8);
  backdrop-filter: blur(10px);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 12px;
  z-index: 50;
}

.status-group {
  display: flex;
  flex-direction: column;
  gap: 3px;
}

.status-label {
  opacity: 0.6;
  font-size: 10px;
}

.status-value {
  font-weight: bold;
  color: #0ff;
}

/* Music Info Display */
#musicInfo {
  position: fixed;
  bottom: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.9);
  backdrop-filter: blur(10px);
  padding: 20px;
  border-radius: 15px;
  border: 1px solid rgba(0,255,255,0.3);
  max-width: calc(100% - 40px);
  text-align: center;
  opacity: 0;
  transition: opacity 0.3s ease;
}

#musicInfo.visible {
  opacity: 1;
}

.track-name {
  font-size: 16px;
  font-weight: bold;
  margin-bottom: 5px;
  color: #0ff;
}

.track-details {
  font-size: 12px;
  opacity: 0.7;
}

/* Control Panel */
#controlPanel {
  position: fixed;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.9);
  backdrop-filter: blur(10px);
  padding: 15px;
  border-radius: 20px;
  border: 1px solid rgba(0,255,255,0.3);
  display: flex;
  gap: 15px;
  align-items: center;
}

.control-button {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: 2px solid #0ff;
  background: rgba(0,255,255,0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  cursor: pointer;
  transition: all 0.2s ease;
  user-select: none;
}

.control-button:active {
  transform: scale(0.9);
  background: rgba(0,255,255,0.3);
  box-shadow: 0 0 20px rgba(0,255,255,0.5);
}

.control-button.active {
  background: rgba(0,255,255,0.5);
  box-shadow: 0 0 20px rgba(0,255,255,0.8);
}

/* AI Status Indicator */
#aiStatus {
  position: fixed;
  top: 80px;
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.9);
  backdrop-filter: blur(10px);
  padding: 10px 20px;
  border-radius: 20px;
  border: 1px solid rgba(255,0,255,0.5);
  font-size: 12px;
  display: flex;
  align-items: center;
  gap: 10px;
  opacity: 0;
  transition: opacity 0.3s ease;
}

#aiStatus.visible {
  opacity: 1;
}

.ai-indicator {
  width: 8px;
  height: 8px;
  background: #f0f;
  border-radius: 50%;
  animation: blink 1s ease-in-out infinite;
}

@keyframes blink {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}

/* Debug Panel */
#debugPanel {
  position: fixed;
  bottom: 200px;
  right: 10px;
  background: rgba(0,0,0,0.9);
  backdrop-filter: blur(10px);
  padding: 10px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.2);
  font-size: 10px;
  font-family: monospace;
  max-width: 200px;
  opacity: 0.7;
}

.debug-line {
  margin: 2px 0;
  color: #0f0;
}

/* Loading Animation */
.loading-spinner {
  width: 40px;
  height: 40px;
  border: 3px solid rgba(0,255,255,0.3);
  border-top-color: #0ff;
  border-radius: 50%;
  animation: spin 1s linear infinite;
  margin: 20px auto;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Error Message */
.error-message {
  background: rgba(255,0,0,0.2);
  border: 1px solid #f00;
  padding: 15px;
  border-radius: 10px;
  margin-top: 20px;
  font-size: 12px;
  max-width: 300px;
}
</style>
</head>
<body>
<div id="spatialGrid"></div>
<div id="userPosition"></div>
<div id="audioZonesContainer"></div>

<div id="startScreen">
  <div class="start-title">SPATIAL MUSIC</div>
  <div class="start-subtitle">Move through space to discover AI-generated music layers</div>
  <button id="startButton">TAP TO ENTER</button>
  <div class="permission-status">
    <div class="permission-item" id="motionStatus">â—¯ Motion Sensors</div>
    <div class="permission-item" id="audioStatus">â—¯ Audio Context</div>
    <div class="permission-item" id="orientationStatus">â—¯ Orientation</div>
  </div>
  <div class="error-message" id="errorMessage" style="display: none;"></div>
</div>

<div id="statusBar">
  <div class="status-group">
    <div class="status-label">POSITION</div>
    <div class="status-value" id="positionDisplay">0, 0</div>
  </div>
  <div class="status-group">
    <div class="status-label">ZONES</div>
    <div class="status-value" id="zonesDisplay">0/0</div>
  </div>
  <div class="status-group">
    <div class="status-label">ENERGY</div>
    <div class="status-value" id="energyDisplay">0%</div>
  </div>
</div>

<div id="aiStatus">
  <div class="ai-indicator"></div>
  <span id="aiStatusText">AI Listening...</span>
</div>

<div id="musicInfo">
  <div class="track-name" id="trackName">Ambient Layer</div>
  <div class="track-details" id="trackDetails">Move to activate zones</div>
</div>

<div id="controlPanel">
  <div class="control-button" id="calibrateBtn" title="Calibrate">âŠ™</div>
  <div class="control-button" id="toggleAudioBtn" title="Audio">â™«</div>
  <div class="control-button" id="resetBtn" title="Reset">â†»</div>
</div>

<div id="debugPanel" style="display: none;">
  <div class="debug-line" id="debugAccel">Accel: 0, 0, 0</div>
  <div class="debug-line" id="debugGyro">Gyro: 0, 0, 0</div>
  <div class="debug-line" id="debugOrient">Orient: 0Â°</div>
  <div class="debug-line" id="debugZones">Active: 0</div>
</div>

<script>
'use strict';

class SpatialMusicLayer {
  constructor() {
    this.audioContext = null;
    this.isActive = false;
    
    // User position (virtual coordinates)
    this.position = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
    this.velocity = { x: 0, y: 0 };
    
    // Motion data
    this.acceleration = { x: 0, y: 0, z: 0 };
    this.gyro = { alpha: 0, beta: 0, gamma: 0 };
    this.orientation = 0;
    this.calibrationOffset = { x: 0, y: 0 };
    
    // Audio zones
    this.zones = [];
    this.activeZones = new Set();
    
    // Oscillators for music generation
    this.oscillators = new Map();
    this.gains = new Map();
    
    // Permission status
    this.permissions = {
      motion: false,
      audio: false,
      orientation: false
    };
    
    // UI elements
    this.ui = {
      startScreen: document.getElementById('startScreen'),
      startButton: document.getElementById('startButton'),
      userPosition: document.getElementById('userPosition'),
      zonesContainer: document.getElementById('audioZonesContainer'),
      positionDisplay: document.getElementById('positionDisplay'),
      zonesDisplay: document.getElementById('zonesDisplay'),
      energyDisplay: document.getElementById('energyDisplay'),
      musicInfo: document.getElementById('musicInfo'),
      trackName: document.getElementById('trackName'),
      trackDetails: document.getElementById('trackDetails'),
      aiStatus: document.getElementById('aiStatus'),
      aiStatusText: document.getElementById('aiStatusText'),
      motionStatus: document.getElementById('motionStatus'),
      audioStatus: document.getElementById('audioStatus'),
      orientationStatus: document.getElementById('orientationStatus'),
      errorMessage: document.getElementById('errorMessage'),
      calibrateBtn: document.getElementById('calibrateBtn'),
      toggleAudioBtn: document.getElementById('toggleAudioBtn'),
      resetBtn: document.getElementById('resetBtn'),
      debugPanel: document.getElementById('debugPanel'),
      debugAccel: document.getElementById('debugAccel'),
      debugGyro: document.getElementById('debugGyro'),
      debugOrient: document.getElementById('debugOrient'),
      debugZones: document.getElementById('debugZones')
    };
    
    this.setupEventListeners();
  }
  
  setupEventListeners() {
    this.ui.startButton.addEventListener('click', () => this.initialize());
    this.ui.calibrateBtn.addEventListener('click', () => this.calibrate());
    this.ui.toggleAudioBtn.addEventListener('click', () => this.toggleAudio());
    this.ui.resetBtn.addEventListener('click', () => this.reset());
    
    // Enable debug panel with long press
    let longPressTimer;
    this.ui.statusBar = document.getElementById('statusBar');
    this.ui.statusBar.addEventListener('touchstart', () => {
      longPressTimer = setTimeout(() => {
        this.ui.debugPanel.style.display = 
          this.ui.debugPanel.style.display === 'none' ? 'block' : 'none';
      }, 2000);
    });
    this.ui.statusBar.addEventListener('touchend', () => {
      clearTimeout(longPressTimer);
    });
  }
  
  async initialize() {
    this.ui.startButton.disabled = true;
    this.ui.startButton.textContent = 'INITIALIZING...';
    
    try {
      // Request permissions in correct order
      await this.requestPermissions();
      
      // Initialize audio
      await this.initializeAudio();
      
      // Setup motion tracking
      this.setupMotionTracking();
      
      // Create audio zones
      this.createAudioZones();
      
      // Start the experience
      this.start();
      
      // Hide start screen
      setTimeout(() => {
        this.ui.startScreen.classList.add('hidden');
      }, 500);
      
    } catch (error) {
      console.error('Initialization failed:', error);
      this.showError(error.message);
      this.ui.startButton.disabled = false;
      this.ui.startButton.textContent = 'TRY AGAIN';
    }
  }
  
  async requestPermissions() {
    // 1. Request DeviceMotion (iOS 13+)
    if (typeof DeviceMotionEvent !== 'undefined' && 
        typeof DeviceMotionEvent.requestPermission === 'function') {
      try {
        const motionPermission = await DeviceMotionEvent.requestPermission();
        this.permissions.motion = motionPermission === 'granted';
        this.updatePermissionStatus('motion', this.permissions.motion);
      } catch (error) {
        console.warn('Motion permission error:', error);
        this.permissions.motion = false;
      }
    } else {
      // Android or older iOS - assume granted
      this.permissions.motion = true;
      this.updatePermissionStatus('motion', true);
    }
    
    // 2. Request DeviceOrientation (iOS 13+)
    if (typeof DeviceOrientationEvent !== 'undefined' && 
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      try {
        const orientPermission = await DeviceOrientationEvent.requestPermission();
        this.permissions.orientation = orientPermission === 'granted';
        this.updatePermissionStatus('orientation', this.permissions.orientation);
      } catch (error) {
        console.warn('Orientation permission error:', error);
        this.permissions.orientation = false;
      }
    } else {
      this.permissions.orientation = true;
      this.updatePermissionStatus('orientation', true);
    }
    
    // Validate at least motion works
    if (!this.permissions.motion) {
      throw new Error('Motion sensors required. Please enable in Settings.');
    }
  }
  
  updatePermissionStatus(type, granted) {
    const statusElement = this.ui[`${type}Status`];
    if (statusElement) {
      statusElement.textContent = granted ? 'âœ“ ' : 'âœ— ';
      statusElement.textContent += type.charAt(0).toUpperCase() + type.slice(1);
      statusElement.className = 'permission-item ' + (granted ? 'granted' : 'denied');
    }
  }
  
  async initializeAudio() {
    try {
      // Create audio context (must be in user gesture)
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      
      // Create master gain
      this.masterGain = this.audioContext.createGain();
      this.masterGain.gain.value = 0.3;
      this.masterGain.connect(this.audioContext.destination);
      
      // Resume context
      if (this.audioContext.state === 'suspended') {
        await this.audioContext.resume();
      }
      
      this.permissions.audio = true;
      this.updatePermissionStatus('audio', true);
      
      console.log('Audio initialized:', this.audioContext.state);
      
    } catch (error) {
      console.error('Audio initialization failed:', error);
      this.permissions.audio = false;
      this.updatePermissionStatus('audio', false);
      throw new Error('Audio initialization failed');
    }
  }
  
  setupMotionTracking() {
    // DeviceMotion for acceleration
    window.addEventListener('devicemotion', (event) => {
      if (event.accelerationIncludingGravity) {
        this.acceleration.x = event.accelerationIncludingGravity.x || 0;
        this.acceleration.y = event.accelerationIncludingGravity.y || 0;
        this.acceleration.z = event.accelerationIncludingGravity.z || 0;
        
        this.updateDebug();
      }
    });
    
    // DeviceOrientation for direction
    window.addEventListener('deviceorientation', (event) => {
      this.gyro.alpha = event.alpha || 0;
      this.gyro.beta = event.beta || 0;
      this.gyro.gamma = event.gamma || 0;
      
      // Use alpha for compass direction
      this.orientation = this.gyro.alpha;
      
      this.updateDebug();
    });
    
    console.log('Motion tracking setup complete');
  }
  
  createAudioZones() {
    const width = window.innerWidth;
    const height = window.innerHeight;
    
    // Create zones with different musical characteristics
    const zoneConfigs = [
      { x: width * 0.2, y: height * 0.3, size: 120, note: 'C4', color: '#0ff', name: 'Cyan Zone' },
      { x: width * 0.8, y: height * 0.3, size: 100, note: 'E4', color: '#f0f', name: 'Magenta Zone' },
      { x: width * 0.5, y: height * 0.6, size: 140, note: 'G4', color: '#0f0', name: 'Green Zone' },
      { x: width * 0.3, y: height * 0.7, size: 90, note: 'A4', color: '#ff0', name: 'Yellow Zone' },
      { x: width * 0.7, y: height * 0.7, size: 110, note: 'D4', color: '#f80', name: 'Orange Zone' }
    ];
    
    zoneConfigs.forEach((config, i) => {
      const zone = {
        id: i,
        x: config.x,
        y: config.y,
        size: config.size,
        note: config.note,
        color: config.color,
        name: config.name,
        element: null,
        oscillator: null,
        gain: null
      };
      
      // Create visual element
      zone.element = document.createElement('div');
      zone.element.className = 'audio-zone';
      zone.element.style.left = (zone.x - zone.size / 2) + 'px';
      zone.element.style.top = (zone.y - zone.size / 2) + 'px';
      zone.element.style.width = zone.size + 'px';
      zone.element.style.height = zone.size + 'px';
      zone.element.style.borderColor = zone.color;
      zone.element.textContent = zone.name;
      
      this.ui.zonesContainer.appendChild(zone.element);
      
      // Create audio for zone
      this.createZoneAudio(zone);
      
      this.zones.push(zone);
    });
    
    console.log('Created', this.zones.length, 'audio zones');
  }
  
  createZoneAudio(zone) {
    // Create oscillator
    const osc = this.audioContext.createOscillator();
    osc.type = 'sine';
    osc.frequency.value = this.noteToFrequency(zone.note);
    
    // Create gain for this zone
    const gain = this.audioContext.createGain();
    gain.gain.value = 0;
    
    // Create filter for character
    const filter = this.audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 2000;
    filter.Q.value = 1;
    
    // Connect: oscillator -> filter -> gain -> master
    osc.connect(filter);
    filter.connect(gain);
    gain.connect(this.masterGain);
    
    // Start oscillator
    osc.start();
    
    zone.oscillator = osc;
    zone.gain = gain;
    zone.filter = filter;
  }
  
  noteToFrequency(note) {
    const notes = {
      'C4': 261.63,
      'D4': 293.66,
      'E4': 329.63,
      'F4': 349.23,
      'G4': 392.00,
      'A4': 440.00,
      'B4': 493.88
    };
    return notes[note] || 440;
  }
  
  start() {
    this.isActive = true;
    this.updateLoop();
    this.audioLoop();
    
    // Show UI elements
    this.ui.musicInfo.classList.add('visible');
    this.ui.aiStatus.classList.add('visible');
    
    console.log('Spatial Music Layer started');
  }
  
  updateLoop() {
    if (!this.isActive) return;
    
    // Update position based on motion
    this.updatePosition();
    
    // Check zone proximity
    this.checkZoneProximity();
    
    // Update displays
    this.updateUI();
    
    requestAnimationFrame(() => this.updateLoop());
  }
  
  audioLoop() {
    if (!this.isActive) return;
    
    // Update audio based on movement
    this.updateAudioParameters();
    
    setTimeout(() => this.audioLoop(), 100);
  }
  
  updatePosition() {
    // Convert acceleration to velocity (simplified physics)
    const sensitivity = 5;
    const damping = 0.95;
    
    // Remove calibration offset and apply sensitivity
    const adjustedX = (this.acceleration.x - this.calibrationOffset.x) * sensitivity;
    const adjustedY = (this.acceleration.y - this.calibrationOffset.y) * sensitivity;
    
    // Update velocity
    this.velocity.x += adjustedX;
    this.velocity.y += adjustedY;
    
    // Apply damping
    this.velocity.x *= damping;
    this.velocity.y *= damping;
    
    // Update position
    this.position.x += this.velocity.x;
    this.position.y += this.velocity.y;
    
    // Bounce off edges
    const margin = 50;
    if (this.position.x < margin) {
      this.position.x = margin;
      this.velocity.x *= -0.5;
    }
    if (this.position.x > window.innerWidth - margin) {
      this.position.x = window.innerWidth - margin;
      this.velocity.x *= -0.5;
    }
    if (this.position.y < margin) {
      this.position.y = margin;
      this.velocity.y *= -0.5;
    }
    if (this.position.y > window.innerHeight - margin) {
      this.position.y = window.innerHeight - margin;
      this.velocity.y *= -0.5;
    }
    
    // Update user position indicator
    this.ui.userPosition.style.left = this.position.x + 'px';
    this.ui.userPosition.style.top = this.position.y + 'px';
  }
  
  checkZoneProximity() {
    let activeCount = 0;
    
    this.zones.forEach(zone => {
      const dx = this.position.x - zone.x;
      const dy = this.position.y - zone.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const threshold = zone.size / 2;
      
      const isNear = distance < threshold;
      
      if (isNear && !this.activeZones.has(zone.id)) {
        // Enter zone
        this.activateZone(zone);
        this.activeZones.add(zone.id);
        activeCount++;
      } else if (!isNear && this.activeZones.has(zone.id)) {
        // Leave zone
        this.deactivateZone(zone);
        this.activeZones.delete(zone.id);
      } else if (isNear) {
        // Update existing zone
        const proximity = 1 - (distance / threshold);
        this.updateZoneIntensity(zone, proximity);
        activeCount++;
      }
    });
    
    this.ui.zonesDisplay.textContent = `${activeCount}/${this.zones.length}`;
  }
  
  activateZone(zone) {
    console.log('Activated:', zone.name);
    
    zone.element.classList.add('active');
    
    // Fade in audio
    if (zone.gain) {
      zone.gain.gain.setTargetAtTime(0.3, this.audioContext.currentTime, 0.3);
    }
    
    // Update music info
    this.ui.trackName.textContent = zone.name;
    this.ui.trackDetails.textContent = `Playing ${zone.note}`;
    
    // AI status
    this.ui.aiStatusText.textContent = `Analyzing ${zone.name}...`;
  }
  
  deactivateZone(zone) {
    console.log('Deactivated:', zone.name);
    
    zone.element.classList.remove('active');
    
    // Fade out audio
    if (zone.gain) {
      zone.gain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.3);
    }
  }
  
  updateZoneIntensity(zone, proximity) {
    // Update audio gain based on proximity
    if (zone.gain) {
      const targetGain = proximity * 0.4;
      zone.gain.gain.setTargetAtTime(targetGain, this.audioContext.currentTime, 0.1);
    }
    
    // Update filter based on proximity
    if (zone.filter) {
      const targetFreq = 500 + proximity * 3000;
      zone.filter.frequency.setTargetAtTime(targetFreq, this.audioContext.currentTime, 0.1);
    }
  }
  
  updateAudioParameters() {
    // Modulate oscillators based on movement speed
    const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
    const normalizedSpeed = Math.min(speed / 10, 1);
    
    this.zones.forEach(zone => {
      if (this.activeZones.has(zone.id) && zone.oscillator) {
        // Add vibrato based on movement
        const baseFreq = this.noteToFrequency(zone.note);
        const vibrato = Math.sin(this.audioContext.currentTime * 5) * normalizedSpeed * 10;
        zone.oscillator.frequency.setTargetAtTime(
          baseFreq + vibrato, 
          this.audioContext.currentTime, 
          0.05
        );
      }
    });
  }
  
  updateUI() {
    // Update position display
    const x = Math.round(this.position.x);
    const y = Math.round(this.position.y);
    this.ui.positionDisplay.textContent = `${x}, ${y}`;
    
    // Update energy display (based on movement)
    const speed = Math.sqrt(this.velocity.x ** 2 + this.velocity.y ** 2);
    const energy = Math.min(Math.round(speed * 10), 100);
    this.ui.energyDisplay.textContent = `${energy}%`;
    
    // Update AI status based on active zones
    if (this.activeZones.size === 0) {
      this.ui.aiStatusText.textContent = 'AI Listening...';
    } else if (this.activeZones.size === 1) {
      this.ui.aiStatusText.textContent = 'Generating melody...';
    } else {
      this.ui.aiStatusText.textContent = 'Harmonizing layers...';
    }
  }
  
  updateDebug() {
    this.ui.debugAccel.textContent = 
      `Accel: ${this.acceleration.x.toFixed(1)}, ${this.acceleration.y.toFixed(1)}, ${this.acceleration.z.toFixed(1)}`;
    this.ui.debugGyro.textContent = 
      `Gyro: ${this.gyro.alpha.toFixed(0)}, ${this.gyro.beta.toFixed(0)}, ${this.gyro.gamma.toFixed(0)}`;
    this.ui.debugOrient.textContent = 
      `Orient: ${this.orientation.toFixed(0)}Â°`;
    this.ui.debugZones.textContent = 
      `Active: ${this.activeZones.size}`;
  }
  
  calibrate() {
    // Set current acceleration as baseline
    this.calibrationOffset.x = this.acceleration.x;
    this.calibrationOffset.y = this.acceleration.y;
    
    // Reset velocity
    this.velocity.x = 0;
    this.velocity.y = 0;
    
    console.log('Calibrated:', this.calibrationOffset);
    
    // Visual feedback
    this.ui.calibrateBtn.classList.add('active');
    setTimeout(() => {
      this.ui.calibrateBtn.classList.remove('active');
    }, 300);
  }
  
  toggleAudio() {
    if (this.masterGain.gain.value > 0) {
      // Mute
      this.masterGain.gain.setTargetAtTime(0, this.audioContext.currentTime, 0.1);
      this.ui.toggleAudioBtn.classList.remove('active');
    } else {
      // Unmute
      this.masterGain.gain.setTargetAtTime(0.3, this.audioContext.currentTime, 0.1);
      this.ui.toggleAudioBtn.classList.add('active');
    }
  }
  
  reset() {
    // Reset position to center
    this.position.x = window.innerWidth / 2;
    this.position.y = window.innerHeight / 2;
    
    // Reset velocity
    this.velocity.x = 0;
    this.velocity.y = 0;
    
    // Deactivate all zones
    this.zones.forEach(zone => {
      if (this.activeZones.has(zone.id)) {
        this.deactivateZone(zone);
      }
    });
    this.activeZones.clear();
    
    // Visual feedback
    this.ui.resetBtn.classList.add('active');
    setTimeout(() => {
      this.ui.resetBtn.classList.remove('active');
    }, 300);
    
    console.log('Reset to center');
  }
  
  showError(message) {
    this.ui.errorMessage.textContent = 'âš ï¸ ' + message;
    this.ui.errorMessage.style.display = 'block';
  }
}

// Initialize when page loads
let app;
document.addEventListener('DOMContentLoaded', () => {
  app = new SpatialMusicLayer();
  console.log('ðŸŽµ Spatial Music Layer ready');
  console.log('ðŸ“± Tap ENTER to begin');
});

// Handle page visibility changes
document.addEventListener('visibilitychange', () => {
  if (app && app.audioContext) {
    if (document.hidden) {
      app.audioContext.suspend();
    } else {
      app.audioContext.resume();
    }
  }
});

// Handle orientation changes
window.addEventListener('orientationchange', () => {
  if (app && app.isActive) {
    // Recalibrate on orientation change
    setTimeout(() => {
      app.calibrate();
    }, 500);
  }
});
