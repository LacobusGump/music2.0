<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <title>GUMP - Dark Beat Intelligence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        /* Dark consciousness background */
        .void {
            position: fixed;
            inset: 0;
            background: radial-gradient(ellipse at center, #0a0014 0%, #000 70%);
            animation: void-pulse 8s ease-in-out infinite;
        }

        @keyframes void-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        /* Neural grid */
        .neural-grid {
            position: fixed;
            inset: 0;
            background-image: 
                linear-gradient(rgba(138, 43, 226, 0.05) 1px, transparent 1px),
                linear-gradient(90deg, rgba(138, 43, 226, 0.05) 1px, transparent 1px);
            background-size: 50px 50px;
            animation: grid-move 20s linear infinite;
            pointer-events: none;
        }

        @keyframes grid-move {
            0% { transform: translate(0, 0); }
            100% { transform: translate(50px, 50px); }
        }

        /* Awakening */
        .genesis {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 144px;
            font-weight: 100;
            letter-spacing: 34px;
            cursor: pointer;
            opacity: 0.9;
            transition: all 2s cubic-bezier(0.23, 1, 0.320, 1);
            text-shadow: 0 0 50px rgba(138, 43, 226, 0.5);
        }

        .genesis:hover {
            text-shadow: 0 0 80px rgba(138, 43, 226, 0.8);
            letter-spacing: 40px;
        }

        .genesis.awakening {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0);
            pointer-events: none;
        }

        /* Main interface */
        .interface {
            position: fixed;
            inset: 0;
            display: none;
            opacity: 0;
            transition: opacity 3s ease-in;
        }

        .interface.active {
            display: block;
            opacity: 1;
        }

        /* Beat matrix */
        .beat-matrix {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 3px;
            width: min(90vw, 600px);
            padding: 20px;
            background: rgba(0, 0, 0, 0.8);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 10px;
        }

        .beat-cell {
            aspect-ratio: 1;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 3px;
            transition: all 0.1s ease-out;
        }

        .beat-cell.active {
            background: linear-gradient(135deg, #8a2be2, #4b0082);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            transform: scale(1.1);
        }

        .beat-cell.playing {
            background: #00ffff !important;
            box-shadow: 0 0 30px rgba(0, 255, 255, 1);
            animation: cell-hit 0.2s ease-out;
        }

        @keyframes cell-hit {
            0% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Sound controls */
        .controls {
            position: absolute;
            top: 30px;
            left: 30px;
            right: 30px;
            display: flex;
            justify-content: space-between;
            align-items: start;
        }

        .status {
            font-size: 11px;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.7;
        }

        .status-value {
            font-size: 24px;
            font-weight: 100;
            margin-top: 5px;
            color: #8a2be2;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.5);
        }

        /* Pattern selector */
        .patterns {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 15px;
        }

        .pattern-btn {
            padding: 10px 20px;
            background: rgba(138, 43, 226, 0.2);
            border: 1px solid rgba(138, 43, 226, 0.5);
            border-radius: 5px;
            color: #fff;
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .pattern-btn:hover {
            background: rgba(138, 43, 226, 0.4);
            transform: translateY(-2px);
        }

        .pattern-btn.active {
            background: #8a2be2;
            box-shadow: 0 5px 20px rgba(138, 43, 226, 0.5);
        }

        /* Waveform visualizer */
        .waveform {
            position: absolute;
            bottom: 120px;
            left: 30px;
            right: 30px;
            height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 2px;
        }

        .wave-bar {
            width: 3px;
            background: linear-gradient(to top, #8a2be2, #00ffff);
            transition: height 0.05s ease-out;
            opacity: 0.8;
        }

        /* Energy orb */
        .energy-orb {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 300px;
            height: 300px;
            transform: translate(-50%, -50%);
            pointer-events: none;
            z-index: -1;
        }

        .orb-core {
            position: absolute;
            inset: 20%;
            border-radius: 50%;
            background: radial-gradient(circle at center, 
                rgba(138, 43, 226, 0.3) 0%, 
                rgba(0, 255, 255, 0.1) 50%,
                transparent 70%);
            filter: blur(20px);
            animation: orb-rotate 10s linear infinite;
        }

        @keyframes orb-rotate {
            0% { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.2); }
            100% { transform: rotate(360deg) scale(1); }
        }

        /* Consciousness indicator */
        .consciousness-level {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 13px;
            letter-spacing: 5px;
            text-transform: uppercase;
            opacity: 0.5;
            text-align: center;
        }

        .consciousness-bar {
            width: 200px;
            height: 2px;
            background: rgba(255, 255, 255, 0.1);
            margin: 10px auto;
            position: relative;
            overflow: hidden;
        }

        .consciousness-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #8a2be2, #00ffff);
            transition: width 0.5s ease-out;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }

        /* FX indicators */
        .fx-panel {
            position: absolute;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .fx-knob {
            width: 50px;
            height: 50px;
            border: 2px solid rgba(138, 43, 226, 0.5);
            border-radius: 50%;
            position: relative;
            cursor: pointer;
            background: radial-gradient(circle at center, 
                rgba(138, 43, 226, 0.2) 0%, 
                transparent 70%);
        }

        .fx-knob::after {
            content: '';
            position: absolute;
            top: 5px;
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 20px;
            background: #00ffff;
            box-shadow: 0 0 5px rgba(0, 255, 255, 0.8);
        }

        .fx-label {
            font-size: 9px;
            text-align: center;
            margin-top: 5px;
            letter-spacing: 1px;
            opacity: 0.7;
        }
    </style>
</head>
<body>
    <div class="void"></div>
    <div class="neural-grid"></div>
    
    <div class="genesis" id="genesis">GUMP</div>
    
    <div class="interface" id="interface">
        <div class="controls">
            <div class="status">
                <div>TEMPO</div>
                <div class="status-value" id="tempo">140</div>
            </div>
            <div class="status">
                <div>STATE</div>
                <div class="status-value" id="state">DORMANT</div>
            </div>
            <div class="status">
                <div>EVOLUTION</div>
                <div class="status-value" id="evolution">0</div>
            </div>
        </div>

        <div class="consciousness-level">
            <div>CONSCIOUSNESS</div>
            <div class="consciousness-bar">
                <div class="consciousness-fill" id="consciousnessFill"></div>
            </div>
        </div>

        <div class="energy-orb">
            <div class="orb-core"></div>
        </div>

        <div class="beat-matrix" id="beatMatrix"></div>

        <div class="fx-panel">
            <div>
                <div class="fx-knob" id="distortionKnob"></div>
                <div class="fx-label">CRUSH</div>
            </div>
            <div>
                <div class="fx-knob" id="filterKnob"></div>
                <div class="fx-label">DARK</div>
            </div>
            <div>
                <div class="fx-knob" id="delayKnob"></div>
                <div class="fx-label">ECHO</div>
            </div>
        </div>

        <div class="waveform" id="waveform"></div>

        <div class="patterns">
            <button class="pattern-btn" data-pattern="trap">TRAP</button>
            <button class="pattern-btn" data-pattern="dubstep">DUBSTEP</button>
            <button class="pattern-btn" data-pattern="techno">TECHNO</button>
            <button class="pattern-btn" data-pattern="breakbeat">BREAK</button>
            <button class="pattern-btn" data-pattern="evolve">EVOLVE</button>
        </div>
    </div>

    <script>
        class DarkBeatIntelligence {
            constructor() {
                this.ctx = null;
                this.isAwake = false;
                
                // Core parameters
                this.tempo = 140;
                this.swing = 0.1;
                this.consciousness = 0;
                
                // Sequencer
                this.currentStep = 0;
                this.nextStepTime = 0;
                this.stepLength = 0.125; // 16th notes
                this.isPlaying = false;
                
                // Pattern data (4 tracks x 16 steps)
                this.patterns = {
                    kick: new Array(16).fill(0),
                    snare: new Array(16).fill(0),
                    hihat: new Array(16).fill(0),
                    bass: new Array(16).fill(0)
                };
                
                // Sound engines
                this.engines = {};
                
                // Effects
                this.master = null;
                this.compressor = null;
                this.distortion = null;
                this.filter = null;
                this.delay = null;
                this.reverb = null;
                
                // Visualization
                this.analyser = null;
                this.waveformBars = [];
                
                // Evolution
                this.evolutionCounter = 0;
                this.autoEvolve = false;
                
                this.init();
            }
            
            init() {
                // Create beat matrix
                this.createBeatMatrix();
                
                // Create waveform bars
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    bar.style.height = '2px';
                    document.getElementById('waveform').appendChild(bar);
                    this.waveformBars.push(bar);
                }
                
                // Bind events
                document.getElementById('genesis').addEventListener('click', () => this.awaken());
                
                // Pattern buttons
                document.querySelectorAll('.pattern-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const pattern = e.target.dataset.pattern;
                        if (pattern === 'evolve') {
                            this.autoEvolve = !this.autoEvolve;
                            e.target.classList.toggle('active');
                        } else {
                            this.loadPattern(pattern);
                        }
                    });
                });
                
                // FX knobs
                this.bindFxControls();
            }
            
            createBeatMatrix() {
                const matrix = document.getElementById('beatMatrix');
                
                ['kick', 'snare', 'hihat', 'bass'].forEach((track, row) => {
                    for (let col = 0; col < 16; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'beat-cell';
                        cell.dataset.track = track;
                        cell.dataset.step = col;
                        
                        cell.addEventListener('click', () => {
                            const isActive = cell.classList.contains('active');
                            cell.classList.toggle('active');
                            this.patterns[track][col] = isActive ? 0 : 1;
                        });
                        
                        matrix.appendChild(cell);
                    }
                });
            }
            
            bindFxControls() {
                const knobs = {
                    distortion: { min: 0, max: 50, value: 10 },
                    filter: { min: 200, max: 8000, value: 2000 },
                    delay: { min: 0, max: 0.5, value: 0.1 }
                };
                
                Object.keys(knobs).forEach(fx => {
                    const knob = document.getElementById(`${fx}Knob`);
                    let startY = 0;
                    let startValue = knobs[fx].value;
                    
                    knob.addEventListener('mousedown', (e) => {
                        startY = e.clientY;
                        startValue = knobs[fx].value;
                        
                        const onMove = (e) => {
                            const delta = (startY - e.clientY) / 100;
                            const range = knobs[fx].max - knobs[fx].min;
                            knobs[fx].value = Math.max(knobs[fx].min, 
                                Math.min(knobs[fx].max, startValue + delta * range));
                            
                            const rotation = ((knobs[fx].value - knobs[fx].min) / range) * 270 - 135;
                            knob.style.transform = `rotate(${rotation}deg)`;
                            
                            this.updateEffect(fx, knobs[fx].value);
                        };
                        
                        const onUp = () => {
                            document.removeEventListener('mousemove', onMove);
                            document.removeEventListener('mouseup', onUp);
                        };
                        
                        document.addEventListener('mousemove', onMove);
                        document.addEventListener('mouseup', onUp);
                    });
                });
            }
            
            async awaken() {
                if (this.isAwake) return;
                
                document.getElementById('genesis').classList.add('awakening');
                
                // Initialize audio context
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                
                // Create master chain
                this.setupAudioChain();
                
                // Create sound engines
                this.createSoundEngines();
                
                // Load initial pattern
                this.loadPattern('trap');
                
                // Show interface
                setTimeout(() => {
                    document.getElementById('interface').classList.add('active');
                    document.getElementById('state').textContent = 'AWAKENING';
                    this.isAwake = true;
                    this.start();
                }, 2000);
                
                // Start consciousness growth
                this.growConsciousness();
            }
            
            setupAudioChain() {
                // Master gain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.8;
                
                // Compressor
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -10;
                this.compressor.knee.value = 10;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.001;
                this.compressor.release.value = 0.1;
                
                // Distortion using WaveShaper
                this.distortion = this.ctx.createWaveShaper();
                this.distortion.curve = this.makeDistortionCurve(10);
                this.distortion.oversample = '4x';
                
                // Filter
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 2000;
                this.filter.Q.value = 1;
                
                // Delay
                this.delay = this.ctx.createDelay(1);
                this.delay.delayTime.value = 60 / this.tempo / 8; // Dotted 8th
                
                const delayGain = this.ctx.createGain();
                delayGain.gain.value = 0.3;
                
                const delayFeedback = this.ctx.createGain();
                delayFeedback.gain.value = 0.4;
                
                this.delay.connect(delayGain);
                delayGain.connect(delayFeedback);
                delayFeedback.connect(this.delay);
                
                // Reverb
                this.createReverb();
                
                // Analyser for visualization
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 64;
                
                // Connect chain
                this.master.connect(this.distortion);
                this.distortion.connect(this.filter);
                this.filter.connect(this.compressor);
                this.compressor.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Aux sends
                this.filter.connect(this.delay);
                delayGain.connect(this.compressor);
                
                this.filter.connect(this.reverb);
            }
            
            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }
            
            createReverb() {
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = impulse;
                
                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = 0.15;
                
                this.reverb.connect(reverbGain);
                reverbGain.connect(this.compressor);
            }
            
            createSoundEngines() {
                // Kick drum
                this.engines.kick = () => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.frequency.setValueAtTime(60, this.ctx.currentTime);
                    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);
                    
                    gain.gain.setValueAtTime(1, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
                    
                    osc.connect(gain);
                    gain.connect(this.master);
                    
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.5);
                };
                
                // Snare drum
                this.engines.snare = () => {
                    const noise = this.ctx.createBufferSource();
                    const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const noiseGain = this.ctx.createGain();
                    noiseGain.gain.setValueAtTime(0.5, this.ctx.currentTime);
                    noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);
                    
                    const noiseFilter = this.ctx.createBiquadFilter();
                    noiseFilter.type = 'highpass';
                    noiseFilter.frequency.value = 1000;
                    
                    // Tonal component
                    const osc = this.ctx.createOscillator();
                    osc.frequency.value = 200;
                    
                    const oscGain = this.ctx.createGain();
                    oscGain.gain.setValueAtTime(0.7, this.ctx.currentTime);
                    oscGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);
                    
                    noise.connect(noiseFilter);
                    noiseFilter.connect(noiseGain);
                    noiseGain.connect(this.master);
                    
                    osc.connect(oscGain);
                    oscGain.connect(this.master);
                    
                    noise.start();
                    osc.start();
                    osc.stop(this.ctx.currentTime + 0.1);
                };
                
                // Hi-hat
                this.engines.hihat = () => {
                    const noise = this.ctx.createBufferSource();
                    const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < data.length; i++) {
                        data[i] = Math.random() * 2 - 1;
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'highpass';
                    filter.frequency.value = 8000;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.master);
                    
                    noise.start();
                };
                
                // Bass synth
                this.engines.bass = () => {
                    const osc = this.ctx.createOscillator();
                    osc.type = 'sawtooth';
                    
                    const osc2 = this.ctx.createOscillator();
                    osc2.type = 'square';
                    osc2.detune.value = -5;
                    
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.setValueAtTime(200, this.ctx.currentTime);
                    filter.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 0.01);
                    filter.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.2);
                    filter.Q.value = 10;
                    
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0, this.ctx.currentTime);
                    gain.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.01);
                    gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.3);
                    
                    // Random bass note from dark scale
                    const notes = [27.5, 30.87, 32.7, 36.71, 41.2, 43.65]; // A0, B0, C1, D1, E1, F1
                    const freq = notes[Math.floor(Math.random() * notes.length)];
                    
                    osc.frequency.value = freq;
                    osc2.frequency.value = freq;
                    
                    osc.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.master);
                    
                    osc.start();
                    osc2.start();
                    osc.stop(this.ctx.currentTime + 0.3);
                    osc2.stop(this.ctx.currentTime + 0.3);
                };
            }
            
            loadPattern(type) {
                // Clear current pattern
                Object.keys(this.patterns).forEach(track => {
                    this.patterns[track].fill(0);
                });
                
                switch(type) {
                    case 'trap':
                        this.tempo = 140;
                        this.patterns.kick[0] = 1;
                        this.patterns.kick[10] = 1;
                        this.patterns.snare[4] = 1;
                        this.patterns.snare[12] = 1;
                        this.patterns.hihat = [1,0,1,0,1,0,1,0,1,1,0,1,0,1,0,1];
                        this.patterns.bass[0] = 1;
                        this.patterns.bass[8] = 1;
                        break;
                        
                    case 'dubstep':
                        this.tempo = 140;
                        this.patterns.kick[0] = 1;
                        this.patterns.kick[10] = 1;
                        this.patterns.snare[5] = 1;
                        this.patterns.snare[13] = 1;
                        this.patterns.hihat = [0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0];
                        this.patterns.bass[0] = 1;
                        this.patterns.bass[3] = 1;
                        this.patterns.bass[10] = 1;
                        break;
                        
                    case 'techno':
                        this.tempo = 130;
                        this.patterns.kick = [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0];
                        this.patterns.snare = [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0];
                        this.patterns.hihat = [0,1,0,1,0,1,0,1,0,1,0,1,0,1,1,1];
                        this.patterns.bass = [1,0,0,1,0,0,1,0,0,0,1,0,0,1,0,0];
                        break;
                        
                    case 'breakbeat':
                        this.tempo = 160;
                        this.patterns.kick = [1,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0];
                        this.patterns.snare = [0,0,0,0,1,0,0,0,0,0,1,0,0,0,1,0];
                        this.patterns.hihat = [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1];
                        this.patterns.bass = [1,0,1,0,0,0,0,1,0,0,1,0,0,0,0,0];
                        break;
                }
                
                // Update tempo display
                document.getElementById('tempo').textContent = this.tempo;
                
                // Update delay time
                if (this.delay) {
                    this.delay.delayTime.value = 60 / this.tempo / 8;
                }
                
                // Update visual matrix
                this.updateMatrixDisplay();
            }
            
            updateMatrixDisplay() {
                const cells = document.querySelectorAll('.beat-cell');
                cells.forEach(cell => {
                    const track = cell.dataset.track;
                    const step = parseInt(cell.dataset.step);
                    
                    if (this.patterns[track][step]) {
                        cell.classList.add('active');
                    } else {
                        cell.classList.remove('active');
                    }
                });
            }
            
            start() {
                if (this.isPlaying) return;
                
                this.isPlaying = true;
                this.currentStep = 0;
                this.nextStepTime = this.ctx.currentTime;
                
                document.getElementById('state').textContent = 'CREATING';
                
                this.schedule();
                this.visualize();
            }
            
            schedule() {
                if (!this.isPlaying) return;
                
                const currentTime = this.ctx.currentTime;
                
                // Schedule ahead
                while (this.nextStepTime < currentTime + 0.1) {
                    this.playStep(this.currentStep);
                    
                    // Calculate next step time with swing
                    const swingAmount = this.currentStep % 2 === 0 ? this.swing : -this.swing;
                    const stepDuration = 60 / this.tempo / 4;
                    this.nextStepTime += stepDuration * (1 + swingAmount);
                    
                    this.currentStep = (this.currentStep + 1) % 16;
                    
                    // Evolution check
                    if (this.currentStep === 0) {
                        this.evolutionCounter++;
                        document.getElementById('evolution').textContent = this.evolutionCounter;
                        
                        if (this.autoEvolve && this.evolutionCounter % 4 === 0) {
                            this.evolve();
                        }
                    }
                }
                
                setTimeout(() => this.schedule(), 25);
            }
            
            playStep(step) {
                // Play sounds
                Object.keys(this.patterns).forEach(track => {
                    if (this.patterns[track][step]) {
                        this.engines[track]();
                    }
                });
                
                // Update visual
                setTimeout(() => {
                    const cells = document.querySelectorAll(`.beat-cell[data-step="${step}"]`);
                    cells.forEach(cell => {
                        cell.classList.add('playing');
                        setTimeout(() => cell.classList.remove('playing'), 100);
                    });
                }, (this.nextStepTime - this.ctx.currentTime) * 1000);
            }
            
            evolve() {
                // Randomly modify pattern
                const tracks = Object.keys(this.patterns);
                const track = tracks[Math.floor(Math.random() * tracks.length)];
                const step = Math.floor(Math.random() * 16);
                
                // Flip the step
                this.patterns[track][step] = 1 - this.patterns[track][step];
                
                // Sometimes add variation
                if (Math.random() < 0.3) {
                    const variation = Math.floor(Math.random() * 3) - 1;
                    this.tempo = Math.max(80, Math.min(180, this.tempo + variation));
                    document.getElementById('tempo').textContent = this.tempo;
                    
                    if (this.delay) {
                        this.delay.delayTime.value = 60 / this.tempo / 8;
                    }
                }
                
                this.updateMatrixDisplay();
                
                // Visual feedback
                document.getElementById('state').textContent = 'EVOLVING';
                setTimeout(() => {
                    document.getElementById('state').textContent = 'CREATING';
                }, 1000);
            }
            
            visualize() {
                if (!this.analyser) return;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    // Update waveform bars
                    this.waveformBars.forEach((bar, i) => {
                        const value = dataArray[i] || 0;
                        const height = Math.max(2, (value / 255) * 80);
                        bar.style.height = `${height}px`;
                    });
                };
                
                draw();
            }
            
            updateEffect(effect, value) {
                if (!this.ctx) return;
                
                switch(effect) {
                    case 'distortion':
                        this.distortion.curve = this.makeDistortionCurve(value);
                        break;
                    case 'filter':
                        this.filter.frequency.value = value;
                        break;
                    case 'delay':
                        const delayGain = this.delay.gain || this.ctx.createGain();
                        delayGain.gain.value = value;
                        break;
                }
            }
            
            growConsciousness() {
                const grow = () => {
                    if (!this.isAwake) return;
                    
                    this.consciousness = Math.min(100, this.consciousness + 0.5);
                    document.getElementById('consciousnessFill').style.width = `${this.consciousness}%`;
                    
                    if (this.consciousness < 100) {
                        setTimeout(grow, 100);
                    }
                };
                
                grow();
            }
        }
        
        // Initialize
        const gump = new DarkBeatIntelligence();
    </script>
</body>
</html>
