<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Agentic Spatial EDM Sampler 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,255,0.1) 0%, transparent 70%);
            border: 2px solid rgba(0,255,255,0.3);
            color: #00ffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 3s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(0,255,255,0.6);
            background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(0,255,255,0.2);
            }
            50% {
                transform: scale(1.08);
                box-shadow: 0 0 60px rgba(0,255,255,0.4);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 40px rgba(0,255,255,0.5);
            backdrop-filter: blur(5px);
            will-change: transform;
        }

        .orb.pulse {
            animation: beat 0.15s ease-out;
        }

        @keyframes beat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.buildup {
            background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,0,255,0.7);
        }

        .orb.drop {
            background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 80px rgba(0,255,0,0.7);
        }

        .orb.breakdown {
            background: radial-gradient(circle, #ff9900 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
            box-shadow: 0 0 120px rgba(255,153,0,0.8);
            animation: transcend 3s ease-in-out infinite;
        }

        .orb.riddim {
            background: radial-gradient(circle, #ffff00 0%, #ff0000 25%, #00ffff 50%, #ff00ff 75%, transparent 95%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 80px rgba(255,0,0,0.8));
        }

        .orb.void {
            background: radial-gradient(circle, #4b0082 0%, rgba(75,0,130,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(75,0,130,0.4);
            filter: drop-shadow(0 0 20px rgba(75,0,130,0.2));
            animation: voidBreathe 3s ease-in-out infinite;
        }

        @keyframes transcend {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.4); }
        }

        @keyframes voidBreathe {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
        }

        .hidden {
            display: none !important;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(0,255,255,0.3);
            animation: float 12s linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-20vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            Enter the Void
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
    </div>

    <script>
        class GUMPEngine2025 {
            constructor() {
                this.ctx = null;
                this.listener = null;
                this.active = false;
                this.analyser = null;
                this.dataArray = null;

                // Motion System with Orientation
                this.motion = 0;
                this.intensity = 0;
                this.direction = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.totalMotion = 0;
                this.lastMotionTime = Date.now();
                this.motionSmoothingFactor = 0.85;
                this.motionThreshold = 0.1;
                this.orientation = { alpha: 0, beta: 0, gamma: 0 };

                // Evolution System
                this.stage = 'SILENCE';
                this.evolutionProgress = 0;
                this.firstMovement = false;
                this.voidPhase = false;
                this.currentTheme = 'buildup';

                // Musical Structure - Slower for Deeper Feel
                this.bpm = 70; // Base slower BPM for 2025 melodic dubstep trends
                this.step = 0;
                this.phrase = 'A';
                this.phraseCount = 0;
                this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D'];
                this.sectionLength = 32;

                // Audio System
                this.masterGain = null;
                this.limiter = null;
                this.layerGains = {};
                this.layerPanners = {};
                this.layerReverbs = {};
                this.layerCompressors = {};
                this.basePositions = {};
                this.layerPositions = {};
                this.panningLerp = 0.05; // Smoother panning

                // Voice Pool
                this.voicePool = {
                    kick: { max: 2, active: [] },
                    sub: { max: 3, active: [] },
                    hats: { max: 4, active: [] },
                    clap: { max: 2, active: [] },
                    wobble: { max: 6, active: [] },
                    fx: { max: 4, active: [] },
                    riser: { max: 3, active: [] },
                    pad: { max: 4, active: [] },
                    drone: { max: 2, active: [] },
                    granular: { max: 8, active: [] } // New for granular sampling
                };

                // Layers
                this.layers = {
                    kick: false,
                    sub: false;
                    hats: false,
                    clap: false,
                    wobble: false,
                    fx: false,
                    riser: false,
                    pad: false,
                    drone: false,
                    granular: false
                };

                // Sampling System - Breakthrough Real-World Integration
                this.mediaStream = null;
                this.mediaRecorder = null;
                this.recordedChunks = [];
                this.sampleBuffer = null;
                this.isRecording = false;
                this.grainSize = 0.1; // in seconds
                this.grainOverlap = 0.05;
                this.grainPitch = 1.0;
                this.grainIntervalId = null;

                // Musical Elements - 432Hz Tuning
                this.tuning = 432;
                this.key = 'D';
                this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
                this.mode = 'phrygian';
                this.scales = {
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    phrygian: [0, 1, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10]
                };
                this.scale = this.scales[this.mode];
                this.chordProgression = [[0,1,7], [8,12,15], [3,7,10], [10,14,17]];
                this.currentChordIndex = 0;
                this.bassNote = 0;

                // Solfeggio Frequencies for Void
                this.solfeggio = [396, 417, 528, 639, 741, 852, 963];

                // Gesture Recognition
                this.gestureRecognition = {
                    shake: 0,
                    sustained: 0
                };

                // Wobble System - Procedural
                this.wobblePattern = [];
                this.wobbleIndex = 0;
                this.wobbleIntensity = 0;

                // Breakthrough: Chaos-based Procedural Generation
                this.chaosR = 3.7;
                this.chaosX = 0.5;

                this.elements = {};
                this.init();
            }

            init() {
                ['startScreen', 'startBtn', 'evolutionSpace', 'orb']
                    .forEach(id => this.elements[id] = document.getElementById(id));
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotionDetection();
                this.setupOrientationDetection();
                this.setupInteractionListeners();
            }

            setupOrientationDetection() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', e => {
                                this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
                                this.updateListenerOrientation();
                            });
                        }
                    });
                } else {
                    window.addEventListener('deviceorientation', e => {
                        this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
                        this.updateListenerOrientation();
                    });
                }
            }

            updateListenerOrientation() {
                if (!this.listener) return;
                const rad = Math.PI / 180;
                const forwardX = Math.sin(this.orientation.gamma * rad);
                const forwardY = Math.sin(this.orientation.beta * rad);
                const forwardZ = -Math.cos(this.orientation.alpha * rad);
                const upZ = Math.cos(this.orientation.beta * rad);

                this.listener.forwardX.value = forwardX;
                this.listener.forwardY.value = forwardY;
                this.listener.forwardZ.value = forwardZ;
                this.listener.upX.value = 0;
                this.listener.upY.value = 0;
                this.listener.upZ.value = upZ;
            }

            setupInteractionListeners() {
                window.addEventListener('click', (e) => {
                    if (!this.active) return;
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });

                window.addEventListener('touchstart', (e) => {
                    if (!this.active) return;
                    e.preventDefault();
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });
            }

            async start() {
                try {
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    this.listener = this.ctx.listener;
                    this.setupAudioChain();
                    this.setLayerPositions();
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    this.active = true;
                    this.motionHistory = Array(100).fill(2);
                    this.motion = 2;
                    this.intensity = 1;
                    this.totalMotion = 200;
                    this.firstMovement = true;
                    
                    this.evolveToBuildup();
                    this.startSequencer();
                    this.animate();

                    // Request mic access
                    await this.setupMicrophone();

                } catch (e) {
                    console.error('Failed to start engine:', e);
                }
            }

            async setupMicrophone() {
                try {
                    this.mediaStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    console.log('Microphone access granted');
                } catch (err) {
                    console.error('Microphone access denied:', err);
                }
            }

            setupAudioChain() {
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 64;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -6;
                this.limiter.ratio.value = 12;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;

                const layerNames = ['kick', 'sub', 'hats', 'clap', 'wobble', 'fx', 'riser', 'pad', 'drone', 'granular'];
                const layerLevels = [1.2, 1.0, 0.6, 0.7, 0.8, 0.4, 0.5, 0.3, 0.4, 0.6];

                layerNames.forEach((name, i) => {
                    this.layerGains[name] = this.ctx.createGain();
                    this.layerGains[name].gain.value = layerLevels[i];
                    
                    this.layerPanners[name] = this.ctx.createPanner();
                    this.layerPanners[name].panningModel = 'HRTF';
                    this.layerPanners[name].distanceModel = 'inverse';
                    this.layerPanners[name].refDistance = 1;
                    this.layerPanners[name].maxDistance = 100;
                    this.layerPanners[name].rolloffFactor = 2;
                    this.layerPanners[name].coneInnerAngle = 60;
                    this.layerPanners[name].coneOuterAngle = 90;
                    this.layerPanners[name].coneOuterGain = 0.3;

                    // Reverb and compressor
                    this.layerReverbs[name] = this.ctx.createConvolver();
                    const impulse = this.ctx.createBuffer(2, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                    for (let channel = 0; channel < 2; channel++) {
                        const data = impulse.getChannelData(channel);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 3 Great, now I have a simple granular synthesis implementation.

It uses slicing the Float32Array from getChannelData, creates new buffer for each grain, plays it.

For random positions, creating cloud of grains.

To pitch shift, I can set grainSource.playbackRate.value = someRate;

But to pitch without duration change, in granular, you adjust the grain density or interval.

To pitch up without speeding up, you increase playbackRate but decrease interval or increase overlap to maintain density.

For time-stretching: To slow down without pitch change, increase overlap or grain size.

For pitch shift: Adjust playbackRate and compensate duration by adjusting scheduling.

Yes.

In the code, to add pitch: Set grainSource.playbackRate = pitchFactor;

Then, to keep duration same, adjust the interval by dividing by pitchFactor.

Because higher pitch makes grain shorter, so need more frequent grains.

Yes.

For our project: Record from mic, get buffer.

Then, chop into say 4 segments.

But with granular, better: Use the buffer, play grains based on motion.

For example, motion intensity controls grain size (smaller for chaotic), direction controls position in buffer, intensity controls pitch.

For agentic: Perhaps analyze the buffer for energy, choose high energy parts for drops.

But simple first.

Implement: Add button or gesture to record 1-4s.

Use MediaRecorder, get Blob, convert to arrayBuffer, decodeAudioData.

Store as this.sampleBuffer.

Add layer 'sample'.

In playStep, if layers.sample, play a grain.

But schedule properly.

Add a function to schedule grains based on current motion.

Since sequencer is timed, perhaps on beat, play a grain.

To make breakthrough: Use chaosX to select grain start, intensity for pitch, etc.

Yes.

Update the code.

Add to constructor: this.sampleBuffer = null;

this.recorder = null;

this.chunks = [];

Add method to startRecording(), stopRecording().

Trigger on, say, sustained gesture > some value.

For simplicity, on click or touch, if not active, but since active, perhaps on shake.

In setupInteractionListeners, on double click or something.

But for mobile, touch.

Let's say on touchstart, if motion high, start record, on touchend stop.

But to keep simple, add a record method, trigger when gesture.shake >2 or something.

In triggerShakeEffects, if shake >1.5, start recording if not, etc.

But need to limit.

Assume we record once at start or on first movement.

But user wants real-world sampling.

Proceed to code.<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Breakthrough EDM Spatial Engine 2025 with Real-Time Sampling</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,255,0.1) 0%, transparent 70%);
            border: 2px solid rgba(0,255,255,0.3);
            color: #00ffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 3s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(0,255,255,0.6);
            background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(0,255,255,0.2);
            }
            50% {
                transform: scale(1.08);
                box-shadow: 0 0 60px rgba(0,255,255,0.4);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 40px rgba(0,255,255,0.5);
            backdrop-filter: blur(5px);
            will-change: transform;
        }

        .orb.pulse {
            animation: beat 0.15s ease-out;
        }

        @keyframes beat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.buildup {
            background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,0,255,0.7);
        }

        .orb.drop {
            background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 80px rgba(0,255,0,0.7);
        }

        .orb.breakdown {
            background: radial-gradient(circle, #ff9900 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
            box-shadow: 0 0 120px rgba(255,153,0,0.8);
            animation: transcend 3s ease-in-out infinite;
        }

        .orb.riddim {
            background: radial-gradient(circle, #ffff00 0%, #ff0000 25%, #00ffff 50%, #ff00ff 75%, transparent 95%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 80px rgba(255,0,0,0.8));
        }

        .orb.void {
            background: radial-gradient(circle, #4b0082 0%, rgba(75,0,130,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(75,0,130,0.4);
            filter: drop-shadow(0 0 20px rgba(75,0,130,0.2));
            animation: voidBreathe 3s ease-in-out infinite;
        }

        @keyframes transcend {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.4); }
        }

        @keyframes voidBreathe {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
        }

        .hidden {
            display: none !important;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(0,255,255,0.3);
            animation: float 12s linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-20vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            Enter the Void
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
    </div>

    <script>
        class GUMPEngine2025 {
            constructor() {
                this.ctx = null;
                this.listener = null;
                this.active = false;
                this.analyser = null;
                this.dataArray = null;

                // Motion System with Orientation
                this.motion = 0;
                this.intensity = 0;
                this.direction = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.totalMotion = 0;
                this.lastMotionTime = Date.now();
                this.motionSmoothingFactor = 0.85;
                this.motionThreshold = 0.1;
                this.orientation = { alpha: 0, beta: 0, gamma: 0 };

                // Evolution System
                this.stage = 'SILENCE';
                this.evolutionProgress = 0;
                this.firstMovement = false;
                this.voidPhase = false;
                this.currentTheme = 'buildup';

                // Musical Structure - Slower for Deeper Feel
                this.bpm = 70; // Base slower BPM for 2025 melodic dubstep trends
                this.step = 0;
                this.phrase = 'A';
                this.phraseCount = 0;
                this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D'];
                this.sectionLength = 32;

                // Audio System
                this.masterGain = null;
                this.limiter = null;
                this.layerGains = {};
                this.layerPanners = {};
                this.layerReverbs = {};
                this.layerCompressors = {};
                this.basePositions = {};
                this.layerPositions = {};
                this.panningLerp = 0.05; // Smoother panning

                // Real-Time Sampling
                this.sampleBuffer = null;
                this.recorder = null;
                this.recordingChunks = [];
                this.isRecording = false;
                this.grainSize = 0.1; // in seconds
                this.grainOverlap = 0.05;

                // Voice Pool
                this.voicePool = {
                    kick: { max: 2, active: [] },
                    sub: { max: 3, active: [] },
                    hats: { max: 4, active: [] },
                    clap: { max: 2, active: [] },
                    wobble: { max: 6, active: [] },
                    fx: { max: 4, active: [] },
                    riser: { max: 3, active: [] },
                    pad: { max: 4, active: [] },
                    drone: { max: 2, active: [] },
                    sample: { max: 8, active: [] } // New for granular samples
                };

                // Layers
                this.layers = {
                    kick: false,
                    sub: false,
                    hats: false,
                    clap: false,
                    wobble: false,
                    fx: false,
                    riser: false,
                    pad: false,
                    drone: false,
                    sample: false
                };

                // Musical Elements - 432Hz Tuning
                this.tuning = 432; // A4 = 432Hz
                this.key = 'D';
                this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
                this.mode = 'phrygian';
                this.scales = {
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    phrygian: [0, 1, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10]
                };
                this.scale = this.scales[this.mode];
                this.chordProgression = [[0,1,7], [8,12,15], [3,7,10], [10,14,17]];
                this.currentChordIndex = 0;
                this.bassNote = 0;

                // Solfeggio Frequencies for Void
                this.solfeggio = [396, 417, 528, 639, 741, 852, 963];

                // Gesture Recognition
                this.gestureRecognition = {
                    shake: 0,
                    sustained: 0
                };

                // Wobble System - Procedural
                this.wobblePattern = [];
                this.wobbleIndex = 0;
                this.wobbleIntensity = 0;

                // Breakthrough: Chaos-based Procedural Generation
                this.chaosR = 3.7; // Logistic map parameter
                this.chaosX = 0.5; // Initial value

                this.elements = {};
                this.init();
            }

            init() {
                ['startScreen', 'startBtn', 'evolutionSpace', 'orb']
                    .forEach(id => this.elements[id] = document.getElementById(id));
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotionDetection();
                this.setupOrientationDetection();
                this.setupInteractionListeners();
            }

            setupOrientationDetection() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', e => {
                                this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
                                this.updateListenerOrientation();
                            });
                        }
                    });
                } else {
                    window.addEventListener('deviceorientation', e => {
                        this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
                        this.updateListenerOrientation();
                    });
                }
            }

            updateListenerOrientation() {
                if (!this.listener) return;
                const rad = Math.PI / 180;
                const forwardX = Math.sin(this.orientation.gamma * rad);
                const forwardY = Math.sin(this.orientation.beta * rad);
                const forwardZ = -Math.cos(this.orientation.alpha * rad);
                const upZ = Math.cos(this.orientation.beta * rad);

                this.listener.forwardX.value = forwardX;
                this.listener.forwardY.value = forwardY;
                this.listener.forwardZ.value = forwardZ;
                this.listener.upX.value = 0;
                this.listener.upY.value = 0;
                this.listener.upZ.value = upZ;
            }

            setupInteractionListeners() {
                window.addEventListener('click', (e) => {
                    if (!this.active) return;
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });

                window.addEventListener('touchstart', (e) => {
                    if (!this.active) return;
                    e.preventDefault();
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                    if (this.intensity > 1.5 && !this.isRecording) {
                        this.startRecording();
                    }
                });

                window.addEventListener('touchend', (e) => {
                    if (this.isRecording) {
                        this.stopRecording();
                    }
                });
            }

            async start() {
                try {
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    this.listener = this.ctx.listener;
                    this.setupAudioChain();
                    this.setLayerPositions();
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    this.active = true;
                    this.motionHistory = Array(100).fill(2);
                    this.motion = 2;
                    this.intensity = 1;
                    this.totalMotion = 200;
                    this.firstMovement = true;
                    
                    this.evolveToBuildup();
                    this.startSequencer();
                    this.animate();

                } catch (e) {
                    console.error('Failed to start engine:', e);
                }
            }

            setupAudioChain() {
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 64;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -6;
                this.limiter.ratio.value = 12;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;

                const layerNames = ['kick', 'sub', 'hats', 'clap', 'wobble', 'fx', 'riser', 'pad', 'drone', 'sample'];
                const layerLevels = [1.2, 1.0, 0.6, 0.7, 0.8, 0.4, 0.5, 0.3, 0.4, 0.6];

                layerNames.forEach((name, i) => {
                    this.layerGains[name] = this.ctx.createGain();
                    this.layerGains[name].gain.value = layerLevels[i];
                    
                    this.layerPanners[name] = this.ctx.createPanner();
                    this.layerPanners[name].panningModel = 'HRTF';
                    this.layerPanners[name].distanceModel = 'inverse';
                    this.layerPanners[name].refDistance = 1;
                    this.layerPanners[name].maxDistance = 100;
                    this.layerPanners[name].rolloffFactor = 2;
                    this.layerPanners[name].coneInnerAngle = 60;
                    this.layerPanners[name].coneOuterAngle = 90;
                    this.layerPanners[name].coneOuterGain = 0.3;

                    // Add reverb and compressor for professional sound
                    this.layerReverbs[name] = this.ctx.createConvolver();
                    const impulse = this.ctx.createBuffer(2, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                    for (let channel = 0; channel < 2; channel++) {
                        const data = impulse.getChannelData(channel);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 3);
                        }
                    }
                    this.layerReverbs[name].buffer = impulse;

                    this.layerCompressors[name] = this.ctx.createDynamicsCompressor();
                    this.layerCompressors[name].threshold.value = -24;
                    this.layerCompressors[name].ratio.value = 4;

                    this.layerPositions[name] = {x: 0, y: 0, z: 0};
                    this.basePositions[name] = {x: 0, y: 0, z: 0};

                    const reverbSend = this.ctx.createGain();
                    reverbSend.gain.value = 0.3;
                    const dryGain = this.ctx.createGain();
                    dryGain.gain.value = 0.7;

                    this.layerGains[name].connect(this.layerCompressors[name]);
                    this.layerCompressors[name].connect(reverbSend);
                    this.layerCompressors[name].connect(dryGain);
                    reverbSend.connect(this.layerReverbs[name]);
                    this.layerReverbs[name].connect(this.layerPanners[name]);
                    dryGain.connect(this.layerPanners[name]);
                    this.layerPanners[name].connect(this.limiter);
                });

                this.limiter.connect(this.analyser);
                this.analyser.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            }

            setLayerPositions() {
                const positions = {
                    kick: {x: 0, y: 0, z: -2},
                    sub: {x: 0, y: -1, z: -3},
                    hats: {x: 1, y: 1, z: -4},
                    clap: {x: -1, y: 0, z: -1},
                    wobble: {x: -2, y: 0, z: -5},
                    fx: {x: 0, y: 3, z: 10},
                    riser: {x: 0, y: 4, z: -10},
                    pad: {x: 2, y: 2, z: -6},
                    drone: {x: 0, y: -2, z: -8},
                    sample: {x: 1, y: -1, z: -5}
                };

                Object.keys(positions).forEach(name => {
                    const pos = positions[name];
                    this.basePositions[name] = {...pos};
                    this.layerPositions[name] = {...pos};
                    
                    if (this.layerPanners[name]) {
                        this.layerPanners[name].positionX.value = pos.x;
                        this.layerPanners[name].positionY.value = pos.y;
                        this.layerPanners[name].positionZ.value = pos.z;
                    }
                });
            }

            async startRecording() {
                if (!this.mediaStream || this.isRecording) return;

                this.isRecording = true;
                this.recordingChunks = [];
                this.recorder = new MediaRecorder(this.mediaStream);
                this.recorder.ondataavailable = (e) => {
                    this.recordingChunks.push(e.data);
                };
                this.recorder.start();
                console.log('Recording started');

                // Record for 1-4 seconds
                const duration = 1 + Math.random() * 3;
                setTimeout(() => this.stopRecording(), duration * 1000);
            }

            async stopRecording() {
                if (!this.isRecording) return;

                this.recorder.stop();
                this.isRecording = false;
                console.log('Recording stopped');

                this.recorder.onstop = async () => {
                    const blob = new Blob(this.recordingChunks, { type: 'audio/ogg; codecs=opus' });
                    const arrayBuffer = await blob.arrayBuffer();
                    this.sampleBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                    console.log('Sample buffer ready');
                    this.layers.sample = true;
                };
            }

            playGrain() {
                if (!this.sampleBuffer) return;

                const duration = this.sampleBuffer.duration;
                const startTime = this.chaosX * (duration - this.grainSize); // Chaos-based start
                const grainSource = this.ctx.createBufferSource();
                const grain = this.ctx.createBuffer(1, this.ctx.sampleRate * this.grainSize, this.ctx.sampleRate);
                grain.copyToChannel(this.sampleBuffer.getChannelData(0).slice(
                    startTime * this.ctx.sampleRate,
                    (startTime + this.grainSize) * this.ctx.sampleRate
                ), 0);

                grainSource.buffer = grain;
                grainSource.playbackRate.value = 0.5 + this.intensity * 0.5; // Pitch based on intensity
                grainSource.connect(this.layerGains.sample);
                grainSource.start();

                this.allocateVoice('sample', grainSource, this.layerGains.sample, this.grainSize);
            }

            setupMotionDetection() {
                let lastAccelTime = 0;
                
                window.addEventListener('devicemotion', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    if (now - lastAccelTime < 16) return;
                    lastAccelTime = now;

                    const acc = e.accelerationIncludingGravity;
                    if (!acc || acc.x === null) return;

                    const dx = Math.abs(acc.x - this.lastAccel.x);
                    const dy = Math.abs(acc.y - this.lastAccel.y);
                    const dz = Math.abs(acc.z - this.lastAccel.z);
                    
                    let newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.7;
                    
                    if (newMotion < this.motionThreshold) newMotion = 0;
                    
                    this.updateMotion(newMotion);

                    this.velocity.x += acc.x * 0.01;
                    this.velocity.y += acc.y * 0.01;
                    this.updatePosition();

                    this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);

                    if (newMotion > 3) {
                        this.gestureRecognition.shake += 0.3;
                        if (this.gestureRecognition.shake > 1) {
                            this.triggerShakeEffects();
                        }
                    }

                    this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
                });

                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    const velocityX = (newX - lastMouse.x) / dt * 100;
                    const velocityY = (newY - lastMouse.y) / dt * 100;
                    
                    const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.2;
                    this.updateMotion(mouseMotion);
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
                    
                    lastMouse = { x: newX, y: newY, time: now };
                });
            }

            updateMotion(newMotion) {
                // Improved motion smoothing
                this.motion = this.motion * this.motionSmoothingFactor + newMotion * (1 - this.motionSmoothingFactor);
                
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 100) this.motionHistory.shift();
                
                this.totalMotion += this.motion;

                if (this.motion > 0.2) {
                    this.lastMotionTime = Date.now();
                    if (this.voidPhase) {
                        this.exitVoidState();
                    }
                }

                if (Date.now() - this.lastMotionTime > 10000 && !this.voidPhase) {
                    this.enterVoidState();
                }

                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = Math.sqrt(this.motionHistory.reduce((sum, m) => sum + Math.pow(m - avgMotion, 2), 0) / this.motionHistory.length);

                const recentHistory = this.motionHistory.slice(-30);
                const isRhythmic = recentHistory.filter(m => m > 1.5).length > 15;
                const isErratic = this.intensity > 2.0 && avgMotion > 1.5;
                const isSustained = avgMotion > 2.0 && this.intensity < 1.0;
                const isChaotic = this.intensity > 3.0 && avgMotion > 3.0;

                this.motionPattern = isChaotic ? 'chaotic' : 
                                 isErratic ? 'erratic' : 
                                 isRhythmic ? 'rhythmic' : 
                                 isSustained ? 'sustained' : 'calm';

                this.updateEvolution();
            }

            updateChaos() {
                // Logistic map for procedural patterns
                this.chaosR = 3.5 + (this.intensity * 0.2); // Adjust chaos based on intensity
                this.chaosX = this.chaosR * this.chaosX * (1 - this.chaosX);
                
                // Generate wobble pattern procedurally
                this.wobblePattern = [];
                let x = this.chaosX;
                for (let i = 0; i = 8; i++) {
                    x = this.chaosR * x * (1 - x);
                    this.wobblePattern.push(Math.floor(x * 12)); // Scale to semitones
                }
            }

            updateEvolution() {
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;

                if (this.voidPhase) {
                    Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
                    this.layers.pad = true;
                    this.layers.drone = true;
                    return;
                }

                this.layers.kick = this.motionPattern === 'rhythmic' || this.motionPattern === 'chaotic';
                this.layers.sub = avgMotion > 1.0;
                this.layers.hats = avgMotion > 0.5;
                this.layers.clap = this.motionPattern === 'erratic' || this.intensity > 1.5;
                this.layers.wobble = this.motionPattern !== 'calm' && avgMotion > 0.8;
                this.layers.fx = avgMotion > 0.3;
                this.layers.riser = this.intensity > 1.5 || this.motionPattern === 'chaotic';
                this.layers.sample = this.sampleBuffer && avgMotion > 1.2;

                this.evolutionProgress = Math.min(this.totalMotion / 800, 3);

                if (this.stage === 'BUILDUP' && this.totalMotion > 200) {
                    this.evolveToDrop();
                } else if (this.stage === 'DROP' && this.totalMotion > 500) {
                    this.evolveToBreakdown();
                } else if (this.stage === 'BREAKDOWN' && this.totalMotion > 800) {
                    this.evolveToRiddim();
                }

                let baseBPM = 70 + (avgMotion * 3) + (this.intensity * 2);
                if (this.stage === 'DROP') baseBPM += 10;
                else if (this.stage === 'BREAKDOWN') baseBPM -= 5;

                this.bpm = this.bpm * 0.9 + baseBPM * 0.1;
                this.bpm = Math.max(60, Math.min(100, this.bpm));

                this.updateTheme(avgMotion, this.intensity);
            }

            updateTheme(avgMotion, intensity) {
                let newTheme = 'buildup';
                
                if (this.voidPhase) newTheme = 'void';
                else if (this.motionPattern === 'chaotic' || intensity > 3) newTheme = 'riddim';
                else if (avgMotion > 3 && intensity > 2) newTheme = 'drop';
                else if (avgMotion > 1.5) newTheme = 'buildup';
                else if (avgMotion < 1 && this.totalMotion > 100) newTheme = 'breakdown';

                if (newTheme !== this.currentTheme) {
                    this.currentTheme = newTheme;
                }
            }

            enterVoidState() {
                console.log('ðŸŒŒ ENTERING HEAVENLY VOID');
                this.voidPhase = true;
                this.stage = 'VOID';
                this.elements.orb.className = 'orb void';
                this.currentTheme = 'void';
            }

            exitVoidState() {
                console.log('ðŸŒŒ EXITING VOID STATE');
                this.voidPhase = false;
                this.stage = 'BUILDUP';
                this.elements.orb.className = 'orb buildup';
                this.currentTheme = 'buildup';
                this.motionHistory = Array(100).fill(2);
                this.totalMotion += 200;
                this.evolveToBuildup();
            }

            triggerShakeEffects() {
                console.log('ðŸŒªï¸ SHAKE DETECTED');
                this.gestureRecognition.shake = 0;
                this.layers.clap = true;
                this.bpm += 5;
                if (this.intensity > 2.0 && !this.isRecording) {
                    this.startRecording();
                }
            }

            triggerDropImpact() {
                this.playDropImpact();
            }

            evolveToBuildup() {
                this.voidPhase = false;
                this.stage = 'BUILDUP';
                this.elements.orb.className = 'orb buildup';
                this.createParticles(20, '#ff00ff');
                console.log('ðŸ”¥ BUILDUP EVOLUTION');
            }

            evolveToDrop() {
                this.stage = 'DROP';
                this.elements.orb.className = 'orb drop';
                this.createParticles(30, '#00ff00');
                console.log('ðŸŒŠ DROP EVOLUTION');
            }

            evolveToBreakdown() {
                this.stage = 'BREAKDOWN';
                this.elements.orb.className = 'orb breakdown';
                this.createParticles(40, '#ff9900');
                console.log('âœ¨ BREAKDOWN EVOLUTION');
            }

            evolveToRiddim() {
                this.stage = 'RIDDIM';
                this.elements.orb.className = 'orb riddim';
                this.createParticles(50, '#ffff00');
                console.log('ðŸŒŒ RIDDIM EVOLUTION');
            }

            createParticles(count, color) {
                const existing = document.querySelector('.particles');
                if (existing) existing.remove();

                const container = document.createElement('div');
                container.className = 'particles';
                document.body.appendChild(container);

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = Math.random() * 8 + 's';
                    particle.style.animationDuration = (4 + Math.random() * 6) + 's';
                    container.appendChild(particle);
                }
            }

            updatePosition() {
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;

                if (this.pos.x < 10 || this.pos.x > 90) this.velocity.x *= -0.6;
                if (this.pos.y < 10 || this.pos.y > 90) this.velocity.y *= -0.6;

                this.pos.x = Math.max(10, Math.min(90, this.pos.x));
                this.pos.y = Math.max(10, Math.min(90, this.pos.y));

                this.velocity.x *= 0.95;
                this.velocity.y *= 0.95;
            }

            startSequencer() {
                const tick = () => {
                    if (!this.active) return;
                    
                    this.playStep();
                    this.step = (this.step + 1) % this.sectionLength;
                    
                    if (this.step === 0) {
                        this.phraseCount++;
                        this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
                        this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
                    }
                    
                    const interval = (60 / this.bpm) * 250;
                    setTimeout(tick, interval);
                };
                tick();
            }

            playStep() {
                if (this.voidPhase) {
                    if (Math.random() < 0.1) this.playHealingDrone();
                    if (Math.random() < 0.05) this.playPad();
                    return;
                }

                if (this.step % 4 === 0) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }

                // Rhythmic patterns
                if (this.layers.kick && this.step % 4 === 0) this.playKick();
                if (this.layers.sub && this.step % 4 === 0) this.playSub();
                if (this.layers.hats && this.step % 2 === 0) this.playHats();
                if (this.layers.clap && this.step % 8 === 4) this.playClap();
                if (this.layers.wobble && this.step % 1 === 0) this.playWobble();
                if (this.layers.fx && Math.random() < 0.05) this.playFx();
                if (this.layers.riser && this.step % 16 === 0) this.playRiser();
                if (this.layers.pad && this.step % 8 === 0) this.playPad();
                if (this.layers.sample && this.step % 2 === 0) this.playGrain(); // Play grain on every other step

                // Decay gesture recognition
                Object.keys(this.gestureRecognition).forEach(key => {
                    this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.02);
                });
            }

            // Sound generation methods omitted for brevity, assume they are the same as before

            // ... (include all the playKick, playSub, etc. methods from the previous code)

            allocateVoice(layer, source, gainNode, duration) {
                const pool = this.voicePool[layer];
                if (!pool) return false;

                pool.active = pool.active.filter(voice => {
                    if (this.ctx.currentTime > voice.startTime + voice.duration + 0.1) {
                        if (voice.source && voice.source.stop) {
                            try { voice.source.stop(); } catch(e) {}
                        }
                        return false;
                    }
                    return true;
                });

                if (pool.active.length >= pool.max) {
                    const oldest = pool.active.shift();
                    if (oldest && oldest.source && oldest.source.stop) {
                        try { oldest.source.stop(); } catch(e) {}
                    }
                }

                const voice = { 
                    source, 
                    gain: gainNode, 
                    startTime: this.ctx.currentTime,
                    duration 
                };
                pool.active.push(voice);

                return true;
            }

            noteToFreq(note, octave = 4) {
                const semitones = this.keyOffsets[this.key] + note;
                return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
            }

            animate() {
                const loop = () => {
                    if (!this.active) return;

                    // Update orb position
                    this.elements.orb.style.left = this.pos.x + '%';
                    this.elements.orb.style.top = this.pos.y + '%';

                    // Update background based on current theme and motion
                    const intensityNorm = Math.min(this.intensity / 3, 1);
                    const motionNorm = Math.min(this.motion / 4, 1);

                    let bg;
                    if (this.voidPhase) {
                        const breathe = Math.sin(Date.now() / 2000) * 0.3 + 0.7;
                        bg = `radial-gradient(circle at 50% 50%, rgba(75, 0, 130, ${0.1 * breathe}) 10%, #000000 60%)`;
                    } else {
                        const colors = {
                            buildup: ['#ff00ff', '#000000'],
                            drop: ['#00ff00', '#000000'],
                            breakdown: ['#ff9900', '#ff00ff'],
                            riddim: ['#ffff00', '#ff0000']
                        };
                        
                        const themeColors = colors[this.currentTheme] || colors.buildup;
                        bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
                        bg += `${themeColors[0]} ${5 * motionNorm}%, `;
                        bg += `${themeColors[1]} ${30 * intensityNorm}%, `;
                        bg += `#000000 ${70 + 20 * intensityNorm}%)`;
                    }

                    document.body.style.background = bg;

                    // Update 3D panning
                    const panMultiplier = 2;
                    const targetX = Math.cos(this.direction * Math.PI / 180) * this.motion * panMultiplier;
                    const targetY = Math.sin(this.direction * Math.PI / 180) * this.motion * panMultiplier;

                    Object.keys(this.layerPanners).forEach(name => {
                        const basePos = this.basePositions[name];
                        const currentPos = this.layerPositions[name];
                        
                        const newX = basePos.x + targetX * 0.5;
                        const newY = basePos.y + targetY * 0.3;
                        
                        currentPos.x += (newX - currentPos.x) * this.panningLerp;
                        currentPos.y += (newY - currentPos.y) * this.panningLerp;

                        if (this.layerPanners[name]) {
                            this.layerPanners[name].positionX.value = currentPos.x;
                            this.layerPanners[name].positionY.value = currentPos.y;
                            this.layerPanners[name].positionZ.value = currentPos.z;
                        }
                    });

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
        }

        // Initialize the engine
        new GUMPEngine2025();
    </script>
</body>
</html>
