<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OMNI // SPECTRAL_DESTRUCTOR</title>
    <style>
        :root { --glitch-green: #00ff41; --dead-black: #050505; --warning: #ff003c; }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Consolas', monospace; }
        body { background: var(--dead-black); color: var(--glitch-green); overflow: hidden; height: 100vh; }
        
        #stage { position: absolute; inset: 0; z-index: 1; opacity: 0.9; }
        .ui-overlay { position: absolute; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; padding: 40px; }
        
        .header { display: flex; justify-content: space-between; font-size: 11px; letter-spacing: 3px; border-bottom: 1px solid rgba(0, 255, 65, 0.2); padding-bottom: 10px; }
        
        .matrix-container { display: grid; grid-template-columns: repeat(4, 1fr); gap: 20px; margin-top: 20px; }
        .matrix-node { border: 1px solid rgba(0, 255, 65, 0.1); padding: 15px; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); }
        .node-label { font-size: 9px; opacity: 0.5; margin-bottom: 10px; }
        .node-val { font-size: 18px; font-weight: bold; }

        .console { margin-top: auto; height: 200px; border: 1px solid rgba(0, 255, 65, 0.1); padding: 15px; font-size: 10px; overflow: hidden; line-height: 1.6; }
        .btn-init { 
            pointer-events: auto; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: none; border: 1px solid var(--glitch-green); color: var(--glitch-green);
            padding: 40px 80px; font-size: 24px; cursor: pointer; letter-spacing: 15px;
            box-shadow: 0 0 50px rgba(0, 255, 65, 0.2); transition: 0.5s cubic-bezier(0.19, 1, 0.22, 1);
        }
        .btn-init:hover { background: var(--glitch-green); color: black; }
    </style>
</head>
<body>

<canvas id="stage"></canvas>

<div class="ui-overlay">
    <div class="header">
        <div>CORE_SYSTEM_v2.09_BETA</div>
        <div id="sync-status">STRETCH_RATIO: 1.000</div>
    </div>

    <div class="matrix-container">
        <div class="matrix-node"><div class="node-label">SPECTRAL_FLUX</div><div class="node-val" id="val-flux">0.00</div></div>
        <div class="matrix-node"><div class="node-label">TRANSIENT_DENSITY</div><div class="node-val" id="val-trans">0.00</div></div>
        <div class="matrix-node"><div class="node-label">HARMONIC_WEIGHT</div><div class="node-val" id="val-harm">0.00</div></div>
        <div class="matrix-node"><div class="node-label">BUFFER_SATURATION</div><div class="node-val" id="val-sat">0%</div></div>
    </div>

    <div class="console" id="console-log"></div>
</div>

<button class="btn-init" id="boot">ACTIVATE</button>

<script>
/**
 * OMNI-ENGINE: PROBABILISTIC SPECTRAL RESYNTHESIZER
 * Designed for real-time deconstruction of environmental acoustics.
 */

class OmniEngine {
    constructor() {
        this.ctx = null;
        this.nodes = {};
        this.memory = {
            buffer: null,
            size: 44100 * 8, // 8 Second High-Resolution Buffer
            ptr: 0,
            spectralHistory: new Float32Array(256)
        };
        
        this.physics = { entropy: 0, gravity: 0, jitter: 0 };
        this.isRunning = false;
    }

    async boot() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive',
            sampleRate: 44100
        });

        // 1. ADVANCED DSP CHAIN
        this.nodes.master = this.ctx.createGain();
        this.nodes.limiter = this.ctx.createDynamicsCompressor();
        this.nodes.limiter.threshold.setValueAtTime(-1, this.ctx.currentTime);
        this.nodes.limiter.ratio.setValueAtTime(20, this.ctx.currentTime);
        
        this.nodes.master.connect(this.nodes.limiter);
        this.nodes.limiter.connect(this.ctx.destination);

        // 2. INPUT DECONSTRUCTION
        const stream = await navigator.mediaDevices.getUserMedia({ 
            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } 
        });
        this.nodes.input = this.ctx.createMediaStreamSource(stream);
        
        this.nodes.analyser = this.ctx.createAnalyser();
        this.nodes.analyser.fftSize = 2048;
        this.nodes.analyser.smoothingTimeConstant = 0.2;
        this.nodes.input.connect(this.nodes.analyser);

        // 3. MEMORY ALLOCATION
        this.memory.buffer = new Float32Array(this.memory.size);
        this.log("ALLOCATING 8s NEURAL RAM... OK");
        
        this.setupSensors();
        this.runKernel();
        this.visualize();
    }

    log(msg) {
        const c = document.getElementById('console-log');
        c.innerHTML = `<div>[${performance.now().toFixed(2)}] ${msg}</div>` + c.innerHTML;
    }

    setupSensors() {
        window.addEventListener('devicemotion', (e) => {
            this.physics.jitter = Math.abs(e.acceleration.x + e.acceleration.y + e.acceleration.z);
            this.physics.entropy = Math.min(this.physics.jitter / 10, 1.0);
        });
    }

    runKernel() {
        // This is the High-Frequency Processing Loop
        const process = () => {
            if(!this.isRunning) return;
            
            // Analyze Spectral Flux
            const freqData = new Uint8Array(this.nodes.analyser.frequencyBinCount);
            this.nodes.analyser.getByteFrequencyData(freqData);
            
            let flux = 0;
            for(let i=0; i<freqData.length; i++) {
                flux += Math.abs(freqData[i] - this.memory.spectralHistory[i]);
                this.memory.spectralHistory[i] = freqData[i];
            }
            
            const normalizedFlux = flux / freqData.length;
            document.getElementById('val-flux').textContent = normalizedFlux.toFixed(2);
            
            // HEURISTIC SEQUENCER
            // Instead of a clock, we use Flux-triggered events
            if (normalizedFlux > (20 - (this.physics.entropy * 10))) {
                this.synthesizeGrain(normalizedFlux);
            }

            requestAnimationFrame(process);
        };

        // Separate thread for recording
        const recorder = this.ctx.createScriptProcessor(4096, 1, 1);
        this.nodes.input.connect(recorder);
        recorder.connect(this.ctx.destination);
        recorder.onaudioprocess = (e) => {
            const data = e.inputBuffer.getChannelData(0);
            this.memory.buffer.set(data, this.memory.ptr);
            this.memory.ptr = (this.memory.ptr + data.length) % this.memory.size;
            document.getElementById('val-sat').textContent = Math.floor((this.memory.ptr / this.memory.size) * 100) + '%';
        };

        this.isRunning = true;
        process();
        this.log("KERNEL STABLE. ENTROPY ENGINE ACTIVE.");
    }

    /**
     * STOCHASTIC RESYNTHESIS
     * This is where the "Future Beat" happens. 
     * It uses a Cosine-Windowed Grain to reconstruct audio based on motion.
     */
    synthesizeGrain(energy) {
        const now = this.audioContextTime();
        const dur = 0.05 + (this.physics.entropy * 0.5); // Movement stretches time
        
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * dur, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Jitter-Correction: Find a slice in memory
        const startPos = Math.floor(Math.random() * (this.memory.size - (this.ctx.sampleRate * dur)));
        
        for(let i=0; i<data.length; i++) {
            // Apply Hanning Window to prevent zero-crossing clicks
            const window = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (data.length - 1)));
            data[i] = this.memory.buffer[startPos + i] * window;
        }

        const src = this.ctx.createBufferSource();
        src.buffer = buffer;
        
        // PITCH MANIPULATION
        // We calculate playback rate based on current device orientation
        src.playbackRate.value = 0.5 + (energy / 50);

        const filter = this.ctx.createBiquadFilter();
        filter.type = "bandpass";
        filter.frequency.value = 200 + (energy * 100);
        filter.Q.value = 5;

        const g = this.ctx.createGain();
        g.gain.setValueAtTime(0, now);
        g.gain.linearRampToValueAtTime(0.6, now + 0.01);
        g.gain.exponentialRampToValueAtTime(0.001, now + dur);

        src.connect(filter);
        filter.connect(g);
        g.connect(this.nodes.master);
        
        src.start(now);
    }

    audioContextTime() { return this.ctx.currentTime; }

    visualize() {
        const canvas = document.getElementById('stage');
        const g = canvas.getContext('2d');
        const freqData = new Uint8Array(this.nodes.analyser.frequencyBinCount);

        const render = () => {
            requestAnimationFrame(render);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            this.nodes.analyser.getByteFrequencyData(freqData);

            g.fillStyle = '#050505';
            g.fillRect(0,0, canvas.width, canvas.height);

            // Draw "The Ghost" - Spectral trails
            for(let i=0; i<freqData.length; i+=4) {
                const barH = (freqData[i] / 255) * canvas.height;
                g.fillStyle = `rgba(0, 255, 65, ${freqData[i]/255})`;
                g.fillRect(i * 4, canvas.height - barH, 2, barH);
                
                // Neural web lines
                if (freqData[i] > 200) {
                    g.strokeStyle = 'rgba(0, 255, 65, 0.2)';
                    g.beginPath();
                    g.moveTo(i * 4, canvas.height - barH);
                    g.lineTo(canvas.width / 2, canvas.height / 2);
                    g.stroke();
                }
            }
        };
        render();
    }
}

const engine = new OmniEngine();
document.getElementById('boot').onclick = (e) => {
    e.target.style.display = 'none';
    engine.boot();
};

</script>
</body>
</html>
