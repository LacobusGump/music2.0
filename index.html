<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

    <title>GUMP: Meta Engine</title>

    <style>

        :root {

            --phi: 1.618033988749895;

            --bg: #000;

            --glow: #ff00ff;

        }

      

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

            -webkit-tap-highlight-color: transparent;

        }

      

        body {

            background: var(--bg);

            overflow: hidden;

            height: 100vh;

            font-family: -apple-system, sans-serif;

            font-weight: 100;

            cursor: none;

        }

      

        /* Custom Cursor */

        .cursor {

            position: fixed;

            width: 20px;

            height: 20px;

            border: 1px solid var(--glow);

            border-radius: 50%;

            pointer-events: none;

            z-index: 10000;

            mix-blend-mode: screen;

            transition: transform 0.1s ease;

        }

      

        .cursor-trail {

            position: fixed;

            width: 40px;

            height: 40px;

            background: radial-gradient(circle, var(--glow) 0%, transparent 70%);

            border-radius: 50%;

            pointer-events: none;

            opacity: 0.2;

            z-index: 9999;

        }

      

        /* Fibonacci Spiral Layout */

        .fibonacci-container {

            position: fixed;

            inset: 0;

            display: flex;

            align-items: center;

            justify-content: center;

        }

      

        .golden-rect {

            position: absolute;

            border: 1px solid rgba(255,0,255,0.1);

            pointer-events: none;

        }

      

        /* Core Orb - Center of Spiral */

        .core-orb {

            width: 233px;

            height: 233px;

            position: absolute;

            top: 50%;

            left: 38.2%;

            transform: translate(-50%, -50%);

            cursor: pointer;

            z-index: 100;

        }

      

        .orb-inner {

            width: 100%;

            height: 100%;

            border-radius: 50%;

            background: radial-gradient(circle at 38.2% 38.2%,

                rgba(255,255,255,0.2) 0%,

                var(--glow) 23.6%,

                rgba(255,0,255,0.5) 38.2%,

                rgba(138,0,255,0.3) 61.8%,

                transparent 100%);

            box-shadow: 0 0 100px var(--glow),

                       inset 0 0 50px rgba(255,255,255,0.2);

            animation: breathe 4s ease-in-out infinite;

        }

      

        @keyframes breathe {

            0%, 100% { transform: scale(1) rotate(0deg); filter: brightness(1); }

            50% { transform: scale(1.05) rotate(180deg); filter: brightness(1.3); }

        }

      

        .orb-ring {

            position: absolute;

            inset: -20px;

            border-radius: 50%;

            background: conic-gradient(from 0deg,

                transparent,

                var(--glow),

                transparent,

                var(--glow),

                transparent);

            animation: spin 10s linear infinite;

            opacity: 0.5;

        }

      

        @keyframes spin {

            100% { transform: rotate(360deg); }

        }

      

        /* Sample Nodes - Fibonacci Positions */

        .sample-node {

            position: absolute;

            width: 55px;

            height: 55px;

            border-radius: 50%;

            background: radial-gradient(circle at center,

                rgba(255,0,255,0.2) 0%,

                transparent 61.8%);

            border: 1px solid rgba(255,0,255,0.3);

            cursor: pointer;

            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

            display: flex;

            align-items: center;

            justify-content: center;

            font-size: 8px;

            color: var(--glow);

            opacity: 0.5;

        }

      

        .sample-node.loaded {

            background: radial-gradient(circle at center,

                var(--glow) 0%,

                rgba(255,0,255,0.5) 38.2%,

                transparent 100%);

            opacity: 1;

            animation: pulse 2s ease-in-out infinite;

        }

      

        @keyframes pulse {

            0%, 100% { transform: scale(1); }

            50% { transform: scale(1.1); }

        }

      

        .sample-node.playing {

            box-shadow: 0 0 30px var(--glow);

            transform: scale(0.9);

        }

      

        /* Spectrum Visualizer - Full Screen */

        .spectrum-canvas {

            position: fixed;

            inset: 0;

            opacity: 0.5;

            pointer-events: none;

            mix-blend-mode: screen;

        }

      

        /* Waveform Scope */

        .waveform-scope {

            position: fixed;

            bottom: 34px;

            left: 50%;

            transform: translateX(-50%);

            width: 377px;

            height: 89px;

            border: 1px solid rgba(255,0,255,0.2);

            background: rgba(0,0,0,0.5);

            opacity: 0.7;

        }

      

        /* Info Overlay */

        .info-overlay {

            position: fixed;

            top: 21px;

            left: 21px;

            font-size: 13px;

            color: rgba(255,255,255,0.5);

            letter-spacing: 2px;

            text-transform: uppercase;

            line-height: 1.618;

        }

      

        .info-value {

            color: var(--glow);

            font-weight: 300;

        }

      

        /* Control Gestures */

        .gesture-indicator {

            position: fixed;

            bottom: 21px;

            right: 21px;

            font-size: 11px;

            color: rgba(255,255,255,0.3);

            text-align: right;

            line-height: 1.618;

        }

      

        /* Particle System */

        .particle {

            position: fixed;

            width: 2px;

            height: 2px;

            background: var(--glow);

            pointer-events: none;

            border-radius: 50%;

        }

      

        /* Start Screen */

        .start-screen {

            position: fixed;

            inset: 0;

            background: var(--bg);

            display: flex;

            align-items: center;

            justify-content: center;

            z-index: 1000;

            cursor: pointer;

        }

      

        .start-text {

            font-size: 144px;

            font-weight: 100;

            color: var(--glow);

            opacity: 0;

            animation: fadeIn 2s ease forwards;

            text-shadow: 0 0 50px var(--glow);

        }

      

        @keyframes fadeIn {

            to { opacity: 1; }

        }

      

        /* Atmospheric Layers */

        .atmosphere-layer {

            position: fixed;

            inset: 0;

            pointer-events: none;

            opacity: 0.03;

        }

      

        .atmosphere-1 {

            background: radial-gradient(circle at 61.8% 38.2%, var(--glow) 0%, transparent 50%);

            animation: drift1 34s ease-in-out infinite;

        }

      

        .atmosphere-2 {

            background: radial-gradient(circle at 38.2% 61.8%, rgba(138,0,255,1) 0%, transparent 50%);

            animation: drift2 55s ease-in-out infinite;

        }

      

        @keyframes drift1 {

            0%, 100% { transform: translate(0, 0) scale(1); }

            50% { transform: translate(-34px, 21px) scale(1.2); }

        }

      

        @keyframes drift2 {

            0%, 100% { transform: translate(0, 0) scale(1); }

            50% { transform: translate(21px, -34px) scale(0.8); }

        }

      

        /* Mobile Optimization */

        @media (max-width: 768px) {

            .start-text { font-size: 89px; }

            .waveform-scope { width: 233px; }

            .info-overlay { font-size: 11px; }

            .cursor, .cursor-trail { display: none; }

        }

        /* Mic Warning */

        .mic-warning {

            position: fixed;

            bottom: 50px;

            left: 50%;

            transform: translateX(-50%);

            font-size: 14px;

            color: red;

            background: rgba(0,0,0,0.7);

            padding: 10px 20px;

            border-radius: 5px;

            z-index: 1000;

        }

    </style>

</head>

<body>

    <!-- Cursor -->

    <div class="cursor" id="cursor"></div>

    <div class="cursor-trail" id="cursorTrail"></div>

  

    <!-- Start -->

    <div class="start-screen" id="startScreen">

        <div class="start-text">GUMP</div>

    </div>

  

    <!-- Atmosphere -->

    <div class="atmosphere-layer atmosphere-1"></div>

    <div class="atmosphere-layer atmosphere-2"></div>

  

    <!-- Main -->

    <div class="fibonacci-container" id="mainContainer" style="display: none;">

        <!-- Golden Rectangles -->

        <div class="golden-rect" style="width: 610px; height: 377px; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>

        <div class="golden-rect" style="width: 377px; height: 233px; top: 50%; left: 50%; transform: translate(-31%, -50%);"></div>

        <div class="golden-rect" style="width: 233px; height: 144px; top: 50%; left: 50%; transform: translate(-19%, -31%);"></div>

      

        <!-- Core Orb -->

        <div class="core-orb" id="coreOrb">

            <div class="orb-ring"></div>

            <div class="orb-inner"></div>

        </div>

      

        <!-- Sample Nodes -->

        <div id="sampleNodes"></div>

    </div>

  

    <!-- Visualizers -->

    <canvas class="spectrum-canvas" id="spectrumCanvas"></canvas>

    <canvas class="waveform-scope" id="waveformScope"></canvas>

  

    <!-- Info -->

    <div class="info-overlay" id="info">

        <div><span class="info-value" id="bpm">120</span> BPM</div>

        <div><span class="info-value" id="key">A</span> MINOR</div>

        <div>COMPLEXITY <span class="info-value" id="complexity">0</span>%</div>

        <div>SAMPLES <span class="info-value" id="samples">0</span></div>

    </div>

  

    <!-- Gestures -->

    <div class="gesture-indicator">

        CLICK: CAPTURE<br>

        MOVE: MODULATE<br>

        SPACE: CLEAR

    </div>

    <script>

        'use strict';

        class GUMPMeta {

            constructor() {

                this.ctx = null;

                this.isRunning = false;

              

                // Buses & Effects

                this.master = null;

                this.buses = {};

                this.effects = {};

              

                // Samples & Synthesis

                this.samples = new Map();

                this.nodes = [];

                this.currentNodeIndex = 0;

              

                // Musical State

                this.bpm = 120;

                this.key = 'A';

                this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor

                this.currentBar = 0;

                this.nextEventTime = 0;

              

                // AI State

                this.complexity = 0;

                this.energy = 0.5;

                this.pattern = null;

              

                // Ambient Capture

                this.micStream = null;

                this.isListening = false;

                this.captureBuffer = [];

                this.hasMic = false;

              

                // UI

                this.ui = {};

                this.mouseX = 0;

                this.mouseY = 0;

              

                // Visualization

                this.analyser = null;

                this.scopeAnalyser = null;

              

                this.init();

            }

          

            init() {

                // Cache elements

                ['startScreen', 'mainContainer', 'coreOrb', 'sampleNodes',

                 'spectrumCanvas', 'waveformScope', 'cursor', 'cursorTrail',

                 'bpm', 'key', 'complexity', 'samples', 'info'].forEach(id => {

                    this.ui[id] = document.getElementById(id);

                });

              

                // Create sample nodes in Fibonacci positions

                this.createFibonacciNodes();

              

                // Events

                this.ui.startScreen.addEventListener('click', () => this.start());

                this.ui.coreOrb.addEventListener('click', () => this.captureNow());

                document.addEventListener('keydown', e => this.handleKey(e));

                document.addEventListener('mousemove', e => this.handleMouse(e));

                document.addEventListener('touchmove', e => this.handleTouch(e));

              

                // Setup visualizers

                this.setupVisualizers();

            }

          

            async start() {

                // Create audio context

                this.ctx = new (window.AudioContext || window.webkitAudioContext)({

                    latencyHint: 'playback',

                    sampleRate: 48000

                });

              

                await this.ctx.resume();

              

                // Initialize audio system

                await this.initAudio();

              

                // Setup microphone

                await this.setupMic();

              

                // Start engines

                this.startSequencer();

                this.startAmbientCapture();

              

                // UI transition

                this.ui.startScreen.style.display = 'none';

                this.ui.mainContainer.style.display = 'block';

              

                // Start visuals

                this.animate();

              

                // Immediate bass drone

                this.startDrone();

              

                // Start with high complexity for chaotic beginning

                this.complexity = 100;

                this.ui.complexity.textContent = Math.floor(this.complexity);

              

                this.isRunning = true;

              

                // Show mic warning if no access

                if (!this.hasMic) {

                    const warning = document.createElement('div');

                    warning.className = 'mic-warning';

                    warning.textContent = 'Microphone access denied or unavailable. Using generated samples instead. For real ambient sampling, serve this file over HTTP/HTTPS (not file://) and grant permission.';

                    document.body.appendChild(warning);

                }

            }

          

            async initAudio() {

                // Master chain

                this.master = this.ctx.createGain();

                this.master.gain.value = 0.9;

              

                // Analyzers

                this.analyser = this.ctx.createAnalyser();

                this.analyser.fftSize = 4096;

              

                this.scopeAnalyser = this.ctx.createAnalyser();

                this.scopeAnalyser.fftSize = 2048;

              

                // Buses

                this.buses.sub = this.ctx.createGain();

                this.buses.bass = this.ctx.createGain();

                this.buses.mid = this.ctx.createGain();

                this.buses.high = this.ctx.createGain();

                this.buses.air = this.ctx.createGain();

              

                // Create high-end effects chain

                await this.createEffects();

              

                // Routing

                Object.values(this.buses).forEach(bus => {

                    bus.connect(this.effects.eq.input);

                });

              

                this.effects.eq.connect(this.effects.multiband);

                this.effects.multiband.connect(this.effects.space.input);

                this.effects.space.connect(this.effects.comp);

                this.effects.comp.connect(this.effects.saturator);

                this.effects.saturator.connect(this.effects.limiter);

                this.effects.limiter.connect(this.master);

              

                this.master.connect(this.analyser);

                this.master.connect(this.scopeAnalyser);

                this.master.connect(this.ctx.destination);

            }

          

            async createEffects() {

                // Parametric EQ

                this.effects.eq = {

                    input: this.ctx.createGain(),

                    low: this.ctx.createBiquadFilter(),

                    lowMid: this.ctx.createBiquadFilter(),

                    highMid: this.ctx.createBiquadFilter(),

                    high: this.ctx.createBiquadFilter(),

                    output: this.ctx.createGain()

                };

              

                this.effects.eq.low.type = 'lowshelf';

                this.effects.eq.low.frequency.value = 100;

                this.effects.eq.low.gain.value = 3;

              

                this.effects.eq.lowMid.type = 'peaking';

                this.effects.eq.lowMid.frequency.value = 250;

                this.effects.eq.lowMid.Q.value = 0.5;

                this.effects.eq.lowMid.gain.value = -2;

              

                this.effects.eq.highMid.type = 'peaking';

                this.effects.eq.highMid.frequency.value = 3000;

                this.effects.eq.highMid.Q.value = 0.7;

                this.effects.eq.highMid.gain.value = 2;

              

                this.effects.eq.high.type = 'highshelf';

                this.effects.eq.high.frequency.value = 10000;

                this.effects.eq.high.gain.value = 4;

              

                this.effects.eq.input.connect(this.effects.eq.low);

                this.effects.eq.low.connect(this.effects.eq.lowMid);

                this.effects.eq.lowMid.connect(this.effects.eq.highMid);

                this.effects.eq.highMid.connect(this.effects.eq.high);

                this.effects.eq.high.connect(this.effects.eq.output);

              

                this.effects.eq.connect = (dest) => this.effects.eq.output.connect(dest);

              

                // Multiband Dynamics

                this.effects.multiband = this.ctx.createDynamicsCompressor();

                this.effects.multiband.threshold.value = -24;

                this.effects.multiband.knee.value = 12;

                this.effects.multiband.ratio.value = 3;

                this.effects.multiband.attack.value = 0.003;

                this.effects.multiband.release.value = 0.1;

              

                // Bus Compressor

                this.effects.comp = this.ctx.createDynamicsCompressor();

                this.effects.comp.threshold.value = -12;

                this.effects.comp.knee.value = 6;

                this.effects.comp.ratio.value = 4;

                this.effects.comp.attack.value = 0.01;

                this.effects.comp.release.value = 0.05;

              

                // Spatial Processor

                this.effects.space = await this.createSpace();

              

                // Tape Saturator

                this.effects.saturator = this.ctx.createWaveShaper();

                this.effects.saturator.curve = this.makeSaturationCurve(10);

                this.effects.saturator.oversample = '4x';

              

                // Brickwall Limiter

                this.effects.limiter = this.ctx.createDynamicsCompressor();

                this.effects.limiter.threshold.value = -0.5;

                this.effects.limiter.knee.value = 0;

                this.effects.limiter.ratio.value = 20;

                this.effects.limiter.attack.value = 0.001;

                this.effects.limiter.release.value = 0.01;

            }

          

            async createSpace() {

                const convolver = this.ctx.createConvolver();

              

                // Create dark hall reverb

                const length = this.ctx.sampleRate * 6;

                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);

              

                for (let ch = 0; ch < 2; ch++) {

                    const data = impulse.getChannelData(ch);

                  

                    for (let i = 0; i < length; i++) {

                        const decay = Math.pow(1 - i / length, 1.5);

                      

                        // Early reflections

                        if (i < this.ctx.sampleRate * 0.1) {

                            if (i % Math.floor(this.ctx.sampleRate * 0.013) === 0) {

                                data[i] = (Math.random() - 0.5) * 0.5 * decay;

                            }

                        }

                      

                        // Diffuse field

                        data[i] += (Math.random() - 0.5) * decay * 0.3;

                      

                        // Low-pass decay

                        if (i > 0) {

                            const cutoff = 0.99 - (i / length) * 0.7;

                            data[i] = data[i] * (1 - cutoff) + data[i-1] * cutoff;

                        }

                    }

                }

              

                convolver.buffer = impulse;

              

                // Wet/dry mix

                const input = this.ctx.createGain();

                const dry = this.ctx.createGain();

                const wet = this.ctx.createGain();

                const output = this.ctx.createGain();

              

                dry.gain.value = 0.7;

                wet.gain.value = 0.3;

              

                input.connect(dry);

                input.connect(convolver);

                convolver.connect(wet);

              

                const merger = this.ctx.createGain();

                dry.connect(merger);

                wet.connect(merger);

                merger.connect(output);

              

                return {

                    input,

                    connect: (dest) => output.connect(dest)

                };

            }

          

            async setupMic() {

                try {

                    const stream = await navigator.mediaDevices.getUserMedia({

                        audio: {

                            echoCancellation: false,

                            noiseSuppression: false,

                            autoGainControl: false

                        }

                    });

                  

                    this.micStream = this.ctx.createMediaStreamSource(stream);

                    const micGain = this.ctx.createGain();

                    micGain.gain.value = 1;

                  

                    const processor = this.ctx.createScriptProcessor(4096, 1, 1);

                    processor.onaudioprocess = (e) => {

                        if (this.isListening) {

                            const data = e.inputBuffer.getChannelData(0);

                            this.processAmbientAudio(data);

                        }

                    };

                  

                    const mute = this.ctx.createGain();

                    mute.gain.value = 0;

                  

                    this.micStream.connect(micGain);

                    micGain.connect(processor);

                    processor.connect(mute);

                    mute.connect(this.ctx.destination);

                  

                    this.hasMic = true;

                } catch (e) {

                    console.error('Mic access failed:', e);

                    this.hasMic = false;

                }

            }

          

            startDrone() {

                // Deep sub bass drone

                const osc = this.ctx.createOscillator();

                osc.type = 'sine';

                osc.frequency.value = 55; // A1

              

                const osc2 = this.ctx.createOscillator();

                osc2.type = 'sine';

                osc2.frequency.value = 55.5; // Slight detune for thickness

              

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(0, this.ctx.currentTime);

                gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 2);

              

                osc.connect(gain);

                osc2.connect(gain);

                gain.connect(this.buses.sub);

              

                osc.start();

                osc2.start();

              

                // Modulate drone

                const lfo = this.ctx.createOscillator();

                lfo.frequency.value = 0.1;

                const lfoGain = this.ctx.createGain();

                lfoGain.gain.value = 0.5;

              

                lfo.connect(lfoGain);

                lfoGain.connect(osc.frequency);

                lfo.start();

            }

          

            startSequencer() {

                const schedule = () => {

                    while (this.nextEventTime < this.ctx.currentTime + 0.1) {

                        const bar = Math.floor(this.currentBar / 16);

                        const step = this.currentBar % 16;

                      

                        // Generate pattern if needed

                        if (step === 0 && bar % 4 === 0) {

                            this.generatePattern();

                        }

                      

                        // Play pattern

                        if (this.pattern) {

                            this.playStep(step, this.nextEventTime);

                        }

                      

                        // Advance

                        this.nextEventTime += 60 / this.bpm / 4;

                        this.currentBar++;

                      

                        // Evolve complexity every bar

                        if (this.currentBar % 16 === 0) {

                            this.complexity = Math.max(0, this.complexity - 1);

                            this.ui.complexity.textContent = Math.floor(this.complexity);

                        }

                    }

                  

                    setTimeout(schedule, 25);

                };

              

                this.nextEventTime = this.ctx.currentTime;

                schedule();

            }

          

            generatePattern() {

                // Evolve complexity (decreasing for settling)

                this.pattern = {

                    kick: this.generateKickPattern(),

                    bass: this.generateBassPattern(),

                    perc: this.generatePercPattern(),

                    hats: this.generateHatsPattern(),

                    atm: Math.random() < 0.3

                };

            }

          

            generateKickPattern() {

                const pattern = new Array(16).fill(false);

              

                // Four on floor base

                for (let i = 0; i < 16; i += 4) {

                    pattern[i] = true;

                }

              

                // Add complexity (more in chaotic phase)

                if (this.complexity > 30) {

                    pattern[14] = Math.random() < (this.complexity / 100);

                }

              

                if (this.complexity > 60) {

                    pattern[7] = Math.random() < (this.complexity / 100);

                }

              

                return pattern;

            }

          

            generateBassPattern() {

                const pattern = new Array(16).fill(null);

                const progression = [0, 0, 5, 3, 0, 0, 7, 3];

              

                for (let i = 0; i < 16; i += 2) {

                    if (Math.random() < 0.8) {

                        pattern[i] = progression[Math.floor(i/2) % progression.length];

                    }

                }

              

                return pattern;

            }

          

            generatePercPattern() {

                const pattern = new Array(16).fill(false);

              

                for (let i = 0; i < 16; i++) {

                    if (i % 2 === 1) {

                        pattern[i] = Math.random() < (0.3 + this.complexity / 200);

                    }

                }

              

                return pattern;

            }

          

            generateHatsPattern() {

                const pattern = new Array(16).fill(false);

              

                for (let i = 1; i < 16; i += 2) {

                    pattern[i] = Math.random() < (0.5 + (100 - this.complexity) / 200);

                }

              

                return pattern;

            }

          

            playStep(step, time) {

                // Visual pulse

                if (step % 4 === 0) {

                    setTimeout(() => {

                        this.ui.coreOrb.style.filter = 'brightness(1.5)';

                        setTimeout(() => {

                            this.ui.coreOrb.style.filter = 'brightness(1)';

                        }, 50);

                    }, (time - this.ctx.currentTime) * 1000);

                }

              

                // Kick

                if (this.pattern.kick[step]) {

                    this.playKick(time);

                }

              

                // Bass

                if (this.pattern.bass[step] !== null) {

                    this.playBass(this.pattern.bass[step], time);

                }

              

                // Percussion

                if (this.pattern.perc[step]) {

                    this.playPerc(time);

                }

              

                // Hats

                if (this.pattern.hats[step]) {

                    this.playHat(time);

                }

              

                // Samples

                this.nodes.forEach((node, idx) => {

                    const sample = this.samples.get(idx);

                    if (sample && sample.pattern && sample.pattern[step]) {

                        this.playSample(idx, time);

                    }

                });

            }

          

            playKick(time) {

                const osc = this.ctx.createOscillator();

                osc.type = 'sine';

                osc.frequency.setValueAtTime(150, time);

                osc.frequency.exponentialRampToValueAtTime(30, time + 0.5);

              

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(1, time);

                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

              

                const dist = this.ctx.createWaveShaper();

                dist.curve = this.makeSaturationCurve(20);

              

                osc.connect(gain);

                gain.connect(dist);

                dist.connect(this.buses.bass);

              

                osc.start(time);

                osc.stop(time + 0.5);

            }

          

            playBass(note, time) {

                const freq = 55 * Math.pow(2, this.scale[note] / 12);

              

                const osc1 = this.ctx.createOscillator();

                osc1.type = 'sawtooth';

                osc1.frequency.value = freq;

              

                const osc2 = this.ctx.createOscillator();

                osc2.type = 'square';

                osc2.frequency.value = freq * 0.5;

                osc2.detune.value = -10;

              

                const filter = this.ctx.createBiquadFilter();

                filter.type = 'lowpass';

                filter.frequency.setValueAtTime(100, time);

                filter.frequency.exponentialRampToValueAtTime(1000, time + 0.01);

                filter.frequency.exponentialRampToValueAtTime(200, time + 0.5);

                filter.Q.value = 8;

              

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(0, time);

                gain.gain.linearRampToValueAtTime(0.5, time + 0.01);

                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.8);

              

                osc1.connect(filter);

                osc2.connect(filter);

                filter.connect(gain);

                gain.connect(this.buses.bass);

              

                osc1.start(time);

                osc2.start(time);

                osc1.stop(time + 0.8);

                osc2.stop(time + 0.8);

            }

          

            playPerc(time) {

                const buffer = this.ctx.createBuffer(1, 0.05 * this.ctx.sampleRate, this.ctx.sampleRate);

                const data = buffer.getChannelData(0);

              

                for (let i = 0; i < data.length; i++) {

                    data[i] = (Math.random() - 0.5) * Math.exp(-i / data.length * 10);

                }

              

                const source = this.ctx.createBufferSource();

                source.buffer = buffer;

              

                const filter = this.ctx.createBiquadFilter();

                filter.type = 'bandpass';

                filter.frequency.value = 5000 + Math.random() * 5000;

                filter.Q.value = 10;

              

                const gain = this.ctx.createGain();

                gain.gain.value = 0.3;

              

                source.connect(filter);

                filter.connect(gain);

                gain.connect(this.buses.high);

              

                source.start(time);

            }

          

            playHat(time) {

                const buffer = this.ctx.createBuffer(1, 0.01 * this.ctx.sampleRate, this.ctx.sampleRate);

                const data = buffer.getChannelData(0);

              

                for (let i = 0; i < data.length; i++) {

                    data[i] = (Math.random() - 0.5) * Math.exp(-i / data.length * 20);

                }

              

                const source = this.ctx.createBufferSource();

                source.buffer = buffer;

              

                const filter = this.ctx.createBiquadFilter();

                filter.type = 'bandpass';

                filter.frequency.value = 12000;

                filter.Q.value = 5;

              

                const gain = this.ctx.createGain();

                gain.gain.value = 0.2;

              

                source.connect(filter);

                filter.connect(gain);

                gain.connect(this.buses.air);

              

                source.start(time);

            }

          

            playSample(idx, time) {

                const sample = this.samples.get(idx);

                if (!sample) return;

              

                const source = this.ctx.createBufferSource();

                source.buffer = sample.buffer;

                source.playbackRate.value = sample.pitch || 1;

              

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(0, time);

                gain.gain.linearRampToValueAtTime(sample.gain || 0.5, time + 0.01);

                gain.gain.exponentialRampToValueAtTime(0.01, time + sample.buffer.duration);

              

                source.connect(gain);

                gain.connect(sample.bus || this.buses.mid);

              

                source.start(time);

                source.stop(time + sample.buffer.duration);

              

                // Visual feedback

                const node = this.nodes[idx];

                node.classList.add('playing');

                setTimeout(() => node.classList.remove('playing'), 100);

            }

          

            startAmbientCapture() {

                if (this.hasMic) {

                    this.isListening = true;

                    setInterval(() => {

                        if (this.captureBuffer.length > this.ctx.sampleRate * 0.5) {

                            this.processCapturedAudio();

                        }

                    }, 2000);

                } else {

                    setInterval(() => this.generateFakeSample(), 3000);

                }

            }

          

            processAmbientAudio(data) {

                // Simple energy detection

                let energy = 0;

                for (let i = 0; i < data.length; i++) {

                    energy += data[i] * data[i];

                }

                energy = Math.sqrt(energy / data.length);

              

                if (energy > 0.001) {

                    this.captureBuffer.push(...data);

                }

              

                // Limit buffer

                if (this.captureBuffer.length > this.ctx.sampleRate * 4) {

                    this.captureBuffer = this.captureBuffer.slice(-this.ctx.sampleRate * 4);

                }

            }

          

            processCapturedAudio() {

                if (this.captureBuffer.length < this.ctx.sampleRate * 0.1) {

                    return;

                }

              

                // Trim to last 1 second for shorter samples

                const trimLength = Math.min(this.captureBuffer.length, this.ctx.sampleRate * 1);

                const startIdx = this.captureBuffer.length - trimLength;

                const trimmedBuffer = this.captureBuffer.slice(startIdx);

              

                const buffer = this.ctx.createBuffer(1, trimmedBuffer.length, this.ctx.sampleRate);

                buffer.getChannelData(0).set(trimmedBuffer);

              

                this.createSampleFromBuffer(buffer);

              

                this.captureBuffer = [];

            }

          

            generateFakeSample() {

                const length = this.ctx.sampleRate * (0.2 + Math.random() * 0.5); // Shorter for less overlap

                const buffer = this.ctx.createBuffer(1, length, this.ctx.sampleRate);

                const data = buffer.getChannelData(0);

                const freq = 100 + Math.random() * 400;

                for (let i = 0; i < length; i++) {

                    data[i] = Math.sin(i / this.ctx.sampleRate * freq * 2 * Math.PI) * Math.exp(-i / length * 3);

                }

              

                this.createSampleFromBuffer(buffer);

            }

          

            createSampleFromBuffer(buffer) {

                const idx = this.currentNodeIndex % 16;

              

                const pitch = this.detectPitch(buffer);

                let bus = this.buses.mid;

              

                if (pitch < 200) bus = this.buses.bass;

                else if (pitch > 1000) bus = this.buses.high;

              

                const pattern = new Array(16).fill(false);

                for (let i = 0; i < 16; i++) {

                    pattern[i] = Math.random() < (0.1 + this.complexity / 200); // Sparser as complexity decreases

                }

              

                this.samples.set(idx, {

                    buffer: buffer,

                    pitch: 1,

                    gain: 0.5,

                    pattern: pattern,

                    bus: bus

                });

              

                this.nodes[idx].classList.add('loaded');

                this.nodes[idx].textContent = '●';

                this.ui.samples.textContent = this.samples.size;

              

                this.currentNodeIndex++;

            }

          

            captureNow() {

                if (this.captureBuffer.length > 0) {

                    this.processCapturedAudio();

                }

            }

          

            detectPitch(buffer) {

                const data = buffer.getChannelData(0);

                let maxCorr = 0;

                let bestPeriod = 0;

              

                for (let period = 50; period < 500; period++) {

                    let corr = 0;

                    for (let i = 0; i < data.length - period; i++) {

                        corr += data[i] * data[i + period];

                    }

                    if (corr > maxCorr) {

                        maxCorr = corr;

                        bestPeriod = period;

                    }

                }

              

                return bestPeriod > 0 ? this.ctx.sampleRate / bestPeriod : 440;

            }

          

            createFibonacciNodes() {

                const positions = [];

                const phi = 1.618033988749895;

              

                // Generate Fibonacci spiral positions

                for (let i = 0; i < 16; i++) {

                    const angle = i * 137.5 * Math.PI / 180; // Golden angle

                    const radius = 50 + i * 15;

                  

                    const x = 50 + radius * Math.cos(angle) * 0.3;

                    const y = 50 + radius * Math.sin(angle) * 0.3;

                  

                    positions.push({ x, y });

                }

              

                // Create nodes

                positions.forEach((pos, idx) => {

                    const node = document.createElement('div');

                    node.className = 'sample-node';

                    node.style.left = pos.x + '%';

                    node.style.top = pos.y + '%';

                    node.style.transform = 'translate(-50%, -50%)';

                  

                    node.addEventListener('click', () => {

                        if (this.samples.has(idx)) {

                            this.playSample(idx);

                        }

                    });

                  

                    this.ui.sampleNodes.appendChild(node);

                    this.nodes.push(node);

                });

            }

          

            setupVisualizers() {

                // Spectrum

                const spectrum = this.ui.spectrumCanvas;

                spectrum.width = window.innerWidth;

                spectrum.height = window.innerHeight;

              

                // Waveform

                const scope = this.ui.waveformScope;

                scope.width = 377;

                scope.height = 89;

            }

          

            handleKey(e) {

                if (e.key === ' ') {

                    e.preventDefault();

                    this.clearAll();

                }

            }

          

            handleMouse(e) {

                this.mouseX = e.clientX;

                this.mouseY = e.clientY;

              

                // Update cursor

                this.ui.cursor.style.left = e.clientX + 'px';

                this.ui.cursor.style.top = e.clientY + 'px';

              

                this.ui.cursorTrail.style.left = e.clientX + 'px';

                this.ui.cursorTrail.style.top = e.clientY + 'px';

              

                // Modulate based on position

                if (this.isRunning) {

                    const x = e.clientX / window.innerWidth;

                    const y = e.clientY / window.innerHeight;

                  

                    // Modulate filter

                    this.effects.eq.highMid.frequency.value = 1000 + x * 4000;

                    this.effects.eq.highMid.gain.value = -5 + y * 10;

                  

                    // Modulate energy

                    this.energy = Math.sqrt(x * x + y * y) / Math.sqrt(2);

                }

            }

          

            handleTouch(e) {

                if (e.touches[0]) {

                    this.handleMouse(e.touches[0]);

                }

            }

          

            clearAll() {

                this.samples.clear();

                this.nodes.forEach(node => {

                    node.classList.remove('loaded');

                    node.textContent = '';

                });

                this.ui.samples.textContent = '0';

                this.complexity = 100; // Reset to chaotic

                this.ui.complexity.textContent = '100';

              

                // Create particles for effect

                for (let i = 0; i < 50; i++) {

                    this.createParticle();

                }

            }

          

            createParticle() {

                const particle = document.createElement('div');

                particle.className = 'particle';

                particle.style.left = '50%';

                particle.style.top = '50%';

                document.body.appendChild(particle);

              

                const angle = Math.random() * Math.PI * 2;

                const velocity = 100 + Math.random() * 200;

                const lifetime = 1000 + Math.random() * 1000;

              

                let x = 0, y = 0;

                const start = Date.now();

              

                const update = () => {

                    const elapsed = Date.now() - start;

                    const progress = elapsed / lifetime;

                  

                    if (progress >= 1) {

                        particle.remove();

                        return;

                    }

                  

                    x += Math.cos(angle) * velocity * 0.016;

                    y += Math.sin(angle) * velocity * 0.016;

                  

                    particle.style.transform = `translate(${x}px, ${y}px)`;

                    particle.style.opacity = 1 - progress;

                  

                    requestAnimationFrame(update);

                };

              

                update();

            }

          

            animate() {

                requestAnimationFrame(() => this.animate());

              

                // Spectrum visualization

                if (this.analyser) {

                    const canvas = this.ui.spectrumCanvas;

                    const ctx = canvas.getContext('2d');

                    const data = new Uint8Array(this.analyser.frequencyBinCount);

                    this.analyser.getByteFrequencyData(data);

                  

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';

                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                  

                    const barWidth = canvas.width / data.length * 3;

                  

                    for (let i = 0; i < data.length; i++) {

                        const height = (data[i] / 255) * canvas.height;

                        const x = i * barWidth;

                      

                        const gradient = ctx.createLinearGradient(0, canvas.height - height, 0, canvas.height);

                        gradient.addColorStop(0, `rgba(255, 0, 255, ${data[i] / 255})`);

                        gradient.addColorStop(1, 'rgba(138, 0, 255, 0.1)');

                      

                        ctx.fillStyle = gradient;

                        ctx.fillRect(x, canvas.height - height, barWidth - 1, height);

                    }

                }

              

                // Waveform scope

                if (this.scopeAnalyser) {

                    const scope = this.ui.waveformScope;

                    const ctx = scope.getContext('2d');

                    const data = new Uint8Array(this.scopeAnalyser.fftSize);

                    this.scopeAnalyser.getByteTimeDomainData(data);

                  

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';

                    ctx.fillRect(0, 0, scope.width, scope.height);

                  

                    ctx.beginPath();

                    ctx.strokeStyle = '#ff00ff';

                    ctx.lineWidth = 1;

                  

                    const sliceWidth = scope.width / data.length;

                    let x = 0;

                  

                    for (let i = 0; i < data.length; i++) {

                        const v = data[i] / 128;

                        const y = v * scope.height / 2;

                      

                        if (i === 0) {

                            ctx.moveTo(x, y);

                        } else {

                            ctx.lineTo(x, y);

                        }

                      

                        x += sliceWidth;

                    }

                  

                    ctx.stroke();

                }

            }

          

            makeSaturationCurve(amount) {

                const samples = 44100;

                const curve = new Float32Array(samples);

              

                for (let i = 0; i < samples; i++) {

                    const x = (i * 2 / samples) - 1;

                    curve[i] = Math.tanh(x * amount) / Math.tanh(amount);

                }

              

                return curve;

            }

        }

      

        // Start

        window.addEventListener('DOMContentLoaded', () => {

            window.gump = new GUMPMeta();

        });

    </script>

</body>

</html>
