<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="microphone=(self)">
    <title>AURORA: Symbiotic Sonic Weaver v12 - Motion Sampling Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,20,20,0.1) 0%, transparent 70%);
            border: 3px solid rgba(255,20,20,0.4);
            color: #ff1414;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(255,20,20,0.8);
            background: radial-gradient(circle, rgba(255,20,20,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        .btn-text {
            font-size: 20px;
            margin-bottom: 8px;
        }

        .btn-subtext {
            font-size: 11px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255,20,20,0.3);
            }
            50% {
                transform: scale(1.06);
                box-shadow: 0 0 80px rgba(255,20,20,0.6);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff1414 0%, rgba(255,20,20,0.4) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 50px rgba(255,20,20,0.6);
            backdrop-filter: blur(8px);
            will-change: transform;
            z-index: 10;
        }

        .orb.pulse {
            animation: beatPulse 0.15s ease-out;
        }

        @keyframes beatPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.8); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.sampling {
            background: radial-gradient(circle, #ff6600 0%, rgba(255,102,0,0.5) 50%, transparent 80%);
            box-shadow: 0 0 70px rgba(255,102,0,0.8);
        }

        .orb.chopping {
            background: radial-gradient(circle, #00ff88 0%, rgba(0,255,136,0.5) 50%, transparent 80%);
            box-shadow: 0 0 90px rgba(0,255,136,0.9);
        }

        .orb.flipping {
            background: radial-gradient(circle, #8800ff 0%, rgba(136,0,255,0.5) 50%, transparent 80%);
            box-shadow: 0 0 120px rgba(136,0,255,1);
        }

        .orb.dropping {
            background: radial-gradient(circle, #ffff00 0%, #ff0080 30%, #00ffff 60%, transparent 90%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 100px rgba(255,0,128,0.8));
        }

        .hidden {
            display: none !important;
        }

        .sample-viz {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 280px;
            height: 100px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,20,20,0.3);
            border-radius: 12px;
            padding: 12px;
            font-size: 11px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .sample-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .sample-details {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .waveform {
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,20,20,0.2);
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #ff1414, #ff6600, #ffff00);
            transition: height 0.08s ease;
            border-radius: 1px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .control-section {
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 10px;
            color: #ff6600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .slider {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff1414, #ff6600);
            border-radius: 3px;
            transition: width 0.2s ease;
        }

        .slider-thumb {
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            transform: translateX(-50%);
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,20,20,0.6);
            animation: float 6s linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-10vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .layer-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            z-index: 100;
        }

        .layer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            min-width: 140px;
        }

        .layer.active {
            background: rgba(255,20,20,0.2);
            border: 1px solid rgba(255,20,20,0.4);
        }

        .layer-name {
            font-weight: bold;
            color: #ff6600;
        }

        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            max-width: 200px;
            z-index: 100;
        }

        .instruction-group {
            margin-bottom: 8px;
        }

        .instruction-title {
            color: #ff6600;
            font-weight: bold;
            margin-bottom: 4px;
        }

        kbd {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            margin-right: 4px;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            <div class="btn-text">START ENGINE</div>
            <div class="btn-subtext">SAMPLE THE WORLD<br>BUILD THE BEAT</div>
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
        
        <div id="sampleViz" class="sample-viz hidden">
            <div class="sample-info">
                <span id="sampleStatus">LISTENING...</span>
                <span id="sampleCount">0 SAMPLES</span>
            </div>
            <div class="sample-details">
                <span id="bpmDisplay">140 BPM</span>
                <span id="stageDisplay">LISTENING</span>
                <span id="motionDisplay">CALM</span>
            </div>
            <div class="waveform" id="waveform"></div>
        </div>

        <div id="controls" class="controls hidden">
            <div class="control-section">
                <div class="control-label">Sampling</div>
                <div class="control-row">
                    <span>Threshold</span>
                    <div class="slider" data-param="threshold">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Sensitivity</span>
                    <div class="slider" data-param="sensitivity">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
            <div class="control-section">
                <div class="control-label">Evolution</div>
                <div class="control-row">
                    <span>Chaos</span>
                    <div class="slider" data-param="chaos">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Speed</span>
                    <div class="slider" data-param="speed">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="layerStatus" class="layer-status hidden">
            <div style="font-weight: bold; margin-bottom: 8px; color: #ff6600;">SAMPLE LAYERS</div>
            <div class="layer" data-layer="kick">
                <span class="layer-name">KICK</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="snare">
                <span class="layer-name">SNARE</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="hats">
                <span class="layer-name">HATS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="bass">
                <span class="layer-name">BASS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="lead">
                <span class="layer-name">LEAD</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="fx">
                <span class="layer-name">FX</span>
                <span class="layer-count">0</span>
            </div>
        </div>

        <div id="instructions" class="instructions hidden">
            <div class="instruction-group">
                <div class="instruction-title">Controls</div>
                <div><kbd>SPACE</kbd> Sample</div>
                <div><kbd>C</kbd> Chop</div>
                <div><kbd>F</kbd> Flip</div>
                <div><kbd>P</kbd> Pitch</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Layers</div>
                <div><kbd>1-6</kbd> Trigger</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Motion</div>
                <div>Move device or mouse</div>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        class AuroraWeaver {
            constructor() {
                // Core audio
                this.ctx = null;
                this.active = false;
                this.masterGain = null;
                this.analyzer = null;
                this.dataArray = null;
                this.timeDomainData = null;
                
                // Microphone and recording
                this.microphone = null;
                this.recorder = null;
                this.dummyGain = null;
                this.sampleBuffer = [];
                this.isRecording = false;
                this.recordingChunks = [];
                
                // Sample management
                this.processedSamples = [];
                this.layers = {};
                this.maxSamples = 24;
                
                // Sequencer
                this.tempo = 140;
                this.beatStep = 0;
                this.patternLength = 32;
                this.sequenceTimeout = null;
                this.isPlaying = false;
                
                // Motion and AI
                this.motion = {
                    value: 0,
                    history: new Float32Array(60),
                    index: 0,
                    pattern: 'calm'
                };
                
                this.lmState = {
                    mood: 'neutral',
                    energy: 0,
                    complexity: 0,
                    spectralCentroid: 0,
                    onsetDensity: 0,
                    harmony: 0
                };
                
                // Sampling parameters
                this.threshold = 0.05;
                this.sensitivity = 1.0;
                this.cooldown = 2000;
                this.lastSampleTime = 0;
                this.samplingInterval = 1000;
                this.maxSampleDuration = 3;
                
                // Effects and processing
                this.autotuneScale = [0, 3, 5, 7, 10]; // Blues pentatonic
                this.keyRoot = 0;
                this.fractalSeed = Math.random();
                this.chaos = 0.5;
                
                // UI elements
                this.elements = {};
                this.waveformBars = [];
                this.stage = 'LISTENING';
                
                // Performance
                this.lastX = undefined;
                this.lastY = undefined;
                this.animationFrame = null;
                
                this.init();
            }

            init() {
                // Cache DOM elements
                const ids = [
                    'startScreen', 'startBtn', 'evolutionSpace', 'orb', 'sampleViz',
                    'sampleStatus', 'sampleCount', 'bpmDisplay', 'stageDisplay', 
                    'motionDisplay', 'waveform', 'controls', 'layerStatus', 'instructions'
                ];
                
                ids.forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });
                
                // Create waveform visualization
                this.setupWaveform();
                
                // Setup controls
                this.setupControls();
                
                // Setup input handlers
                this.setupInput();
                
                // Bind start button
                this.elements.startBtn.onclick = () => this.awaken();
                
                console.log('🎵 Aurora Weaver initialized');
            }

            setupWaveform() {
                const frag = document.createDocumentFragment();
                for (let i = 0; i < 60; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.left = `${i * 1.67}%`;
                    bar.style.width = '1.33%';
                    frag.appendChild(bar);
                }
                this.elements.waveform.appendChild(frag);
                this.waveformBars = this.elements.waveform.querySelectorAll('.waveform-bar');
            }

            setupControls() {
                const sliders = document.querySelectorAll('.slider');
                const params = { 
                    threshold: 0.15, 
                    sensitivity: 0.5, 
                    chaos: 0.2, 
                    speed: 0.5 
                };
                
                sliders.forEach(slider => {
                    const param = slider.dataset.param;
                    const fill = slider.querySelector('.slider-fill');
                    const thumb = slider.querySelector('.slider-thumb');
                    const value = params[param];
                    
                    // Set initial position
                    fill.style.width = `${value * 100}%`;
                    thumb.style.left = `${value * 100}%`;
                    
                    let active = false;
                    
                    const update = (e) => {
                        if (!active) return;
                        const rect = slider.getBoundingClientRect();
                        const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                        const val = x / rect.width;
                        
                        fill.style.width = `${val * 100}%`;
                        thumb.style.left = `${val * 100}%`;
                        
                        // Update parameters
                        if (param === 'speed') {
                            this.tempo = 80 + val * 80;
                        } else if (param === 'threshold') {
                            this.threshold = 0.01 + val * 0.1;
                        } else if (param === 'sensitivity') {
                            this.sensitivity = 0.5 + val * 2;
                        } else if (param === 'chaos') {
                            this.chaos = val;
                        }
                        
                        this.updateDisplay();
                    };
                    
                    slider.onmousedown = (e) => {
                        active = true;
                        update(e);
                        
                        document.onmousemove = update;
                        document.onmouseup = () => {
                            active = false;
                            document.onmousemove = null;
                            document.onmouseup = null;
                        };
                    };
                });
            }

            setupInput() {
                // Keyboard controls
                const keys = {
                    ' ': () => this.toggleRecording(),
                    'c': () => this.playRandom('chop'),
                    'f': () => this.playRandom('flip'),
                    'p': () => this.playRandom('pitch'),
                    '1': () => this.triggerLayer('kick'),
                    '2': () => this.triggerLayer('snare'),
                    '3': () => this.triggerLayer('hats'),
                    '4': () => this.triggerLayer('bass'),
                    '5': () => this.triggerLayer('lead'),
                    '6': () => this.triggerLayer('fx')
                };
                
                document.onkeydown = (e) => {
                    if (!this.active || e.repeat) return;
                    const fn = keys[e.key.toLowerCase()];
                    if (fn) {
                        e.preventDefault();
                        fn();
                    }
                };
                
                // Mouse motion tracking
                let lastMove = 0;
                document.onmousemove = (e) => {
                    if (!this.active) return;
                    
                    const now = performance.now();
                    if (now - lastMove < 16) return; // 60fps throttle
                    lastMove = now;
                    
                    const x = e.clientX / window.innerWidth;
                    const y = e.clientY / window.innerHeight;
                    
                    if (this.lastX !== undefined) {
                        const dx = x - this.lastX;
                        const dy = y - this.lastY;
                        const vel = Math.sqrt(dx * dx + dy * dy) * 60;
                        this.updateMotion(vel);
                    }
                    
                    this.lastX = x;
                    this.lastY = y;
                    
                    // Move orb
                    this.elements.orb.style.left = `${x * 100}%`;
                    this.elements.orb.style.top = `${y * 100}%`;
                    
                    // Update background
                    document.body.style.background = `radial-gradient(circle at ${x * 100}% ${y * 100}%, rgba(255,20,20,0.1), #000)`;
                };
                
                // Device motion
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        if (!this.active || !e.accelerationIncludingGravity) return;
                        
                        const {x, y, z} = e.accelerationIncludingGravity;
                        const magnitude = Math.sqrt(x*x + y*y + z*z) * 0.1;
                        this.updateMotion(magnitude);
                    });
                }
            }

            updateMotion(value) {
                this.motion.value = this.motion.value * 0.8 + value * 0.2;
                this.motion.history[this.motion.index] = this.motion.value;
                this.motion.index = (this.motion.index + 1) % 60;
                
                const avg = this.motion.history.reduce((a, b) => a + b) / 60;
                
                if (avg > 3) {
                    this.motion.pattern = 'chaotic';
                    this.lmState.mood = 'chaotic';
                } else if (avg > 1.5) {
                    this.motion.pattern = 'active';
                    this.lmState.mood = 'aggressive';
                } else if (avg > 0.5) {
                    this.motion.pattern = 'rhythmic';
                    this.lmState.mood = 'rhythmic';
                } else {
                    this.motion.pattern = 'calm';
                    this.lmState.mood = 'mellow';
                }
                
                this.lmState.complexity = Math.min(1, avg / 2);
                this.updateDisplay();
            }

            async awaken() {
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    // Setup audio chain
                    this.setupAudio();
                    
                    // Create initial drum samples
                    await this.createDrums();
                    
                    // Get microphone access
                    await this.setupMic();
                    
                    // Show UI
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    ['sampleViz', 'controls', 'layerStatus', 'instructions'].forEach(id => {
                        this.elements[id].classList.remove('hidden');
                    });
                    
                    this.active = true;
                    this.motion.history.fill(0.1);
                    
                    // Start loops
                    this.startVis();
                    this.startSeq();
                    
                    this.elements.sampleStatus.textContent = 'SYMBIOSIS ACTIVE';
                    this.stage = 'SAMPLING';
                    this.updateDisplay();
                    
                    console.log('🎵 Aurora Weaver awakened successfully');
                    
                } catch (e) {
                    console.error('Awakening failed:', e);
                    this.elements.sampleStatus.textContent = 'SYMBIOSIS DENIED: ' + e.message;
                }
            }

            setupAudio() {
                // Master chain with lo-fi processing
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.7;
                
                // Lo-fi filter chain
                const lowpass = this.ctx.createBiquadFilter();
                lowpass.type = 'lowpass';
                lowpass.frequency.value = 8000;
                lowpass.Q.value = 0.5;
                
                const highpass = this.ctx.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 80;
                highpass.Q.value = 0.5;
                
                // Warm saturation
                const waveshaper = this.ctx.createWaveShaper();
                const curve = new Float32Array(65536);
                for (let i = 0; i < 65536; i++) {
                    const x = (i - 32768) / 32768;
                    curve[i] = Math.tanh(x * 0.5) * 0.8;
                }
                waveshaper.curve = curve;
                
                // Connect chain
                this.masterGain.connect(highpass);
                highpass.connect(lowpass);
                lowpass.connect(waveshaper);
                waveshaper.connect(this.ctx.destination);
                
                // Analyzer for visualization
                this.analyzer = this.ctx.createAnalyser();
                this.analyzer.fftSize = 2048;
                this.analyzer.smoothingTimeConstant = 0.3;
                this.dataArray = new Uint8Array(this.analyzer.frequencyBinCount);
                this.timeDomainData = new Float32Array(this.analyzer.fftSize);
                
                this.masterGain.connect(this.analyzer);
                
                // Initialize layer gains
                const layerNames = ['kick', 'snare', 'hats', 'bass', 'lead', 'fx'];
                const layerGains = [1.0, 0.8, 0.6, 0.9, 0.7, 0.5];
                
                layerNames.forEach((name, i) => {
                    const gain = this.ctx.createGain();
                    gain.gain.value = layerGains[i];
                    gain.connect(this.masterGain);
                    
                    this.layers[name] = {
                        gain,
                        samples: []
                    };
                });
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // 808 Kick
                const kickBuffer = this.ctx.createBuffer(1, sr * 0.8, sr);
                const kickData = kickBuffer.getChannelData(0);
                
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    const env = t < 0.01 ? t / 0.01 : Math.exp(-3 * (t - 0.01));
                    const pitch = 60 * Math.exp(-30 * t) + 30;
                    
                    let signal = Math.sin(2 * Math.PI * pitch * t) * 0.8;
                    signal += Math.sin(4 * Math.PI * pitch * t) * 0.2 * Math.exp(-40 * t);
                    
                    // Add click for punch
                    if (t < 0.003) {
                        const click = Math.sin(2 * Math.PI * 1000 * t) * 0.4 * (1 - t / 0.003);
                        signal += click;
                    }
                    
                    kickData[i] = Math.tanh(signal * 1.5) * env;
                }
                
                // Trap Snare
                const snareBuffer = this.ctx.createBuffer(1, sr * 0.2, sr);
                const snareData = snareBuffer.getChannelData(0);
                
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-8 * t);
                    
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.3;
                    const noise = (Math.random() * 2 - 1) * 0.6;
                    const crack = Math.sin(2 * Math.PI * 300 * t) * 0.2 * Math.exp(-20 * t);
                    
                    snareData[i] = Math.tanh((tone + noise + crack) * 1.8) * env * 0.7;
                }
                
                // Hi-hats
                const hatBuffer = this.ctx.createBuffer(1, sr * 0.05, sr);
                const hatData = hatBuffer.getChannelData(0);
                
                for (let i = 0; i < hatData.length; i++) {
                    const t = i / sr;
                    let signal = 0;
                    
                    // High frequency content
                    [8000, 10000, 12000, 15000].forEach(freq => {
                        signal += Math.sin(2 * Math.PI * freq * t) * 0.15;
                    });
                    
                    signal += (Math.random() * 2 - 1) * 0.4;
                    signal *= Math.exp(-60 * t);
                    
                    hatData[i] = signal * 0.5;
                }
                
                // Sub Bass
                const bassBuffer = this.ctx.createBuffer(1, sr * 1.5, sr);
                const bassData = bassBuffer.getChannelData(0);
                
                for (let i = 0; i < bassData.length; i++) {
                    const t = i / sr;
                    const env = Math.min(1, t / 0.01) * (t > 1.2 ? Math.max(0, 1 - (t - 1.2) / 0.3) : 1);
                    const wobble = 1 + Math.sin(2 * Math.PI * 3 * t) * 0.02;
                    
                    bassData[i] = Math.sin(2 * Math.PI * 55 * wobble * t) * env * 0.8;
                }
                
                // Create sample objects
                const drumSamples = [
                    { buffer: kickBuffer, layer: 'kick', pitch: 60 },
                    { buffer: snareBuffer, layer: 'snare', pitch: 200 },
                    { buffer: hatBuffer, layer: 'hats', pitch: null },
                    { buffer: bassBuffer, layer: 'bass', pitch: 55 }
                ];
                
                drumSamples.forEach(({ buffer, layer, pitch }) => {
                    const sample = {
                        id: `${layer}_${Date.now()}`,
                        buffer,
                        duration: buffer.duration,
                        analysis: {
                            pitch,
                            energy: layer === 'kick' ? 'high' : layer === 'snare' ? 'medium' : 'low',
                            brightness: layer === 'hats' ? 'bright' : 'dark'
                        },
                        rate: 1,
                        layer
                    };
                    
                    this.processedSamples.push(sample);
                    this.layers[layer].samples.push(sample);
                });
                
                this.updateStage();
            }

            async setupMic() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });
                
                this.microphone = this.ctx.createMediaStreamSource(stream);
                
                // Recording processor
                this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                this.dummyGain = this.ctx.createGain();
                this.dummyGain.gain.value = 0;
                
                this.recorder.onaudioprocess = (e) => this.processAudio(e);
                
                this.microphone.connect(this.recorder);
                this.recorder.connect(this.dummyGain);
                this.dummyGain.connect(this.ctx.destination);
            }

            processAudio(e) {
                if (!this.active) return;
                
                const input = e.inputBuffer.getChannelData(0);
                const rms = this.rootMeanSquare(input);
                const now = Date.now();
                
                // Auto-sampling on sound detection
                if (rms > this.threshold && !this.isRecording && now - this.lastSampleTime > this.cooldown) {
                    this.startRecording();
                } else if (rms < this.threshold * 0.3 && this.isRecording) {
                    this.stopRecording();
                }
                
                // Real-time analysis for LM
                this.lmState.energy = rms * this.sensitivity;
                
                // Update waveform visualization
                this.updateWaveform(input);
            }

            rootMeanSquare(array) {
                let sum = 0;
                for (let i = 0; i < array.length; i++) {
                    sum += array[i] * array[i];
                }
                return Math.sqrt(sum / array.length);
            }

            toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                if (this.isRecording) return;
                
                this.isRecording = true;
                this.sampleBuffer = [];
                this.lastSampleTime = Date.now();
                
                this.elements.orb.classList.add('sampling');
                this.elements.sampleStatus.textContent = 'SAMPLING...';
                this.stage = 'SAMPLING';
                
                console.log('🎤 Recording started');
            }

            stopRecording() {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                this.elements.orb.classList.remove('sampling');
                
                if (this.sampleBuffer.length > 0) {
                    this.createSample();
                }
                
                this.elements.sampleStatus.textContent = 'PROCESSING...';
                this.stage = 'PROCESSING';
                
                console.log('✅ Recording stopped, processing sample');
            }

            createSample() {
                if (this.sampleBuffer.length === 0) return;
                
                // Create audio buffer from recorded data
                const buffer = this.ctx.createBuffer(1, this.sampleBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.sampleBuffer);
                
                // Analyze sample
                const analysis = this.analyze(buffer);
                
                // Create sample object
                const sample = {
                    id: `rec_${Date.now()}`,
                    buffer,
                    duration: buffer.duration,
                    analysis,
                    rate: 1,
                    layer: this.categorize(analysis)
                };
                
                // Autotune if pitched
                if (analysis.pitch) {
                    const targetPitch = this.quantizePitch(analysis.pitch);
                    sample.rate = targetPitch / analysis.pitch;
                }
                
                // Add to collections
                this.processedSamples.push(sample);
                this.layers[sample.layer].samples.push(sample);
                
                // Maintain sample limit
                while (this.processedSamples.length > this.maxSamples) {
                    const oldSample = this.processedSamples.shift();
                    Object.values(this.layers).forEach(layer => {
                        layer.samples = layer.samples.filter(s => s.id !== oldSample.id);
                    });
                }
                
                this.updateStage();
                console.log(`📚 Sample added to ${sample.layer}, total: ${this.processedSamples.length}`);
            }

            analyze(buffer) {
                const data = buffer.getChannelData(0);
                const len = data.length;
                
                // RMS Energy
                let rms = 0;
                for (let i = 0; i < len; i++) {
                    rms += data[i] * data[i];
                }
                rms = Math.sqrt(rms / len);
                
                // Zero crossing rate (brightness indicator)
                let zeroCrossings = 0;
                for (let i = 1; i < len; i++) {
                    if ((data[i] >= 0) !== (data[i-1] >= 0)) {
                        zeroCrossings++;
                    }
                }
                const zcr = zeroCrossings / buffer.duration;
                
                // Simple pitch detection via autocorrelation
                let pitch = null;
                if (len > 1024) {
                    const maxDelay = Math.min(len >> 1, 2000);
                    const minDelay = 40;
                    let maxCorrelation = 0;
                    let bestDelay = -1;
                    
                    for (let delay = minDelay; delay < maxDelay; delay++) {
                        let correlation = 0;
                        for (let i = 0; i < len - delay; i++) {
                            correlation += data[i] * data[i + delay];
                        }
                        
                        if (correlation > maxCorrelation) {
                            maxCorrelation = correlation;
                            bestDelay = delay;
                        }
                    }
                    
                    if (maxCorrelation > rms * rms * len * 0.3 && bestDelay > 0) {
                        pitch = this.ctx.sampleRate / bestDelay;
                    }
                }
                
                return {
                    rms,
                    zcr,
                    energy: rms > 0.1 ? 'high' : rms > 0.03 ? 'medium' : 'low',
                    brightness: zcr > 3000 ? 'bright' : 'dark',
                    pitch,
                    duration: buffer.duration
                };
            }

            categorize(analysis) {
                const { energy, brightness, pitch, duration, zcr } = analysis;
                
                // Kick: High energy, dark, short
                if (energy === 'high' && brightness === 'dark' && duration < 0.8) {
                    return 'kick';
                }
                
                // Snare: Medium energy, some brightness, short-medium
                if (energy === 'medium' && zcr > 1500 && zcr < 6000 && duration < 1) {
                    return 'snare';
                }
                
                // Hi-hats: Bright, short
                if (brightness === 'bright' && duration < 0.2) {
                    return 'hats';
                }
                
                // Bass: Low pitch, longer duration
                if (pitch && pitch < 150 && duration > 0.3) {
                    return 'bass';
                }
                
                // Lead: Mid-high pitch
                if (pitch && pitch >= 150 && pitch < 1000) {
                    return 'lead';
                }
                
                // Everything else goes to FX
                return 'fx';
            }

            quantizePitch(frequency) {
                // Quantize to A minor pentatonic scale
                const scales = {
                    'mellow': [0, 3, 5, 7, 10],      // Minor pentatonic
                    'aggressive': [0, 2, 3, 5, 7, 8, 10], // Natural minor
                    'rhythmic': [0, 2, 4, 7, 9],     // Major pentatonic
                    'chaotic': [0, 1, 3, 6, 8, 10]   // Blues scale
                };
                
                const scale = scales[this.lmState.mood] || scales['mellow'];
                const rootFreq = 110; // A2
                
                // Convert to semitones from root
                const semitones = 12 * Math.log2(frequency / rootFreq);
                const octave = Math.floor(semitones / 12);
                const note = semitones % 12;
                
                // Find closest scale note
                let closest = scale[0];
                let minDistance = Math.abs(note - closest);
                
                for (const scaleNote of scale) {
                    const distance = Math.abs(note - scaleNote);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = scaleNote;
                    }
                }
                
                // Return quantized frequency
                return rootFreq * Math.pow(2, (octave * 12 + closest) / 12);
            }

            startVis() {
                const loop = () => {
                    if (!this.active) return;
                    
                    this.analyzer.getByteFrequencyData(this.dataArray);
                    this.analyzer.getFloatTimeDomainData(this.timeDomainData);
                    
                    // Update LM state from real-time audio
                    this.updateLMState();
                    
                    // Continue loop
                    this.animationFrame = requestAnimationFrame(loop);
                };
                
                this.animationFrame = requestAnimationFrame(loop);
            }

            updateLMState() {
                // Energy from time domain
                let energy = 0;
                for (let val of this.timeDomainData) {
                    energy += val * val;
                }
                this.lmState.energy = Math.sqrt(energy / this.timeDomainData.length);
                
                // Spectral centroid from frequency domain
                let numerator = 0, denominator = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    const magnitude = this.dataArray[i];
                    numerator += i * magnitude;
                    denominator += magnitude;
                }
                
                if (denominator > 0) {
                    this.lmState.spectralCentroid = (numerator / denominator) * (this.ctx.sampleRate / 2 / this.dataArray.length);
                }
                
                // Update complexity based on motion and energy
                this.lmState.complexity = Math.min(1, (this.motion.value + this.lmState.energy) / 2);
            }

            updateWaveform(audioData) {
                const stride = Math.floor(audioData.length / this.waveformBars.length);
                
                for (let i = 0; i < this.waveformBars.length; i++) {
                    let max = 0;
                    for (let j = 0; j < stride; j++) {
                        const sample = Math.abs(audioData[i * stride + j] || 0);
                        if (sample > max) max = sample;
                    }
                    
                    const height = Math.min(100, max * this.sensitivity * 200);
                    this.waveformBars[i].style.height = `${height}%`;
                }
                
                // Store in sample buffer if recording
                if (this.isRecording) {
                    this.sampleBuffer.push(...audioData);
                    
                    // Auto-stop if too long
                    if (this.sampleBuffer.length > this.ctx.sampleRate * this.maxSampleDuration) {
                        this.stopRecording();
                    }
                }
            }

            startSeq() {
                if (this.isPlaying) return;
                this.isPlaying = true;
                this.playStep();
            }

            playStep() {
                if (!this.active || !this.isPlaying) return;
                
                const pattern = this.generateFractalPattern();
                const stepDuration = (60 / this.tempo / 4) * 1000; // 16th note duration in ms
                
                // Play samples based on pattern and LM state
                this.executeStep(pattern);
                
                this.beatStep = (this.beatStep + 1) % this.patternLength;
                
                // Schedule next step
                this.sequenceTimeout = setTimeout(() => this.playStep(), stepDuration);
            }

            generateFractalPattern() {
                const pattern = {
                    kick: new Array(this.patternLength).fill(false),
                    snare: new Array(this.patternLength).fill(false),
                    hats: new Array(this.patternLength).fill(false),
                    bass: new Array(this.patternLength).fill(false),
                    lead: new Array(this.patternLength).fill(false),
                    fx: new Array(this.patternLength).fill(false)
                };
                
                // Base patterns influenced by mood
                const moodPatterns = {
                    'mellow': {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [4, 12, 20, 28]
                    },
                    'aggressive': {
                        kick: [0, 6, 16, 22],
                        snare: [8, 24],
                        hats: [0, 4, 8, 12, 16, 20, 24, 28],
                        bass: [0, 16]
                    },
                    'rhythmic': {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [2, 6, 10, 14, 18, 22, 26, 30],
                        bass: [0, 8, 16, 24]
                    },
                    'chaotic': {
                        kick: [0, 5, 16, 21],
                        snare: [8, 15, 24, 31],
                        hats: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31],
                        bass: [0, 4, 8, 12, 16, 20, 24, 28],
                        lead: [2, 6, 10, 14, 18, 22, 26, 30]
                    }
                };
                
                const basePattern = moodPatterns[this.lmState.mood] || moodPatterns['mellow'];
                
                // Apply base pattern
                Object.keys(basePattern).forEach(layer => {
                    basePattern[layer].forEach(step => {
                        if (step < this.patternLength) {
                            pattern[layer][step] = true;
                        }
                    });
                });
                
                // Add chaos and complexity
                Object.keys(pattern).forEach(layer => {
                    for (let i = 0; i < this.patternLength; i++) {
                        // Fractal-based additions
                        const fractalValue = this.fractalNoise(i, layer.length);
                        const threshold = 0.7 - (this.chaos * 0.4) - (this.lmState.complexity * 0.2);
                        
                        if (fractalValue > threshold && Math.random() < this.chaos) {
                            pattern[layer][i] = true;
                        }
                        
                        // Motion-based modifications
                        if (this.motion.value > 2 && Math.random() < this.motion.value * 0.1) {
                            pattern[layer][i] = !pattern[layer][i];
                        }
                    }
                });
                
                return pattern;
            }

            fractalNoise(x, seed) {
                const scale1 = Math.sin(x * 0.1 + seed) * 0.5 + 0.5;
                const scale2 = Math.sin(x * 0.3 + seed * 2) * 0.3 + 0.5;
                const scale3 = Math.sin(x * 0.7 + seed * 3) * 0.2 + 0.5;
                return (scale1 + scale2 + scale3) / 3;
            }

            executeStep(pattern) {
                Object.keys(pattern).forEach(layer => {
                    if (pattern[layer][this.beatStep] && this.layers[layer].samples.length > 0) {
                        this.triggerLayer(layer);
                    }
                });
                
                // Visual feedback
                if (pattern.kick[this.beatStep] || pattern.snare[this.beatStep]) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }
            }

            triggerLayer(layerName) {
                const layer = this.layers[layerName];
                if (!layer || layer.samples.length === 0) return;
                
                // Select sample based on LM state
                let sampleIndex;
                if (this.lmState.mood === 'chaotic') {
                    sampleIndex = Math.floor(Math.random() * layer.samples.length);
                } else {
                    // Use most recent sample for consistency
                    sampleIndex = layer.samples.length - 1;
                }
                
                const sample = layer.samples[sampleIndex];
                this.play(sample, layer.gain);
                
                // Visual feedback
                const layerElement = document.querySelector(`[data-layer="${layerName}"]`);
                if (layerElement) {
                    layerElement.classList.add('active');
                    setTimeout(() => layerElement.classList.remove('active'), 200);
                }
                
                console.log(`🥁 Triggered ${layerName}`);
            }

            play(sample, gainNode, rate = null) {
                if (!sample || !sample.buffer) return;
                
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                source.playbackRate.value = rate || sample.rate;
                
                // Add subtle randomization for humanization
                source.playbackRate.value *= 1 + (Math.random() - 0.5) * 0.02;
                
                // Create envelope for smooth playback
                const envelope = this.ctx.createGain();
                envelope.gain.setValueAtTime(0, this.ctx.currentTime);
                envelope.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.01);
                envelope.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + sample.duration * 0.9);
                
                source.connect(envelope);
                envelope.connect(gainNode);
                
                source.start(0);
                source.stop(this.ctx.currentTime + sample.duration);
            }

            playRandom(effect) {
                if (this.processedSamples.length === 0) return;
                
                const sample = this.processedSamples[Math.floor(Math.random() * this.processedSamples.length)];
                const layer = this.layers[sample.layer];
                
                this.elements.orb.classList.add(effect);
                setTimeout(() => this.elements.orb.classList.remove(effect), 300);
                
                switch (effect) {
                    case 'chop':
                        this.playChop(sample, layer.gain);
                        this.stage = 'CHOPPING';
                        break;
                    case 'flip':
                        this.playReverse(sample, layer.gain);
                        this.stage = 'FLIPPING';
                        break;
                    case 'pitch':
                        const randomRate = 0.5 + Math.random() * 1.5;
                        this.play(sample, layer.gain, randomRate);
                        this.stage = 'PITCHING';
                        break;
                }
                
                this.updateDisplay();
                setTimeout(() => {
                    this.stage = 'LISTENING';
                    this.updateDisplay();
                }, 1000);
            }

            playChop(sample, gainNode) {
                const chopSize = 0.1 + Math.random() * 0.2; // 100-300ms chops
                const numChops = Math.floor(sample.duration / chopSize);
                
                for (let i = 0; i < Math.min(numChops, 8); i++) {
                    setTimeout(() => {
                        const source = this.ctx.createBufferSource();
                        source.buffer = sample.buffer;
                        source.connect(gainNode);
                        
                        const startTime = i * chopSize;
                        source.start(0, startTime, chopSize);
                    }, i * 120); // Slight delay between chops
                }
            }

            playReverse(sample, gainNode) {
                // Create reversed buffer
                const reversedBuffer = this.ctx.createBuffer(
                    sample.buffer.numberOfChannels,
                    sample.buffer.length,
                    sample.buffer.sampleRate
                );
                
                for (let channel = 0; channel < sample.buffer.numberOfChannels; channel++) {
                    const originalData = sample.buffer.getChannelData(channel);
                    const reversedData = reversedBuffer.getChannelData(channel);
                    
                    for (let i = 0; i < originalData.length; i++) {
                        reversedData[i] = originalData[originalData.length - 1 - i];
                    }
                }
                
                const source = this.ctx.createBufferSource();
                source.buffer = reversedBuffer;
                source.connect(gainNode);
                source.start(0);
            }

            updateStage() {
                this.elements.sampleCount.textContent = `${this.processedSamples.length} SAMPLES`;
                
                // Update layer counts
                Object.keys(this.layers).forEach(layerName => {
                    const count = this.layers[layerName].samples.length;
                    const element = document.querySelector(`[data-layer="${layerName}"] .layer-count`);
                    if (element) {
                        element.textContent = count;
                    }
                });
                
                // Update stage based on activity
                if (this.processedSamples.length === 0) {
                    this.stage = 'LISTENING';
                } else if (this.isRecording) {
                    this.stage = 'SAMPLING';
                } else {
                    this.stage = 'WEAVING';
                }
                
                this.updateDisplay();
            }

            updateDisplay() {
                this.elements.bpmDisplay.textContent = `${Math.round(this.tempo)} BPM`;
                this.elements.stageDisplay.textContent = this.stage;
                this.elements.motionDisplay.textContent = this.motion.pattern.toUpperCase();
                
                // Update orb size based on motion
                const scale = 1 + this.motion.value * 0.1;
                this.elements.orb.style.transform = `translate(-50%, -50%) scale(${scale})`;
            }

            destroy() {
                this.active = false;
                
                if (this.animationFrame) {
                    cancelAnimationFrame(this.animationFrame);
                }
                
                if (this.sequenceTimeout) {
                    clearTimeout(this.sequenceTimeout);
                }
                
                if (this.ctx) {
                    this.ctx.close();
                }
                
                console.log('🔇 Aurora Weaver destroyed');
            }
        }

        // Initialize the engine
        const weaver = new AuroraWeaver();
        
        // Global access for debugging
        window.weaver = weaver;
        
    </script>
</body>
</html>
