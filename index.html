<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: EDM Drop Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,255,0.1) 0%, transparent 70%);
            border: 2px solid rgba(0,255,255,0.3);
            color: #00ffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 3s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(0,255,255,0.6);
            background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(0,255,255,0.2);
            }
            50% {
                transform: scale(1.08);
                box-shadow: 0 0 60px rgba(0,255,255,0.4);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 40px rgba(0,255,255,0.5);
            backdrop-filter: blur(5px);
            will-change: transform;
        }

        .orb.pulse {
            animation: beat 0.15s ease-out;
        }

        @keyframes beat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.buildup {
            background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,0,255,0.7);
        }

        .orb.drop {
            background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 80px rgba(0,255,0,0.7);
        }

        .orb.breakdown {
            background: radial-gradient(circle, #ff9900 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
            box-shadow: 0 0 120px rgba(255,153,0,0.8);
            animation: transcend 3s ease-in-out infinite;
        }

        .orb.riddim {
            background: radial-gradient(circle, #ffff00 0%, #ff0000 25%, #00ffff 50%, #ff00ff 75%, transparent 95%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 80px rgba(255,0,0,0.8));
        }

        .orb.void {
            background: radial-gradient(circle, #4b0082 0%, rgba(75,0,130,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(75,0,130,0.4);
            filter: drop-shadow(0 0 20px rgba(75,0,130,0.2));
            animation: voidBreathe 3s ease-in-out infinite;
        }

        @keyframes transcend {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.4); }
        }

        @keyframes voidBreathe {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
        }

        .hidden {
            display: none !important;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(0,255,255,0.3);
            animation: float 12s linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-20vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            Let's Go
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
    </div>

    <script>
        class GUMPEngine {
            constructor() {
                this.ctx = null;
                this.active = false;
                this.analyser = null;
                this.dataArray = null;

                // Optimized Motion System
                this.motion = 0;
                this.intensity = 0;
                this.direction = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.totalMotion = 0;
                this.lastMotionTime = Date.now();
                this.motionSmoothingFactor = 0.85; // Improved smoothing
                this.motionThreshold = 0.1; // Noise reduction

                // Evolution System
                this.stage = 'SILENCE';
                this.evolutionProgress = 0;
                this.firstMovement = false;
                this.voidPhase = false;
                this.currentTheme = 'buildup';

                // Musical Structure
                this.bpm = 140;
                this.step = 0;
                this.phrase = 'A';
                this.phraseCount = 0;
                this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D'];
                this.sectionLength = 32;

                // Audio System - Optimized
                this.masterGain = null;
                this.limiter = null;
                this.layerGains = {};
                this.layerPanners = {};
                this.basePositions = {};
                this.layerPositions = {};
                this.panningLerp = 0.03; // Improved responsiveness

                // Optimized Voice Pool
                this.voicePool = {
                    kick: { max: 2, active: [] },
                    sub: { max: 3, active: [] },
                    hats: { max: 4, active: [] },
                    clap: { max: 2, active: [] },
                    wobble: { max: 6, active: [] },
                    fx: { max: 4, active: [] },
                    riser: { max: 3, active: [] }
                };

                // Layers
                this.layers = {
                    kick: false,
                    sub: false,
                    hats: false,
                    clap: false,
                    wobble: false,
                    fx: false,
                    riser: false
                };

                // Musical Elements
                this.key = 'D';
                this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
                this.mode = 'phrygian';
                this.scales = {
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    phrygian: [0, 1, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10]
                };
                this.scale = this.scales[this.mode];
                this.chordProgression = [[0,1,7], [8,12,15], [3,7,10], [10,14,17]];
                this.currentChordIndex = 0;
                this.bassNote = 0;

                // Gesture Recognition - Simplified
                this.gestureRecognition = {
                    shake: 0,
                    sustained: 0
                };

                // Wobble System
                this.wobblePattern = [0,3,7,10,7,3,7,10];
                this.wobbleIndex = 0;
                this.wobbleIntensity = 0;

                this.elements = {};
                this.init();
            }

            init() {
                ['startScreen', 'startBtn', 'evolutionSpace', 'orb']
                    .forEach(id => this.elements[id] = document.getElementById(id));
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotionDetection();
                this.setupInteractionListeners();
            }

            setupInteractionListeners() {
                // Simplified gesture detection
                window.addEventListener('click', (e) => {
                    if (!this.active) return;
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });

                // Touch handling for mobile
                window.addEventListener('touchstart', (e) => {
                    if (!this.active) return;
                    e.preventDefault();
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });
            }

            async start() {
                try {
                    // Request permissions
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    this.setupAudioChain();
                    this.setLayerPositions();
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    this.active = true;
                    this.motionHistory = Array(100).fill(2); // Reduced history size
                    this.motion = 2;
                    this.intensity = 1;
                    this.totalMotion = 200;
                    this.firstMovement = true;
                    
                    this.evolveToBuildup();
                    this.startSequencer();
                    this.animate();

                } catch (e) {
                    console.error('Failed to start engine:', e);
                }
            }

            setupAudioChain() {
                // Simplified audio chain for better performance
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 64; // Reduced for performance
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -6;
                this.limiter.ratio.value = 12;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;

                // Simplified layer setup
                const layerNames = ['kick', 'sub', 'hats', 'clap', 'wobble', 'fx', 'riser'];
                const layerLevels = [1.2, 1.0, 0.6, 0.7, 0.8, 0.4, 0.5];

                layerNames.forEach((name, i) => {
                    this.layerGains[name] = this.ctx.createGain();
                    this.layerGains[name].gain.value = layerLevels[i];
                    
                    this.layerPanners[name] = this.ctx.createPanner();
                    this.layerPanners[name].panningModel = 'HRTF';
                    this.layerPanners[name].distanceModel = 'inverse';
                    this.layerPanners[name].refDistance = 1;

                    this.layerPositions[name] = {x: 0, y: 0, z: 0};
                    this.basePositions[name] = {x: 0, y: 0, z: 0};

                    this.layerGains[name].connect(this.layerPanners[name]);
                    this.layerPanners[name].connect(this.limiter);
                });

                this.limiter.connect(this.analyser);
                this.analyser.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            }

            setLayerPositions() {
                const positions = {
                    kick: {x: 0, y: 0, z: -2},
                    sub: {x: 0, y: -1, z: -3},
                    hats: {x: 0, y: 1, z: -4},
                    clap: {x: 0, y: 0, z: -1},
                    wobble: {x: -2, y: 0, z: -5},
                    fx: {x: 0, y: 3, z: 10},
                    riser: {x: 0, y: 4, z: -10}
                };

                Object.keys(positions).forEach(name => {
                    const pos = positions[name];
                    this.basePositions[name] = {...pos};
                    this.layerPositions[name] = {...pos};
                    
                    if (this.layerPanners[name]) {
                        this.layerPanners[name].positionX.value = pos.x;
                        this.layerPanners[name].positionY.value = pos.y;
                        this.layerPanners[name].positionZ.value = pos.z;
                    }
                });
            }

            setupMotionDetection() {
                let lastAccelTime = 0;
                
                window.addEventListener('devicemotion', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    if (now - lastAccelTime < 16) return; // Throttle to ~60fps
                    lastAccelTime = now;

                    const acc = e.accelerationIncludingGravity;
                    if (!acc || acc.x === null) return;

                    // Improved motion calculation with noise reduction
                    const dx = Math.abs(acc.x - this.lastAccel.x);
                    const dy = Math.abs(acc.y - this.lastAccel.y);
                    const dz = Math.abs(acc.z - this.lastAccel.z);
                    
                    let newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.7;
                    
                    // Apply noise threshold
                    if (newMotion < this.motionThreshold) newMotion = 0;
                    
                    this.updateMotion(newMotion);

                    // Update velocity with damping
                    this.velocity.x += acc.x * 0.01;
                    this.velocity.y += acc.y * 0.01;
                    this.updatePosition();

                    this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);

                    // Shake detection
                    if (newMotion > 3) {
                        this.gestureRecognition.shake += 0.3;
                        if (this.gestureRecognition.shake > 1) {
                            this.triggerShakeEffects();
                        }
                    }

                    this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
                });

                // Fallback mouse motion
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    const velocityX = (newX - lastMouse.x) / dt * 100;
                    const velocityY = (newY - lastMouse.y) / dt * 100;
                    
                    const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.2;
                    this.updateMotion(mouseMotion);
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
                    
                    lastMouse = { x: newX, y: newY, time: now };
                });
            }

            updateMotion(newMotion) {
                // Improved motion smoothing
                this.motion = this.motion * this.motionSmoothingFactor + newMotion * (1 - this.motionSmoothingFactor);
                
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 100) this.motionHistory.shift(); // Reduced size
                
                this.totalMotion += this.motion;

                // Track motion for void state
                if (this.motion > 0.2) {
                    this.lastMotionTime = Date.now();
                    if (this.voidPhase) {
                        this.exitVoidState();
                    }
                }

                if (Date.now() - this.lastMotionTime > 10000 && !this.voidPhase) {
                    this.enterVoidState();
                }

                // Calculate intensity with better algorithm
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = Math.sqrt(this.motionHistory.reduce((sum, m) => sum + Math.pow(m - avgMotion, 2), 0) / this.motionHistory.length);

                // Determine motion pattern
                const recentHistory = this.motionHistory.slice(-30);
                const isRhythmic = recentHistory.filter(m => m > 1.5).length > 15;
                const isErratic = this.intensity > 2.0 && avgMotion > 1.5;
                const isSustained = avgMotion > 2.0 && this.intensity < 1.0;
                const isChaotic = this.intensity > 3.0 && avgMotion > 3.0;

                this.motionPattern = isChaotic ? 'chaotic' : 
                                 isErratic ? 'erratic' : 
                                 isRhythmic ? 'rhythmic' : 
                                 isSustained ? 'sustained' : 'calm';

                this.updateEvolution();
            }

            updateEvolution() {
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;

                if (this.voidPhase) {
                    Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
                    return;
                }

                // Simplified layer activation
                this.layers.kick = this.motionPattern === 'rhythmic' || this.motionPattern === 'chaotic';
                this.layers.sub = avgMotion > 1.0;
                this.layers.hats = avgMotion > 0.5;
                this.layers.clap = this.motionPattern === 'erratic' || this.intensity > 1.5;
                this.layers.wobble = this.motionPattern !== 'calm' && avgMotion > 0.8;
                this.layers.fx = avgMotion > 0.3;
                this.layers.riser = this.intensity > 1.5 || this.motionPattern === 'chaotic';

                // Evolution progression
                this.evolutionProgress = Math.min(this.totalMotion / 800, 3);

                if (this.stage === 'BUILDUP' && this.totalMotion > 200) {
                    this.evolveToDrop();
                } else if (this.stage === 'DROP' && this.totalMotion > 500) {
                    this.evolveToBreakdown();
                } else if (this.stage === 'BREAKDOWN' && this.totalMotion > 800) {
                    this.evolveToRiddim();
                }

                // Dynamic BPM
                let baseBPM = 140 + (avgMotion * 3) + (this.intensity * 2);
                if (this.stage === 'DROP') baseBPM += 15;
                else if (this.stage === 'BREAKDOWN') baseBPM -= 10;

                this.bpm = this.bpm * 0.9 + baseBPM * 0.1;
                this.bpm = Math.max(120, Math.min(160, this.bpm));

                this.updateTheme(avgMotion, this.intensity);
            }

            updateTheme(avgMotion, intensity) {
                let newTheme = 'buildup';
                
                if (this.voidPhase) newTheme = 'void';
                else if (this.motionPattern === 'chaotic' || intensity > 3) newTheme = 'riddim';
                else if (avgMotion > 3 && intensity > 2) newTheme = 'drop';
                else if (avgMotion > 1.5) newTheme = 'buildup';
                else if (avgMotion < 1 && this.totalMotion > 100) newTheme = 'breakdown';

                if (newTheme !== this.currentTheme) {
                    this.currentTheme = newTheme;
                }
            }

            enterVoidState() {
                console.log('🌌 ENTERING VOID STATE');
                this.voidPhase = true;
                this.stage = 'VOID';
                this.elements.orb.className = 'orb void';
                this.currentTheme = 'void';
            }

            exitVoidState() {
                console.log('🌌 EXITING VOID STATE');
                this.voidPhase = false;
                this.stage = 'BUILDUP';
                this.elements.orb.className = 'orb buildup';
                this.currentTheme = 'buildup';
                this.motionHistory = Array(100).fill(2);
                this.totalMotion += 200;
                this.evolveToBuildup();
            }

            triggerShakeEffects() {
                console.log('🌪️ SHAKE DETECTED');
                this.gestureRecognition.shake = 0;
                this.layers.clap = true;
                this.bpm += 5;
            }

            triggerDropImpact() {
                this.playDropImpact();
            }

            evolveToBuildup() {
                this.voidPhase = false;
                this.stage = 'BUILDUP';
                this.elements.orb.className = 'orb buildup';
                this.createParticles(20, '#ff00ff');
                console.log('🔥 BUILDUP EVOLUTION');
            }

            evolveToDrop() {
                this.stage = 'DROP';
                this.elements.orb.className = 'orb drop';
                this.createParticles(30, '#00ff00');
                console.log('🌊 DROP EVOLUTION');
            }

            evolveToBreakdown() {
                this.stage = 'BREAKDOWN';
                this.elements.orb.className = 'orb breakdown';
                this.createParticles(40, '#ff9900');
                console.log('✨ BREAKDOWN EVOLUTION');
            }

            evolveToRiddim() {
                this.stage = 'RIDDIM';
                this.elements.orb.className = 'orb riddim';
                this.createParticles(50, '#ffff00');
                console.log('🌌 RIDDIM EVOLUTION');
            }

            createParticles(count, color) {
                const existing = document.querySelector('.particles');
                if (existing) existing.remove();

                const container = document.createElement('div');
                container.className = 'particles';
                document.body.appendChild(container);

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = Math.random() * 8 + 's';
                    particle.style.animationDuration = (4 + Math.random() * 6) + 's';
                    container.appendChild(particle);
                }
            }

            updatePosition() {
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;

                // Boundary constraints with damping
                if (this.pos.x < 10 || this.pos.x > 90) this.velocity.x *= -0.6;
                if (this.pos.y < 10 || this.pos.y > 90) this.velocity.y *= -0.6;

                this.pos.x = Math.max(10, Math.min(90, this.pos.x));
                this.pos.y = Math.max(10, Math.min(90, this.pos.y));

                this.velocity.x *= 0.95; // Improved damping
                this.velocity.y *= 0.95;
            }

            startSequencer() {
                const tick = () => {
                    if (!this.active) return;
                    
                    this.playStep();
                    this.step = (this.step + 1) % this.sectionLength;
                    
                    if (this.step === 0) {
                        this.phraseCount++;
                        this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
                        this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
                    }
                    
                    const interval = (60 / this.bpm) * 250;
                    setTimeout(tick, interval);
                };
                tick();
            }

            playStep() {
                if (this.voidPhase) return;

                if (this.step % 4 === 0) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }

                // Rhythmic patterns
                if (this.layers.kick && this.step % 4 === 0) this.playKick();
                if (this.layers.sub && this.step % 4 === 0) this.playSub();
                if (this.layers.hats && this.step % 2 === 0) this.playHats();
                if (this.layers.clap && this.step % 8 === 4) this.playClap();
                if (this.layers.wobble && this.step % 1 === 0) this.playWobble();
                if (this.layers.fx && Math.random() < 0.05) this.playFx();
                if (this.layers.riser && this.step % 16 === 0) this.playRiser();

                // Decay gesture recognition
                Object.keys(this.gestureRecognition).forEach(key => {
                    this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.02);
                });
            }

            // Optimized sound generation methods
            playKick() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('kick', osc, gain, 0.5)) return;

                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);

                env.gain.setValueAtTime(1, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);

                gain.gain.value = 1.2;

                osc.connect(env).connect(gain).connect(this.layerGains.kick);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.5);
            }

            playSub() {
                const freq = this.noteToFreq(this.bassNote, 1);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('sub', osc, gain, 0.6)) return;

                osc.type = 'triangle';
                osc.frequency.value = freq;

                env.gain.setValueAtTime(0.8, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);

                gain.gain.value = 1.0;

                osc.connect(env).connect(gain).connect(this.layerGains.sub);
                osc.start();
                osc.stop(this.ctx.currentTime + 0.6);
            }

            playHats() {
                const noise = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                if (!this.allocateVoice('hats', noise, gain, 0.05)) return;

                // Create noise buffer
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }
                noise.buffer = noiseBuffer;

                filter.type = 'highpass';
                filter.frequency.value = 8000;

                env.gain.setValueAtTime(0.6, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);

                gain.gain.value = 0.4;

                noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.hats);
                noise.start();
                noise.stop(this.ctx.currentTime + 0.05);
            }

            playClap() {
                const noise = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                if (!this.allocateVoice('clap', noise, gain, 0.2)) return;

                // Create clap noise
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 1.5);
                }
                noise.buffer = noiseBuffer;

                filter.type = 'bandpass';
                filter.frequency.value = 2000;
                filter.Q.value = 2;

                env.gain.setValueAtTime(0.8, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);

                gain.gain.value = 0.7;

                noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.clap);
                noise.start();
                noise.stop(this.ctx.currentTime + 0.2);
            }

            playWobble() {
                const noteIndex = this.wobblePattern[this.wobbleIndex % this.wobblePattern.length];
                const freq = this.noteToFreq(noteIndex, 2);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                const lfo = this.ctx.createOscillator();

                if (!this.allocateVoice('wobble', osc, gain, 0.25)) return;

                osc.type = 'sawtooth';
                osc.frequency.value = freq;

                lfo.type = 'triangle';
                lfo.frequency.value = 8 + this.intensity * 12;
                lfo.connect(filter.frequency);

                filter.type = 'lowpass';
                filter.frequency.value = 300 + this.motion * 200;
                filter.Q.value = 10;

                env.gain.setValueAtTime(0.6, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);

                gain.gain.value = 0.8;

                osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.wobble);
                
                lfo.start();
                osc.start();
                lfo.stop(this.ctx.currentTime + 0.25);
                osc.stop(this.ctx.currentTime + 0.25);

                this.wobbleIndex++;
            }

            playFx() {
                const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 4);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('fx', osc, gain, 3)) return;

                osc.type = 'sine';
                osc.frequency.value = freq;

                env.gain.setValueAtTime(0, this.ctx.currentTime);
                env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 1);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);

                gain.gain.value = 0.3;

                osc.connect(env).connect(gain).connect(this.layerGains.fx);
                osc.start();
                osc.stop(this.ctx.currentTime + 3);
            }

            playRiser() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('riser', osc, gain, 2)) return;

                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(200, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(1000, this.ctx.currentTime + 2);

                env.gain.setValueAtTime(0, this.ctx.currentTime);
                env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 2);

                gain.gain.value = 0.5;

                osc.connect(env).connect(gain).connect(this.layerGains.riser);
                osc.start();
                osc.stop(this.ctx.currentTime + 2);
            }

            playDropImpact() {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('kick', osc, gain, 1)) return;

                osc.type = 'sine';
                osc.frequency.setValueAtTime(80, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.1);

                env.gain.setValueAtTime(1.5, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);

                gain.gain.value = 1.5;

                osc.connect(env).connect(gain).connect(this.layerGains.kick);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }

            allocateVoice(layer, source, gainNode, duration) {
                const pool = this.voicePool[layer];
                if (!pool) return false;

                // Clean up expired voices
                pool.active = pool.active.filter(voice => {
                    if (this.ctx.currentTime > voice.startTime + voice.duration + 0.1) {
                        if (voice.source && voice.source.stop) {
                            try { voice.source.stop(); } catch(e) {}
                        }
                        return false;
                    }
                    return true;
                });

                // Remove oldest if at limit
                if (pool.active.length >= pool.max) {
                    const oldest = pool.active.shift();
                    if (oldest && oldest.source && oldest.source.stop) {
                        try { oldest.source.stop(); } catch(e) {}
                    }
                }

                const voice = { 
                    source, 
                    gain: gainNode, 
                    startTime: this.ctx.currentTime,
                    duration 
                };
                pool.active.push(voice);

                return true;
            }

            noteToFreq(note, octave = 4) {
                const semitones = this.keyOffsets[this.key] + note;
                return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
            }

            animate() {
                const loop = () => {
                    if (!this.active) return;

                    // Update orb position
                    this.elements.orb.style.left = this.pos.x + '%';
                    this.elements.orb.style.top = this.pos.y + '%';

                    // Update background based on current theme and motion
                    const intensityNorm = Math.min(this.intensity / 3, 1);
                    const motionNorm = Math.min(this.motion / 4, 1);

                    let bg;
                    if (this.voidPhase) {
                        const breathe = Math.sin(Date.now() / 2000) * 0.3 + 0.7;
                        bg = `radial-gradient(circle at 50% 50%, rgba(75, 0, 130, ${0.1 * breathe}) 10%, #000000 60%)`;
                    } else {
                        const colors = {
                            buildup: ['#ff00ff', '#000000'],
                            drop: ['#00ff00', '#000000'],
                            breakdown: ['#ff9900', '#ff00ff'],
                            riddim: ['#ffff00', '#ff0000']
                        };
                        
                        const themeColors = colors[this.currentTheme] || colors.buildup;
                        bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
                        bg += `${themeColors[0]} ${5 * motionNorm}%, `;
                        bg += `${themeColors[1]} ${30 * intensityNorm}%, `;
                        bg += `#000000 ${70 + 20 * intensityNorm}%)`;
                    }

                    document.body.style.background = bg;

                    // Update 3D panning
                    const panMultiplier = 2;
                    const targetX = Math.cos(this.direction * Math.PI / 180) * this.motion * panMultiplier;
                    const targetY = Math.sin(this.direction * Math.PI / 180) * this.motion * panMultiplier;

                    Object.keys(this.layerPanners).forEach(name => {
                        const basePos = this.basePositions[name];
                        const currentPos = this.layerPositions[name];
                        
                        const newX = basePos.x + targetX * 0.5;
                        const newY = basePos.y + targetY * 0.3;
                        
                        currentPos.x += (newX - currentPos.x) * this.panningLerp;
                        currentPos.y += (newY - currentPos.y) * this.panningLerp;

                        if (this.layerPanners[name]) {
                            this.layerPanners[name].positionX.value = currentPos.x;
                            this.layerPanners[name].positionY.value = currentPos.y;
                            this.layerPanners[name].positionZ.value = currentPos.z;
                        }
                    });

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
        }

        // Initialize the engine
        new GUMPEngine();
    </script>
</body>
</html>
