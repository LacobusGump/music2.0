<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Audiophile Void Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 3s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
      opacity: 0;
      animation: fadeIn 2s ease forwards;
    }
    
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    
    .start-btn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1) 0%, transparent 60%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 300;
      letter-spacing: 3px;
      backdrop-filter: blur(20px);
      transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
    }
    
    .start-btn::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%);
      transform: rotate(0deg);
      animation: rotate 20s linear infinite;
    }
    
    @keyframes rotate {
      to { transform: rotate(360deg); }
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      transform: scale(1.05);
      box-shadow: 0 0 40px rgba(255,255,255,0.1);
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.1) 40%, transparent 70%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      filter: blur(0.5px);
      mix-blend-mode: screen;
    }
    
    .orb.pulse {
      animation: pulse 0.3s cubic-bezier(0.4, 0, 0.6, 1);
    }
    
    @keyframes pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.8); }
    }
    
    .orb.tribal {
      background: radial-gradient(circle at 30% 30%, #ff6b35 0%, rgba(255,107,53,0.3) 40%, transparent 70%);
      box-shadow: 0 0 80px rgba(255,107,53,0.5), 0 0 120px rgba(255,107,53,0.3);
    }
    
    .orb.orchestral {
      background: radial-gradient(circle at 30% 30%, #4a90e2 0%, rgba(74,144,226,0.3) 40%, transparent 70%);
      box-shadow: 0 0 100px rgba(74,144,226,0.5), 0 0 150px rgba(74,144,226,0.3);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle at 30% 30%, #fff 0%, #9b59b6 20%, #e74c3c 40%, transparent 70%);
      box-shadow: 0 0 150px rgba(155,89,182,0.6), 0 0 200px rgba(155,89,182,0.3);
      filter: blur(0.2px);
    }
    
    .ui-panel {
      position: fixed;
      background: rgba(0,0,0,0.5);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 12px;
      padding: 20px;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      letter-spacing: 0.5px;
    }
    
    .ui-panel.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-panel.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-panel.top-right {
      top: 20px;
      right: 20px;
      text-align: right;
    }
    
    .stage-name {
      font-size: 18px;
      font-weight: 200;
      letter-spacing: 3px;
      margin-bottom: 12px;
      color: #fff;
    }
    
    .metric {
      margin: 8px 0;
      display: flex;
      align-items: center;
      justify-content: space-between;
      min-width: 180px;
    }
    
    .metric-value {
      font-weight: 400;
      color: #fff;
    }
    
    .bar {
      width: 100%;
      height: 2px;
      background: rgba(255,255,255,0.1);
      margin: 12px 0;
      border-radius: 1px;
      overflow: hidden;
      position: relative;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      width: 0%;
      transition: width 0.15s cubic-bezier(0.4, 0, 0.6, 1);
      border-radius: 1px;
      box-shadow: 0 0 10px rgba(155,89,182,0.5);
    }
    
    .instruction {
      position: fixed;
      bottom: 60px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: 300;
    }
    
    .instruction.show { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 120px;
      pointer-events: none;
      z-index: 3;
      opacity: 0.8;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 2px;
      background: linear-gradient(0deg, rgba(255,255,255,0.6), rgba(255,255,255,0.05));
      border-radius: 1px 1px 0 0;
      transition: height 0.05s ease-out;
    }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      border-radius: 50%;
      background: rgba(255,255,255,0.4);
      animation: drift 20s linear infinite;
    }
    
    @keyframes drift {
      0% { 
        transform: translate(0, 100vh) scale(0);
        opacity: 0;
      }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { 
        transform: translate(100px, -100px) scale(1.2);
        opacity: 0;
      }
    }
    
    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 40%, rgba(0,0,0,0.4) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">BREATHE</div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO SHAPE THE VOID</div>
    
    <div class="ui-panel top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">
        <span>TECHNIQUE</span>
        <span class="metric-value" id="technique">WAITING</span>
      </div>
      <div class="metric">
        <span>HARMONIC</span>
        <span class="metric-value" id="harmonic">SUSPENDED</span>
      </div>
    </div>
    
    <div class="ui-panel bottom-left">
      <div class="metric">MOTION FLOW</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">SPECTRAL TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="tensionBar"></div>
      </div>
    </div>
    
    <div class="ui-panel top-right">
      <div class="metric">
        <span>TEMPO</span>
        <span class="metric-value" id="bpmDisplay">60</span>
      </div>
      <div class="metric">
        <span>KEY</span>
        <span class="metric-value" id="keyDisplay">Am</span>
      </div>
      <div class="metric">
        <span>VOICES</span>
        <span class="metric-value" id="voiceCount">0</span>
      </div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>

  <script>
    class AudiophileVoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        
        // High-quality audio parameters
        this.sampleRate = 48000;
        this.bufferSize = 256; // Lower latency
        
        // Musical timing with micro-timing for groove
        this.bpm = 60;
        this.swing = 0.05; // Subtle swing factor
        this.currentNote = 0;
        this.nextNoteTime = 0.0;
        this.scheduleAheadTime = 0.1;
        this.noteLength = 0.05;
        
        // Motion tracking with smoothing
        this.motion = 0;
        this.smoothMotion = 0;
        this.intensity = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.acceleration = { x: 0, y: 0 };
        this.jerk = { x: 0, y: 0 }; // Rate of change of acceleration
        
        // Evolution states
        this.stage = 'SILENCE';
        this.stageProgress = 0;
        this.totalEnergy = 0;
        
        // Professional audio chain components
        this.masterBus = null;
        this.mixBus = null;
        this.sendBus = null;
        
        // High-end processing
        this.multiband = {
          low: null,
          mid: null,
          high: null,
          crossoverLow: 200,
          crossoverHigh: 2000
        };
        
        // Spatial audio
        this.binauralPanner = null;
        this.ambisonicEncoder = null;
        
        // Analysis
        this.analyser = null;
        this.spectralData = null;
        
        // Voice architecture
        this.voiceAllocator = new VoiceAllocator();
        this.layers = {};
        
        // Harmonic system
        this.key = 'A';
        this.mode = 'aeolian';
        this.currentChord = [0, 3, 5];
        this.tension = 0;
        
        this.elements = {};
        this.spectrumBars = [];
        
        this.init();
      }

      init() {
        this.cacheElements();
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupSpectrumVisualizer();
      }

      cacheElements() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'harmonic', 'motionBar', 'tensionBar',
         'bpmDisplay', 'keyDisplay', 'voiceCount', 'cinematicOverlay', 'spectrumViz']
        .forEach(id => this.elements[id] = document.getElementById(id));
      }

      setupSpectrumVisualizer() {
        const barCount = 128;
        for (let i = 0; i < barCount; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${(i / barCount) * 100}%`;
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      async start() {
        try {
          // Request permissions for motion
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            await DeviceMotionEvent.requestPermission();
          }

          // Create high-quality audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'playback',
            sampleRate: this.sampleRate
          });
          
          await this.ctx.resume();
          this.setupAudioChain();
          this.initializeLayers();

          // UI transitions
          this.elements.startScreen.style.display = 'none';
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 3000);
          }, 1000);

          this.active = true;
          this.nextNoteTime = this.ctx.currentTime;
          this.scheduler();
          this.animate();
          
        } catch (e) {
          console.error('Initialization failed:', e);
        }
      }

      setupAudioChain() {
        // Professional mastering chain
        this.setupMasterBus();
        this.setupMixBus();
        this.setupSendEffects();
        this.setupAnalysis();
        
        // Connect main signal flow
        this.mixBus.connect(this.multiband.splitter);
        this.multiband.lowBand.connect(this.masterBus);
        this.multiband.midBand.connect(this.masterBus);
        this.multiband.highBand.connect(this.masterBus);
        this.masterBus.connect(this.ctx.destination);
        this.masterBus.connect(this.analyser);
      }

      setupMasterBus() {
        // Create multiband processing
        this.multiband.splitter = this.ctx.createChannelSplitter(2);
        this.multiband.merger = this.ctx.createChannelMerger(2);
        
        // Low band
        this.multiband.lowBand = this.ctx.createBiquadFilter();
        this.multiband.lowBand.type = 'lowshelf';
        this.multiband.lowBand.frequency.value = this.multiband.crossoverLow;
        this.multiband.lowBand.gain.value = 2; // Gentle bass boost
        
        // Mid band with dynamic EQ
        this.multiband.midBand = this.ctx.createBiquadFilter();
        this.multiband.midBand.type = 'peaking';
        this.multiband.midBand.frequency.value = 1000;
        this.multiband.midBand.Q.value = 0.5;
        this.multiband.midBand.gain.value = 0;
        
        // High band with air
        this.multiband.highBand = this.ctx.createBiquadFilter();
        this.multiband.highBand.type = 'highshelf';
        this.multiband.highBand.frequency.value = 8000;
        this.multiband.highBand.gain.value = 1.5; // Air frequencies
        
        // Master limiter with lookahead
        this.masterBus = this.ctx.createDynamicsCompressor();
        this.masterBus.threshold.value = -3;
        this.masterBus.knee.value = 2;
        this.masterBus.ratio.value = 20;
        this.masterBus.attack.value = 0.001;
        this.masterBus.release.value = 0.1;
      }

      setupMixBus() {
        // Mix bus with glue compression
        this.mixBus = this.ctx.createDynamicsCompressor();
        this.mixBus.threshold.value = -18;
        this.mixBus.knee.value = 6;
        this.mixBus.ratio.value = 4;
        this.mixBus.attack.value = 0.01;
        this.mixBus.release.value = 0.1;
      }

      setupSendEffects() {
        // Convolution reverb with custom IR
        this.sendBus = this.ctx.createGain();
        this.sendBus.gain.value = 0.3;
        
        // Create high-quality reverb
        this.reverb = this.ctx.createConvolver();
        this.reverb.buffer = this.createReverbIR(3, 2, 0.5);
        
        // Delay with modulation
        this.delay = this.ctx.createDelay(2);
        this.delay.delayTime.value = 0.375; // Dotted eighth
        
        this.delayFeedback = this.ctx.createGain();
        this.delayFeedback.gain.value = 0.3;
        
        this.delayFilter = this.ctx.createBiquadFilter();
        this.delayFilter.type = 'highpass';
        this.delayFilter.frequency.value = 400;
        
        // Connect send effects
        this.sendBus.connect(this.reverb);
        this.sendBus.connect(this.delay);
        this.delay.connect(this.delayFilter);
        this.delayFilter.connect(this.delayFeedback);
        this.delayFeedback.connect(this.delay);
        
        this.reverb.connect(this.mixBus);
        this.delayFilter.connect(this.mixBus);
      }

      setupAnalysis() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.analyser.smoothingTimeConstant = 0.8;
        this.spectralData = new Float32Array(this.analyser.frequencyBinCount);
      }

      createReverbIR(duration, decay, mix) {
        const length = this.ctx.sampleRate * duration;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            // Early reflections
            if (i < length * 0.1) {
              if (Math.random() < 0.001) {
                channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 0.5);
              }
            }
            // Diffuse tail
            else {
              channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay) * mix;
            }
          }
        }
        
        return impulse;
      }

      initializeLayers() {
        // Define sophisticated layer architecture
        this.layers = {
          sub: new SubBassLayer(this),
          kick: new KickLayer(this),
          bass: new BassLayer(this),
          rhythm: new RhythmLayer(this),
          harmonic: new HarmonicLayer(this),
          melodic: new MelodicLayer(this),
          textural: new TexturalLayer(this),
          atmospheric: new AtmosphericLayer(this)
        };
        
        // Connect all layers to mix bus
        Object.values(this.layers).forEach(layer => {
          layer.output.connect(this.mixBus);
          if (layer.sendAmount > 0) {
            layer.output.connect(this.sendBus);
          }
        });
      }

      setupMotionDetection() {
        // High-resolution motion tracking
        let lastTime = 0;
        let lastAccel = { x: 0, y: 0, z: 0 };
        
        window.addEventListener('devicemotion', e => {
          if (!this.active || !e.accelerationIncludingGravity) return;
          
          const currentTime = Date.now();
          const dt = Math.max(1, currentTime - lastTime) / 1000;
          
          const acc = e.accelerationIncludingGravity;
          
          // Calculate jerk (derivative of acceleration)
          this.jerk.x = (acc.x - lastAccel.x) / dt;
          this.jerk.y = (acc.y - lastAccel.y) / dt;
          
          // Update motion with sophisticated filtering
          const rawMotion = Math.sqrt(acc.x ** 2 + acc.y ** 2 + acc.z ** 2);
          const jerkMagnitude = Math.sqrt(this.jerk.x ** 2 + this.jerk.y ** 2);
          
          this.motion = this.motion * 0.7 + rawMotion * 0.3;
          this.smoothMotion = this.smoothMotion * 0.9 + this.motion * 0.1;
          this.intensity = Math.min(1, jerkMagnitude / 100);
          
          // Update position physics
          this.velocity.x += acc.x * dt * 0.5;
          this.velocity.y += acc.y * dt * 0.5;
          this.velocity.x *= 0.95; // Damping
          this.velocity.y *= 0.95;
          
          this.pos.x += this.velocity.x;
          this.pos.y += this.velocity.y;
          this.pos.x = Math.max(5, Math.min(95, this.pos.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y));
          
          lastAccel = { x: acc.x, y: acc.y, z: acc.z };
          lastTime = currentTime;
          
          this.updateEvolution();
        });
        
        // Mouse/touch fallback with smoothing
        let mouseVelocity = { x: 0, y: 0 };
        let lastMouse = { x: 0, y: 0, time: 0 };
        
        const handlePointer = e => {
          if (!this.active) return;
          
          const rect = document.body.getBoundingClientRect();
          const x = (e.clientX / rect.width) * 100;
          const y = (e.clientY / rect.height) * 100;
          const currentTime = Date.now();
          const dt = Math.max(1, currentTime - lastMouse.time) / 1000;
          
          if (lastMouse.time > 0) {
            mouseVelocity.x = (x - lastMouse.x) / dt;
            mouseVelocity.y = (y - lastMouse.y) / dt;
            
            const speed = Math.sqrt(mouseVelocity.x ** 2 + mouseVelocity.y ** 2);
            this.motion = this.motion * 0.8 + Math.min(speed / 50, 10) * 0.2;
            this.smoothMotion = this.smoothMotion * 0.95 + this.motion * 0.05;
            
            // Calculate intensity from acceleration change
            const accelX = (mouseVelocity.x - this.velocity.x) / dt;
            const accelY = (mouseVelocity.y - this.velocity.y) / dt;
            this.intensity = Math.min(1, Math.sqrt(accelX ** 2 + accelY ** 2) / 1000);
          }
          
          this.pos.x = x;
          this.pos.y = y;
          this.velocity = { ...mouseVelocity };
          
          lastMouse = { x, y, time: currentTime };
          this.updateEvolution();
        };
        
        window.addEventListener('mousemove', handlePointer);
        window.addEventListener('touchmove', e => handlePointer(e.touches[0]));
      }

      updateEvolution() {
        // Accumulate energy
        this.totalEnergy += this.smoothMotion * 0.01;
        
        // Evolution thresholds with hysteresis
        const thresholds = {
          TRIBAL: { enter: 10, exit: 5 },
          ORCHESTRAL: { enter: 50, exit: 40 },
          TRANSCENDENT: { enter: 100, exit: 90 }
        };
        
        // State transitions
        if (this.stage === 'SILENCE' && this.totalEnergy > thresholds.TRIBAL.enter) {
          this.evolve('TRIBAL');
        } else if (this.stage === 'TRIBAL' && this.totalEnergy > thresholds.ORCHESTRAL.enter) {
          this.evolve('ORCHESTRAL');
        } else if (this.stage === 'ORCHESTRAL' && this.totalEnergy > thresholds.TRANSCENDENT.enter) {
          this.evolve('TRANSCENDENT');
        }
        
        // Update tempo with musical sensibility
        const targetBPM = 60 + this.smoothMotion * 8 + this.totalEnergy * 0.5;
        this.bpm = this.bpm * 0.95 + Math.min(140, targetBPM) * 0.05;
        
        // Update harmonic tension
        this.tension = this.intensity * 0.3 + this.smoothMotion * 0.1;
        
        // Update layers based on motion patterns
        this.updateLayers();
      }

      evolve(newStage) {
        this.stage = newStage;
        this.stageProgress = 0;
        
        const stageConfigs = {
          TRIBAL: { orbClass: 'tribal', particles: 30, color: '#ff6b35' },
          ORCHESTRAL: { orbClass: 'orchestral', particles: 50, color: '#4a90e2' },
          TRANSCENDENT: { orbClass: 'transcendent', particles: 80, color: '#9b59b6' }
        };
        
        const config = stageConfigs[newStage];
        this.elements.orb.className = `orb ${config.orbClass}`;
        this.createParticles(config.particles, config.color);
        
        // Musical changes
        if (newStage === 'ORCHESTRAL') {
          this.key = 'C';
          this.mode = 'ionian';
        } else if (newStage === 'TRANSCENDENT') {
          this.key = 'E';
          this.mode = 'lydian';
        }
      }

      updateLayers() {
        const m = this.smoothMotion;
        const i = this.intensity;
        const e = this.totalEnergy;
        
        // Sophisticated layer activation logic
        this.layers.sub.active = m > 0.5 || e > 5;
        this.layers.kick.active = m > 1 && this.stage !== 'SILENCE';
        this.layers.bass.active = m > 1.5 && e > 10;
        this.layers.rhythm.active = m > 2 || i > 0.3;
        this.layers.harmonic.active = e > 20 && m < 5;
        this.layers.melodic.active = this.stage !== 'SILENCE' && m > 0.5;
        this.layers.textural.active = i < 0.2 && e > 30;
        this.layers.atmospheric.active = m < 1 && e > 50;
        
        // Update layer parameters
        Object.values(this.layers).forEach(layer => {
          layer.updateParameters(m, i, this.tension);
        });
      }

      scheduler() {
        // High-precision scheduling
        const currentTime = this.ctx.currentTime;
        
        while (this.nextNoteTime < currentTime + this.scheduleAheadTime) {
          // Apply swing timing
          const swingOffset = this.currentNote % 2 === 1 ? this.swing : 0;
          this.scheduleNote(this.currentNote, this.nextNoteTime + swingOffset);
          this.nextNote();
        }
        
        if (this.active) {
          requestAnimationFrame(() => this.scheduler());
        }
      }

      nextNote() {
        const secondsPerBeat = 60.0 / this.bpm;
        this.nextNoteTime += 0.125 * secondsPerBeat; // 32nd notes
        
        this.currentNote++;
        if (this.currentNote === 32) {
          this.currentNote = 0;
          this.updateHarmony();
        }
      }

      scheduleNote(noteNumber, time) {
        // Trigger layers with musical timing
        Object.values(this.layers).forEach(layer => {
          if (layer.active) {
            layer.trigger(noteNumber, time);
          }
        });
        
        // Visual pulse on downbeats
        if (noteNumber % 8 === 0) {
          setTimeout(() => {
            this.elements.orb.classList.add('pulse');
            setTimeout(() => this.elements.orb.classList.remove('pulse'), 300);
          }, (time - this.ctx.currentTime) * 1000);
        }
      }

      updateHarmony() {
        // Sophisticated harmonic progression
        const progressions = {
          aeolian: [[0, 3, 5], [5, 8, 10], [3, 7, 10], [0, 3, 5]],
          ionian: [[0, 4, 7], [5, 9, 0], [7, 11, 2], [0, 4, 7]],
          lydian: [[0, 4, 7], [2, 6, 9], [7, 11, 2], [0, 4, 6]]
        };
        
        const progression = progressions[this.mode] || progressions.aeolian;
        this.currentChord = progression[Math.floor(this.totalEnergy / 10) % progression.length];
      }

      createParticles(count, color) {
        const existing = document.querySelector('.particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.background = color;
          particle.style.animationDelay = Math.random() * 20 + 's';
          particle.style.animationDuration = (15 + Math.random() * 10) + 's';
          container.appendChild(particle);
        }
      }

      updateUI() {
        // Update all UI elements
        this.elements.stageName.textContent = this.stage;
        this.elements.technique.textContent = this.getCurrentTechnique();
        this.elements.harmonic.textContent = this.getHarmonicDescription();
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = `${this.key}${this.mode.charAt(0).toUpperCase()}`;
        
        const motionPercent = Math.min(this.smoothMotion * 10, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        const tensionPercent = this.tension * 100;
        this.elements.tensionBar.style.width = tensionPercent + '%';
        
        const activeVoices = Object.values(this.layers).reduce((sum, layer) => 
          sum + (layer.active ? layer.voiceCount : 0), 0);
        this.elements.voiceCount.textContent = activeVoices;
        
        // Update spectrum
        if (this.analyser) {
          this.analyser.getFloatFrequencyData(this.spectralData);
          const binWidth = this.spectralData.length / this.spectrumBars.length;
          
          this.spectrumBars.forEach((bar, i) => {
            const startBin = Math.floor(i * binWidth);
            const endBin = Math.floor((i + 1) * binWidth);
            let sum = 0;
            
            for (let j = startBin; j < endBin; j++) {
              sum += this.spectralData[j] + 140; // Normalize from -140 to 0 dB
            }
            
            const average = sum / (endBin - startBin);
            const height = Math.max(0, average * 1.2);
            bar.style.height = height + 'px';
          });
        }
      }

      getCurrentTechnique() {
        if (this.intensity > 0.7) return 'FRACTAL BURST';
        if (this.smoothMotion > 5) return 'FLOW STATE';
        if (this.tension > 0.5) return 'HARMONIC TENSION';
        if (this.totalEnergy < 10) return 'GATHERING';
        return 'EXPLORING';
      }

      getHarmonicDescription() {
        const chordTypes = {
          '0,3,5': 'MINOR TRIAD',
          '0,4,7': 'MAJOR TRIAD',
          '0,3,7': 'SUS2',
          '0,5,7': 'SUS4',
          '0,4,6': 'AUGMENTED'
        };
        
        const chordKey = this.currentChord.sort().join(',');
        return chordTypes[chordKey] || 'COMPLEX';
      }

      animate() {
        if (!this.active) return;
        
        // Update orb position
        this.elements.orb.style.left = this.pos.x + '%';
        this.elements.orb.style.top = this.pos.y + '%';
        
        // Update UI
        this.updateUI();
        
        // Dynamic background
        const gradient = this.generateBackground();
        document.body.style.background = gradient;
        
        // Cinematic overlay
        const showOverlay = this.intensity > 0.5 || this.stage === 'TRANSCENDENT';
        this.elements.cinematicOverlay.classList.toggle('active', showOverlay);
        
        requestAnimationFrame(() => this.animate());
      }

      generateBackground() {
        const stageColors = {
          SILENCE: ['#0a0a0a', '#1a1a1a'],
          TRIBAL: ['#1a0a0a', '#2a1515'],
          ORCHESTRAL: ['#0a0a1a', '#151a2a'],
          TRANSCENDENT: ['#0a0a0a', '#1a0a1a', '#2a0a2a']
        };
        
        const colors = stageColors[this.stage];
        const centerX = this.pos.x;
        const centerY = this.pos.y;
        const spread = 20 + this.smoothMotion * 10;
        
        let gradient = `radial-gradient(circle at ${centerX}% ${centerY}%, `;
        colors.forEach((color, i) => {
          const position = i * spread + this.intensity * 10;
          gradient += `${color} ${position}%`;
          if (i < colors.length - 1) gradient += ', ';
        });
        gradient += ')';
        
        return gradient;
      }
    }

    // Professional audio layer implementations
    class AudioLayer {
      constructor(engine, name) {
        this.engine = engine;
        this.name = name;
        this.active = false;
        this.voiceCount = 0;
        this.sendAmount = 0.2;
        
        // Create layer-specific audio chain
        this.output = engine.ctx.createGain();
        this.output.gain.value = 1;
        
        this.compressor = engine.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 4;
        this.compressor.ratio.value = 3;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.1;
        
        this.eq = engine.ctx.createBiquadFilter();
        this.eq.type = 'peaking';
        this.eq.frequency.value = 1000;
        this.eq.Q.value = 1;
        this.eq.gain.value = 0;
        
        this.compressor.connect(this.eq);
        this.eq.connect(this.output);
      }
      
      trigger(noteNumber, time) {
        // Override in subclasses
      }
      
      updateParameters(motion, intensity, tension) {
        // Override in subclasses
      }
    }

    class SubBassLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'sub');
        this.fundamental = 55; // A1
      }
      
      trigger(noteNumber, time) {
        if (noteNumber % 8 !== 0) return;
        
        const osc = this.engine.ctx.createOscillator();
        const gain = this.engine.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = this.fundamental;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.8, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
        
        osc.connect(gain);
        gain.connect(this.compressor);
        
        osc.start(time);
        osc.stop(time + 0.5);
        
        this.voiceCount = 1;
      }
      
      updateParameters(motion, intensity, tension) {
        this.fundamental = 55 * Math.pow(2, tension * 0.25); // Slight pitch bend
      }
    }

    class KickLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'kick');
      }
      
      trigger(noteNumber, time) {
        if (noteNumber % 4 !== 0) return;
        
        // Multi-oscillator kick with click
        const clickOsc = this.engine.ctx.createOscillator();
        const bodyOsc = this.engine.ctx.createOscillator();
        const subOsc = this.engine.ctx.createOscillator();
        
        const clickGain = this.engine.ctx.createGain();
        const bodyGain = this.engine.ctx.createGain();
        const subGain = this.engine.ctx.createGain();
        const masterGain = this.engine.ctx.createGain();
        
        // Click transient
        clickOsc.type = 'square';
        clickOsc.frequency.setValueAtTime(200, time);
        clickOsc.frequency.exponentialRampToValueAtTime(40, time + 0.02);
        
        clickGain.gain.setValueAtTime(0.3, time);
        clickGain.gain.exponentialRampToValueAtTime(0.001, time + 0.02);
        
        // Body
        bodyOsc.type = 'sine';
        bodyOsc.frequency.setValueAtTime(60, time);
        bodyOsc.frequency.exponentialRampToValueAtTime(30, time + 0.15);
        
        bodyGain.gain.setValueAtTime(1, time);
        bodyGain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
        
        // Sub
        subOsc.type = 'sine';
        subOsc.frequency.value = 35;
        
        subGain.gain.setValueAtTime(0.5, time);
        subGain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
        
        masterGain.gain.value = 0.9;
        
        // Connect
        clickOsc.connect(clickGain);
        bodyOsc.connect(bodyGain);
        subOsc.connect(subGain);
        
        clickGain.connect(masterGain);
        bodyGain.connect(masterGain);
        subGain.connect(masterGain);
        masterGain.connect(this.compressor);
        
        // Start
        clickOsc.start(time);
        bodyOsc.start(time);
        subOsc.start(time);
        
        clickOsc.stop(time + 0.02);
        bodyOsc.stop(time + 0.2);
        subOsc.stop(time + 0.3);
        
        this.voiceCount = 3;
      }
    }

    class BassLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'bass');
        this.pattern = [0, 0, 3, 5, 7, 5, 3, 0];
        this.patternIndex = 0;
      }
      
      trigger(noteNumber, time) {
        if (noteNumber % 2 !== 0) return;
        
        const note = this.pattern[this.patternIndex % this.pattern.length];
        const freq = this.getNoteFrequency(note, 2);
        
        const osc1 = this.engine.ctx.createOscillator();
        const osc2 = this.engine.ctx.createOscillator();
        const filter = this.engine.ctx.createBiquadFilter();
        const gain = this.engine.ctx.createGain();
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc1.detune.value = -5;
        
        osc2.type = 'square';
        osc2.frequency.value = freq * 0.5;
        osc2.detune.value = 5;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, time);
        filter.frequency.exponentialRampToValueAtTime(1000, time + 0.05);
        filter.frequency.exponentialRampToValueAtTime(200, time + 0.2);
        filter.Q.value = 8;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.4, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);
        
        osc1.start(time);
        osc2.start(time);
        osc1.stop(time + 0.3);
        osc2.stop(time + 0.3);
        
        this.patternIndex++;
        this.voiceCount = 2;
      }
      
      getNoteFrequency(interval, octave) {
        const keyMap = { A: 0, B: 2, C: 3, D: 5, E: 7, F: 8, G: 10 };
        const rootNote = keyMap[this.engine.key] || 0;
        const modeIntervals = {
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          ionian: [0, 2, 4, 5, 7, 9, 11],
          lydian: [0, 2, 4, 6, 7, 9, 11]
        };
        
        const scale = modeIntervals[this.engine.mode] || modeIntervals.aeolian;
        const noteInScale = scale[interval % scale.length];
        const totalSemitones = rootNote + noteInScale + (octave - 4) * 12;
        
        return 440 * Math.pow(2, totalSemitones / 12);
      }
    }

    class RhythmLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'rhythm');
        this.euclidean = this.generateEuclidean(13, 8); // Interesting rhythm
      }
      
      generateEuclidean(steps, pulses) {
        const pattern = new Array(steps).fill(0);
        const spacing = steps / pulses;
        
        for (let i = 0; i < pulses; i++) {
          pattern[Math.floor(i * spacing)] = 1;
        }
        
        return pattern;
      }
      
      trigger(noteNumber, time) {
        const step = noteNumber % this.euclidean.length;
        if (!this.euclidean[step]) return;
        
        // Layered percussion
        const noise = this.engine.ctx.createBufferSource();
        const noiseBuffer = this.engine.ctx.createBuffer(1, 4800, this.engine.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        
        noise.buffer = noiseBuffer;
        
        const filter = this.engine.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 2000 + Math.random() * 2000;
        filter.Q.value = 10;
        
        const gain = this.engine.ctx.createGain();
        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.05);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);
        
        noise.start(time);
        
        this.voiceCount = 1;
      }
    }

    class HarmonicLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'harmonic');
        this.voiceSpread = 7; // Unison voices
      }
      
      trigger(noteNumber, time) {
        if (noteNumber % 16 !== 0) return;
        
        const chord = this.engine.currentChord;
        const voicesPerNote = Math.floor(this.voiceSpread / chord.length);
        
        chord.forEach((interval, chordIndex) => {
          for (let v = 0; v < voicesPerNote; v++) {
            const freq = this.getNoteFrequency(interval, 4);
            const osc = this.engine.ctx.createOscillator();
            const gain = this.engine.ctx.createGain();
            const pan = this.engine.ctx.createStereoPanner();
            
            osc.type = 'sine';
            osc.frequency.value = freq * (1 + (v - voicesPerNote/2) * 0.001); // Slight detune
            
            // Stereo spread
            pan.pan.value = (chordIndex - chord.length/2) * 0.3;
            
            gain.gain.setValueAtTime(0, time);
            gain.gain.linearRampToValueAtTime(0.1 / voicesPerNote, time + 1);
            gain.gain.linearRampToValueAtTime(0.05 / voicesPerNote, time + 3);
            gain.gain.exponentialRampToValueAtTime(0.001, time + 4);
            
            osc.connect(gain);
            gain.connect(pan);
            pan.connect(this.compressor);
            
            osc.start(time);
            osc.stop(time + 4);
          }
        });
        
        this.voiceCount = chord.length * voicesPerNote;
      }
      
      getNoteFrequency(interval, octave) {
        // Same as BassLayer
        const keyMap = { A: 0, B: 2, C: 3, D: 5, E: 7, F: 8, G: 10 };
        const rootNote = keyMap[this.engine.key] || 0;
        const modeIntervals = {
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          ionian: [0, 2, 4, 5, 7, 9, 11],
          lydian: [0, 2, 4, 6, 7, 9, 11]
        };
        
        const scale = modeIntervals[this.engine.mode] || modeIntervals.aeolian;
        const noteInScale = scale[interval % scale.length];
        const totalSemitones = rootNote + noteInScale + (octave - 4) * 12;
        
        return 440 * Math.pow(2, totalSemitones / 12);
      }
    }

    class MelodicLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'melodic');
        this.sequence = [];
        this.generateSequence();
      }
      
      generateSequence() {
        // Procedural melody generation
        const length = 16;
        const range = 7;
        let lastNote = Math.floor(range / 2);
        
        this.sequence = [];
        for (let i = 0; i < length; i++) {
          const direction = Math.random() > 0.5 ? 1 : -1;
          const step = Math.floor(Math.random() * 3);
          lastNote = Math.max(0, Math.min(range - 1, lastNote + direction * step));
          this.sequence.push(lastNote);
        }
      }
      
      trigger(noteNumber, time) {
        if (noteNumber % 2 !== 0) return;
        
        const seqIndex = (noteNumber / 2) % this.sequence.length;
        const note = this.sequence[seqIndex];
        const freq = this.getNoteFrequency(note, 5);
        
        const osc = this.engine.ctx.createOscillator();
        const filter = this.engine.ctx.createBiquadFilter();
        const gain = this.engine.ctx.createGain();
        
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 2000;
        filter.Q.value = 2;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.15, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.2);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);
        
        osc.start(time);
        osc.stop(time + 0.2);
        
        this.voiceCount = 1;
        
        // Regenerate sequence occasionally
        if (Math.random() < 0.01) {
          this.generateSequence();
        }
      }
      
      getNoteFrequency(interval, octave) {
        const keyMap = { A: 0, B: 2, C: 3, D: 5, E: 7, F: 8, G: 10 };
        const rootNote = keyMap[this.engine.key] || 0;
        const modeIntervals = {
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          ionian: [0, 2, 4, 5, 7, 9, 11],
          lydian: [0, 2, 4, 6, 7, 9, 11]
        };
        
        const scale = modeIntervals[this.engine.mode] || modeIntervals.aeolian;
        const noteInScale = scale[interval % scale.length];
        const totalSemitones = rootNote + noteInScale + (octave - 4) * 12;
        
        return 440 * Math.pow(2, totalSemitones / 12);
      }
    }

    class TexturalLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'textural');
        this.grainSize = 0.05;
        this.grainDensity = 10;
      }
      
      trigger(noteNumber, time) {
        if (Math.random() > 0.1) return; // Sparse triggering
        
        // Granular synthesis
        for (let i = 0; i < this.grainDensity; i++) {
          const grainTime = time + Math.random() * 0.1;
          const freq = 200 + Math.random() * 800;
          
          const osc = this.engine.ctx.createOscillator();
          const gain = this.engine.ctx.createGain();
          const filter = this.engine.ctx.createBiquadFilter();
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          filter.type = 'bandpass';
          filter.frequency.value = freq;
          filter.Q.value = 5;
          
          // Grain envelope
          gain.gain.setValueAtTime(0, grainTime);
          gain.gain.linearRampToValueAtTime(0.05, grainTime + this.grainSize * 0.3);
          gain.gain.linearRampToValueAtTime(0, grainTime + this.grainSize);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.compressor);
          
          osc.start(grainTime);
          osc.stop(grainTime + this.grainSize);
        }
        
        this.voiceCount = this.grainDensity;
      }
      
      updateParameters(motion, intensity, tension) {
        this.grainDensity = Math.floor(5 + tension * 20);
        this.grainSize = 0.02 + (1 - intensity) * 0.08;
      }
    }

    class AtmosphericLayer extends AudioLayer {
      constructor(engine) {
        super(engine, 'atmospheric');
        this.sendAmount = 0.8; // Heavy reverb
      }
      
      trigger(noteNumber, time) {
        if (Math.random() > 0.05) return; // Very sparse
        
        const duration = 8 + Math.random() * 8;
        const freq = this.getNoteFrequency(
          Math.floor(Math.random() * 7), 
          3 + Math.floor(Math.random() * 3)
        );
        
        const osc = this.engine.ctx.createOscillator();
        const filter = this.engine.ctx.createBiquadFilter();
        const gain = this.engine.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 500;
        filter.Q.value = 0.5;
        
        // Long fade in/out
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.03, time + duration * 0.3);
        gain.gain.linearRampToValueAtTime(0.03, time + duration * 0.7);
        gain.gain.linearRampToValueAtTime(0, time + duration);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.compressor);
        
        osc.start(time);
        osc.stop(time + duration);
        
        this.voiceCount = 1;
      }
      
      getNoteFrequency(interval, octave) {
        const keyMap = { A: 0, B: 2, C: 3, D: 5, E: 7, F: 8, G: 10 };
        const rootNote = keyMap[this.engine.key] || 0;
        const modeIntervals = {
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          ionian: [0, 2, 4, 5, 7, 9, 11],
          lydian: [0, 2, 4, 6, 7, 9, 11]
        };
        
        const scale = modeIntervals[this.engine.mode] || modeIntervals.aeolian;
        const noteInScale = scale[interval % scale.length];
        const totalSemitones = rootNote + noteInScale + (octave - 4) * 12;
        
        return 440 * Math.pow(2, totalSemitones / 12);
      }
    }

    // Voice allocation system
    class VoiceAllocator {
      constructor() {
        this.voices = new Map();
        this.maxVoices = 64; // Total voice limit
      }
      
      allocate(layer, voice) {
        if (!this.voices.has(layer)) {
          this.voices.set(layer, new Set());
        }
        
        const layerVoices = this.voices.get(layer);
        
        // Global voice stealing
        if (this.getTotalVoices() >= this.maxVoices) {
          this.stealOldestVoice();
        }
        
        layerVoices.add(voice);
      }
      
      deallocate(layer, voice) {
        if (this.voices.has(layer)) {
          this.voices.get(layer).delete(voice);
        }
      }
      
      getTotalVoices() {
        let total = 0;
        this.voices.forEach(layerVoices => {
          total += layerVoices.size;
        });
        return total;
      }
      
      stealOldestVoice() {
        // Find oldest voice across all layers
        let oldestTime = Infinity;
        let oldestVoice = null;
        let oldestLayer = null;
        
        this.voices.forEach((layerVoices, layer) => {
          layerVoices.forEach(voice => {
            if (voice.startTime < oldestTime) {
              oldestTime = voice.startTime;
              oldestVoice = voice;
              oldestLayer = layer;
            }
          });
        });
        
        if (oldestVoice && oldestLayer) {
          oldestVoice.stop();
          this.deallocate(oldestLayer, oldestVoice);
        }
      }
    }

    // Initialize the engine
    new AudiophileVoidEngine();
  </script>
</body>
</html>
