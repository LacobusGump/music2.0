<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;color:#fff;font-family:system-ui;height:100vh;overflow:hidden;touch-action:none}
        #start{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;z-index:10}
        #start.off{display:none}
        .title{font-size:10px;letter-spacing:8px;opacity:0.4}
        .sub{font-size:20px;font-weight:200;letter-spacing:3px}
        button{width:100px;height:100px;border-radius:50%;background:transparent;border:1px solid #0fa;color:#0fa;font:inherit;font-size:9px;letter-spacing:2px;cursor:pointer;transition:0.3s}
        button:hover{background:#0fa;color:#000}
        .hint{font-size:9px;opacity:0.25;text-align:center;max-width:200px;line-height:1.5}
        #app{display:none;height:100vh}
        #app.on{display:block}
        canvas{position:fixed;inset:0;width:100%;height:100%}
        .hud{position:fixed;font-size:8px;letter-spacing:1px;opacity:0.3;z-index:5}
        .tl{top:16px;left:16px}
        .tr{top:16px;right:16px;text-align:right}
        .bl{bottom:16px;left:16px}
        .br{bottom:16px;right:16px;text-align:right}
        .v{font-size:11px;margin-top:3px;opacity:0.7}
    </style>
</head>
<body>
<div id="start">
    <div class="title">GUMP</div>
    <div class="sub">Grand Unified Music Project</div>
    <button id="go">ENTER</button>
    <div class="hint">Move through space. You are the instrument.</div>
</div>
<div id="app">
    <canvas id="c"></canvas>
    <div class="hud tl"><div>MODE</div><div class="v" id="mode">BUILDING</div></div>
    <div class="hud tr"><div>FLOW</div><div class="v" id="flw">0</div></div>
    <div class="hud bl"><div>LAYERS</div><div class="v" id="layers">0</div></div>
    <div class="hud br"><div>BEAT</div><div class="v" id="beat">1</div></div>
</div>
<script>
// GUMP - Grand Unified Music Project
// The sound of something that shouldn't exist

const PHI = 1.618033988749;

// Dark modes - b2 is the key to unease
const PHRYGIAN = [0, 1, 3, 5, 7, 8, 10]; // that b2 tension
const LOCRIAN = [0, 1, 3, 5, 6, 8, 10];  // diminished, unstable

// State
const F = {
    x: 0, y: 0, z: 0,
    vx: 0, vy: 0, vz: 0,
    speed: 0,
    phase: 0,
    density: 0,
    field: 0,
    lfo: 0 // slow movement
};

// Memory
const M = {
    mode: 'building',
    tape: [],
    loopLen: 8,
    beatTime: 0.4,
    playhead: 0,
    lastBeat: 0,
    layers: [],
    activeLayer: null,
    blend: 0.6,
    beatDropped: false,
    beatIntensity: 0,
    darkness: 0 // builds over time
};

// Audio nodes
let ctx, master, reverb, reverbDistort, delay, subDrone, textureNoise;
let walls = []; // the massive sound walls
let running = false;

// Mic
let micStream, micSource, micBuffer;
const MIC_BUFFER_SIZE = 48000 * 4;
let micWritePos = 0;

const ROOT = 55;
const BPM = 78; // slower, heavier

// ============ AUDIO ENGINE ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    M.beatTime = 60 / BPM / 2;

    // Master
    master = ctx.createGain();
    master.gain.value = 0.8;

    // Create waveshaper for saturation
    const saturator = createSaturator();

    // Dark reverb with distortion after it
    reverb = createDarkReverb();

    // Delay
    delay = ctx.createDelay(2);
    delay.delayTime.value = 60 / BPM * 0.75;
    const delayFb = ctx.createGain();
    delayFb.gain.value = 0.4;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2000;

    delay.connect(delayFilter);
    delayFilter.connect(delayFb);
    delayFb.connect(delay);
    delay.connect(saturator);

    // Compression - aggressive
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -24;
    comp.ratio.value = 8;
    comp.attack.value = 0.002;
    comp.release.value = 0.1;
    comp.knee.value = 0;

    // Final chain
    saturator.connect(master);
    master.connect(comp);
    comp.connect(ctx.destination);

    // Create the sound sources
    createSubDrone();
    createWalls();
    createTexture();
    initMic();
}

// Waveshaper for that gritty saturation
function createSaturator() {
    const shaper = ctx.createWaveShaper();
    const samples = 44100;
    const curve = new Float32Array(samples);

    for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        // Soft clipping with odd harmonics
        curve[i] = Math.tanh(x * 2) * 0.8 + Math.tanh(x * 4) * 0.2;
    }

    shaper.curve = curve;
    shaper.oversample = '2x';
    return shaper;
}

// Dark reverb - long, filtered, with distortion
function createDarkReverb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.4;

    // Longer, darker taps
    const times = [0.05, 0.13, 0.21, 0.34, 0.55, 0.89, 1.44];
    const gains = [0.6, 0.5, 0.45, 0.35, 0.3, 0.25, 0.2];

    times.forEach((t, i) => {
        const d = ctx.createDelay(2);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = gains[i];
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 2500 - i * 300; // gets darker
        f.Q.value = 0.5;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
    });

    // Distortion AFTER reverb - key for that eerie sound
    reverbDistort = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        const x = (i / 128) - 1;
        curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.7);
    }
    reverbDistort.curve = curve;

    output.connect(reverbDistort);
    reverbDistort.connect(master);

    return input;
}

// ============ SUB DRONE - THE FOUNDATION ============

function createSubDrone() {
    // Deep, rumbling sub that's always there
    const sub = ctx.createOscillator();
    const sub2 = ctx.createOscillator();
    const subGain = ctx.createGain();
    const subFilter = ctx.createBiquadFilter();

    sub.type = 'sine';
    sub.frequency.value = ROOT / 2; // 27.5 Hz - you feel it more than hear it

    sub2.type = 'sine';
    sub2.frequency.value = ROOT / 2 * 1.002; // beating

    subFilter.type = 'lowpass';
    subFilter.frequency.value = 80;

    subGain.gain.value = 0;

    sub.connect(subFilter);
    sub2.connect(subFilter);
    subFilter.connect(subGain);
    subGain.connect(master);

    sub.start();
    sub2.start();

    subDrone = { sub, sub2, gain: subGain, filter: subFilter };
}

// ============ THE WALLS - MASSIVE SUPERSAW CHORDS ============

function createWalls() {
    // 3 massive chord voices, each is a 7-oscillator supersaw
    const chordIntervals = [
        [0, 0],      // root
        [3, 1],      // minor 3rd + octave (cluster)
        [7, 13]      // 5th + b9 up high (the tension)
    ];

    chordIntervals.forEach((interval, idx) => {
        const wall = createSupersaw(ROOT * Math.pow(2, interval[0]/12 + interval[1]/12), idx);
        walls.push(wall);
    });
}

function createSupersaw(baseFreq, idx) {
    // 7 detuned oscillators - the classic supersaw
    const NUM_OSCS = 7;
    const oscs = [];
    const gains = [];
    const output = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    const panL = ctx.createGain();
    const panR = ctx.createGain();
    const merger = ctx.createChannelMerger(2);

    // Detune amounts (in cents) - asymmetric like the JP-8000
    const detunes = [-35, -20, -10, 0, 12, 24, 40];
    // Gains - center voice loudest
    const oscGains = [0.5, 0.7, 0.9, 1, 0.9, 0.7, 0.5];

    for (let i = 0; i < NUM_OSCS; i++) {
        const osc = ctx.createOscillator();
        const g = ctx.createGain();

        osc.type = 'sawtooth';
        osc.frequency.value = baseFreq;
        osc.detune.value = detunes[i];

        g.gain.value = oscGains[i] / NUM_OSCS;

        // Stereo spread - left voices detuned down, right detuned up
        if (i < 3) {
            osc.connect(g);
            g.connect(panL);
        } else if (i > 3) {
            osc.connect(g);
            g.connect(panR);
        } else {
            // Center goes to both
            osc.connect(g);
            g.connect(panL);
            g.connect(panR);
        }

        osc.start();
        oscs.push(osc);
        gains.push(g);
    }

    // Stereo output
    panL.connect(merger, 0, 0);
    panR.connect(merger, 0, 1);

    // Rich resonant filter
    filter.type = 'lowpass';
    filter.frequency.value = 800;
    filter.Q.value = 4;

    merger.connect(filter);
    filter.connect(output);
    output.gain.value = 0;
    output.connect(master);
    output.connect(reverb);
    output.connect(delay);

    return { oscs, gains, output, filter, baseFreq, panL, panR };
}

function updateWalls() {
    const now = ctx.currentTime;
    const S = getBlendedState();

    // LFO for slow movement
    F.lfo = Math.sin(now * 0.3) * 0.5 + 0.5;

    walls.forEach((w, i) => {
        // Amplitude - builds with movement and darkness
        let amp = (0.05 + S.speed * 0.15 + M.darkness * 0.1);

        // Position affects which voices are prominent
        if (i === 0) amp *= 0.8; // root always present
        if (i === 1) amp *= (1 + S.x) / 2; // minor 3rd on right side
        if (i === 2) amp *= (1 + S.y) / 2 * M.darkness; // tension voice builds

        w.output.gain.linearRampToValueAtTime(amp * 0.3, now + 0.2);

        // Filter - opens slowly, controlled by movement
        const filterBase = 400 + M.darkness * 1500;
        const filterMod = S.speed * 2000 + F.lfo * 500;
        w.filter.frequency.linearRampToValueAtTime(filterBase + filterMod, now + 0.15);
        w.filter.Q.linearRampToValueAtTime(2 + S.speed * 6, now + 0.15);

        // Subtle pitch drift
        const drift = Math.sin(now * (0.1 + i * 0.07)) * 5;
        w.oscs.forEach((osc, j) => {
            const baseDetune = [-35, -20, -10, 0, 12, 24, 40][j];
            osc.detune.linearRampToValueAtTime(baseDetune + drift, now + 0.1);
        });
    });

    // Sub drone - always rumbling, intensity varies
    const subAmp = 0.15 + S.speed * 0.2 + M.darkness * 0.15;
    subDrone.gain.gain.linearRampToValueAtTime(subAmp, now + 0.2);

    // Sub filter opens with intensity
    subDrone.filter.frequency.linearRampToValueAtTime(60 + S.speed * 40, now + 0.2);

    // Build darkness over time
    M.darkness = Math.min(1, M.darkness + 0.0005);
}

// ============ TEXTURE LAYER - FILTERED NOISE CHAOS ============

function createTexture() {
    // Continuous noise that morphs with movement
    const bufferSize = ctx.sampleRate * 2;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = noiseBuffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    noise.loop = true;

    const noiseGain = ctx.createGain();
    noiseGain.gain.value = 0;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 1000;
    noiseFilter.Q.value = 5;

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(reverb);

    noise.start();

    textureNoise = { source: noise, gain: noiseGain, filter: noiseFilter };
}

function updateTexture() {
    const now = ctx.currentTime;
    const S = getBlendedState();

    // Noise level - whispers of chaos
    const noiseAmp = S.speed * 0.08 + M.darkness * 0.05;
    textureNoise.gain.gain.linearRampToValueAtTime(noiseAmp, now + 0.1);

    // Filter sweeps with position
    const freq = 500 + S.x * 2000 + S.y * 1500 + F.lfo * 1000;
    textureNoise.filter.frequency.linearRampToValueAtTime(freq, now + 0.1);
    textureNoise.filter.Q.linearRampToValueAtTime(3 + M.darkness * 8, now + 0.1);
}

// ============ DARK MELODIC VOICES ============

function playDarkNote(semitones, duration) {
    const freq = ROOT * Math.pow(2, semitones / 12);
    const now = ctx.currentTime;

    // Supersaw voice for melody too
    const NUM = 5;
    const oscs = [];
    const output = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    const detunes = [-25, -10, 0, 10, 25];

    for (let i = 0; i < NUM; i++) {
        const osc = ctx.createOscillator();
        osc.type = i === 2 ? 'triangle' : 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = detunes[i];
        osc.connect(filter);
        osc.start(now);
        osc.stop(now + duration + 0.5);
        oscs.push(osc);
    }

    filter.type = 'lowpass';
    filter.frequency.value = 3000;
    filter.Q.value = 3;

    // Filter envelope
    filter.frequency.setValueAtTime(5000, now);
    filter.frequency.exponentialRampToValueAtTime(800, now + duration * 0.7);

    output.gain.setValueAtTime(0, now);
    output.gain.linearRampToValueAtTime(0.15, now + 0.01);
    output.gain.exponentialRampToValueAtTime(0.001, now + duration);

    filter.connect(output);
    output.connect(master);
    output.connect(delay);
    output.connect(reverb);
}

function playCluster() {
    // Cluster chord - notes fighting each other
    const now = ctx.currentTime;
    const scale = M.darkness > 0.5 ? LOCRIAN : PHRYGIAN;

    // Pick 3-4 close notes
    const root = Math.floor(F.y * 3 + 2) * 12; // octave from position
    const notes = [
        root + scale[0],
        root + scale[1], // b2 - the tension
        root + scale[2],
    ];

    // Sometimes add the tritone
    if (M.darkness > 0.3 && Math.random() > 0.5) {
        notes.push(root + 6); // tritone
    }

    notes.forEach((n, i) => {
        setTimeout(() => playDarkNote(n, M.beatTime * 4), i * 30);
    });
}

// ============ MICROPHONE CAPTURE ============

async function initMic() {
    try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micSource = ctx.createMediaStreamSource(micStream);

        // Create buffer for granular
        micBuffer = ctx.createBuffer(1, MIC_BUFFER_SIZE, ctx.sampleRate);

        // Use ScriptProcessor to capture (AudioWorklet would be better but more complex)
        const processor = ctx.createScriptProcessor(4096, 1, 1);
        processor.onaudioprocess = (e) => {
            const input = e.inputBuffer.getChannelData(0);
            const buffer = micBuffer.getChannelData(0);

            for (let i = 0; i < input.length; i++) {
                buffer[micWritePos] = input[i];
                micWritePos = (micWritePos + 1) % MIC_BUFFER_SIZE;
            }
        };

        micSource.connect(processor);
        processor.connect(ctx.createGain()); // dummy connection to keep alive
    } catch (e) {
        console.log('Mic not available');
    }
}

function playGrain() {
    if (!micBuffer) return;

    const now = ctx.currentTime;
    const bufferData = micBuffer.getChannelData(0);

    // Find a loud section to grab
    let bestPos = 0, bestAmp = 0;
    for (let i = 0; i < 10; i++) {
        const pos = Math.floor(Math.random() * (MIC_BUFFER_SIZE - 4096));
        let amp = 0;
        for (let j = 0; j < 512; j++) {
            amp += Math.abs(bufferData[pos + j]);
        }
        if (amp > bestAmp) {
            bestAmp = amp;
            bestPos = pos;
        }
    }

    if (bestAmp < 10) return; // too quiet

    // Create grain
    const grainLen = 0.05 + Math.random() * 0.15;
    const grainSamples = Math.floor(grainLen * ctx.sampleRate);
    const grain = ctx.createBuffer(1, grainSamples, ctx.sampleRate);
    const grainData = grain.getChannelData(0);

    // Copy with envelope
    for (let i = 0; i < grainSamples; i++) {
        const env = Math.sin(Math.PI * i / grainSamples); // smooth envelope
        const srcIdx = (bestPos + i) % MIC_BUFFER_SIZE;
        grainData[i] = bufferData[srcIdx] * env;
    }

    // Play grain
    const source = ctx.createBufferSource();
    source.buffer = grain;

    // Random pitch shift (musical intervals)
    const pitchShifts = [0.5, 0.75, 1, 1, 1.5, 2];
    source.playbackRate.value = pitchShifts[Math.floor(Math.random() * pitchShifts.length)];

    const gain = ctx.createGain();
    gain.gain.value = 0.4;

    const filter = ctx.createBiquadFilter();
    filter.type = Math.random() > 0.5 ? 'lowpass' : 'bandpass';
    filter.frequency.value = 500 + Math.random() * 3000;
    filter.Q.value = 1 + Math.random() * 3;

    const pan = ctx.createStereoPanner();
    pan.pan.value = (Math.random() - 0.5) * 0.8;

    source.connect(filter);
    filter.connect(gain);
    gain.connect(pan);
    pan.connect(master);
    pan.connect(reverb);

    source.start(now);
}

// ============ BEAT ENGINE ============

function playKick() {
    const now = ctx.currentTime;

    // Sub oscillator
    const sub = ctx.createOscillator();
    sub.type = 'sine';
    sub.frequency.setValueAtTime(150, now);
    sub.frequency.exponentialRampToValueAtTime(40, now + 0.15);

    // Click
    const click = ctx.createOscillator();
    click.type = 'triangle';
    click.frequency.setValueAtTime(1000, now);
    click.frequency.exponentialRampToValueAtTime(100, now + 0.03);

    const subGain = ctx.createGain();
    const clickGain = ctx.createGain();
    const output = ctx.createGain();

    subGain.gain.setValueAtTime(0.8 * M.beatIntensity, now);
    subGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

    clickGain.gain.setValueAtTime(0.5 * M.beatIntensity, now);
    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

    output.gain.value = 0.7;

    sub.connect(subGain);
    click.connect(clickGain);
    subGain.connect(output);
    clickGain.connect(output);
    output.connect(master);

    sub.start(now);
    click.start(now);
    sub.stop(now + 0.4);
    click.stop(now + 0.1);
}

function playSnare() {
    const now = ctx.currentTime;

    // Noise burst
    const noiseLen = 0.15;
    const noise = ctx.createBuffer(1, ctx.sampleRate * noiseLen, ctx.sampleRate);
    const noiseData = noise.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.05));
    }

    const noiseSource = ctx.createBufferSource();
    noiseSource.buffer = noise;

    // Tone body
    const tone = ctx.createOscillator();
    tone.type = 'triangle';
    tone.frequency.value = 200;

    const noiseGain = ctx.createGain();
    const toneGain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000;

    noiseGain.gain.setValueAtTime(0.6 * M.beatIntensity, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

    toneGain.gain.setValueAtTime(0.3 * M.beatIntensity, now);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

    noiseSource.connect(filter);
    filter.connect(noiseGain);
    tone.connect(toneGain);
    noiseGain.connect(master);
    toneGain.connect(master);
    noiseGain.connect(reverb);

    noiseSource.start(now);
    tone.start(now);
    tone.stop(now + 0.15);
}

function playHat(open = false) {
    const now = ctx.currentTime;

    const len = open ? 0.2 : 0.05;
    const noise = ctx.createBuffer(1, ctx.sampleRate * len, ctx.sampleRate);
    const data = noise.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1);
    }

    const source = ctx.createBufferSource();
    source.buffer = noise;

    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 7000;

    gain.gain.setValueAtTime(0.25 * M.beatIntensity, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + len);

    source.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    source.start(now);
}

function updateBeat() {
    // Beat drops after 2 layers
    if (!M.beatDropped && M.layers.length >= 2) {
        M.beatDropped = true;
        M.beatIntensity = 0.3;
    }

    if (!M.beatDropped) return;

    // Intensity builds with layers
    const targetIntensity = 0.3 + M.layers.length * 0.2;
    M.beatIntensity += (targetIntensity - M.beatIntensity) * 0.01;
    M.beatIntensity = Math.min(1, M.beatIntensity);

    // Play beat elements based on playhead
    const beat = M.playhead;

    if (beat === 0 || beat === 4) playKick();
    if (beat === 2 || beat === 6) playSnare();
    if (M.beatIntensity > 0.5) {
        playHat(beat === 4);
    }
    if (M.beatIntensity > 0.7 && (beat === 3 || beat === 7)) {
        playKick(); // extra kicks at high intensity
    }
}

// ============ MEMORY SYSTEM ============

function snapshot() {
    return { x: F.x, y: F.y, speed: F.speed, density: F.density };
}

function updateMemory() {
    const now = ctx.currentTime;

    if (now - M.lastBeat >= M.beatTime) {
        M.lastBeat = now;

        if (M.mode === 'building') {
            M.tape.push(snapshot());
            if (M.tape.length >= M.loopLen) {
                M.mode = 'looping';
                M.playhead = 0;
            }
        } else {
            M.playhead = (M.playhead + 1) % M.loopLen;

            // Beat
            updateBeat();

            // Dark melodic events - clusters and tension
            if (M.playhead === 0 || M.playhead === 4) {
                // Cluster chords on downbeats
                if (F.speed > 0.15 || M.darkness > 0.3) {
                    playCluster();
                }
            }

            // Single dark notes on other beats
            if (M.playhead % 2 === 1 && F.speed > 0.2) {
                const scale = PHRYGIAN;
                const degree = scale[Math.floor((F.y + 1) * 3) % 7];
                const octave = Math.floor(F.x * 2 + 2) * 12;
                playDarkNote(degree + octave, M.beatTime * 3);
            }

            // Grains woven in
            if (M.playhead % 2 === 1 && F.speed > 0.1) {
                playGrain();
            }

            // Layer recording
            if (M.activeLayer) {
                M.activeLayer.push(snapshot());
                if (M.activeLayer.length >= M.loopLen) {
                    M.layers.push(M.activeLayer);
                    M.activeLayer = null;
                    if (M.layers.length > 3) M.layers.shift();
                }
            }
        }
    }
}

function getBlendedState() {
    if (M.mode === 'building' || M.tape.length === 0) {
        return { x: F.x, y: F.y, speed: F.speed };
    }

    const rec = M.tape[M.playhead];
    const live = 1 - M.blend;
    const loop = M.blend;

    let x = rec.x * loop + F.x * live;
    let y = rec.y * loop + F.y * live;
    let speed = rec.speed * loop + F.speed * live;

    M.layers.forEach((layer, li) => {
        const ls = layer[M.playhead];
        const w = 0.3 / (li + 1);
        x += ls.x * w;
        y += ls.y * w;
        speed += ls.speed * w;
    });

    return {
        x: Math.max(-1, Math.min(1, x)),
        y: Math.max(-1, Math.min(1, y)),
        speed: Math.min(1, speed)
    };
}

// ============ INPUT HANDLERS ============

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    F.vx = F.vx * 0.8 + (a.x || 0) * 0.02;
    F.vy = F.vy * 0.8 + (a.y || 0) * 0.02;
    F.vz = F.vz * 0.8 + (a.z || 0) * 0.02;

    F.speed = Math.min(1, Math.sqrt(F.vx*F.vx + F.vy*F.vy + F.vz*F.vz) / 3);
    F.density = F.density * 0.99 + F.speed * 0.01;
}

function onOrientation(e) {
    F.x = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    F.y = Math.max(-1, Math.min(1, (e.beta || 0) / 45 - 1));
    F.field = (e.alpha || 0) / 360;
}

function onPointer(x, y) {
    const px = (x / window.innerWidth) * 2 - 1;
    const py = 1 - (y / window.innerHeight) * 2;

    F.vx = F.vx * 0.7 + (px - F.x) * 0.3;
    F.vy = F.vy * 0.7 + (py - F.y) * 0.3;

    F.x = px;
    F.y = py;

    F.speed = Math.min(1, Math.sqrt(F.vx*F.vx + F.vy*F.vy) * 3);
    F.density = F.density * 0.98 + F.speed * 0.02;
}

// ============ VISUALIZATION ============

let vc;
function initViz() {
    const canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const canvas = document.getElementById('c');
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const S = getBlendedState();

    // Fade
    vc.fillStyle = `rgba(0,0,0,${0.08 + (1-F.density) * 0.07})`;
    vc.fillRect(0, 0, w, h);

    const cx = w/2 + S.x * w * 0.25;
    const cy = h/2 - S.y * h * 0.25;

    // Outer loop ring
    const loopR = Math.min(w, h) * 0.4;
    if (M.tape.length > 0) {
        const progress = M.mode === 'building'
            ? M.tape.length / M.loopLen
            : (M.playhead + 1) / M.loopLen;

        vc.beginPath();
        vc.arc(w/2, h/2, loopR, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
        vc.strokeStyle = M.mode === 'building' ? 'rgba(255,100,100,0.4)' : 'rgba(0,255,170,0.25)';
        vc.lineWidth = M.beatDropped ? 4 + M.beatIntensity * 4 : 3;
        vc.stroke();
    }

    // Layer rings
    M.layers.forEach((_, i) => {
        vc.beginPath();
        vc.arc(w/2, h/2, loopR - 12 - i * 10, 0, Math.PI * 2);
        vc.strokeStyle = `rgba(0,255,170,${0.15 + i * 0.08})`;
        vc.lineWidth = 2;
        vc.stroke();
    });

    // Recording ring
    if (M.activeLayer) {
        const recP = M.activeLayer.length / M.loopLen;
        vc.beginPath();
        vc.arc(w/2, h/2, loopR - 12 - M.layers.length * 10, -Math.PI/2, -Math.PI/2 + recP * Math.PI * 2);
        vc.strokeStyle = 'rgba(255,100,100,0.6)';
        vc.lineWidth = 3;
        vc.stroke();
    }

    // Beat pulse
    if (M.beatDropped) {
        const beatPulse = Math.sin(M.playhead * Math.PI / 4) * 0.5 + 0.5;
        vc.beginPath();
        vc.arc(w/2, h/2, loopR + 20 + beatPulse * 15 * M.beatIntensity, 0, Math.PI * 2);
        vc.strokeStyle = `rgba(255,200,100,${0.1 + beatPulse * 0.2 * M.beatIntensity})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Wall visualization - massive rings that pulse
    walls.forEach((w, i) => {
        const amp = w.output.gain.value;
        if (amp > 0.005) {
            const r = 50 + i * 40 + amp * 100;
            vc.beginPath();
            vc.arc(cx, cy, r, 0, Math.PI * 2);
            // Colors shift darker with darkness level
            const hue = 200 - M.darkness * 60 + i * 20;
            vc.strokeStyle = `hsla(${hue}, 50%, ${30 + amp * 30}%, ${amp * 1.5})`;
            vc.lineWidth = 3 + amp * 10;
            vc.stroke();
        }
    });

    // Darkness fog creeping in
    if (M.darkness > 0.1) {
        const fogGr = vc.createRadialGradient(w/2, h/2, loopR * 0.5, w/2, h/2, loopR * 1.5);
        fogGr.addColorStop(0, 'transparent');
        fogGr.addColorStop(1, `rgba(20,0,30,${M.darkness * 0.4})`);
        vc.fillStyle = fogGr;
        vc.fillRect(0, 0, w, h);
    }

    // Core - shifts color with darkness
    const coreR = 30 + S.speed * 40;
    const coreHue = 170 - M.darkness * 50;
    const gr = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    gr.addColorStop(0, `hsla(${coreHue}, 80%, 50%, ${0.5 + S.speed * 0.4})`);
    gr.addColorStop(0.5, `hsla(${coreHue - 30}, 60%, 40%, ${0.3 + S.speed * 0.2})`);
    gr.addColorStop(1, 'transparent');
    vc.fillStyle = gr;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, Math.PI * 2);
    vc.fill();

    // Mic activity indicator
    if (micBuffer) {
        const micLevel = micBuffer.getChannelData(0).slice(micWritePos - 512, micWritePos)
            .reduce((a, b) => a + Math.abs(b), 0) / 512;
        if (micLevel > 0.01) {
            vc.beginPath();
            vc.arc(cx, cy, coreR + 10 + micLevel * 50, 0, Math.PI * 2);
            vc.strokeStyle = `rgba(255,150,100,${micLevel * 2})`;
            vc.lineWidth = 2;
            vc.stroke();
        }
    }
}

function updateUI() {
    let modeText = M.mode === 'building'
        ? `BUILDING ${M.tape.length}/${M.loopLen}`
        : (M.activeLayer ? 'RECORDING' : (M.beatDropped ? 'LIVE' : 'LOOPING'));
    document.getElementById('mode').textContent = modeText;
    document.getElementById('flw').textContent = F.speed.toFixed(2);
    document.getElementById('layers').textContent = M.layers.length + (M.activeLayer ? '+1' : '');
    document.getElementById('beat').textContent = M.beatDropped ? `${M.playhead + 1} \u266A` : M.playhead + 1;
}

// ============ MAIN LOOP ============

function tick() {
    if (!running) return;

    F.phase += 0.01 * (1 + F.speed);

    updateMemory();

    // Auto-start layer recording on significant movement
    if (M.mode === 'looping' && !M.activeLayer && F.speed > 0.35) {
        M.activeLayer = [];
    }

    updateWalls();
    updateTexture();
    draw();
    updateUI();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('start').classList.add('off');
    document.getElementById('app').classList.add('on');

    // Request permissions
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);
    document.addEventListener('mousemove', e => onPointer(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        onPointer(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    init();
    initViz();
    running = true;
    tick();
}

document.getElementById('go').addEventListener('click', start);
</script>
</body>
</html>
