<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .orb {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.5px);
        }

        .orb.pulse {
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
            50% { transform: translate(-50%, -50%) scale(3); box-shadow: 0 0 30px rgba(255,255,255,0.6); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: rec 1s ease-in-out infinite;
        }

        .orb.processing {
            background: radial-gradient(circle, rgba(100,100,255,0.8) 0%, rgba(0,0,255,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(0,0,255,0.5);
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            opacity: 0.5;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>
    <div class="info">SPACE TO SAMPLE â€¢ CLICK TO START</div>

    <script>
        'use strict';

        // Optimized Beat Matcher
        class BeatMatcher {
            constructor() {
                this.bpm = 75;
                this.cache = new Map();
            }

            findTransients(buffer) {
                const key = buffer.length;
                if (this.cache.has(key)) return this.cache.get(key);

                const data = buffer.getChannelData(0);
                const transients = [];
                const windowSize = 512;
                let prevEnergy = 0;
                
                for (let i = 0; i < data.length - windowSize; i += windowSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += Math.abs(data[i + j]);
                    }
                    energy /= windowSize;
                    
                    if (energy > prevEnergy * 1.5 && energy > 0.05) {
                        transients.push({ 
                            time: i / buffer.sampleRate, 
                            energy,
                            index: i 
                        });
                    }
                    prevEnergy = energy;
                }
                
                this.cache.set(key, transients);
                return transients;
            }

            quantize(duration) {
                const beatLength = 60 / this.bpm;
                const bars = [0.25, 0.5, 1, 2, 4];
                
                for (const bar of bars) {
                    const target = beatLength * bar;
                    if (Math.abs(duration - target) < beatLength * 0.25) {
                        return target / duration;
                    }
                }
                
                return (beatLength * 2) / duration;
            }
        }

        // Optimized LoFi Processor
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
                this.setupNodes();
            }

            setupNodes() {
                // Pre-create reusable nodes
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 3000;
                this.filter.Q.value = 1;

                this.bitcrusher = this.ctx.createWaveShaper();
                const bits = 6;
                const n = 256;
                const curve = new Float32Array(n);
                const step = 2 / n;
                
                for (let i = 0; i < n; i++) {
                    const x = -1 + step * i;
                    curve[i] = Math.round(x * bits) / bits;
                }
                
                this.bitcrusher.curve = curve;
                this.bitcrusher.oversample = 'none';
            }

            process(source, amount = 1) {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                const dry = this.ctx.createGain();
                const wet = this.ctx.createGain();
                
                dry.gain.value = 1 - amount;
                wet.gain.value = amount;
                
                source.connect(input);
                input.connect(dry);
                input.connect(this.bitcrusher);
                this.bitcrusher.connect(this.filter);
                this.filter.connect(wet);
                
                dry.connect(output);
                wet.connect(output);
                
                return output;
            }
        }

        // Musical Evolution Engine
        class Evolution {
            constructor() {
                this.complexity = 0;
                this.energy = 0.5;
                this.patterns = {
                    kick: [
                        [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,1, 0,0,1,0, 1,0,0,0, 0,0,1,0],
                        [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0]
                    ],
                    snare: [
                        [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
                        [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,0],
                        [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,1],
                        [0,0,1,0, 1,0,0,1, 0,0,0,0, 1,0,1,0]
                    ],
                    hat: [
                        [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                        [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
                        [1,1,1,0, 1,0,1,1, 1,0,1,0, 1,1,1,0],
                        [1,1,1,1, 1,0,1,1, 1,1,1,0, 1,1,1,1]
                    ]
                };
                this.bassNotes = [40, 43, 45, 47, 50, 52]; // E, G, A, B, D, E
                this.currentBassline = 0;
            }

            evolve() {
                this.complexity = Math.min(3, this.complexity + 0.1);
                this.energy = 0.5 + Math.sin(Date.now() * 0.0001) * 0.3;
            }

            getPattern(type) {
                const idx = Math.floor(this.complexity);
                return this.patterns[type][idx] || this.patterns[type][0];
            }

            getBassline(step) {
                const progressions = [
                    [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3],
                    [0, 0, 2, 2, 1, 1, 3, 3, 0, 0, 2, 2, 4, 4, 3, 3],
                    [0, 0, 4, 4, 2, 2, 1, 1, 0, 0, 3, 3, 2, 2, 1, 1],
                    [0, 2, 0, 3, 1, 3, 1, 4, 0, 2, 0, 5, 1, 3, 1, 2]
                ];
                
                const idx = Math.floor(this.complexity);
                const progression = progressions[idx] || progressions[0];
                return this.bassNotes[progression[step % 16]];
            }
        }

        // Main Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.evolution = new Evolution();
                this.recording = false;
                this.preBuffer = [];
                this.buffer = [];
                this.seq = { step: 0, swing: 0.15 };
                this.orb = document.getElementById('orb');
                this.activeSamples = new Map();
                
                document.addEventListener('click', () => this.start());
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 44100, latencyHint: 'interactive' });
                    this.lofi = new LoFi(this.ctx);
                    
                    // Setup master chain
                    this.setupMasterChain();
                    
                    // Create instrument layers
                    this.setupLayers();
                    
                    // Create instruments
                    await this.createInstruments();
                    
                    // Setup microphone with pre-buffering
                    await this.setupMicrophone();
                    
                    // Start engines
                    this.startSequencer();
                    this.startAutoSampler();
                    
                    // Key handlers
                    document.onkeydown = e => {
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.toggle();
                        }
                    };
                    
                    document.querySelector('.info').style.display = 'none';
                    
                } catch (e) {
                    console.error('Init error:', e);
                }
            }

            setupMasterChain() {
                // Master bus
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.8;
                
                // Sidechain compressor
                this.nodes.sidechain = this.ctx.createDynamicsCompressor();
                this.nodes.sidechain.threshold.value = -10;
                this.nodes.sidechain.knee.value = 0;
                this.nodes.sidechain.ratio.value = 20;
                this.nodes.sidechain.attack.value = 0.001;
                this.nodes.sidechain.release.value = 0.1;
                
                // Master limiter
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -3;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.01;
                
                // Warmth
                this.nodes.warmth = this.ctx.createBiquadFilter();
                this.nodes.warmth.type = 'lowshelf';
                this.nodes.warmth.frequency.value = 200;
                this.nodes.warmth.gain.value = 3;
                
                // Connect chain
                this.nodes.master.connect(this.nodes.sidechain);
                this.nodes.sidechain.connect(this.nodes.warmth);
                this.nodes.warmth.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);
            }

            setupLayers() {
                const layers = {
                    kick: { vol: 0.9, pan: 0 },
                    snare: { vol: 0.7, pan: 0.1 },
                    hat: { vol: 0.3, pan: -0.2 },
                    bass: { vol: 0.8, pan: 0 },
                    sample: { vol: 0.6, pan: 0 },
                    vinyl: { vol: 0.1, pan: 0 }
                };
                
                Object.entries(layers).forEach(([name, config]) => {
                    const gain = this.ctx.createGain();
                    const pan = this.ctx.createStereoPanner();
                    
                    gain.gain.value = config.vol;
                    pan.pan.value = config.pan;
                    
                    gain.connect(pan);
                    pan.connect(this.nodes.master);
                    
                    this.nodes[name] = { gain, pan, input: gain };
                    this.samples.set(name, []);
                });
            }

            async createInstruments() {
                const sr = this.ctx.sampleRate;
                
                // Punchy kick
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.pow(1 - t * 2, 3);
                    const pitch = 55 * Math.exp(-35 * t);
                    const click = Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-100 * t) * 0.3;
                    kd[i] = (Math.sin(2 * Math.PI * pitch * t) + click) * env;
                }
                
                // Snappy snare
                const snare = this.ctx.createBuffer(1, sr * 0.2, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-20 * t);
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.5;
                    const noise = (Math.random() * 2 - 1) * 0.5;
                    sd[i] = (tone + noise) * env;
                }
                
                // Crisp hat
                const hat = this.ctx.createBuffer(1, sr * 0.03, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-200 * t);
                    hd[i] = (Math.random() * 2 - 1) * env * 0.8;
                }
                
                // Vinyl crackle loop
                const vinyl = this.ctx.createBuffer(2, sr * 10, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const vd = vinyl.getChannelData(ch);
                    for (let i = 0; i < vd.length; i++) {
                        vd[i] = (Math.random() - 0.5) * 0.02;
                        if (Math.random() < 0.0001) {
                            vd[i] = (Math.random() - 0.5) * 0.2;
                        }
                    }
                }
                
                // Store samples
                this.samples.get('kick').push({ buffer: kick, rate: 1 });
                this.samples.get('snare').push({ buffer: snare, rate: 1 });
                this.samples.get('hat').push({ buffer: hat, rate: 1 });
                
                // Start vinyl noise
                const vinylSource = this.ctx.createBufferSource();
                vinylSource.buffer = vinyl;
                vinylSource.loop = true;
                vinylSource.connect(this.nodes.vinyl.input);
                vinylSource.start();
            }

            async setupMicrophone() {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });
                
                this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                
                // Pre-buffer for instant capture
                this.nodes.preRec = this.ctx.createScriptProcessor(2048, 1, 1);
                this.preBuffer = new Float32Array(this.ctx.sampleRate * 2); // 2 sec rolling buffer
                this.preBufferIndex = 0;
                
                this.nodes.preRec.onaudioprocess = e => {
                    const input = e.inputBuffer.getChannelData(0);
                    
                    // Rolling buffer
                    for (let i = 0; i < input.length; i++) {
                        this.preBuffer[this.preBufferIndex] = input[i];
                        this.preBufferIndex = (this.preBufferIndex + 1) % this.preBuffer.length;
                    }
                    
                    // Active recording
                    if (this.recording) {
                        this.buffer.push(...input);
                        if (this.buffer.length > this.ctx.sampleRate * 4) {
                            this.stopRec();
                        }
                    }
                };
                
                this.nodes.mic.connect(this.nodes.preRec);
                this.nodes.preRec.connect(this.ctx.destination);
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    // Include pre-buffer for instant capture
                    this.buffer = [];
                    
                    // Add last 0.5 seconds from pre-buffer
                    const preCapture = this.ctx.sampleRate * 0.5;
                    const startIdx = (this.preBufferIndex - preCapture + this.preBuffer.length) % this.preBuffer.length;
                    
                    for (let i = 0; i < preCapture; i++) {
                        const idx = (startIdx + i) % this.preBuffer.length;
                        this.buffer.push(this.preBuffer[idx]);
                    }
                    
                    this.recording = true;
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                this.recording = false;
                this.orb.classList.remove('recording');
                this.orb.classList.add('processing');
                
                // Process immediately
                setTimeout(() => this.processSample(), 10);
            }

            processSample() {
                if (this.buffer.length < this.ctx.sampleRate * 0.2) {
                    this.orb.classList.remove('processing');
                    return;
                }
                
                // Create buffer
                const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                buf.getChannelData(0).set(this.buffer);
                
                // Find transients
                const transients = this.beatMatcher.findTransients(buf);
                
                // Trim silence from start
                const data = buf.getChannelData(0);
                let startIdx = 0;
                for (let i = 0; i < data.length; i++) {
                    if (Math.abs(data[i]) > 0.01) {
                        startIdx = i;
                        break;
                    }
                }
                
                // Create trimmed buffer
                const trimmed = this.ctx.createBuffer(1, data.length - startIdx, this.ctx.sampleRate);
                trimmed.getChannelData(0).set(data.slice(startIdx));
                
                // First play - raw sample
                this.playNewSample(trimmed, 1, 0);
                
                // Schedule pitched version
                setTimeout(() => {
                    const pitch = [0.5, 0.667, 1, 1.5, 2][Math.floor(Math.random() * 5)];
                    this.playNewSample(trimmed, pitch, 1);
                }, 2000);
                
                // Schedule quantized version
                setTimeout(() => {
                    const stretch = this.beatMatcher.quantize(trimmed.duration);
                    const pitch = [0.5, 1, 2][Math.floor(Math.random() * 3)];
                    this.addToLoop(trimmed, stretch * pitch, 2);
                }, 4000);
                
                this.orb.classList.remove('processing');
            }

            playNewSample(buffer, rate, evolution) {
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = buffer;
                src.playbackRate.value = rate;
                
                // Filter based on evolution
                filter.type = 'lowpass';
                filter.frequency.value = 20000 - (evolution * 5000);
                filter.Q.value = 1 + evolution;
                
                gain.gain.value = 0.6;
                
                // Process
                const processed = this.lofi.process(src, evolution * 0.3);
                processed.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample.input);
                
                src.start();
            }

            addToLoop(buffer, rate, evolution) {
                const samples = this.samples.get('sample');
                
                // Keep max 4 samples
                if (samples.length >= 4) {
                    const oldest = samples.shift();
                    if (this.activeSamples.has(oldest)) {
                        this.activeSamples.get(oldest).stop();
                        this.activeSamples.delete(oldest);
                    }
                }
                
                const sample = { buffer, rate, evolution };
                samples.push(sample);
                
                // Start looping immediately
                this.loopSample(sample);
            }

            loopSample(sample) {
                if (this.activeSamples.has(sample)) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                
                // Sync to beat
                const beatLength = 60 / this.beatMatcher.bpm;
                src.loopEnd = Math.min(sample.buffer.duration, beatLength * 4);
                
                // Dynamic filter
                filter.type = 'lowpass';
                filter.frequency.value = 5000;
                filter.Q.value = 2;
                
                gain.gain.value = 0.5;
                
                // Process
                const processed = this.lofi.process(src, sample.evolution * 0.5);
                processed.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample.input);
                
                // Start on next bar
                const nextBar = Math.ceil(this.ctx.currentTime / (beatLength * 4)) * (beatLength * 4);
                src.start(nextBar);
                
                this.activeSamples.set(sample, src);
                
                // Filter automation
                const lfo = () => {
                    if (!this.activeSamples.has(sample)) return;
                    
                    const now = this.ctx.currentTime;
                    const mod = 3000 + Math.sin(now * 0.2) * 2000;
                    filter.frequency.linearRampToValueAtTime(mod, now + 0.1);
                    
                    requestAnimationFrame(lfo);
                };
                lfo();
            }

            startSequencer() {
                const beatLength = 60 / this.beatMatcher.bpm / 4;
                let nextTime = this.ctx.currentTime;
                
                const schedule = () => {
                    const currentTime = this.ctx.currentTime;
                    
                    // Schedule ahead
                    while (nextTime < currentTime + 0.1) {
                        const step = this.seq.step;
                        
                        // Get patterns based on evolution
                        const kickPattern = this.evolution.getPattern('kick');
                        const snarePattern = this.evolution.getPattern('snare');
                        const hatPattern = this.evolution.getPattern('hat');
                        
                        // Schedule hits
                        if (kickPattern[step]) {
                            this.scheduleHit('kick', nextTime, 0.9);
                            // Sidechain duck
                            this.nodes.sidechain.threshold.setValueAtTime(-30, nextTime);
                            this.nodes.sidechain.threshold.linearRampToValueAtTime(-10, nextTime + 0.1);
                        }
                        
                        if (snarePattern[step]) {
                            this.scheduleHit('snare', nextTime + beatLength * this.seq.swing, 0.7);
                        }
                        
                        if (hatPattern[step]) {
                            const velocity = 0.3 + Math.random() * 0.3 * this.evolution.energy;
                            this.scheduleHit('hat', nextTime, velocity);
                        }
                        
                        // Bass line
                        if (step % 2 === 0) {
                            const note = this.evolution.getBassline(step);
                            this.scheduleBass(note, nextTime, beatLength * 2);
                        }
                        
                        // Visual pulse
                        if (step % 4 === 0) {
                            setTimeout(() => {
                                this.orb.classList.add('pulse');
                                setTimeout(() => this.orb.classList.remove('pulse'), 300);
                            }, (nextTime - currentTime) * 1000);
                        }
                        
                        // Evolve
                        if (step === 0) {
                            this.evolution.evolve();
                        }
                        
                        this.seq.step = (step + 1) % 16;
                        nextTime += beatLength;
                    }
                    
                    setTimeout(schedule, 25);
                };
                
                schedule();
            }

            scheduleHit(type, time, velocity) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                const sample = samples[Math.floor(Math.random() * samples.length)];
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                src.buffer = sample.buffer;
                gain.gain.value = velocity;
                
                src.connect(gain);
                gain.connect(this.nodes[type].input);
                
                src.start(time);
            }

            scheduleBass(note, time, duration) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = note;
                
                // Sub layer
                const sub = this.ctx.createOscillator();
                sub.type = 'sine';
                sub.frequency.value = note / 2;
                
                // Filter for warmth
                filter.type = 'lowpass';
                filter.frequency.value = note * 4;
                filter.Q.value = 3;
                
                // Envelope
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.6, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.3, time + duration * 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
                
                // Connect
                osc.connect(filter);
                sub.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.bass.input);
                
                osc.start(time);
                sub.start(time);
                osc.stop(time + duration);
                sub.stop(time + duration);
            }

            startAutoSampler() {
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                let threshold = 0.1;
                
                const detect = () => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        requestAnimationFrame(detect);
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    // Adaptive threshold
                    let sum = 0;
                    let peaks = 0;
                    
                    // Focus on musical frequencies (80Hz - 4kHz)
                    for (let i = 4; i < 200; i++) {
                        sum += data[i];
                        if (data[i] > 150) peaks++;
                    }
                    
                    const avg = sum / 196;
                    threshold = threshold * 0.95 + avg * 0.05; // Adaptive threshold
                    
                    // Detect interesting sounds
                    if (peaks > 10 && avg > threshold * 2) {
                        console.log('Auto-sampling detected sound');
                        this.toggle();
                        cooldown = 100; // 2 second cooldown at 50fps
                    }
                    
                    requestAnimationFrame(detect);
                };
                
                detect();
            }
        }

        // Initialize
        const engine = new Engine();
    </script>
</body>
</html>
