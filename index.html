<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP 2.0</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a0a;overflow:hidden;touch-action:none;height:100vh;font-family:system-ui,-apple-system,sans-serif}
        canvas{position:fixed;inset:0}

        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100;cursor:pointer;background:#0a0a0a}
        #enter.off{display:none}
        #enter div{width:140px;height:140px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px}
        #enter .title{font-size:11px;letter-spacing:6px;color:rgba(255,255,255,0.4)}
        #enter .sub{font-size:8px;letter-spacing:2px;color:rgba(255,255,255,0.2)}

        #loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:99;background:#0a0a0a;color:rgba(255,255,255,0.3);font-size:10px;letter-spacing:2px}
        #loading.off{display:none}

        #dials{position:fixed;bottom:0;left:0;right:0;z-index:50;padding:10px 0 20px;background:linear-gradient(transparent,rgba(0,0,0,0.95));touch-action:pan-x}
        .wheel{margin-bottom:15px;position:relative}
        .wheel-label{font-size:8px;letter-spacing:3px;color:rgba(255,255,255,0.25);text-transform:uppercase;text-align:center;margin-bottom:8px}
        .wheel-container{position:relative;height:44px;overflow:hidden}
        .wheel-track{display:flex;position:absolute;left:50%;transform:translateX(-50%);transition:transform 0.3s cubic-bezier(0.2,0.9,0.3,1)}
        .wheel-notch{width:70px;height:44px;display:flex;align-items:center;justify-content:center;font-size:11px;color:rgba(255,255,255,0.25);cursor:pointer;position:relative;flex-shrink:0;transition:all 0.3s;-webkit-tap-highlight-color:transparent}
        .wheel-notch::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:1px;height:20px;background:rgba(255,255,255,0.1)}
        .wheel-notch:first-child::before{display:none}
        .wheel-notch.active{color:#fff;font-size:13px;text-shadow:0 0 20px rgba(255,255,255,0.5)}
        .wheel-indicator{position:absolute;left:50%;top:0;bottom:0;width:80px;transform:translateX(-50%);border-left:1px solid rgba(255,255,255,0.2);border-right:1px solid rgba(255,255,255,0.2);pointer-events:none;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.03),transparent)}
        .wheel-teeth{position:absolute;left:0;right:0;height:3px;display:flex;justify-content:center;gap:8px;pointer-events:none}
        .wheel-teeth.top{top:0}
        .wheel-teeth.bottom{bottom:0}
        .wheel-tooth{width:2px;height:3px;background:rgba(255,255,255,0.15)}
    </style>
</head>
<body>
<div id="enter">
    <div>
        <span class="title">GUMP</span>
        <span class="sub">tap to begin</span>
    </div>
</div>
<div id="loading" class="off">loading samples...</div>

<div id="dials" style="display:none">
    <div class="wheel" id="beats-wheel" data-dial="beats">
        <div class="wheel-label">beats</div>
        <div class="wheel-container">
            <div class="wheel-indicator"></div>
            <div class="wheel-teeth top"></div>
            <div class="wheel-teeth bottom"></div>
            <div class="wheel-track">
                <div class="wheel-notch" data-value="none">off</div>
                <div class="wheel-notch active" data-value="lofi">lo-fi</div>
                <div class="wheel-notch" data-value="trap">trap</div>
                <div class="wheel-notch" data-value="boom">boom bap</div>
                <div class="wheel-notch" data-value="house">house</div>
            </div>
        </div>
    </div>
    <div class="wheel" id="bass-wheel" data-dial="bass">
        <div class="wheel-label">bass</div>
        <div class="wheel-container">
            <div class="wheel-indicator"></div>
            <div class="wheel-teeth top"></div>
            <div class="wheel-teeth bottom"></div>
            <div class="wheel-track">
                <div class="wheel-notch" data-value="none">off</div>
                <div class="wheel-notch active" data-value="sub">808</div>
                <div class="wheel-notch" data-value="reese">reese</div>
                <div class="wheel-notch" data-value="analog">analog</div>
            </div>
        </div>
    </div>
    <div class="wheel" id="vibe-wheel" data-dial="vibe">
        <div class="wheel-label">vibe</div>
        <div class="wheel-container">
            <div class="wheel-indicator"></div>
            <div class="wheel-teeth top"></div>
            <div class="wheel-teeth bottom"></div>
            <div class="wheel-track">
                <div class="wheel-notch" data-value="raw">raw</div>
                <div class="wheel-notch active" data-value="lofi">lo-fi</div>
                <div class="wheel-notch" data-value="polished">polished</div>
                <div class="wheel-notch" data-value="saturated">saturated</div>
            </div>
        </div>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// GUMP 2.0 - Real Samples + Professional FX
// "More real than real instruments"

const TAU = Math.PI * 2;
let ctx, master, canvas, vc;
let running = false;

// State
let dials = { beats: 'lofi', bass: 'sub', vibe: 'lofi' };
let field = { x: 0.5, y: 0.5, energy: 0, time: 0 };

// ============ SAMPLE LIBRARY ============
// Using high-quality samples from freesound.org (CC0) and similar

const SAMPLE_URLS = {
    // Lo-fi kit - dusty, vinyl, warm
    lofi_kick: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
    lofi_snare: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    lofi_hat: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',

    // Trap kit - hard 808s, crisp
    trap_kick: 'https://cdn.freesound.org/previews/568/568573_12517458-lq.mp3',
    trap_snare: 'https://cdn.freesound.org/previews/387/387530_7255534-lq.mp3',
    trap_hat: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',

    // Boom bap - classic hip hop
    boom_kick: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
    boom_snare: 'https://cdn.freesound.org/previews/398/398712_183766-lq.mp3',
    boom_hat: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',

    // House - four on floor
    house_kick: 'https://cdn.freesound.org/previews/568/568573_12517458-lq.mp3',
    house_snare: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    house_hat: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',

    // 808 bass notes
    bass_c1: 'https://cdn.freesound.org/previews/145/145438_2607098-lq.mp3',
};

let samples = {};
let samplesLoaded = false;

async function loadSamples() {
    const keys = Object.keys(SAMPLE_URLS);
    let loaded = 0;

    for (const key of keys) {
        try {
            const response = await fetch(SAMPLE_URLS[key]);
            const arrayBuffer = await response.arrayBuffer();
            samples[key] = await ctx.decodeAudioData(arrayBuffer);
            loaded++;
        } catch (e) {
            console.warn(`Failed to load ${key}:`, e);
            // Create fallback synthetic sample
            samples[key] = createFallbackSample(key);
            loaded++;
        }
    }

    samplesLoaded = true;
    document.getElementById('loading').classList.add('off');
    document.getElementById('dials').style.display = 'block';
}

// Fallback synthesis if samples fail to load
function createFallbackSample(key) {
    const sr = ctx.sampleRate;
    const len = sr * 0.5;
    const buf = ctx.createBuffer(2, len, sr);

    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);

        if (key.includes('kick')) {
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                const freq = 150 * Math.exp(-t * 30) + 40;
                const env = Math.exp(-t * 15);
                d[i] = Math.sin(TAU * freq * t) * env * 0.8;
            }
        } else if (key.includes('snare')) {
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                const env = Math.exp(-t * 20);
                const tone = Math.sin(TAU * 200 * t) * Math.exp(-t * 30);
                const noise = (Math.random() * 2 - 1) * env;
                d[i] = (tone * 0.4 + noise * 0.6) * 0.6;
            }
        } else if (key.includes('hat')) {
            for (let i = 0; i < len * 0.1; i++) {
                const t = i / sr;
                const env = Math.exp(-t * 80);
                d[i] = (Math.random() * 2 - 1) * env * 0.3;
            }
        } else if (key.includes('bass')) {
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                const env = Math.exp(-t * 2);
                d[i] = Math.sin(TAU * 55 * t) * env * 0.9;
            }
        }
    }

    return buf;
}

// ============ PROFESSIONAL FX CHAIN ============

let drumBus, bassBus, masterBus;
let saturation, eq, compressor, limiter, stereoWidener;
let lofiFilter, tapeDelay, reverbConvolver;

function createFXChain() {
    // Individual buses for mixing
    drumBus = ctx.createGain();
    drumBus.gain.value = 0.8;

    bassBus = ctx.createGain();
    bassBus.gain.value = 0.7;

    masterBus = ctx.createGain();
    masterBus.gain.value = 1.0;

    // Saturation (warm distortion)
    saturation = ctx.createWaveShaper();
    const satCurve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        // Soft clipping curve
        satCurve[i] = Math.tanh(x * 1.5) * 0.9;
    }
    saturation.curve = satCurve;
    saturation.oversample = '4x';

    // EQ (low shelf boost, high shelf)
    const eqLow = ctx.createBiquadFilter();
    eqLow.type = 'lowshelf';
    eqLow.frequency.value = 100;
    eqLow.gain.value = 3;

    const eqHigh = ctx.createBiquadFilter();
    eqHigh.type = 'highshelf';
    eqHigh.frequency.value = 8000;
    eqHigh.gain.value = 2;

    const eqMid = ctx.createBiquadFilter();
    eqMid.type = 'peaking';
    eqMid.frequency.value = 2500;
    eqMid.Q.value = 1;
    eqMid.gain.value = -2; // Slight mid scoop

    eq = { low: eqLow, mid: eqMid, high: eqHigh };

    // Compressor
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -12;
    compressor.knee.value = 6;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.15;

    // Limiter
    limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.knee.value = 0;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.05;

    // Lo-fi filter (for vibe)
    lofiFilter = ctx.createBiquadFilter();
    lofiFilter.type = 'lowpass';
    lofiFilter.frequency.value = 20000;
    lofiFilter.Q.value = 0.5;

    // Tape delay
    tapeDelay = ctx.createDelay(1);
    tapeDelay.delayTime.value = 0.375;
    const delayFeedback = ctx.createGain();
    delayFeedback.gain.value = 0.3;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 3000;
    const delayWet = ctx.createGain();
    delayWet.gain.value = 0.15;

    tapeDelay.connect(delayFilter);
    delayFilter.connect(delayFeedback);
    delayFeedback.connect(tapeDelay);
    delayFilter.connect(delayWet);

    // Reverb (convolution)
    reverbConvolver = ctx.createConvolver();
    const reverbLen = ctx.sampleRate * 2;
    const reverbBuf = ctx.createBuffer(2, reverbLen, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = reverbBuf.getChannelData(ch);
        for (let i = 0; i < reverbLen; i++) {
            // Exponential decay with early reflections
            const t = i / ctx.sampleRate;
            const early = i < ctx.sampleRate * 0.05 ? Math.random() * 0.5 : 0;
            const late = Math.random() * Math.exp(-t * 2);
            d[i] = (early + late) * 0.3;
        }
    }
    reverbConvolver.buffer = reverbBuf;
    const reverbWet = ctx.createGain();
    reverbWet.gain.value = 0.2;
    reverbConvolver.connect(reverbWet);

    // Master output
    master = ctx.createGain();
    master.gain.value = 0.85;

    // Routing
    drumBus.connect(masterBus);
    bassBus.connect(masterBus);

    masterBus.connect(saturation);
    saturation.connect(eqLow);
    eqLow.connect(eqMid);
    eqMid.connect(eqHigh);
    eqHigh.connect(lofiFilter);
    lofiFilter.connect(compressor);

    // Send to delay and reverb
    masterBus.connect(tapeDelay);
    masterBus.connect(reverbConvolver);

    compressor.connect(limiter);
    delayWet.connect(limiter);
    reverbWet.connect(limiter);

    limiter.connect(master);
    master.connect(ctx.destination);
}

// ============ SAMPLE PLAYBACK ============

function playSample(buffer, options = {}) {
    if (!buffer) return;

    const source = ctx.createBufferSource();
    source.buffer = buffer;

    // Pitch shift
    if (options.pitch) {
        source.playbackRate.value = Math.pow(2, options.pitch / 12);
    }

    // Gain
    const gain = ctx.createGain();
    gain.gain.value = options.volume || 1;

    // Optional filter
    if (options.filterFreq) {
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = options.filterFreq;
        source.connect(filter);
        filter.connect(gain);
    } else {
        source.connect(gain);
    }

    // Pan
    if (options.pan) {
        const panner = ctx.createStereoPanner();
        panner.pan.value = options.pan;
        gain.connect(panner);
        panner.connect(options.bus || drumBus);
    } else {
        gain.connect(options.bus || drumBus);
    }

    source.start(ctx.currentTime + (options.delay || 0));

    return source;
}

// ============ BEAT PATTERNS ============

const PATTERNS = {
    none: null,
    lofi: {
        bpm: 72,
        swing: 0.1,
        steps: 16,
        kick: [0, 8],
        snare: [4, 12],
        hat: [2, 6, 10, 14],
        prefix: 'lofi'
    },
    trap: {
        bpm: 140,
        swing: 0,
        steps: 16,
        kick: [0, 6, 10],
        snare: [4, 12],
        hat: [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15],
        prefix: 'trap'
    },
    boom: {
        bpm: 90,
        swing: 0.15,
        steps: 16,
        kick: [0, 5, 8, 13],
        snare: [4, 12],
        hat: [2, 6, 10, 14],
        prefix: 'boom'
    },
    house: {
        bpm: 124,
        swing: 0,
        steps: 16,
        kick: [0, 4, 8, 12],
        snare: [4, 12],
        hat: [2, 6, 10, 14],
        prefix: 'house'
    }
};

let currentStep = 0;
let lastStepTime = 0;
let stepInterval = 0;

function updateBeats() {
    const pattern = PATTERNS[dials.beats];
    if (!pattern || !samplesLoaded) return;

    const now = ctx.currentTime;
    const stepDuration = 60 / pattern.bpm / 4;

    if (now - lastStepTime >= stepDuration) {
        lastStepTime = now;
        const step = currentStep % pattern.steps;

        // Apply swing to off-beats
        let swingDelay = 0;
        if (pattern.swing && step % 2 === 1) {
            swingDelay = stepDuration * pattern.swing;
        }

        // Play drums
        if (pattern.kick.includes(step)) {
            playSample(samples[pattern.prefix + '_kick'], {
                volume: 0.9,
                delay: swingDelay
            });
        }

        if (pattern.snare.includes(step)) {
            playSample(samples[pattern.prefix + '_snare'], {
                volume: 0.75,
                delay: swingDelay,
                pan: (Math.random() - 0.5) * 0.1
            });
        }

        if (pattern.hat.includes(step)) {
            const velocity = step % 4 === 0 ? 0.5 : 0.35;
            playSample(samples[pattern.prefix + '_hat'], {
                volume: velocity,
                delay: swingDelay,
                pan: (Math.random() - 0.5) * 0.3,
                filterFreq: dials.vibe === 'lofi' ? 8000 : 16000
            });
        }

        currentStep++;
    }
}

// ============ BASS ============

let bassOsc1, bassOsc2, bassFilter, bassGain, bassDistortion;

function initBass() {
    // Two oscillators for thickness
    bassOsc1 = ctx.createOscillator();
    bassOsc2 = ctx.createOscillator();

    bassOsc1.type = 'sine';
    bassOsc2.type = 'sine';
    bassOsc1.frequency.value = 55;
    bassOsc2.frequency.value = 55;

    // Slight detune for width
    bassOsc2.detune.value = 5;

    // Filter
    bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 500;
    bassFilter.Q.value = 2;

    // Distortion for harmonics
    bassDistortion = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        const x = (i / 128) - 1;
        curve[i] = Math.tanh(x * 2);
    }
    bassDistortion.curve = curve;

    bassGain = ctx.createGain();
    bassGain.gain.value = 0;

    const merge = ctx.createGain();
    merge.gain.value = 0.5;

    bassOsc1.connect(merge);
    bassOsc2.connect(merge);
    merge.connect(bassFilter);
    bassFilter.connect(bassDistortion);
    bassDistortion.connect(bassGain);
    bassGain.connect(bassBus);

    bassOsc1.start();
    bassOsc2.start();
}

function updateBass() {
    if (dials.bass === 'none') {
        bassGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
        return;
    }

    const configs = {
        sub: {
            type1: 'sine', type2: 'sine',
            base: 32.7, // C1
            filterFreq: 200,
            distortion: 0.5,
            volume: 0.6
        },
        reese: {
            type1: 'sawtooth', type2: 'sawtooth',
            base: 55,
            filterFreq: 800,
            distortion: 0.8,
            volume: 0.4,
            detune: 15
        },
        analog: {
            type1: 'square', type2: 'sawtooth',
            base: 55,
            filterFreq: 1000,
            distortion: 0.3,
            volume: 0.35,
            detune: 7
        }
    };

    const cfg = configs[dials.bass];
    const freq = cfg.base * Math.pow(2, (1 - field.y) * 1.5);

    bassOsc1.type = cfg.type1;
    bassOsc2.type = cfg.type2;
    bassOsc1.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.02);
    bassOsc2.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.02);
    bassOsc2.detune.value = cfg.detune || 5;

    const filterMod = 1 + field.energy * 2;
    bassFilter.frequency.linearRampToValueAtTime(cfg.filterFreq * filterMod, ctx.currentTime + 0.05);

    bassGain.gain.linearRampToValueAtTime(cfg.volume, ctx.currentTime + 0.1);
}

// ============ LAYERS ============

let layers = [];

function createLayer() {
    if (layers.length >= 4) {
        const old = layers.shift();
        old.osc.stop();
    }

    const freq = 220 * Math.pow(2, (1 - field.y) * 2);

    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const f = ctx.createBiquadFilter();

    o.type = layers.length % 2 === 0 ? 'sine' : 'triangle';
    o.frequency.value = freq;

    f.type = 'lowpass';
    f.frequency.value = 2000;

    const vol = 0.04 * Math.pow(0.6, layers.length);
    g.gain.value = vol;

    o.connect(f).connect(g).connect(masterBus);
    o.start();

    layers.push({ osc: o, gain: g, filter: f, freq, vol, phase: 0, len: 2 + Math.random() });
}

function updateLayers(dt) {
    for (const L of layers) {
        L.phase += dt / L.len;
        if (L.phase >= 1) L.phase -= 1;
        const env = 0.5 + 0.5 * Math.cos(L.phase * TAU);
        L.gain.gain.value = L.vol * env;
    }
}

let orb = { active: false, x: 0.5, y: 0.5 };

function updateOrb(dt) {
    if (!orb.active && field.energy > 0.04) {
        orb.active = true;
        orb.x = field.x;
        orb.y = field.y;
    }

    if (orb.active) {
        const dx = 0.5 - orb.x;
        const dy = 0.5 - orb.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.03) {
            orb.x += (dx / dist) * 0.5 * dt;
            orb.y += (dy / dist) * 0.5 * dt;
        } else {
            createLayer();
            orb.active = false;
        }

        if (field.energy < 0.01) orb.active = false;
    }
}

// ============ VIBE CONTROL ============

const VIBES = {
    raw: { filter: 20000, saturation: 0.5, reverb: 0.1, delay: 0.05 },
    lofi: { filter: 3500, saturation: 1.2, reverb: 0.25, delay: 0.15 },
    polished: { filter: 18000, saturation: 0.8, reverb: 0.2, delay: 0.1 },
    saturated: { filter: 12000, saturation: 2.5, reverb: 0.15, delay: 0.2 }
};

function updateVibe() {
    const cfg = VIBES[dials.vibe];

    lofiFilter.frequency.linearRampToValueAtTime(cfg.filter, ctx.currentTime + 0.2);

    // Update saturation curve
    const amount = cfg.saturation;
    const curve = saturation.curve;
    for (let i = 0; i < curve.length; i++) {
        const x = (i / (curve.length / 2)) - 1;
        curve[i] = Math.tanh(x * amount) / Math.tanh(amount || 1);
    }
}

// ============ INPUT ============

function onMove(nx, ny) {
    const dx = nx - field.x;
    const dy = ny - field.y;
    field.x += dx * 0.2;
    field.y += dy * 0.2;
    field.energy = field.energy * 0.9 + Math.sqrt(dx*dx + dy*dy) * 2;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;
    field.x = Math.max(0, Math.min(1, field.x + ax * 0.05));
    field.y = Math.max(0, Math.min(1, field.y - ay * 0.05));
    field.energy = field.energy * 0.9 + Math.sqrt(ax*ax + ay*ay) * 0.5;
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 45;
    const gy = (e.beta || 0) / 45 - 0.5;
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ WHEEL UI ============

function initWheels() {
    document.querySelectorAll('.wheel').forEach(wheel => {
        const track = wheel.querySelector('.wheel-track');
        const notches = wheel.querySelectorAll('.wheel-notch');
        const dialName = wheel.dataset.dial;
        let currentIndex = Array.from(notches).findIndex(n => n.classList.contains('active'));

        function updateWheel(index) {
            index = Math.max(0, Math.min(notches.length - 1, index));
            currentIndex = index;
            notches.forEach((n, i) => n.classList.toggle('active', i === index));
            track.style.transform = `translateX(calc(-50% + ${-index * 70}px))`;
            dials[dialName] = notches[index].dataset.value;

            if (dialName === 'beats') {
                currentStep = 0;
                lastStepTime = ctx ? ctx.currentTime : 0;
            }
            if (dialName === 'vibe' && ctx) updateVibe();
        }

        notches.forEach((notch, i) => {
            notch.addEventListener('click', e => { e.stopPropagation(); updateWheel(i); });
            notch.addEventListener('touchend', e => e.stopPropagation());
        });

        let startX = 0, startIndex = 0;
        wheel.addEventListener('touchstart', e => { e.stopPropagation(); startX = e.touches[0].clientX; startIndex = currentIndex; }, { passive: true });
        wheel.addEventListener('touchmove', e => e.stopPropagation(), { passive: true });
        wheel.addEventListener('touchend', e => {
            e.stopPropagation();
            const diff = startX - e.changedTouches[0].clientX;
            if (Math.abs(diff) > 30) updateWheel(startIndex + (diff > 0 ? 1 : -1));
        });
        wheel.addEventListener('click', e => e.stopPropagation());

        updateWheel(currentIndex);

        const teethTop = wheel.querySelector('.wheel-teeth.top');
        const teethBottom = wheel.querySelector('.wheel-teeth.bottom');
        for (let i = 0; i < 20; i++) {
            teethTop.innerHTML += '<div class="wheel-tooth"></div>';
            teethBottom.innerHTML += '<div class="wheel-tooth"></div>';
        }
    });
}

// ============ VISUALS ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    vc.fillStyle = 'rgba(10,10,10,0.12)';
    vc.fillRect(0, 0, w, h);

    vc.strokeStyle = 'rgba(255,255,255,0.06)';
    vc.beginPath();
    vc.arc(w/2, h/2, 25, 0, TAU);
    vc.stroke();

    layers.forEach((L, i) => {
        const r = 35 + i * 25;
        const a = 0.08 + (0.5 + 0.5 * Math.cos(L.phase * TAU)) * 0.12;
        vc.strokeStyle = `rgba(120,150,200,${a})`;
        vc.beginPath();
        vc.arc(w/2, h/2, r, 0, TAU);
        vc.stroke();
    });

    if (orb.active) {
        vc.fillStyle = 'rgba(255,255,255,0.5)';
        vc.beginPath();
        vc.arc(orb.x * w, orb.y * h, 5, 0, TAU);
        vc.fill();
    }

    vc.fillStyle = `rgba(255,255,255,${0.12 + field.energy * 0.4})`;
    vc.beginPath();
    vc.arc(field.x * w, field.y * h, 4 + field.energy * 10, 0, TAU);
    vc.fill();
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    const dt = 1/60;
    field.time += dt;
    field.energy *= 0.97;

    updateBeats();
    updateBass();
    updateOrb(dt);
    updateLayers(dt);

    draw();
    requestAnimationFrame(tick);
}

// ============ INIT ============

async function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    createFXChain();
    initBass();
    initWheels();

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    addEventListener('resize', resize);

    // Load samples
    document.getElementById('loading').classList.remove('off');
    await loadSamples();

    updateVibe();
}

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    await init();

    addEventListener('devicemotion', onMotion);
    addEventListener('deviceorientation', onOrientation);

    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
