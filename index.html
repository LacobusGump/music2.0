<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OMNI | Music 2.0</title>

    <!-- Essentia.js for audio analysis -->
    <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia-wasm.web.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/essentia.js@0.1.3/dist/essentia.js-core.js"></script>

    <!-- Tone.js for synthesis -->
    <script src="https://cdn.jsdelivr.net/npm/tone@15.0.4/build/Tone.min.js"></script>

    <style>
        :root {
            /* Fibonacci-based spacing: 1, 2, 3, 5, 8, 13, 21, 34, 55, 89 */
            --phi: 1.618033988749;
            --space-1: 1px;
            --space-2: 2px;
            --space-3: 3px;
            --space-5: 5px;
            --space-8: 8px;
            --space-13: 13px;
            --space-21: 21px;
            --space-34: 34px;
            --space-55: 55px;
            --space-89: 89px;

            --bg: #0a0a0b;
            --surface: #111113;
            --accent: #00ffa3;
            --accent-dim: rgba(0, 255, 163, 0.15);
            --text: #e8e8e8;
            --text-dim: #666;
            --font: 'SF Mono', 'Fira Code', 'Consolas', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: var(--font);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Golden ratio container: width/height = phi */
        .container {
            width: min(90vw, 610px);
            height: min(90vh, 377px); /* 610/phi â‰ˆ 377 */
            display: flex;
            flex-direction: column;
            position: relative;
        }

        /* Start screen */
        #start-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: var(--space-34);
            z-index: 100;
            transition: opacity 0.8s ease, visibility 0.8s ease;
        }

        #start-screen.hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
        }

        .logo {
            font-size: var(--space-21);
            letter-spacing: var(--space-8);
            font-weight: 300;
            color: var(--text);
        }

        .logo span {
            color: var(--accent);
        }

        .start-btn {
            width: 144px; /* Fibonacci: 89 + 55 */
            height: 89px;
            background: transparent;
            border: 1px solid var(--accent-dim);
            color: var(--accent);
            font-family: var(--font);
            font-size: 11px;
            letter-spacing: var(--space-3);
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .start-btn::before {
            content: '';
            position: absolute;
            inset: 0;
            background: var(--accent);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .start-btn:hover::before {
            opacity: 0.1;
        }

        .start-btn:hover {
            border-color: var(--accent);
            box-shadow: 0 0 var(--space-34) var(--accent-dim);
        }

        /* Main interface */
        #main {
            display: none;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        #main.active {
            display: flex;
        }

        /* Header */
        .header {
            height: var(--space-55);
            padding: 0 var(--space-21);
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--accent-dim);
            background: var(--surface);
        }

        .header-title {
            font-size: 11px;
            letter-spacing: var(--space-3);
            color: var(--text-dim);
        }

        .header-title span {
            color: var(--accent);
        }

        .header-stats {
            display: flex;
            gap: var(--space-21);
            font-size: 10px;
            color: var(--text-dim);
        }

        .stat-value {
            color: var(--accent);
        }

        /* Canvas area */
        .viewport {
            flex: 1;
            position: relative;
            background: var(--bg);
        }

        #canvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
        }

        /* Central orb */
        .orb-container {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .orb {
            width: 89px;
            height: 89px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%,
                rgba(0, 255, 163, 0.4) 0%,
                rgba(0, 255, 163, 0.1) 50%,
                transparent 70%);
            box-shadow: 0 0 var(--space-55) var(--accent-dim);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .orb.listening {
            animation: breathe 3s ease-in-out infinite;
        }

        .orb.active {
            animation: pulse 0.5s ease-out;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.08); opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); box-shadow: 0 0 var(--space-89) var(--accent); }
            100% { transform: scale(1); }
        }

        /* Stage indicator */
        .stage {
            position: absolute;
            bottom: var(--space-34);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .stage-name {
            font-size: 10px;
            letter-spacing: var(--space-5);
            color: var(--accent);
            margin-bottom: var(--space-8);
        }

        .stage-progress {
            width: 144px;
            height: var(--space-2);
            background: var(--surface);
            border-radius: 1px;
            overflow: hidden;
        }

        .stage-fill {
            height: 100%;
            width: 0%;
            background: var(--accent);
            transition: width 0.5s ease;
        }

        /* Info panels - Fibonacci positioned */
        .panel {
            position: absolute;
            background: rgba(17, 17, 19, 0.9);
            border: 1px solid var(--accent-dim);
            padding: var(--space-13);
            font-size: 9px;
            backdrop-filter: blur(8px);
        }

        .panel-left {
            left: var(--space-21);
            top: var(--space-21);
            width: 144px;
        }

        .panel-right {
            right: var(--space-21);
            top: var(--space-21);
            width: 89px;
        }

        .panel-label {
            color: var(--text-dim);
            margin-bottom: var(--space-3);
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .panel-value {
            color: var(--text);
            font-size: 11px;
        }

        .panel-row {
            margin-bottom: var(--space-8);
        }

        .panel-row:last-child {
            margin-bottom: 0;
        }

        /* Meter bar */
        .meter {
            height: var(--space-3);
            background: var(--surface);
            margin-top: var(--space-3);
            border-radius: 1px;
            overflow: hidden;
        }

        .meter-fill {
            height: 100%;
            background: var(--accent);
            width: 0%;
            transition: width 0.1s ease;
        }

        /* Log window */
        .log {
            position: absolute;
            bottom: var(--space-21);
            left: var(--space-21);
            width: 233px; /* 144 + 89 */
            height: 89px;
            overflow: hidden;
            font-size: 8px;
            color: var(--text-dim);
        }

        .log-entry {
            margin-bottom: var(--space-2);
            opacity: 0.7;
        }

        .log-entry.highlight {
            color: var(--accent);
            opacity: 1;
        }

        /* Mobile adjustments */
        @media (max-width: 600px) {
            .panel { display: none; }
            .log { display: none; }
            .orb { width: 55px; height: 55px; }
        }
    </style>
</head>
<body>

<div id="start-screen">
    <div class="logo">OMNI <span>//</span> MUSIC 2.0</div>
    <button class="start-btn" id="start-btn">LISTEN</button>
</div>

<div id="main">
    <header class="header">
        <div class="header-title">OMNI <span>_</span> ENGINE</div>
        <div class="header-stats">
            <div>STAGE: <span id="stat-stage" class="stat-value">LISTENING</span></div>
            <div>BPM: <span id="stat-bpm" class="stat-value">--</span></div>
            <div>KEY: <span id="stat-key" class="stat-value">--</span></div>
        </div>
    </header>

    <div class="viewport">
        <canvas id="canvas"></canvas>

        <div class="orb-container">
            <div class="orb listening" id="orb"></div>
        </div>

        <div class="panel panel-left">
            <div class="panel-row">
                <div class="panel-label">Energy</div>
                <div class="meter"><div class="meter-fill" id="meter-energy"></div></div>
            </div>
            <div class="panel-row">
                <div class="panel-label">Detected</div>
                <div class="panel-value" id="val-detected">--</div>
            </div>
            <div class="panel-row">
                <div class="panel-label">Samples</div>
                <div class="panel-value" id="val-samples">0</div>
            </div>
        </div>

        <div class="panel panel-right">
            <div class="panel-row">
                <div class="panel-label">Voices</div>
                <div class="panel-value" id="val-voices">0</div>
            </div>
            <div class="panel-row">
                <div class="panel-label">Coherence</div>
                <div class="meter"><div class="meter-fill" id="meter-coherence"></div></div>
            </div>
        </div>

        <div class="stage">
            <div class="stage-name" id="stage-name">AWAKENING</div>
            <div class="stage-progress">
                <div class="stage-fill" id="stage-fill"></div>
            </div>
        </div>

        <div class="log" id="log"></div>
    </div>
</div>

<script>
// ============================================================================
// OMNI MUSIC 2.0 - HYBRID AI AUDIO ENGINE
// ============================================================================

const PHI = 1.618033988749;
const FIB = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610];

// ============================================================================
// CORE STATE
// ============================================================================

const OMNI = {
    stage: 'AWAKENING',
    stageProgress: 0,
    isRunning: false,

    // Audio analysis state
    energy: 0,
    pitch: 0,
    onset: false,
    tempo: 0,

    // Musical state
    detectedKey: null,
    detectedBPM: null,
    coherence: 0,

    // Sample memory
    samples: [],
    maxSamples: 34, // Fibonacci

    // Voice count
    activeVoices: 0,

    // Evolution thresholds (Fibonacci-based)
    stages: {
        AWAKENING: { threshold: 0, next: 'GATHERING' },
        GATHERING: { threshold: 21, next: 'PULSING' },
        PULSING: { threshold: 55, next: 'HARMONIZING' },
        HARMONIZING: { threshold: 89, next: 'COHESION' },
        COHESION: { threshold: 144, next: null }
    }
};

// ============================================================================
// LOGGING
// ============================================================================

function log(msg, highlight = false) {
    const logEl = document.getElementById('log');
    const entry = document.createElement('div');
    entry.className = 'log-entry' + (highlight ? ' highlight' : '');
    entry.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.prepend(entry);
    if (logEl.children.length > 13) {
        logEl.removeChild(logEl.lastChild);
    }
}

// ============================================================================
// AUDIO ENGINE
// ============================================================================

class AudioEngine {
    constructor() {
        this.ctx = null;
        this.analyser = null;
        this.micSource = null;
        this.essentia = null;

        // Ring buffer for sample capture
        this.ringBuffer = null;
        this.ringBufferSize = 44100 * 8; // 8 seconds
        this.writePtr = 0;

        // Analysis buffers
        this.fftSize = 2048;
        this.timeData = null;
        this.freqData = null;

        // Onset detection state
        this.prevEnergy = 0;
        this.onsetThreshold = 0.02; // Much more sensitive
        this.onsetCooldown = 0;

        // Pitch tracking
        this.pitchHistory = [];
        this.pitchHistorySize = 21;

        // Tempo detection
        this.onsetTimes = [];
        this.tempoWindow = 5000; // 5 seconds
    }

    async init() {
        try {
            // Initialize Web Audio
            this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                sampleRate: 44100
            });

            // Get microphone
            const stream = await navigator.mediaDevices.getUserMedia({
                audio: {
                    echoCancellation: false,
                    noiseSuppression: false,
                    autoGainControl: false
                }
            });

            this.micSource = this.ctx.createMediaStreamSource(stream);

            // Analyser node
            this.analyser = this.ctx.createAnalyser();
            this.analyser.fftSize = this.fftSize;
            this.analyser.smoothingTimeConstant = 0.3;
            this.micSource.connect(this.analyser);

            // Buffers
            this.timeData = new Float32Array(this.fftSize);
            this.freqData = new Float32Array(this.analyser.frequencyBinCount);
            this.ringBuffer = new Float32Array(this.ringBufferSize);

            // Initialize Essentia
            if (typeof EssentiaWASM !== 'undefined') {
                const wasmModule = await EssentiaWASM();
                this.essentia = new Essentia(wasmModule);
                log('ESSENTIA: Audio analysis ready', true);
            } else {
                log('ESSENTIA: Fallback to basic analysis');
            }

            // Script processor for ring buffer (deprecated but works everywhere)
            const processor = this.ctx.createScriptProcessor(2048, 1, 1);
            this.micSource.connect(processor);
            processor.connect(this.ctx.destination);
            processor.onaudioprocess = (e) => {
                const input = e.inputBuffer.getChannelData(0);
                this.writeToRingBuffer(input);
            };

            log('AUDIO: Microphone active', true);
            return true;

        } catch (err) {
            log('AUDIO: ' + err.message);
            throw err;
        }
    }

    writeToRingBuffer(data) {
        for (let i = 0; i < data.length; i++) {
            this.ringBuffer[this.writePtr] = data[i];
            this.writePtr = (this.writePtr + 1) % this.ringBufferSize;
        }
    }

    analyze() {
        if (!this.analyser) return null;

        this.analyser.getFloatTimeDomainData(this.timeData);
        this.analyser.getFloatFrequencyData(this.freqData);

        // RMS Energy
        let sum = 0;
        for (let i = 0; i < this.timeData.length; i++) {
            sum += this.timeData[i] * this.timeData[i];
        }
        const energy = Math.sqrt(sum / this.timeData.length);
        OMNI.energy = energy;

        // Onset detection (energy increase)
        const energyDelta = energy - this.prevEnergy;
        let onset = false;

        if (this.onsetCooldown > 0) {
            this.onsetCooldown--;
        } else if (energyDelta > this.onsetThreshold && energy > 0.01) {
            onset = true;
            this.onsetCooldown = 8; // Prevent rapid retriggering
            this.recordOnsetTime();
        }
        this.prevEnergy = energy * 0.7 + this.prevEnergy * 0.3;
        OMNI.onset = onset;

        // Pitch estimation (zero crossing + spectral peak)
        let pitch = this.estimatePitch();
        if (pitch > 0) {
            this.pitchHistory.push(pitch);
            if (this.pitchHistory.length > this.pitchHistorySize) {
                this.pitchHistory.shift();
            }
        }
        OMNI.pitch = pitch;

        // Tempo estimation
        OMNI.tempo = this.estimateTempo();

        return { energy, onset, pitch };
    }

    estimatePitch() {
        // Simple autocorrelation-based pitch detection
        const buffer = this.timeData;
        const SIZE = buffer.length;
        const MAX_SAMPLES = Math.floor(SIZE / 2);
        let bestOffset = -1;
        let bestCorrelation = 0;
        let foundGoodCorrelation = false;

        const correlations = new Array(MAX_SAMPLES);

        for (let offset = 0; offset < MAX_SAMPLES; offset++) {
            let correlation = 0;
            for (let i = 0; i < MAX_SAMPLES; i++) {
                correlation += Math.abs(buffer[i] - buffer[i + offset]);
            }
            correlation = 1 - (correlation / MAX_SAMPLES);
            correlations[offset] = correlation;

            if (correlation > 0.9 && correlation > bestCorrelation) {
                bestCorrelation = correlation;
                bestOffset = offset;
                foundGoodCorrelation = true;
            }
        }

        if (!foundGoodCorrelation) return 0;

        // Refine with parabolic interpolation
        const shift = (correlations[bestOffset + 1] - correlations[bestOffset - 1]) /
                     (2 * (2 * correlations[bestOffset] - correlations[bestOffset - 1] - correlations[bestOffset + 1]));

        return this.ctx.sampleRate / (bestOffset + shift);
    }

    recordOnsetTime() {
        const now = Date.now();
        this.onsetTimes.push(now);

        // Keep only recent onsets
        const cutoff = now - this.tempoWindow;
        this.onsetTimes = this.onsetTimes.filter(t => t > cutoff);
    }

    estimateTempo() {
        if (this.onsetTimes.length < 4) return 0;

        // Calculate intervals between onsets
        const intervals = [];
        for (let i = 1; i < this.onsetTimes.length; i++) {
            intervals.push(this.onsetTimes[i] - this.onsetTimes[i - 1]);
        }

        // Filter reasonable intervals (200ms to 2000ms = 30 to 300 BPM)
        const validIntervals = intervals.filter(i => i >= 200 && i <= 2000);
        if (validIntervals.length < 3) return 0;

        // Find median interval
        validIntervals.sort((a, b) => a - b);
        const medianInterval = validIntervals[Math.floor(validIntervals.length / 2)];

        // Convert to BPM
        return Math.round(60000 / medianInterval);
    }

    captureSample(durationMs = 500) {
        const samples = Math.floor((durationMs / 1000) * this.ctx.sampleRate);
        const buffer = new Float32Array(samples);

        let readPtr = this.writePtr - samples;
        if (readPtr < 0) readPtr += this.ringBufferSize;

        for (let i = 0; i < samples; i++) {
            buffer[i] = this.ringBuffer[(readPtr + i) % this.ringBufferSize];
        }

        return buffer;
    }
}

// ============================================================================
// SYNTHESIS ENGINE (Tone.js)
// ============================================================================

class SynthEngine {
    constructor() {
        this.isReady = false;
        this.synths = {};
        this.effects = {};
        this.grainPlayers = [];
    }

    async init() {
        await Tone.start();

        // Master limiter
        const limiter = new Tone.Limiter(-1).toDestination();

        // Reverb for space
        this.effects.reverb = new Tone.Reverb({
            decay: 3,
            wet: 0.3
        }).connect(limiter);
        await this.effects.reverb.generate();

        // Delay for rhythmic interest
        this.effects.delay = new Tone.FeedbackDelay({
            delayTime: '8n',
            feedback: 0.3,
            wet: 0.2
        }).connect(this.effects.reverb);

        // Filter for warmth
        this.effects.filter = new Tone.Filter({
            frequency: 2000,
            type: 'lowpass',
            rolloff: -24
        }).connect(this.effects.delay);

        // Synths
        this.synths.pad = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'sine' },
            envelope: { attack: 0.5, decay: 0.3, sustain: 0.8, release: 2 }
        }).connect(this.effects.filter);
        this.synths.pad.volume.value = -12;

        this.synths.pluck = new Tone.PluckSynth({
            resonance: 0.9,
            release: 1
        }).connect(this.effects.delay);
        this.synths.pluck.volume.value = -8;

        this.synths.membrane = new Tone.MembraneSynth({
            pitchDecay: 0.05,
            octaves: 4
        }).connect(limiter);
        this.synths.membrane.volume.value = -10;

        // Noise for texture
        this.synths.noise = new Tone.NoiseSynth({
            noise: { type: 'brown' },
            envelope: { attack: 0.5, decay: 0.2, sustain: 0.5, release: 1 }
        }).connect(this.effects.reverb);
        this.synths.noise.volume.value = -20;

        this.isReady = true;
        log('SYNTH: Tone.js initialized', true);
    }

    playPad(notes, duration = '2n') {
        if (!this.isReady) return;
        this.synths.pad.triggerAttackRelease(notes, duration);
        OMNI.activeVoices++;
        setTimeout(() => OMNI.activeVoices--, Tone.Time(duration).toMilliseconds());
    }

    playPluck(note, duration = '8n') {
        if (!this.isReady) return;
        this.synths.pluck.triggerAttackRelease(note, duration);
        OMNI.activeVoices++;
        setTimeout(() => OMNI.activeVoices--, Tone.Time(duration).toMilliseconds());
    }

    playKick(note = 'C1') {
        if (!this.isReady) return;
        this.synths.membrane.triggerAttackRelease(note, '8n');
        OMNI.activeVoices++;
        setTimeout(() => OMNI.activeVoices--, 200);
    }

    playTexture(duration = '4n') {
        if (!this.isReady) return;
        this.synths.noise.triggerAttackRelease(duration);
    }

    setTempo(bpm) {
        Tone.Transport.bpm.value = bpm;
    }

    getTransportTime() {
        return Tone.Transport.seconds;
    }
}

// ============================================================================
// SAMPLE MEMORY
// ============================================================================

class SampleMemory {
    constructor() {
        this.samples = [];
        this.maxSamples = 34;
    }

    add(audioBuffer, metadata) {
        const sample = {
            id: Date.now(),
            buffer: audioBuffer,
            type: metadata.type || 'unknown', // 'percussive', 'tonal', 'texture'
            energy: metadata.energy || 0,
            pitch: metadata.pitch || 0,
            timestamp: Date.now()
        };

        this.samples.push(sample);

        // Keep only maxSamples
        if (this.samples.length > this.maxSamples) {
            this.samples.shift();
        }

        OMNI.samples = this.samples;
        return sample;
    }

    getByType(type) {
        return this.samples.filter(s => s.type === type);
    }

    getRandom() {
        if (this.samples.length === 0) return null;
        return this.samples[Math.floor(Math.random() * this.samples.length)];
    }

    getRecent(count = 5) {
        return this.samples.slice(-count);
    }
}

// ============================================================================
// CONDUCTOR - The AI that creates musical order
// ============================================================================

class Conductor {
    constructor(audioEngine, synthEngine, sampleMemory) {
        this.audio = audioEngine;
        this.synth = synthEngine;
        this.memory = sampleMemory;

        // Musical state
        this.detectedKey = null;
        this.currentScale = [0, 2, 4, 5, 7, 9, 11]; // Major scale intervals
        this.rootNote = 60; // Middle C

        // Fibonacci timing
        this.fibIndex = 0;
        this.nextEventTime = 0;
        this.baseInterval = 250; // ms - faster events

        // Evolution
        this.totalEvents = 0;
        this.coherenceScore = 0;

        // Pattern building
        this.rhythmPattern = [];
        this.melodyPattern = [];

        // Scheduling
        this.scheduledEvents = [];
    }

    update(analysisResult) {
        if (!analysisResult) return;

        const { energy, onset, pitch } = analysisResult;
        const now = Date.now();

        // Capture sample on onset
        if (onset && energy > 0.005) {
            this.captureAndClassify(energy, pitch);
        }

        // React to energy in real-time (even without onset)
        if (energy > 0.05 && Math.random() < energy * 0.5) {
            const note = Tone.Frequency(this.rootNote + 12 + this.currentScale[Math.floor(Math.random() * this.currentScale.length)], 'midi').toNote();
            this.synth.playPluck(note, '16n');
        }

        // Fibonacci-timed generative events
        if (now >= this.nextEventTime) {
            this.generateEvent();
            this.scheduleNextEvent();
        }

        // Update coherence based on pattern consistency
        this.updateCoherence();

        // Check for stage evolution
        this.checkEvolution();
    }

    captureAndClassify(energy, pitch) {
        const buffer = this.audio.captureSample(300);

        // Classify the sound
        let type = 'texture';
        if (energy > 0.3 && pitch < 200) {
            type = 'percussive';
        } else if (pitch > 100 && pitch < 2000) {
            type = 'tonal';
        }

        const sample = this.memory.add(buffer, { type, energy, pitch });

        // Update detected key if tonal
        if (type === 'tonal' && pitch > 0) {
            this.updateKeyDetection(pitch);
        }

        document.getElementById('val-detected').textContent = type.toUpperCase();
        document.getElementById('val-samples').textContent = this.memory.samples.length;

        log(`CAPTURED: ${type} (E:${energy.toFixed(2)} P:${Math.round(pitch)}Hz)`);

        // Pulse the orb
        const orb = document.getElementById('orb');
        orb.classList.remove('listening');
        orb.classList.add('active');
        setTimeout(() => {
            orb.classList.remove('active');
            orb.classList.add('listening');
        }, 500);

        this.totalEvents++;
    }

    updateKeyDetection(pitch) {
        // Convert frequency to MIDI note
        const midiNote = 12 * Math.log2(pitch / 440) + 69;
        const noteClass = Math.round(midiNote) % 12;

        // Simple key detection: track note occurrences
        if (!this.noteHistogram) {
            this.noteHistogram = new Array(12).fill(0);
        }
        this.noteHistogram[noteClass]++;

        // Find most common note as root
        let maxCount = 0;
        let root = 0;
        for (let i = 0; i < 12; i++) {
            if (this.noteHistogram[i] > maxCount) {
                maxCount = this.noteHistogram[i];
                root = i;
            }
        }

        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        this.detectedKey = noteNames[root];
        this.rootNote = 48 + root; // C3 + root

        document.getElementById('stat-key').textContent = this.detectedKey;
        OMNI.detectedKey = this.detectedKey;
    }

    generateEvent() {
        const stage = OMNI.stage;

        // Always log that we're generating
        if (this.fibIndex % 10 === 0) {
            log(`Stage: ${stage} | Events: ${this.totalEvents}`);
        }

        switch (stage) {
            case 'AWAKENING':
                // Ambient texture and occasional plucks to show it's alive
                if (Math.random() < 0.3) {
                    this.synth.playTexture('4n');
                }
                if (Math.random() < 0.2) {
                    const note = Tone.Frequency(this.rootNote + this.currentScale[Math.floor(Math.random() * 3)], 'midi').toNote();
                    this.synth.playPluck(note, '8n');
                }
                break;

            case 'GATHERING':
                // Start responding to captured sounds
                this.playFromMemory();
                break;

            case 'PULSING':
                // Establish rhythm
                this.playRhythm();
                break;

            case 'HARMONIZING':
                // Add harmony and melody
                this.playHarmony();
                this.playRhythm();
                break;

            case 'COHESION':
                // Full ensemble
                this.playFull();
                break;
        }
    }

    playFromMemory() {
        const sample = this.memory.getRandom();
        if (!sample) return;

        // Play synthesized response based on sample type
        if (sample.type === 'percussive') {
            this.synth.playKick();
        } else if (sample.type === 'tonal' && sample.pitch > 0) {
            const note = Tone.Frequency(sample.pitch, 'hz').toNote();
            this.synth.playPluck(note);
        }
    }

    playRhythm() {
        // Use detected tempo or default
        const bpm = OMNI.tempo || 90;
        this.synth.setTempo(bpm);
        document.getElementById('stat-bpm').textContent = bpm;
        OMNI.detectedBPM = bpm;

        // Play kick on downbeat
        if (this.fibIndex % 2 === 0) {
            this.synth.playKick();
        }

        // Pluck on off-beats (Fibonacci pattern)
        if (FIB[this.fibIndex % FIB.length] % 3 === 0) {
            const noteIndex = this.currentScale[this.fibIndex % this.currentScale.length];
            const note = Tone.Frequency(this.rootNote + noteIndex, 'midi').toNote();
            this.synth.playPluck(note);
        }
    }

    playHarmony() {
        // Build chord from scale
        const root = this.rootNote;
        const chord = [
            Tone.Frequency(root, 'midi').toNote(),
            Tone.Frequency(root + this.currentScale[2], 'midi').toNote(),
            Tone.Frequency(root + this.currentScale[4], 'midi').toNote()
        ];

        // Play pad chord occasionally
        if (this.fibIndex % 8 === 0) {
            this.synth.playPad(chord, '1n');
        }

        // Melody from Fibonacci sequence
        const melodyDegree = FIB[this.fibIndex % 8] % this.currentScale.length;
        const melodyNote = Tone.Frequency(root + 12 + this.currentScale[melodyDegree], 'midi').toNote();

        if (Math.random() < 0.6) {
            this.synth.playPluck(melodyNote, '4n');
        }
    }

    playFull() {
        this.playHarmony();
        this.playRhythm();

        // Add texture from captured samples
        if (Math.random() < 0.2) {
            this.synth.playTexture('8n');
        }
    }

    scheduleNextEvent() {
        // Fibonacci-based timing
        const fibMs = FIB[this.fibIndex % 8] * this.baseInterval / 8;
        this.nextEventTime = Date.now() + fibMs;
        this.fibIndex++;
    }

    updateCoherence() {
        // Coherence increases with consistent patterns
        const hasKey = this.detectedKey !== null;
        const hasTempo = OMNI.tempo > 0;
        const hasSamples = this.memory.samples.length > 5;

        let score = 0;
        if (hasKey) score += 0.3;
        if (hasTempo) score += 0.3;
        if (hasSamples) score += 0.4;

        // Smooth transition
        this.coherenceScore = this.coherenceScore * 0.95 + score * 0.05;
        OMNI.coherence = this.coherenceScore;

        document.getElementById('meter-coherence').style.width = (this.coherenceScore * 100) + '%';
    }

    checkEvolution() {
        const current = OMNI.stages[OMNI.stage];
        if (!current || !current.next) return;

        const nextStage = current.next;
        const threshold = OMNI.stages[nextStage]?.threshold || Infinity;

        // Progress based on total events
        const progress = Math.min(100, (this.totalEvents / threshold) * 100);
        OMNI.stageProgress = progress;
        document.getElementById('stage-fill').style.width = progress + '%';

        // Evolve to next stage
        if (this.totalEvents >= threshold) {
            this.evolve(nextStage);
        }
    }

    evolve(nextStage) {
        OMNI.stage = nextStage;
        document.getElementById('stage-name').textContent = nextStage;
        document.getElementById('stat-stage').textContent = nextStage;
        log(`EVOLVED: ${nextStage}`, true);

        // Visual feedback
        const orb = document.getElementById('orb');
        orb.classList.add('active');
        setTimeout(() => orb.classList.remove('active'), 1000);
    }
}

// ============================================================================
// VISUAL ENGINE
// ============================================================================

class VisualEngine {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.ctx = this.canvas.getContext('2d');
        this.particles = [];
        this.resize();
        window.addEventListener('resize', () => this.resize());
    }

    resize() {
        const dpr = window.devicePixelRatio || 1;
        this.canvas.width = window.innerWidth * dpr;
        this.canvas.height = window.innerHeight * dpr;
        this.ctx.scale(dpr, dpr);
    }

    update() {
        this.ctx.fillStyle = 'rgba(10, 10, 11, 0.1)';
        this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

        // Spawn particles on energy
        if (OMNI.energy > 0.1 && Math.random() < OMNI.energy) {
            this.spawnParticle();
        }

        // Update particles
        for (let i = this.particles.length - 1; i >= 0; i--) {
            const p = this.particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.01;
            p.vy += 0.02; // gravity

            if (p.life <= 0) {
                this.particles.splice(i, 1);
                continue;
            }

            this.ctx.beginPath();
            this.ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
            this.ctx.fillStyle = `rgba(0, 255, 163, ${p.life * 0.5})`;
            this.ctx.fill();
        }
    }

    spawnParticle() {
        const cx = window.innerWidth / 2;
        const cy = window.innerHeight / 2;
        const angle = Math.random() * Math.PI * 2;
        const speed = 1 + Math.random() * 2;

        this.particles.push({
            x: cx + (Math.random() - 0.5) * 50,
            y: cy + (Math.random() - 0.5) * 50,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed - 2,
            size: 2 + Math.random() * 3,
            life: 1
        });

        // Limit particles
        if (this.particles.length > 89) {
            this.particles.shift();
        }
    }
}

// ============================================================================
// MAIN APPLICATION
// ============================================================================

class OmniApp {
    constructor() {
        this.audio = new AudioEngine();
        this.synth = new SynthEngine();
        this.memory = new SampleMemory();
        this.conductor = null;
        this.visuals = null;
        this.isRunning = false;
    }

    async start() {
        try {
            log('OMNI: Initializing...', true);

            await this.audio.init();
            await this.synth.init();

            this.conductor = new Conductor(this.audio, this.synth, this.memory);
            this.visuals = new VisualEngine('canvas');

            // Hide start screen, show main
            document.getElementById('start-screen').classList.add('hidden');
            document.getElementById('main').classList.add('active');

            this.isRunning = true;
            OMNI.isRunning = true;

            log('OMNI: Music 2.0 Active', true);
            log('Make sounds to begin...');

            this.run();

        } catch (err) {
            log('ERROR: ' + err.message);
            console.error(err);
        }
    }

    run() {
        if (!this.isRunning) return;

        // Analyze audio
        const analysis = this.audio.analyze();

        // Update conductor
        this.conductor.update(analysis);

        // Update visuals
        this.visuals.update();

        // Update UI
        document.getElementById('meter-energy').style.width = (OMNI.energy * 100) + '%';
        document.getElementById('val-voices').textContent = OMNI.activeVoices;

        requestAnimationFrame(() => this.run());
    }
}

// ============================================================================
// BOOTSTRAP
// ============================================================================

const app = new OmniApp();

document.getElementById('start-btn').addEventListener('click', async () => {
    await app.start();
});

// Keyboard shortcut
document.addEventListener('keydown', async (e) => {
    if (e.code === 'Space' && !OMNI.isRunning) {
        e.preventDefault();
        await app.start();
    }
});
</script>

</body>
</html>
