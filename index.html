<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP Optimized</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: 'Courier New', monospace;
        }

        .orb {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.5px);
            will-change: transform, box-shadow;
        }

        .orb.pulse {
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
            50% { transform: translate(-50%, -50%) scale(3); box-shadow: 0 0 30px rgba(255,255,255,0.6); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: rec 1s ease-in-out infinite;
        }

        .orb.held {
            background: radial-gradient(circle, rgba(100,255,100,0.8) 0%, rgba(0,255,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
            animation: hold 2s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        @keyframes hold {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); box-shadow: 0 0 40px rgba(0,255,0,0.8); }
        }

        .motion-particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
            filter: blur(0.5px);
            will-change: transform, opacity;
        }

        .controls {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 100;
            font-size: 12px;
            opacity: 0.7;
            user-select: none;
        }

        .control-item {
            margin-bottom: 5px;
            color: rgba(255,255,255,0.8);
        }

        .bassline-viz {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 4px;
            background: rgba(255,255,255,0.1);
            border-radius: 2px;
            overflow: hidden;
        }

        .bassline-bar {
            height: 100%;
            background: linear-gradient(90deg, #ff6b6b, #4ecdc4);
            width: 0%;
            transition: width 0.1s ease;
            will-change: width;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            opacity: 0.5;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="loading" id="loading">Click anywhere to start...</div>
    <div id="orb" class="orb"></div>
    <div class="controls">
        <div class="control-item">SPACE: Record/Stop</div>
        <div class="control-item">H: Hold/Release</div>
        <div class="control-item">B: Toggle Bass Evolution</div>
        <div class="control-item">Samples: <span id="sampleCount">0</span></div>
        <div class="control-item">Evolution: <span id="evolutionStage">Intro</span></div>
        <div class="control-item">BPM: <span id="bpmDisplay">75</span></div>
    </div>
    <div class="bassline-viz">
        <div class="bassline-bar" id="basslineBar"></div>
    </div>

    <script>
        'use strict';

        // Optimized Motion Engine with object pooling
        class MotionEngine {
            constructor() {
                this.particles = [];
                this.audioData = { bass: 0, mid: 0, high: 0 };
                this.bounds = { width: window.innerWidth, height: window.innerHeight };
                this.updateId = null;
                this.lastUpdate = 0;
                this.createParticles(20); // Reduced from 30 for performance
                this.start();
                
                // Handle resize
                window.addEventListener('resize', () => this.handleResize(), { passive: true });
            }

            createParticles(count) {
                const fragment = document.createDocumentFragment();
                
                for (let i = 0; i < count; i++) {
                    const element = document.createElement('div');
                    element.className = 'motion-particle';
                    fragment.appendChild(element);
                    
                    this.particles.push({
                        element,
                        x: Math.random() * this.bounds.width,
                        y: Math.random() * this.bounds.height,
                        vx: (Math.random() - 0.5) * 0.5,
                        vy: (Math.random() - 0.5) * 0.5,
                        originalVx: (Math.random() - 0.5) * 0.5,
                        originalVy: (Math.random() - 0.5) * 0.5,
                        phase: Math.random() * Math.PI * 2,
                        frequency: 0.02 + Math.random() * 0.03,
                        lastSize: 2,
                        lastOpacity: 0.3
                    });
                }
                
                document.body.appendChild(fragment);
            }

            handleResize() {
                this.bounds = { width: window.innerWidth, height: window.innerHeight };
            }

            setAudioData(data) {
                this.audioData = data;
            }

            start() {
                if (this.updateId) return;
                this.update();
            }

            stop() {
                if (this.updateId) {
                    cancelAnimationFrame(this.updateId);
                    this.updateId = null;
                }
            }

            update() {
                const now = performance.now();
                if (now - this.lastUpdate < 16.67) { // Limit to ~60fps
                    this.updateId = requestAnimationFrame(() => this.update());
                    return;
                }
                this.lastUpdate = now;

                const time = now * 0.001;
                const { bass, mid, high } = this.audioData;
                
                for (let i = 0; i < this.particles.length; i++) {
                    const particle = this.particles[i];
                    
                    // Base motion
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    // Audio reactivity - optimized calculations
                    const bassInfluence = bass * 50;
                    const midInfluence = mid * 30;
                    const highInfluence = high * 20;
                    
                    // Audio-reactive movement
                    particle.vx = particle.originalVx + Math.sin(time + particle.phase) * bassInfluence * 0.01;
                    particle.vy = particle.originalVy + Math.cos(time + particle.phase) * midInfluence * 0.01;
                    
                    // Size and opacity - only update if changed significantly
                    const newSize = 2 + highInfluence * 0.1;
                    const newOpacity = Math.min(0.3 + bassInfluence * 0.01, 1);
                    
                    if (Math.abs(newSize - particle.lastSize) > 0.1) {
                        particle.element.style.width = newSize + 'px';
                        particle.element.style.height = newSize + 'px';
                        particle.lastSize = newSize;
                    }
                    
                    if (Math.abs(newOpacity - particle.lastOpacity) > 0.05) {
                        particle.element.style.opacity = newOpacity;
                        particle.lastOpacity = newOpacity;
                    }
                    
                    // Boundary wrapping
                    if (particle.x < 0) particle.x = this.bounds.width;
                    else if (particle.x > this.bounds.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.bounds.height;
                    else if (particle.y > this.bounds.height) particle.y = 0;
                    
                    // Update position with transform for better performance
                    particle.element.style.transform = `translate(${particle.x}px, ${particle.y}px)`;
                }
                
                this.updateId = requestAnimationFrame(() => this.update());
            }

            destroy() {
                this.stop();
                this.particles.forEach(p => p.element.remove());
                this.particles = [];
                window.removeEventListener('resize', this.handleResize);
            }
        }

        // Optimized Beat Matcher
        class BeatMatcher {
            constructor() {
                this.bpm = 75;
                this.quickAnalysis = true;
                this.peakCache = new Map(); // Cache peaks for similar buffers
            }

            findPeaks(buffer, sr) {
                // Check cache first
                const bufferHash = this.hashBuffer(buffer);
                if (this.peakCache.has(bufferHash)) {
                    return this.peakCache.get(bufferHash);
                }

                const data = buffer.getChannelData(0);
                const peaks = [];
                const windowSize = 512;
                const hop = 256;
                
                for (let i = 0; i < data.length - windowSize; i += hop) {
                    let energy = 0;
                    // Unrolled loop for better performance
                    for (let j = 0; j < windowSize; j += 4) {
                        const s1 = data[i + j] || 0;
                        const s2 = data[i + j + 1] || 0;
                        const s3 = data[i + j + 2] || 0;
                        const s4 = data[i + j + 3] || 0;
                        energy += s1 * s1 + s2 * s2 + s3 * s3 + s4 * s4;
                    }
                    energy = Math.sqrt(energy / windowSize);
                    
                    if (peaks.length > 0 && energy > peaks[peaks.length - 1].energy * 1.2 && energy > 0.03) {
                        peaks.push({ time: i / sr, energy, index: i });
                    } else if (peaks.length === 0 && energy > 0.03) {
                        peaks.push({ time: i / sr, energy, index: i });
                    }
                }
                
                // Cache result
                if (this.peakCache.size > 50) {
                    this.peakCache.clear(); // Simple cache cleanup
                }
                this.peakCache.set(bufferHash, peaks);
                
                return peaks;
            }

            hashBuffer(buffer) {
                // Simple hash of buffer for caching
                const data = buffer.getChannelData(0);
                let hash = 0;
                for (let i = 0; i < Math.min(data.length, 1000); i += 100) {
                    hash = ((hash << 5) - hash + data[i] * 1000) | 0;
                }
                return hash;
            }

            matchToGrid(peaks, barLength = 4) {
                if (peaks.length < 2) return 1;
                
                const intervals = peaks.slice(1).map((peak, i) => peak.time - peaks[i].time);
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const beatDuration = 60 / this.bpm;
                
                const divisions = [4, 2, 1, 0.5, 0.25];
                let bestDiv = 1;
                let minDiff = Infinity;
                
                for (const div of divisions) {
                    const targetInterval = beatDuration * div;
                    const diff = Math.abs(avgInterval - targetInterval);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestDiv = div;
                    }
                }
                
                const targetDuration = beatDuration * barLength;
                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                
                return Math.max(0.5, Math.min(2, targetDuration / actualDuration)); // Clamp stretch factor
            }

            chopSample(buffer, peaks, chopsPerBar = 4) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration * 4 / chopsPerBar;
                
                for (let i = 0; i < Math.min(peaks.length - 1, chopsPerBar); i++) {
                    const start = peaks[i].time;
                    const end = Math.min(start + chopLength, buffer.duration);
                    chops.push({ start, end, peak: peaks[i].energy });
                }
                
                return chops;
            }
        }

        // Optimized Bassline Generator with pre-generated buffers
        class BasslineGenerator {
            constructor(ctx) {
                this.ctx = ctx;
                this.progression = [40, 35, 45, 38]; // F, B, A, D
                this.currentNote = 0;
                this.patterns = [
                    [1, 0, 1, 0, 1, 0, 0, 1],
                    [1, 0, 0, 1, 1, 0, 1, 0],
                    [1, 1, 0, 1, 0, 0, 1, 0],
                ];
                this.currentPattern = 0;
                this.bassCache = new Map(); // Cache generated bass sounds
            }

            createBass(freq, duration) {
                const cacheKey = `${freq}_${duration}`;
                if (this.bassCache.has(cacheKey)) {
                    return this.bassCache.get(cacheKey);
                }

                const sampleRate = this.ctx.sampleRate;
                const length = Math.floor(sampleRate * duration);
                const bass = this.ctx.createBuffer(1, length, sampleRate);
                const data = bass.getChannelData(0);
                
                const invSampleRate = 1 / sampleRate;
                
                for (let i = 0; i < length; i++) {
                    const t = i * invSampleRate;
                    const env = t < 0.02 ? t * 50 : Math.exp(-3 * (t - 0.02));
                    const wave = Math.sin(6.283185307179586 * freq * t) + 
                               Math.sin(6.283185307179586 * freq * 2 * t) * 0.3 +
                               Math.sin(6.283185307179586 * freq * 0.5 * t) * 0.2;
                    data[i] = wave * env * 0.6;
                }
                
                // Cache the result
                if (this.bassCache.size > 20) {
                    this.bassCache.clear(); // Simple cleanup
                }
                this.bassCache.set(cacheKey, bass);
                
                return bass;
            }

            getNextNote() {
                const freq = 55 * Math.pow(2, this.progression[this.currentNote] / 12);
                this.currentNote = (this.currentNote + 1) % this.progression.length;
                return freq;
            }

            evolvePattern() {
                this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
            }

            getCurrentPattern() {
                return this.patterns[this.currentPattern];
            }
        }

        // Optimized Lo-fi processor
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
                this.processorCache = new WeakMap(); // Cache processors per source
            }

            process(source) {
                // Check if we already processed this source
                if (this.processorCache.has(source)) {
                    return this.processorCache.get(source);
                }

                // Bitcrusher with reduced buffer size for lower latency
                const bitcrusher = this.ctx.createScriptProcessor(2048, 1, 1);
                const bits = 8;
                const normFreq = 0.3;
                
                let phaser = 0;
                bitcrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    const step = 0.00390625; // Pre-calculated Math.pow(0.5, 8)
                    
                    for (let i = 0; i < input.length; i++) {
                        phaser += normFreq;
                        if (phaser >= 1) {
                            phaser -= 1;
                            output[i] = step * Math.floor(input[i] / step + 0.5);
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };
                
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3000;
                filter.Q.value = 1;
                
                const waveshaper = this.ctx.createWaveShaper();
                const curve = new Float32Array(256);
                for (let i = 0; i < 128; i++) {
                    const x = i / 128;
                    const tanhValue = Math.tanh(x * 2);
                    curve[128 + i] = tanhValue;
                    curve[128 - i - 1] = -tanhValue;
                }
                waveshaper.curve = curve;
                
                source.connect(bitcrusher);
                bitcrusher.connect(filter);
                filter.connect(waveshaper);
                
                // Cache the final node
                this.processorCache.set(source, waveshaper);
                
                return waveshaper;
            }
        }

        // Main Optimized Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.basslineGenerator = null;
                this.motionEngine = null;
                this.recording = false;
                this.held = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.15, last: 0 };
                this.orb = document.getElementById('orb');
                this.loading = document.getElementById('loading');
                this.evolution = {
                    stage: 0,
                    barCount: 0,
                    stageNames: ['Intro', 'Bass Added', 'Complex', 'Full Evolution']
                };
                this.bassEvolution = true;
                this.audioAnalyzer = null;
                this.audioData = { bass: 0, mid: 0, high: 0 };
                this.isInitialized = false;
                this.tickId = null;
                this.analysisId = null;
                
                // Optimized pitch shifts
                this.pitchShifts = [0.5, 0.667, 0.75, 1, 1.5, 2];
                
                // Optimized auto-sampling
                this.quickSampleTimer = null;
                this.lastActivityCheck = 0;
                this.activityThreshold = 5000;
                
                // Event handlers with proper binding
                this.handleClick = this.handleClick.bind(this);
                this.handleKeyDown = this.handleKeyDown.bind(this);
                this.handleVisibilityChange = this.handleVisibilityChange.bind(this);
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                document.addEventListener('click', this.handleClick, { once: true });
                document.addEventListener('keydown', this.handleKeyDown);
                document.addEventListener('visibilitychange', this.handleVisibilityChange);
                
                // Handle page unload
                window.addEventListener('beforeunload', () => this.cleanup());
            }

            handleClick() {
                this.start().catch(console.error);
            }

            handleKeyDown(e) {
                if (!this.isInitialized) return;
                
                switch(e.key) {
                    case ' ':
                        e.preventDefault();
                        this.toggle();
                        break;
                    case 'h':
                    case 'H':
                        this.toggleHold();
                        break;
                    case 'b':
                    case 'B':
                        this.bassEvolution = !this.bassEvolution;
                        console.log('Bass evolution:', this.bassEvolution ? 'ON' : 'OFF');
                        break;
                }
            }

            handleVisibilityChange() {
                if (document.hidden) {
                    this.pauseEngine();
                } else {
                    this.resumeEngine();
                }
            }

            pauseEngine() {
                if (this.motionEngine) this.motionEngine.stop();
                if (this.tickId) {
                    cancelAnimationFrame(this.tickId);
                    this.tickId = null;
                }
                if (this.analysisId) {
                    cancelAnimationFrame(this.analysisId);
                    this.analysisId = null;
                }
            }

            resumeEngine() {
                if (this.isInitialized) {
                    if (this.motionEngine) this.motionEngine.start();
                    this.tick();
                    this.updateAudioAnalysis();
                }
            }

            async start() {
                if (this.ctx) return;
                
                try {
                    this.loading.textContent = 'Initializing audio...';
                    
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({ 
                        sampleRate: 44100,
                        latencyHint: 'interactive'
                    });
                    
                    // Resume context if suspended
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                    
                    this.lofi = new LoFi(this.ctx);
                    this.basslineGenerator = new BasslineGenerator(this.ctx);
                    this.motionEngine = new MotionEngine();
                    
                    this.loading.textContent = 'Setting up audio chain...';
                    await this.setupAudioChain();
                    
                    this.loading.textContent = 'Creating sounds...';
                    await this.createDrums();
                    this.createVinyl();
                    
                    this.loading.textContent = 'Accessing microphone...';
                    await this.setupMicrophone();
                    
                    this.loading.style.display = 'none';
                    
                    // Start everything
                    this.isInitialized = true;
                    this.seq.last = this.ctx.currentTime;
                    this.tick();
                    this.updateAudioAnalysis();
                    this.startQuickSampling();
                    
                    console.log('GUMP Engine initialized successfully');
                    
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.loading.textContent = 'Failed to initialize. Please refresh and try again.';
                    this.loading.style.color = '#ff6b6b';
                }
            }

            async setupAudioChain() {
                // Master chain with optimized order
                this.nodes.out = this.ctx.createGain();
                this.nodes.out.gain.value = 0.8;
                
                this.nodes.vinyl = this.ctx.createBiquadFilter();
                this.nodes.vinyl.type = 'highpass';
                this.nodes.vinyl.frequency.value = 30;
                
                this.nodes.warmth = this.ctx.createBiquadFilter();
                this.nodes.warmth.type = 'lowshelf';
                this.nodes.warmth.frequency.value = 200;
                this.nodes.warmth.gain.value = 2;
                
                this.nodes.comp = this.ctx.createDynamicsCompressor();
                this.nodes.comp.threshold.value = -20;
                this.nodes.comp.knee.value = 10;
                this.nodes.comp.ratio.value = 3;
                this.nodes.comp.attack.value = 0.01;
                this.nodes.comp.release.value = 0.25;
                
                this.nodes.dust = this.ctx.createBiquadFilter();
                this.nodes.dust.type = 'lowpass';
                this.nodes.dust.frequency.value = 8000;
                this.nodes.dust.Q.value = 0.7;
                
                // Connect master chain
                this.nodes.out.connect(this.nodes.vinyl);
                this.nodes.vinyl.connect(this.nodes.warmth);
                this.nodes.warmth.connect(this.nodes.comp);
                this.nodes.comp.connect(this.nodes.dust);
                this.nodes.dust.connect(this.ctx.destination);
                
                // Audio analyzer
                this.audioAnalyzer = this.ctx.createAnalyser();
                this.audioAnalyzer.fftSize = 128; // Smaller for better performance
                this.audioAnalyzer.smoothingTimeConstant = 0.8;
                this.nodes.dust.connect(this.audioAnalyzer);
                
                // Create optimized layers
                const layers = {
                    kick: 0.9,
                    snare: 0.7,
                    hats: 0.3,
                    sample: 0.8,
                    bass: 0.85,
                    bassline: 0.7,
                    vinyl: 0.15
                };
                
                Object.entries(layers).forEach(([name, vol]) => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = vol;
                    this.nodes[name].connect(this.nodes.out);
                    this.samples.set(name, []);
                });
            }

            async setupMicrophone() {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });
                
                this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                this.nodes.rec = this.ctx.createScriptProcessor(2048, 1, 1); // Smaller buffer
                
                // Connect mic to analyzer
                this.nodes.mic.connect(this.audioAnalyzer);
                
                this.nodes.rec.onaudioprocess = e => {
                    if (this.recording) {
                        this.buffer.push(...e.inputBuffer.getChannelData(0));
                        if (this.buffer.length > this.ctx.sampleRate * 6) {
                            this.stopRec();
                        }
                    }
                };
            }

            startQuickSampling() {
                if (this.quickSampleTimer) return;
                
                this.quickSampleTimer = setInterval(() => {
                    if (!this.recording && !this.held && this.ctx && this.audioAnalyzer) {
                        const now = performance.now();
                        if (now - this.lastActivityCheck < 100) return; // Throttle checks
                        this.lastActivityCheck = now;
                        
                        const data = new Uint8Array(this.audioAnalyzer.frequencyBinCount);
                        this.audioAnalyzer.getByteFrequencyData(data);
                        
                        let activity = 0;
                        for (let i = 0; i < data.length; i++) {
                            activity += data[i];
                        }
                        
                        if (activity > this.activityThreshold) {
                            this.toggle();
                            setTimeout(() => {
                                if (this.recording) this.stopRec();
                            }, 1000 + Math.random() * 2000);
                        }
                    }
                }, 500);
            }

            toggleHold() {
                this.held = !this.held;
                this.orb.classList.toggle('held', this.held);
                console.log('HOLD MODE:', this.held ? 'ON' : 'OFF');
            }

            updateAudioAnalysis() {
                if (!this.audioAnalyzer || !this.isInitialized) return;
                
                const data = new Uint8Array(this.audioAnalyzer.frequencyBinCount);
                this.audioAnalyzer.getByteFrequencyData(data);
                
                // Optimized frequency band analysis
                const bassEnd = Math.floor(data.length * 0.1);
                const midEnd = Math.floor(data.length * 0.5);
                
                let bass = 0, mid = 0, high = 0;
                
                // Unrolled loops for better performance
                for (let i = 0; i < bassEnd; i++) bass += data[i];
                for (let i = bassEnd; i < midEnd; i++) mid += data[i];
                for (let i = midEnd; i < data.length; i++) high += data[i];
                
                // Normalize and smooth
                const invBassEnd = 1 / (bassEnd * 255);
                const invMidRange = 1 / ((midEnd - bassEnd) * 255);
                const invHighRange = 1 / ((data.length - midEnd) * 255);
                
                this.audioData.bass = bass * invBassEnd;
                this.audioData.mid = mid * invMidRange;
                this.audioData.high = high * invHighRange;
                
                // Update motion engine
                if (this.motionEngine) {
                    this.motionEngine.setAudioData(this.audioData);
                }
                
                // Update bassline visualization efficiently
                const basslineBar = document.getElementById('basslineBar');
                if (basslineBar) {
                    const width = Math.min(this.audioData.bass * 100, 100);
                    basslineBar.style.width = width + '%';
                }
                
                this.analysisId = requestAnimationFrame(() => this.updateAudioAnalysis());
            }

            evolveMusic() {
                if (this.held) return;
                
                this.evolution.barCount++;
                
                if (this.bassEvolution) {
                    const { stage, barCount } = this.evolution;
                    
                    if (barCount === 8 && stage === 0) {
                        this.evolution.stage = 1;
                        console.log('EVOLUTION: Adding bassline');
                    } else if (barCount === 16 && stage === 1) {
                        this.evolution.stage = 2;
                        this.basslineGenerator.evolvePattern();
                        console.log('EVOLUTION: Complex patterns');
                    } else if (barCount === 24 && stage === 2) {
                        this.evolution.stage = 3;
                        console.log('EVOLUTION: Full arrangement');
                    }
                }
                
                // Update UI efficiently
                const evolutionStage = document.getElementById('evolutionStage');
                if (evolutionStage) {
                    evolutionStage.textContent = this.evolution.stageNames[this.evolution.stage];
                }
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.rec);
                    this.nodes.rec.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                if (!this.recording) return;
                
                this.recording = false;
                try {
                    this.nodes.mic.disconnect(this.nodes.rec);
                    this.nodes.rec.disconnect();
                } catch (e) {
                    console.warn('Disconnect error:', e);
                }
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.3) {
                    this.processSample();
                }
                
                this.buffer = []; // Clear buffer
            }

            processSample() {
                try {
                    const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    buf.getChannelData(0).set(this.buffer);
                    
                    const peaks = this.beatMatcher.findPeaks(buf, this.ctx.sampleRate);
                    const stretch = this.beatMatcher.matchToGrid(peaks);
                    const pitch = this.pitchShifts[Math.floor(Math.random() * this.pitchShifts.length)];
                    const chops = this.beatMatcher.chopSample(buf, peaks);
                    
                    const sample = {
                        buffer: buf,
                        rate: stretch * pitch,
                        chops,
                        pitch
                    };
                    
                    const samples = this.samples.get('sample');
                    if (samples.length >= 3) {
                        samples.shift(); // Remove oldest
                    }
                    samples.push(sample);
                    
                    // Update sample count
                    const sampleCount = document.getElementById('sampleCount');
                    if (sampleCount) {
                        sampleCount.textContent = samples.length;
                    }
                    
                    console.log(`Sample added: ${pitch}x pitch, ${stretch.toFixed(2)}x stretch`);
                } catch (error) {
                    console.error('Sample processing error:', error);
                }
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                const invSr = 1 / sr;
                
                // Optimized drum creation with pre-calculated values
                const kick = this.ctx.createBuffer(1, Math.floor(sr * 0.3), sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i * invSr;
                    const env = Math.exp(-10 * t);
                    const pitch = 60 * Math.exp(-50 * t);
                    let s = Math.sin(6.283185307179586 * pitch * t) * env; // 2*PI pre-calculated
                    s = Math.round(s * 8) * 0.125; // Optimized bit crushing
                    kd[i] = s * 0.9;
                }
                
                const snare = this.ctx.createBuffer(1, Math.floor(sr * 0.15), sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i * invSr;
                    const env = Math.exp(-30 * t);
                    const tone = Math.sin(1256.6370614359173 * t) * 0.3; // 2*PI*200 pre-calculated
                    const noise = (Math.random() * 2 - 1) * 0.6;
                    let s = (tone + noise) * env;
                    s = Math.round(s * 6) / 6;
                    sd[i] = s * 0.8;
                }
                
                const hat = this.ctx.createBuffer(1, Math.floor(sr * 0.05), sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i * invSr;
                    const env = Math.exp(-100 * t);
                    let s = (Math.random() * 2 - 1) * env;
                    if (i > 0) s = s * 0.3 + hd[i-1] * 0.7;
                    hd[i] = s * 0.5;
                }
                
                const bass = this.ctx.createBuffer(1, sr, sr);
                const bd = bass.getChannelData(0);
                for (let i = 0; i < bd.length; i++) {
                    const t = i * invSr;
                    const env = t < 0.02 ? t * 50 : Math.exp(-2 * (t - 0.02));
                    bd[i] = Math.sin(251.32741228718345 * t) * env * 0.8; // 2*PI*40 pre-calculated
                }
                
                // Add to samples
                this.samples.get('kick').push({ buffer: kick, rate: 1 });
                this.samples.get('snare').push({ buffer: snare, rate: 1 });
                this.samples.get('hats').push({ buffer: hat, rate: 1 });
                this.samples.get('bass').push({ buffer: bass, rate: 1 });
            }

            createVinyl() {
                const duration = 10;
                const vinyl = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = vinyl.getChannelData(0);
                const invSampleRate = 1 / this.ctx.sampleRate;
                
                for (let i = 0; i < data.length; i++) {
                    if (Math.random() < 0.0001) {
                        data[i] = (Math.random() - 0.5) * 0.3;
                    } else {
                        data[i] = (Math.random() - 0.5) * 0.02;
                    }
                    data[i] += Math.sin(3.141592653589793 * i * invSampleRate) * 0.01; // PI*i/sr for 0.5Hz
                }
                
                const playVinyl = () => {
                    if (!this.ctx || this.ctx.state === 'closed') return;
                    
                    const source = this.ctx.createBufferSource();
                    source.buffer = vinyl;
                    source.loop = true;
                    source.connect(this.nodes.vinyl);
                    source.start();
                    
                    // Store reference for cleanup
                    this.vinylSource = source;
                };
                
                playVinyl();
            }

            playBassline(step) {
                if (this.evolution.stage < 1 || this.held) return;
                
                const pattern = this.basslineGenerator.getCurrentPattern();
                if (!pattern[step % pattern.length]) return;
                
                try {
                    const freq = this.basslineGenerator.getNextNote();
                    const duration = 60 / this.beatMatcher.bpm / 2;
                    const bassBuffer = this.basslineGenerator.createBass(freq, duration);
                    
                    const src = this.ctx.createBufferSource();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    src.buffer = bassBuffer;
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = 300 + (this.evolution.stage * 200);
                    filter.Q.value = 2;
                    
                    gain.gain.value = 0.7;
                    if (step % 16 === 0 || step % 16 === 10) {
                        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                        gain.gain.exponentialRampToValueAtTime(0.7, this.ctx.currentTime + 0.1);
                    }
                    
                    src.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.nodes.bassline);
                    
                    src.start();
                } catch (error) {
                    console.warn('Bassline play error:', error);
                }
            }

            tick() {
                if (!this.ctx || !this.isInitialized) return;
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.beatMatcher.bpm / 4;
                const swing = this.seq.step % 2 === 1 ? beat * (1 + this.seq.swing) : beat * (1 - this.seq.swing);
                
                if (now >= this.seq.last + swing) {
                    this.seq.last = now;
                    
                    if (!this.held) {
                        this.processStep();
                        this.seq.step = (this.seq.step + 1) % 32;
                    }
                }
                
                this.tickId = requestAnimationFrame(() => this.tick());
            }

            processStep() {
                const step = this.seq.step;
                const stage = this.evolution.stage;
                
                // Pulse on downbeats
                if (step % 4 === 0) {
                    this.orb.classList.add('pulse');
                    setTimeout(() => this.orb.classList.remove('pulse'), 300);
                }
                
                // Optimized pattern matching
                this.playDrumPatterns(step, stage);
                this.playBassline(step);
                this.playSamples(step, stage);
                
                // Evolution check
                if (step === 0) {
                    this.evolveMusic();
                }
            }

            playDrumPatterns(step, stage) {
                // Kick patterns
                if (step === 0 || step === 10) {
                    this.play('kick', 0.9);
                }
                if (stage >= 2 && step === 6) {
                    this.play('kick', 0.6);
                }
                
                // Snare patterns
                if (step === 8 || step === 24) {
                    this.play('snare', 0.7);
                }
                if (stage >= 3 && step === 16) {
                    this.play('snare', 0.4);
                }
                
                // Hi-hat patterns
                const hatSteps = stage >= 2 ? 
                    [2, 6, 10, 12, 14, 18, 22, 26, 30] :
                    [2, 6, 10, 14, 18, 22, 26, 30];
                
                if (hatSteps.includes(step)) {
                    this.play('hats', 0.3 + Math.random() * 0.2);
                }
                
                // Bass hits
                if ([0, 3, 8, 11, 16, 19, 24, 27].includes(step)) {
                    this.play('bass', 0.8);
                }
            }

            playSamples(step, stage) {
                const samples = this.samples.get('sample');
                if (samples.length === 0) return;
                
                let shouldPlay = false;
                let sampleIndex = 0;
                
                if (stage === 0 && step % 16 === 0) {
                    shouldPlay = true;
                    sampleIndex = 0;
                } else if (stage >= 1 && step % 8 === 0) {
                    shouldPlay = true;
                    sampleIndex = Math.floor(Math.random() * samples.length);
                }
                
                if (shouldPlay) {
                    this.playSample(samples[sampleIndex]);
                }
            }

            play(type, vel) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                try {
                    const sample = samples[Math.floor(Math.random() * samples.length)];
                    const src = this.ctx.createBufferSource();
                    const gain = this.ctx.createGain();
                    
                    src.buffer = sample.buffer;
                    src.playbackRate.value = sample.rate || 1;
                    gain.gain.value = vel;
                    
                    const processed = this.lofi.process(src);
                    
                    // Add evolution-based effects
                    if (this.evolution.stage >= 2 && Math.random() < 0.3) {
                        const delay = this.ctx.createDelay(0.1);
                        delay.delayTime.value = 0.02 + Math.random() * 0.03;
                        const delayGain = this.ctx.createGain();
                        delayGain.gain.value = 0.1;
                        
                        processed.connect(delay);
                        delay.connect(delayGain);
                        delayGain.connect(gain);
                    }
                    
                    processed.connect(gain);
                    gain.connect(this.nodes[type]);
                    
                    src.start();
                } catch (error) {
                    console.warn('Play error:', error);
                }
            }

            playSample(sample) {
                if (!sample) return;
                
                try {
                    const src = this.ctx.createBufferSource();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    src.buffer = sample.buffer;
                    src.playbackRate.value = sample.rate;
                    src.loop = true;
                    src.loopStart = 0;
                    src.loopEnd = Math.min(sample.buffer.duration, 60 / this.beatMatcher.bpm * 4);
                    
                    filter.type = 'lowpass';
                    const baseFreq = 2000 + (this.evolution.stage * 500);
                    filter.frequency.value = baseFreq;
                    filter.Q.value = 2;
                    
                    if (this.evolution.stage >= 2) {
                        const sweepTime = 4 + Math.random() * 4;
                        filter.frequency.setValueAtTime(baseFreq, this.ctx.currentTime);
                        filter.frequency.linearRampToValueAtTime(baseFreq + 2000, this.ctx.currentTime + sweepTime / 2);
                        filter.frequency.linearRampToValueAtTime(baseFreq, this.ctx.currentTime + sweepTime);
                    }
                    
                    gain.gain.value = 0.7;
                    
                    const processed = this.lofi.process(src);
                    processed.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.nodes.sample);
                    
                    src.start();
                    
                    // Stop previous sample
                    if (this.currentSample) {
                        try {
                            this.currentSample.stop();
                        } catch (e) {
                            // Sample already stopped
                        }
                    }
                    this.currentSample = src;
                } catch (error) {
                    console.warn('Sample play error:', error);
                }
            }

            cleanup() {
                console.log('Cleaning up GUMP Engine...');
                
                // Clear timers
                if (this.quickSampleTimer) {
                    clearInterval(this.quickSampleTimer);
                    this.quickSampleTimer = null;
                }
                
                // Cancel animation frames
                if (this.tickId) {
                    cancelAnimationFrame(this.tickId);
                    this.tickId = null;
                }
                
                if (this.analysisId) {
                    cancelAnimationFrame(this.analysisId);
                    this.analysisId = null;
                }
                
                // Stop current sample
                if (this.currentSample) {
                    try {
                        this.currentSample.stop();
                    } catch (e) {}
                }
                
                // Stop vinyl
                if (this.vinylSource) {
                    try {
                        this.vinylSource.stop();
                    } catch (e) {}
                }
                
                // Clean up motion engine
                if (this.motionEngine) {
                    this.motionEngine.destroy();
                    this.motionEngine = null;
                }
                
                // Close audio context
                if (this.ctx && this.ctx.state !== 'closed') {
                    this.ctx.close();
                }
                
                // Remove event listeners
                document.removeEventListener('keydown', this.handleKeyDown);
                document.removeEventListener('visibilitychange', this.handleVisibilityChange);
            }
        }

        // Initialize with error handling
        let engine;
        try {
            engine = new Engine();
        } catch (error) {
            console.error('Failed to create engine:', error);
            document.getElementById('loading').textContent = 'Failed to initialize. Please refresh.';
            document.getElementById('loading').style.color = '#ff6b6b';
        }
    </script>
</body>
</html>
