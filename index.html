<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>Real World Sampler</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
}

body {
  background: #000;
  color: #fff;
  overflow: hidden;
  font-family: 'Courier New', monospace;
  height: 100vh;
  width: 100vw;
  position: fixed;
}

.start-screen {
  position: absolute;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: #000;
  z-index: 1000;
  transition: opacity 0.5s;
}

.start-screen.hidden {
  opacity: 0;
  pointer-events: none;
}

.title {
  font-size: 36px;
  margin-bottom: 20px;
  letter-spacing: 4px;
}

.start-btn {
  padding: 20px 50px;
  font-size: 18px;
  background: #fff;
  color: #000;
  border: none;
  cursor: pointer;
  font-family: 'Courier New', monospace;
  letter-spacing: 2px;
}

.interface {
  opacity: 0;
  transition: opacity 1s;
  width: 100%;
  height: 100%;
  position: relative;
}

.interface.active {
  opacity: 1;
}

.waveform {
  position: absolute;
  top: 50%;
  left: 0;
  transform: translateY(-50%);
  width: 100%;
  height: 200px;
  display: flex;
  align-items: center;
  justify-content: center;
}

canvas {
  width: 100%;
  height: 100%;
}

.status {
  position: absolute;
  top: 20px;
  left: 20px;
  font-size: 14px;
  opacity: 0.7;
}

.samples {
  position: absolute;
  top: 20px;
  right: 20px;
  text-align: right;
  font-size: 12px;
  opacity: 0.7;
}

.sample-item {
  margin: 5px 0;
  padding: 5px 10px;
  background: rgba(255,255,255,0.1);
  border-radius: 3px;
}

.sample-item.active {
  background: rgba(255,255,255,0.3);
  animation: flashSample 0.5s;
}

@keyframes flashSample {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

.info {
  position: absolute;
  bottom: 20px;
  left: 20px;
  font-size: 11px;
  opacity: 0.5;
  max-width: 300px;
}

.recording {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border: 3px solid red;
  border-radius: 50%;
  opacity: 0;
  pointer-events: none;
  animation: recordPulse 1s infinite;
}

.recording.active {
  opacity: 1;
}

@keyframes recordPulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; }
  50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.3; }
}
</style>
</head>
<body>
<div class="start-screen" id="startScreen">
  <h1 class="title">REAL WORLD SAMPLER</h1>
  <button class="start-btn" id="startBtn">START</button>
</div>

<div class="interface" id="interface">
  <div class="status">
    <div>LISTENING: <span id="listening">NO</span></div>
    <div>MOTION: <span id="motion">0.0</span></div>
    <div>TILT: <span id="tilt">0°</span></div>
    <div>SAMPLES: <span id="sampleCount">0</span></div>
  </div>

  <div class="samples" id="samples"></div>

  <div class="waveform">
    <canvas id="canvas"></canvas>
  </div>

  <div class="info">
    Move your phone to change playback • Real sounds from your environment being processed in real-time
  </div>

  <div class="recording" id="recording"></div>
</div>

<script>
'use strict';

class RealSampler {
  constructor() {
    this.audioCtx = null;
    this.micStream = null;
    this.micSource = null;
    this.recorder = null;
    this.scriptProcessor = null;
    
    // Sample storage
    this.samples = [];
    this.maxSamples = 8;
    this.recordingBuffer = [];
    this.isRecording = false;
    this.recordingStartTime = 0;
    this.sampleDuration = 0.5; // seconds
    this.lastSampleTime = 0;
    
    // Playback
    this.playingSources = [];
    this.masterGain = null;
    this.convolver = null;
    this.delay = null;
    this.filter = null;
    
    // Environment
    this.motion = 0;
    this.tilt = 0;
    this.orientation = { alpha: 0, beta: 0, gamma: 0 };
    
    // Visual
    this.canvas = null;
    this.ctx2d = null;
    this.analyser = null;
    this.freqData = null;
    
    this.active = false;
    
    this.init();
  }
  
  init() {
    document.getElementById('startBtn').onclick = () => this.start();
    
    this.canvas = document.getElementById('canvas');
    this.ctx2d = this.canvas.getContext('2d');
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());
    
    this.setupSensors();
  }
  
  resizeCanvas() {
    this.canvas.width = this.canvas.clientWidth;
    this.canvas.height = this.canvas.clientHeight;
  }
  
  setupSensors() {
    window.addEventListener('devicemotion', (e) => {
      if (!this.active) return;
      const acc = e.accelerationIncludingGravity || e.acceleration;
      if (acc && acc.x !== null) {
        const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
        this.motion = this.motion * 0.7 + mag * 0.3;
      }
    });
    
    window.addEventListener('deviceorientation', (e) => {
      if (!this.active || e.beta === null) return;
      this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
      this.tilt = Math.abs(e.beta);
      this.updateEffects();
    });
  }
  
  async start() {
    try {
      if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        await DeviceMotionEvent.requestPermission();
      }
      if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        await DeviceOrientationEvent.requestPermission();
      }
      
      this.audioCtx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: 44100
      });
      await this.audioCtx.resume();
      
      // Setup audio chain
      this.setupAudio();
      
      // Request microphone
      this.micStream = await navigator.mediaDevices.getUserMedia({ 
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: 44100
        } 
      });
      
      this.micSource = this.audioCtx.createMediaStreamSource(this.micStream);
      
      // Create script processor for recording
      this.scriptProcessor = this.audioCtx.createScriptProcessor(4096, 1, 1);
      this.micSource.connect(this.scriptProcessor);
      // DON'T connect to destination - just capture data
      
      this.scriptProcessor.onaudioprocess = (e) => {
        if (!this.isRecording) return;
        
        const input = e.inputBuffer.getChannelData(0);
        this.recordingBuffer.push(new Float32Array(input));
        
        const elapsed = (Date.now() - this.recordingStartTime) / 1000;
        if (elapsed >= this.sampleDuration) {
          this.finishSample();
        }
      };
      
      // Setup analyzer
      this.analyser = this.audioCtx.createAnalyser();
      this.analyser.fftSize = 2048;
      this.freqData = new Uint8Array(this.analyser.frequencyBinCount);
      this.micSource.connect(this.analyser);
      
      document.getElementById('startScreen').classList.add('hidden');
      setTimeout(() => {
        document.getElementById('interface').classList.add('active');
      }, 500);
      
      this.active = true;
      document.getElementById('listening').textContent = 'YES';
      
      this.animate();
      this.startSampling();
      
      console.log('Real Sampler Active');
      
    } catch (error) {
      console.error('Start failed:', error);
      alert('Microphone access required');
    }
  }
  
  setupAudio() {
    // Master gain
    this.masterGain = this.audioCtx.createGain();
    this.masterGain.gain.value = 0.8;
    
    // Filter
    this.filter = this.audioCtx.createBiquadFilter();
    this.filter.type = 'lowpass';
    this.filter.frequency.value = 5000;
    this.filter.Q.value = 1;
    
    // Delay
    this.delay = this.audioCtx.createDelay(2);
    this.delay.delayTime.value = 0.25;
    const delayFeedback = this.audioCtx.createGain();
    delayFeedback.gain.value = 0.4;
    const delayMix = this.audioCtx.createGain();
    delayMix.gain.value = 0.3;
    
    this.delay.connect(delayFeedback);
    delayFeedback.connect(this.delay);
    this.delay.connect(delayMix);
    delayMix.connect(this.audioCtx.destination);
    
    // Reverb
    this.convolver = this.audioCtx.createConvolver();
    this.convolver.buffer = this.createReverbImpulse(2, 2);
    const reverbMix = this.audioCtx.createGain();
    reverbMix.gain.value = 0.4;
    this.convolver.connect(reverbMix);
    reverbMix.connect(this.audioCtx.destination);
    
    // Connect chain
    this.filter.connect(this.masterGain);
    this.masterGain.connect(this.audioCtx.destination);
    this.masterGain.connect(this.delay);
    this.masterGain.connect(this.convolver);
  }
  
  createReverbImpulse(duration, decay) {
    const length = this.audioCtx.sampleRate * duration;
    const impulse = this.audioCtx.createBuffer(2, length, this.audioCtx.sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const data = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
      }
    }
    
    return impulse;
  }
  
  startSampling() {
    // Auto-record samples
    setInterval(() => {
      if (!this.isRecording && this.samples.length < this.maxSamples) {
        const now = Date.now();
        if (now - this.lastSampleTime > 3000) {
          this.startRecording();
        }
      }
    }, 500);
    
    // Auto-play samples frequently
    setInterval(() => {
      if (this.samples.length > 0) {
        this.playSample();
      }
    }, 800);
  }
  
  startRecording() {
    this.isRecording = true;
    this.recordingBuffer = [];
    this.recordingStartTime = Date.now();
    document.getElementById('recording').classList.add('active');
    console.log('Recording started...');
  }
  
  finishSample() {
    this.isRecording = false;
    this.lastSampleTime = Date.now();
    document.getElementById('recording').classList.remove('active');
    
    if (this.recordingBuffer.length === 0) return;
    
    // Calculate total length
    const totalLength = this.recordingBuffer.reduce((sum, buf) => sum + buf.length, 0);
    
    // Create audio buffer
    const audioBuffer = this.audioCtx.createBuffer(1, totalLength, this.audioCtx.sampleRate);
    const channelData = audioBuffer.getChannelData(0);
    
    // Copy data
    let offset = 0;
    for (const buf of this.recordingBuffer) {
      channelData.set(buf, offset);
      offset += buf.length;
    }
    
    // Calculate RMS to check if sample has content
    let sum = 0;
    for (let i = 0; i < channelData.length; i++) {
      sum += channelData[i] * channelData[i];
    }
    const rms = Math.sqrt(sum / channelData.length);
    
    if (rms > 0.01) { // Only save if there's actual audio
      this.samples.push({
        buffer: audioBuffer,
        timestamp: Date.now(),
        rms: rms
      });
      
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      
      this.updateSampleList();
      console.log('Sample captured, RMS:', rms.toFixed(4), 'Duration:', audioBuffer.duration.toFixed(2));
      
      // Play it immediately so you hear what was captured
      setTimeout(() => this.playSample(), 100);
    } else {
      console.log('Sample too quiet, RMS:', rms.toFixed(4));
    }
    
    this.recordingBuffer = [];
  }
  
  playSample() {
    if (this.samples.length === 0) return;
    
    const sample = this.samples[Math.floor(Math.random() * this.samples.length)];
    
    const source = this.audioCtx.createBufferSource();
    source.buffer = sample.buffer;
    
    // Random playback rate based on motion
    const rateVariation = 1 + (Math.random() - 0.5) * (this.motion / 20);
    source.playbackRate.value = Math.max(0.5, Math.min(2, rateVariation));
    
    // Gain - boost it significantly
    const gain = this.audioCtx.createGain();
    gain.gain.value = Math.min(2.5, (sample.rms * 50) + 0.5); // Much louder
    
    source.connect(gain);
    gain.connect(this.filter);
    
    const now = this.audioCtx.currentTime;
    source.start(now);
    
    console.log('Playing sample, rate:', source.playbackRate.value.toFixed(2), 'gain:', gain.gain.value.toFixed(2));
    
    this.playingSources.push({ source, gain, startTime: Date.now() });
    
    source.onended = () => {
      this.playingSources = this.playingSources.filter(s => s.source !== source);
    };
    
    // Flash UI
    const items = document.querySelectorAll('.sample-item');
    if (items.length > 0) {
      const randomItem = items[Math.floor(Math.random() * items.length)];
      randomItem.classList.add('active');
      setTimeout(() => randomItem.classList.remove('active'), 500);
    }
  }
  
  updateEffects() {
    // Filter frequency controlled by tilt
    const freq = 500 + (this.tilt / 90) * 4500;
    this.filter.frequency.linearRampToValueAtTime(freq, this.audioCtx.currentTime + 0.1);
    
    // Delay time controlled by orientation
    const delayTime = 0.1 + (Math.abs(this.orientation.gamma) / 90) * 0.4;
    this.delay.delayTime.linearRampToValueAtTime(delayTime, this.audioCtx.currentTime + 0.1);
  }
  
  updateSampleList() {
    const container = document.getElementById('samples');
    container.innerHTML = '';
    
    this.samples.forEach((sample, i) => {
      const div = document.createElement('div');
      div.className = 'sample-item';
      div.textContent = `SAMPLE ${i + 1} [${(sample.buffer.duration * 1000).toFixed(0)}ms]`;
      container.appendChild(div);
    });
    
    document.getElementById('sampleCount').textContent = this.samples.length;
  }
  
  animate() {
    const render = () => {
      if (!this.active) return;
      
      // Update UI
      document.getElementById('motion').textContent = this.motion.toFixed(1);
      document.getElementById('tilt').textContent = Math.round(this.tilt) + '°';
      
      // Draw waveform
      if (this.analyser) {
        const timeData = new Uint8Array(this.analyser.fftSize);
        this.analyser.getByteTimeDomainData(timeData);
        
        const width = this.canvas.width;
        const height = this.canvas.height;
        
        this.ctx2d.fillStyle = '#000';
        this.ctx2d.fillRect(0, 0, width, height);
        
        this.ctx2d.lineWidth = 2;
        this.ctx2d.strokeStyle = '#fff';
        this.ctx2d.beginPath();
        
        const sliceWidth = width / timeData.length;
        let x = 0;
        
        for (let i = 0; i < timeData.length; i++) {
          const v = timeData[i] / 128.0;
          const y = v * height / 2;
          
          if (i === 0) {
            this.ctx2d.moveTo(x, y);
          } else {
            this.ctx2d.lineTo(x, y);
          }
          
          x += sliceWidth;
        }
        
        this.ctx2d.stroke();
      }
      
      requestAnimationFrame(render);
    };
    
    requestAnimationFrame(render);
  }
}

const sampler = new RealSampler();
</script>
</body>
</html>
