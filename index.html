<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        #orb {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,1), rgba(255,255,255,0.2));
            box-shadow: 0 0 120px rgba(255,255,255,0.8), 
                        0 0 60px rgba(255,255,255,0.6),
                        inset -10px -10px 20px rgba(0,0,0,0.3);
            transition: all 0.15s ease-out;
            z-index: 1000;
            pointer-events: none;
        }

        #orb.recording {
            background: radial-gradient(circle at 30% 30%, #ff0000, #660000);
            box-shadow: 0 0 150px #ff0000, 
                        0 0 80px #ff0000,
                        inset -10px -10px 20px rgba(0,0,0,0.5);
            transform: scale(1.2);
        }

        #orb.beat {
            transform: scale(1.3);
            box-shadow: 0 0 200px rgba(255,255,255,1), 
                        0 0 100px rgba(255,255,255,0.8);
        }

        #orb.god-mode {
            background: radial-gradient(circle at 30% 30%, #ff00ff, #00ffff);
            animation: godPulse 2s ease-in-out infinite;
        }

        @keyframes godPulse {
            0%, 100% { transform: scale(1); filter: hue-rotate(0deg); }
            50% { transform: scale(1.5); filter: hue-rotate(180deg); }
        }

        .status {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
            text-transform: uppercase;
        }

        .status.visible {
            opacity: 0.7;
        }

        .hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 2s;
            text-transform: uppercase;
        }

        .hint.visible {
            opacity: 0.5;
        }

        .producer-status {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
            text-transform: uppercase;
            color: #ff00ff;
        }

        .producer-status.visible {
            opacity: 0.6;
        }

        .visualizer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s;
        }

        .visualizer.active {
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <canvas id="visualizer" class="visualizer"></canvas>
    <div id="orb"></div>
    <div id="status" class="status"></div>
    <div id="producer-status" class="producer-status"></div>
    <div id="hint" class="hint">Click anywhere to begin</div>

    <script>
        'use strict';

        // The beat machine that actually slaps
        class GUMP {
            constructor() {
                this.ctx = null;
                this.isInitialized = false;
                this.isRecording = false;
                this.recordBuffer = [];
                this.samples = new Map();
                this.loops = [];
                
                // Tempo and swing
                this.bpm = 72;
                this.swing = 0.15;
                this.currentStep = 0;
                this.barCount = 0;
                
                // Visual elements
                this.orb = document.getElementById('orb');
                this.status = document.getElementById('status');
                this.producerStatus = document.getElementById('producer-status');
                this.hint = document.getElementById('hint');
                
                // Producer AI state
                this.producer = {
                    energy: 0,
                    complexity: 0,
                    evolution: 0,
                    mood: 'building',
                    godMode: false,
                    decisions: []
                };
                
                // Track mouse
                document.addEventListener('mousemove', (e) => {
                    this.orb.style.left = e.clientX + 'px';
                    this.orb.style.top = e.clientY + 'px';
                });
                
                // Init on click
                document.addEventListener('click', () => this.init());
                
                // Show hint
                setTimeout(() => this.hint.classList.add('visible'), 500);
            }

            async init() {
                if (this.isInitialized) {
                    this.toggleRecording();
                    return;
                }

                try {
                    // Create audio context with optimal settings
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });

                    // Build the signal chain
                    this.buildMasterChain();
                    
                    // Create drum sounds
                    this.createDrumKit();
                    
                    // Setup microphone
                    await this.setupMicrophone();
                    
                    // Initialize visualizer
                    this.initVisualizer();
                    
                    // Create the intro sequence
                    this.scheduleIntro();
                    
                    // Setup keyboard controls
                    this.setupControls();
                    
                    // Start the producer AI
                    this.startProducerAI();
                    
                    this.isInitialized = true;
                    this.hint.textContent = 'Space to sample • G for god mode • Hold space to clear';
                    
                    console.log('GUMP initialized - let\'s make beats');

                } catch (err) {
                    console.error('Failed to initialize:', err);
                    this.status.textContent = 'Failed to initialize';
                    this.status.classList.add('visible');
                }
            }

            buildMasterChain() {
                // Master gain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.95;

                // Bus compressor for glue
                this.busComp = this.ctx.createDynamicsCompressor();
                this.busComp.threshold.value = -8;
                this.busComp.knee.value = 3;
                this.busComp.ratio.value = 4;
                this.busComp.attack.value = 0.01;
                this.busComp.release.value = 0.1;

                // Warmth - low shelf EQ
                this.warmth = this.ctx.createBiquadFilter();
                this.warmth.type = 'lowshelf';
                this.warmth.frequency.value = 150;
                this.warmth.gain.value = 4;

                // Presence - high shelf EQ
                this.presence = this.ctx.createBiquadFilter();
                this.presence.type = 'highshelf';
                this.presence.frequency.value = 8000;
                this.presence.gain.value = 3;

                // Soft clipper using waveshaper
                this.clipper = this.ctx.createWaveShaper();
                this.clipper.curve = this.makeSoftClipCurve();
                this.clipper.oversample = '2x';

                // Final limiter
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -1;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                // Connect the chain
                this.master.connect(this.busComp);
                this.busComp.connect(this.warmth);
                this.warmth.connect(this.presence);
                this.presence.connect(this.clipper);
                this.clipper.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);

                // Create separate buses with effects
                this.drumBus = this.ctx.createGain();
                this.drumBus.gain.value = 1;
                
                // Drum effects chain
                this.drumReverb = this.createReverb(0.3);
                this.drumDelay = this.createDelay(0.375, 0.3);
                this.drumFilter = this.ctx.createBiquadFilter();
                this.drumFilter.frequency.value = 20000;
                
                this.drumBus.connect(this.drumFilter);
                this.drumFilter.connect(this.master);
                
                // Parallel drum effects
                this.drumBus.connect(this.drumReverb.input);
                this.drumReverb.output.connect(this.master);
                this.drumBus.connect(this.drumDelay.input);
                this.drumDelay.output.connect(this.master);

                // Sample bus with heavy processing
                this.sampleBus = this.ctx.createGain();
                this.sampleBus.gain.value = 0.8;
                
                // Sample effects
                this.sampleReverb = this.createReverb(0.7);
                this.sampleDelay = this.createDelay(0.5, 0.5);
                this.sampleDistortion = this.ctx.createWaveShaper();
                this.sampleDistortion.curve = this.makeDistortionCurve(50);
                this.sampleFilter = this.ctx.createBiquadFilter();
                this.sampleFilter.frequency.value = 5000;
                
                // Sample routing
                this.sampleBus.connect(this.sampleFilter);
                this.sampleFilter.connect(this.sampleDistortion);
                this.sampleDistortion.connect(this.master);
                
                // Parallel sample effects
                this.sampleBus.connect(this.sampleReverb.input);
                this.sampleReverb.output.connect(this.master);
                this.sampleBus.connect(this.sampleDelay.input);
                this.sampleDelay.output.connect(this.master);

                // Analyzer for visualizer
                this.analyzer = this.ctx.createAnalyser();
                this.analyzer.fftSize = 2048;
                this.limiter.connect(this.analyzer);
            }

            createReverb(wetness) {
                const convolver = this.ctx.createConvolver();
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                convolver.buffer = impulse;
                
                const input = this.ctx.createGain();
                const wet = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                wet.gain.value = wetness;
                
                input.connect(convolver);
                convolver.connect(wet);
                wet.connect(output);
                
                return { input, output };
            }

            createDelay(time, feedback) {
                const delay = this.ctx.createDelay(2);
                const feedbackGain = this.ctx.createGain();
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                const wetGain = this.ctx.createGain();
                
                delay.delayTime.value = time;
                feedbackGain.gain.value = feedback;
                wetGain.gain.value = 0.3;
                
                input.connect(delay);
                delay.connect(feedbackGain);
                feedbackGain.connect(delay);
                delay.connect(wetGain);
                wetGain.connect(output);
                
                return { input, output };
            }

            makeSoftClipCurve() {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    curve[i] = Math.sign(x) * Math.min(Math.abs(x), 0.9 + 0.1 * Math.tanh(10 * (Math.abs(x) - 0.9)));
                }
                
                return curve;
            }

            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    curve[i] = Math.tanh(x * amount) * 0.7;
                }
                
                return curve;
            }

            createDrumKit() {
                this.drums = {
                    kick: this.synthesizeKick(),
                    snare: this.synthesizeSnare(),
                    hihat: this.synthesizeHihat(),
                    openhat: this.synthesizeOpenHat(),
                    clap: this.synthesizeClap(),
                    perc: this.synthesizePerc()
                };
            }

            synthesizeKick() {
                const duration = 0.8;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Pitch envelope: starts at 120Hz, drops to 45Hz
                    const pitch = 120 * Math.exp(-35 * t) + 45;
                    
                    // Amplitude envelope with punch
                    const amp = Math.exp(-3 * t) * (1 - 0.5 * t);
                    
                    // Main tone
                    let sample = Math.sin(2 * Math.PI * pitch * t) * amp;
                    
                    // Add click for punch (first 5ms)
                    if (t < 0.005) {
                        sample += Math.sin(2 * Math.PI * 4000 * t) * (1 - t * 200) * 0.3;
                    }
                    
                    // Add harmonics for beef
                    sample += Math.sin(4 * Math.PI * pitch * t) * amp * 0.15;
                    
                    // Soft clip
                    data[i] = Math.tanh(sample * 1.5) * 0.9;
                }
                
                return buffer;
            }

            synthesizeSnare() {
                const duration = 0.25;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Layer 1: Pitched tone (body)
                const toneFreq1 = 200;
                const toneFreq2 = 340;
                
                // Layer 2: Noise burst
                let previousNoise = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Envelopes
                    const toneEnv = Math.exp(-20 * t) * (1 - t * 2);
                    const noiseEnv = Math.exp(-30 * t);
                    const clickEnv = t < 0.003 ? (1 - t * 333) : 0;
                    
                    // Tone component - two detuned sine waves
                    const tone1 = Math.sin(2 * Math.PI * toneFreq1 * t);
                    const tone2 = Math.sin(2 * Math.PI * toneFreq2 * t);
                    const toneComponent = (tone1 + tone2 * 0.8) * toneEnv * 0.4;
                    
                    // Noise component with high-pass filtering
                    const whiteNoise = Math.random() * 2 - 1;
                    const highpassedNoise = whiteNoise - previousNoise * 0.95;
                    previousNoise = whiteNoise;
                    const noiseComponent = highpassedNoise * noiseEnv * 0.6;
                    
                    // Click/attack transient
                    const click = Math.sin(2 * Math.PI * 3500 * t + Math.sin(8000 * t)) * clickEnv * 0.5;
                    
                    // Mix all components
                    let sample = toneComponent + noiseComponent + click;
                    
                    // Add subtle ring modulation for character
                    sample *= (1 + 0.3 * Math.sin(2 * Math.PI * 1700 * t));
                    
                    // Soft saturation
                    data[i] = Math.tanh(sample * 1.2) * 0.85;
                }
                
                return buffer;
            }

            synthesizeHihat() {
                const duration = 0.05;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-200 * t);
                    
                    // High-passed noise
                    let sample = (Math.random() * 2 - 1);
                    
                    // Simple high-pass filter simulation
                    if (i > 0) {
                        sample = sample - data[i - 1] * 0.95;
                    }
                    
                    data[i] = sample * env * 0.8;
                }
                
                return buffer;
            }

            synthesizeOpenHat() {
                const duration = 0.3;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-6 * t);
                    
                    // Metallic noise
                    let sample = (Math.random() * 2 - 1);
                    
                    // Add some ringing
                    sample += Math.sin(2 * Math.PI * 5000 * t) * 0.1;
                    sample += Math.sin(2 * Math.PI * 7500 * t) * 0.05;
                    
                    // High-pass
                    if (i > 0) {
                        sample = sample - data[i - 1] * 0.9;
                    }
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeClap() {
                const duration = 0.15;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Multiple short bursts to simulate clap
                const clapTimes = [0, 0.01, 0.025];
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    let sample = 0;
                    
                    for (const clapTime of clapTimes) {
                        if (t >= clapTime && t < clapTime + 0.02) {
                            const localT = t - clapTime;
                            const env = Math.exp(-100 * localT);
                            sample += (Math.random() * 2 - 1) * env;
                        }
                    }
                    
                    data[i] = sample * 0.7;
                }
                
                return buffer;
            }

            synthesizePerc() {
                const duration = 0.1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-50 * t);
                    
                    // Wood block sound
                    const freq = 800 + Math.sin(2 * Math.PI * 20 * t) * 200;
                    let sample = Math.sin(2 * Math.PI * freq * t);
                    
                    // Add click
                    if (t < 0.002) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 500);
                    }
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            async setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.micSource = this.ctx.createMediaStreamSource(stream);
                    
                    // Create a script processor for recording
                    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.recorder.onaudioprocess = (e) => {
                        if (this.isRecording) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            this.recordBuffer.push(...inputData);
                            
                            // Auto-stop after 8 seconds
                            if (this.recordBuffer.length > this.ctx.sampleRate * 8) {
                                this.stopRecording();
                            }
                        }
                    };
                    
                } catch (err) {
                    console.log('Microphone not available');
                    this.hint.textContent = 'Click to play';
                }
            }

            initVisualizer() {
                const canvas = document.getElementById('visualizer');
                const ctx = canvas.getContext('2d');
                
                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resize();
                window.addEventListener('resize', resize);
                
                this.visualizerCtx = ctx;
                this.visualizerCanvas = canvas;
            }

            animateVisualizer() {
                if (!this.analyzer || this.producer.energy < 0.3) return;
                
                const canvas = this.visualizerCanvas;
                const ctx = this.visualizerCtx;
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    if (this.producer.energy < 0.3) {
                        canvas.classList.remove('active');
                        return;
                    }
                    
                    canvas.classList.add('active');
                    requestAnimationFrame(draw);
                    
                    this.analyzer.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = canvas.width / bufferLength * 2.5;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = dataArray[i] * canvas.height / 255 * this.producer.energy;
                        
                        const hue = i / bufferLength * 360 + this.ctx.currentTime * 50;
                        ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${0.5 + this.producer.complexity * 0.5})`;
                        
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        x += barWidth + 1;
                    }
                };
                
                draw();
            }

            scheduleIntro() {
                const startTime = this.ctx.currentTime + 0.1;
                const beat = 60 / this.bpm;
                
                // Epic 8-bar intro that builds
                const intro = [
                    // Bar 1 - Sparse kick
                    { time: 0, sound: 'kick', vel: 0.6 },
                    { time: beat * 2, sound: 'kick', vel: 0.4 },
                    
                    // Bar 2 - Add ghost kicks
                    { time: beat * 4, sound: 'kick', vel: 0.8 },
                    { time: beat * 5.5, sound: 'kick', vel: 0.3 },
                    { time: beat * 6, sound: 'kick', vel: 0.5 },
                    
                    // Bar 3 - Introduce hats
                    { time: beat * 8, sound: 'kick', vel: 0.9 },
                    { time: beat * 8.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 9, sound: 'hihat', vel: 0.4 },
                    { time: beat * 9.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 10, sound: 'kick', vel: 0.5 },
                    { time: beat * 10.5, sound: 'hihat', vel: 0.4 },
                    
                    // Bar 4 - Build tension
                    { time: beat * 12, sound: 'kick', vel: 1 },
                    { time: beat * 12.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 13, sound: 'snare', vel: 0.6 },
                    { time: beat * 13.5, sound: 'hihat', vel: 0.4 },
                    { time: beat * 14, sound: 'kick', vel: 0.7 },
                    { time: beat * 14.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 15, sound: 'snare', vel: 0.5 },
                    { time: beat * 15.5, sound: 'snare', vel: 0.4 },
                ];
                
                // Schedule intro hits
                intro.forEach(hit => {
                    this.scheduleSound(hit.sound, startTime + hit.time, hit.vel);
                });
                
                // Start main loop after intro
                setTimeout(() => {
                    this.startMainLoop();
                }, beat * 16 * 1000);
            }

            scheduleSound(sound, time, velocity = 1, bus = null) {
                const source = this.ctx.createBufferSource();
                const gainNode = this.ctx.createGain();
                
                source.buffer = this.drums[sound];
                
                // Producer AI can modify velocity
                const producerMultiplier = this.producer.godMode ? 
                    1 + Math.random() * 0.5 : 1;
                
                gainNode.gain.value = velocity * producerMultiplier;
                
                // Add slight pitch variation for life
                source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.02;
                
                // Producer can add extra effects
                if (this.producer.complexity > 0.7 && Math.random() < 0.3) {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = Math.random() > 0.5 ? 'highpass' : 'lowpass';
                    filter.frequency.value = 200 + Math.random() * 5000;
                    filter.Q.value = 1 + Math.random() * 10;
                    
                    source.connect(filter);
                    filter.connect(gainNode);
                } else {
                    source.connect(gainNode);
                }
                
                gainNode.connect(bus || this.drumBus);
                
                source.start(time);
                
                // Visual feedback
                const delay = (time - this.ctx.currentTime) * 1000;
                if (delay >= 0 && delay < 100) {
                    setTimeout(() => {
                        this.orb.classList.add('beat');
                        setTimeout(() => this.orb.classList.remove('beat'), 50);
                    }, delay);
                }
            }

            startMainLoop() {
                const beat = 60 / this.bpm;
                const sixteenth = beat / 4;
                let nextTime = this.ctx.currentTime;
                
                // Main pattern - that bounce
                const pattern = {
                    kick: [0, 10, 20, 22],
                    snare: [8, 24],
                    hihat: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
                    openhat: [14, 30],
                    clap: [8, 24],
                    perc: [5, 13, 21, 29]
                };
                
                const loop = () => {
                    const currentTime = this.ctx.currentTime;
                    
                    // Schedule ahead
                    while (nextTime < currentTime + 0.1) {
                        const step = this.currentStep % 32;
                        
                        // Track bars for producer AI
                        if (step === 0) {
                            this.barCount++;
                            this.updateProducerState();
                        }
                        
                        // Apply swing to off-beats
                        let swingOffset = 0;
                        if (step % 2 === 1) {
                            swingOffset = sixteenth * this.swing;
                        }
                        
                        // Schedule hits based on producer decisions
                        Object.entries(pattern).forEach(([sound, steps]) => {
                            if (steps.includes(step)) {
                                // Producer can mute/modify sounds
                                if (this.shouldPlaySound(sound, step)) {
                                    let velocity = this.getProducerVelocity(sound, step);
                                    this.scheduleSound(sound, nextTime + swingOffset, velocity);
                                }
                            }
                        });
                        
                        // Producer can add ghost notes
                        if (this.producer.complexity > 0.5 && Math.random() < this.producer.complexity * 0.1) {
                            const ghostSound = ['kick', 'snare', 'hihat'][Math.floor(Math.random() * 3)];
                            this.scheduleSound(ghostSound, nextTime + swingOffset + Math.random() * sixteenth * 0.5, 0.2);
                        }
                        
                        // Trigger samples
                        if (step === 0 && this.loops.length > 0) {
                            this.triggerSampleLoop(nextTime);
                        }
                        
                        this.currentStep++;
                        nextTime += sixteenth;
                    }
                    
                    requestAnimationFrame(loop);
                };
                
                loop();
            }

            shouldPlaySound(sound, step) {
                // Producer AI decisions on what to play
                if (this.producer.godMode) {
                    // In god mode, anything can happen
                    if (Math.random() < 0.05) return false; // Random dropouts
                    if (Math.random() < 0.02) return true; // Force play even off-pattern
                }
                
                // Energy-based decisions
                if (this.producer.energy < 0.3) {
                    // Low energy - strip back to essentials
                    if (sound === 'hihat' && Math.random() < 0.5) return false;
                    if (sound === 'perc') return false;
                }
                
                // Complexity-based decisions
                if (this.producer.complexity < 0.3) {
                    // Simple mode - remove embellishments
                    if (sound === 'openhat' && step !== 14) return false;
                    if (sound === 'clap' && step === 24) return false;
                }
                
                return true;
            }

            getProducerVelocity(sound, step) {
                let velocity = 0.8;
                
                // Basic velocity variations
                if (sound === 'hihat') {
                    velocity = step % 4 === 0 ? 0.6 : 0.4;
                } else if (sound === 'kick' && step === 0) {
                    velocity = 1;
                }
                
                // Producer modifications
                velocity *= (0.7 + this.producer.energy * 0.3);
                
                // God mode chaos
                if (this.producer.godMode) {
                    velocity *= (0.5 + Math.random() * 1);
                }
                
                return Math.min(velocity, 1);
            }

            startProducerAI() {
                // Producer AI that evolves the track
                setInterval(() => {
                    if (!this.isInitialized) return;
                    
                    // Analyze current state
                    const hasLoops = this.loops.length > 0;
                    const loopCount = this.loops.length;
                    const timeElapsed = this.barCount * 4 * 60 / this.bpm;
                    
                    // Update evolution
                    this.producer.evolution = Math.min(timeElapsed / 120, 1); // 2 minutes to full evolution
                    
                    // Make decisions
                    if (this.producer.godMode) {
                        // God mode - maximum chaos and creativity
                        this.producer.energy = 0.7 + Math.sin(this.ctx.currentTime * 0.1) * 0.3;
                        this.producer.complexity = 0.8 + Math.sin(this.ctx.currentTime * 0.15) * 0.2;
                        
                        // Random filter sweeps
                        this.drumFilter.frequency.setTargetAtTime(
                            500 + Math.random() * 19500,
                            this.ctx.currentTime,
                            0.5
                        );
                        
                        // Random tempo variations
                        if (Math.random() < 0.01) {
                            this.bpm = 72 + (Math.random() - 0.5) * 10;
                        }
                    } else {
                        // Normal evolution
                        const targetEnergy = hasLoops ? 
                            0.4 + loopCount * 0.15 + this.producer.evolution * 0.2 : 
                            0.3 + this.producer.evolution * 0.3;
                        
                        const targetComplexity = hasLoops ?
                            0.3 + loopCount * 0.1 + this.producer.evolution * 0.3 :
                            0.2 + this.producer.evolution * 0.2;
                        
                        // Smooth transitions
                        this.producer.energy += (targetEnergy - this.producer.energy) * 0.05;
                        this.producer.complexity += (targetComplexity - this.producer.complexity) * 0.05;
                    }
                    
                    // Update effects based on producer state
                    this.updateEffects();
                    
                    // Start visualizer when energy is high enough
                    if (this.producer.energy > 0.3 && !this.visualizerActive) {
                        this.visualizerActive = true;
                        this.animateVisualizer();
                    }
                    
                }, 100);
            }

            updateProducerState() {
                // Called every bar
                const decision = [];
                
                // Decide on arrangement changes
                if (this.barCount % 8 === 0) {
                    if (Math.random() < 0.3) {
                        decision.push('BREAKDOWN');
                        this.producer.energy *= 0.5;
                    }
                }
                
                if (this.barCount % 16 === 0) {
                    if (Math.random() < 0.5) {
                        decision.push('BUILD');
                        this.producer.energy = Math.min(this.producer.energy * 1.2, 1);
                    }
                }
                
                // Update UI
                if (decision.length > 0) {
                    this.producerStatus.textContent = decision.join(' • ');
                    this.producerStatus.classList.add('visible');
                    setTimeout(() => this.producerStatus.classList.remove('visible'), 3000);
                }
            }

            updateEffects() {
                // Drum bus filter automation
                const drumFreq = 20000 - (1 - this.producer.energy) * 15000;
                this.drumFilter.frequency.setTargetAtTime(drumFreq, this.ctx.currentTime, 0.5);
                
                // Sample bus processing intensity
                const sampleFreq = 500 + this.producer.complexity * 10000;
                this.sampleFilter.frequency.setTargetAtTime(sampleFreq, this.ctx.currentTime, 1);
                
                // Update distortion curve based on energy
                const distAmount = 10 + this.producer.energy * 100;
                this.sampleDistortion.curve = this.makeDistortionCurve(distAmount);
                
                // Reverb automation
                if (this.sampleReverb && this.sampleReverb.output.gain) {
                    const reverbAmount = 0.3 + this.producer.complexity * 0.5;
                    this.sampleReverb.output.gain.setTargetAtTime(reverbAmount, this.ctx.currentTime, 0.5);
                }
            }

            toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                if (!this.micSource) return;
                
                this.isRecording = true;
                this.recordBuffer = [];
                this.orb.classList.add('recording');
                this.status.textContent = 'Recording...';
                this.status.classList.add('visible');
                
                // Connect mic to recorder
                this.micSource.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
            }

            stopRecording() {
                this.isRecording = false;
                this.orb.classList.remove('recording');
                this.status.classList.remove('visible');
                
                // Disconnect
                try {
                    this.micSource.disconnect(this.recorder);
                    this.recorder.disconnect();
                } catch (e) {}
                
                // Process if we have enough audio
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                    this.processSample();
                }
            }

            processSample() {
                // Create buffer from recording
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                // Find loop points (4 bars)
                const barLength = this.ctx.sampleRate * 60 / this.bpm * 4;
                const loopLength = Math.min(buffer.length, barLength);
                
                // Create perfectly looped buffer
                const loopBuffer = this.ctx.createBuffer(1, Math.floor(loopLength), this.ctx.sampleRate);
                const sourceData = buffer.getChannelData(0);
                const loopData = loopBuffer.getChannelData(0);
                
                // Copy with crossfade at loop point
                const fadeLength = 100; // samples
                for (let i = 0; i < loopLength; i++) {
                    let sample = sourceData[i];
                    
                    // Fade in
                    if (i < fadeLength) {
                        sample *= i / fadeLength;
                    }
                    
                    // Fade out
                    if (i > loopLength - fadeLength) {
                        sample *= (loopLength - i) / fadeLength;
                    }
                    
                    loopData[i] = sample;
                }
                
                // Store the loop
                this.loops.push({
                    buffer: loopBuffer,
                    playing: null,
                    age: 0
                });
                
                // Keep only last 4 loops
                if (this.loops.length > 4) {
                    const removed = this.loops.shift();
                    if (removed.playing) {
                        removed.playing.stop();
                    }
                }
                
                this.status.textContent = `Sample ${this.loops.length} ready`;
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }

            triggerSampleLoop(time) {
                // Play all loops with increasing processing
                this.loops.forEach((loop, index) => {
                    loop.age++;
                    
                    // Stop previous instance
                    if (loop.playing) {
                        loop.playing.stop(time);
                    }
                    
                    // Create new source
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    const panner = this.ctx.createStereoPanner();
                    
                    source.buffer = loop.buffer;
                    source.loop = true;
                    
                    // Processing gets more intense with age and producer state
                    const processingIntensity = (loop.age / 100) * this.producer.complexity;
                    
                    // Filter automation
                    filter.type = ['lowpass', 'highpass', 'bandpass'][index % 3];
                    filter.frequency.value = 20000 - (index * 3000);
                    filter.Q.value = 1 + processingIntensity * 10;
                    
                    // Stereo positioning
                    panner.pan.value = (index % 2 === 0 ? -1 : 1) * (index * 0.2) * this.producer.complexity;
                    
                    // Gain based on layer and producer energy
                    gainNode.gain.value = (0.7 - (index * 0.1)) * (0.5 + this.producer.energy * 0.5);
                    
                    // Pitch shifting for trippiness
                    source.playbackRate.value = 1 + (processingIntensity * 0.1 * Math.sin(loop.age * 0.01));
                    
                    // Connect chain
                    source.connect(filter);
                    filter.connect(panner);
                    panner.connect(gainNode);
                    gainNode.connect(this.sampleBus);
                    
                    source.start(time);
                    loop.playing = source;
                    
                    // Animate filter for movement
                    const lfoRate = 0.1 + (index * 0.05) + (this.producer.complexity * 0.2);
                    const animateFilter = () => {
                        if (loop.playing === source) {
                            const now = this.ctx.currentTime;
                            const mod = Math.sin(now * lfoRate) * 0.5 + 0.5;
                            const baseFreq = 2000 + this.producer.energy * 10000;
                            filter.frequency.value = baseFreq + mod * (18000 - index * 3000);
                            
                            // In god mode, go crazy
                            if (this.producer.godMode) {
                                filter.Q.value = 1 + Math.sin(now * 0.3) * 20;
                                panner.pan.value = Math.sin(now * 0.7) * 0.8;
                            }
                            
                            requestAnimationFrame(animateFilter);
                        }
                    };
                    animateFilter();
                });
            }

            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.toggleRecording();
                    } else if (e.code === 'KeyG') {
                        this.toggleGodMode();
                    }
                });
                
                // Hold space to clear samples
                let spaceHoldTimer;
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.repeat) {
                        spaceHoldTimer = setTimeout(() => {
                            this.clearSamples();
                        }, 1000);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        clearTimeout(spaceHoldTimer);
                    }
                });
            }

            toggleGodMode() {
                this.producer.godMode = !this.producer.godMode;
                
                if (this.producer.godMode) {
                    this.orb.classList.add('god-mode');
                    this.producerStatus.textContent = 'GOD MODE ACTIVATED';
                    this.producerStatus.classList.add('visible');
                    
                    // Immediate energy boost
                    this.producer.energy = 1;
                    this.producer.complexity = 1;
                } else {
                    this.orb.classList.remove('god-mode');
                    this.producerStatus.textContent = 'God mode deactivated';
                    this.producerStatus.classList.add('visible');
                }
                
                setTimeout(() => this.producerStatus.classList.remove('visible'), 2000);
            }

            clearSamples() {
                this.loops.forEach(loop => {
                    if (loop.playing) {
                        loop.playing.stop();
                    }
                });
                this.loops = [];
                
                this.status.textContent = 'Samples cleared';
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }
        }

        // Initialize GUMP
        const gump = new GUMP();
    </script>
</body>
</html>
