<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP 2.0</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a0a;overflow:hidden;touch-action:none;height:100vh;font-family:system-ui,-apple-system,sans-serif}
        canvas{position:fixed;inset:0}

        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100;cursor:pointer;background:#0a0a0a}
        #enter.off{display:none}
        #enter div{width:140px;height:140px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px}
        #enter .title{font-size:11px;letter-spacing:6px;color:rgba(255,255,255,0.4)}
        #enter .sub{font-size:8px;letter-spacing:2px;color:rgba(255,255,255,0.2)}

        #dials{position:fixed;bottom:0;left:0;right:0;z-index:50;padding:15px 10px 25px;background:linear-gradient(transparent,rgba(0,0,0,0.9))}
        .dial{margin-bottom:12px}
        .dial-label{font-size:9px;letter-spacing:3px;color:rgba(255,255,255,0.3);margin-bottom:6px;text-transform:uppercase}
        .dial-track{display:flex;gap:6px;overflow-x:auto;scrollbar-width:none;padding:3px 0}
        .dial-track::-webkit-scrollbar{display:none}
        .dial-option{flex-shrink:0;padding:10px 18px;border-radius:20px;font-size:12px;color:rgba(255,255,255,0.4);background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);cursor:pointer;transition:all 0.2s;user-select:none;-webkit-tap-highlight-color:transparent}
        .dial-option.active{background:rgba(255,255,255,0.15);color:#fff;border-color:rgba(255,255,255,0.4)}
    </style>
</head>
<body>
<div id="enter">
    <div>
        <span class="title">GUMP</span>
        <span class="sub">tap to begin</span>
    </div>
</div>

<div id="dials" style="display:none">
    <div class="dial" id="beats-dial">
        <div class="dial-label">beats</div>
        <div class="dial-track">
            <div class="dial-option" data-value="none">off</div>
            <div class="dial-option active" data-value="lofi">lo-fi</div>
            <div class="dial-option" data-value="trap">trap</div>
            <div class="dial-option" data-value="jazz">jazz</div>
            <div class="dial-option" data-value="rock">rock</div>
        </div>
    </div>
    <div class="dial" id="bass-dial">
        <div class="dial-label">bass</div>
        <div class="dial-track">
            <div class="dial-option" data-value="none">off</div>
            <div class="dial-option active" data-value="sub">sub</div>
            <div class="dial-option" data-value="funk">funk</div>
            <div class="dial-option" data-value="synth">synth</div>
        </div>
    </div>
    <div class="dial" id="vibe-dial">
        <div class="dial-label">vibe</div>
        <div class="dial-track">
            <div class="dial-option" data-value="raw">raw</div>
            <div class="dial-option active" data-value="lofi">lo-fi</div>
            <div class="dial-option" data-value="polished">polished</div>
            <div class="dial-option" data-value="crushed">crushed</div>
        </div>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// GUMP 2.0 - Clean rebuild

const TAU = Math.PI * 2;
let ctx, master, filter, canvas, vc;
let running = false;

// State
let dials = { beats: 'lofi', bass: 'sub', vibe: 'lofi' };
let field = { x: 0.5, y: 0.5, energy: 0, time: 0 };

// Beat configs
const BEATS = {
    none: null,
    lofi: { bpm: 72, kick: [0, 2], snare: [1, 3], hat: [0.5, 1.5, 2.5, 3.5] },
    trap: { bpm: 140, kick: [0, 1.5, 2], snare: [1, 3], hat: [0,0.25,0.5,0.75,1,1.25,1.5,1.75,2,2.25,2.5,2.75,3,3.25,3.5,3.75] },
    jazz: { bpm: 95, kick: [0, 2.5], snare: [1.5], ride: [0,0.66,1.33,2,2.66,3.33] },
    rock: { bpm: 120, kick: [0, 2], snare: [1, 3], hat: [0,0.5,1,1.5,2,2.5,3,3.5] }
};

const VIBES = {
    raw: { cutoff: 20000 },
    lofi: { cutoff: 3000 },
    polished: { cutoff: 16000 },
    crushed: { cutoff: 2000 }
};

// Drum sounds
function kick() {
    const now = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.frequency.setValueAtTime(150, now);
    o.frequency.exponentialRampToValueAtTime(40, now + 0.1);
    g.gain.setValueAtTime(0.6, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
    o.connect(g).connect(master);
    o.start(now);
    o.stop(now + 0.25);
}

function snare() {
    const now = ctx.currentTime;
    // Tone
    const o = ctx.createOscillator();
    const og = ctx.createGain();
    o.type = 'triangle';
    o.frequency.value = 180;
    og.gain.setValueAtTime(0.2, now);
    og.gain.exponentialRampToValueAtTime(0.001, now + 0.1);
    o.connect(og).connect(master);
    o.start(now);
    o.stop(now + 0.1);
    // Noise
    const buf = ctx.createBuffer(1, ctx.sampleRate * 0.08, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const n = ctx.createBufferSource();
    n.buffer = buf;
    const nf = ctx.createBiquadFilter();
    nf.type = 'highpass';
    nf.frequency.value = 2000;
    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.25, now);
    ng.gain.exponentialRampToValueAtTime(0.001, now + 0.08);
    n.connect(nf).connect(ng).connect(master);
    n.start(now);
}

function hat() {
    const now = ctx.currentTime;
    const buf = ctx.createBuffer(1, ctx.sampleRate * 0.03, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const n = ctx.createBufferSource();
    n.buffer = buf;
    const f = ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = 8000;
    const g = ctx.createGain();
    g.gain.setValueAtTime(0.1, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.03);
    n.connect(f).connect(g).connect(master);
    n.start(now);
}

function ride() {
    const now = ctx.currentTime;
    const o1 = ctx.createOscillator();
    const o2 = ctx.createOscillator();
    const g = ctx.createGain();
    o1.frequency.value = 400;
    o2.frequency.value = 540;
    g.gain.setValueAtTime(0.06, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
    o1.connect(g);
    o2.connect(g);
    g.connect(master);
    o1.start(now);
    o2.start(now);
    o1.stop(now + 0.4);
    o2.stop(now + 0.4);
}

// Beat sequencer
let beatStep = 0;
let lastBeatTime = 0;

function updateBeats() {
    const cfg = BEATS[dials.beats];
    if (!cfg) return;

    const beatDuration = 60 / cfg.bpm / 4; // 16th notes
    const now = ctx.currentTime;

    if (now - lastBeatTime >= beatDuration) {
        lastBeatTime = now;
        const step = beatStep % 16; // 4 beats * 4 subdivisions
        const beat = step / 4;

        if (cfg.kick && cfg.kick.includes(beat)) kick();
        if (cfg.snare && cfg.snare.includes(beat)) snare();
        if (cfg.hat && cfg.hat.includes(beat)) hat();
        if (cfg.ride && cfg.ride.includes(beat)) ride();

        beatStep++;
    }
}

// Bass
let bassOsc, bassGain;

function initBass() {
    bassOsc = ctx.createOscillator();
    bassGain = ctx.createGain();
    bassOsc.type = 'sine';
    bassOsc.frequency.value = 55;
    bassGain.gain.value = 0;
    bassOsc.connect(bassGain).connect(master);
    bassOsc.start();
}

function updateBass() {
    if (dials.bass === 'none') {
        bassGain.gain.value = 0;
        return;
    }

    const baseFreq = dials.bass === 'sub' ? 40 : dials.bass === 'funk' ? 60 : 55;
    const freq = baseFreq * Math.pow(2, (1 - field.y) * 1.5);

    bassOsc.type = dials.bass === 'sub' ? 'sine' : dials.bass === 'funk' ? 'sawtooth' : 'square';
    bassOsc.frequency.value = freq;
    bassGain.gain.value = 0.15 + field.energy * 0.1;
}

// Layers from motion
let layers = [];

function createLayer() {
    if (layers.length >= 5) {
        const old = layers.shift();
        old.osc.stop();
    }

    const freq = 220 * Math.pow(2, (1 - field.y) * 2);
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    o.type = layers.length % 2 === 0 ? 'sine' : 'triangle';
    o.frequency.value = freq;
    g.gain.value = 0.06 * Math.pow(0.7, layers.length);

    o.connect(g).connect(master);
    o.start();

    layers.push({ osc: o, gain: g, freq, vol: g.gain.value, phase: 0, len: 1.5 + Math.random() });
}

function updateLayers(dt) {
    for (const L of layers) {
        L.phase += dt / L.len;
        if (L.phase >= 1) L.phase -= 1;
        const env = 0.5 + 0.5 * Math.cos(L.phase * TAU);
        L.gain.gain.value = L.vol * env;
    }
}

// Orb
let orb = { active: false, x: 0.5, y: 0.5 };

function updateOrb(dt) {
    if (!orb.active && field.energy > 0.04) {
        orb.active = true;
        orb.x = field.x;
        orb.y = field.y;
    }

    if (orb.active) {
        const dx = 0.5 - orb.x;
        const dy = 0.5 - orb.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.03) {
            const speed = 0.4 * dt;
            orb.x += (dx / dist) * speed;
            orb.y += (dy / dist) * speed;
        } else {
            createLayer();
            orb.active = false;
        }

        if (field.energy < 0.01) orb.active = false;
    }
}

// Vibe (just filter for now - no glitchy waveshaper)
function updateVibe() {
    const cfg = VIBES[dials.vibe];
    filter.frequency.value = cfg.cutoff;
}

// Input
function onMove(nx, ny) {
    const dx = nx - field.x;
    const dy = ny - field.y;
    field.x += dx * 0.2;
    field.y += dy * 0.2;
    field.energy = field.energy * 0.9 + Math.sqrt(dx*dx + dy*dy) * 2;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;
    field.x = Math.max(0, Math.min(1, field.x + ax * 0.05));
    field.y = Math.max(0, Math.min(1, field.y - ay * 0.05));
    field.energy = field.energy * 0.9 + Math.sqrt(ax*ax + ay*ay) * 0.5;
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 45;
    const gy = (e.beta || 0) / 45 - 0.5;
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// Visuals
function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    vc.fillStyle = 'rgba(10,10,10,0.15)';
    vc.fillRect(0, 0, w, h);

    // Center
    vc.strokeStyle = 'rgba(255,255,255,0.1)';
    vc.beginPath();
    vc.arc(w/2, h/2, 25, 0, TAU);
    vc.stroke();

    // Layers
    layers.forEach((L, i) => {
        const r = 35 + i * 25;
        const a = 0.1 + (0.5 + 0.5 * Math.cos(L.phase * TAU)) * 0.2;
        vc.strokeStyle = `rgba(150,180,255,${a})`;
        vc.beginPath();
        vc.arc(w/2, h/2, r, 0, TAU);
        vc.stroke();
    });

    // Orb
    if (orb.active) {
        const ox = orb.x * w, oy = orb.y * h;
        vc.fillStyle = 'rgba(255,255,255,0.7)';
        vc.beginPath();
        vc.arc(ox, oy, 8, 0, TAU);
        vc.fill();
    }

    // Cursor
    const cx = field.x * w, cy = field.y * h;
    vc.fillStyle = `rgba(255,255,255,${0.2 + field.energy})`;
    vc.beginPath();
    vc.arc(cx, cy, 5 + field.energy * 15, 0, TAU);
    vc.fill();
}

// Loop
function tick() {
    if (!running) return;

    const dt = 1/60;
    field.time += dt;
    field.energy *= 0.98;

    updateBeats();
    updateBass();
    updateOrb(dt);
    updateLayers(dt);

    draw();
    requestAnimationFrame(tick);
}

// Init
function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 3000;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -10;
    comp.ratio.value = 4;

    master = ctx.createGain();
    master.gain.value = 0.8;

    master.connect(filter).connect(comp).connect(ctx.destination);

    initBass();

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    addEventListener('resize', resize);

    // Dial clicks
    document.querySelectorAll('.dial-option').forEach(opt => {
        opt.addEventListener('click', () => {
            const dial = opt.closest('.dial');
            const id = dial.id.replace('-dial', '');
            dial.querySelectorAll('.dial-option').forEach(o => o.classList.remove('active'));
            opt.classList.add('active');
            dials[id] = opt.dataset.value;
            if (id === 'beats') { beatStep = 0; lastBeatTime = ctx.currentTime; }
            if (id === 'vibe') updateVibe();
        });
    });

    updateVibe();
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('dials').style.display = 'block';

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    addEventListener('devicemotion', onMotion);
    addEventListener('deviceorientation', onOrientation);
    document.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    document.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
