<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump - AI DJ Live Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --phi: 1.618033988749;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }

        /* Start screen */
        .start {
            width: var(--fib144);
            height: var(--fib144);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%, 
                rgba(255,255,255,0.03) 0%, 
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }

        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }

        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib8);
            opacity: 0.618;
        }

        /* Main interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }

        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* AI Status */
        .ai-status {
            position: fixed;
            top: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: var(--fib13);
            letter-spacing: var(--fib8);
            opacity: 0.618;
        }

        .listening-indicator {
            display: inline-block;
            width: var(--fib13);
            height: var(--fib13);
            border-radius: 50%;
            background: rgba(0,255,0,0.5);
            margin-left: var(--fib8);
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.5); opacity: 0.8; }
        }

        /* Track layers */
        .track-layers {
            position: fixed;
            left: var(--fib34);
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--fib13);
        }

        .track {
            display: flex;
            align-items: center;
            gap: var(--fib13);
            opacity: 0.3;
            transition: all 0.618s ease;
        }

        .track.active {
            opacity: 1;
        }

        .track-label {
            font-size: var(--fib8);
            letter-spacing: var(--fib8);
            width: var(--fib55);
            text-align: right;
        }

        .track-visualizer {
            width: var(--fib144);
            height: var(--fib21);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
        }

        .track-fill {
            position: absolute;
            top: 0;
            left: 0;
            height: 100%;
            background: linear-gradient(90deg, 
                rgba(255,255,255,0.1), 
                rgba(255,255,255,0.3));
            width: 0%;
            transition: width 0.1s ease;
        }

        .track.beat .track-fill { background: linear-gradient(90deg, rgba(255,0,0,0.3), rgba(255,0,0,0.5)); }
        .track.bass .track-fill { background: linear-gradient(90deg, rgba(0,255,0,0.3), rgba(0,255,0,0.5)); }
        .track.lead .track-fill { background: linear-gradient(90deg, rgba(0,100,255,0.3), rgba(0,100,255,0.5)); }
        .track.melody .track-fill { background: linear-gradient(90deg, rgba(255,0,255,0.3), rgba(255,0,255,0.5)); }

        /* Sample capture visualization */
        .capture-viz {
            position: fixed;
            right: var(--fib34);
            top: 50%;
            transform: translateY(-50%);
            width: var(--fib144);
            height: var(--fib144);
            display: flex;
            flex-direction: column;
            gap: var(--fib8);
        }

        .sample-queue {
            display: flex;
            flex-direction: column;
            gap: var(--fib8);
            max-height: var(--fib144);
            overflow-y: auto;
        }

        .sample-item {
            padding: var(--fib8);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            font-size: var(--fib8);
            letter-spacing: 1px;
            opacity: 0;
            animation: slideIn 0.382s ease forwards;
        }

        @keyframes slideIn {
            from { transform: translateX(50px); opacity: 0; }
            to { transform: translateX(0); opacity: 0.618; }
        }

        /* Waveform */
        #waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--fib89);
            pointer-events: none;
            opacity: 0.3;
        }

        /* BPM and tempo */
        .tempo-display {
            position: fixed;
            bottom: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0.618;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib13);
            letter-spacing: var(--fib8);
            opacity: 0.618;
            display: none;
        }
    </style>
</head>
<body>
    <canvas id="waveform"></canvas>
    
    <div class="start" id="start">
        <span class="start-text">START</span>
    </div>
    
    <div class="interface" id="interface">
        <div class="ai-status">
            AI DJ LIVE
            <span class="listening-indicator"></span>
        </div>
        
        <div class="track-layers">
            <div class="track beat" data-track="beat">
                <div class="track-label">BEAT</div>
                <div class="track-visualizer">
                    <div class="track-fill"></div>
                </div>
            </div>
            <div class="track bass" data-track="bass">
                <div class="track-label">BASS</div>
                <div class="track-visualizer">
                    <div class="track-fill"></div>
                </div>
            </div>
            <div class="track lead" data-track="lead">
                <div class="track-label">LEAD</div>
                <div class="track-visualizer">
                    <div class="track-fill"></div>
                </div>
            </div>
            <div class="track melody" data-track="melody">
                <div class="track-label">MELODY</div>
                <div class="track-visualizer">
                    <div class="track-fill"></div>
                </div>
            </div>
        </div>
        
        <div class="capture-viz">
            <div class="sample-queue" id="sampleQueue"></div>
        </div>
        
        <div class="tempo-display">
            <div id="bpm">120 BPM</div>
        </div>
    </div>
    
    <div class="loading" id="loading">INITIALIZING AI...</div>

    <script>
        class AIDJSampler {
            constructor() {
                this.ctx = null;
                this.analyser = null;
                this.microphone = null;
                this.isListening = false;
                
                // Track system
                this.tracks = {
                    beat: { samples: [], currentSample: null, gain: null },
                    bass: { samples: [], currentSample: null, gain: null },
                    lead: { samples: [], currentSample: null, gain: null },
                    melody: { samples: [], currentSample: null, gain: null }
                };
                
                // Timing
                this.bpm = 120;
                this.beatLength = 60 / this.bpm;
                this.currentBeat = 0;
                
                // Sample detection
                this.sampleBuffer = [];
                this.isCapturing = false;
                this.captureThreshold = 0.15;
                this.silenceCount = 0;
                
                // AI Classification thresholds
                this.classificationParams = {
                    beat: { lowFreq: 0.7, attack: 0.8, duration: [0.05, 0.3] },
                    bass: { lowFreq: 0.6, sustain: 0.6, duration: [0.2, 1.0] },
                    lead: { midFreq: 0.6, harmonic: 0.5, duration: [0.3, 2.0] },
                    melody: { highFreq: 0.5, pitch: 0.6, duration: [0.5, 3.0] }
                };
                
                this.init();
            }
            
            async init() {
                document.getElementById('start').addEventListener('click', () => this.start());
            }
            
            async start() {
                document.getElementById('loading').style.display = 'block';
                document.getElementById('start').style.display = 'none';
                
                try {
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.setupAudio(stream);
                    this.startEngine();
                    
                    document.getElementById('loading').style.display = 'none';
                    document.getElementById('interface').classList.add('active');
                    
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    document.getElementById('loading').textContent = 'MIC ACCESS REQUIRED';
                }
            }
            
            setupAudio(stream) {
                // Create nodes
                this.microphone = this.ctx.createMediaStreamSource(stream);
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                
                // Create processor for sample detection
                this.processor = this.ctx.createScriptProcessor(2048, 1, 1);
                this.processor.onaudioprocess = (e) => this.processAudio(e);
                
                // Connect microphone to analyser and processor
                this.microphone.connect(this.analyser);
                this.microphone.connect(this.processor);
                this.processor.connect(this.ctx.destination);
                
                // Create track gains
                const masterGain = this.ctx.createGain();
                masterGain.gain.value = 0.8;
                masterGain.connect(this.ctx.destination);
                
                Object.keys(this.tracks).forEach(track => {
                    this.tracks[track].gain = this.ctx.createGain();
                    this.tracks[track].gain.gain.value = 0.5;
                    this.tracks[track].gain.connect(masterGain);
                });
                
                // Setup visualizer
                this.setupVisualizer();
            }
            
            processAudio(e) {
                if (!this.isListening) return;
                
                const inputData = e.inputBuffer.getChannelData(0);
                const rms = this.calculateRMS(inputData);
                
                // Detect sound events
                if (rms > this.captureThreshold && !this.isCapturing) {
                    this.startCapture();
                } else if (this.isCapturing) {
                    this.continueCapture(inputData, rms);
                }
            }
            
            calculateRMS(data) {
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i];
                }
                return Math.sqrt(sum / data.length);
            }
            
            startCapture() {
                this.isCapturing = true;
                this.sampleBuffer = [];
                this.silenceCount = 0;
            }
            
            continueCapture(data, rms) {
                this.sampleBuffer.push(...data);
                
                // Check for end of sound
                if (rms < this.captureThreshold * 0.5) {
                    this.silenceCount++;
                    if (this.silenceCount > 10) {
                        this.endCapture();
                    }
                } else {
                    this.silenceCount = 0;
                }
                
                // Max capture length
                if (this.sampleBuffer.length > this.ctx.sampleRate * 3) {
                    this.endCapture();
                }
            }
            
            endCapture() {
                this.isCapturing = false;
                
                if (this.sampleBuffer.length > this.ctx.sampleRate * 0.05) {
                    this.classifyAndAssign(this.sampleBuffer);
                }
                
                this.sampleBuffer = [];
            }
            
            classifyAndAssign(audioData) {
                // Analyze sample characteristics
                const analysis = this.analyzeSample(audioData);
                
                // Classify into track type
                const trackType = this.classifySample(analysis);
                
                // Create buffer
                const buffer = this.ctx.createBuffer(1, audioData.length, this.ctx.sampleRate);
                const channelData = buffer.getChannelData(0);
                for (let i = 0; i < audioData.length; i++) {
                    channelData[i] = audioData[i];
                }
                
                // Add to track
                this.addSampleToTrack(trackType, buffer, analysis);
                
                // Update UI
                this.showSampleCapture(trackType);
            }
            
            analyzeSample(data) {
                const fftSize = 2048;
                const fft = new Float32Array(fftSize);
                
                // Simple FFT approximation for frequency analysis
                let lowFreq = 0, midFreq = 0, highFreq = 0;
                for (let i = 0; i < data.length - fftSize; i += fftSize) {
                    const segment = data.slice(i, i + fftSize);
                    
                    // Calculate frequency bins (simplified)
                    for (let j = 0; j < fftSize / 2; j++) {
                        const magnitude = Math.abs(segment[j]);
                        if (j < fftSize / 8) lowFreq += magnitude;
                        else if (j < fftSize / 4) midFreq += magnitude;
                        else highFreq += magnitude;
                    }
                }
                
                const total = lowFreq + midFreq + highFreq;
                
                // Calculate attack
                const attackSamples = Math.min(data.length, this.ctx.sampleRate * 0.05);
                let attackSum = 0;
                for (let i = 0; i < attackSamples; i++) {
                    attackSum += Math.abs(data[i]);
                }
                const attack = attackSum / attackSamples;
                
                return {
                    duration: data.length / this.ctx.sampleRate,
                    lowFreq: lowFreq / total,
                    midFreq: midFreq / total,
                    highFreq: highFreq / total,
                    attack: attack,
                    rms: this.calculateRMS(data)
                };
            }
            
            classifySample(analysis) {
                const scores = {
                    beat: 0,
                    bass: 0,
                    lead: 0,
                    melody: 0
                };
                
                // Score for beat (short, punchy, low freq)
                if (analysis.duration < 0.3 && analysis.attack > 0.1 && analysis.lowFreq > 0.5) {
                    scores.beat = analysis.attack * analysis.lowFreq;
                }
                
                // Score for bass (sustained low freq)
                if (analysis.duration > 0.2 && analysis.lowFreq > 0.6) {
                    scores.bass = analysis.lowFreq * (1 - analysis.attack);
                }
                
                // Score for lead (mid freq, moderate length)
                if (analysis.duration > 0.3 && analysis.midFreq > 0.4) {
                    scores.lead = analysis.midFreq;
                }
                
                // Score for melody (high freq, longer)
                if (analysis.duration > 0.5 && (analysis.highFreq > 0.3 || analysis.midFreq > 0.5)) {
                    scores.melody = (analysis.highFreq + analysis.midFreq) / 2;
                }
                
                // Find best match
                let bestTrack = 'melody';
                let bestScore = 0;
                
                for (const [track, score] of Object.entries(scores)) {
                    if (score > bestScore) {
                        bestScore = score;
                        bestTrack = track;
                    }
                }
                
                return bestTrack;
            }
            
            addSampleToTrack(trackType, buffer, analysis) {
                const track = this.tracks[trackType];
                
                // Store sample
                const sample = {
                    buffer: buffer,
                    analysis: analysis,
                    playbackRate: 1,
                    startTime: 0
                };
                
                track.samples.push(sample);
                
                // Keep only recent samples
                if (track.samples.length > 4) {
                    track.samples.shift();
                }
                
                // Update current sample
                track.currentSample = sample;
                
                // Activate track
                document.querySelector(`.track.${trackType}`).classList.add('active');
            }
            
            showSampleCapture(trackType) {
                const queue = document.getElementById('sampleQueue');
                const item = document.createElement('div');
                item.className = 'sample-item';
                item.textContent = `${trackType.toUpperCase()} CAPTURED`;
                queue.appendChild(item);
                
                // Remove old items
                if (queue.children.length > 5) {
                    queue.removeChild(queue.firstChild);
                }
            }
            
            startEngine() {
                this.isListening = true;
                
                // Start the beat
                this.scheduleBeat();
                
                // Start visualizations
                this.animate();
            }
            
            scheduleBeat() {
                const scheduleNext = () => {
                    const now = this.ctx.currentTime;
                    
                    // Play samples on each beat
                    this.playTracksOnBeat();
                    
                    // Update beat counter
                    this.currentBeat = (this.currentBeat + 1) % 16;
                    
                    // Update BPM display
                    document.getElementById('bpm').textContent = `${Math.round(this.bpm)} BPM`;
                    
                    // Schedule next beat
                    setTimeout(scheduleNext, this.beatLength * 1000);
                };
                
                scheduleNext();
            }
            
            playTracksOnBeat() {
                const now = this.ctx.currentTime;
                
                // Beat track - play every beat
                if (this.tracks.beat.currentSample && this.currentBeat % 1 === 0) {
                    this.playGrain(this.tracks.beat, now);
                }
                
                // Bass track - play every 2 beats
                if (this.tracks.bass.currentSample && this.currentBeat % 2 === 0) {
                    this.playGrain(this.tracks.bass, now);
                }
                
                // Lead track - play every 4 beats
                if (this.tracks.lead.currentSample && this.currentBeat % 4 === 0) {
                    this.playGrain(this.tracks.lead, now);
                }
                
                // Melody track - play every 8 beats with variation
                if (this.tracks.melody.currentSample && this.currentBeat % 8 === 0) {
                    this.playGrain(this.tracks.melody, now, true);
                }
            }
            
            playGrain(track, when, randomize = false) {
                if (!track.currentSample) return;
                
                const source = this.ctx.createBufferSource();
                source.buffer = track.currentSample.buffer;
                
                const gainNode = this.ctx.createGain();
                
                // Randomize playback for variety
                if (randomize) {
                    source.playbackRate.value = 0.8 + Math.random() * 0.4;
                    const startOffset = Math.random() * (source.buffer.duration * 0.5);
                    source.start(when, startOffset, Math.min(source.buffer.duration - startOffset, this.beatLength * 2));
                } else {
                    // Sync to beat
                    const duration = Math.min(source.buffer.duration, this.beatLength);
                    source.start(when, 0, duration);
                }
                
                // Envelope
                gainNode.gain.setValueAtTime(0, when);
                gainNode.gain.linearRampToValueAtTime(0.5, when + 0.01);
                gainNode.gain.exponentialRampToValueAtTime(0.001, when + this.beatLength);
                
                source.connect(gainNode);
                gainNode.connect(track.gain);
                
                // Update visualization
                this.updateTrackVisualization(track);
            }
            
            updateTrackVisualization(track) {
                const trackName = Object.keys(this.tracks).find(key => this.tracks[key] === track);
                const fill = document.querySelector(`.track.${trackName} .track-fill`);
                
                if (fill) {
                    fill.style.width = '100%';
                    setTimeout(() => {
                        fill.style.width = '0%';
                    }, this.beatLength * 500);
                }
            }
            
            setupVisualizer() {
                this.waveCanvas = document.getElementById('waveform');
                this.waveCtx = this.waveCanvas.getContext('2d');
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
            }
            
            resizeCanvas() {
                this.waveCanvas.width = window.innerWidth;
                this.waveCanvas.height = 89; // Fibonacci number
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.analyser) return;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteTimeDomainData(dataArray);
                
                this.waveCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                this.waveCtx.fillRect(0, 0, this.waveCanvas.width, this.waveCanvas.height);
                
                this.waveCtx.lineWidth = 2;
                this.waveCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                this.waveCtx.beginPath();
                
                const sliceWidth = this.waveCanvas.width / bufferLength;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * this.waveCanvas.height / 2;
                    
                    if (i === 0) {
                        this.waveCtx.moveTo(x, y);
                    } else {
                        this.waveCtx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                this.waveCtx.stroke();
            }
        }
        
        // Initialize
        const dj = new AIDJSampler();
    </script>
</body>
</html>
