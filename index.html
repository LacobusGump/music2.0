<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Grand Unified Music Project</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 40% 60%, #0a0a1a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: space-between;
      transition: all 1s ease;
    }
    
    body.transcendent {
      background: radial-gradient(circle at 60% 40%, #080012 0%, #1a0a2e 25%, #2a1a3e 50%, #3a2a4e 75%, #1a0a2e 100%);
      color: #ff88cc;
      filter: blur(0.5px) brightness(1.2);
    }
    
    .app {
      width: 100%;
      max-width: 600px;
      padding: 25px;
      text-align: center;
      backdrop-filter: blur(5px) saturate(180%);
      border-radius: 20px;
      background: rgba(10, 10, 20, 0.1);
      box-shadow: 0 0 20px rgba(0, 255, 170, 0.2);
    }
    
    .header {
      margin-bottom: 20px;
    }
    
    .logo {
      font-size: clamp(3.5rem, 14vw, 7rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: pulse 3s ease-in-out infinite;
    }
    
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
    
    .tagline { font-size: clamp(1.2rem, 5vw, 1.5rem); opacity: 0.85; margin-bottom: 15px; font-weight: 300; }
    
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      margin-bottom: 20px;
    }
    
    .start-btn, .contemplative-btn, .evolutionary-btn {
      padding: 15px 30px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 25px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0, 255, 170, 0.3);
    }
    
    .start-btn:hover, .contemplative-btn:hover, .evolutionary-btn:hover {
      transform: translateY(-3px);
      box-shadow: 0 12px 35px rgba(0, 255, 170, 0.5);
    }
    
    .contemplative-btn { background: linear-gradient(45deg, #ff6b6b, #ffaa00); }
    .evolutionary-btn { background: linear-gradient(45deg, #4ecdc4, #45b7d1); }
    
    .spatial-viz {
      width: 100%;
      height: 250px;
      border: 3px solid rgba(0, 255, 170, 0.3);
      border-radius: 25px;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle, rgba(0, 255, 170, 0.05) 0%, rgba(0, 20, 40, 0.05) 100%);
      margin-bottom: 20px;
      transition: all 1s ease;
    }
    
    .spatial-viz.transcendent {
      border-color: rgba(255, 136, 204, 0.5);
      background: rgba(255, 136, 204, 0.08);
    }
    
    .orb {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffaa, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.25s ease;
      box-shadow: 0 0 40px rgba(0, 255, 170, 0.6);
      will-change: transform;
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #ff88cc, transparent);
      box-shadow: 0 0 80px rgba(255, 136, 204, 0.8);
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }
    
    .stat {
      background: rgba(0, 255, 170, 0.15);
      padding: 15px;
      border-radius: 15px;
      border: 2px solid rgba(0, 255, 170, 0.3);
      transition: all 0.3s ease;
    }
    
    .stat.transcendent {
      background: rgba(255, 136, 204, 0.15);
      border-color: rgba(255, 136, 204, 0.3);
    }
    
    .stat-value { font-size: 1.3rem; font-weight: 800; color: #00ffaa; transition: color 0.3s ease; }
    .stat.transcendent .stat-value { color: #ff88cc; }
    .stat-label { font-size: 0.8rem; opacity: 0.75; margin-top: 5px; }
    
    .status {
      font-size: 1rem;
      color: #4ecdc4;
      opacity: 0.85;
      animation: statusBreathe 2.5s ease-in-out infinite;
      margin-bottom: 20px;
    }
    
    @keyframes statusBreathe { 0%, 100% { opacity: 0.85; } 50% { opacity: 1.1; } }
    
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .particles.active { opacity: 0.7; }
    .particle {
      position: absolute;
      width: 4px;
      height: 4px;
      background: radial-gradient(circle, #ff88cc, transparent);
      border-radius: 50%;
      animation: float 7s linear infinite;
    }
    
    @keyframes float {
      0% { transform: translateY(110vh) scale(0); opacity: 0; }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { transform: translateY(-30vh) scale(1.5); opacity: 0; }
    }
    
    .hidden { display: none !important; }
    .error {
      background: rgba(255, 107, 107, 0.15);
      border: 2px solid rgba(255, 107, 107, 0.4);
      border-radius: 20px;
      padding: 15px;
      color: #ff6b6b;
      margin-top: 15px;
      text-align: left;
    }
    
    .canvas-container {
      width: 100%;
      height: 200px;
      margin-bottom: 20px;
      position: relative;
    }
    
    canvas {
      width: 100%;
      height: 100%;
      background: rgba(0, 20, 40, 0.1);
      border-radius: 15px;
    }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  
  <div class="app">
    <div class="header">
      <div class="logo" id="logo">GUMP</div>
      <div class="tagline" id="tagline">Grand Unified Music Project</div>
    </div>
    <div class="controls">
      <button class="start-btn" id="start">ðŸŽµ Start Spatial Audio</button>
      <button class="contemplative-btn" id="contemplative">ðŸŒŒ Contemplative Drift</button>
      <button class="evolutionary-btn" id="evolutionary">ðŸŒŠ Evolutionary Surge</button>
    </div>
    <div class="canvas-container">
      <canvas id="visualizer"></canvas>
    </div>
    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>
    <div class="stats hidden" id="stats">
      <div class="stat"><div class="stat-value" id="motion">0</div><div class="stat-label">Motion</div></div>
      <div class="stat"><div class="stat-value" id="bpm">90</div><div class="stat-label">BPM</div></div>
      <div class="stat"><div class="stat-value" id="groove">CHILL</div><div class="stat-label">State</div></div>
      <div class="stat"><div class="stat-value" id="section">INTRO</div><div class="stat-label">Section</div></div>
    </div>
    <div class="status hidden" id="status">ðŸŽµ Flowing with your vibe...</div>
    <div class="error hidden" id="error"></div>
  </div>

  <script>
    class AudioAgent {
      constructor(ctx, reverb, id, baseFreq, role) {
        this.ctx = ctx;
        this.reverb = reverb;
        this.id = id; // 0=kick, 1=bass, 2=hihat, 3=melody, 4=pad, 5=ambient
        this.baseFreq = baseFreq;
        this.role = role;
        this.traits = {
          pitchShift: 0,
          rhythmFactor: 1,
          volume: 0.1,
          activeThreshold: [0.1, 0.3, 0.5, 0.7, 0.9, 1.0][id],
          waveform: this.role === 'melody' ? 'sine' : this.role === 'pad' ? 'sawtooth' : ['sawtooth', 'triangle', 'square'][id % 3]
        };
        this.active = false;
        this.gain = ctx.createGain();
        this.gain.connect(reverb);
        this.oscillators = new Set();
        this.filter = ctx.createBiquadFilter();
      }

      activate() {
        this.active = true;
        this.gain.gain.value = this.traits.volume;
        this.filter.connect(this.gain);
      }

      evolve(motion, rampLevel, envDensity, locationData) {
        if (!this.active || rampLevel < this.traits.activeThreshold || Math.random() > 0.5) return;

        const motionImpact = motion > 10 ? 0.1 : motion < 5 ? -0.1 : 0;
        this.traits.pitchShift = Math.max(-0.3, Math.min(0.5, this.traits.pitchShift + motionImpact * 0.02 * envDensity));

        const speedFactor = locationData.speed > 0.5 ? 0.05 : 0;
        this.traits.volume = Math.min(0.7, this.traits.volume + rampLevel * 0.1 + speedFactor);

        this.play(this.role === 'kick' ? 0.3 : this.role === 'pad' ? 1.5 : 0.2);
      }

      conjugate(partner) {
        if (partner && partner !== this && Math.random() < 0.2) {
          this.traits.rhythmFactor = partner.traits.rhythmFactor * (1 + (Math.random() - 0.5) * 0.2);
          partner.traits.pitchShift += (this.traits.pitchShift - partner.traits.pitchShift) * 0.15;
        }
      }

      play(duration) {
        if (!this.active || !this.ctx) return;

        try {
          const osc = this.ctx.createOscillator();
          osc.type = this.traits.waveform;
          osc.frequency.value = this.baseFreq * (1 + this.traits.pitchShift * (this.role === 'kick' ? 0.4 : 0.3));

          this.filter.type = this.role === 'pad' ? 'lowpass' : 'bandpass';
          this.filter.frequency.value = this.role === 'pad' ? 500 + this.traits.pitchShift * 200 : 300 + this.traits.pitchShift * 100;
          this.filter.Q.value = this.role === 'pad' ? 1.5 : 4;

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(this.traits.volume, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

          osc.connect(this.filter).connect(gain).connect(this.gain);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);

          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), duration * 1000 + 150);
        } catch (e) {
          console.error(`Play error for ${this.role}: ${e.message}`);
        }
      }

      deactivate() {
        this.oscillators.forEach(osc => {
          try { osc.stop(this.ctx.currentTime + 0.2); } catch (e) { console.warn(`Deactivate error: ${e.message}`); }
        });
        this.oscillators.clear();
        this.active = false;
      }
    }

    class GUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 90;
        this.pos = { x: 50, y: 50, z: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.state = 'CHILL';
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.lastUpdateTime = 0;
        this.frameCount = 0;
        this.reverb = null;
        this.agents = [];
        this.oscillators = new Set();
        this.rampLevel = 0;
        this.envDensity = 0;
        this.locationData = { lat: 0, lon: 0, speed: 0, accuracy: 100 };
        this.contemplativeDrift = false;
        this.evolutionarySurge = false;
        this.songHistory = [];
        this.visualizer = null;

        this.scale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25, 587.33, 659.25];
        this.chords = [[0, 2, 4], [5, 0, 2], [3, 5, 0], [4, 6, 1], [2, 4, 6]];
        this.currentChord = 0;
        this.patterns = {
          kick: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
          hihat: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
          snare: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0]
        };
        this.songSection = 'INTRO';
        this.layerProgress = 0;
        this.lastStrideTime = 0;
        this.strideInterval = 600;

        this.elements = {};
        this.init();
        this.loadState();
      }

      init() {
        const ids = ['start', 'viz', 'stats', 'status', 'logo', 'tagline', 'orb', 'motion', 'bpm', 'groove', 'error', 'particles', 'contemplative', 'evolutionary', 'section', 'visualizer'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));

        this.elements.start.onclick = () => this.start();
        this.elements.contemplative.onclick = () => this.toggleContemplativeDrift();
        this.elements.evolutionary.onclick = () => this.toggleEvolutionarySurge();

        this.visualizer = new Visualizer(this.elements.visualizer);
        this.setupEventListeners();
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.visualizer.resize());
        window.addEventListener('beforeunload', () => this.saveState());
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') {
              this.handleError('Motion permission denied. Enable device motion.');
              return;
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();

          this.elements.start.classList.add('hidden');
          ['viz', 'stats', 'status'].forEach(id => this.elements[id].classList.remove('hidden'));

          this.active = true;
          this.spawnAgents();
          this.startSensors();
          this.startGroove();
          this.animate();
          this.monitorTranscendence();
          this.startVisualization();
        } catch (e) {
          this.handleError(`Startup failed: ${e.message}`);
        }
      }

      spawnAgents() {
        const roles = ['kick', 'bass', 'hihat', 'melody', 'pad', 'ambient'];
        const baseFreqs = this.scale.slice(0, 6);
        roles.forEach((role, idx) => {
          const agent = new AudioAgent(this.ctx, this.reverb, idx, baseFreqs[idx], role);
          agent.activate();
          this.agents.push(agent);
        });
      }

      startSensors() {
        let lastSensorTime = 0;
        const throttleMs = 40;

        window.addEventListener('devicemotion', e => {
          if (!this.active) return;

          const now = Date.now();
          if (now - lastSensorTime < throttleMs) return;
          lastSensorTime = now;

          const acc = e.accelerationIncludingGravity || { x: 0, y: 0, z: 0 };
          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);

          this.motion = Math.min(100, Math.sqrt(dx * dx + dy * dy + dz * dz) * 4);
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };

          if (this.motion > 5 && now - this.lastStrideTime > this.strideInterval) {
            this.lastStrideTime = now;
            this.updateSongProgress();
            this.updateEnvDensity();
            this.evolveAgents();
          }

          if (this.motion > 5) this.lastMotionTime = now;

          this.pos.x = Math.max(5, Math.min(95, this.pos.x * 0.85 + (50 + acc.x * 1.2) * 0.15));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y * 0.85 + (50 + acc.y * 1.2) * 0.15));
          this.pos.z = Math.max(-50, Math.min(50, this.pos.z * 0.9 + (acc.z * 4) * 0.1));

          this.updateState();
          this.visualizer.update(this.motion, this.pos);
        }, { passive: true });
      }

      toggleContemplativeDrift() {
        this.contemplativeDrift = !this.contemplativeDrift;
        this.elements.contemplative.style.background = this.contemplativeDrift ? 'linear-gradient(45deg, #ffaa00, #ff6b6b)' : 'linear-gradient(45deg, #ff6b6b, #ffaa00)';
        if (this.contemplativeDrift) {
          this.bpm = Math.max(60, this.bpm - 5);
          this.agents.forEach(agent => agent.traits.volume *= 0.9);
        } else {
          this.bpm = Math.min(150, this.bpm + 5);
          this.agents.forEach(agent => agent.traits.volume /= 0.9);
        }
        this.updateState();
      }

      toggleEvolutionarySurge() {
        this.evolutionarySurge = !this.evolutionarySurge;
        this.elements.evolutionary.style.background = this.evolutionarySurge ? 'linear-gradient(45deg, #45b7d1, #4ecdc4)' : 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
        if (this.evolutionarySurge) this.performEvolutionarySurge();
      }

      performEvolutionarySurge() {
        if (!this.evolutionarySurge) return;
        this.bpm = Math.min(150, this.bpm + 10);
        this.agents.forEach(agent => agent.traits.volume = Math.min(0.8, agent.traits.volume * 1.1));
        this.updateState();
        setTimeout(() => this.performEvolutionarySurge(), 5000);
      }

      monitorTranscendence() {
        let lastCheck = 0;
        const check = () => {
          if (!this.active) return;

          const now = Date.now();
          if (now - lastCheck < 100) {
            requestAnimationFrame(check);
            return;
          }
          lastCheck = now;

          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 1200;

          if (shouldTranscend && !this.transcendent) this.enterTranscendence();
          else if (!shouldTranscend && this.transcendent) this.exitTranscendence();

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 1200) / 4000);
            this.deepenVoid();
          }

          requestAnimationFrame(check);
        };
        requestAnimationFrame(check);
      }

      enterTranscendence() {
        this.transcendent = true;
        this.state = 'VOID';
        const elements = [this.elements.logo, this.elements.tagline, this.elements.viz, this.elements.orb];
        elements.forEach(el => el?.classList.add('transcendent'));
        document.body.classList.add('transcendent');
        this.createParticles();
        this.startHeavenLayers();
        this.saveState();
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.state = 'CHILL';
        const elements = [this.elements.logo, this.elements.tagline, this.elements.viz, this.elements.orb];
        elements.forEach(el => el?.classList.remove('transcendent'));
        document.body.classList.remove('transcendent');
        this.clearParticles();
        this.stopHeavenLayers();
        this.agents.forEach(agent => agent.deactivate());
        this.saveState();
      }

      createParticles() {
        const container = this.elements.particles;
        if (!container) return;
        container.classList.add('active');
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 30; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = `${Math.random() * 100}%`;
          particle.style.animationDelay = `${Math.random() * 8}s`;
          fragment.appendChild(particle);
        }
        container.appendChild(fragment);
      }

      clearParticles() {
        const container = this.elements.particles;
        if (!container) return;
        container.classList.remove('active');
        setTimeout(() => container.innerHTML = '', 2500);
      }

      createReverb() {
        if (!this.ctx) return;
        try {
          this.reverb = this.ctx.createConvolver();
          const length = this.ctx.sampleRate * 3;
          const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
          for (let c = 0; c < 2; c++) {
            const data = buffer.getChannelData(c);
            for (let i = 0; i < data.length; i++) {
              data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.5);
            }
          }
          this.reverb.buffer = buffer;
          this.reverb.connect(this.ctx.destination);
        } catch (e) {
          this.handleError(`Reverb creation failed: ${e.message}`);
        }
      }

      deepenVoid() {
        const intensity = this.transcendentIntensity;
        if (intensity > 0.3 && Math.random() < 0.008) this.voidWhisper();
        if (intensity > 0.6 && Math.random() < 0.006) this.voidBell();
        if (intensity > 0.2) {
          const depth = Math.floor(intensity * 35);
          document.body.style.background = `radial-gradient(circle at 60% 40%, #050010 ${depth}%, #0a0a1e 60%, #1a0a2e 90%, #0a0a1e 100%)`;
        }
      }

      voidWhisper() {
        if (!this.ctx) return;
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          osc.type = 'triangle';
          osc.frequency.value = 70 + Math.random() * 120;
          filter.type = 'bandpass';
          filter.frequency.value = 140 + Math.random() * 100;
          filter.Q.value = 5;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.015 * this.transcendentIntensity, this.ctx.currentTime + 1.5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 6);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 6500);
        } catch (e) {
          console.warn('Void whisper error:', e);
        }
      }

      voidBell() {
        if (!this.ctx) return;
        try {
          const freq = [174, 207, 261][Math.floor(Math.random() * 3)] * 0.5;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.06 * this.transcendentIntensity, this.ctx.currentTime + 0.3);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 7);
          osc.connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 7);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 7500);
        } catch (e) {
          console.warn('Void bell error:', e);
        }
      }

      startHeavenLayers() {
        if (!this.ctx) return;
        try {
          const chord = this.chords[this.currentChord];
          chord.forEach(note => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = this.scale[note] * 0.25;
            filter.type = 'lowpass';
            filter.frequency.value = 200 + this.motion * 0.5;
            filter.Q.value = 1.2;
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.12 * this.transcendentIntensity, this.ctx.currentTime + 5);
            osc.connect(filter).connect(gain).connect(this.reverb);
            osc.start();
            this.oscillators.add(osc);
          });
        } catch (e) {
          console.warn('Heaven layers error:', e);
        }
      }

      stopHeavenLayers() {
        this.oscillators.forEach(osc => {
          try { osc.stop(this.ctx.currentTime + 2.5); } catch (e) { console.warn('Stop error:', e); }
        });
        this.oscillators.clear();
      }

      updateLocation(position) {
        this.locationData.lat = position.coords.latitude;
        this.locationData.lon = position.coords.longitude;
        this.locationData.speed = position.coords.speed || 0;
        this.locationData.accuracy = position.coords.accuracy || 100;
        const responsiveness = Math.max(0.1, 100 / this.locationData.accuracy);

        this.envDensity = Math.min(1, Math.max(0, this.envDensity + (this.locationData.speed * 0.015 * responsiveness)));
        this.rampLevel = Math.min(1, this.rampLevel + (this.locationData.speed * 0.03 * responsiveness));

        if (this.locationData.speed > 0.5) {
          this.bpm = Math.min(150, this.bpm + Math.round(this.envDensity * 3));
        }
      }

      updateEnvDensity() {
        const motionFactor = this.motion * 0.006;
        const locationFactor = this.locationData.speed * 0.01;
        this.envDensity = Math.max(0, Math.min(1, this.envDensity + (motionFactor + locationFactor) * 0.1 + (Math.random() - 0.5) * 0.015));
      }

      updateSongProgress() {
        if (this.motion > 5 || this.locationData.speed > 0.5) {
          this.layerProgress += 0.06;
          if (this.songSection === 'INTRO' && this.layerProgress >= 15) {
            this.songSection = 'BUILD';
            this.layerProgress = 0;
          } else if (this.songSection === 'BUILD' && this.layerProgress >= 30) {
            this.songSection = 'MAIN';
            this.layerProgress = 0;
          } else if (this.songSection === 'MAIN' && this.layerProgress >= 45) {
            this.songSection = 'OUTRO';
            this.layerProgress = 0;
          } else if (this.songSection === 'OUTRO' && this.layerProgress >= 60) {
            this.songSection = 'INTRO';
            this.layerProgress = 0;
            this.currentChord = (this.currentChord + 1) % this.chords.length;
          }
        }
      }

      evolveAgents() {
        this.agents.forEach((agent, idx) => {
          if (this.songSection === 'INTRO' && idx === 0) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData);
          else if (this.songSection === 'BUILD' && idx < 2) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData);
          else if (this.songSection === 'MAIN' && idx < 4) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData);
          else if (this.songSection === 'OUTRO' && idx < 6) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData);
        });
      }

      updateStatus() {
        if (this.contemplativeDrift) this.elements.status.textContent = `ðŸŽµ Contemplative Drift... ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()}`;
        else if (this.evolutionarySurge) this.elements.status.textContent = `ðŸŽµ Evolutionary Surge... ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()}`;
        else this.elements.status.textContent = `ðŸŽµ ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()}...`;
      }

      updateState() {
        if (this.transcendent) {
          const states = ['VOID', 'DARKNESS', 'ETHEREAL', 'INFINITE', 'TRANSCENDENCE'];
          this.state = states[Math.floor(this.transcendentIntensity * states.length)];
          this.bpm = Math.round(50 + (this.transcendentIntensity * 40) + (this.motion * 0.15));
        } else {
          const targetBPM = 85 + this.motion * 1.5 + this.envDensity * 15 + (this.locationData.speed * 10);
          this.bpm = Math.round(this.bpm * 0.9 + targetBPM * 0.1);
          this.state = this.motion < 8 ? 'CHILL' : this.motion < 20 ? 'FLOW' : this.motion < 40 ? 'ENERGY' : 'PEAK';
        }

        if (this.frameCount % 12 === 0) {
          this.elements.bpm.textContent = this.bpm;
          this.elements.groove.textContent = this.state;
          this.elements.section.textContent = this.songSection;
          this.updateStatus();
          this.elements.motion.textContent = Math.round(this.motion);
          this.songHistory.push({ time: Date.now(), state: this.state, section: this.songSection, bpm: this.bpm });
          if (this.songHistory.length > 100) this.songHistory.shift();
        }
      }

      startGroove() {
        const tick = () => {
          if (!this.active) return;

          if (this.transcendent) {
            if (this.step % 8 === 0) this.etherealKick();
            if (this.step % 12 === 6 && this.transcendentIntensity > 0.3) this.voidPulse();
          } else {
            const beat = this.step % 16;
            this.agents.forEach((agent, idx) => {
              if (this.songSection === 'INTRO' && idx === 0 && this.patterns.kick[beat]) agent.play(0.3);
              if (this.songSection === 'BUILD' && idx < 2 && (this.patterns.kick[beat] || beat % 4 === 2)) agent.play(0.2);
              if (this.songSection === 'MAIN' && idx < 4 && (this.patterns.kick[beat] || this.patterns.hihat[beat] || beat % 4 === 2)) agent.play(0.2);
              if (this.songSection === 'OUTRO' && idx < 6 && (beat % 8 === 0 || this.patterns.hihat[beat])) agent.play(0.2);
            });
          }

          this.step = (this.step + 1) % 32;
          if (this.step === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
            if (this.contemplativeDrift) this.adjustForContemplativeDrift();
          }

          const interval = Math.max(50, 60000 / this.bpm / 4);
          setTimeout(tick, interval);
        };
        tick();
      }

      adjustForContemplativeDrift() {
        if (this.contemplativeDrift) {
          this.bpm = Math.max(60, this.bpm - 5);
          this.agents.forEach(agent => agent.traits.volume *= 0.9);
        }
      }

      etherealKick() {
        if (!this.ctx) return;
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(40, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.5);
          gain.gain.setValueAtTime(0.4 * this.transcendentIntensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
          osc.connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 1);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1100);
        } catch (e) {
          console.warn('Ethereal kick error:', e);
        }
      }

      voidPulse() {
        if (!this.ctx) return;
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          osc.type = 'sawtooth';
          osc.frequency.value = 20 + this.motion * 0.1;
          filter.type = 'lowpass';
          filter.frequency.value = 50 + this.motion * 0.3;
          filter.Q.value = 3;
          gain.gain.setValueAtTime(0.5 * this.transcendentIntensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1600);
        } catch (e) {
          console.warn('Void pulse error:', e);
        }
      }

      startVisualization() {
        this.visualizer.start(this.ctx);
      }

      animate() {
        const update = () => {
          if (!this.active) return;

          const now = Date.now();
          if (now - this.lastUpdateTime < 33) {
            requestAnimationFrame(update);
            return;
          }
          this.lastUpdateTime = now;

          this.elements.orb.style.transform = `translate(${this.pos.x - 50}%, ${this.pos.y - 50}%) scale(${1 + this.motion * 0.015}) rotate(${this.pos.z}deg)`;
          this.visualizer.render(this.motion, this.bpm, this.pos);

          this.frameCount++;
          requestAnimationFrame(update);
        };
        requestAnimationFrame(update);
      }

      handleError(message) {
        const errorDiv = this.elements.error;
        errorDiv.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
        errorDiv.classList.remove('hidden');
        setTimeout(() => errorDiv.classList.add('hidden'), 5000);
      }

      saveState() {
        const state = {
          bpm: this.bpm,
          state: this.state,
          section: this.songSection,
          rampLevel: this.rampLevel,
          envDensity: this.envDensity,
          locationData: this.locationData,
          songHistory: this.songHistory
        };
        localStorage.setItem('gumpState', JSON.stringify(state));
      }

      loadState() {
        const savedState = localStorage.getItem('gumpState');
        if (savedState) {
          const state = JSON.parse(savedState);
          this.bpm = state.bpm || 90;
          this.state = state.state || 'CHILL';
          this.songSection = state.section || 'INTRO';
          this.rampLevel = state.rampLevel || 0;
          this.envDensity = state.envDensity || 0;
          this.locationData = state.locationData || { lat: 0, lon: 0, speed: 0, accuracy: 100 };
          this.songHistory = state.songHistory || [];
        }
      }

      cleanup() {
        this.active = false;
        this.agents.forEach(agent => agent.deactivate());
        this.oscillators.forEach(osc => {
          try { osc.stop(); } catch (e) { console.warn('Cleanup osc error:', e); }
        });
        this.oscillators.clear();
        this.stopHeavenLayers();
        this.saveState();
      }
    }

    class Visualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.resize();
      }

      resize() {
        this.width = this.canvas.parentElement.clientWidth;
        this.height = 200;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
      }

      start(audioCtx) {
        this.analyser = audioCtx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.bufferLength = this.analyser.frequencyBinCount;
        this.dataArray = new Uint8Array(this.bufferLength);
        gump.agents.forEach(agent => agent.gain.connect(this.analyser));
        this.analyser.connect(audioCtx.destination);
      }

      update(motion, pos) {
        this.motion = motion;
        this.pos = pos;
      }

      render(motion, bpm, pos) {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.analyser.getByteFrequencyData(this.dataArray);

        const barWidth = (this.width / this.bufferLength) * 2.5;
        let x = 0;

        this.ctx.fillStyle = `rgba(0, 255, 170, ${Math.min(0.5, motion / 100)})`;
        for (let i = 0; i < this.bufferLength; i++) {
          const barHeight = (this.dataArray[i] / 255) * (this.height * 0.8);
          this.ctx.fillRect(x, this.height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }

        this.ctx.beginPath();
        this.ctx.arc(this.width * (pos.x / 100), this.height * (1 - pos.y / 100), 10 + (motion / 10), 0, Math.PI * 2);
        this.ctx.fillStyle = 'rgba(0, 255, 170, 0.7)';
        this.ctx.fill();
        this.ctx.closePath();

        this.ctx.fillStyle = '#00ffaa';
        this.ctx.font = '16px sans-serif';
        this.ctx.fillText(`BPM: ${bpm}`, 10, 20);
      }
    }

    const gump = new GUMP();
  </script>
</body>
</html>
