<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump - Active Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
            --fib233: 144px;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
            cursor: none;
        }

        /* Custom cursor that shows sampling */
        .cursor {
            position: fixed;
            width: var(--fib34);
            height: var(--fib34);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
            transition: transform 0.1s ease;
            z-index: 9999;
        }

        .cursor.sampling {
            animation: cursorPulse 0.5s ease-out;
        }

        @keyframes cursorPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* Start */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%, 
                rgba(255,255,255,0.03) 0%, 
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }

        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }

        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }

        /* Title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }

        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }

        /* Interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }

        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Real-time input meter */
        .input-meter {
            position: fixed;
            top: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib233);
            height: var(--fib8);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }

        .input-level {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            width: 0%;
            transition: width 0.05s ease;
        }

        /* Phase indicator */
        .phase-indicator {
            position: fixed;
            top: var(--fib55);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib5);
            opacity: 0.618;
            text-align: center;
            transition: all 0.382s ease;
        }

        .phase-indicator.building {
            color: #ff8c00;
            text-shadow: 0 0 var(--fib13) rgba(255, 140, 0, 0.5);
        }

        .phase-indicator.dropping {
            color: #ff0000;
            text-shadow: 0 0 var(--fib21) rgba(255, 0, 0, 0.8);
            animation: phasePulse 0.25s ease-in-out infinite;
        }

        .phase-indicator.void {
            color: #8a2be2;
            text-shadow: 0 0 var(--fib34) rgba(138, 43, 226, 0.8);
        }

        @keyframes phasePulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }

        /* Motion vector display */
        .motion-vector {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            width: var(--fib89);
            height: var(--fib89);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .motion-dot {
            width: var(--fib8);
            height: var(--fib8);
            background: rgba(255,255,255,0.618);
            border-radius: 50%;
            position: absolute;
            transition: all 0.1s ease;
        }

        /* Layer grid - visual representation of samples */
        .layer-grid {
            position: fixed;
            bottom: var(--fib55);
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(4, var(--fib55));
            grid-template-rows: repeat(2, var(--fib34));
            gap: var(--fib8);
        }

        .layer-cell {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
            transition: all 0.382s ease;
        }

        .layer-cell.active {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.08);
        }

        .layer-cell.recording {
            animation: cellRecord 1s ease-in-out infinite;
        }

        @keyframes cellRecord {
            0%, 100% { background: rgba(255,0,0,0.1); }
            50% { background: rgba(255,0,0,0.3); }
        }

        .layer-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        /* BPM and timing */
        .timing-info {
            position: fixed;
            bottom: var(--fib34);
            right: var(--fib34);
            text-align: right;
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
        }

        .bpm-value {
            font-size: var(--fib21);
            opacity: 0.618;
        }

        /* Build energy bar */
        .energy-bar {
            position: fixed;
            left: var(--fib21);
            top: 50%;
            transform: translateY(-50%);
            width: var(--fib8);
            height: var(--fib144);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.618s ease;
        }

        .energy-bar.active {
            opacity: 0.618;
        }

        .energy-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #8a2be2, #ff0000, #ff8c00);
            height: 0%;
            transition: height 0.1s ease;
        }

        /* Sample trigger zones */
        .trigger-zone {
            position: fixed;
            border: 1px dashed rgba(255,255,255,0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.382s ease;
        }

        .trigger-zone.active {
            opacity: 1;
            animation: zoneGlow 2s ease-in-out infinite;
        }

        @keyframes zoneGlow {
            0%, 100% { box-shadow: 0 0 var(--fib13) rgba(255,255,255,0.2); }
            50% { box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.4); }
        }

        /* Canvas */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #visualizer { z-index: 1; opacity: 0.3; }
        #particles { z-index: 2; opacity: 0.5; }
        #spiral { z-index: 0; opacity: 0.05; }

        /* Instructions */
        .instructions {
            position: fixed;
            top: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            transition: opacity 0.618s ease;
            text-align: center;
        }

        .instructions.show {
            opacity: 0.618;
        }
    </style>
</head>
<body>
    <div class="cursor" id="cursor"></div>
    
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
    
    <div class="title">Gump by James McCandless</div>
    
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
    
    <div class="interface" id="interface">
        <div class="input-meter">
            <div class="input-level" id="inputLevel"></div>
        </div>
        
        <div class="phase-indicator" id="phaseIndicator">INITIALIZING</div>
        
        <div class="instructions" id="instructions">MOVE TO SAMPLE • STILLNESS TO BUILD</div>
        
        <div class="motion-vector">
            <div class="motion-dot" id="motionDot"></div>
        </div>
        
        <div class="layer-grid" id="layerGrid">
            <!-- 8 cells will be created -->
        </div>
        
        <div class="timing-info">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">128</div>
        </div>
        
        <div class="energy-bar" id="energyBar">
            <div class="energy-fill" id="energyFill"></div>
        </div>
        
        <!-- Invisible trigger zones -->
        <div class="trigger-zone" id="zone0"></div>
        <div class="trigger-zone" id="zone1"></div>
        <div class="trigger-zone" id="zone2"></div>
        <div class="trigger-zone" id="zone3"></div>
    </div>

    <script>
        // Gump Active Sampling Engine
        class GumpActiveSampler {
            constructor() {
                // Audio context
                this.ctx = null;
                this.masterOut = null;
                
                // Circular buffer for continuous recording
                this.circularBuffer = {
                    size: 0, // Will be set to 10 seconds
                    data: null,
                    writeIndex: 0,
                    isRecording: false
                };
                
                // Real-time analysis
                this.realtime = {
                    inputNode: null,
                    analyser: null,
                    processor: null,
                    inputLevel: 0,
                    beatDetector: null,
                    lastBeatTime: 0
                };
                
                // Motion tracking with immediate response
                this.motion = {
                    x: 0.5,
                    y: 0.5,
                    velocity: 0,
                    lastX: 0.5,
                    lastY: 0.5,
                    lastTime: 0,
                    isMoving: false,
                    stillnessTime: 0,
                    captureThreshold: 0.3
                };
                
                // Sample layers
                this.layers = Array(8).fill(null).map(() => ({
                    buffer: null,
                    isActive: false,
                    source: null,
                    gain: null,
                    filter: null,
                    pattern: null,
                    type: null
                }));
                
                // Musical state
                this.musical = {
                    bpm: 128,
                    currentBeat: 0,
                    nextBeatTime: 0,
                    phase: 'collecting', // collecting, building, dropping, void
                    energy: 0,
                    scale: [0, 3, 5, 7, 10], // Pentatonic for easy harmony
                    key: 60 // Middle C
                };
                
                // AI DJ Brain
                this.ai = {
                    layerCount: 0,
                    buildStartTime: 0,
                    dropScheduled: false,
                    arrangement: [],
                    sampleMemory: []
                };
                
                // Effects
                this.fx = {
                    reverb: null,
                    delay: null,
                    compressor: null,
                    filter: null
                };
                
                // Visual elements
                this.ui = {};
                this.canvases = {};
                
                // Trigger zones for spatial sampling
                this.zones = [];
                
                this.init();
            }
            
            init() {
                // Get UI elements
                this.ui = {
                    start: document.getElementById('start'),
                    interface: document.getElementById('interface'),
                    cursor: document.getElementById('cursor'),
                    inputLevel: document.getElementById('inputLevel'),
                    phaseIndicator: document.getElementById('phaseIndicator'),
                    instructions: document.getElementById('instructions'),
                    motionDot: document.getElementById('motionDot'),
                    layerGrid: document.getElementById('layerGrid'),
                    bpmValue: document.getElementById('bpmValue'),
                    energyBar: document.getElementById('energyBar'),
                    energyFill: document.getElementById('energyFill')
                };
                
                // Create layer cells
                for (let i = 0; i < 8; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'layer-cell';
                    cell.dataset.index = i;
                    const canvas = document.createElement('canvas');
                    canvas.className = 'layer-waveform';
                    canvas.width = 55;
                    canvas.height = 34;
                    cell.appendChild(canvas);
                    this.ui.layerGrid.appendChild(cell);
                }
                
                // Setup canvases
                ['spiral', 'visualizer', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d'),
                        width: window.innerWidth,
                        height: window.innerHeight
                    };
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
                
                // Create trigger zones
                this.createTriggerZones();
                
                // Mouse tracking from the start
                this.setupMouseTracking();
                
                // Start button
                this.ui.start.addEventListener('click', () => this.begin());
                
                // Draw fibonacci spiral
                this.drawSpiral();
            }
            
            setupMouseTracking() {
                let mouseTimer;
                
                document.addEventListener('mousemove', (e) => {
                    // Update cursor position
                    this.ui.cursor.style.left = e.clientX + 'px';
                    this.ui.cursor.style.top = e.clientY + 'px';
                    
                    // Calculate motion
                    const now = performance.now();
                    const dt = (now - this.motion.lastTime) / 1000;
                    
                    const newX = e.clientX / window.innerWidth;
                    const newY = e.clientY / window.innerHeight;
                    
                    const dx = newX - this.motion.lastX;
                    const dy = newY - this.motion.lastY;
                    
                    this.motion.velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                    this.motion.x = newX;
                    this.motion.y = newY;
                    
                    this.motion.lastX = newX;
                    this.motion.lastY = newY;
                    this.motion.lastTime = now;
                    
                    // Reset stillness
                    this.motion.isMoving = true;
                    this.motion.stillnessTime = 0;
                    clearTimeout(mouseTimer);
                    
                    mouseTimer = setTimeout(() => {
                        this.motion.isMoving = false;
                    }, 100);
                    
                    // Update motion dot
                    if (this.ui.motionDot) {
                        this.ui.motionDot.style.transform = `translate(${(newX - 0.5) * 80}px, ${(newY - 0.5) * 80}px)`;
                    }
                });
            }
            
            createTriggerZones() {
                // Create 4 zones in corners
                const positions = [
                    { top: '10%', left: '10%', width: '20%', height: '20%' },
                    { top: '10%', right: '10%', width: '20%', height: '20%' },
                    { bottom: '10%', left: '10%', width: '20%', height: '20%' },
                    { bottom: '10%', right: '10%', width: '20%', height: '20%' }
                ];
                
                positions.forEach((pos, i) => {
                    const zone = document.getElementById(`zone${i}`);
                    Object.assign(zone.style, pos);
                    this.zones.push({
                        element: zone,
                        index: i,
                        lastTrigger: 0
                    });
                });
            }
            
            async begin() {
                this.ui.start.style.display = 'none';
                
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });
                    
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    // Setup audio chain
                    await this.setupAudio(stream);
                    
                    // Show interface
                    this.ui.interface.classList.add('active');
                    this.ui.instructions.classList.add('show');
                    
                    // Start the engine!
                    this.startEngine();
                    
                } catch (error) {
                    console.error('Setup failed:', error);
                    alert('Microphone access required. Please reload and allow access.');
                }
            }
            
            async setupAudio(stream) {
                // Input from microphone
                this.realtime.inputNode = this.ctx.createMediaStreamSource(stream);
                
                // Analyser for visualization
                this.realtime.analyser = this.ctx.createAnalyser();
                this.realtime.analyser.fftSize = 2048;
                this.realtime.analyser.smoothingTimeConstant = 0.8;
                
                // Create circular buffer (10 seconds)
                this.circularBuffer.size = this.ctx.sampleRate * 10;
                this.circularBuffer.data = new Float32Array(this.circularBuffer.size);
                
                // Script processor for recording
                this.realtime.processor = this.ctx.createScriptProcessor(2048, 1, 1);
                this.realtime.processor.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    this.processRealtimeAudio(input);
                };
                
                // Master output with effects
                this.setupEffects();
                
                // Connect input chain
                this.realtime.inputNode.connect(this.realtime.analyser);
                this.realtime.inputNode.connect(this.realtime.processor);
                this.realtime.processor.connect(this.ctx.destination); // Required for processor
                
                // Start recording immediately
                this.circularBuffer.isRecording = true;
            }
            
            setupEffects() {
                // Master compressor
                this.fx.compressor = this.ctx.createDynamicsCompressor();
                this.fx.compressor.threshold.value = -12;
                this.fx.compressor.knee.value = 3;
                this.fx.compressor.ratio.value = 6;
                
                // Reverb
                this.fx.reverb = this.ctx.createConvolver();
                const reverbTime = 2;
                const reverbDecay = 3;
                const impulseSamples = this.ctx.sampleRate * reverbTime;
                const impulse = this.ctx.createBuffer(2, impulseSamples, this.ctx.sampleRate);
                
                for (let ch = 0; ch < 2; ch++) {
                    const channelData = impulse.getChannelData(ch);
                    for (let i = 0; i < impulseSamples; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseSamples, reverbDecay);
                    }
                }
                this.fx.reverb.buffer = impulse;
                
                // Delay
                this.fx.delay = this.ctx.createDelay(1);
                this.fx.delay.delayTime.value = 60 / this.musical.bpm / 8; // 1/8 note
                
                this.fx.delayFeedback = this.ctx.createGain();
                this.fx.delayFeedback.gain.value = 0.4;
                
                this.fx.delayGain = this.ctx.createGain();
                this.fx.delayGain.gain.value = 0.3;
                
                // Master filter
                this.fx.filter = this.ctx.createBiquadFilter();
                this.fx.filter.type = 'lowpass';
                this.fx.filter.frequency.value = 20000;
                
                // Connect delay feedback
                this.fx.delay.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delay);
                this.fx.delay.connect(this.fx.delayGain);
                
                // Master output
                this.masterOut = this.ctx.createGain();
                this.masterOut.gain.value = 0.8;
                
                // Master chain
                this.masterOut.connect(this.fx.filter);
                this.fx.filter.connect(this.fx.compressor);
                this.fx.compressor.connect(this.ctx.destination);
                
                // Send to effects
                this.fx.reverbSend = this.ctx.createGain();
                this.fx.reverbSend.gain.value = 0.2;
                this.masterOut.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb);
                this.fx.reverb.connect(this.ctx.destination);
                
                this.fx.delaySend = this.ctx.createGain();
                this.fx.delaySend.gain.value = 0.15;
                this.masterOut.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delay);
                this.fx.delayGain.connect(this.ctx.destination);
            }
            
            processRealtimeAudio(input) {
                // Write to circular buffer
                for (let i = 0; i < input.length; i++) {
                    this.circularBuffer.data[this.circularBuffer.writeIndex] = input[i];
                    this.circularBuffer.writeIndex = (this.circularBuffer.writeIndex + 1) % this.circularBuffer.size;
                }
                
                // Calculate input level
                let sum = 0;
                for (let i = 0; i < input.length; i++) {
                    sum += Math.abs(input[i]);
                }
                this.realtime.inputLevel = sum / input.length;
                
                // Update UI
                const levelPercent = Math.min(100, this.realtime.inputLevel * 500);
                this.ui.inputLevel.style.width = levelPercent + '%';
                
                // Beat detection
                this.detectBeat(input);
            }
            
            detectBeat(input) {
                // Simple energy-based beat detection
                let energy = 0;
                for (let i = 0; i < input.length; i++) {
                    energy += input[i] * input[i];
                }
                energy = Math.sqrt(energy / input.length);
                
                const now = this.ctx.currentTime;
                if (energy > this.realtime.inputLevel * 3 && now - this.realtime.lastBeatTime > 0.1) {
                    this.realtime.lastBeatTime = now;
                    // Could sync BPM here
                }
            }
            
            startEngine() {
                // Start the musical clock
                this.startScheduler();
                
                // Start motion tracking
                this.trackMotion();
                
                // Start visualization
                this.animate();
                
                // Show instructions
                setTimeout(() => {
                    this.ui.instructions.textContent = 'MOVE TO CREATE • EXPLORE THE SPACE';
                }, 3000);
            }
            
            startScheduler() {
                const schedule = () => {
                    const now = this.ctx.currentTime;
                    
                    while (this.musical.nextBeatTime < now + 0.1) {
                        this.onBeat();
                        this.musical.nextBeatTime += 60 / this.musical.bpm / 4; // 16th notes
                        this.musical.currentBeat++;
                    }
                    
                    setTimeout(schedule, 25);
                };
                
                this.musical.nextBeatTime = this.ctx.currentTime;
                schedule();
            }
            
            onBeat() {
                const beat = this.musical.currentBeat;
                const bar = Math.floor(beat / 16);
                
                // Play active layers
                this.layers.forEach((layer, i) => {
                    if (layer.isActive && layer.pattern) {
                        const step = beat % 16;
                        if (layer.pattern[step]) {
                            this.triggerLayer(i);
                        }
                    }
                });
                
                // Update energy
                if (this.musical.phase === 'building') {
                    this.musical.energy = Math.min(1, (bar - this.ai.buildStartTime) / 8);
                    this.ui.energyFill.style.height = (this.musical.energy * 100) + '%';
                    
                    // Check for drop
                    if (this.musical.energy >= 1 && !this.ai.dropScheduled) {
                        this.ai.dropScheduled = true;
                        this.scheduleDrop();
                    }
                }
                
                // Generate atmospheric elements
                if (beat % 64 === 0) {
                    this.generateAtmosphere();
                }
            }
            
            trackMotion() {
                const track = () => {
                    // Check if moving through zones
                    if (this.motion.isMoving && this.motion.velocity > this.motion.captureThreshold) {
                        this.checkZoneTriggers();
                    } else {
                        // Track stillness
                        this.motion.stillnessTime += 50;
                        
                        // After 2 seconds of stillness, capture ambient
                        if (this.motion.stillnessTime > 2000 && this.ai.layerCount < 8) {
                            this.captureAmbient();
                            this.motion.stillnessTime = 0;
                        }
                    }
                    
                    // Update phase based on layers
                    this.updatePhase();
                    
                    setTimeout(track, 50);
                };
                
                track();
            }
            
            checkZoneTriggers() {
                const now = Date.now();
                const x = this.motion.x * window.innerWidth;
                const y = this.motion.y * window.innerHeight;
                
                this.zones.forEach((zone, i) => {
                    const rect = zone.element.getBoundingClientRect();
                    
                    if (x >= rect.left && x <= rect.right && 
                        y >= rect.top && y <= rect.bottom) {
                        
                        // Trigger if not recently triggered
                        if (now - zone.lastTrigger > 1000) {
                            zone.lastTrigger = now;
                            zone.element.classList.add('active');
                            this.captureSample(i);
                            
                            setTimeout(() => {
                                zone.element.classList.remove('active');
                            }, 500);
                        }
                    }
                });
            }
            
            captureSample(zoneIndex) {
                // Visual feedback
                this.ui.cursor.classList.add('sampling');
                setTimeout(() => this.ui.cursor.classList.remove('sampling'), 500);
                
                // Find next empty layer
                let targetLayer = -1;
                for (let i = 0; i < 8; i++) {
                    if (!this.layers[i].isActive) {
                        targetLayer = i;
                        break;
                    }
                }
                
                if (targetLayer === -1) {
                    // Replace oldest
                    targetLayer = this.ai.sampleMemory.shift();
                }
                
                // Capture from circular buffer based on motion
                const captureLength = Math.floor(this.ctx.sampleRate * (0.5 + Math.random() * 2)); // 0.5-2.5 seconds
                const captureData = new Float32Array(captureLength);
                
                // Get recent audio with some randomness
                const offset = Math.floor(Math.random() * this.ctx.sampleRate * 2); // Up to 2 seconds back
                const startIndex = (this.circularBuffer.writeIndex - captureLength - offset + this.circularBuffer.size) % this.circularBuffer.size;
                
                for (let i = 0; i < captureLength; i++) {
                    const idx = (startIndex + i) % this.circularBuffer.size;
                    captureData[i] = this.circularBuffer.data[idx];
                }
                
                // Process and store
                this.processCapture(captureData, targetLayer, zoneIndex);
            }
            
            captureAmbient() {
                // Similar to captureSample but for ambient stillness
                let targetLayer = -1;
                for (let i = 0; i < 8; i++) {
                    if (!this.layers[i].isActive) {
                        targetLayer = i;
                        break;
                    }
                }
                
                if (targetLayer === -1) return;
                
                // Longer ambient captures
                const captureLength = Math.floor(this.ctx.sampleRate * (2 + Math.random() * 2)); // 2-4 seconds
                const captureData = new Float32Array(captureLength);
                
                const startIndex = (this.circularBuffer.writeIndex - captureLength + this.circularBuffer.size) % this.circularBuffer.size;
                
                for (let i = 0; i < captureLength; i++) {
                    const idx = (startIndex + i) % this.circularBuffer.size;
                    captureData[i] = this.circularBuffer.data[idx];
                }
                
                this.processCapture(captureData, targetLayer, -1); // -1 for ambient
            }
            
            processCapture(data, layerIndex, zoneIndex) {
                // Create buffer
                const buffer = this.ctx.createBuffer(1, data.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(data);
                
                // Quick analysis
                let maxVal = 0;
                let energy = 0;
                for (let i = 0; i < data.length; i++) {
                    maxVal = Math.max(maxVal, Math.abs(data[i]));
                    energy += data[i] * data[i];
                }
                
                // Normalize
                if (maxVal > 0) {
                    const scale = 0.8 / maxVal;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= scale;
                    }
                }
                
                // Determine type based on zone or analysis
                const types = ['kick', 'snare', 'hat', 'bass', 'pad', 'lead', 'fx', 'ambient'];
                const type = zoneIndex >= 0 ? types[zoneIndex % types.length] : 'ambient';
                
                // Generate pattern based on type and phase
                const pattern = this.generatePattern(type);
                
                // Setup layer
                const layer = this.layers[layerIndex];
                layer.buffer = buffer;
                layer.isActive = true;
                layer.type = type;
                layer.pattern = pattern;
                
                // Create audio nodes
                layer.gain = this.ctx.createGain();
                layer.gain.gain.value = 0.7;
                
                layer.filter = this.ctx.createBiquadFilter();
                layer.filter.type = 'lowpass';
                layer.filter.frequency.value = 2000;
                
                // Connect
                layer.gain.connect(layer.filter);
                layer.filter.connect(this.masterOut);
                
                // Update UI
                const cell = this.ui.layerGrid.children[layerIndex];
                cell.classList.add('active');
                this.drawWaveform(cell.querySelector('canvas'), data);
                
                // Track
                this.ai.layerCount++;
                this.ai.sampleMemory.push(layerIndex);
                if (this.ai.sampleMemory.length > 8) {
                    this.ai.sampleMemory.shift();
                }
            }
            
            generatePattern(type) {
                const patterns = {
                    kick: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
                    snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
                    hat: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                    bass: [1,0,0,1, 0,0,1,0, 1,0,0,0, 1,0,1,0],
                    pad: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
                    lead: [0,0,0,0, 1,0,0,0, 0,0,1,0, 0,0,0,0],
                    fx: [0,0,0,1, 0,0,0,0, 0,1,0,0, 0,0,0,0],
                    ambient: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0]
                };
                
                // Modify based on phase
                if (this.musical.phase === 'dropping') {
                    // More intense patterns
                    return patterns[type].map((step, i) => i % 2 === 0 ? 1 : step);
                } else if (this.musical.phase === 'void') {
                    // Sparse patterns
                    return patterns[type].map(step => Math.random() > 0.7 ? step : 0);
                }
                
                return patterns[type] || patterns.ambient;
            }
            
            triggerLayer(index) {
                const layer = this.layers[index];
                if (!layer.buffer || !layer.isActive) return;
                
                const source = this.ctx.createBufferSource();
                source.buffer = layer.buffer;
                
                // Apply phase-based processing
                if (this.musical.phase === 'dropping') {
                    source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.1;
                    layer.filter.frequency.value = 500 + Math.random() * 3000;
                    layer.filter.Q.value = 5 + Math.random() * 10;
                } else if (this.musical.phase === 'void') {
                    source.playbackRate.value = 0.5 + Math.random() * 0.3;
                    layer.filter.frequency.value = 200 + Math.random() * 500;
                }
                
                source.connect(layer.gain);
                source.start();
                
                // Visual feedback
                const cell = this.ui.layerGrid.children[index];
                cell.classList.add('recording');
                setTimeout(() => cell.classList.remove('recording'), 100);
            }
            
            updatePhase() {
                const oldPhase = this.musical.phase;
                
                if (this.ai.layerCount < 2) {
                    this.musical.phase = 'collecting';
                } else if (this.ai.layerCount < 4) {
                    if (oldPhase === 'collecting') {
                        this.musical.phase = 'building';
                        this.ai.buildStartTime = Math.floor(this.musical.currentBeat / 16);
                        this.ui.energyBar.classList.add('active');
                    }
                } else if (this.ai.layerCount >= 6 && this.musical.energy >= 1) {
                    this.musical.phase = 'void';
                }
                
                // Update UI
                if (oldPhase !== this.musical.phase) {
                    this.ui.phaseIndicator.textContent = this.musical.phase.toUpperCase();
                    this.ui.phaseIndicator.className = 'phase-indicator ' + this.musical.phase;
                    
                    // Phase-specific changes
                    if (this.musical.phase === 'building') {
                        this.createBuildEffects();
                    } else if (this.musical.phase === 'void') {
                        this.createVoidEffects();
                    }
                }
            }
            
            createBuildEffects() {
                // Rising sweep
                const sweep = this.ctx.createOscillator();
                const sweepGain = this.ctx.createGain();
                
                sweep.type = 'sawtooth';
                sweep.frequency.setValueAtTime(100, this.ctx.currentTime);
                sweep.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 8);
                
                sweepGain.gain.setValueAtTime(0, this.ctx.currentTime);
                sweepGain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 8);
                
                sweep.connect(sweepGain);
                sweepGain.connect(this.fx.filter);
                
                sweep.start();
                sweep.stop(this.ctx.currentTime + 8);
            }
            
            scheduleDrop() {
                setTimeout(() => {
                    this.musical.phase = 'dropping';
                    this.ui.phaseIndicator.textContent = 'DROP!';
                    this.ui.energyBar.classList.remove('active');
                    
                    // Drop impact
                    this.createDropImpact();
                    
                    // Change all patterns to intense
                    this.layers.forEach(layer => {
                        if (layer.isActive) {
                            layer.pattern = layer.pattern.map((_, i) => i % 2 === 0 ? 1 : Math.random() > 0.3 ? 1 : 0);
                        }
                    });
                    
                    // Bass wobble
                    this.createWobbleBass();
                    
                }, 1000);
            }
            
            createDropImpact() {
                // Sub drop
                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                
                sub.type = 'sine';
                sub.frequency.setValueAtTime(80, this.ctx.currentTime);
                sub.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 2);
                
                subGain.gain.setValueAtTime(1, this.ctx.currentTime);
                subGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 2);
                
                sub.connect(subGain);
                subGain.connect(this.masterOut);
                
                sub.start();
                sub.stop(this.ctx.currentTime + 2);
            }
            
            createWobbleBass() {
                const bass = this.ctx.createOscillator();
                const bassFilter = this.ctx.createBiquadFilter();
                const bassGain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                
                bass.type = 'sawtooth';
                bass.frequency.value = 55;
                
                bassFilter.type = 'lowpass';
                bassFilter.Q.value = 15;
                
                lfo.type = 'sine';
                lfo.frequency.value = 4; // 4Hz wobble
                
                lfoGain.gain.value = 800;
                
                bassGain.gain.value = 0.5;
                
                // Connect LFO to filter
                lfo.connect(lfoGain);
                lfoGain.connect(bassFilter.frequency);
                
                // Connect bass
                bass.connect(bassFilter);
                bassFilter.connect(bassGain);
                bassGain.connect(this.masterOut);
                
                bass.start();
                lfo.start();
                
                // Stop after 16 bars
                const stopTime = this.ctx.currentTime + (16 * 4 * 60 / this.musical.bpm);
                bass.stop(stopTime);
                lfo.stop(stopTime);
            }
            
            createVoidEffects() {
                // Dark reverb increase
                this.fx.reverbSend.gain.value = 0.6;
                
                // Low pass everything
                this.fx.filter.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 2);
                
                // Slow down delay
                this.fx.delay.delayTime.value = 60 / this.musical.bpm / 2; // Half note
                
                // Dark drone
                const drone = this.ctx.createOscillator();
                const droneGain = this.ctx.createGain();
                
                drone.type = 'triangle';
                drone.frequency.value = 27.5; // Low A
                droneGain.gain.value = 0.2;
                
                drone.connect(droneGain);
                droneGain.connect(this.fx.reverb);
                
                drone.start();
            }
            
            generateAtmosphere() {
                if (this.musical.phase === 'collecting') return;
                
                const note = this.musical.scale[Math.floor(Math.random() * this.musical.scale.length)];
                const freq = 440 * Math.pow(2, (this.musical.key + note - 69) / 12);
                
                const osc = this.ctx.createOscillator();
                const env = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.value = freq;
                
                const now = this.ctx.currentTime;
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(0.05, now + 0.5);
                env.gain.exponentialRampToValueAtTime(0.001, now + 3);
                
                osc.connect(env);
                env.connect(this.fx.reverbSend);
                
                osc.start(now);
                osc.stop(now + 3);
            }
            
            drawWaveform(canvas, data) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                
                const step = Math.ceil(data.length / width);
                
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    const sample = data[i * step] || 0;
                    const y = (1 + sample) * height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
            }
            
            drawSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                
                let r = 0;
                let angle = 0;
                
                ctx.beginPath();
                for (let i = 0; i < 500; i++) {
                    r = i * 0.5;
                    angle = i * 0.1;
                    
                    const x = centerX + r * Math.cos(angle);
                    const y = centerY + r * Math.sin(angle);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                ctx.stroke();
            }
            
            animate() {
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    this.drawVisualizer();
                    this.drawParticles();
                };
                
                draw();
            }
            
            drawVisualizer() {
                const { ctx, canvas } = this.canvases.visualizer;
                const freq = new Uint8Array(this.realtime.analyser.frequencyBinCount);
                this.realtime.analyser.getByteFrequencyData(freq);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / freq.length * 2;
                
                for (let i = 0; i < freq.length; i++) {
                    const height = freq[i] / 255 * canvas.height * 0.7;
                    const hue = (i / freq.length) * 360 + this.musical.currentBeat;
                    
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                    ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 1, height);
                }
            }
            
            drawParticles() {
                const { ctx, canvas } = this.canvases.particles;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const time = Date.now() * 0.001;
                const count = 8 + this.ai.layerCount * 3;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + time * 0.1;
                    const radius = 100 + Math.sin(time + i) * 50;
                    
                    const x = this.motion.x * canvas.width + Math.cos(angle) * radius * this.motion.velocity;
                    const y = this.motion.y * canvas.height + Math.sin(angle) * radius * this.motion.velocity;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 2 + this.musical.energy * 3, 0, Math.PI * 2);
                    
                    let color;
                    switch (this.musical.phase) {
                        case 'building':
                            color = `rgba(255, ${140 + this.musical.energy * 115}, 0, 0.8)`;
                            break;
                        case 'dropping':
                            color = `rgba(255, 0, ${Math.sin(time * 10) * 127 + 128}, 0.8)`;
                            break;
                        case 'void':
                            color = 'rgba(138, 43, 226, 0.6)';
                            break;
                        default:
                            color = 'rgba(255, 255, 255, 0.5)';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }
        
        // Start Gump
        const gump = new GumpActiveSampler();
    </script>
</body>
</html>
