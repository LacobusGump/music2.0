<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>VIBE Core - Fibonacci Environmental Synthesis</title>
  <style>
    :root {
      --phi: 1.618;
      --fib1: 1px;
      --fib2: 1px;
      --fib3: 2px;
      --fib5: 3px;
      --fib8: 5px;
      --fib13: 8px;
      --fib21: 13px;
      --fib34: 21px;
      --core: #f5f5f5;
      --accent: #333;
      --subtle: #666;
      --bg: #fafafa;
      --glass: rgba(255, 255, 255, 0.8);
      --border: rgba(0, 0, 0, 0.05);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg);
      color: var(--accent);
      font-family: 'Helvetica Neue', Arial, sans-serif;
      overflow: hidden;
      height: 100vh;
      position: relative;
    }

    #initCore {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--core), #e0e0e0);
      z-index: 1000;
      transition: opacity 0.8s ease;
    }

    .core-btn {
      width: calc(21 * var(--fib21));
      height: calc(21 * var(--fib21));
      border-radius: calc(10.5 * var(--fib21));
      background: var(--glass);
      border: var(--fib3) solid var(--border);
      color: var(--accent);
      font-size: calc(8 * var(--fib8));
      letter-spacing: calc(2 * var(--fib5));
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .core-btn:hover {
      border-color: var(--accent);
      transform: scale(1.02);
    }

    #canvasCore {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }

    .phi-orb {
      position: absolute;
      width: calc(5 * var(--fib13));
      height: calc(5 * var(--fib13));
      border-radius: 50%;
      background: radial-gradient(circle, var(--accent), transparent);
      opacity: 0.3;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
    }

    .core-panel {
      position: fixed;
      background: var(--glass);
      border: var(--fib2) solid var(--border);
      border-radius: calc(3 * var(--fib5));
      padding: calc(5 * var(--fib8));
      font-size: calc(6 * var(--fib5));
      letter-spacing: calc(1 * var(--fib3));
      z-index: 100;
      width: calc(34 * var(--fib34) * 0.618); /* Golden ratio */
      box-shadow: 0 calc(2 * var(--fib13)) calc(5 * var(--fib21)) rgba(0,0,0,0.05);
    }

    .core-panel.top-left { top: calc(5 * var(--fib13)); left: calc(5 * var(--fib13)); }
    .core-panel.top-right { top: calc(5 * var(--fib13)); right: calc(5 * var(--fib13)); }
    .core-panel.bottom-left { bottom: calc(5 * var(--fib13)); left: calc(5 * var(--fib13)); }
    .core-panel.bottom-right { bottom: calc(5 * var(--fib13)); right: calc(5 * var(--fib13)); }

    .panel-head {
      font-size: calc(5 * var(--fib5));
      opacity: 0.6;
      margin-bottom: calc(3 * var(--fib8));
      text-transform: uppercase;
      letter-spacing: calc(2 * var(--fib5));
    }

    .phi-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: calc(2 * var(--fib5)) 0;
    }

    .metric-val {
      font-weight: 500;
    }

    .fib-bar {
      height: var(--fib3);
      background: var(--border);
      border-radius: var(--fib2);
      overflow: hidden;
      margin: calc(3 * var(--fib5)) 0;
    }

    .bar-fill {
      height: 100%;
      background: var(--accent);
      transition: width 0.2s ease;
    }

    .phi-spectrum {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: calc(8 * var(--fib21));
      display: flex;
      align-items: flex-end;
      justify-content: space-around;
      padding: 0 calc(5 * var(--fib13));
      pointer-events: none;
    }

    .spectrum-bar {
      flex: 1;
      background: var(--accent);
      border-radius: var(--fib2) var(--fib2) 0 0;
      transition: height 0.05s ease;
      opacity: 0.7;
      margin: 0 calc(1 * var(--fib3));
    }

    .env-fib {
      position: fixed;
      top: 50%;
      left: calc(5 * var(--fib13));
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: calc(3 * var(--fib8));
    }

    .fib-btn {
      width: calc(8 * var(--fib13));
      height: calc(8 * var(--fib13));
      border-radius: 50%;
      background: var(--glass);
      border: var(--fib2) solid var(--border);
      color: var(--accent);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
      font-size: calc(5 * var(--fib8));
    }

    .fib-btn:hover, .fib-btn.active {
      border-color: var(--accent);
    }

    .particle-fib {
      position: absolute;
      width: var(--fib5);
      height: var(--fib5);
      background: var(--accent);
      border-radius: 50%;
      pointer-events: none;
      opacity: 0.5;
      animation: fib-float 2s ease-out forwards;
    }

    @keyframes fib-float {
      to { transform: translateY(-100vh); opacity: 0; }
    }

    .fib-mode {
      position: fixed;
      top: 50%;
      right: calc(5 * var(--fib13));
      transform: translateY(-50%);
      font-size: calc(5 * var(--fib5));
      opacity: 0.4;
      writing-mode: vertical-rl;
      letter-spacing: calc(1 * var(--fib5));
    }

    .hidden { display: none !important; }
  </style>
</head>
<body>
  <div id="initCore">
    <button class="core-btn" id="coreBtn">SYNTHESIZE</button>
    <p style="margin-top: calc(5 * var(--fib13)); opacity: 0.6; font-size: calc(5 * var(--fib5)); letter-spacing: calc(1 * var(--fib3));">FIBONACCI SOUNDSCAPE</p>
  </div>

  <canvas id="canvasCore"></canvas>

  <div class="core-panel top-left hidden" id="audioCore">
    <div class="panel-head">Audio Core</div>
    <div class="phi-metric">
      <span>Volume</span>
      <span class="metric-val" id="volumeVal">0.70</span>
    </div>
    <div class="fib-bar">
      <div class="bar-fill" id="volumeBar"></div>
    </div>
    <div class="phi-metric">
      <span>Compression</span>
      <span class="metric-val" id="compVal">0dB</span>
    </div>
    <div class="phi-metric">
      <span>Voices</span>
      <span class="metric-val" id="voicesVal">0</span>
    </div>
    <div class="phi-metric">
      <span>Load</span>
      <span class="metric-val" id="loadVal">0%</span>
    </div>
  </div>

  <div class="core-panel top-right hidden" id="envCore">
    <div class="panel-head">Environment</div>
    <div class="phi-metric">
      <span>Motion</span>
      <span class="metric-val" id="motionVal">0.00</span>
    </div>
    <div class="fib-bar">
      <div class="bar-fill" id="motionBar"></div>
    </div>
    <div class="phi-metric">
      <span>Ambient</span>
      <span class="metric-val" id="ambientVal">0dB</span>
    </div>
    <div class="phi-metric">
      <span>Samples</span>
      <span class="metric-val" id="samplesVal">0</span>
    </div>
  </div>

  <div class="core-panel bottom-left hidden" id="synthCore">
    <div class="panel-head">Synthesis</div>
    <div class="phi-metric">
      <span>Mode</span>
      <span class="metric-val" id="modeVal">HYBRID</span>
    </div>
    <div class="phi-metric">
      <span>Key</span>
      <span class="metric-val" id="keyVal">C MAJ</span>
    </div>
    <div class="phi-metric">
      <span>BPM</span>
      <span class="metric-val" id="bpmVal">120</span>
    </div>
    <div class="phi-metric">
      <span>Harmonics</span>
      <span class="metric-val" id="harmVal">4</span>
    </div>
  </div>

  <div class="core-panel bottom-right hidden" id="mixCore">
    <div class="panel-head">Mix</div>
    <div class="phi-metric">
      <span>Low</span>
      <span class="metric-val" id="lowVal">0dB</span>
    </div>
    <div class="phi-metric">
      <span>Mid</span>
      <span class="metric-val" id="midVal">0dB</span>
    </div>
    <div class="phi-metric">
      <span>High</span>
      <span class="metric-val" id="highVal">0dB</span>
    </div>
    <div class="phi-metric">
      <span>Spatial</span>
      <span class="metric-val" id="spatialVal">50%</span>
    </div>
  </div>

  <div class="env-fib hidden" id="envFib">
    <button class="fib-btn" id="micFib" title="Sample Mic">üé§</button>
    <button class="fib-btn" id="recFib" title="Record">‚è∫</button>
    <button class="fib-btn" id="grainFib" title="Granular">‚ö°</button>
  </div>

  <div class="phi-spectrum" id="phiSpectrum"></div>

  <div class="fib-mode hidden" id="fibMode">FIBONACCI</div>

  <div class="phi-orb" id="phiOrb" style="display: none;"></div>

  <script>
    class FibonacciVoicePool {
      constructor(ctx, input) {
        this.ctx = ctx;
        this.input = input;
        this.pool = new Map();
        this.maxVoices = 32;
      }

      acquire(id, config = {}) {
        if (this.pool.size >= this.maxVoices) {
          const oldestId = this.pool.keys().next().value;
          this.release(oldestId);
        }
        const voice = this.createVoice(config);
        this.pool.set(id, { voice, config, time: performance.now() });
        return voice.output;
      }

      release(id) {
        const entry = this.pool.get(id);
        if (entry) {
          entry.voice.osc.stop();
          this.pool.delete(id);
        }
      }

      createVoice({ type = 'sine', freq, duration = 0.5, amp = 0.2, attack = 0.01, release = 0.1 }) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        osc.type = type;
        osc.frequency.setValueAtTime(freq || 440, this.ctx.currentTime);

        filter.type = 'lowpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1;

        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(amp, this.ctx.currentTime + attack);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration + release);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.input);

        osc.start();
        osc.stop(this.ctx.currentTime + duration + release);

        return { osc, gain, filter };
      }

      getCount() {
        return this.pool.size;
      }
    }

    class FibonacciSequencer {
      constructor(ctx, voicePool, key = 'C', mode = 'major', bpm = 120) {
        this.ctx = ctx;
        this.voicePool = voicePool;
        this.key = key;
        this.mode = mode;
        this.bpm = bpm;
        this.scale = this.generateScale();
        this.nextTime = 0;
      }

      generateScale() {
        const offsets = this.mode === 'major' ? [0, 2, 4, 5, 7, 9, 11] : [0, 2, 3, 5, 7, 8, 10];
        const keyOffset = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'].indexOf(this.key);
        return offsets.map(o => 261.63 * Math.pow(2, (o + keyOffset) / 12));
      }

      getFreq(degree, octave = 4) {
        const semitone = this.scale[degree % this.scale.length];
        return semitone * Math.pow(2, octave - 4);
      }

      setBPM(bpm) {
        this.bpm = bpm;
      }

      schedule() {
        this.nextTime = this.ctx.currentTime;
        const interval = 60000 / this.bpm / 4; // 16th notes
        const scheduler = () => {
          while (this.nextTime < this.ctx.currentTime + 0.1) {
            this.triggerBeat(this.nextTime);
            this.nextTime += interval / 1000;
          }
          requestAnimationFrame(scheduler);
        };
        scheduler();
      }

      triggerBeat(time) {
        const beat = Math.floor((time * this.bpm / 60000) * 4) % 16;

        // Drums
        if (beat % 4 === 0) this.playKick(time);
        if (beat % 4 === 2) this.playSnare(time);
        if (beat % 1 === 0) this.playHiHat(time, beat % 2 === 0 ? 0.05 : 0.02);

        // Bass
        if (beat % 4 === 0) {
          const bassNotes = [0, 0, 3, 5];
          const note = bassNotes[beat / 4 % 4];
          this.playBass(time, note, 2);
        }

        // Melody/Chords
        if (beat % 8 === 0) {
          const chordRoots = [0, 3, 4, 0]; // I iv V I
          const root = chordRoots[beat / 8 % 4];
          this.playChord(time, root, [0, 2, 4], 4);
        }
      }

      playKick(time) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(50, time);
        osc.frequency.exponentialRampToValueAtTime(20, time + 0.1);
        gain.gain.setValueAtTime(0.3, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
        osc.connect(gain);
        gain.connect(this.voicePool.input);
        osc.start(time);
        osc.stop(time + 0.3);
      }

      playSnare(time) {
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 0.1);
        source.connect(filter).connect(gain);
        gain.connect(this.voicePool.input);
        source.start(time);
      }

      playHiHat(time, duration) {
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 5000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.1, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + duration);
        source.connect(filter).connect(gain);
        gain.connect(this.voicePool.input);
        source.start(time);
      }

      playBass(time, degree, octave) {
        const freq = this.getFreq(degree, octave);
        const id = `bass-${time}`;
        this.voicePool.acquire(id, { type: 'sawtooth', freq, duration: 0.25, amp: 0.25 });
      }

      playChord(time, root, intervals, octave) {
        intervals.forEach((int, i) => {
          const degree = (root + int) % 7;
          const freq = this.getFreq(degree, octave + Math.floor(i / 3));
          const id = `chord-${time}-${i}`;
          this.voicePool.acquire(id, { type: 'sine', freq, duration: 1, amp: 0.1 });
        });
      }
    }

    class GranularFib {
      constructor(ctx, input) {
        this.ctx = ctx;
        this.input = input;
        this.samples = [];
        this.active = false;
        this.grains = new Set();
      }

      addSample(buffer) {
        this.samples.push(buffer);
      }

      toggle() {
        this.active = !this.active;
        if (this.active) this.scheduleGrains();
      }

      scheduleGrains() {
        if (!this.active || !this.samples.length) return;
        const schedule = () => {
          if (!this.active) return;
          const buffer = this.samples[Math.floor(Math.random() * this.samples.length)];
          const grainLen = 0.05 + Math.random() * 0.1;
          const offset = Math.random() * (buffer.duration - grainLen);
          const source = this.ctx.createBufferSource();
          const gain = this.ctx.createGain();
          const pan = this.ctx.createStereoPanner();
          pan.pan.value = Math.random() * 2 - 1;
          source.playbackRate.value = 0.5 + Math.random();
          source.buffer = buffer;
          gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 0.01);
          gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + grainLen);
          source.connect(pan).connect(gain);
          gain.connect(this.input);
          source.start(this.ctx.currentTime, offset, grainLen);
          setTimeout(schedule, 50 + Math.random() * 200);
        };
        schedule();
      }
    }

    class VibeCore {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.voicePool = null;
        this.sequencer = null;
        this.granular = null;
        this.micStream = null;
        this.micSource = null;
        this.recorder = null;
        this.motion = { magnitude: 0 };
        this.position = { x: 50, y: 50 };
        this.samples = [];
        this.ui = {};
        this.analyser = null;
        this.visualData = new Uint8Array(256);
        this.canvasCtx = null;
        this.mainInput = null;
        this.masterGain = null;
        this.compressor = null;
        this.lowShelf = null;
        this.midPeak = null;
        this.highShelf = null;
        this.convolver = null;
        this.init();
      }

      async init() {
        this.bindUI();
        this.setupCanvas();
        this.setupSpectrum();
        this.setupMotion();
      }

      bindUI() {
        this.ui = {
          coreBtn: document.getElementById('coreBtn'),
          initCore: document.getElementById('initCore'),
          canvasCore: document.getElementById('canvasCore'),
          phiOrb: document.getElementById('phiOrb'),
          phiSpectrum: document.getElementById('phiSpectrum'),
          audioCore: document.getElementById('audioCore'),
          envCore: document.getElementById('envCore'),
          synthCore: document.getElementById('synthCore'),
          mixCore: document.getElementById('mixCore'),
          envFib: document.getElementById('envFib'),
          fibMode: document.getElementById('fibMode'),
          volumeVal: document.getElementById('volumeVal'),
          volumeBar: document.getElementById('volumeBar'),
          compVal: document.getElementById('compVal'),
          voicesVal: document.getElementById('voicesVal'),
          loadVal: document.getElementById('loadVal'),
          motionVal: document.getElementById('motionVal'),
          motionBar: document.getElementById('motionBar'),
          ambientVal: document.getElementById('ambientVal'),
          samplesVal: document.getElementById('samplesVal'),
          modeVal: document.getElementById('modeVal'),
          keyVal: document.getElementById('keyVal'),
          bpmVal: document.getElementById('bpmVal'),
          harmVal: document.getElementById('harmVal'),
          lowVal: document.getElementById('lowVal'),
          midVal: document.getElementById('midVal'),
          highVal: document.getElementById('highVal'),
          spatialVal: document.getElementById('spatialVal'),
          micFib: document.getElementById('micFib'),
          recFib: document.getElementById('recFib'),
          grainFib: document.getElementById('grainFib')
        };

        this.ui.coreBtn.addEventListener('click', () => this.activate());
        this.ui.micFib.addEventListener('click', () => this.toggleMic());
        this.ui.recFib.addEventListener('click', () => this.toggleRecord());
        this.ui.grainFib.addEventListener('click', () => this.toggleGrain());
      }

      setupCanvas() {
        const canvas = this.ui.canvasCore;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        this.canvasCtx = canvas.getContext('2d');
        window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        });
      }

      setupSpectrum() {
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          this.ui.phiSpectrum.appendChild(bar);
        }
      }

      setupMotion() {
        const handleMotion = (e) => {
          const acc = e.accelerationIncludingGravity;
          if (acc) {
            this.motion.magnitude = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
            this.adaptMotion();
          }
        };
        if (DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
          DeviceMotionEvent.requestPermission().then(permission => {
            if (permission === 'granted') window.addEventListener('devicemotion', handleMotion);
          });
        } else {
          window.addEventListener('devicemotion', handleMotion);
        }
        window.addEventListener('mousemove', (e) => {
          this.position.x = (e.clientX / window.innerWidth) * 100;
          this.position.y = (e.clientY / window.innerHeight) * 100;
        });
      }

      async activate() {
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)({ latencyHint: 'interactive' });
          await this.ctx.resume();
          this.setupAudioChain();
          this.mainInput = this.ctx.createGain();
          this.mainInput.connect(this.lowShelf);
          this.voicePool = new FibonacciVoicePool(this.ctx, this.mainInput);
          this.sequencer = new FibonacciSequencer(this.ctx, this.voicePool, 'C', 'major', 120);
          this.sequencer.schedule();
          this.granular = new GranularFib(this.ctx, this.mainInput);
          this.ui.initCore.style.opacity = '0';
          setTimeout(() => {
            this.ui.initCore.classList.add('hidden');
            this.showCore();
          }, 800);
          this.active = true;
          this.animate();
        } catch (err) {
          console.error(err);
          alert('Synthesis failed. Check permissions.');
        }
      }

      setupAudioChain() {
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;

        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 30;
        this.compressor.ratio.value = 12;
        this.compressor.attack.value = 0;
        this.compressor.release.value = 0.25;

        this.lowShelf = this.ctx.createBiquadFilter();
        this.lowShelf.type = 'lowshelf';
        this.lowShelf.frequency.value = 320;
        this.lowShelf.gain.value = 0;

        this.midPeak = this.ctx.createBiquadFilter();
        this.midPeak.type = 'peaking';
        this.midPeak.frequency.value = 1500;
        this.midPeak.gain.value = 0;
        this.midPeak.Q.value = 1;

        this.highShelf = this.ctx.createBiquadFilter();
        this.highShelf.type = 'highshelf';
        this.highShelf.frequency.value = 3000;
        this.highShelf.gain.value = 0;

        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createImpulse(2);
        const reverbGain = this.ctx.createGain();
        reverbGain.gain.value = 0.2;
        const dryGain = this.ctx.createGain();
        dryGain.gain.value = 0.8;
        const wetGain = this.ctx.createGain();
        wetGain.gain.value = 0.3;

        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 512;
        this.analyser.smoothingTimeConstant = 0.8;

        // Routing: input -> split dry/wet -> EQ -> comp -> master -> analyser -> dest
        // Wet to convolver -> reverbGain
        this.mainInput.connect(dryGain);
        this.mainInput.connect(wetGain);
        wetGain.connect(this.convolver);
        this.convolver.connect(reverbGain);
        dryGain.connect(this.lowShelf);
        reverbGain.connect(this.lowShelf);
        this.lowShelf.connect(this.midPeak);
        this.midPeak.connect(this.highShelf);
        this.highShelf.connect(this.compressor);
        this.compressor.connect(this.masterGain);
        this.masterGain.connect(this.analyser);
        this.analyser.connect(this.ctx.destination);
      }

      createImpulse(decay = 2) {
        const length = this.ctx.sampleRate * decay;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
          const data = impulse.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay);
          }
        }
        return impulse;
      }

      showCore() {
        [this.ui.audioCore, this.ui.envCore, this.ui.synthCore, this.ui.mixCore, this.ui.envFib, this.ui.fibMode].forEach(el => el.classList.remove('hidden'));
        this.ui.phiOrb.style.display = 'block';
      }

      async toggleMic() {
        if (this.micStream) {
          this.micStream.getTracks().forEach(track => track.stop());
          this.micSource.disconnect();
          this.micStream = null;
          this.micSource = null;
          this.ui.micFib.classList.remove('active');
        } else {
          try {
            this.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.micSource = this.ctx.createMediaStreamSource(this.micStream);
            const micGain = this.ctx.createGain();
            micGain.gain.value = 0.3;
            this.micSource.connect(micGain);
            micGain.connect(this.mainInput);
            this.ui.micFib.classList.add('active');
          } catch (err) {
            console.error(err);
          }
        }
      }

      async toggleRecord() {
        if (!this.micSource) await this.toggleMic();
        if (this.recorder && this.recorder.state === 'recording') {
          this.recorder.stop();
          this.ui.recFib.classList.remove('active');
        } else {
          const dest = this.ctx.createMediaStreamDestination();
          this.micSource.connect(dest);
          const chunks = [];
          this.recorder = new MediaRecorder(dest.stream);
          this.recorder.ondataavailable = e => chunks.push(e.data);
          this.recorder.onstop = async () => {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
            this.samples.push(audioBuffer);
            this.granular.addSample(audioBuffer);
            this.ui.samplesVal.textContent = this.samples.length;
          };
          this.recorder.start();
          this.ui.recFib.classList.add('active');
          setTimeout(() => this.recorder.stop(), 5000);
        }
      }

      toggleGrain() {
        this.granular.toggle();
        this.ui.grainFib.classList.toggle('active');
      }

      adaptMotion() {
        const norm = Math.min(this.motion.magnitude / 10, 1);
        this.sequencer.setBPM(80 + norm * 80);
        if (norm > 0.5 && Math.random() < 0.2) {
          this.triggerMotionSound(norm);
        }
      }

      triggerMotionSound(intensity) {
        const freq = this.sequencer.getFreq(Math.floor(Math.random() * 7), 3);
        const id = `motion-${Date.now()}`;
        this.voicePool.acquire(id, { freq, duration: 0.3, amp: intensity * 0.2, type: 'triangle' });
        this.createParticle();
      }

      createParticle() {
        const particle = document.createElement('div');
        particle.className = 'particle-fib';
        particle.style.left = this.position.x + '%';
        particle.style.top = this.position.y + '%';
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 2000);
      }

      updateUI() {
        if (!this.active) return;
        this.ui.volumeVal.textContent = this.masterGain.gain.value.toFixed(2);
        this.ui.volumeBar.style.width = (this.masterGain.gain.value * 100) + '%';
        this.ui.compVal.textContent = (this.compressor.reduction.value || 0).toFixed(0) + 'dB';
        this.ui.voicesVal.textContent = this.voicePool.getCount();
        this.ui.loadVal.textContent = Math.round((this.voicePool.getCount() / this.voicePool.maxVoices) * 100) + '%';
        this.ui.motionVal.textContent = this.motion.magnitude.toFixed(2);
        this.ui.motionBar.style.width = (this.motion.magnitude * 10) + '%';
        this.ui.bpmVal.textContent = this.sequencer.bpm;
        this.ui.lowVal.textContent = this.lowShelf.gain.value.toFixed(0) + 'dB';
        this.ui.midVal.textContent = this.midPeak.gain.value.toFixed(0) + 'dB';
        this.ui.highVal.textContent = this.highShelf.gain.value.toFixed(0) + 'dB';
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.visualData);
          document.querySelectorAll('.spectrum-bar').forEach((bar, i) => {
            bar.style.height = (this.visualData[i * 4] / 255 * 80) + 'px';
          });
        }
        this.ui.phiOrb.style.left = this.position.x + '%';
        this.ui.phiOrb.style.top = this.position.y + '%';
      }

      draw() {
        this.canvasCtx.fillStyle = 'rgba(250, 250, 250, 0.05)';
        this.canvasCtx.fillRect(0, 0, this.canvasCtx.canvas.width, this.canvasCtx.canvas.height);
        if (this.analyser) {
          const timeData = new Uint8Array(this.analyser.frequencyBinCount);
          this.analyser.getByteTimeDomainData(timeData);
          this.canvasCtx.lineWidth = 1;
          this.canvasCtx.strokeStyle = '#333';
          this.canvasCtx.beginPath();
          const width = this.canvasCtx.canvas.width;
          const slice = width / timeData.length;
          let x = 0;
          for (let i = 0; i < timeData.length; i++) {
            const v = timeData[i] / 128.0;
            const y = v * this.canvasCtx.canvas.height / 2;
            if (i === 0) this.canvasCtx.moveTo(x, y);
            else this.canvasCtx.lineTo(x, y);
            x += slice;
          }
          this.canvasCtx.stroke();
        }
      }

      animate() {
        if (!this.active) return;
        this.updateUI();
        this.draw();
        requestAnimationFrame(() => this.animate());
      }
    }

    const core = new VibeCore();
  </script>
</body>
</html>
