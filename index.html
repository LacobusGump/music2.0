<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GUMP: Grand Unified Music Project</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html,body { height:100%; margin:0; background:#090d15; overflow:hidden;}
    body { font-family: -apple-system, BlinkMacSystemFont, sans-serif;}
    .intro { position:fixed; top:0; left:0; width:100vw; height:100vh; background:radial-gradient(ellipse at 60% 50%,#181e2f 0%,#090b12 80%); display:flex; flex-direction:column; align-items:center; justify-content:center; z-index:20; transition:opacity 1.1s;}
    .intro-title { font-size:2.6rem; font-weight:900; letter-spacing:2px; color:#e5f8ff; text-shadow:0 0 60px #7fdaff,0 4px 16px #000b; margin-bottom:2.2rem; opacity:.95; animation:introFade 2.7s cubic-bezier(.9,0,.1,1) alternate infinite;}
    .intro-author { font-size:1.18rem; color:#b3e3f9; opacity:.84; margin-bottom:2.6rem; letter-spacing:.7px;}
    .intro-btn { background:linear-gradient(85deg,#00cfff 25%,#ed9fe7 90%); color:#111; font-weight:700; font-size:1.21rem; padding:19px 52px; border-radius:40px; border:none; cursor:pointer; box-shadow:0 0 36px #59d4fd22; letter-spacing:1px; transition:transform 0.16s;}
    .intro-btn:active { transform:scale(0.98);}
    @keyframes introFade { from { text-shadow:0 0 16px #b2fff7; } to { text-shadow:0 0 68px #fff9,0 4px 20px #b4d7ff88;} }
    .app {position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1;opacity:0;transition:opacity 1.3s;}
    .orb-viz { width:80vw; max-width:360px; height:80vw; max-height:360px; margin:0 auto; position:relative; top:5vh; border-radius:50%; background:radial-gradient(circle at 44% 50%,#222a44 12%,#090c16 90%); box-shadow:0 0 90px 12px #334f9655,0 0 130px #02122e88 inset; border:2.5px solid #3e579c60; display:flex; align-items:center; justify-content:center; transition:all 2.5s cubic-bezier(0.4,0,0.2,1);}
    .orb-viz.void { background:radial-gradient(circle at 44% 50%,#4a3244 12%,#1a0f16 90%); box-shadow:0 0 140px 20px #9f5f8855,0 0 180px #2e1222aa inset; border:2.5px solid #8c5f9c80;}
    .music-orb { position:absolute; width:108px; height:108px; left:50%; top:50%; transform:translate(-50%,-50%); background:radial-gradient(circle at 58% 41%,#17234a 0%,#b4cfff35 69%,#171d27 100%); border-radius:50%; box-shadow:0 0 100px #a8c8fa48,0 0 32px #b9fff888; z-index:2; transition:all 2.8s cubic-bezier(0.25,0.8,0.25,1); animation:orbPulse 4.8s cubic-bezier(.65,0,.35,1) infinite alternate;}
    .music-orb.void { background:radial-gradient(circle at 52% 46%,#fff2ee 4%,#ecc4e7 30%,#c1c4fd 90%); box-shadow:0 0 200px #edbcff88,0 0 120px #fff8,0 0 300px #ff9fdd33; animation:voidPulse 6.2s cubic-bezier(.4,0,.6,1) infinite alternate; transform:translate(-50%,-50%) scale(1.08);}
    .orb-glow { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:320px; height:320px; border-radius:50%; z-index:1; background:radial-gradient(circle at 52% 48%,#6eacf933 1%,#bdf2ffa0 30%,#0b0f1800 98%); pointer-events:none; mix-blend-mode:lighten; opacity:.81; filter:blur(6px); transition:all 2.5s cubic-bezier(0.4,0,0.2,1); animation:orbPulse 4.8s cubic-bezier(.65,0,.35,1) infinite alternate;}
    .orb-glow.void { background:radial-gradient(circle at 52% 48%,#f99aff55 1%,#ecc4e7aa 30%,#1a0f1600 98%); width:420px; height:420px; filter:blur(12px); animation:voidGlow 7.1s cubic-bezier(.3,0,.7,1) infinite alternate;}
    .particles { position:absolute; width:100%; height:100%; top:0; left:0; pointer-events:none; z-index:0;}
    .particle { position:absolute; width:2px; height:2px; background:#4a9fff; border-radius:50%; opacity:0; animation:float 8s infinite linear;}
    .particle.void { background:#ff6ec7; animation:voidFloat 6s infinite linear;}
    @keyframes float { 0%{opacity:0;transform:translateY(20px);} 10%{opacity:1;} 90%{opacity:1;} 100%{opacity:0;transform:translateY(-300px);} }
    @keyframes voidFloat { 0%{opacity:0;transform:translateY(20px) rotate(0deg);} 10%{opacity:1;} 90%{opacity:1;} 100%{opacity:0;transform:translateY(-300px) rotate(360deg);} }
    @keyframes orbPulse {from{opacity:.79;}to{opacity:.96;}}
    @keyframes voidPulse {from{opacity:.85;transform:translate(-50%,-50%) scale(1.08);}to{opacity:1;transform:translate(-50%,-50%) scale(1.12);}}
    @keyframes voidGlow {from{opacity:.6;}to{opacity:.95;}}
    .world-label { position:absolute; left:50%; top:93%; transform:translate(-50%,-50%); background:rgba(17,24,31,0.85); color:#e5f8ff; padding:12px 30px; border-radius:30px; font-size:1.18rem; letter-spacing:.6px; font-weight:600; opacity:0; pointer-events:none; box-shadow:0 8px 30px #0b0f1b36; transition:all 0.8s cubic-bezier(0.4,0,0.2,1); z-index:10; text-align:center;}
    .world-label.show { opacity:1; transform:translate(-50%,-50%) scale(1.02);}
    .world-label.void { background:rgba(42,24,41,0.9); color:#f9e5ff; box-shadow:0 8px 40px #3d1b3b66;}
    .label-floatin { animation: labelFloatIn 0.8s cubic-bezier(.8,0,.4,1);}
    @keyframes labelFloatIn { from { opacity:0; transform:translate(-50%,20px); } to{ opacity:1; transform:translate(-50%,-50%);} }
    .music-vis { position:absolute; width:200px; height:200px; left:50%; top:50%; transform:translate(-50%,-50%); z-index:3; pointer-events:none;}
    .freq-bar { position:absolute; width:3px; background:linear-gradient(to top,#4a9fff,#ff6ec7); border-radius:2px; transform-origin:bottom; opacity:0.7; transition:height 0.1s ease;}
    @media (max-width:500px) {
      .intro-title{font-size:1.4rem;}
      .world-label{font-size:1rem;}
      .orb-viz{top:2vh;}
    }
  </style>
</head>
<body>
  <div class="intro" id="intro">
    <div class="intro-title">GUMP: Grand Unified Music Project</div>
    <div class="intro-author">By James McCandless</div>
    <button class="intro-btn" id="begin">Begin</button>
  </div>
  <div class="app" id="app">
    <div class="orb-viz" id="orbViz">
      <div class="particles" id="particles"></div>
      <div class="orb-glow" id="orbGlow"></div>
      <div class="music-orb" id="orb"></div>
      <div class="music-vis" id="musicVis"></div>
      <div class="world-label" id="worldLabel"></div>
    </div>
  </div>
  <script>
    let ctx = null, mainGain = null, allowMotion = false, analyser = null, dataArray = null;
    let orbEl = null, orbVizEl = null, orbGlowEl = null, labelEl = null, musicVisEl = null;
    let world = { weather:"Clear", hour:12, day:"Monday", city:"Nowhere", lat:40.7, lon:-74.0 };
    let musicState = { layers:[], scale:[261.63,293.66,329.63,349.23,392.00,440.00,493.88], key:0, tempo:120, intensity:0.5 };
    let voidMode = false, lastMove = 0, particleCount = 0, harmonicLayers = [];
    let weatherPad = null, timeBass = null, dayGroove = null, locationMotif = null;

    window.onload = ()=>{
      orbEl = document.getElementById('orb');
      orbVizEl = document.getElementById('orbViz');
      orbGlowEl = document.getElementById('orbGlow');
      labelEl = document.getElementById('worldLabel');
      musicVisEl = document.getElementById('musicVis');
      document.getElementById('begin').onclick = startGUMP;
      createParticles();
      createFreqBars();
    };

    function createParticles(){
      for(let i=0;i<20;i++){
        let p = document.createElement('div');
        p.className = 'particle';
        p.style.left = Math.random()*100+'%';
        p.style.animationDelay = Math.random()*8+'s';
        p.style.animationDuration = (6+Math.random()*4)+'s';
        document.getElementById('particles').appendChild(p);
      }
    }

    function createFreqBars(){
      for(let i=0;i<16;i++){
        let bar = document.createElement('div');
        bar.className = 'freq-bar';
        bar.style.left = (i*12)+'px';
        bar.style.bottom = '0px';
        bar.style.height = '0px';
        musicVisEl.appendChild(bar);
      }
    }

    function updateParticles(){
      let particles = document.querySelectorAll('.particle');
      particles.forEach(p => {
        p.classList.toggle('void', voidMode);
      });
    }

    function updateFreqBars(){
      if(!analyser) return;
      analyser.getByteFrequencyData(dataArray);
      let bars = document.querySelectorAll('.freq-bar');
      bars.forEach((bar, i) => {
        let val = dataArray[i*8] || 0;
        bar.style.height = (val/255*100)+'px';
        bar.style.opacity = voidMode ? 0.9 : 0.7;
      });
    }

    function fadeOut(el, ms=1000){el.style.transition=`opacity ${ms}ms`;el.style.opacity=0;}
    function fadeIn(el, ms=1000){el.style.transition=`opacity ${ms}ms`;el.style.opacity=1;}
    function showLabel(msg, time=1400) {
      labelEl.textContent = msg;
      labelEl.classList.add('show','label-floatin');
      setTimeout(()=>labelEl.classList.remove('label-floatin'),600);
      if(time) setTimeout(()=>labelEl.classList.remove('show'),time);
    }

    async function startGUMP() {
      fadeOut(document.getElementById('intro'),800);
      setTimeout(()=>{
        document.getElementById('intro').style.display='none';
        document.getElementById('app').style.opacity=1;
        beginPermissions();
      },800);
    }

    async function beginPermissions(){
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      await ctx.resume();
      mainGain = ctx.createGain();
      mainGain.gain.value = 0.7;
      mainGain.connect(ctx.destination);
      analyser = ctx.createAnalyser();
      analyser.fftSize = 256;
      dataArray = new Uint8Array(analyser.frequencyBinCount);
      mainGain.connect(analyser);
      
      if(window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission==="function") {
        try { let r = await DeviceMotionEvent.requestPermission(); if(r==="granted") allowMotion=true; }catch{}
      } else allowMotion=true;
      
      if(window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission==="function") {
        try { await DeviceOrientationEvent.requestPermission(); }catch{}
      }
      
      runStartupSequence();
    }

    function runStartupSequence(){
      orbEl.style.opacity = 0.8;
      orbEl.style.transform = "translate(-50%,-50%) scale(0.93)";
      
      let dt = new Date();
      world.hour = dt.getHours();
      world.day = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"][dt.getDay()];
      world.city = "Jersey";
      world.weather = ["Clear","Cloudy","Rain","Fog","Snow"][Math.floor(Math.random()*5)];
      
      // Enhanced musical key selection based on time and weather
      let timeKey = Math.floor(world.hour/3) % 7;
      let weatherMod = {"Clear":0,"Cloudy":1,"Rain":2,"Fog":3,"Snow":4}[world.weather];
      musicState.key = (timeKey + weatherMod) % 7;
      
      let steps = [
        { label:"Reading Weather Patterns…", fn: () => initWeatherLayer() },
        { label:"Synchronizing Time…", fn: () => initTimeLayer() },
        { label:"Detecting Weekly Rhythm…", fn: () => initDayLayer() },
        { label:"Locating Harmonic Position…", fn: () => initLocationLayer() }
      ];
      
      let i=0;
      function nextLayer(){
        if(i<steps.length){
          showLabel(steps[i].label,1050);
          steps[i].fn();
          orbEl.style.transform = `translate(-50%,-50%) scale(${1+0.03*i})`;
          setTimeout(nextLayer,1050);
          i++;
        } else {
          setTimeout(()=>{
            showLabel("Reality Synthesizer Online",1600);
            orbEl.style.transform = "translate(-50%,-50%) scale(1.05)";
            startRealTimeMusic();
          },900);
        }
      }
      setTimeout(nextLayer, 1200);
    }

    // ========== ENHANCED MUSIC SYSTEM ==========
    
    function getNote(index, octave=4) {
      return musicState.scale[index % 7] * Math.pow(2, octave-4);
    }

    function createFilter(type, freq, q=1) {
      let filter = ctx.createBiquadFilter();
      filter.type = type;
      filter.frequency.value = freq;
      filter.Q.value = q;
      return filter;
    }

    function initWeatherLayer() {
      let weatherMap = {
        "Clear": { freq: getNote(0), type: "sine", filter: "lowpass", filterFreq: 2000 },
        "Cloudy": { freq: getNote(2), type: "triangle", filter: "bandpass", filterFreq: 800 },
        "Rain": { freq: getNote(4), type: "sawtooth", filter: "highpass", filterFreq: 400 },
        "Fog": { freq: getNote(1), type: "sine", filter: "lowpass", filterFreq: 600 },
        "Snow": { freq: getNote(6), type: "triangle", filter: "bandpass", filterFreq: 1200 }
      };
      
      let config = weatherMap[world.weather];
      weatherPad = createPad(config.freq, config.type, config.filter, config.filterFreq);
    }

    function initTimeLayer() {
      let isNight = world.hour < 6 || world.hour > 19;
      let freq = isNight ? getNote(0, 2) : getNote(4, 2);
      let intensity = isNight ? 0.3 : 0.2;
      timeBass = createBass(freq, intensity, isNight);
    }

    function initDayLayer() {
      let dayIndex = ["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"].indexOf(world.day);
      let patterns = [
        [1,0,1,0,1,0,0,0], // Sunday - peaceful
        [1,0,0,1,0,0,1,0], // Monday - structured
        [1,0,1,0,0,1,0,1], // Tuesday - energetic
        [1,0,0,0,1,0,1,0], // Wednesday - balanced
        [1,0,1,1,0,0,1,0], // Thursday - anticipatory
        [1,1,0,1,0,1,0,0], // Friday - exciting
        [1,0,0,1,0,0,0,1]  // Saturday - relaxed
      ];
      dayGroove = createGroove(patterns[dayIndex], getNote(2, 5));
    }

    function initLocationLayer() {
      let cityCode = world.city.charCodeAt(0);
      let noteIndex = (cityCode - 65) % 7;
      let melody = [noteIndex, (noteIndex+2)%7, (noteIndex+4)%7, (noteIndex+1)%7];
      locationMotif = createMotif(melody);
    }

    function createPad(freq, type, filterType, filterFreq) {
      let osc = ctx.createOscillator();
      let gain = ctx.createGain();
      let filter = createFilter(filterType, filterFreq, 2);
      
      osc.type = type;
      osc.frequency.value = freq;
      gain.gain.value = 0;
      gain.gain.linearRampToValueAtTime(0.15, ctx.currentTime + 1);
      
      osc.connect(filter).connect(gain).connect(mainGain);
      osc.start();
      
      return { osc, gain, filter };
    }

    function createBass(freq, intensity, isNight) {
      let osc = ctx.createOscillator();
      let gain = ctx.createGain();
      let filter = createFilter("lowpass", 200, 1);
      
      osc.type = isNight ? "triangle" : "sawtooth";
      osc.frequency.value = freq;
      gain.gain.value = 0;
      gain.gain.linearRampToValueAtTime(intensity, ctx.currentTime + 0.5);
      
      osc.connect(filter).connect(gain).connect(mainGain);
      osc.start();
      
      return { osc, gain, filter };
    }

    function createGroove(pattern, baseFreq) {
      let interval = 60 / musicState.tempo * 1000;
      let index = 0;
      
      function playBeat() {
        if(pattern[index % pattern.length]) {
          let osc = ctx.createOscillator();
          let gain = ctx.createGain();
          let filter = createFilter("highpass", 1000, 0.5);
          
          osc.type = "square";
          osc.frequency.value = baseFreq + (index * 50);
          gain.gain.setValueAtTime(0.1, ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.1);
          
          osc.connect(filter).connect(gain).connect(mainGain);
          osc.start();
          osc.stop(ctx.currentTime + 0.1);
        }
        index++;
      }
      
      let grooveInterval = setInterval(playBeat, interval / 4);
      return { interval: grooveInterval, pattern };
    }

    function createMotif(melody) {
      let index = 0;
      let interval = 60 / musicState.tempo * 1000;
      
      function playNote() {
        let freq = getNote(melody[index % melody.length], 5);
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        let filter = createFilter("bandpass", freq * 2, 1);
        
        osc.type = "triangle";
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0.08, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.3);
        
        osc.connect(filter).connect(gain).connect(mainGain);
        osc.start();
        osc.stop(ctx.currentTime + 0.3);
        
        index++;
      }
      
      let motifInterval = setInterval(playNote, interval);
      return { interval: motifInterval, melody };
    }

    // ========== REAL-TIME MOTION MUSIC ==========

    function startRealTimeMusic(){
      let moving = false;
      let motionIntensity = 0;
      let lastOrientation = { alpha: 0, beta: 0, gamma: 0 };
      
      setInterval(updateFreqBars, 50);
      
      window.addEventListener('devicemotion', e => {
        if(!allowMotion) return;
        let acc = e.accelerationIncludingGravity;
        if(!acc) return;
        
        let magnitude = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
        motionIntensity = Math.min(magnitude / 20, 1);
        let nowT = performance.now();
        
        if(magnitude > 8) { moving = true; lastMove = nowT; }
        if(nowT - lastMove > 2000) { moving = false; motionIntensity = 0; }
        
        // Update music based on motion
        if(weatherPad) {
          weatherPad.gain.gain.setTargetAtTime(0.1 + motionIntensity * 0.1, ctx.currentTime, 0.1);
          weatherPad.filter.frequency.setTargetAtTime(200 + motionIntensity * 1800, ctx.currentTime, 0.1);
        }
        
        if(timeBass) {
          timeBass.gain.gain.setTargetAtTime(0.15 + motionIntensity * 0.15, ctx.currentTime, 0.1);
        }
        
        // Visual feedback
        orbEl.style.opacity = 0.7 + motionIntensity * 0.3;
        orbEl.style.transform = `translate(-50%,-50%) scale(${1 + motionIntensity * 0.2})`;
        
        // Generate harmonic layers on intense motion
        if(motionIntensity > 0.7 && Math.random() < 0.1) {
          createHarmonicBurst(motionIntensity);
        }
      });
      
      window.addEventListener('deviceorientation', e => {
        if(!e.alpha) return;
        
        let deltaAlpha = Math.abs(e.alpha - lastOrientation.alpha);
        let deltaBeta = Math.abs(e.beta - lastOrientation.beta);
        let deltaGamma = Math.abs(e.gamma - lastOrientation.gamma);
        
        if(deltaAlpha > 5 || deltaBeta > 5 || deltaGamma > 5) {
          // Rotation affects musical key
          let newKey = Math.floor((e.alpha / 51.4) % 7);
          if(newKey !== musicState.key) {
            musicState.key = newKey;
            updateMusicalKey();
          }
        }
        
        lastOrientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
      });
      
      // Void mode detection
      setInterval(() => {
        let targetVoid = motionIntensity < 0.1;
        if(targetVoid !== voidMode) {
          voidMode = targetVoid;
          orbVizEl.classList.toggle('void', voidMode);
          orbEl.classList.toggle('void', voidMode);
          orbGlowEl.classList.toggle('void', voidMode);
          labelEl.classList.toggle('void', voidMode);
          updateParticles();
          
          if(voidMode) {
            showLabel("Entering the Void...", 1800);
            createVoidAmbience();
          } else {
            showLabel("Reality Restored", 1200);
            stopVoidAmbience();
          }
        }
      }, 500);
    }

    function createHarmonicBurst(intensity) {
      let numHarmonics = Math.floor(3 + intensity * 5);
      let baseFreq = getNote(musicState.key, 4);
      
      for(let i = 0; i < numHarmonics; i++) {
        let osc = ctx.createOscillator();
        let gain = ctx.createGain();
        let filter = createFilter("bandpass", baseFreq * (i + 1), 2);
        
        osc.type = "sine";
        osc.frequency.value = baseFreq * (i + 1);
        gain.gain.setValueAtTime(0.05 / (i + 1), ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.5);
        
        osc.connect(filter).connect(gain).connect(mainGain);
        osc.start();
        osc.stop(ctx.currentTime + 0.5);
      }
    }

    function updateMusicalKey() {
      if(weatherPad) {
        weatherPad.osc.frequency.setTargetAtTime(getNote(musicState.key), ctx.currentTime, 0.3);
      }
      if(timeBass) {
        timeBass.osc.frequency.setTargetAtTime(getNote(musicState.key, 2), ctx.currentTime, 0.3);
      }
    }

    function createVoidAmbience() {
      let osc = ctx.createOscillator();
      let gain = ctx.createGain();
      let filter = createFilter("lowpass", 300, 1);
      
      osc.type = "sine";
      osc.frequency.value = getNote(0, 2);
      gain.gain.setValueAtTime(0, ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0.2, ctx.currentTime + 2);
      
      osc.connect(filter).connect(gain).connect(mainGain);
      osc.start();
      
      harmonicLayers.push({ osc, gain, filter });
    }

    function stopVoidAmbience() {
      harmonicLayers.forEach(layer => {
        layer.gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 1);
        layer.osc.stop(ctx.currentTime + 1);
      });
      harmonicLayers = [];
    }
  </script>
</body>
</html>
