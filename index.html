<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;color:#fff;font-family:system-ui;height:100vh;overflow:hidden;touch-action:none}
        #start{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;z-index:10}
        #start.off{display:none}
        .title{font-size:10px;letter-spacing:8px;opacity:0.4}
        .sub{font-size:20px;font-weight:200;letter-spacing:3px}
        button{width:100px;height:100px;border-radius:50%;background:transparent;border:1px solid #0fa;color:#0fa;font:inherit;font-size:9px;letter-spacing:2px;cursor:pointer;transition:0.3s}
        button:hover{background:#0fa;color:#000}
        .hint{font-size:9px;opacity:0.25;text-align:center;max-width:200px;line-height:1.5}
        #app{display:none;height:100vh}
        #app.on{display:block}
        canvas{position:fixed;inset:0;width:100%;height:100%}
        .hud{position:fixed;font-size:8px;letter-spacing:1px;opacity:0.3;z-index:5}
        .tl{top:16px;left:16px}
        .tr{top:16px;right:16px;text-align:right}
        .bl{bottom:16px;left:16px}
        .br{bottom:16px;right:16px;text-align:right}
        .v{font-size:11px;margin-top:3px;opacity:0.7}
    </style>
</head>
<body>
<div id="start">
    <div class="title">GUMP</div>
    <div class="sub">Grand Unified Music Project</div>
    <button id="go">ENTER</button>
    <div class="hint">Move through space. You are the instrument.</div>
</div>
<div id="app">
    <canvas id="c"></canvas>
    <div class="hud tl"><div>STAGE</div><div class="v" id="stage">VOID</div></div>
    <div class="hud tr"><div>ENERGY</div><div class="v" id="flw">0</div></div>
    <div class="hud bl"><div>MOOD</div><div class="v" id="layers">-</div></div>
    <div class="hud br"><div>TIME</div><div class="v" id="journey">0:00</div></div>
</div>
<script>
// GUMP - Grand Unified Music Project
// A journey through sound and self
// GENERATIVE. UNPREDICTABLE. ALIVE.

const PHI = 1.618033988749;
const TAU = Math.PI * 2;

// ============ GENERATIVE DNA - UNIQUE EACH SESSION ============

// This gets randomized at init - every session is different
const DNA = {
    root: 55,           // will be randomized
    bpm: 72,            // will be randomized
    scale: null,        // will be picked
    chordSet: null,     // will be generated
    loopLen: 8,         // will vary
    swingAmount: 0,     // rhythmic swing
    chaosLevel: 0.3,    // probability of random events
    dropThreshold: 0.5, // when drops happen
    mutationRate: 0.02  // how fast things evolve
};

// All available scales - will pick randomly
const SCALE_POOL = [
    { name: 'phrygian', notes: [0, 1, 3, 5, 7, 8, 10], mood: 'dark' },
    { name: 'locrian', notes: [0, 1, 3, 5, 6, 8, 10], mood: 'unstable' },
    { name: 'dorian', notes: [0, 2, 3, 5, 7, 9, 10], mood: 'mysterious' },
    { name: 'harmonic_minor', notes: [0, 2, 3, 5, 7, 8, 11], mood: 'dramatic' },
    { name: 'hungarian', notes: [0, 2, 3, 6, 7, 8, 11], mood: 'exotic' },
    { name: 'prometheus', notes: [0, 2, 4, 6, 9, 10], mood: 'alien' },
    { name: 'enigmatic', notes: [0, 1, 4, 6, 8, 10, 11], mood: 'wtf' }
];

// Possible root notes (different vibes)
const ROOT_POOL = [41.2, 46.25, 49, 55, 58.27, 61.74, 65.41]; // Eb2 to C3

// State
const F = {
    x: 0, y: 0, z: 0,
    vx: 0, vy: 0, vz: 0,
    speed: 0,
    phase: 0,
    density: 0,
    field: 0,
    lfo: 0,
    breath: 0,
    orbit: 0,
    energy: 0,          // accumulated movement energy
    lastEventTime: 0    // for spacing out events
};

// Journey state - now more responsive
const J = {
    stage: 0,
    stageTime: 0,
    totalTime: 0,
    intensity: 0,
    tension: 0,         // NOW builds continuously based on energy
    lastDrop: -10,      // start negative so first drop can happen sooner
    dropPending: false,
    frisson: 0,
    keyOffset: 0,
    silenceUntil: 0,
    chordIndex: 0,      // current chord in progression
    nextChordTime: 0,   // when to change chords
    surpriseCount: 0    // track surprising events
};

// Memory - now with mutation
const M = {
    mode: 'building',
    tape: [],
    loopLen: 8,
    beatTime: 0.4,
    playhead: 0,
    lastBeat: 0,
    layers: [],
    activeLayer: null,
    blend: 0.5,
    beatDropped: false,
    beatIntensity: 0,
    darkness: 0,
    mutationAccum: 0,   // accumulates toward tape mutation
    groove: []          // randomized beat pattern
};

// Audio nodes
let ctx, master, reverb, reverbDistort, delay, subDrone, textureNoise;
let walls = [];
let binaural = null;
let shimmer = null;
let whisper = null;
let orbitSounds = [];
let running = false;

// Mic
let micStream, micSource, micBuffer;
const MIC_BUFFER_SIZE = 48000 * 4;
let micWritePos = 0;

// ============ GENERATE UNIQUE DNA ============

function generateDNA() {
    // Random root note
    DNA.root = ROOT_POOL[Math.floor(Math.random() * ROOT_POOL.length)];

    // Random tempo 60-90 BPM
    DNA.bpm = 60 + Math.random() * 30;

    // Random scale
    DNA.scale = SCALE_POOL[Math.floor(Math.random() * SCALE_POOL.length)];

    // Random loop length 6-12
    DNA.loopLen = 6 + Math.floor(Math.random() * 7);
    M.loopLen = DNA.loopLen;

    // Generate unique chord progression (4-6 chords)
    const numChords = 4 + Math.floor(Math.random() * 3);
    DNA.chordSet = [];
    for (let i = 0; i < numChords; i++) {
        DNA.chordSet.push(generateChord());
    }

    // Random swing 0-0.3
    DNA.swingAmount = Math.random() * 0.3;

    // Chaos level 0.2-0.5
    DNA.chaosLevel = 0.2 + Math.random() * 0.3;

    // Drop threshold - lower = more drops
    DNA.dropThreshold = 0.4 + Math.random() * 0.3;

    // Generate unique groove pattern
    generateGroove();

    console.log('DNA:', DNA.scale.name, 'root:', DNA.root.toFixed(1), 'bpm:', DNA.bpm.toFixed(0));
}

function generateChord() {
    // Generate interesting chord voicings from the scale
    const scale = DNA.scale.notes;
    const voicing = [];

    // Root (maybe)
    if (Math.random() > 0.2) voicing.push(0);

    // Pick 2-4 more notes from scale, possibly in different octaves
    const numNotes = 2 + Math.floor(Math.random() * 3);
    for (let i = 0; i < numNotes; i++) {
        const degree = scale[Math.floor(Math.random() * scale.length)];
        const octave = Math.floor(Math.random() * 2) * 12; // 0 or 12
        voicing.push(degree + octave);
    }

    // Sometimes add tension notes outside the scale
    if (Math.random() > 0.7) {
        const tension = [1, 6, 11][Math.floor(Math.random() * 3)]; // b2, tritone, or maj7
        voicing.push(tension + 12);
    }

    return [...new Set(voicing)].sort((a, b) => a - b); // unique, sorted
}

function generateGroove() {
    // Create a unique rhythmic pattern
    M.groove = [];
    for (let i = 0; i < DNA.loopLen; i++) {
        M.groove.push({
            kick: Math.random() > 0.6,
            snare: Math.random() > 0.7,
            hat: Math.random() > 0.5,
            accent: Math.random() > 0.8,
            probability: 0.5 + Math.random() * 0.5 // how likely this beat plays
        });
    }
    // Ensure at least one kick
    M.groove[0].kick = true;
    M.groove[0].probability = 1;
}

// ============ AUDIO ENGINE ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // GENERATE UNIQUE DNA FOR THIS SESSION
    generateDNA();

    M.beatTime = 60 / DNA.bpm / 2;

    // Master
    master = ctx.createGain();
    master.gain.value = 0.8;

    // Create waveshaper for saturation
    const saturator = createSaturator();

    // Dark reverb with distortion after it
    reverb = createDarkReverb();

    // Delay - synced to tempo
    delay = ctx.createDelay(2);
    delay.delayTime.value = 60 / DNA.bpm * 0.75;
    const delayFb = ctx.createGain();
    delayFb.gain.value = 0.4;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2000;

    delay.connect(delayFilter);
    delayFilter.connect(delayFb);
    delayFb.connect(delay);
    delay.connect(saturator);

    // Compression - aggressive
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -24;
    comp.ratio.value = 8;
    comp.attack.value = 0.002;
    comp.release.value = 0.1;
    comp.knee.value = 0;

    // Final chain
    saturator.connect(master);
    master.connect(comp);
    comp.connect(ctx.destination);

    // Create the sound sources
    createSubDrone();
    createWalls();
    createTexture();
    createBinaural();
    createShimmer();
    createWhisper();
    initOrbits();
    initMic();

    // Schedule first chord change
    J.nextChordTime = ctx.currentTime + 4 + Math.random() * 4;
}

// Waveshaper for that gritty saturation
function createSaturator() {
    const shaper = ctx.createWaveShaper();
    const samples = 44100;
    const curve = new Float32Array(samples);

    for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        // Soft clipping with odd harmonics
        curve[i] = Math.tanh(x * 2) * 0.8 + Math.tanh(x * 4) * 0.2;
    }

    shaper.curve = curve;
    shaper.oversample = '2x';
    return shaper;
}

// Dark reverb - long, filtered, with distortion
function createDarkReverb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.4;

    // Longer, darker taps
    const times = [0.05, 0.13, 0.21, 0.34, 0.55, 0.89, 1.44];
    const gains = [0.6, 0.5, 0.45, 0.35, 0.3, 0.25, 0.2];

    times.forEach((t, i) => {
        const d = ctx.createDelay(2);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = gains[i];
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 2500 - i * 300; // gets darker
        f.Q.value = 0.5;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
    });

    // Distortion AFTER reverb - key for that eerie sound
    reverbDistort = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        const x = (i / 128) - 1;
        curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.7);
    }
    reverbDistort.curve = curve;

    output.connect(reverbDistort);
    reverbDistort.connect(master);

    return input;
}

// ============ SUB DRONE - THE FOUNDATION ============

function createSubDrone() {
    // Deep, rumbling sub that's always there
    const sub = ctx.createOscillator();
    const sub2 = ctx.createOscillator();
    const subGain = ctx.createGain();
    const subFilter = ctx.createBiquadFilter();

    sub.type = 'sine';
    sub.frequency.value = DNA.root / 2; // You feel it more than hear it

    sub2.type = 'sine';
    sub2.frequency.value = DNA.root / 2 * 1.002; // beating

    subFilter.type = 'lowpass';
    subFilter.frequency.value = 80;

    subGain.gain.value = 0;

    sub.connect(subFilter);
    sub2.connect(subFilter);
    subFilter.connect(subGain);
    subGain.connect(master);

    sub.start();
    sub2.start();

    subDrone = { sub, sub2, gain: subGain, filter: subFilter, baseFreq: DNA.root / 2 };
}

// ============ THE WALLS - MASSIVE SUPERSAW CHORDS ============

function createWalls() {
    // Create walls based on the FIRST chord in our generated progression
    // These will morph to other chords over time
    const chord = DNA.chordSet[0];

    chord.forEach((semitone, idx) => {
        const freq = DNA.root * Math.pow(2, semitone / 12);
        const wall = createSupersaw(freq, idx);
        wall.semitone = semitone; // track what note this is
        walls.push(wall);
    });
}

function morphToChord(chordIndex) {
    // Smoothly morph all walls to a new chord voicing
    const chord = DNA.chordSet[chordIndex % DNA.chordSet.length];
    const now = ctx.currentTime;

    // Match existing walls to new chord notes (some may not map)
    walls.forEach((wall, i) => {
        if (i < chord.length) {
            const newSemitone = chord[i];
            const newFreq = DNA.root * Math.pow(2, (newSemitone + J.keyOffset) / 12);
            wall.semitone = newSemitone;
            wall.baseFreq = newFreq;

            wall.oscs.forEach(osc => {
                osc.frequency.linearRampToValueAtTime(newFreq, now + 0.8);
            });
        }
    });

    J.chordIndex = chordIndex;
}

function createSupersaw(baseFreq, idx) {
    // 7 detuned oscillators - the classic supersaw
    const NUM_OSCS = 7;
    const oscs = [];
    const gains = [];
    const output = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    const panL = ctx.createGain();
    const panR = ctx.createGain();
    const merger = ctx.createChannelMerger(2);

    // Detune amounts (in cents) - asymmetric like the JP-8000
    const detunes = [-35, -20, -10, 0, 12, 24, 40];
    // Gains - center voice loudest
    const oscGains = [0.5, 0.7, 0.9, 1, 0.9, 0.7, 0.5];

    for (let i = 0; i < NUM_OSCS; i++) {
        const osc = ctx.createOscillator();
        const g = ctx.createGain();

        osc.type = 'sawtooth';
        osc.frequency.value = baseFreq;
        osc.detune.value = detunes[i];

        g.gain.value = oscGains[i] / NUM_OSCS;

        // Stereo spread - left voices detuned down, right detuned up
        if (i < 3) {
            osc.connect(g);
            g.connect(panL);
        } else if (i > 3) {
            osc.connect(g);
            g.connect(panR);
        } else {
            // Center goes to both
            osc.connect(g);
            g.connect(panL);
            g.connect(panR);
        }

        osc.start();
        oscs.push(osc);
        gains.push(g);
    }

    // Stereo output
    panL.connect(merger, 0, 0);
    panR.connect(merger, 0, 1);

    // Rich resonant filter
    filter.type = 'lowpass';
    filter.frequency.value = 800;
    filter.Q.value = 4;

    merger.connect(filter);
    filter.connect(output);
    output.gain.value = 0;
    output.connect(master);
    output.connect(reverb);
    output.connect(delay);

    return { oscs, gains, output, filter, baseFreq, panL, panR };
}

function updateWalls() {
    const now = ctx.currentTime;
    const S = getBlendedState();

    // LFO for slow movement
    F.lfo = Math.sin(now * 0.3) * 0.5 + 0.5;

    walls.forEach((w, i) => {
        // Amplitude - builds with movement and darkness
        let amp = (0.05 + S.speed * 0.15 + M.darkness * 0.1);

        // Position affects which voices are prominent
        if (i === 0) amp *= 0.8; // root always present
        if (i === 1) amp *= (1 + S.x) / 2; // minor 3rd on right side
        if (i === 2) amp *= (1 + S.y) / 2 * M.darkness; // tension voice builds

        w.output.gain.linearRampToValueAtTime(amp * 0.3, now + 0.2);

        // Filter - opens slowly, controlled by movement
        const filterBase = 400 + M.darkness * 1500;
        const filterMod = S.speed * 2000 + F.lfo * 500;
        w.filter.frequency.linearRampToValueAtTime(filterBase + filterMod, now + 0.15);
        w.filter.Q.linearRampToValueAtTime(2 + S.speed * 6, now + 0.15);

        // Subtle pitch drift
        const drift = Math.sin(now * (0.1 + i * 0.07)) * 5;
        w.oscs.forEach((osc, j) => {
            const baseDetune = [-35, -20, -10, 0, 12, 24, 40][j];
            osc.detune.linearRampToValueAtTime(baseDetune + drift, now + 0.1);
        });
    });

    // Sub drone - always rumbling, intensity varies
    const subAmp = 0.15 + S.speed * 0.2 + M.darkness * 0.15;
    subDrone.gain.gain.linearRampToValueAtTime(subAmp, now + 0.2);

    // Sub filter opens with intensity
    subDrone.filter.frequency.linearRampToValueAtTime(60 + S.speed * 40, now + 0.2);

    // Build darkness over time
    M.darkness = Math.min(1, M.darkness + 0.0005);
}

// ============ TEXTURE LAYER - FILTERED NOISE CHAOS ============

function createTexture() {
    // Continuous noise that morphs with movement
    const bufferSize = ctx.sampleRate * 2;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = noiseBuffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    noise.loop = true;

    const noiseGain = ctx.createGain();
    noiseGain.gain.value = 0;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 1000;
    noiseFilter.Q.value = 5;

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(reverb);

    noise.start();

    textureNoise = { source: noise, gain: noiseGain, filter: noiseFilter };
}

function updateTexture() {
    const now = ctx.currentTime;
    const S = getBlendedState();

    // Noise level varies with journey stage
    const stageNoise = [0.02, 0.04, 0.08, 0.12, 0.06, 0.03][J.stage];
    const noiseAmp = S.speed * 0.08 + stageNoise;
    textureNoise.gain.gain.linearRampToValueAtTime(noiseAmp, now + 0.1);

    // Filter sweeps with position
    const freq = 500 + S.x * 2000 + S.y * 1500 + F.lfo * 1000;
    textureNoise.filter.frequency.linearRampToValueAtTime(freq, now + 0.1);
    textureNoise.filter.Q.linearRampToValueAtTime(3 + J.tension * 8, now + 0.1);
}

// ============ BINAURAL BEATS - ALTER CONSCIOUSNESS ============

function createBinaural() {
    // Two oscillators with slightly different frequencies in each ear
    // The difference creates a perceived "beat" that entrains brainwaves
    // Theta (4-8Hz) = dreamlike, meditative
    // Alpha (8-12Hz) = relaxed, aware

    const baseFreq = 100; // carrier frequency
    const merger = ctx.createChannelMerger(2);

    const oscL = ctx.createOscillator();
    const oscR = ctx.createOscillator();
    const gainL = ctx.createGain();
    const gainR = ctx.createGain();

    oscL.type = 'sine';
    oscR.type = 'sine';
    oscL.frequency.value = baseFreq;
    oscR.frequency.value = baseFreq + 6; // 6Hz difference = theta waves

    gainL.gain.value = 0;
    gainR.gain.value = 0;

    oscL.connect(gainL);
    oscR.connect(gainR);
    gainL.connect(merger, 0, 0);
    gainR.connect(merger, 0, 1);
    merger.connect(master);

    oscL.start();
    oscR.start();

    binaural = { oscL, oscR, gainL, gainR, baseFreq };
}

function updateBinaural() {
    if (!binaural) return;
    const now = ctx.currentTime;

    // Binaural intensity based on journey stage
    const stageAmp = [0.03, 0.05, 0.08, 0.12, 0.08, 0.15][J.stage];
    const amp = stageAmp * (0.5 + F.breath * 0.5);

    binaural.gainL.gain.linearRampToValueAtTime(amp, now + 0.5);
    binaural.gainR.gain.linearRampToValueAtTime(amp, now + 0.5);

    // Frequency difference changes with stage
    // Deeper stages = slower theta, transcendence = higher alpha
    const beatFreqs = [4, 5, 6, 7, 8, 10]; // Hz difference per stage
    const beatFreq = beatFreqs[J.stage];

    binaural.oscL.frequency.linearRampToValueAtTime(binaural.baseFreq, now + 1);
    binaural.oscR.frequency.linearRampToValueAtTime(binaural.baseFreq + beatFreq, now + 1);
}

// ============ SHIMMER - HIGH FREQUENCY TINGLE ============

function createShimmer() {
    // Very high frequencies that create that "tingle" sensation
    // Multiple detuned oscillators in the 3-6kHz range

    const oscs = [];
    const output = ctx.createGain();
    output.gain.value = 0;

    const freqs = [3000, 4000, 5000, 6000];
    freqs.forEach((f, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = f;
        osc.detune.value = Math.random() * 20 - 10;

        const g = ctx.createGain();
        g.gain.value = 0.1 / freqs.length;

        osc.connect(g);
        g.connect(output);
        osc.start();
        oscs.push({ osc, gain: g });
    });

    output.connect(reverb);
    shimmer = { oscs, output };
}

function updateShimmer() {
    if (!shimmer) return;
    const now = ctx.currentTime;

    // Shimmer emerges in later stages, peaks at transcendence
    const stageAmp = [0, 0, 0.02, 0.03, 0.08, 0.15][J.stage];
    const amp = stageAmp * J.frisson;

    shimmer.output.gain.linearRampToValueAtTime(amp, now + 0.3);

    // Slight frequency wobble
    shimmer.oscs.forEach((s, i) => {
        const wobble = Math.sin(now * (0.5 + i * 0.2)) * 50;
        s.osc.detune.linearRampToValueAtTime(wobble, now + 0.1);
    });
}

// ============ WHISPER - VOCAL-LIKE FORMANTS ============

function createWhisper() {
    // Filtered noise that sounds almost like distant voices
    // Uses formant frequencies to create vocal quality

    const bufferSize = ctx.sampleRate * 2;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    noise.loop = true;

    // Formant filters (vowel-like resonances)
    const formants = [
        { freq: 700, Q: 10 },   // "ah"
        { freq: 1200, Q: 8 },   // "eh"
        { freq: 2500, Q: 6 }    // "ee" / presence
    ];

    const filters = formants.map(f => {
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = f.freq;
        filter.Q.value = f.Q;
        return filter;
    });

    const output = ctx.createGain();
    output.gain.value = 0;

    // Parallel formants
    filters.forEach(f => {
        noise.connect(f);
        f.connect(output);
    });

    output.connect(reverb);
    noise.start();

    whisper = { noise, filters, output };
}

function updateWhisper() {
    if (!whisper) return;
    const now = ctx.currentTime;

    // Whispers appear in deep/emergence stages
    const stageAmp = [0, 0, 0.01, 0.04, 0.03, 0.02][J.stage];
    const amp = stageAmp * (0.5 + F.breath * 0.5);

    whisper.output.gain.linearRampToValueAtTime(amp, now + 0.5);

    // Formants shift slowly, creating morphing "words"
    const shift = Math.sin(now * 0.2) * 200;
    whisper.filters[0].frequency.linearRampToValueAtTime(700 + shift, now + 0.5);
    whisper.filters[1].frequency.linearRampToValueAtTime(1200 - shift * 0.5, now + 0.5);
}

// ============ ORBITAL SOUNDS - SPATIAL MOVEMENT ============

function createOrbitSound(freq, radius) {
    // A sound that rotates around the listener in stereo

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const panL = ctx.createGain();
    const panR = ctx.createGain();
    const merger = ctx.createChannelMerger(2);

    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.value = 0;

    osc.connect(gain);
    gain.connect(panL);
    gain.connect(panR);
    panL.connect(merger, 0, 0);
    panR.connect(merger, 0, 1);
    merger.connect(master);
    merger.connect(reverb);

    osc.start();

    return { osc, gain, panL, panR, radius, angle: Math.random() * TAU };
}

function initOrbits() {
    // Create several orbital sounds at harmonics of the root
    const harmonics = [2, 3, 4, 5, 6];
    harmonics.forEach((h, i) => {
        const freq = DNA.root * h;
        orbitSounds.push(createOrbitSound(freq, 0.8 - i * 0.12));
    });
}

function updateOrbits() {
    const now = ctx.currentTime;
    F.orbit += 0.005 * (1 + J.intensity);

    orbitSounds.forEach((o, i) => {
        // Rotate at different speeds
        o.angle += 0.01 * (1 + i * 0.3) * (1 + F.speed);

        // Pan based on angle
        const pan = Math.sin(o.angle);
        const depth = Math.cos(o.angle) * 0.5 + 0.5; // 0.5 to 1 (front/back simulation)

        o.panL.gain.linearRampToValueAtTime((1 - pan) * 0.5 * depth, now + 0.05);
        o.panR.gain.linearRampToValueAtTime((1 + pan) * 0.5 * depth, now + 0.05);

        // Amplitude based on stage
        const stageAmp = [0, 0.02, 0.04, 0.06, 0.08, 0.1][J.stage];
        o.gain.gain.linearRampToValueAtTime(stageAmp * (0.5 + F.speed * 0.5), now + 0.1);
    });
}

// ============ THE JOURNEY - NOW ACTUALLY RESPONSIVE ============

function updateJourney() {
    const now = ctx.currentTime;
    const dt = 1/60;

    J.totalTime += dt;
    J.stageTime += dt;

    // Breath cycle
    F.breath = (Math.sin(now * TAU / 5) + 1) / 2;

    // LFO
    F.lfo = Math.sin(now * 0.3) * 0.5 + 0.5;

    // ENERGY accumulates with movement - this drives everything
    F.energy = Math.min(1, F.energy * 0.998 + F.speed * 0.02);

    // TENSION NOW BUILDS CONTINUOUSLY based on energy AND time since last drop
    const timeSinceDrop = now - J.lastDrop;
    const tensionGrowth = 0.002 + F.energy * 0.008 + (timeSinceDrop * 0.0001);
    J.tension = Math.min(1, J.tension + tensionGrowth);

    // Intensity for visuals
    J.intensity = Math.min(1, J.intensity * 0.995 + F.speed * 0.02 + 0.001);

    // Frisson decays but can spike
    J.frisson *= 0.98;

    // CHORD CHANGES - happen on their own timeline
    if (now > J.nextChordTime) {
        J.chordIndex = (J.chordIndex + 1) % DNA.chordSet.length;
        morphToChord(J.chordIndex);
        // Next chord change in 6-15 seconds
        J.nextChordTime = now + 6 + Math.random() * 9;
    }

    // THE DROP - triggers when tension is high enough (much lower threshold!)
    // Minimum 8 seconds between drops, tension threshold based on DNA
    if (J.tension > DNA.dropThreshold && !J.dropPending && timeSinceDrop > 8) {
        J.dropPending = true;
        scheduleDrop(now + 1.5 + Math.random()); // drop in 1.5-2.5 seconds
    }

    // RANDOM CHAOS EVENTS - based on DNA.chaosLevel
    if (Math.random() < DNA.chaosLevel * 0.01) {
        triggerChaos();
    }

    // Stage progression - faster, based on energy not time
    const stageThresholds = [
        { energy: 0.15, time: 5 },   // VOID → AWAKENING
        { energy: 0.3, time: 12 },   // AWAKENING → DESCENT
        { energy: 0.5, time: 25 },   // DESCENT → DEEP
        { energy: 0.7, time: 45 },   // DEEP → EMERGENCE
        { energy: 0.85, time: 70 }   // EMERGENCE → TRANSCEND
    ];

    if (J.stage < 5) {
        const threshold = stageThresholds[J.stage];
        if (F.energy > threshold.energy && J.totalTime > threshold.time) {
            advanceStage();
        }
    }

    // Darkness based on stage and tension
    M.darkness = Math.min(1, [0, 0.15, 0.4, 0.8, 0.5, 0.2][J.stage] + J.tension * 0.3);
}

function advanceStage() {
    J.stage = Math.min(5, J.stage + 1);
    J.stageTime = 0;

    // Key modulation on certain stages
    if (J.stage === 4) { // EMERGENCE
        modulateKey(1);
        J.frisson = 0.5;
    } else if (J.stage === 5) { // TRANSCEND
        modulateKey(2);
        J.frisson = 0.8;
    }

    // Trigger a surprise sound
    triggerSurprise();
}

function modulateKey(semitones) {
    J.keyOffset += semitones;
    const now = ctx.currentTime;

    // Shift all walls
    walls.forEach(w => {
        const newFreq = DNA.root * Math.pow(2, (w.semitone + J.keyOffset) / 12);
        w.oscs.forEach(osc => {
            osc.frequency.linearRampToValueAtTime(newFreq, now + 0.5);
        });
    });

    // Shift sub drone
    const newSub = subDrone.baseFreq * Math.pow(2, J.keyOffset / 12);
    subDrone.sub.frequency.linearRampToValueAtTime(newSub, now + 0.5);
    subDrone.sub2.frequency.linearRampToValueAtTime(newSub * 1.002, now + 0.5);
}

// CHAOS EVENTS - random disruptions
function triggerChaos() {
    const now = ctx.currentTime;
    const chaos = Math.random();

    if (chaos < 0.3) {
        // Filter sweep
        walls.forEach(w => {
            const target = 200 + Math.random() * 4000;
            w.filter.frequency.linearRampToValueAtTime(target, now + 0.1);
            w.filter.frequency.linearRampToValueAtTime(800, now + 0.5);
        });
    } else if (chaos < 0.5) {
        // Pitch wobble
        walls.forEach(w => {
            w.oscs.forEach(osc => {
                const wobble = (Math.random() - 0.5) * 100;
                osc.detune.linearRampToValueAtTime(wobble, now + 0.05);
                osc.detune.linearRampToValueAtTime(0, now + 0.3);
            });
        });
    } else if (chaos < 0.7) {
        // Volume duck
        master.gain.linearRampToValueAtTime(0.3, now + 0.05);
        master.gain.linearRampToValueAtTime(0.8, now + 0.2);
    } else {
        // Random melodic fragment
        playRandomMelody();
    }
}

function triggerSurprise() {
    // Play a surprising sound on stage change
    const now = ctx.currentTime;
    J.surpriseCount++;

    // Rising sweep
    const sweep = ctx.createOscillator();
    const sweepGain = ctx.createGain();
    sweep.type = 'sawtooth';
    sweep.frequency.setValueAtTime(DNA.root, now);
    sweep.frequency.exponentialRampToValueAtTime(DNA.root * 4, now + 0.5);
    sweepGain.gain.setValueAtTime(0.3, now);
    sweepGain.gain.exponentialRampToValueAtTime(0.001, now + 0.6);

    sweep.connect(sweepGain);
    sweepGain.connect(reverb);
    sweepGain.connect(master);
    sweep.start(now);
    sweep.stop(now + 0.7);
}

function playRandomMelody() {
    // Quick random melody from the scale
    const scale = DNA.scale.notes;
    const numNotes = 3 + Math.floor(Math.random() * 4);
    const baseOctave = 1 + Math.floor(Math.random() * 2);

    for (let i = 0; i < numNotes; i++) {
        const degree = scale[Math.floor(Math.random() * scale.length)];
        const octave = baseOctave * 12;
        setTimeout(() => {
            playDarkNote(degree + octave + J.keyOffset, M.beatTime * 2);
        }, i * 80);
    }
}

// ============ THE DROP - SILENCE THEN RELEASE ============

function scheduleDrop(time) {
    // Everything cuts out, tension hangs, then SLAM back
    const now = ctx.currentTime;
    const silenceDuration = 0.8 + Math.random() * 0.7; // 0.8-1.5 seconds

    // Fade everything out quickly
    setTimeout(() => {
        J.silenceUntil = ctx.currentTime + silenceDuration;
        master.gain.linearRampToValueAtTime(0.02, ctx.currentTime + 0.15);

        // Maybe shift to a new chord during the silence
        if (Math.random() > 0.5) {
            J.chordIndex = (J.chordIndex + 1) % DNA.chordSet.length;
            morphToChord(J.chordIndex);
        }
    }, (time - now - 0.3) * 1000);

    // THE RETURN - slam back harder
    setTimeout(() => {
        const returnTime = ctx.currentTime;

        // Volume surge (louder than before)
        master.gain.linearRampToValueAtTime(1.2, returnTime + 0.02);
        master.gain.linearRampToValueAtTime(0.85, returnTime + 0.3);

        J.dropPending = false;
        J.lastDrop = returnTime;
        J.tension = 0.1; // reset but not to zero

        // BIG frisson spike
        J.frisson = Math.min(1, J.frisson + 0.7);

        // Impact sounds
        playKick();
        setTimeout(() => playKick(), 50);
        setTimeout(() => playKick(), 100);

        // Maybe key change on the drop
        if (Math.random() > 0.7) {
            modulateKey(Math.random() > 0.5 ? 1 : -1);
        }

        // Regenerate groove pattern for variety
        if (Math.random() > 0.6) {
            generateGroove();
        }

    }, (time - now + silenceDuration) * 1000);
}

// ============ DARK MELODIC VOICES ============

function playDarkNote(semitones, duration) {
    const freq = DNA.root * Math.pow(2, semitones / 12);
    const now = ctx.currentTime;

    // Supersaw voice for melody - with randomized character
    const NUM = 3 + Math.floor(Math.random() * 3); // 3-5 oscillators
    const oscs = [];
    const output = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    for (let i = 0; i < NUM; i++) {
        const osc = ctx.createOscillator();
        // Random waveform selection
        osc.type = ['sawtooth', 'square', 'triangle'][Math.floor(Math.random() * 3)];
        osc.frequency.value = freq;
        osc.detune.value = (Math.random() - 0.5) * 50; // random detune
        osc.connect(filter);
        osc.start(now);
        osc.stop(now + duration + 0.5);
        oscs.push(osc);
    }

    filter.type = 'lowpass';
    filter.frequency.value = 1500 + Math.random() * 2000;
    filter.Q.value = 1 + Math.random() * 5;

    // Filter envelope with variation
    const filterStart = 2000 + Math.random() * 4000;
    const filterEnd = 400 + Math.random() * 600;
    filter.frequency.setValueAtTime(filterStart, now);
    filter.frequency.exponentialRampToValueAtTime(filterEnd, now + duration * 0.7);

    // Amplitude with variation
    const amp = 0.1 + Math.random() * 0.1;
    output.gain.setValueAtTime(0, now);
    output.gain.linearRampToValueAtTime(amp, now + 0.01);
    output.gain.exponentialRampToValueAtTime(0.001, now + duration);

    // Random panning
    const pan = ctx.createStereoPanner();
    pan.pan.value = (Math.random() - 0.5) * 0.8;

    filter.connect(pan);
    pan.connect(output);
    output.connect(master);
    output.connect(delay);
    output.connect(reverb);
}

function playCluster() {
    // Cluster chord from current scale
    const scale = DNA.scale.notes;

    // Pick octave based on position
    const octave = Math.floor((F.y + 1) * 1.5 + 1) * 12;

    // Pick 2-4 notes from scale
    const numNotes = 2 + Math.floor(Math.random() * 3);
    const notes = [];

    for (let i = 0; i < numNotes; i++) {
        const degree = scale[Math.floor(Math.random() * scale.length)];
        notes.push(octave + degree + J.keyOffset);
    }

    // Sometimes add chromatic tension
    if (M.darkness > 0.4 && Math.random() > 0.5) {
        const tension = [1, 6, 11][Math.floor(Math.random() * 3)];
        notes.push(octave + tension + J.keyOffset);
    }

    // Stagger the notes slightly
    notes.forEach((n, i) => {
        const delay = i * (20 + Math.random() * 40);
        setTimeout(() => playDarkNote(n, M.beatTime * (3 + Math.random() * 2)), delay);
    });
}

// ============ MICROPHONE CAPTURE ============

async function initMic() {
    try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micSource = ctx.createMediaStreamSource(micStream);

        // Create buffer for granular
        micBuffer = ctx.createBuffer(1, MIC_BUFFER_SIZE, ctx.sampleRate);

        // Use ScriptProcessor to capture (AudioWorklet would be better but more complex)
        const processor = ctx.createScriptProcessor(4096, 1, 1);
        processor.onaudioprocess = (e) => {
            const input = e.inputBuffer.getChannelData(0);
            const buffer = micBuffer.getChannelData(0);

            for (let i = 0; i < input.length; i++) {
                buffer[micWritePos] = input[i];
                micWritePos = (micWritePos + 1) % MIC_BUFFER_SIZE;
            }
        };

        micSource.connect(processor);
        processor.connect(ctx.createGain()); // dummy connection to keep alive
    } catch (e) {
        console.log('Mic not available');
    }
}

function playGrain() {
    if (!micBuffer) return;

    const now = ctx.currentTime;
    const bufferData = micBuffer.getChannelData(0);

    // Find a loud section to grab
    let bestPos = 0, bestAmp = 0;
    for (let i = 0; i < 10; i++) {
        const pos = Math.floor(Math.random() * (MIC_BUFFER_SIZE - 4096));
        let amp = 0;
        for (let j = 0; j < 512; j++) {
            amp += Math.abs(bufferData[pos + j]);
        }
        if (amp > bestAmp) {
            bestAmp = amp;
            bestPos = pos;
        }
    }

    if (bestAmp < 10) return; // too quiet

    // Create grain
    const grainLen = 0.05 + Math.random() * 0.15;
    const grainSamples = Math.floor(grainLen * ctx.sampleRate);
    const grain = ctx.createBuffer(1, grainSamples, ctx.sampleRate);
    const grainData = grain.getChannelData(0);

    // Copy with envelope
    for (let i = 0; i < grainSamples; i++) {
        const env = Math.sin(Math.PI * i / grainSamples); // smooth envelope
        const srcIdx = (bestPos + i) % MIC_BUFFER_SIZE;
        grainData[i] = bufferData[srcIdx] * env;
    }

    // Play grain
    const source = ctx.createBufferSource();
    source.buffer = grain;

    // Random pitch shift (musical intervals)
    const pitchShifts = [0.5, 0.75, 1, 1, 1.5, 2];
    source.playbackRate.value = pitchShifts[Math.floor(Math.random() * pitchShifts.length)];

    const gain = ctx.createGain();
    gain.gain.value = 0.4;

    const filter = ctx.createBiquadFilter();
    filter.type = Math.random() > 0.5 ? 'lowpass' : 'bandpass';
    filter.frequency.value = 500 + Math.random() * 3000;
    filter.Q.value = 1 + Math.random() * 3;

    const pan = ctx.createStereoPanner();
    pan.pan.value = (Math.random() - 0.5) * 0.8;

    source.connect(filter);
    filter.connect(gain);
    gain.connect(pan);
    pan.connect(master);
    pan.connect(reverb);

    source.start(now);
}

// ============ BEAT ENGINE ============

function playKick() {
    const now = ctx.currentTime;

    // Kick tuned to the root note for musical coherence
    const kickFreq = DNA.root * 2 + Math.random() * 20; // slight variation

    // Sub oscillator
    const sub = ctx.createOscillator();
    sub.type = 'sine';
    sub.frequency.setValueAtTime(kickFreq * 2, now);
    sub.frequency.exponentialRampToValueAtTime(kickFreq * 0.5, now + 0.15);

    // Click with variation
    const click = ctx.createOscillator();
    click.type = Math.random() > 0.5 ? 'triangle' : 'square';
    click.frequency.setValueAtTime(800 + Math.random() * 400, now);
    click.frequency.exponentialRampToValueAtTime(kickFreq, now + 0.03);

    const subGain = ctx.createGain();
    const clickGain = ctx.createGain();
    const output = ctx.createGain();

    // Amplitude variation
    const amp = 0.6 + Math.random() * 0.3;
    subGain.gain.setValueAtTime(amp * M.beatIntensity, now);
    subGain.gain.exponentialRampToValueAtTime(0.001, now + 0.25 + Math.random() * 0.1);

    clickGain.gain.setValueAtTime((amp * 0.6) * M.beatIntensity, now);
    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);

    output.gain.value = 0.7;

    sub.connect(subGain);
    click.connect(clickGain);
    subGain.connect(output);
    clickGain.connect(output);
    output.connect(master);

    sub.start(now);
    click.start(now);
    sub.stop(now + 0.4);
    click.stop(now + 0.1);
}

function playSnare() {
    const now = ctx.currentTime;

    // Varied noise length
    const noiseLen = 0.1 + Math.random() * 0.1;
    const noise = ctx.createBuffer(1, ctx.sampleRate * noiseLen, ctx.sampleRate);
    const noiseData = noise.getChannelData(0);
    const decay = 0.03 + Math.random() * 0.04;
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * decay));
    }

    const noiseSource = ctx.createBufferSource();
    noiseSource.buffer = noise;

    // Tone body with pitch variation
    const tone = ctx.createOscillator();
    tone.type = Math.random() > 0.7 ? 'square' : 'triangle';
    tone.frequency.value = 150 + Math.random() * 100;

    const noiseGain = ctx.createGain();
    const toneGain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 800 + Math.random() * 600;

    // Random pan
    const pan = ctx.createStereoPanner();
    pan.pan.value = (Math.random() - 0.5) * 0.4;

    const amp = 0.5 + Math.random() * 0.2;
    noiseGain.gain.setValueAtTime(amp * M.beatIntensity, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + noiseLen);

    toneGain.gain.setValueAtTime((amp * 0.5) * M.beatIntensity, now);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

    noiseSource.connect(filter);
    filter.connect(noiseGain);
    tone.connect(toneGain);
    noiseGain.connect(pan);
    toneGain.connect(pan);
    pan.connect(master);
    noiseGain.connect(reverb);

    noiseSource.start(now);
    tone.start(now);
    tone.stop(now + 0.15);
}

function playHat(open = false) {
    const now = ctx.currentTime;

    const len = open ? 0.2 : 0.05;
    const noise = ctx.createBuffer(1, ctx.sampleRate * len, ctx.sampleRate);
    const data = noise.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1);
    }

    const source = ctx.createBufferSource();
    source.buffer = noise;

    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 7000;

    gain.gain.setValueAtTime(0.25 * M.beatIntensity, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + len);

    source.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    source.start(now);
}

function updateBeat() {
    // Beat drops based on energy now, not layers
    if (!M.beatDropped && F.energy > 0.2) {
        M.beatDropped = true;
        M.beatIntensity = 0.4;
    }

    if (!M.beatDropped) return;

    // Intensity builds with energy and tension
    const targetIntensity = 0.4 + F.energy * 0.3 + J.tension * 0.2;
    M.beatIntensity += (targetIntensity - M.beatIntensity) * 0.02;
    M.beatIntensity = Math.min(1, M.beatIntensity);

    // Use the GENERATED groove pattern
    const beat = M.playhead % M.groove.length;
    const groove = M.groove[beat];

    // Probability gate - not every beat fires
    if (Math.random() > groove.probability * M.beatIntensity) return;

    // Play elements based on generated pattern
    if (groove.kick) {
        playKick();
        // Sometimes double hit
        if (groove.accent && Math.random() > 0.6) {
            setTimeout(() => playKick(), 30 + Math.random() * 30);
        }
    }

    if (groove.snare && M.beatIntensity > 0.4) {
        playSnare();
    }

    if (groove.hat && M.beatIntensity > 0.3) {
        playHat(groove.accent);
    }

    // Random ghost notes at high intensity
    if (M.beatIntensity > 0.7 && Math.random() > 0.8) {
        setTimeout(() => {
            if (Math.random() > 0.5) playKick();
            else playHat(false);
        }, M.beatTime * 250); // off-grid
    }
}

// ============ MEMORY SYSTEM - NOW WITH MUTATION ============

function snapshot() {
    return {
        x: F.x,
        y: F.y,
        speed: F.speed,
        density: F.density,
        energy: F.energy
    };
}

function mutateTape() {
    // Slowly mutate the recorded tape - nothing stays the same
    if (M.tape.length === 0) return;

    const idx = Math.floor(Math.random() * M.tape.length);
    const mutation = (Math.random() - 0.5) * DNA.mutationRate * 2;

    // Mutate a random property
    const prop = ['x', 'y', 'speed'][Math.floor(Math.random() * 3)];
    M.tape[idx][prop] = Math.max(-1, Math.min(1, M.tape[idx][prop] + mutation));
}

function updateMemory() {
    const now = ctx.currentTime;

    // Apply swing to beat timing
    const swingOffset = (M.playhead % 2 === 1) ? DNA.swingAmount * M.beatTime : 0;
    const effectiveBeatTime = M.beatTime + swingOffset * 0.5;

    if (now - M.lastBeat >= effectiveBeatTime) {
        M.lastBeat = now;

        if (M.mode === 'building') {
            M.tape.push(snapshot());
            if (M.tape.length >= M.loopLen) {
                M.mode = 'looping';
                M.playhead = 0;
            }
        } else {
            M.playhead = (M.playhead + 1) % M.loopLen;

            // ACCUMULATE MUTATION
            M.mutationAccum += DNA.mutationRate;
            if (M.mutationAccum > 1) {
                mutateTape();
                M.mutationAccum = 0;
            }

            // Beat system
            updateBeat();

            // PROBABILISTIC melodic events - not tied to specific beats
            const melodicChance = 0.15 + F.energy * 0.2 + J.tension * 0.1;

            if (Math.random() < melodicChance) {
                // Cluster or single note?
                if (Math.random() > 0.6) {
                    playCluster();
                } else {
                    // Single note from scale
                    const scale = DNA.scale.notes;
                    const degree = scale[Math.floor(Math.random() * scale.length)];
                    const octave = Math.floor(Math.random() * 2 + 1) * 12;
                    playDarkNote(degree + octave + J.keyOffset, M.beatTime * (2 + Math.random() * 3));
                }
            }

            // Grains - probabilistic
            if (Math.random() < 0.15 + F.speed * 0.2) {
                playGrain();
            }

            // Random melodic runs at high tension
            if (J.tension > 0.6 && Math.random() > 0.95) {
                playRandomMelody();
            }

            // Layer recording
            if (M.activeLayer) {
                M.activeLayer.push(snapshot());
                if (M.activeLayer.length >= M.loopLen) {
                    M.layers.push(M.activeLayer);
                    M.activeLayer = null;
                    if (M.layers.length > 3) M.layers.shift();
                }
            }
        }
    }
}

function getBlendedState() {
    if (M.mode === 'building' || M.tape.length === 0) {
        return { x: F.x, y: F.y, speed: F.speed };
    }

    const rec = M.tape[M.playhead];
    const live = 1 - M.blend;
    const loop = M.blend;

    let x = rec.x * loop + F.x * live;
    let y = rec.y * loop + F.y * live;
    let speed = rec.speed * loop + F.speed * live;

    M.layers.forEach((layer, li) => {
        const ls = layer[M.playhead];
        const w = 0.3 / (li + 1);
        x += ls.x * w;
        y += ls.y * w;
        speed += ls.speed * w;
    });

    return {
        x: Math.max(-1, Math.min(1, x)),
        y: Math.max(-1, Math.min(1, y)),
        speed: Math.min(1, speed)
    };
}

// ============ INPUT HANDLERS ============

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    F.vx = F.vx * 0.8 + (a.x || 0) * 0.02;
    F.vy = F.vy * 0.8 + (a.y || 0) * 0.02;
    F.vz = F.vz * 0.8 + (a.z || 0) * 0.02;

    F.speed = Math.min(1, Math.sqrt(F.vx*F.vx + F.vy*F.vy + F.vz*F.vz) / 3);
    F.density = F.density * 0.99 + F.speed * 0.01;
}

function onOrientation(e) {
    F.x = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    F.y = Math.max(-1, Math.min(1, (e.beta || 0) / 45 - 1));
    F.field = (e.alpha || 0) / 360;
}

function onPointer(x, y) {
    const px = (x / window.innerWidth) * 2 - 1;
    const py = 1 - (y / window.innerHeight) * 2;

    F.vx = F.vx * 0.7 + (px - F.x) * 0.3;
    F.vy = F.vy * 0.7 + (py - F.y) * 0.3;

    F.x = px;
    F.y = py;

    F.speed = Math.min(1, Math.sqrt(F.vx*F.vx + F.vy*F.vy) * 3);
    F.density = F.density * 0.98 + F.speed * 0.02;
}

// ============ VISUALIZATION ============

let vc;
function initViz() {
    const canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const canvas = document.getElementById('c');
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

// Stage color palettes - each stage has its own vibe
const STAGE_COLORS = {
    0: { bg: [0, 0, 5], core: [180, 30, 30], ring: [200, 40, 20] },      // VOID - deep black, dim cyan
    1: { bg: [5, 5, 10], core: [200, 50, 40], ring: [180, 60, 30] },     // AWAKENING - emerging blue
    2: { bg: [10, 0, 15], core: [270, 60, 45], ring: [260, 50, 35] },    // DESCENT - purple tension
    3: { bg: [15, 0, 20], core: [300, 70, 35], ring: [280, 60, 30] },    // DEEP - deep magenta
    4: { bg: [10, 10, 20], core: [30, 80, 55], ring: [40, 70, 45] },     // EMERGENCE - golden hope
    5: { bg: [20, 20, 30], core: [50, 90, 70], ring: [60, 85, 60] }      // TRANSCEND - brilliant white-gold
};

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const S = getBlendedState();
    const colors = STAGE_COLORS[J.stage];

    // Background - stage dependent, darkens during silence
    const silenceMult = ctx && ctx.currentTime < J.silenceUntil ? 0.3 : 1;
    vc.fillStyle = `rgba(${colors.bg[0] * silenceMult},${colors.bg[1] * silenceMult},${colors.bg[2] * silenceMult},${0.08 + (1-F.density) * 0.07})`;
    vc.fillRect(0, 0, w, h);

    const cx = w/2 + S.x * w * 0.25;
    const cy = h/2 - S.y * h * 0.25;
    const loopR = Math.min(w, h) * 0.4;

    // FRISSON PARTICLES - sparkles when frisson is high
    if (J.frisson > 0.2) {
        const numParticles = Math.floor(J.frisson * 50);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * TAU;
            const dist = loopR * 0.3 + Math.random() * loopR * 0.8;
            const px = w/2 + Math.cos(angle) * dist;
            const py = h/2 + Math.sin(angle) * dist;
            const size = 1 + Math.random() * 3 * J.frisson;

            vc.beginPath();
            vc.arc(px, py, size, 0, TAU);
            vc.fillStyle = `rgba(255,255,${200 + Math.random() * 55},${J.frisson * 0.7})`;
            vc.fill();
        }
    }

    // TENSION WAVES - pulsing circles when tension builds
    if (J.tension > 0.3) {
        const numWaves = Math.floor(J.tension * 4);
        for (let i = 0; i < numWaves; i++) {
            const wavePhase = (F.phase * 0.5 + i * 0.25) % 1;
            const waveR = loopR * 0.5 + wavePhase * loopR * 0.7;
            vc.beginPath();
            vc.arc(w/2, h/2, waveR, 0, TAU);
            vc.strokeStyle = `rgba(${colors.ring[0]}, ${colors.ring[1]}%, ${colors.ring[2]}%, ${(1 - wavePhase) * J.tension * 0.3})`;
            vc.lineWidth = 2 + J.tension * 3;
            vc.stroke();
        }
    }

    // Outer loop ring
    if (M.tape.length > 0) {
        const progress = M.mode === 'building'
            ? M.tape.length / M.loopLen
            : (M.playhead + 1) / M.loopLen;

        vc.beginPath();
        vc.arc(w/2, h/2, loopR, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
        vc.strokeStyle = M.mode === 'building'
            ? 'rgba(255,100,100,0.4)'
            : `hsla(${colors.ring[0]}, ${colors.ring[1]}%, ${colors.ring[2]}%, 0.35)`;
        vc.lineWidth = M.beatDropped ? 4 + M.beatIntensity * 4 : 3;
        vc.stroke();
    }

    // Layer rings
    M.layers.forEach((_, i) => {
        vc.beginPath();
        vc.arc(w/2, h/2, loopR - 12 - i * 10, 0, Math.PI * 2);
        vc.strokeStyle = `hsla(${colors.ring[0]}, ${colors.ring[1]}%, ${colors.ring[2] + 10}%, ${0.15 + i * 0.08})`;
        vc.lineWidth = 2;
        vc.stroke();
    });

    // Recording ring
    if (M.activeLayer) {
        const recP = M.activeLayer.length / M.loopLen;
        vc.beginPath();
        vc.arc(w/2, h/2, loopR - 12 - M.layers.length * 10, -Math.PI/2, -Math.PI/2 + recP * Math.PI * 2);
        vc.strokeStyle = 'rgba(255,100,100,0.6)';
        vc.lineWidth = 3;
        vc.stroke();
    }

    // Beat pulse
    if (M.beatDropped) {
        const beatPulse = Math.sin(M.playhead * Math.PI / 4) * 0.5 + 0.5;
        vc.beginPath();
        vc.arc(w/2, h/2, loopR + 20 + beatPulse * 15 * M.beatIntensity, 0, Math.PI * 2);
        vc.strokeStyle = `rgba(255,200,100,${0.1 + beatPulse * 0.2 * M.beatIntensity})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Wall visualization - massive rings that pulse
    walls.forEach((wall, i) => {
        const amp = wall.output.gain.value;
        if (amp > 0.005) {
            const r = 50 + i * 40 + amp * 100;
            vc.beginPath();
            vc.arc(cx, cy, r, 0, Math.PI * 2);
            // Colors based on stage
            const hue = colors.core[0] - i * 15 + J.frisson * 30;
            vc.strokeStyle = `hsla(${hue}, ${colors.core[1] + 20}%, ${colors.core[2] + amp * 25}%, ${amp * 1.5})`;
            vc.lineWidth = 3 + amp * 10;
            vc.stroke();
        }
    });

    // ORBITAL VISUALIZATION - spinning lights
    orbitSounds.forEach((o, i) => {
        const orbitAmp = o.gain.gain.value;
        if (orbitAmp > 0.01) {
            const orbitR = loopR * 0.6 + i * 20;
            const ox = w/2 + Math.cos(o.angle) * orbitR;
            const oy = h/2 + Math.sin(o.angle) * orbitR;

            vc.beginPath();
            vc.arc(ox, oy, 4 + orbitAmp * 20, 0, TAU);
            vc.fillStyle = `hsla(${colors.core[0] + i * 30}, 70%, 60%, ${orbitAmp * 3})`;
            vc.fill();
        }
    });

    // Darkness fog creeping in
    if (M.darkness > 0.1) {
        const fogGr = vc.createRadialGradient(w/2, h/2, loopR * 0.5, w/2, h/2, loopR * 1.5);
        fogGr.addColorStop(0, 'transparent');
        fogGr.addColorStop(1, `rgba(20,0,30,${M.darkness * 0.4})`);
        vc.fillStyle = fogGr;
        vc.fillRect(0, 0, w, h);
    }

    // BINAURAL VISUALIZATION - subtle pulsing rings at breath rate
    if (binaural && J.stage > 0) {
        const binAmp = binaural.gainL.gain.value;
        if (binAmp > 0.01) {
            const binR = 80 + F.breath * 30;
            vc.beginPath();
            vc.arc(cx, cy, binR, 0, TAU);
            vc.strokeStyle = `rgba(100,150,255,${binAmp * 2})`;
            vc.lineWidth = 1 + F.breath * 2;
            vc.stroke();
        }
    }

    // Core - shifts color with stage
    const coreR = 30 + S.speed * 40 + J.frisson * 20;
    const gr = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    gr.addColorStop(0, `hsla(${colors.core[0]}, ${colors.core[1]}%, ${colors.core[2] + 20}%, ${0.5 + S.speed * 0.4 + J.frisson * 0.3})`);
    gr.addColorStop(0.5, `hsla(${colors.core[0] - 30}, ${colors.core[1] - 10}%, ${colors.core[2]}%, ${0.3 + S.speed * 0.2})`);
    gr.addColorStop(1, 'transparent');
    vc.fillStyle = gr;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, Math.PI * 2);
    vc.fill();

    // GLITCH EFFECT - during high tension moments
    if (J.tension > 0.7 && Math.random() > 0.9) {
        const glitchH = 5 + Math.random() * 20;
        const glitchY = Math.random() * h;
        const glitchShift = (Math.random() - 0.5) * 30;

        // Slice and shift
        const imgData = vc.getImageData(0, glitchY, w, glitchH);
        vc.putImageData(imgData, glitchShift, glitchY);
    }

    // Mic activity indicator
    if (micBuffer) {
        const micLevel = micBuffer.getChannelData(0).slice(micWritePos - 512, micWritePos)
            .reduce((a, b) => a + Math.abs(b), 0) / 512;
        if (micLevel > 0.01) {
            vc.beginPath();
            vc.arc(cx, cy, coreR + 10 + micLevel * 50, 0, Math.PI * 2);
            vc.strokeStyle = `rgba(255,150,100,${micLevel * 2})`;
            vc.lineWidth = 2;
            vc.stroke();
        }
    }

    // STAGE INDICATOR - subtle text at bottom
    const stageNames = ['VOID', 'AWAKENING', 'DESCENT', 'DEEP', 'EMERGENCE', 'TRANSCEND'];
    vc.font = '10px system-ui';
    vc.fillStyle = `rgba(255,255,255,${0.1 + J.intensity * 0.2})`;
    vc.textAlign = 'center';
    vc.fillText(stageNames[J.stage], w/2, h - 30);
}

function updateUI() {
    // Stage names with emotional cues
    const stageNames = ['VOID', 'AWAKENING', 'DESCENT', 'DEEP', 'EMERGENCE', 'TRANSCEND'];
    let stageName = stageNames[J.stage];

    // Add tension/frisson indicators
    if (J.tension > 0.5) stageName += ' \u2191';  // tension rising
    if (J.dropPending) stageName += ' ...';       // drop coming
    if (J.frisson > 0.3) stageName += ' \u2728'; // sparkle for frisson

    document.getElementById('stage').textContent = stageName;

    // Show energy instead of raw speed
    document.getElementById('flw').textContent = F.energy.toFixed(2);

    // Show DNA mood instead of layers
    const moodInfo = DNA.scale ? DNA.scale.mood.toUpperCase() : 'INIT';
    document.getElementById('layers').textContent = moodInfo;

    // Journey time
    const mins = Math.floor(J.totalTime / 60);
    const secs = Math.floor(J.totalTime % 60);
    document.getElementById('journey').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ============ MAIN LOOP ============

function tick() {
    if (!running) return;

    F.phase += 0.01 * (1 + F.speed);

    // The journey evolves
    updateJourney();
    updateMemory();

    // Auto-start layer recording on significant movement
    if (M.mode === 'looping' && !M.activeLayer && F.speed > 0.35) {
        M.activeLayer = [];
    }

    // Update all sound layers
    updateWalls();
    updateTexture();
    updateBinaural();
    updateShimmer();
    updateWhisper();
    updateOrbits();

    draw();
    updateUI();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('start').classList.add('off');
    document.getElementById('app').classList.add('on');

    // Request permissions
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);
    document.addEventListener('mousemove', e => onPointer(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        onPointer(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    init();
    initViz();
    running = true;
    tick();
}

document.getElementById('go').addEventListener('click', start);
</script>
</body>
</html>
