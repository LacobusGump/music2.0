<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music 2.0: Environmental Soundscape</title>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; background: linear-gradient(to bottom, #1e3a8a, #7c3aed); color: white; }
    #status { font-size: 0.9rem; opacity: 0.8; }
    #controls { display: flex; flex-wrap: wrap; gap: 1rem; }
  </style>
</head>
<body>
  <div class="text-center p-4 max-w-md">
    <h1 class="text-3xl font-bold mb-4">Music 2.0</h1>
    <p class="mb-4">Immersive soundscape based on your environment. Allow location and motion permissions.</p>
    <button id="startBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-lg transition">Start Music</button>
    <div id="status" class="mt-4">Waiting to start...</div>
    <div id="controls" class="mt-4">
      <label class="flex items-center"><input type="checkbox" id="padToggle" checked class="mr-2"> Ambient Pad</label>
      <label class="flex items-center"><input type="checkbox" id="arpToggle" checked class="mr-2"> Arpeggio</label>
      <label class="flex items-center"><input type="checkbox" id="percToggle" checked class="mr-2"> Percussion</label>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const statusDiv = document.getElementById('status');
    const padToggle = document.getElementById('padToggle');
    const arpToggle = document.getElementById('arpToggle');
    const percToggle = document.getElementById('percToggle');
    let synth, arp, perc, reverb, delay, isPlaying = false;

    // Initialize audio components
    function initAudio() {
      synth = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'triangle' }, envelope: { attack: 0.5, decay: 1, sustain: 0.7, release: 2 } }).toDestination();
      arp = new Tone.PolySynth(Tone.Synth, { oscillator: { type: 'square' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 } }).toDestination();
      perc = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10 }).toDestination();
      reverb = new Tone.Reverb({ decay: 5, wet: 0.5 }).toDestination();
      delay = new Tone.PingPongDelay({ delayTime: '8n', feedback: 0.3, wet: 0.2 }).toDestination();
      synth.connect(reverb);
      arp.connect(delay);
      perc.connect(reverb);
    }

    // Get user location
    async function getLocation() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) reject('Geolocation not supported');
        navigator.geolocation.getCurrentPosition(
          pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
          err => reject(err.message)
        );
      });
    }

    // Fetch weather from Open-Meteo (free, no API key)
    async function getWeather(lat, lon) {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,wind_speed_10m,cloud_cover,weather_code`;
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather fetch failed');
        const data = await response.json();
        return {
          temp: data.current.temperature_2m,
          wind: data.current.wind_speed_10m,
          clouds: data.current.cloud_cover,
          condition: data.current.weather_code // WMO code
        };
      } catch (err) {
        console.error('Weather fetch failed:', err);
        return { temp: 20, wind: 10, clouds: 0, condition: 0 }; // Fallback
      }
    }

    // Get time-based scale and tempo
    function getTimeParams() {
      const hour = new Date().getHours();
      if (hour < 6) return { scale: ['C4', 'Eb4', 'G4', 'Bb4'], tempo: 60 }; // Night: minor, slow
      if (hour < 12) return { scale: ['C4', 'F4', 'A4', 'C5'], tempo: 80 }; // Morning: bright, medium
      if (hour < 18) return { scale: ['G4', 'B4', 'D5', 'F5'], tempo: 100 }; // Afternoon: upbeat, fast
      return { scale: ['A4', 'C5', 'E5', 'G5'], tempo: 70 }; // Evening: calm, medium
    }

    // Handle device motion
    function handleMotion(event) {
      if (!isPlaying) return;
      const accel = event.accelerationIncludingGravity;
      const x = Math.abs(accel.x || 0);
      const volume = Math.min(0, -20 + x * 3); // Tilt to volume
      const filterFreq = Math.min(5000, 200 + x * 500); // Tilt to filter
      synth.volume.value = volume;
      arp.volume.value = volume;
      perc.volume.value = volume;
      if (synth.filter) synth.filter.frequency = filterFreq;
    }

    // Generate music
    async function generateMusic() {
      if (!isPlaying) return;
      try {
        const { lat, lon } = await getLocation();
        const weather = await getWeather(lat, lon);
        const { scale, tempo } = getTimeParams();

        // Map weather to music
        const temp = weather.temp; // -20 to 40°C
        const wind = weather.wind; // 0 to 100 km/h
        const clouds = weather.clouds; // 0 to 100%
        const isRainy = [45, 48, 51, 53, 55, 56, 57, 61, 63, 65, 66, 67].includes(weather.condition);
        const baseFreq = 200 + (temp + 20) * 5; // Temp to pitch
        reverb.wet.value = isRainy ? 0.9 : clouds / 200; // Rain or clouds to reverb
        delay.wet.value = wind / 100; // Wind to delay
        Tone.Transport.bpm.value = Math.max(60, Math.min(120, tempo + wind / 5)); // Wind to tempo

        // Ambient pad
        if (padToggle.checked) {
          const note = scale[Math.floor(Math.random() * scale.length)];
          synth.triggerAttackRelease(note, '2m');
        }

        // Arpeggio
        if (arpToggle.checked) {
          const pattern = scale.concat(scale.map(n => n.replace(/\d/, n => +n + 1))); // Octave up
          let i = 0;
          const arpLoop = new Tone.Loop(time => {
            arp.triggerAttackRelease(pattern[i % pattern.length], '8n', time);
            i++;
          }, '8n').start(0);
        }

        // Percussion
        if (percToggle.checked && Math.random() < clouds / 200) {
          perc.triggerAttackRelease('C2', '8n');
        }

        statusDiv.textContent = `Temp: ${temp}°C, Wind: ${wind} km/h, Clouds: ${clouds}%, Time: ${new Date().toLocaleTimeString()}`;
      } catch (err) {
        statusDiv.textContent = `Error: ${err}. Using fallback data.`;
      }

      setTimeout(generateMusic, 4000);
    }

    // Start music
    startBtn.addEventListener('click', async () => {
      if (isPlaying) return;
      isPlaying = true;
      startBtn.textContent = 'Playing...';
      startBtn.classList.add('opacity-50', 'cursor-not-allowed');
      await Tone.start();
      initAudio();
      Tone.Transport.start();

      // Request motion permission
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceMotionEvent.requestPermission();
          if (permission === 'granted') {
            window.addEventListener('devicemotion', handleMotion);
          } else {
            statusDiv.textContent += ' Motion denied. Tilt won’t affect sound.';
          }
        } catch (err) {
          statusDiv.textContent += ' Motion permission error.';
        }
      } else {
        window.addEventListener('devicemotion', handleMotion);
      }

      generateMusic();
    });
  </script>
</body>
</html>
