<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: The World Is The Song</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            cursor: none;
            font-family: 'Helvetica Neue', sans-serif;
        }

        /* Multi-dimensional orb system */
        .orb-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
            mix-blend-mode: screen;
        }

        .orb-core {
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.9) 0%, 
                rgba(255,255,255,0.4) 30%, 
                transparent 70%);
            box-shadow: 
                0 0 20px rgba(255,255,255,0.5),
                0 0 40px rgba(255,255,255,0.3);
            filter: blur(0.5px);
            z-index: 100;
        }

        .orb-echo {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle,
                transparent 0%,
                rgba(255,255,255,0.05) 30%,
                transparent 70%);
            animation: orbit 8s linear infinite;
        }

        .orb-field {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle,
                rgba(255,100,255,0.1) 0%,
                transparent 50%);
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes orbit {
            from { transform: translate(-50%, -50%) rotate(0deg) translateX(30px) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg) translateX(30px) rotate(-360deg); }
        }

        @keyframes breathe {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.3; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.1; }
        }

        .orb-core.recording {
            background: radial-gradient(circle, 
                rgba(255,100,100,0.9) 0%, 
                rgba(255,0,0,0.4) 30%, 
                transparent 70%);
            box-shadow: 
                0 0 30px rgba(255,0,0,0.7),
                0 0 60px rgba(255,0,0,0.4);
            animation: rec-pulse 1s ease-in-out infinite;
        }

        @keyframes rec-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
        }

        /* Visual feedback layers */
        .freq-viz {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            pointer-events: none;
            opacity: 0.3;
        }

        .freq-bar {
            display: inline-block;
            width: 2%;
            height: 100%;
            background: linear-gradient(to top, 
                rgba(255,255,255,0.1) 0%, 
                rgba(255,255,255,0.8) 100%);
            margin: 0 0.5%;
            transform-origin: bottom;
            transition: transform 0.1s ease-out;
        }

        /* World sensor indicators */
        .world-sensors {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.6;
            text-transform: uppercase;
        }

        .sensor {
            margin: 5px 0;
            transition: all 0.3s ease;
        }

        .sensor.active {
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        .sensor-motion { color: #00ff88; }
        .sensor-light { color: #ffaa00; }
        .sensor-location { color: #00aaff; }
        .sensor-time { color: #ff00ff; }
        .sensor-network { color: #ff0088; }

        /* Pattern matrix */
        .pattern-matrix {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            opacity: 0.4;
        }

        .pattern-step {
            width: 8px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            transition: all 0.1s ease;
        }

        .pattern-step.active {
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .pattern-step.has-sample {
            background: rgba(255,100,255,0.3);
        }

        /* Floating UI */
        .info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .info h1 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 8px;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .info p {
            font-size: 14px;
            opacity: 0.6;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .hide { opacity: 0; }

        /* Particle system */
        .particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: white;
            pointer-events: none;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div class="orb-container">
        <div class="orb orb-field"></div>
        <div class="orb orb-echo"></div>
        <div id="orb" class="orb orb-core"></div>
    </div>

    <div class="world-sensors">
        <div class="sensor sensor-motion">MOTION</div>
        <div class="sensor sensor-light">LIGHT</div>
        <div class="sensor sensor-location">LOCATION</div>
        <div class="sensor sensor-time">TIME</div>
        <div class="sensor sensor-network">NETWORK</div>
    </div>

    <div class="pattern-matrix" id="pattern"></div>
    <div class="freq-viz" id="viz"></div>

    <div class="info" id="info">
        <h1>GUMP</h1>
        <p>Click anywhere to begin</p>
    </div>

    <script>
        'use strict';

        // Genius-level beat matching with AI-like pattern recognition
        class QuantumBeatMatcher {
            constructor() {
                this.bpm = 75;
                this.patterns = new Map();
                this.memory = [];
                this.consciousness = 0;
            }

            // Advanced onset detection using spectral flux
            findTransients(buffer, sr) {
                const data = buffer.getChannelData(0);
                const fftSize = 2048;
                const hop = 512;
                const transients = [];
                
                // Multi-resolution analysis
                const resolutions = [512, 1024, 2048, 4096];
                const allPeaks = [];
                
                for (const resolution of resolutions) {
                    const peaks = this.spectralFlux(data, sr, resolution, hop);
                    allPeaks.push(peaks);
                }
                
                // Combine multi-resolution peaks
                const combined = this.combinePeaks(allPeaks, sr);
                
                // Musical pattern recognition
                const patterns = this.findPatterns(combined);
                
                return { transients: combined, patterns };
            }

            spectralFlux(data, sr, fftSize, hop) {
                const peaks = [];
                const window = new Float32Array(fftSize);
                
                // Hann window
                for (let i = 0; i < fftSize; i++) {
                    window[i] = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / fftSize);
                }
                
                let prevSpectrum = new Float32Array(fftSize / 2);
                
                for (let pos = 0; pos < data.length - fftSize; pos += hop) {
                    // Window the signal
                    const windowed = new Float32Array(fftSize);
                    for (let i = 0; i < fftSize; i++) {
                        windowed[i] = data[pos + i] * window[i];
                    }
                    
                    // Simple FFT magnitude (simplified for demo)
                    const spectrum = this.getSpectrum(windowed);
                    
                    // Spectral flux
                    let flux = 0;
                    for (let i = 0; i < spectrum.length; i++) {
                        const diff = spectrum[i] - prevSpectrum[i];
                        if (diff > 0) flux += diff;
                    }
                    
                    if (flux > 0.1 && peaks.length > 0 && pos / sr - peaks[peaks.length - 1].time > 0.05) {
                        peaks.push({
                            time: pos / sr,
                            strength: flux,
                            freq: this.dominantFreq(spectrum, sr, fftSize)
                        });
                    }
                    
                    prevSpectrum = spectrum;
                }
                
                return peaks;
            }

            getSpectrum(data) {
                // Simplified spectrum calculation
                const spectrum = new Float32Array(data.length / 2);
                for (let i = 0; i < spectrum.length; i++) {
                    let real = 0, imag = 0;
                    for (let j = 0; j < data.length; j++) {
                        const angle = -2 * Math.PI * i * j / data.length;
                        real += data[j] * Math.cos(angle);
                        imag += data[j] * Math.sin(angle);
                    }
                    spectrum[i] = Math.sqrt(real * real + imag * imag);
                }
                return spectrum;
            }

            dominantFreq(spectrum, sr, fftSize) {
                let maxBin = 0;
                let maxVal = 0;
                for (let i = 0; i < spectrum.length; i++) {
                    if (spectrum[i] > maxVal) {
                        maxVal = spectrum[i];
                        maxBin = i;
                    }
                }
                return maxBin * sr / fftSize;
            }

            combinePeaks(allPeaks, sr) {
                const combined = [];
                const tolerance = 0.02; // 20ms
                
                // Merge peaks across resolutions
                for (const peaks of allPeaks) {
                    for (const peak of peaks) {
                        const existing = combined.find(p => 
                            Math.abs(p.time - peak.time) < tolerance
                        );
                        
                        if (existing) {
                            existing.strength += peak.strength;
                            existing.confidence++;
                        } else {
                            combined.push({
                                ...peak,
                                confidence: 1
                            });
                        }
                    }
                }
                
                // Sort by time and filter by confidence
                return combined
                    .filter(p => p.confidence >= 2)
                    .sort((a, b) => a.time - b.time);
            }

            findPatterns(peaks) {
                const patterns = [];
                
                // Look for rhythmic patterns
                for (let i = 1; i < peaks.length - 1; i++) {
                    const interval1 = peaks[i].time - peaks[i-1].time;
                    const interval2 = peaks[i+1].time - peaks[i].time;
                    
                    const ratio = interval2 / interval1;
                    
                    // Common rhythmic ratios
                    const ratios = [
                        { value: 1, name: 'steady' },
                        { value: 0.5, name: 'double' },
                        { value: 2, name: 'half' },
                        { value: 0.667, name: 'triplet' },
                        { value: 1.5, name: 'dotted' }
                    ];
                    
                    for (const r of ratios) {
                        if (Math.abs(ratio - r.value) < 0.1) {
                            patterns.push({
                                type: r.name,
                                position: i,
                                strength: peaks[i].strength
                            });
                        }
                    }
                }
                
                return patterns;
            }

            // Quantum-style pattern matching
            matchToGrid(peaks, patterns, barLength = 4) {
                if (peaks.length < 2) return { stretch: 1, confidence: 0 };
                
                // Calculate sample's natural tempo
                const intervals = [];
                for (let i = 1; i < Math.min(peaks.length, 10); i++) {
                    intervals.push(peaks[i].time - peaks[i-1].time);
                }
                
                const medianInterval = intervals.sort((a, b) => a - b)[Math.floor(intervals.length / 2)];
                const estimatedBPM = 60 / (medianInterval * 4);
                
                // Confidence based on pattern regularity
                const confidence = this.calculateConfidence(patterns, peaks);
                
                // Intelligent stretch calculation
                const stretch = this.bpm / estimatedBPM;
                
                // Store in memory for learning
                this.memory.push({ 
                    patterns, 
                    stretch, 
                    confidence,
                    timestamp: Date.now() 
                });
                
                // Increase consciousness (learning)
                this.consciousness = Math.min(1, this.consciousness + 0.01);
                
                return { stretch, confidence };
            }

            calculateConfidence(patterns, peaks) {
                if (patterns.length === 0) return 0.3;
                
                // Pattern diversity and strength
                const uniquePatterns = new Set(patterns.map(p => p.type)).size;
                const avgStrength = patterns.reduce((s, p) => s + p.strength, 0) / patterns.length;
                
                return Math.min(1, (uniquePatterns * 0.2 + avgStrength) * (peaks.length / 10));
            }

            // AI-like chop generation
            intelligentChop(buffer, peaks, patterns) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                
                // Group peaks by musical significance
                const groups = this.groupPeaks(peaks, patterns);
                
                // Create chops based on musical structure
                for (const group of groups) {
                    const chop = {
                        start: group.start,
                        end: group.end,
                        type: group.type,
                        energy: group.energy,
                        pitch: this.suggestPitch(group)
                    };
                    chops.push(chop);
                }
                
                return chops;
            }

            groupPeaks(peaks, patterns) {
                const groups = [];
                let currentGroup = null;
                
                for (let i = 0; i < peaks.length; i++) {
                    const peak = peaks[i];
                    const pattern = patterns.find(p => p.position === i);
                    
                    if (!currentGroup || peak.time - currentGroup.end > 0.1) {
                        if (currentGroup) groups.push(currentGroup);
                        currentGroup = {
                            start: peak.time,
                            end: peak.time,
                            peaks: [peak],
                            type: pattern?.type || 'ambient',
                            energy: peak.strength
                        };
                    } else {
                        currentGroup.end = peak.time;
                        currentGroup.peaks.push(peak);
                        currentGroup.energy = Math.max(currentGroup.energy, peak.strength);
                    }
                }
                
                if (currentGroup) groups.push(currentGroup);
                return groups;
            }

            suggestPitch(group) {
                // Kanye-inspired pitch suggestions based on energy and type
                const pitchMap = {
                    steady: [1, 1, 0.5, 1.5],
                    double: [2, 1, 0.5],
                    half: [0.5, 0.25, 1],
                    triplet: [0.667, 1.333, 1],
                    dotted: [0.75, 1.5, 1],
                    ambient: [0.5, 0.667, 0.75, 1, 1.5]
                };
                
                const options = pitchMap[group.type] || pitchMap.ambient;
                return options[Math.floor(Math.random() * options.length)];
            }
        }

        // World sensor integration
        class WorldSensor {
            constructor(engine) {
                this.engine = engine;
                this.sensors = {
                    motion: { active: false, value: 0 },
                    light: { active: false, value: 0 },
                    location: { active: false, value: 0 },
                    time: { active: true, value: 0 },
                    network: { active: false, value: 0 }
                };
                
                this.init();
            }

            async init() {
                // Motion sensor (device orientation)
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        this.sensors.motion.active = true;
                        this.sensors.motion.value = Math.abs(e.beta) / 180 + Math.abs(e.gamma) / 180;
                        this.updateSensor('motion');
                    });
                }

                // Accelerometer for more motion
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        if (e.acceleration) {
                            const acc = Math.sqrt(
                                e.acceleration.x ** 2 + 
                                e.acceleration.y ** 2 + 
                                e.acceleration.z ** 2
                            );
                            this.sensors.motion.value = Math.min(1, acc / 10);
                        }
                    });
                }

                // Light sensor (ambient light)
                if ('AmbientLightSensor' in window) {
                    try {
                        const sensor = new AmbientLightSensor();
                        sensor.addEventListener('reading', () => {
                            this.sensors.light.active = true;
                            this.sensors.light.value = Math.min(1, sensor.illuminance / 1000);
                            this.updateSensor('light');
                        });
                        sensor.start();
                    } catch (e) {
                        console.log('Light sensor not available');
                    }
                }

                // Time-based variations
                setInterval(() => {
                    const now = new Date();
                    const hourNorm = now.getHours() / 24;
                    const minuteNorm = now.getMinutes() / 60;
                    
                    // Create time-based rhythm variations
                    this.sensors.time.value = Math.sin(hourNorm * Math.PI * 2) * 0.5 + 0.5;
                    
                    // Network activity simulation
                    this.sensors.network.value = Math.random() * 0.3 + 0.3;
                    
                    this.updateSensor('time');
                    this.updateSensor('network');
                }, 1000);

                // Location (if available)
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition((pos) => {
                        this.sensors.location.active = true;
                        // Use coordinates to influence sound
                        const latNorm = (pos.coords.latitude + 90) / 180;
                        const lonNorm = (pos.coords.longitude + 180) / 360;
                        this.sensors.location.value = (latNorm + lonNorm) / 2;
                        this.updateSensor('location');
                    });
                }
            }

            updateSensor(type) {
                const el = document.querySelector(`.sensor-${type}`);
                if (el && this.sensors[type].active) {
                    el.classList.add('active');
                    el.style.opacity = 0.6 + this.sensors[type].value * 0.4;
                }
            }

            // Generate world-influenced parameters
            getWorldParams() {
                const params = {
                    swing: 0.15 + this.sensors.motion.value * 0.2,
                    filter: 2000 + this.sensors.light.value * 3000,
                    reverb: 0.2 + this.sensors.location.value * 0.3,
                    bitcrush: 8 - Math.floor(this.sensors.network.value * 4),
                    delay: this.sensors.time.value * 0.3
                };
                
                return params;
            }
        }

        // Advanced LoFi processor with world influence
        class WorldLoFi {
            constructor(ctx, worldSensor) {
                this.ctx = ctx;
                this.world = worldSensor;
                this.nodes = {};
                this.setupChain();
            }

            setupChain() {
                // Dynamic bitcrusher
                this.nodes.bitcrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                
                // Tape delay
                this.nodes.delay = this.ctx.createDelay(1);
                this.nodes.delayGain = this.ctx.createGain();
                this.nodes.delayFilter = this.ctx.createBiquadFilter();
                
                // Reverb impulse
                this.nodes.reverb = this.ctx.createConvolver();
                this.nodes.reverbGain = this.ctx.createGain();
                
                // Setup reverb impulse
                this.createImpulse();
                
                // Connect delay feedback
                this.nodes.delay.connect(this.nodes.delayFilter);
                this.nodes.delayFilter.connect(this.nodes.delayGain);
                this.nodes.delayGain.connect(this.nodes.delay);
                
                this.nodes.delayFilter.type = 'lowpass';
                this.nodes.delayFilter.frequency.value = 2000;
                
                // Update parameters based on world
                this.updateParams();
            }

            createImpulse() {
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (length * 0.1));
                    }
                }
                
                this.nodes.reverb.buffer = impulse;
            }

            updateParams() {
                const params = this.world.getWorldParams();
                
                // Update bitcrusher
                const bits = params.bitcrush;
                const normFreq = 0.3 - params.motion * 0.2;
                
                let phaser = 0;
                this.nodes.bitcrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    for (let i = 0; i < input.length; i++) {
                        phaser += normFreq;
                        if (phaser >= 1) {
                            phaser -= 1;
                            const step = Math.pow(0.5, bits);
                            output[i] = step * Math.floor(input[i] / step + 0.5);
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };
                
                // Update delay
                this.nodes.delay.delayTime.value = params.delay * 0.5;
                this.nodes.delayGain.gain.value = 0.3 + params.delay * 0.3;
                
                // Update reverb
                this.nodes.reverbGain.gain.value = params.reverb;
                
                // Schedule next update
                setTimeout(() => this.updateParams(), 100);
            }

            process(source) {
                const input = this.ctx.createGain();
                const dry = this.ctx.createGain();
                const wet = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                // Split signal
                source.connect(input);
                input.connect(dry);
                input.connect(wet);
                
                // Dry path
                dry.gain.value = 0.7;
                dry.connect(output);
                
                // Wet path
                wet.gain.value = 0.3;
                wet.connect(this.nodes.bitcrusher);
                this.nodes.bitcrusher.connect(this.nodes.delay);
                this.nodes.delay.connect(this.nodes.reverb);
                this.nodes.reverb.connect(this.nodes.reverbGain);
                this.nodes.reverbGain.connect(output);
                
                return output;
            }
        }

        // Main Einstein Engine
        class EinsteinEngine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new QuantumBeatMatcher();
                this.worldSensor = null;
                this.recording = false;
                this.buffer = [];
                this.seq = { 
                    step: 0, 
                    swing: 0.15,
                    pattern: new Array(32).fill(null),
                    variations: []
                };
                
                this.consciousness = 0; // AI consciousness level
                this.memory = []; // Pattern memory
                
                this.ui = {
                    orb: document.getElementById('orb'),
                    info: document.getElementById('info'),
                    pattern: document.getElementById('pattern'),
                    viz: document.getElementById('viz')
                };
                
                this.setupUI();
                document.addEventListener('click', () => this.start());
            }

            setupUI() {
                // Create pattern display
                for (let i = 0; i < 32; i++) {
                    const step = document.createElement('div');
                    step.className = 'pattern-step';
                    step.dataset.step = i;
                    this.ui.pattern.appendChild(step);
                }
                
                // Create frequency visualizer
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'freq-bar';
                    this.ui.viz.appendChild(bar);
                }
                
                // Mouse tracking for orb
                let mouseX = window.innerWidth / 2;
                let mouseY = window.innerHeight / 2;
                
                document.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                // Smooth orb movement
                const moveOrb = () => {
                    const orbs = document.querySelectorAll('.orb');
                    const currentX = parseFloat(orbs[0].style.left || '50%');
                    const currentY = parseFloat(orbs[0].style.top || '50%');
                    
                    const targetX = (mouseX / window.innerWidth) * 100;
                    const targetY = (mouseY / window.innerHeight) * 100;
                    
                    const newX = currentX + (targetX - currentX) * 0.1;
                    const newY = currentY + (targetY - currentY) * 0.1;
                    
                    orbs.forEach((orb, i) => {
                        const delay = i * 0.1;
                        orb.style.left = `${newX}%`;
                        orb.style.top = `${newY}%`;
                    });
                    
                    requestAnimationFrame(moveOrb);
                };
                moveOrb();
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 44100 });
                    this.worldSensor = new WorldSensor(this);
                    this.lofi = new WorldLoFi(this.ctx, this.worldSensor);
                    
                    // Hide intro
                    this.ui.info.classList.add('hide');
                    
                    // Master chain with sidechain compression
                    this.setupMasterChain();
                    
                    // Create sound layers
                    this.setupLayers();
                    
                    // Generate initial sounds
                    await this.createDrums();
                    await this.createWorldSounds();
                    
                    // Setup mic with advanced processing
                    await this.setupMic();
                    
                    // Setup visualizer
                    this.setupVisualizer();
                    
                    // Start the engine
                    this.loop();
                    this.seq.last = this.ctx.currentTime;
                    requestAnimationFrame(() => this.tick());
                    
                    // Keyboard controls
                    this.setupKeyboard();
                    
                    // Create initial particles
                    this.particleSystem();
                    
                } catch (e) {
                    console.error('Engine initialization failed:', e);
                }
            }

            setupMasterChain() {
                // Master output
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.9;
                
                // Sidechain compressor
                this.nodes.sidechain = this.ctx.createDynamicsCompressor();
                this.nodes.sidechain.threshold.value = -10;
                this.nodes.sidechain.knee.value = 0;
                this.nodes.sidechain.ratio.value = 20;
                this.nodes.sidechain.attack.value = 0.001;
                this.nodes.sidechain.release.value = 0.1;
                
                // Master limiter
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -3;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.003;
                this.nodes.limiter.release.value = 0.01;
                
                // Analog warmth
                this.nodes.warmth = this.ctx.createWaveShaper();
                const samples = 44100;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2 / samples) - 1;
                    curve[i] = (3 + 0.5) * x * 20 * (Math.PI / 180) / (Math.PI + 0.5 * Math.abs(x));
                }
                this.nodes.warmth.curve = curve;
                this.nodes.warmth.oversample = '4x';
                
                // Connect chain
                this.nodes.master.connect(this.nodes.sidechain);
                this.nodes.sidechain.connect(this.nodes.warmth);
                this.nodes.warmth.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);
            }

            setupLayers() {
                const layers = {
                    kick: { vol: 0.9, pan: 0 },
                    snare: { vol: 0.7, pan: -0.1 },
                    hats: { vol: 0.3, pan: 0.3 },
                    perc: { vol: 0.4, pan: -0.5 },
                    bass: { vol: 0.85, pan: 0 },
                    sample: { vol: 0.8, pan: 0 },
                    world: { vol: 0.6, pan: 0 },
                    texture: { vol: 0.3, pan: 0 }
                };
                
                Object.entries(layers).forEach(([name, config]) => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = config.vol;
                    
                    const panner = this.ctx.createStereoPanner();
                    panner.pan.value = config.pan;
                    
                    this.nodes[name].connect(panner);
                    panner.connect(this.nodes.master);
                    
                    this.samples.set(name, []);
                });
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // Kanye-style punchy kick
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-5 * t) * (1 - t * 2);
                    const pitch = 55 * Math.exp(-35 * t);
                    const sine = Math.sin(2 * Math.PI * pitch * t);
                    const click = Math.sin(2 * Math.PI * 320 * t) * Math.exp(-100 * t) * 0.3;
                    kd[i] = (sine + click) * env;
                }
                
                // Snappy snare with character
                const snare = this.ctx.createBuffer(1, sr * 0.2, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-25 * t);
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.5;
                    const tone2 = Math.sin(2 * Math.PI * 300 * t) * 0.3;
                    const noise = (Math.random() * 2 - 1) * 0.8;
                    sd[i] = (tone + tone2 + noise) * env * 0.7;
                }
                
                // Multiple hat variations
                const hatTypes = ['closed', 'open', 'pedal'];
                hatTypes.forEach((type, idx) => {
                    const duration = 0.05 + idx * 0.1;
                    const hat = this.ctx.createBuffer(1, sr * duration, sr);
                    const hd = hat.getChannelData(0);
                    
                    for (let i = 0; i < hd.length; i++) {
                        const t = i / sr;
                        const env = Math.exp(-50 / (idx + 1) * t);
                        const noise = (Math.random() * 2 - 1);
                        const filtered = i > 0 ? noise * 0.3 + hd[i-1] * 0.7 : noise;
                        hd[i] = filtered * env * 0.4;
                    }
                    
                    this.samples.get('hats').push({ 
                        buffer: hat, 
                        rate: 1,
                        type 
                    });
                });
                
                // Percussion elements
                const percTypes = ['rim', 'conga', 'shaker'];
                percTypes.forEach(type => {
                    const perc = this.ctx.createBuffer(1, sr * 0.1, sr);
                    const pd = perc.getChannelData(0);
                    
                    for (let i = 0; i < pd.length; i++) {
                        const t = i / sr;
                        let sound = 0;
                        
                        switch(type) {
                            case 'rim':
                                sound = Math.sin(2 * Math.PI * 800 * t) * Math.exp(-80 * t);
                                break;
                            case 'conga':
                                const f = 150 + Math.sin(2 * Math.PI * 5 * t) * 50;
                                sound = Math.sin(2 * Math.PI * f * t) * Math.exp(-20 * t);
                                break;
                            case 'shaker':
                                sound = (Math.random() * 2 - 1) * Math.sin(2 * Math.PI * 0.5 * t / 0.1);
                                break;
                        }
                        
                        pd[i] = sound * 0.5;
                    }
                    
                    this.samples.get('perc').push({ 
                        buffer: perc, 
                        rate: 1,
                        type 
                    });
                });
                
                // Deep sub bass
                const bass = this.ctx.createBuffer(1, sr * 2, sr);
                const bd = bass.getChannelData(0);
                for (let i = 0; i < bd.length; i++) {
                    const t = i / sr;
                    const env = t < 0.01 ? t / 0.01 : Math.exp(-1 * (t - 0.01));
                    const freq = 40 + Math.sin(2 * Math.PI * 0.25 * t) * 5;
                    bd[i] = Math.sin(2 * Math.PI * freq * t) * env * 0.9;
                }
                
                // Store samples
                this.samples.get('kick').push({ buffer: kick, rate: 1 });
                this.samples.get('snare').push({ buffer: snare, rate: 1 });
                this.samples.get('bass').push({ buffer: bass, rate: 1 });
            }

            async createWorldSounds() {
                const sr = this.ctx.sampleRate;
                
                // Ambient texture from world data
                const texture = this.ctx.createBuffer(2, sr * 4, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = texture.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        const freq = 100 + Math.sin(2 * Math.PI * 0.1 * t) * 50;
                        const phase = ch * Math.PI / 4;
                        data[i] = Math.sin(2 * Math.PI * freq * t + phase) * 0.1;
                        
                        // Add harmonics
                        for (let h = 2; h <= 5; h++) {
                            data[i] += Math.sin(2 * Math.PI * freq * h * t + phase) * 0.02 / h;
                        }
                    }
                }
                
                this.samples.get('texture').push({ buffer: texture, rate: 1 });
                
                // World sounds that react to sensors
                const worldSound = this.ctx.createBuffer(1, sr * 2, sr);
                const wd = worldSound.getChannelData(0);
                for (let i = 0; i < wd.length; i++) {
                    const t = i / sr;
                    let sound = 0;
                    
                    // Multiple oscillators
                    for (let osc = 0; osc < 5; osc++) {
                        const freq = 50 * (osc + 1) + Math.sin(2 * Math.PI * 0.2 * t) * 10;
                        sound += Math.sin(2 * Math.PI * freq * t) * 0.1 / (osc + 1);
                    }
                    
                    wd[i] = sound * Math.sin(Math.PI * t / 2); // Fade in/out
                }
                
                this.samples.get('world').push({ buffer: worldSound, rate: 1 });
            }

            async setupMic() {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });
                
                this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                this.nodes.micGain = this.ctx.createGain();
                this.nodes.micGain.gain.value = 1;
                
                // Pre-processing
                this.nodes.micFilter = this.ctx.createBiquadFilter();
                this.nodes.micFilter.type = 'highpass';
                this.nodes.micFilter.frequency.value = 80;
                
                this.nodes.mic.connect(this.nodes.micFilter);
                this.nodes.micFilter.connect(this.nodes.micGain);
                
                // Recording processor
                this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                this.nodes.recorder.onaudioprocess = (e) => {
                    if (this.recording) {
                        const input = e.inputBuffer.getChannelData(0);
                        this.buffer.push(...input);
                        
                        // Auto-stop on silence or max length
                        const rms = Math.sqrt(input.reduce((s, x) => s + x * x, 0) / input.length);
                        if (rms < 0.01 || this.buffer.length > this.ctx.sampleRate * 8) {
                            this.stopRecording();
                        }
                    }
                };
            }

            setupVisualizer() {
                this.nodes.analyser = this.ctx.createAnalyser();
                this.nodes.analyser.fftSize = 64;
                this.nodes.analyser.smoothingTimeConstant = 0.8;
                
                this.nodes.master.connect(this.nodes.analyser);
                
                const data = new Uint8Array(this.nodes.analyser.frequencyBinCount);
                const bars = this.ui.viz.querySelectorAll('.freq-bar');
                
                const draw = () => {
                    this.nodes.analyser.getByteFrequencyData(data);
                    
                    bars.forEach((bar, i) => {
                        const value = data[i] / 255;
                        bar.style.transform = `scaleY(${value})`;
                        bar.style.opacity = 0.3 + value * 0.7;
                    });
                    
                    requestAnimationFrame(draw);
                };
                draw();
            }

            setupKeyboard() {
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.toggle();
                            break;
                        case 'c':
                            this.clearPattern();
                            break;
                        case 'r':
                            this.randomizePattern();
                            break;
                        case 'm':
                            this.mutatePattern();
                            break;
                    }
                });
            }

            toggle() {
                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                this.recording = true;
                this.buffer = [];
                this.nodes.micGain.connect(this.nodes.recorder);
                this.nodes.recorder.connect(this.ctx.destination);
                this.ui.orb.classList.add('recording');
                
                // Show recording feedback
                this.createParticle(window.innerWidth / 2, window.innerHeight / 2, 'record');
            }

            stopRecording() {
                this.recording = false;
                this.nodes.micGain.disconnect(this.nodes.recorder);
                this.nodes.recorder.disconnect();
                this.ui.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.1) {
                    this.processRecording();
                }
            }

            processRecording() {
                const audioBuffer = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                audioBuffer.getChannelData(0).set(this.buffer);
                
                // Quantum beat matching
                const analysis = this.beatMatcher.findTransients(audioBuffer, this.ctx.sampleRate);
                const { stretch, confidence } = this.beatMatcher.matchToGrid(
                    analysis.transients, 
                    analysis.patterns
                );
                
                // Intelligent pitch selection based on world state
                const worldParams = this.worldSensor.getWorldParams();
                const pitchOptions = [0.5, 0.667, 0.75, 1, 1.5, 2];
                const pitchIndex = Math.floor(worldParams.filter / 5000 * pitchOptions.length);
                const pitch = pitchOptions[pitchIndex];
                
                // Create sample with metadata
                const sample = {
                    buffer: audioBuffer,
                    rate: stretch * pitch,
                    pitch,
                    confidence,
                    patterns: analysis.patterns,
                    timestamp: Date.now(),
                    worldState: { ...worldParams }
                };
                
                // Add to appropriate layer based on content
                const targetLayer = this.classifySample(analysis);
                const samples = this.samples.get(targetLayer);
                
                if (samples.length >= 4) samples.shift();
                samples.push(sample);
                
                // Update pattern
                this.integrateIntoPattern(sample, targetLayer);
                
                // Increase consciousness
                this.consciousness = Math.min(1, this.consciousness + confidence * 0.1);
                
                console.log(`Sample classified as ${targetLayer}: ${pitch}x pitch, ${stretch.toFixed(2)}x stretch, ${confidence.toFixed(2)} confidence`);
            }

            classifySample(analysis) {
                // Classify based on transient density and patterns
                const density = analysis.transients.length / 4; // per second
                
                if (density < 2) return 'texture';
                if (density < 4) return 'world';
                if (analysis.patterns.some(p => p.type === 'steady')) return 'sample';
                return 'perc';
            }

            integrateIntoPattern(sample, layer) {
                // Find empty slots in pattern
                const emptySlots = [];
                for (let i = 0; i < 32; i++) {
                    if (!this.seq.pattern[i]) emptySlots.push(i);
                }
                
                if (emptySlots.length === 0) return;
                
                // Place sample based on its patterns
                const slot = emptySlots[Math.floor(Math.random() * emptySlots.length)];
                this.seq.pattern[slot] = {
                    layer,
                    sample,
                    probability: 0.8
                };
                
                // Update UI
                const stepEl = this.ui.pattern.children[slot];
                stepEl.classList.add('has-sample');
            }

            tick() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.beatMatcher.bpm / 4;
                const worldParams = this.worldSensor.getWorldParams();
                
                // Dynamic swing from world
                let swing = this.seq.step % 2 === 1 ? 
                    beat * (1 + worldParams.swing) : 
                    beat * (1 - worldParams.swing);
                
                if (now >= this.seq.last + swing) {
                    this.seq.last = now;
                    
                    // Update pattern display
                    this.updatePatternDisplay();
                    
                    // Core rhythm with variations
                    this.playStep(this.seq.step);
                    
                    // Check pattern slots
                    const slot = this.seq.pattern[this.seq.step];
                    if (slot && Math.random() < slot.probability) {
                        this.playSample(slot.sample, slot.layer);
                    }
                    
                    this.seq.step = (this.seq.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            playStep(step) {
                // Kanye-inspired patterns with world influence
                const worldParams = this.worldSensor.getWorldParams();
                
                // Kick pattern - steady but with micro-variations
                if (step === 0 || step === 10 || (step === 22 && Math.random() < 0.7)) {
                    this.play('kick', 0.9 + Math.random() * 0.1);
                }
                
                // Snare with ghost notes
                if (step === 8 || step === 24) {
                    this.play('snare', 0.7);
                } else if ([7, 23, 15].includes(step) && Math.random() < 0.3) {
                    this.play('snare', 0.2); // Ghost notes
                }
                
                // Hi-hats with variation
                const hatPattern = [2, 6, 10, 12, 14, 18, 22, 26, 30];
                if (hatPattern.includes(step) || (Math.random() < worldParams.network * 0.3)) {
                    const hatType = this.samples.get('hats')[Math.floor(Math.random() * 3)];
                    this.playBuffer(hatType.buffer, 'hats', 0.3 + Math.random() * 0.2, hatType.rate);
                }
                
                // Percussion elements
                if (Math.random() < 0.2 + worldParams.motion * 0.3) {
                    const perc = this.samples.get('perc')[Math.floor(Math.random() * 3)];
                    this.playBuffer(perc.buffer, 'perc', 0.3, perc.rate);
                }
                
                // Bass hits
                const bassPattern = [0, 3, 8, 11, 16, 19, 24, 27];
                if (bassPattern.includes(step)) {
                    this.play('bass', 0.8);
                }
                
                // World sounds
                if (step % 8 === 0 && this.consciousness > 0.5) {
                    this.play('world', worldParams.location * 0.5);
                }
                
                // Texture layer
                if (step === 0) {
                    this.play('texture', worldParams.time * 0.3);
                }
            }

            play(type, velocity) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                const sample = samples[Math.floor(Math.random() * samples.length)];
                this.playBuffer(sample.buffer, type, velocity, sample.rate);
            }

            playBuffer(buffer, destination, velocity, rate = 1) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = buffer;
                source.playbackRate.value = rate;
                gain.gain.value = velocity;
                
                // Apply world-influenced processing
                const processed = this.lofi.process(source);
                processed.connect(gain);
                gain.connect(this.nodes[destination]);
                
                source.start();
                
                // Visual feedback
                if (destination === 'kick' || destination === 'snare') {
                    this.createParticle(
                        Math.random() * window.innerWidth,
                        Math.random() * window.innerHeight,
                        destination
                    );
                }
            }

            playSample(sample, layer) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.rate;
                
                // Dynamic filtering based on world
                const worldParams = this.worldSensor.getWorldParams();
                filter.type = 'lowpass';
                filter.frequency.value = worldParams.filter;
                filter.Q.value = 2 + worldParams.motion * 8;
                
                // Envelope
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 0.01);
                
                // Processing chain
                const processed = this.lofi.process(source);
                processed.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes[layer]);
                
                source.start();
            }

            updatePatternDisplay() {
                const steps = this.ui.pattern.children;
                for (let i = 0; i < steps.length; i++) {
                    steps[i].classList.toggle('active', i === this.seq.step);
                }
            }

            clearPattern() {
                this.seq.pattern = new Array(32).fill(null);
                const steps = this.ui.pattern.children;
                for (let step of steps) {
                    step.classList.remove('has-sample');
                }
            }

            randomizePattern() {
                this.clearPattern();
                
                // Add random samples to pattern
                const allSamples = [];
                for (const [layer, samples] of this.samples) {
                    if (samples.length > 0 && layer !== 'kick' && layer !== 'snare' && layer !== 'bass') {
                        samples.forEach(s => allSamples.push({ sample: s, layer }));
                    }
                }
                
                if (allSamples.length === 0) return;
                
                // Place 4-8 samples randomly
                const count = 4 + Math.floor(Math.random() * 5);
                for (let i = 0; i < count; i++) {
                    const slot = Math.floor(Math.random() * 32);
                    const { sample, layer } = allSamples[Math.floor(Math.random() * allSamples.length)];
                    
                    this.seq.pattern[slot] = {
                        layer,
                        sample,
                        probability: 0.5 + Math.random() * 0.5
                    };
                    
                    this.ui.pattern.children[slot].classList.add('has-sample');
                }
            }

            mutatePattern() {
                // Evolve the pattern based on consciousness
                for (let i = 0; i < 32; i++) {
                    if (this.seq.pattern[i] && Math.random() < 0.2) {
                        // Mutate probability
                        this.seq.pattern[i].probability = Math.max(0.1, Math.min(1, 
                            this.seq.pattern[i].probability + (Math.random() - 0.5) * 0.3
                        ));
                        
                        // Maybe move to adjacent slot
                        if (Math.random() < 0.1) {
                            const newSlot = (i + (Math.random() < 0.5 ? -1 : 1) + 32) % 32;
                            if (!this.seq.pattern[newSlot]) {
                                this.seq.pattern[newSlot] = this.seq.pattern[i];
                                this.seq.pattern[i] = null;
                                
                                this.ui.pattern.children[i].classList.remove('has-sample');
                                this.ui.pattern.children[newSlot].classList.add('has-sample');
                            }
                        }
                    }
                }
            }

            createParticle(x, y, type) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                
                // Color based on type
                const colors = {
                    kick: '#ffffff',
                    snare: '#ffaa00',
                    record: '#ff0000',
                    default: '#00ffaa'
                };
                
                particle.style.background = colors[type] || colors.default;
                particle.style.boxShadow = `0 0 10px ${particle.style.background}`;
                
                document.body.appendChild(particle);
                
                // Animate
                const angle = Math.random() * Math.PI * 2;
                const velocity = 2 + Math.random() * 3;
                let opacity = 1;
                
                const animate = () => {
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity;
                    
                    particle.style.left = (parseFloat(particle.style.left) + dx) + 'px';
                    particle.style.top = (parseFloat(particle.style.top) + dy) + 'px';
                    
                    opacity -= 0.02;
                    particle.style.opacity = opacity;
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };
                animate();
            }

            particleSystem() {
                // Ambient particles based on world state
                setInterval(() => {
                    if (Math.random() < 0.1 + this.consciousness * 0.2) {
                        this.createParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'default'
                        );
                    }
                }, 500);
            }

            loop() {
                // Continuous analysis and evolution
                setInterval(() => {
                    // Update world parameters
                    const worldParams = this.worldSensor.getWorldParams();
                    
                    // Evolve BPM slightly based on time
                    this.beatMatcher.bpm = 75 + Math.sin(Date.now() / 30000) * 5;
                    
                    // Auto-mutate if consciousness is high
                    if (this.consciousness > 0.8 && Math.random() < 0.01) {
                        this.mutatePattern();
                    }
                    
                    // Memory cleanup
                    if (this.memory.length > 100) {
                        this.memory = this.memory.slice(-50);
                    }
                }, 1000);
                
                // Auto-sampling based on world activity
                const analyser = this.ctx.createAnalyser();
                this.nodes.micGain.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                
                setInterval(() => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    // Detect interesting sounds
                    let energy = 0;
                    let complexity = 0;
                    
                    for (let i = 0; i < data.length; i++) {
                        if (data[i] > 128) {
                            energy += data[i];
                            complexity++;
                        }
                    }
                    
                    // Auto-record if interesting
                    if (complexity > 50 && energy > 10000) {
                        this.startRecording();
                        cooldown = 100; // 2 second cooldown
                        
                        // Auto-stop after 2 seconds
                        setTimeout(() => {
                            if (this.recording) this.stopRecording();
                        }, 2000);
                    }
                }, 20);
            }
        }

        // Initialize the Einstein Engine
        new EinsteinEngine();
    </script>
</body>
</html>
