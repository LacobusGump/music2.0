<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Music 2.0</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .app {
      width: 100%;
      max-width: 400px;
      padding: 20px;
      text-align: center;
    }
    
    .logo {
      font-size: clamp(2.5rem, 10vw, 4rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.3rem;
      animation: pulse 3s ease-in-out infinite;
    }
    
    .version {
      font-size: 0.9rem;
      color: #ff6b6b;
      font-weight: 700;
      margin-bottom: 0.5rem;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.03); }
    }
    
    .tagline {
      font-size: clamp(0.9rem, 3.5vw, 1rem);
      opacity: 0.8;
      margin-bottom: 2rem;
      font-weight: 300;
    }
    
    .start-btn {
      padding: 18px 35px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 25px;
      font-size: 1.1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 8px 25px rgba(0,255,170,0.3);
      margin-bottom: 1.5rem;
    }
    
    .start-btn:hover { transform: translateY(-2px); box-shadow: 0 12px 35px rgba(0,255,170,0.5); }
    .start-btn:active { transform: translateY(0); }
    
    .spatial-viz {
      width: 100%;
      height: 180px;
      border: 2px solid rgba(0,255,170,0.2);
      border-radius: 20px;
      position: relative;
      overflow: hidden;
      background: rgba(0,255,170,0.03);
      margin-bottom: 1.5rem;
    }
    
    .orb {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffaa, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease;
      box-shadow: 0 0 25px rgba(0,255,170,0.5);
    }
    
    .pattern-trail {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(0,255,170,0.3);
      pointer-events: none;
      animation: fade 2s ease-out forwards;
    }
    
    @keyframes fade {
      0% { opacity: 0.8; transform: scale(1); }
      100% { opacity: 0; transform: scale(0.2); }
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 8px;
      margin-bottom: 1.5rem;
    }
    
    .stat {
      background: rgba(0,255,170,0.1);
      padding: 10px 6px;
      border-radius: 12px;
      border: 1px solid rgba(0,255,170,0.2);
      backdrop-filter: blur(10px);
    }
    
    .stat-value {
      font-size: 1.1rem;
      font-weight: 700;
      color: #00ffaa;
    }
    
    .stat-label {
      font-size: 0.65rem;
      opacity: 0.7;
      margin-top: 2px;
    }
    
    .status {
      font-size: 0.85rem;
      color: #4ecdc4;
      opacity: 0.9;
      animation: breathe 2s ease-in-out infinite;
    }
    
    @keyframes breathe {
      0%, 100% { opacity: 0.7; }
      50% { opacity: 1; }
    }
    
    .hidden { display: none !important; }
    
    .error {
      background: rgba(255,107,107,0.1);
      border: 1px solid rgba(255,107,107,0.3);
      border-radius: 15px;
      padding: 20px;
      color: #ff6b6b;
      margin-top: 20px;
    }
    
    .emergence {
      color: #ff6b6b;
      animation: emerge 4s ease-in-out infinite;
    }
    
    @keyframes emerge {
      0%, 100% { opacity: 0.6; }
      50% { opacity: 1; transform: scale(1.05); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="logo">GUMP</div>
    <div class="version">MUSIC 2.0</div>
    <div class="tagline">Self-Organizing AI Soundtrack</div>
    
    <button class="start-btn" id="start">ðŸŽµ Begin Emergence</button>
    
    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>
    
    <div class="stats hidden" id="stats">
      <div class="stat">
        <div class="stat-value" id="motion">0</div>
        <div class="stat-label">Motion</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="patterns">0</div>
        <div class="stat-label">Patterns</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="evolution">1</div>
        <div class="stat-label">Evolution</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="complexity">LOW</div>
        <div class="stat-label">Complexity</div>
      </div>
    </div>
    
    <div class="status hidden" id="status">ðŸŽµ <span class="emergence">Emerging from chaos...</span></div>
    
    <div class="error hidden" id="error">
      Motion sensors unavailable. Please use a mobile device.
    </div>
  </div>

  <script>
    class MusicEmergence {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.active = false;
        this.time = 0;
        this.evolution = 1;
        
        // Self-organizing pattern memory
        this.patterns = [];
        this.patternHistory = [];
        this.rhythmMemory = [];
        this.motionHistory = [];
        this.lastMotionTime = 0;
        
        // Emergent music parameters
        this.scale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25]; // C major
        this.activeNotes = new Set();
        this.harmony = [];
        this.complexity = 'LOW';
        
        // Chaos to order parameters
        this.chaos = 1.0;
        this.order = 0.0;
        this.phase = 'CHAOS';
        
        this.init();
      }
      
      init() {
        document.getElementById('start').onclick = () => this.start();
      }
      
      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') throw new Error('Permission denied');
          }
          
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          
          document.getElementById('start').classList.add('hidden');
          ['viz', 'stats', 'status'].forEach(id => 
            document.getElementById(id).classList.remove('hidden')
          );
          
          this.active = true;
          this.startSensors();
          this.startEmergence();
          this.animate();
          
        } catch (error) {
          this.showError('Motion sensors unavailable. Please use a mobile device.');
        }
      }
      
      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          
          const motion = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
          this.motion = Math.min(100, motion * 8);
          
          // Update position with momentum
          this.velocity.x += acc.x * 0.1;
          this.velocity.y += acc.y * 0.1;
          this.velocity.x *= 0.95;
          this.velocity.y *= 0.95;
          
          this.pos.x = Math.max(5, Math.min(95, this.pos.x + this.velocity.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y + this.velocity.y));
          
          // Record motion patterns
          this.recordMotion(motion);
          
        }, { passive: true });
      }
      
      recordMotion(motion) {
        const now = this.ctx.currentTime;
        const timeSinceLastMotion = now - this.lastMotionTime;
        
        if (motion > 5) {
          this.motionHistory.push({
            time: now,
            motion: motion,
            interval: timeSinceLastMotion,
            x: this.pos.x,
            y: this.pos.y
          });
          
          this.lastMotionTime = now;
          
          // Keep only recent history
          if (this.motionHistory.length > 50) {
            this.motionHistory.shift();
          }
          
          // Analyze for patterns
          this.analyzePatterns();
        }
      }
      
      analyzePatterns() {
        if (this.motionHistory.length < 4) return;
        
        const recent = this.motionHistory.slice(-8);
        const intervals = recent.map(r => r.interval).filter(i => i > 0.1 && i < 2);
        
        if (intervals.length >= 3) {
          // Look for rhythmic patterns
          const avgInterval = intervals.reduce((a,b) => a+b) / intervals.length;
          const variance = intervals.reduce((sum, i) => sum + Math.pow(i - avgInterval, 2), 0) / intervals.length;
          
          if (variance < 0.1) { // Consistent rhythm detected
            this.reinforcePattern(avgInterval, recent);
          }
        }
      }
      
      reinforcePattern(interval, motionData) {
        const pattern = {
          interval: interval,
          motion: motionData.map(m => m.motion),
          positions: motionData.map(m => ({x: m.x, y: m.y})),
          strength: 1,
          created: this.ctx.currentTime
        };
        
        // Check if similar pattern exists
        let found = false;
        for (let p of this.patterns) {
          if (Math.abs(p.interval - interval) < 0.2) {
            p.strength += 0.5;
            found = true;
            break;
          }
        }
        
        if (!found) {
          this.patterns.push(pattern);
        }
        
        // Evolve based on pattern recognition
        this.evolve();
      }
      
      evolve() {
        const patternCount = this.patterns.length;
        const totalStrength = this.patterns.reduce((sum, p) => sum + p.strength, 0);
        
        // Transition from chaos to order
        this.order = Math.min(1, totalStrength / 10);
        this.chaos = 1 - this.order;
        
        if (this.order > 0.3) {
          this.phase = 'EMERGING';
          this.complexity = 'MID';
        }
        if (this.order > 0.7) {
          this.phase = 'ORGANIZED';
          this.complexity = 'HIGH';
        }
        
        this.evolution = Math.floor(this.order * 10) + 1;
      }
      
      startEmergence() {
        const emerge = () => {
          if (!this.active) return;
          
          this.time += 0.1;
          
          // Generate music based on current state
          this.generateEmergentMusic();
          
          // Clean up old patterns
          this.patterns = this.patterns.filter(p => 
            this.ctx.currentTime - p.created < 30 && p.strength > 0.1
          );
          
          // Decay pattern strength
          this.patterns.forEach(p => p.strength *= 0.995);
          
          setTimeout(emerge, 100);
        };
        
        emerge();
      }
      
      generateEmergentMusic() {
        const intensity = this.motion / 100;
        
        // Chaos-driven random events
        if (this.chaos > 0.5 && Math.random() < 0.1) {
          this.randomSpatialHit();
        }
        
        // Pattern-driven organized music
        if (this.order > 0.3) {
          this.generateFromPatterns();
        }
        
        // Continuous ambient based on motion
        if (intensity > 0.1) {
          this.generateAmbient();
        }
        
        // Harmonic evolution
        if (this.time % 4 < 0.1 && this.order > 0.5) {
          this.evolveHarmony();
        }
      }
      
      randomSpatialHit() {
        const freq = 200 + Math.random() * 1000;
        const duration = 0.1 + Math.random() * 0.3;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();
        
        osc.frequency.value = freq;
        osc.type = ['sine', 'square', 'triangle'][Math.floor(Math.random() * 3)];
        
        panner.pan.value = (this.pos.x - 50) / 50;
        
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        osc.connect(gain).connect(panner).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        this.createVisualTrail();
      }
      
      generateFromPatterns() {
        this.patterns.forEach(pattern => {
          if (Math.random() < pattern.strength / 10) {
            this.playPatternNote(pattern);
          }
        });
      }
      
      playPatternNote(pattern) {
        const noteIndex = Math.floor(pattern.interval * 4) % this.scale.length;
        const freq = this.scale[noteIndex];
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.frequency.value = freq;
        osc.type = 'sine';
        
        filter.type = 'lowpass';
        filter.frequency.value = 800 + this.order * 1200;
        filter.Q.value = 1 + this.order * 3;
        
        gain.gain.setValueAtTime(0.1 * pattern.strength, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        osc.connect(filter).connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }
      
      generateAmbient() {
        if (Math.random() < 0.05) {
          const freq = this.scale[Math.floor(Math.random() * this.scale.length)] * 0.5;
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const delay = this.ctx.createDelay();
          const feedback = this.ctx.createGain();
          
          osc.frequency.value = freq;
          osc.type = 'triangle';
          
          delay.delayTime.value = 0.3;
          feedback.gain.value = 0.3;
          
          gain.gain.setValueAtTime(0.02, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(gain);
          gain.connect(delay);
          delay.connect(feedback);
          feedback.connect(delay);
          delay.connect(this.ctx.destination);
          gain.connect(this.ctx.destination);
          
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
        }
      }
      
      evolveHarmony() {
        const rootNote = this.scale[Math.floor(this.evolution % this.scale.length)];
        const chord = [rootNote, rootNote * 1.25, rootNote * 1.5]; // Major triad
        
        chord.forEach((freq, i) => {
          setTimeout(() => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            
            osc.frequency.value = freq;
            osc.type = 'sine';
            
            gain.gain.setValueAtTime(0.03, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
            
            osc.connect(gain).connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + 3);
          }, i * 100);
        });
      }
      
      createVisualTrail() {
        const trail = document.createElement('div');
        trail.className = 'pattern-trail';
        trail.style.left = this.pos.x + '%';
        trail.style.top = this.pos.y + '%';
        
        document.getElementById('viz').appendChild(trail);
        
        setTimeout(() => {
          trail.remove();
        }, 2000);
      }
      
      animate() {
        if (!this.active) return;
        
        const orb = document.getElementById('orb');
        orb.style.left = `${this.pos.x}%`;
        orb.style.top = `${this.pos.y}%`;
        orb.style.transform = `translate(-50%, -50%) scale(${1 + this.motion * 0.02})`;
        
        document.getElementById('motion').textContent = Math.round(this.motion);
        document.getElementById('patterns').textContent = this.patterns.length;
        document.getElementById('evolution').textContent = this.evolution;
        document.getElementById('complexity').textContent = this.complexity;
        
        // Update status based on phase
        const statusMessages = {
          'CHAOS': 'ðŸŒ€ Emerging from chaos...',
          'EMERGING': 'ðŸŽµ Patterns forming...',
          'ORGANIZED': 'ðŸŽ¼ Music evolved!'
        };
        
        document.getElementById('status').innerHTML = statusMessages[this.phase];
        
        requestAnimationFrame(() => this.animate());
      }
      
      showError(message) {
        document.getElementById('start').classList.add('hidden');
        const error = document.getElementById('error');
        error.textContent = message;
        error.classList.remove('hidden');
      }
    }
    
    new MusicEmergence();
  </script>
</body>
</html>
