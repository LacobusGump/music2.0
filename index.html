<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Grand Unified Music Project</title>
  <style>
    html,body { height:100%; margin:0; padding:0; background:#090c11;}
    body { overflow:hidden;}
    .app { width:100vw; height:100vh; display:flex; align-items:center; justify-content:center; opacity:0; transition:opacity 1.5s;}
    .viz { width:340px; height:340px; border-radius:40px; background:rgba(20,20,32,0.13); position:relative; border:3px solid #333558; box-shadow:0 0 60px #39428022; transition:border 1s,box-shadow 1.5s;}
    .viz.void { border-color:#cfd0fd; box-shadow:0 0 140px #9fc3ff44,0 0 180px #dce1facc;}
    .orb { position:absolute; width:120px; height:120px; border-radius:50%; background:radial-gradient(circle,#111f33 0%,#6077ee22 90%,transparent 100%); top:50%; left:50%; transform:translate(-50%,-50%); box-shadow:0 0 60px #2a4fa855; transition:all .26s;}
    .orb.void { background:radial-gradient(circle,#d9f2ff 0%,#e5aaff 45%,transparent 100%); box-shadow:0 0 120px #d9f2ff88,0 0 200px #f8f8f855;}
    .pulse { animation:pulse 1.2s cubic-bezier(.8,0,.3,1) alternate infinite;}
    @keyframes pulse {from{transform:translate(-50%,-50%) scale(1);} to{transform:translate(-50%,-50%) scale(1.15);} }
    .start-btn { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); font-size:1.2rem; padding:18px 45px; border-radius:30px; background:linear-gradient(45deg,#1e304b,#a3ffd7); color:#000; border:none; font-weight:700; cursor:pointer; z-index:10; box-shadow:0 4px 22px #00ffaa22;}
    .hidden { display:none!important;}
    .error { position:absolute; top: 24%; left:50%; transform:translateX(-50%); background: #221a 1px solid #c33; border-radius: 15px; padding:18px; color:#ff6b6b;}
    .intro { position:fixed; z-index:100; width:100vw; height:100vh; background:#090c11; display:flex; flex-direction:column; justify-content:center; align-items:center; animation: fadein 1.7s; transition: opacity 1.5s;}
    .intro-title { font-size:2.1rem; font-weight:800; color:#d8fdff; letter-spacing:1.6px; margin-bottom:2.1rem; text-shadow:0 0 22px #7fdaff; opacity:1; transition: opacity 1s;}
    .intro-author { font-size:1.1rem; color:#acecff; opacity:.76; margin-bottom:2.3rem; letter-spacing:.7px;}
    .intro-btn { background:linear-gradient(80deg,#2eeaff,#a9c6ff 80%); color:#161b22; font-weight:700; font-size:1.25rem; padding:19px 60px; border-radius:40px; border:none; cursor:pointer; box-shadow:0 0 32px #00ffaa22; transition: background .5s;}
    .intro-btn:hover { background:linear-gradient(80deg,#a9c6ff,#2eeaff 80%);}
    @keyframes fadein {from{opacity:0;}to{opacity:1;}}
    .wisp { opacity:0!important; transition: opacity 1.5s;}
  </style>
</head>
<body>
  <div class="intro" id="intro">
    <div class="intro-title">GUMP: Grand Unified Music Project</div>
    <div class="intro-author">By: James McCandless</div>
    <button class="intro-btn" id="introBtn">Begin</button>
  </div>
  <div class="app">
    <div class="viz" id="viz"><div class="orb" id="orb"></div></div>
    <button class="start-btn" id="start">Start</button>
    <div class="error hidden" id="error"></div>
  </div>
  <script>
    // ---- INTRO FADE ----
    document.querySelector('.app').style.opacity = 0;
    document.getElementById('introBtn').onclick = function() {
      let intro = document.getElementById('intro');
      intro.classList.add('wisp');
      setTimeout(()=>{ intro.style.display = 'none'; }, 1600);
      setTimeout(()=>{ document.querySelector('.app').style.opacity = 1; }, 900);
    };

    class GUMP {
      constructor() {
        // ---- State ----
        this.ctx = null; this.reverb = null;
        this.motion = 0; this.motionWindow = [];
        this.last = { x:0, y:0, z:0 };
        this.lastMotionTime = Date.now();
        this.movedAt = null;
        this.hasMoved = false;
        this.introBar = 0;
        this.hasStartedVibe = false;
        this.zone = 0;
        this.scale = [130.8, 155.6, 174.6, 196, 220, 261.6, 293.66, 329.63, 392];
        this.progression = [
          [[0,3,4],[1,4,5],[0,2,5],[1,2,4]], // Center
          [[2,4,5],[1,4,3],[3,4,5],[0,3,5]], // North
          [[0,1,5],[3,4,0],[2,4,3],[1,3,5]], // South
          [[0,2,4],[1,3,5],[2,4,0],[3,5,1]], // East
          [[0,4,5],[2,5,3],[1,3,4],[0,2,5]], // West
        ];
        this.chordStep = 0; this.tick = 0;
        this.basePos = null; this.gpsOK = false;
        // Easter eggs: hardcode a few sample corners (change these lat/lon to real intersections if you want)
        this.easterEggs = [
          {lat:null,lon:null,active:false,dist:50}, // Main one: will be set to home + ~30m N/W/E/S
        ];
        // Visual cue timer
        this.cueTimeout = null;
        this.state = 'void';
        this.init();
      }
      init() {
        document.getElementById('start').onclick = () => this.start();
      }
      createReverb() {
        this.reverb = this.ctx.createConvolver();
        let b = this.ctx.createBuffer(2, this.ctx.sampleRate*3.5, this.ctx.sampleRate);
        for (let c=0;c<2;c++) {
          let d = b.getChannelData(c);
          for (let i=0;i<d.length;i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/d.length, 3.7);
        }
        this.reverb.buffer = b;
        this.reverb.connect(this.ctx.destination);
      }
      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') throw new Error('Permission denied');
          }
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();
          document.getElementById('start').classList.add('hidden');
          this.active = true;
          this.startSensors();
          this.startGPS();
          this.masterClock();
          this.animate();
        } catch (e) {
          this.showError('Motion sensors unavailable. Please use a mobile device.');
        }
      }
      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          const dx = acc.x - this.last.x, dy = acc.y - this.last.y, dz = acc.z - this.last.z;
          let power = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.motionWindow.push(power); if (this.motionWindow.length > 8) this.motionWindow.shift();
          this.motion = this.motionWindow.reduce((a,b)=>a+b,0)/this.motionWindow.length;
          if (this.motion > 0.7) {
            this.lastMotionTime = Date.now();
            if (!this.hasMoved) {
              this.hasMoved = true;
              this.movedAt = Date.now();
              this.introBar = 0; // start intro sequence
              this.hasStartedVibe = false;
            }
          }
          this.pos = {x: Math.max(10, Math.min(90, 50 + acc.x*9)), y: Math.max(10, Math.min(90, 50 + acc.y*9))};
        });
      }
      animate() {
        const update = () => {
          if (!this.active) return;
          let orb = document.getElementById('orb');
          let viz = document.getElementById('viz');
          let inVoid = this.state === 'void';
          orb.style.left = this.pos.x + '%'; orb.style.top = this.pos.y + '%';
          orb.className = 'orb' + (inVoid ? ' void pulse' : ' pulse');
          viz.className = 'viz' + (inVoid ? ' void' : '');
          document.body.className = inVoid ? 'void' : '';
          requestAnimationFrame(update);
        };
        update();
      }
      masterClock() {
        setInterval(() => {
          if (!this.active) return;
          this.updateState();
          // --- Nothing until movement ---
          if (!this.hasMoved) return;
          // Easter egg fade-in if near one
          let eggIntensity = this.getEasterEggIntensity();
          // ---- Music build-up logic ----
          if (this.state === 'dark') {
            if (this.introBar === 0) { // bar 1: DRUMS ONLY
              this.darkEngine({ drums:true, vibe:false, egg:eggIntensity });
              if (this.tick === 15) this.introBar++;
            }
            else if (this.introBar === 1) { // bar 2: fade in vibes
              this.darkEngine({ drums:true, vibe:true, egg:eggIntensity, fade:(this.tick/16) });
              if (this.tick === 15) { this.introBar++; this.hasStartedVibe=true; }
            }
            else { // Full scene
              this.darkEngine({ drums:true, vibe:true, egg:eggIntensity, fade:1 });
            }
          } else { // VOID
            this.voidEngine();
          }
          this.tick = (this.tick+1) % 16;
          if (this.tick === 0) {
            this.chordStep = (this.chordStep+1)%this.progression[this.zone].length;
          }
        }, 250); // 120bpm 8th
      }
      updateState() {
        const now = Date.now();
        if ((now-this.lastMotionTime)<1400) this.state = 'dark';
        else this.state = 'void';
      }
      // ---- GPS: zones & easter egg logic ----
      startGPS() {
        if (!navigator.geolocation) return;
        navigator.geolocation.getCurrentPosition(pos=>{
          this.basePos = {lat: pos.coords.latitude, lon: pos.coords.longitude};
          this.gpsOK = true;
          this.zone = 0;
          // Place 4 easter eggs 30m away N/S/E/W
          let dLat = 0.00027, dLon = 0.00035; // ~30m
          this.easterEggs = [
            {lat:this.basePos.lat+dLat, lon:this.basePos.lon, active:false, dist:30},
            {lat:this.basePos.lat-dLat, lon:this.basePos.lon, active:false, dist:30},
            {lat:this.basePos.lat, lon:this.basePos.lon+dLon, active:false, dist:30},
            {lat:this.basePos.lat, lon:this.basePos.lon-dLon, active:false, dist:30}
          ];
          this.monitorGPS();
        }, ()=>{}, { enableHighAccuracy:true, maximumAge:10000, timeout:15000 });
      }
      monitorGPS() {
        if (!navigator.geolocation) return;
        setInterval(()=>{
          navigator.geolocation.getCurrentPosition(pos=>{
            if (!this.basePos) return;
            let lat = pos.coords.latitude, lon = pos.coords.longitude;
            let dx = this.haversine(lat,lon,this.basePos.lat,this.basePos.lon,'E');
            let dy = this.haversine(lat,lon,this.basePos.lat,this.basePos.lon,'N');
            let thresh = 0.018;
            let z = 0;
            if (Math.abs(dx)>thresh || Math.abs(dy)>thresh) {
              if (Math.abs(dx)>Math.abs(dy)) z = dx>0?3:4;
              else z = dy>0?1:2;
            }
            if (z!==this.zone) {
              this.zone = z;
              this.chordStep = 0;
              this.zoneCue();
            }
            // Update easter egg distance
            this.easterEggs.forEach(egg=>{
              egg.lastDist = this.geoDist(lat,lon,egg.lat,egg.lon);
              egg.active = (egg.lastDist < egg.dist);
            });
          },()=>{}, {enableHighAccuracy:true,maximumAge:8000,timeout:8000});
        }, 6000);
      }
      haversine(lat1,lon1,lat2,lon2,axis) {
        if (axis==='E') return (lon1-lon2)*Math.cos((lat1+lat2)/2*Math.PI/180)*111;
        else return (lat1-lat2)*111;
      }
      geoDist(lat1,lon1,lat2,lon2) {
        let dLat = (lat2-lat1)*Math.PI/180;
        let dLon = (lon2-lon1)*Math.PI/180;
        let a = Math.sin(dLat/2)*Math.sin(dLat/2) +
          Math.cos(lat1*Math.PI/180)*Math.cos(lat2*Math.PI/180)*
          Math.sin(dLon/2)*Math.sin(dLon/2);
        let d = 2*6371*Math.atan2(Math.sqrt(a),Math.sqrt(1-a));
        return d*1000;
      }
      zoneCue() {
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(220, this.ctx.currentTime);
        o.frequency.linearRampToValueAtTime(660, this.ctx.currentTime+0.34);
        g.gain.setValueAtTime(0.11,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.7);
        o.connect(g).connect(this.reverb);
        o.start(); o.stop(this.ctx.currentTime+0.7);
        let orb = document.getElementById('orb');
        orb.style.boxShadow = '0 0 120px #ffdcee,0 0 220px #c5d1ff';
        clearTimeout(this.cueTimeout);
        this.cueTimeout = setTimeout(()=>{ orb.style.boxShadow='0 0 60px #2a4fa855'; },600);
      }
      getEasterEggIntensity() {
        // Returns a fade value 0..1 depending on how close you are to *any* easter egg
        let min = 1;
        this.easterEggs.forEach(egg=>{
          if (egg.lastDist && egg.lastDist<egg.dist)
            min = Math.min(min, 1-egg.lastDist/egg.dist);
        });
        return Math.max(0,min);
      }
      // --- MUSIC ENGINES ---
      darkEngine({drums=true, vibe=false, egg=0, fade=1}) {
        let chord = this.progression[this.zone][this.chordStep];
        let posInBar = this.tick % 16;
        // --- Drums (always) ---
        if (drums) {
          if (posInBar===0) this.darkKick();
          if (posInBar===8) this.darkKick(0.1);
          if (posInBar===4||posInBar===12) this.darkSnare();
          if (posInBar%2===0) this.lowHat();
        }
        // --- Vibes (chords/bass) fade in only if allowed ---
        if (vibe) {
          let vAmt = fade ?? 1;
          if (posInBar===1||posInBar===9) this.darkBass(chord[0], vAmt);
          if (posInBar===2||posInBar===10) this.darkBass(chord[1], vAmt);
          if (posInBar===0 || posInBar===8) this.darkPad(chord, vAmt);
        }
        // --- Easter egg: build up a new synth the closer you get ---
        if (egg>0) this.easterEggSynth(egg);
      }
      darkKick(offset=0) {
        let now = this.ctx.currentTime + offset;
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.setValueAtTime(44, now);
        o.frequency.exponentialRampToValueAtTime(21, now+0.22);
        g.gain.setValueAtTime(1.09, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+0.38);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+0.4);
      }
      darkSnare() {
        let now = this.ctx.currentTime;
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.21,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=1160;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.19,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.23);
        n.connect(f).connect(g).connect(this.reverb); n.start(now); n.stop(now+0.22);
      }
      lowHat() {
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.025,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=4200;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.045,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.07);
        n.connect(f).connect(g).connect(this.reverb); n.start(); n.stop(this.ctx.currentTime+0.07);
      }
      darkBass(degree, amt=1) {
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'triangle'; o.frequency.value = this.scale[degree]*0.45;
        o.detune.value = -35 + Math.random()*50;
        g.gain.setValueAtTime(0.18*amt,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.39);
        o.connect(g).connect(this.reverb); o.start(); o.stop(this.ctx.currentTime+0.4);
      }
      darkPad(chord, amt=1) {
        let now = this.ctx.currentTime;
        chord.forEach((deg,i)=>{
          let freq=this.scale[deg]*[0.98,1.03,0.53][i%3];
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='triangle'; o.frequency.value=freq;
          o.detune.value = (Math.random()-0.5)*10;
          g.gain.setValueAtTime(0.07*amt, now);
          g.gain.linearRampToValueAtTime(0.11*amt, now+0.7+0.14*i);
          g.gain.linearRampToValueAtTime(0.001, now+2.0+0.19*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.06*i); o.stop(now+2.2+0.13*i);
        });
      }
      easterEggSynth(egg) {
        let now = this.ctx.currentTime;
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sawtooth'; o.frequency.value = 330 + Math.sin(Date.now()/800)*120;
        g.gain.setValueAtTime(0.001, now);
        g.gain.linearRampToValueAtTime(0.19*egg, now+0.15);
        g.gain.linearRampToValueAtTime(0.001, now+0.8+egg*1.5);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+0.8+egg*1.5);
      }
      voidEngine() {
        let chord = this.progression[this.zone][this.chordStep];
        let posInBar = this.tick % 16;
        if (posInBar===0 || posInBar===8) this.floatPad(chord);
        if (posInBar===7 && Math.random()<0.47) this.voidBell();
        if (posInBar===13 && Math.random()<0.25) this.angelic();
      }
      floatPad(chord) {
        let now = this.ctx.currentTime;
        chord.forEach((deg,i)=>{
          let freq=this.scale[deg]*[0.38,0.61,0.94][i%3];
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='sine'; o.frequency.value=freq;
          o.detune.value = (Math.sin(Date.now()/3600)+i*0.2)*21;
          g.gain.setValueAtTime(0.11, now);
          g.gain.linearRampToValueAtTime(0.16, now+0.9+0.28*i);
          g.gain.linearRampToValueAtTime(0.001, now+3.5+0.4*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.13*i); o.stop(now+3.7+0.2*i);
        });
      }
      voidBell() {
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'triangle'; o.frequency.value = 311 + Math.random()*97;
        g.gain.setValueAtTime(0.13, this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime+3.8+Math.random());
        o.connect(g).connect(this.reverb);
        o.start(); o.stop(this.ctx.currentTime+3.7+Math.random());
      }
      angelic() {
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sine'; o.frequency.value = 924 + Math.random()*222;
        g.gain.setValueAtTime(0.07, this.ctx.currentTime);
        g.gain.linearRampToValueAtTime(0.001, this.ctx.currentTime+2.9);
        o.connect(g).connect(this.reverb);
        o.start(); o.stop(this.ctx.currentTime+2.8);
      }
      showError(msg) {
        let e = document.getElementById('error');
        e.textContent = msg; e.classList.remove('hidden');
      }
    }
    new GUMP();
  </script>
</body>
</html>
