<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, system-ui;
        }

        .orb {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.3) 40%, transparent 70%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.23, 1, 0.32, 1);
            box-shadow: 0 0 40px rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 10;
        }

        .orb::after {
            content: '';
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: inherit;
            filter: blur(8px);
            opacity: 0.6;
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.6; }
            50% { transform: scale(1.5); opacity: 0.3; }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,50,50,1) 0%, rgba(255,0,0,0.4) 40%, transparent 70%);
            box-shadow: 0 0 60px rgba(255,0,0,0.8);
            animation: rec-pulse 0.5s ease-in-out infinite;
        }

        @keyframes rec-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
        }

        .orb.sync {
            animation: sync-flash 0.15s ease-out;
        }

        @keyframes sync-flash {
            0% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
            50% { transform: translate(-50%, -50%) scale(2); filter: brightness(2); }
            100% { transform: translate(-50%, -50%) scale(1); filter: brightness(1); }
        }

        .world-freq {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 10px;
            letter-spacing: 2px;
            opacity: 0.3;
            font-variant-numeric: tabular-nums;
        }

        .genius-mode {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 2s;
        }

        .genius-mode.active {
            opacity: 0.5;
        }

        .ripple {
            position: fixed;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            pointer-events: none;
            animation: ripple-out 2s ease-out forwards;
        }

        @keyframes ripple-out {
            to {
                transform: scale(100);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>
    <div class="world-freq" id="freq">∞ Hz</div>
    <div class="genius-mode" id="genius">EINSTEIN MODE</div>

    <script>
        'use strict';

        // Quantum Beat Processor - Einstein-level beat matching using wave interference
        class QuantumBeat {
            constructor() {
                this.φ = (1 + Math.sqrt(5)) / 2; // Golden ratio
                this.bpm = 75; // Trip hop sweet spot
                this.quantum = new Map(); // Quantum state storage
                this.harmonics = [1, 1.5, 2, 2.5, 3, 4, 5, 6, 8]; // Harmonic series
                this.scales = {
                    // Kanye's favorite progressions
                    soul: [0, 3, 5, 7, 10], // Minor pentatonic
                    gospel: [0, 2, 4, 7, 9, 11], // Major with passing tones
                    drill: [0, 1, 5, 7, 8], // Dark minimal
                    future: [0, 3, 4, 7, 10, 11] // Experimental
                };
                this.currentScale = 'soul';
            }

            // Find quantum beats using Fourier transform
            quantumAnalyze(buffer, sr) {
                const data = buffer.getChannelData(0);
                const fftSize = 2048;
                const hop = 256;
                const tempo = [];
                
                // Sliding window FFT
                for (let i = 0; i < data.length - fftSize; i += hop) {
                    const window = data.slice(i, i + fftSize);
                    const spectrum = this.fft(window);
                    const peaks = this.findSpectralPeaks(spectrum);
                    
                    // Quantum beat detection via harmonic relationships
                    peaks.forEach(p => {
                        const beatFreq = p.freq * 60 / sr;
                        if (beatFreq > 60 && beatFreq < 180) {
                            tempo.push({
                                bpm: beatFreq,
                                strength: p.mag,
                                phase: p.phase,
                                time: i / sr
                            });
                        }
                    });
                }
                
                // Quantum collapse to most probable BPM
                return this.collapseTempo(tempo);
            }

            fft(data) {
                // Simplified FFT for real-time performance
                const n = data.length;
                const spectrum = new Array(n/2);
                
                for (let k = 0; k < n/2; k++) {
                    let real = 0, imag = 0;
                    for (let t = 0; t < n; t++) {
                        const angle = -2 * Math.PI * k * t / n;
                        real += data[t] * Math.cos(angle);
                        imag += data[t] * Math.sin(angle);
                    }
                    spectrum[k] = {
                        mag: Math.sqrt(real * real + imag * imag),
                        phase: Math.atan2(imag, real),
                        freq: k
                    };
                }
                
                return spectrum;
            }

            findSpectralPeaks(spectrum) {
                const peaks = [];
                for (let i = 1; i < spectrum.length - 1; i++) {
                    if (spectrum[i].mag > spectrum[i-1].mag && 
                        spectrum[i].mag > spectrum[i+1].mag &&
                        spectrum[i].mag > 0.1) {
                        peaks.push(spectrum[i]);
                    }
                }
                return peaks.sort((a, b) => b.mag - a.mag).slice(0, 10);
            }

            collapseTempo(observations) {
                if (!observations.length) return { bpm: this.bpm, confidence: 0 };
                
                // Quantum tempo via weighted probability
                const histogram = {};
                observations.forEach(obs => {
                    const rounded = Math.round(obs.bpm);
                    histogram[rounded] = (histogram[rounded] || 0) + obs.strength;
                });
                
                // Find quantum mode
                let maxBpm = this.bpm;
                let maxStrength = 0;
                
                Object.entries(histogram).forEach(([bpm, strength]) => {
                    // Prefer tempos near our target with golden ratio weighting
                    const distance = Math.abs(parseInt(bpm) - this.bpm);
                    const weight = strength / (1 + distance / this.φ);
                    
                    if (weight > maxStrength) {
                        maxStrength = weight;
                        maxBpm = parseInt(bpm);
                    }
                });
                
                return {
                    bpm: maxBpm,
                    confidence: Math.min(maxStrength / observations.length, 1)
                };
            }

            // Generate note from scale degree with microtonal bends
            getNote(degree, octave = 0) {
                const scale = this.scales[this.currentScale];
                const note = scale[degree % scale.length];
                const microBend = (Math.random() - 0.5) * 0.1; // Slight detuning
                return Math.pow(2, (note + octave * 12 + microBend) / 12);
            }
        }

        // World Synthesizer - turns environment into music
        class WorldSynth {
            constructor(ctx) {
                this.ctx = ctx;
                this.voices = new Map();
                this.worldData = {
                    motion: { x: 0, y: 0, z: 0 },
                    light: 0,
                    time: new Date(),
                    location: null,
                    weather: null
                };
                
                // Granular synthesis parameters
                this.grainSize = 0.05; // 50ms grains
                this.grainOverlap = 0.75;
                this.grainSpread = 0.2;
                
                this.initWorldSensors();
            }

            initWorldSensors() {
                // Motion sensing
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', e => {
                        if (e.accelerationIncludingGravity) {
                            this.worldData.motion = {
                                x: e.accelerationIncludingGravity.x || 0,
                                y: e.accelerationIncludingGravity.y || 0,
                                z: e.accelerationIncludingGravity.z || 0
                            };
                        }
                    });
                }

                // Light sensing via camera (experimental)
                this.initLightSensor();

                // Time-based modulation
                setInterval(() => {
                    this.worldData.time = new Date();
                    this.updateTimeModulation();
                }, 1000);

                // Mouse as motion backup
                window.addEventListener('mousemove', e => {
                    this.worldData.motion.x = (e.clientX / window.innerWidth - 0.5) * 20;
                    this.worldData.motion.y = (e.clientY / window.innerHeight - 0.5) * 20;
                });
            }

            async initLightSensor() {
                try {
                    if ('AmbientLightSensor' in window) {
                        const sensor = new AmbientLightSensor();
                        sensor.addEventListener('reading', () => {
                            this.worldData.light = sensor.illuminance / 1000; // Normalize
                        });
                        sensor.start();
                    }
                } catch (e) {
                    // Fallback to time-based light estimation
                    this.estimateLight();
                }
            }

            estimateLight() {
                const hour = new Date().getHours();
                // Sine wave approximation of daylight
                this.worldData.light = Math.max(0, Math.sin((hour - 6) * Math.PI / 12));
            }

            updateTimeModulation() {
                const time = this.worldData.time;
                const seconds = time.getSeconds() + time.getMilliseconds() / 1000;
                
                // Circadian rhythm modulation
                const hour = time.getHours() + time.getMinutes() / 60;
                this.circadianPhase = Math.sin(hour * Math.PI / 12);
            }

            // Granular synthesis engine
            createGranularVoice(buffer, params = {}) {
                const voice = {
                    buffer,
                    grains: [],
                    nextGrain: 0,
                    params: {
                        pitch: params.pitch || 1,
                        position: params.position || 0,
                        spread: params.spread || this.grainSpread,
                        density: params.density || 10, // Grains per second
                        ...params
                    }
                };

                // Schedule first grain
                this.scheduleGrain(voice);
                
                return voice;
            }

            scheduleGrain(voice) {
                const now = this.ctx.currentTime;
                
                if (now >= voice.nextGrain) {
                    const grain = this.ctx.createBufferSource();
                    const envelope = this.ctx.createGain();
                    const panner = this.ctx.createStereoPanner();
                    
                    grain.buffer = voice.buffer;
                    
                    // Grain position with world modulation
                    const worldMod = Math.abs(this.worldData.motion.x + this.worldData.motion.y) / 20;
                    const position = voice.params.position + (Math.random() - 0.5) * voice.params.spread;
                    const startTime = Math.max(0, Math.min(position * voice.buffer.duration, voice.buffer.duration - this.grainSize));
                    
                    // Pitch with world influence
                    const pitchMod = 1 + (this.worldData.motion.z / 100);
                    grain.playbackRate.value = voice.params.pitch * pitchMod;
                    
                    // Spatial positioning based on world data
                    panner.pan.value = Math.sin(now * 2) * worldMod;
                    
                    // Grain envelope
                    envelope.gain.setValueAtTime(0, now);
                    envelope.gain.linearRampToValueAtTime(0.5, now + this.grainSize * 0.1);
                    envelope.gain.exponentialRampToValueAtTime(0.001, now + this.grainSize);
                    
                    // Connect
                    grain.connect(envelope);
                    envelope.connect(panner);
                    
                    // Start grain
                    grain.start(now, startTime, this.grainSize);
                    
                    // Schedule next grain
                    voice.nextGrain = now + (1 / voice.params.density);
                    
                    // Store for cleanup
                    voice.grains.push({ grain, envelope, panner, startTime: now });
                    
                    // Cleanup old grains
                    voice.grains = voice.grains.filter(g => g.startTime > now - 1);
                    
                    return panner;
                }
                
                return null;
            }

            // World frequency calculation
            getWorldFrequency() {
                const motion = Math.sqrt(
                    this.worldData.motion.x ** 2 + 
                    this.worldData.motion.y ** 2 + 
                    this.worldData.motion.z ** 2
                );
                
                const timeFreq = (this.worldData.time.getSeconds() % 10) / 10;
                const lightFreq = this.worldData.light;
                
                // Combine world signals into frequency
                return 20 + (motion * 50) + (timeFreq * 100) + (lightFreq * 200);
            }
        }

        // Main Einstein Engine
        class EinsteinEngine {
            constructor() {
                this.ctx = null;
                this.quantum = new QuantumBeat();
                this.nodes = {};
                this.samples = new Map();
                this.recording = false;
                this.buffer = [];
                this.genius = false;
                this.worldPhase = 0;
                
                // UI elements
                this.orb = document.getElementById('orb');
                this.freqDisplay = document.getElementById('freq');
                this.geniusDisplay = document.getElementById('genius');
                
                // Start on interaction
                document.addEventListener('click', () => this.init());
                document.addEventListener('touchstart', () => this.init());
            }

            async init() {
                if (this.ctx) return this.toggleRecord();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 48000, latencyHint: 'interactive' });
                    this.world = new WorldSynth(this.ctx);
                    
                    // Master bus with Kanye-style warmth
                    this.createMasterBus();
                    
                    // Initialize layers
                    this.createLayers();
                    
                    // Create initial sounds
                    await this.createSounds();
                    
                    // Setup input
                    await this.setupInput();
                    
                    // Start engines
                    this.startSequencer();
                    this.startWorldEngine();
                    
                    // Keyboard controls
                    this.setupControls();
                    
                    console.log('EINSTEIN MODE INITIALIZED');
                    
                } catch (e) {
                    console.error('Init failed:', e);
                }
            }

            createMasterBus() {
                // Main output
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.85;
                
                // Multiband compression for that pro sound
                this.nodes.multiband = {
                    low: this.createBand(0, 200),
                    mid: this.createBand(200, 2000),
                    high: this.createBand(2000, 20000)
                };
                
                // Tape saturation
                this.nodes.tape = this.ctx.createWaveShaper();
                this.nodes.tape.curve = this.createTapeCurve();
                this.nodes.tape.oversample = '4x';
                
                // Final limiter
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -3;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.05;
                
                // Master EQ for that vinyl warmth
                this.nodes.warmth = this.ctx.createBiquadFilter();
                this.nodes.warmth.type = 'lowshelf';
                this.nodes.warmth.frequency.value = 100;
                this.nodes.warmth.gain.value = 3;
                
                this.nodes.air = this.ctx.createBiquadFilter();
                this.nodes.air.type = 'highshelf';
                this.nodes.air.frequency.value = 10000;
                this.nodes.air.gain.value = 2;
                
                // Chain everything
                this.nodes.master.connect(this.nodes.tape);
                this.nodes.tape.connect(this.nodes.warmth);
                this.nodes.warmth.connect(this.nodes.air);
                this.nodes.air.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);
            }

            createBand(low, high) {
                const band = {
                    input: this.ctx.createGain(),
                    low: this.ctx.createBiquadFilter(),
                    high: this.ctx.createBiquadFilter(),
                    comp: this.ctx.createDynamicsCompressor(),
                    output: this.ctx.createGain()
                };
                
                band.low.type = 'highpass';
                band.low.frequency.value = low;
                band.high.type = 'lowpass';
                band.high.frequency.value = high;
                
                band.comp.threshold.value = -15;
                band.comp.knee.value = 5;
                band.comp.ratio.value = 4;
                band.comp.attack.value = low < 200 ? 0.01 : 0.003;
                band.comp.release.value = low < 200 ? 0.1 : 0.05;
                
                band.input.connect(band.low);
                band.low.connect(band.high);
                band.high.connect(band.comp);
                band.comp.connect(band.output);
                
                return band;
            }

            createTapeCurve() {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    // Soft saturation with odd harmonics
                    curve[i] = Math.tanh(x * 2) * 0.95 + Math.tanh(x * 5) * 0.05;
                }
                
                return curve;
            }

            createLayers() {
                const layers = {
                    drums: { gain: 0.9, pan: 0 },
                    bass: { gain: 0.85, pan: 0 },
                    sample: { gain: 0.7, pan: 0 },
                    world: { gain: 0.6, pan: 0 },
                    texture: { gain: 0.3, pan: 0 }
                };
                
                Object.entries(layers).forEach(([name, config]) => {
                    const chain = {
                        input: this.ctx.createGain(),
                        filter: this.ctx.createBiquadFilter(),
                        comp: this.ctx.createDynamicsCompressor(),
                        pan: this.ctx.createStereoPanner(),
                        send: this.ctx.createGain(),
                        output: this.ctx.createGain()
                    };
                    
                    chain.input.gain.value = config.gain;
                    chain.pan.pan.value = config.pan;
                    chain.send.gain.value = 0.2; // Reverb send
                    
                    // Basic compression per layer
                    chain.comp.threshold.value = -12;
                    chain.comp.knee.value = 2;
                    chain.comp.ratio.value = 3;
                    
                    // Connect chain
                    chain.input.connect(chain.filter);
                    chain.filter.connect(chain.comp);
                    chain.comp.connect(chain.pan);
                    chain.pan.connect(chain.output);
                    chain.pan.connect(chain.send);
                    
                    chain.output.connect(this.nodes.master);
                    
                    this.nodes[name] = chain;
                    this.samples.set(name, []);
                });
                
                // Global reverb
                this.createReverb();
            }

            async createReverb() {
                // Convolution reverb for space
                this.nodes.reverb = this.ctx.createConvolver();
                this.nodes.reverbGain = this.ctx.createGain();
                this.nodes.reverbGain.gain.value = 0.3;
                
                // Create IR
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        // Exponential decay with early reflections
                        const decay = Math.exp(-3 * i / length);
                        const early = i < 1000 ? Math.random() * 0.5 : 0;
                        data[i] = (Math.random() * 2 - 1) * decay + early;
                    }
                }
                
                this.nodes.reverb.buffer = impulse;
                
                // Connect sends
                Object.values(this.nodes).forEach(node => {
                    if (node.send) {
                        node.send.connect(this.nodes.reverb);
                    }
                });
                
                this.nodes.reverb.connect(this.nodes.reverbGain);
                this.nodes.reverbGain.connect(this.nodes.master);
            }

            async createSounds() {
                const sr = this.ctx.sampleRate;
                
                // Punchy 808-style kick
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-5 * t) * (1 - t * 2);
                    const pitch = 60 * Math.exp(-35 * t) + 40;
                    const tone = Math.sin(2 * Math.PI * pitch * t);
                    const click = Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-100 * t) * 0.3;
                    kd[i] = (tone + click) * env;
                }
                
                // Snappy snare
                const snare = this.ctx.createBuffer(1, sr * 0.2, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-20 * t);
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.5;
                    const noise = (Math.random() * 2 - 1);
                    sd[i] = (tone + noise) * env * 0.8;
                }
                
                // Crisp hat
                const hat = this.ctx.createBuffer(1, sr * 0.03, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-200 * t);
                    hd[i] = (Math.random() * 2 - 1) * env * 0.5;
                }
                
                // Sub bass
                const bass = this.ctx.createBuffer(1, sr * 2, sr);
                const bd = bass.getChannelData(0);
                for (let i = 0; i < bd.length; i++) {
                    const t = i / sr;
                    const env = t < 0.01 ? t * 100 : Math.exp(-0.5 * (t - 0.01));
                    const freq = 40 * (1 + Math.sin(2 * Math.PI * 0.25 * t) * 0.1);
                    bd[i] = Math.sin(2 * Math.PI * freq * t) * env;
                }
                
                // Store drum samples
                this.samples.get('drums').push(
                    { type: 'kick', buffer: kick },
                    { type: 'snare', buffer: snare },
                    { type: 'hat', buffer: hat }
                );
                
                this.samples.get('bass').push({ type: 'sub', buffer: bass });
                
                // Create world texture
                this.createWorldTexture();
            }

            createWorldTexture() {
                // Ambient texture that responds to world
                const duration = 4;
                const texture = this.ctx.createBuffer(2, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                
                for (let ch = 0; ch < 2; ch++) {
                    const data = texture.getChannelData(ch);
                    const phaseOffset = ch * Math.PI / 4;
                    
                    for (let i = 0; i < data.length; i++) {
                        const t = i / this.ctx.sampleRate;
                        
                        // Harmonic drone
                        let sample = 0;
                        for (let h = 1; h <= 5; h++) {
                            const freq = 55 * h * (1 + Math.sin(t * 0.1 + phaseOffset) * 0.01);
                            sample += Math.sin(2 * Math.PI * freq * t) / h;
                        }
                        
                        // Envelope
                        const env = Math.sin(t * Math.PI / duration);
                        data[i] = sample * env * 0.1;
                    }
                }
                
                this.samples.get('texture').push({ type: 'ambient', buffer: texture });
            }

            async setupInput() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.analyzer = this.ctx.createAnalyser();
                    this.nodes.analyzer.fftSize = 2048;
                    
                    // Recording processor
                    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.nodes.recorder.onaudioprocess = e => {
                        if (this.recording) {
                            const input = e.inputBuffer.getChannelData(0);
                            this.buffer.push(...input);
                            
                            // Auto-stop at 16 seconds
                            if (this.buffer.length > this.ctx.sampleRate * 16) {
                                this.stopRecording();
                            }
                        }
                    };
                    
                    this.nodes.mic.connect(this.nodes.analyzer);
                    
                    // Start continuous analysis
                    this.startAnalysis();
                    
                } catch (e) {
                    console.error('Mic setup failed:', e);
                }
            }

            startAnalysis() {
                const data = new Uint8Array(this.nodes.analyzer.frequencyBinCount);
                let silenceCounter = 0;
                
                const analyze = () => {
                    if (!this.recording && this.genius) {
                        this.nodes.analyzer.getByteFrequencyData(data);
                        
                        // Detect interesting sounds
                        let energy = 0;
                        let harmonics = 0;
                        
                        for (let i = 0; i < data.length; i++) {
                            if (data[i] > 128) energy++;
                            if (i > 10 && i < 100 && data[i] > 150) harmonics++;
                        }
                        
                        // Auto-sample interesting sounds
                        if (energy > 50 && harmonics > 10) {
                            if (silenceCounter > 100) { // After 2 seconds of silence
                                this.toggleRecord();
                                silenceCounter = 0;
                            }
                        } else {
                            silenceCounter++;
                        }
                    }
                    
                    requestAnimationFrame(analyze);
                };
                
                analyze();
            }

            toggleRecord() {
                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                this.recording = true;
                this.buffer = [];
                this.nodes.mic.connect(this.nodes.recorder);
                this.nodes.recorder.connect(this.ctx.destination);
                this.orb.classList.add('recording');
            }

            stopRecording() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.recorder);
                this.nodes.recorder.disconnect();
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.1) { // Min 100ms
                    this.processRecording();
                }
            }

            processRecording() {
                const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                buf.getChannelData(0).set(this.buffer);
                
                // Quantum beat analysis
                const analysis = this.quantum.quantumAnalyze(buf, this.ctx.sampleRate);
                
                // Create sample with Einstein-level processing
                const sample = {
                    buffer: buf,
                    analysis,
                    grains: null,
                    quantum: Math.random() // Quantum state
                };
                
                // Determine best use based on content
                if (analysis.confidence > 0.7 && buf.duration > 2) {
                    // Strong rhythm - use as main sample
                    this.samples.get('sample').push(sample);
                    
                    // Create granular voice
                    sample.grains = this.world.createGranularVoice(buf, {
                        pitch: 1,
                        density: 20,
                        spread: 0.1
                    });
                    
                    // Update scale based on harmonic content
                    this.updateScale(buf);
                    
                    console.log(`QUANTUM SAMPLE: ${analysis.bpm} BPM @ ${(analysis.confidence * 100).toFixed(0)}% confidence`);
                } else {
                    // Texture or one-shot
                    this.samples.get('texture').push(sample);
                    console.log('TEXTURE CAPTURED');
                }
                
                // Visual feedback
                this.createRipple();
            }

            updateScale(buffer) {
                // Analyze harmonic content to choose scale
                const data = buffer.getChannelData(0);
                const spectrum = this.quantum.fft(data.slice(0, 2048));
                
                // Find strongest harmonics
                const peaks = this.quantum.findSpectralPeaks(spectrum);
                
                // Map to scale (simplified)
                if (peaks[0].freq < 50) {
                    this.quantum.currentScale = 'drill'; // Dark
                } else if (peaks.length > 5) {
                    this.quantum.currentScale = 'gospel'; // Rich
                } else {
                    this.quantum.currentScale = 'soul'; // Default
                }
            }

            createRipple() {
                const ripple = document.createElement('div');
                ripple.className = 'ripple';
                ripple.style.width = '20px';
                ripple.style.height = '20px';
                ripple.style.left = '50%';
                ripple.style.top = '50%';
                ripple.style.transform = 'translate(-50%, -50%)';
                document.body.appendChild(ripple);
                
                setTimeout(() => ripple.remove(), 2000);
            }

            startSequencer() {
                let step = 0;
                let lastBeat = this.ctx.currentTime;
                const swing = 0.08; // Subtle swing
                
                const sequence = () => {
                    const now = this.ctx.currentTime;
                    const beatDuration = 60 / this.quantum.bpm / 4;
                    const swingOffset = step % 2 === 1 ? swing : -swing;
                    const nextBeat = lastBeat + beatDuration + swingOffset;
                    
                    if (now >= nextBeat) {
                        lastBeat = nextBeat;
                        
                        // Drum pattern - sparse but groovy
                        const pattern = {
                            kick: [0, 10, 20, 22],
                            snare: [8, 24],
                            hat: [2, 6, 10, 14, 18, 22, 26, 30]
                        };
                        
                        // Play drums
                        if (pattern.kick.includes(step)) {
                            this.playDrum('kick', 0.9);
                        }
                        if (pattern.snare.includes(step)) {
                            this.playDrum('snare', 0.7);
                        }
                        if (pattern.hat.includes(step)) {
                            this.playDrum('hat', 0.3 + Math.random() * 0.2);
                        }
                        
                        // Bass line - follows kick with variations
                        if (pattern.kick.includes(step) || step === 12 || step === 28) {
                            this.playBass(step);
                        }
                        
                        // Play samples and grains
                        this.updateGrains();
                        
                        // Visual sync
                        if (step % 4 === 0) {
                            this.orb.classList.add('sync');
                            setTimeout(() => this.orb.classList.remove('sync'), 150);
                        }
                        
                        step = (step + 1) % 32;
                    }
                    
                    requestAnimationFrame(sequence);
                };
                
                sequence();
            }

            playDrum(type, velocity) {
                const drums = this.samples.get('drums').filter(s => s.type === type);
                if (!drums.length) return;
                
                const drum = drums[0];
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = drum.buffer;
                gain.gain.value = velocity;
                
                // Vary pitch slightly
                source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.02;
                
                source.connect(gain);
                gain.connect(this.nodes.drums.input);
                
                source.start();
            }

            playBass(step) {
                const bass = this.samples.get('bass').find(s => s.type === 'sub');
                if (!bass) return;
                
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                source.buffer = bass.buffer;
                
                // Note selection based on step
                const progression = [0, 0, 3, 5]; // Root, root, minor 3rd, 5th
                const note = progression[Math.floor(step / 8) % progression.length];
                source.playbackRate.value = this.quantum.getNote(note, -1);
                
                // Filter movement
                filter.type = 'lowpass';
                filter.frequency.value = 200 + Math.sin(step * 0.2) * 100;
                filter.Q.value = 5;
                
                gain.gain.value = 0.8;
                
                // Sidechain compression effect
                gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                gain.gain.exponentialRampToValueAtTime(0.8, this.ctx.currentTime + 0.05);
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.bass.input);
                
                source.start();
            }

            updateGrains() {
                // Update all granular voices
                const samples = this.samples.get('sample');
                samples.forEach(sample => {
                    if (sample.grains) {
                        const output = this.world.scheduleGrain(sample.grains);
                        if (output) {
                            output.connect(this.nodes.sample.input);
                        }
                        
                        // Modulate grain parameters with world data
                        const worldMod = this.world.getWorldFrequency() / 1000;
                        sample.grains.params.position = (sample.grains.params.position + 0.001 * worldMod) % 1;
                        sample.grains.params.pitch = 1 + Math.sin(this.worldPhase) * 0.1;
                    }
                });
                
                // Update texture layers
                if (Math.random() < 0.01) { // Occasionally trigger textures
                    this.playTexture();
                }
            }

            playTexture() {
                const textures = this.samples.get('texture');
                if (!textures.length) return;
                
                const texture = textures[Math.floor(Math.random() * textures.length)];
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                
                source.buffer = texture.buffer;
                
                // Random pitch within harmonic series
                const harmonic = this.quantum.harmonics[Math.floor(Math.random() * this.quantum.harmonics.length)];
                source.playbackRate.value = harmonic * (0.5 + Math.random());
                
                // Spatial positioning
                panner.pan.value = (Math.random() - 0.5) * 0.8;
                
                // Fade in/out
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.5);
                gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
                
                source.connect(panner);
                panner.connect(gain);
                gain.connect(this.nodes.texture.input);
                
                source.start();
            }

            startWorldEngine() {
                const update = () => {
                    // Update world phase
                    this.worldPhase += 0.01;
                    
                    // Update frequency display
                    const freq = this.world.getWorldFrequency();
                    this.freqDisplay.textContent = `${freq.toFixed(0)} Hz`;
                    
                    // Modulate master filters based on world
                    const brightness = this.world.worldData.light;
                    this.nodes.air.frequency.value = 8000 + brightness * 4000;
                    
                    // Time-based modulation
                    const circadian = this.world.circadianPhase || 0;
                    this.nodes.warmth.gain.value = 3 + circadian * 2;
                    
                    requestAnimationFrame(update);
                };
                
                update();
            }

            setupControls() {
                document.addEventListener('keydown', e => {
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.toggleRecord();
                            break;
                        case 'g':
                            this.genius = !this.genius;
                            this.geniusDisplay.classList.toggle('active', this.genius);
                            console.log(`GENIUS MODE: ${this.genius ? 'ON' : 'OFF'}`);
                            break;
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                            const scales = Object.keys(this.quantum.scales);
                            this.quantum.currentScale = scales[parseInt(e.key) - 1];
                            console.log(`SCALE: ${this.quantum.currentScale}`);
                            break;
                    }
                });
                
                // Touch controls
                let touchStart = 0;
                document.addEventListener('touchstart', e => {
                    touchStart = Date.now();
                });
                
                document.addEventListener('touchend', e => {
                    const duration = Date.now() - touchStart;
                    if (duration > 500) {
                        this.genius = !this.genius;
                        this.geniusDisplay.classList.toggle('active', this.genius);
                    }
                });
            }
        }

        // Initialize the Einstein Engine
        const engine = new EinsteinEngine();
    </script>
</body>
</html>
