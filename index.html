<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: World-Sampling Trip Hop Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
        }

        .orb {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 20px rgba(255,255,255,0.4);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.3px);
        }

        .orb.pulse {
            animation: pulse 0.4s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.3px); }
            50% { transform: translate(-50%, -50%) scale(3.5); box-shadow: 0 0 40px rgba(255,255,255,0.7); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.3px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,1) 0%, rgba(255,0,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 25px rgba(255,0,0,0.6);
            animation: rec 0.8s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
        }

        .orb.motion {
            background: radial-gradient(circle, rgba(100,255,100,1) 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 25px rgba(0,255,0,0.6);
            animation: motionGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes motionGlow {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>

    <script>
        'use strict';

        // Advanced BeatMatcher with onset detection and phase vocoder-inspired stretching
        class BeatMatcher {
            constructor(bpm = 75) {
                this.bpm = bpm;
                this.barLength = 4; // Beats per bar
            }

            // Enhanced peak detection using spectral flux onset detection
            findPeaks(buffer) {
                const sr = buffer.sampleRate;
                const data = buffer.getChannelData(0);
                const fftSize = 1024;
                const hopSize = 256;
                const peaks = [];
                let prevSpectrum = new Float32Array(fftSize / 2);

                const analyser = new OfflineAudioContext(1, data.length, sr);
                const source = analyser.createBufferSource();
                source.buffer = buffer;
                const scriptNode = analyser.createScriptProcessor(fftSize, 1, 1);
                const fft = new AnalyserNode(analyser, { fftSize });

                source.connect(fft);
                fft.connect(scriptNode);
                scriptNode.connect(analyser.destination);

                scriptNode.onaudioprocess = (e) => {
                    const spectrum = new Float32Array(fft.frequencyBinCount);
                    fft.getFloatFrequencyData(spectrum);

                    let flux = 0;
                    for (let i = 0; i < spectrum.length; i++) {
                        const diff = spectrum[i] - prevSpectrum[i];
                        flux += diff > 0 ? diff : 0;
                    }
                    flux /= spectrum.length;

                    if (flux > 8 && e.playbackTime > 0.1) { // Threshold for onset
                        peaks.push({ time: e.playbackTime, energy: flux, index: Math.floor(e.playbackTime * sr) });
                    }

                    prevSpectrum.set(spectrum);
                };

                await analyser.startRendering();
                return peaks.filter((p, i) => i === 0 || p.time - peaks[i-1].time > 0.05); // Debounce
            }

            // Improved grid matching with tempo estimation
            matchToGrid(peaks) {
                if (peaks.length < 3) return 1;

                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i].time - peaks[i - 1].time);
                }

                // Estimate BPM from median interval
                const medianInterval = intervals.slice().sort((a,b) => a-b)[Math.floor(intervals.length/2)];
                const estimatedBPM = 60 / medianInterval;

                // Snap to closest reasonable BPM (60-120 range for trip hop)
                this.bpm = Math.round(estimatedBPM / 5) * 5;
                this.bpm = Math.max(60, Math.min(120, this.bpm));

                const beatDuration = 60 / this.bpm;
                const targetDuration = beatDuration * this.barLength * (peaks.length - 1) / intervals.length * intervals.length;

                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                return targetDuration / actualDuration;
            }

            // Advanced chopping with fade envelopes
            chopSample(buffer, peaks, chopsPerBar = 8) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration * this.barLength / chopsPerBar;

                for (let i = 0; i < Math.min(peaks.length - 1, chopsPerBar); i++) {
                    const start = peaks[i].time;
                    const end = Math.min(start + chopLength, buffer.duration);
                    chops.push({ start, end, energy: peaks[i].energy });
                }

                return chops;
            }
        }

        // Revolutionary Bass Synth: Multi-layer FM + Wavefolding for 2025 Kanye depth
        class ProfessionalBass {
            constructor(ctx, bpm) {
                this.ctx = ctx;
                this.bpm = bpm;
                this.activeVoices = new Map();
                // Evolving Kanye-inspired patterns
                this.patterns = [
                    [36, 36, 43, 41, 38, 38, 34, 36], // Pattern 1
                    [31, 31, 38, 36, 33, 33, 29, 31]  // Pattern 2
                ];
                this.currentPattern = 0;
                this.triggerPattern = [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0];
            }

            midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }

            play(step, output) {
                if (!this.triggerPattern[step % 16]) return;

                const noteIndex = Math.floor(step / 2) % 8;
                const midi = this.patterns[this.currentPattern][noteIndex];
                const freq = this.midiToFreq(midi);

                if (this.activeVoices.has(midi)) {
                    this.activeVoices.get(midi).stop(this.ctx.currentTime);
                    this.activeVoices.delete(midi);
                }

                const voice = this.createVoice(freq, output);
                this.activeVoices.set(midi, voice);

                // Evolve pattern every 32 steps
                if (step % 32 === 0) this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
            }

            createVoice(freq, output) {
                const now = this.ctx.currentTime;
                const duration = 60 / this.bpm / 2; // Half note

                // Multi-layer: Sub sine + FM mid + Wavefolded top
                const sub = this.ctx.createOscillator();
                sub.type = 'sine';
                sub.frequency.value = freq * 0.5;

                const fmCarrier = this.ctx.createOscillator();
                fmCarrier.type = 'sine';
                fmCarrier.frequency.value = freq;

                const fmMod = this.ctx.createOscillator();
                fmMod.type = 'triangle';
                fmMod.frequency.value = freq * 3;

                const fmGain = this.ctx.createGain();
                fmGain.gain.value = freq * 2; // FM index

                fmMod.connect(fmGain);
                fmGain.connect(fmCarrier.frequency);

                const top = this.ctx.createOscillator();
                top.type = 'sawtooth';
                top.frequency.value = freq * 2;

                // Wavefolder for harmonics
                const folder = this.ctx.createWaveShaper();
                const curve = new Float32Array(1024);
                for (let i = 0; i < 1024; i++) {
                    let x = (i - 512) / 512 * 3;
                    curve[i] = Math.tanh(x) / Math.tanh(3);
                }
                folder.curve = curve;
                folder.oversample = '4x';

                // Gains
                const subGain = this.ctx.createGain();
                subGain.gain.value = 0.9;
                const fmGainNode = this.ctx.createGain();
                fmGainNode.gain.value = 0.7;
                const topGain = this.ctx.createGain();
                topGain.gain.value = 0.4;

                // Resonant filter with movement
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 150;
                filter.Q.value = 12;

                filter.frequency.setValueAtTime(100, now);
                filter.frequency.exponentialRampToValueAtTime(300, now + 0.03);
                filter.frequency.exponentialRampToValueAtTime(150, now + duration * 0.4);
                filter.frequency.exponentialRampToValueAtTime(80, now + duration);

                // Envelope
                const env = this.ctx.createGain();
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(1, now + 0.01);
                env.gain.exponentialRampToValueAtTime(0.6, now + 0.15);
                env.gain.exponentialRampToValueAtTime(0.001, now + duration);

                // 808-style pitch glide
                const glideAmount = -18;
                sub.frequency.exponentialRampToValueAtTime(freq * 0.5 * Math.pow(2, glideAmount/12), now + duration * 0.8);
                fmCarrier.frequency.exponentialRampToValueAtTime(freq * Math.pow(2, glideAmount/12), now + duration * 0.8);
                top.frequency.exponentialRampToValueAtTime(freq * 2 * Math.pow(2, glideAmount/12), now + duration * 0.8);

                // Connect
                sub.connect(subGain);
                fmCarrier.connect(fmGainNode);
                top.connect(folder);
                folder.connect(topGain);

                [subGain, fmGainNode, topGain].forEach(g => g.connect(filter));
                filter.connect(env);
                env.connect(output);

                // Start oscillators
                [sub, fmCarrier, fmMod, top].forEach(osc => {
                    osc.start(now);
                    osc.stop(now + duration + 0.1);
                });

                return {
                    stop: (when) => [sub, fmCarrier, fmMod, top].forEach(osc => osc.stop(when))
                };
            }
        }

        // Enhanced LoFi Processor with vinyl warp and tape hiss
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
            }

            createProcessor() {
                // Bitcrusher with variable depth
                const bitcrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                const bits = 7;
                const downsample = 0.25;
                let phase = 0;
                bitcrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < input.length; i++) {
                        phase += downsample;
                        if (phase >= 1) {
                            phase -= 1;
                            const step = Math.pow(0.5, bits);
                            output[i] = step * Math.floor(input[i] / step + 0.5);
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };

                // Tape saturation
                const saturator = this.ctx.createWaveShaper();
                const satCurve = new Float32Array(1024);
                for (let i = 0; i < 1024; i++) {
                    const x = (i / 512 - 1) * 2;
                    satCurve[i] = x / (1 + Math.abs(x * 1.5));
                }
                saturator.curve = satCurve;
                saturator.oversample = '2x';

                // Warm filter
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2500;
                filter.Q.value = 0.8;

                // Hiss generator
                const hiss = this.ctx.createScriptProcessor(4096, 1, 1);
                hiss.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < output.length; i++) {
                        output[i] += (Math.random() * 2 - 1) * 0.02;
                    }
                };
                const hissGain = this.ctx.createGain();
                hissGain.gain.value = 0.05;

                // Chain
                const input = this.ctx.createGain();
                input.connect(bitcrusher);
                bitcrusher.connect(saturator);
                saturator.connect(filter);
                filter.connect(hiss);
                hiss.connect(hissGain);
                hissGain.connect(this.ctx.createGain()); // Output node

                return { input, output: hissGain };
            }
        }

        // Main Engine: Breakthrough integration with motion-reactive effects
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.professionalBass = null;
                this.lofi = null;
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.2, last: 0 };
                this.orb = document.getElementById('orb');
                this.bassActive = false;
                this.warmupBeats = 0;
                this.pitchShifts = [0.5, 0.707, 0.8, 1, 1.25, 1.414, 2]; // Musical intervals
                this.motionThreshold = 1.5; // g-force for trigger
                this.motionEffect = null;

                // Orb as interactive cursor
                document.addEventListener('mousemove', (e) => {
                    this.orb.style.left = `${e.clientX}px`;
                    this.orb.style.top = `${e.clientY}px`;
                });

                // Motion engine
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', this.handleMotion.bind(this));
                }

                document.addEventListener('click', () => this.start());
                document.addEventListener('keydown', (e) => {
                    if (e.key === ' ') this.toggleRecording();
                });
            }

            async start() {
                if (this.ctx) return this.toggleRecording();

                this.ctx = new (AudioContext || webkitAudioContext)({ sampleRate: 44100 });
                this.lofi = new LoFi(this.ctx);
                this.professionalBass = new ProfessionalBass(this.ctx, this.beatMatcher.bpm);

                // Master chain with reverb for depth
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.85;

                const reverb = await this.createReverb();
                this.nodes.master.connect(reverb);
                reverb.connect(this.ctx.destination);

                // Vinyl highpass
                this.nodes.vinylFilter = this.ctx.createBiquadFilter();
                this.nodes.vinylFilter.type = 'highpass';
                this.nodes.vinylFilter.frequency.value = 25;

                // Compression
                this.nodes.comp = this.ctx.createDynamicsCompressor();
                this.nodes.comp.threshold.value = -24;
                this.nodes.comp.knee.value = 15;
                this.nodes.comp.ratio.value = 4;
                this.nodes.comp.attack.value = 0.005;
                this.nodes.comp.release.value = 0.2;

                // Dust filter
                this.nodes.dust = this.ctx.createBiquadFilter();
                this.nodes.dust.type = 'lowpass';
                this.nodes.dust.frequency.value = 7000;
                this.nodes.dust.Q.value = 1;

                // Chain: master -> vinyl -> comp -> dust -> reverb -> destination
                this.nodes.master.connect(this.nodes.vinylFilter);
                this.nodes.vinylFilter.connect(this.nodes.comp);
                this.nodes.comp.connect(this.nodes.dust);
                this.nodes.dust.connect(reverb);

                // Layer gains
                const layers = {
                    kick: 0.95,
                    snare: 0.75,
                    hats: 0.35,
                    sample: 0.85,
                    bass: 0.9,
                    vinyl: 0.12
                };
                Object.entries(layers).forEach(([name, vol]) => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = vol;
                    this.nodes[name].connect(this.nodes.master);
                    this.samples.set(name, []);
                });

                // Generate drums and vinyl
                await this.generateDrums();
                this.generateVinylNoise();

                // Mic setup
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                    });
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);

                    this.nodes.recorder.onaudioprocess = (e) => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            if (this.buffer.length > this.ctx.sampleRate * 10) this.stopRecording(); // Max 10s
                        }
                    };
                } catch (e) {
                    console.warn('Mic access denied - sampling disabled');
                }

                // Auto-sampling loop
                this.autoSampleLoop();

                // Start sequencer
                this.seq.last = this.ctx.currentTime;
                requestAnimationFrame(this.tick.bind(this));
            }

            async createReverb() {
                // Impulse response for rich depth
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                const left = impulse.getChannelData(0);
                const right = impulse.getChannelData(1);

                for (let i = 0; i < length; i++) {
                    left[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    right[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                }

                const reverb = this.ctx.createConvolver();
                reverb.buffer = impulse;

                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = 0.3;

                const dry = this.ctx.createGain();
                dry.gain.value = 0.7;

                const wet = this.ctx.createGain();
                wet.gain.value = 0.3;

                const merger = this.ctx.createChannelMerger(2);

                // Input splits to dry and wet
                const input = this.ctx.createGain();
                input.connect(dry);
                input.connect(reverb);
                reverb.connect(wet);

                dry.connect(merger, 0, 0);
                dry.connect(merger, 0, 1);
                wet.connect(merger, 0, 0);
                wet.connect(merger, 0, 1);

                return input; // Use as node.connect(input)
            }

            async generateDrums() {
                const sr = this.ctx.sampleRate;

                // Deep 808 kick with layered subs
                const kickBuffer = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kickData = kickBuffer.getChannelData(0);
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-t * 10);
                    const freq = 50 * Math.exp(-t * 30);
                    const sub = Math.sin(2 * Math.PI * freq * t) * env * 1.2;
                    const punch = Math.sin(2 * Math.PI * 120 * t) * Math.exp(-t * 50) * 0.5;
                    const click = (Math.random() * 2 - 1) * Math.exp(-t * 200) * 0.3;
                    kickData[i] = Math.tanh(sub + punch + click);
                }

                // Rich snare with noise body
                const snareBuffer = this.ctx.createBuffer(1, sr * 0.3, sr);
                const snareData = snareBuffer.getChannelData(0);
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-t * 25);
                    const tone = Math.sin(2 * Math.PI * 180 * t) * 0.5;
                    const body = Math.sin(2 * Math.PI * 90 * t) * Math.exp(-t * 60) * 0.4;
                    const noise = (Math.random() * 2 - 1) * 0.8;
                    snareData[i] = Math.tanh((tone + body + noise) * env * 1.1);
                }

                // Airy hats with shimmer
                const hatBuffer = this.ctx.createBuffer(1, sr * 0.1, sr);
                const hatData = hatBuffer.getChannelData(0);
                for (let i = 0; i < hatData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-t * 80);
                    let s = (Math.random() * 2 - 1) * env;
                    if (i > 2) s = s * 0.4 + hatData[i-1] * 0.5 + hatData[i-2] * 0.4;
                    hatData[i] = s * 0.6;
                }

                this.samples.get('kick').push({ buffer: kickBuffer, rate: 1 });
                this.samples.get('snare').push({ buffer: snareBuffer, rate: 1 });
                this.samples.get('hats').push({ buffer: hatBuffer, rate: 1 });
            }

            generateVinylNoise() {
                const duration = 5;
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = (Math.random() - 0.5) * 0.03; // Hiss
                    if (Math.random() < 0.0002) data[i] += (Math.random() - 0.5) * 0.4; // Pops
                }

                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.loop = true;
                source.connect(this.nodes.vinyl);
                source.start();
            }

            toggleRecording() {
                if (!this.nodes.mic) return;

                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.recorder);
                    this.nodes.recorder.connect(this.ctx.destination); // Monitor
                    this.orb.classList.add('recording');
                }
            }

            async stopRecording() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.recorder);
                this.nodes.recorder.disconnect();
                this.orb.classList.remove('recording');

                if (this.buffer.length < this.ctx.sampleRate * 0.3) return;

                const audioBuffer = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                audioBuffer.getChannelData(0).set(this.buffer);

                // Process sample
                const peaks = await this.beatMatcher.findPeaks(audioBuffer);
                const stretch = this.beatMatcher.matchToGrid(peaks);
                const pitch = this.pitchShifts[Math.floor(Math.random() * this.pitchShifts.length)];
                const chops = this.beatMatcher.chopSample(audioBuffer, peaks);

                const sample = { buffer: audioBuffer, rate: stretch * pitch, chops, pitch };

                const samples = this.samples.get('sample');
                if (samples.length >= 3) samples.shift();
                samples.push(sample);

                console.log(`New sample added: ${pitch.toFixed(2)}x pitch, ${stretch.toFixed(2)}x stretch, ${chops.length} chops`);
            }

            autoSampleLoop() {
                if (!this.nodes.mic) return;

                const analyser = this.ctx.createAnalyser();
                analyser.fftSize = 2048;
                this.nodes.mic.connect(analyser);

                const data = new Float32Array(analyser.frequencyBinCount);
                let cooldown = 0;

                const check = () => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        requestAnimationFrame(check);
                        return;
                    }

                    analyser.getFloatFrequencyData(data);

                    let score = 0;
                    for (let i = 20; i < 200; i++) { // Mid-range harmonics
                        if (data[i] > -60) score += data[i] + 60;
                    }
                    score /= 180;

                    if (score > 20) {
                        this.toggleRecording();
                        cooldown = 300; // ~6s cooldown
                    }

                    requestAnimationFrame(check);
                };
                check();
            }

            handleMotion(e) {
                const acc = e.accelerationIncludingGravity;
                const g = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2) / 9.81;

                if (g > this.motionThreshold) {
                    this.orb.classList.add('motion');
                    // Motion-triggered effect: Modulate filter
                    if (this.motionEffect) this.motionEffect.frequency.value = 2000 + (g - 1) * 1000;
                    setTimeout(() => this.orb.classList.remove('motion'), 500);
                }
            }

            tick() {
                const now = this.ctx.currentTime;
                const beatDuration = 60 / this.beatMatcher.bpm / 4;
                const swingFactor = this.seq.step % 2 === 1 ? 1 + this.seq.swing : 1 - this.seq.swing;
                const stepDuration = beatDuration * swingFactor;

                if (now >= this.seq.last + stepDuration) {
                    this.seq.last = now;
                    this.warmupBeats++;

                    // Visual pulse on downbeat
                    if (this.seq.step % 4 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 400);
                    }

                    // Drum patterns (trip hop groove)
                    if ([0, 8, 16, 24].includes(this.seq.step % 32)) {
                        this.playSampleType('kick', 1);
                    }
                    if ([4, 12, 20, 28].includes(this.seq.step % 32)) {
                        this.playSampleType('snare', 0.9);
                    }
                    if ([1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31].includes(this.seq.step % 32)) {
                        this.playSampleType('hats', 0.4 + Math.random() * 0.2);
                    }

                    // Activate bass after warmup (4 bars)
                    if (this.warmupBeats > 64 && !this.bassActive) {
                        this.bassActive = true;
                        console.log('Deep bass engaged');
                    }

                    if (this.bassActive) {
                        this.professionalBass.play(this.seq.step, this.nodes.bass);
                    }

                    // Play layered samples
                    const samples = this.samples.get('sample');
                    if (samples.length > 0 && this.seq.step % 8 === 0) {
                        this.playLayeredSample(samples[samples.length - 1]);
                    }

                    this.seq.step = (this.seq.step + 1) % 32;
                }

                requestAnimationFrame(this.tick.bind(this));
            }

            playSampleType(type, velocity) {
                const samples = this.samples.get(type);
                if (!samples.length) return;

                const sample = samples[Math.floor(Math.random() * samples.length)];
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.rate || 1;

                const gain = this.ctx.createGain();
                gain.gain.value = velocity;

                const processor = this.lofi.createProcessor();
                source.connect(processor.input);
                processor.output.connect(gain);
                gain.connect(this.nodes[type]);

                source.start();
            }

            playLayeredSample(sample) {
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.rate;
                source.loop = true;
                source.loopEnd = 60 / this.beatMatcher.bpm * this.beatMatcher.barLength;

                const gain = this.ctx.createGain();
                gain.gain.value = 0.8;

                // Dynamic filter with motion integration
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1800;
                filter.Q.value = 3;
                this.motionEffect = filter; // For motion modulation

                // Sweep
                filter.frequency.linearRampToValueAtTime(4000, this.ctx.currentTime + 4);
                filter.frequency.linearRampToValueAtTime(1800, this.ctx.currentTime + 8);

                // Sidechain ducking
                const sidechainInterval = setInterval(() => {
                    if (this.seq.step % 4 === 0) {
                        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.15);
                    }
                }, beatDuration * 1000);

                const processor = this.lofi.createProcessor();
                source.connect(processor.input);
                processor.output.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample);

                source.start();

                // Stop previous
                if (this.currentSampleSource) {
                    this.currentSampleSource.stop();
                    clearInterval(this.currentSampleSidechain);
                }
                this.currentSampleSource = source;
                this.currentSampleSidechain = sidechainInterval;
            }
        }

        new Engine();
    </script>
</body>
</html>
