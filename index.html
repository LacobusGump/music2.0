<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ALIVE DJ</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  background: #000;
  color: #fff;
  overflow: hidden;
  height: 100vh;
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  cursor: none;
  user-select: none;
}

/* Fibonacci Golden Ratio Grid */
.phi-container {
  position: fixed;
  inset: 0;
  display: grid;
  grid-template-columns: 1fr 1.618fr;
  grid-template-rows: 1.618fr 1fr;
  pointer-events: none;
}

/* Minimal DNA Visualizer */
.dna-strand {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 233px; /* Fibonacci number */
  height: 377px; /* Fibonacci number */
  opacity: 0;
  transition: opacity 3s cubic-bezier(0.23, 1, 0.320, 1);
  pointer-events: none;
}

.dna-strand.active {
  opacity: 1;
}

.dna-helix {
  position: absolute;
  width: 100%;
  height: 100%;
}

.dna-node {
  position: absolute;
  width: 3px;
  height: 3px;
  background: rgba(255, 255, 255, 0.8);
  border-radius: 50%;
  box-shadow: 0 0 13px rgba(255, 255, 255, 0.5);
}

/* Spectral Aura */
.spectral-aura {
  position: fixed;
  inset: 0;
  background: radial-gradient(
    circle at 50% 50%,
    transparent 0%,
    transparent 38.2%, /* Golden ratio % */
    rgba(255, 255, 255, 0.01) 61.8%,
    rgba(0, 0, 0, 0.8) 100%
  );
  pointer-events: none;
  mix-blend-mode: screen;
}

/* Evolution State */
.evolution-state {
  position: fixed;
  bottom: 21px; /* Fibonacci */
  left: 50%;
  transform: translateX(-50%);
  font-size: 8px; /* Fibonacci */
  letter-spacing: 5px; /* Fibonacci */
  opacity: 0.382; /* Golden ratio */
  text-transform: uppercase;
  font-weight: 100;
  transition: opacity 1.618s ease;
}

.evolution-state.pulse {
  opacity: 0.618;
}

/* Waveform Memory */
.memory-trace {
  position: fixed;
  top: 34px; /* Fibonacci */
  left: 50%;
  transform: translateX(-50%);
  width: 610px; /* Fibonacci */
  height: 2px;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.1) 38.2%,
    rgba(255, 255, 255, 0.1) 61.8%,
    transparent 100%
  );
  overflow: hidden;
}

.memory-wave {
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(
    90deg,
    transparent 0%,
    rgba(255, 255, 255, 0.618) 50%,
    transparent 100%
  );
  animation: memory-flow 8s linear infinite;
}

@keyframes memory-flow {
  to { left: 100%; }
}

/* Frequency Bloom */
.freq-bloom {
  position: fixed;
  width: 89px; /* Fibonacci */
  height: 89px;
  border-radius: 50%;
  background: radial-gradient(
    circle,
    rgba(255, 255, 255, 0.05) 0%,
    transparent 61.8%
  );
  pointer-events: none;
  opacity: 0;
  transform: translate(-50%, -50%) scale(0);
  transition: all 2.618s cubic-bezier(0.23, 1, 0.320, 1);
}

.freq-bloom.active {
  opacity: 1;
  transform: translate(-50%, -50%) scale(1);
}

/* Start Ritual */
.start-ritual {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  transition: opacity 1.618s ease;
  cursor: pointer;
}

.start-ritual.hidden {
  opacity: 0;
  pointer-events: none;
}

.ritual-text {
  font-size: 13px; /* Fibonacci */
  letter-spacing: 8px; /* Fibonacci */
  opacity: 0.618;
  animation: breathe 3s ease-in-out infinite;
}

@keyframes breathe {
  0%, 100% { opacity: 0.382; }
  50% { opacity: 0.618; }
}

/* Harmonic Particles */
.harmonic-particle {
  position: fixed;
  width: 2px;
  height: 2px;
  background: rgba(255, 255, 255, 0.618);
  border-radius: 50%;
  pointer-events: none;
  animation: drift 13s linear infinite;
}

@keyframes drift {
  from {
    transform: translateY(100vh) translateX(0);
    opacity: 0;
  }
  5% { opacity: 0.618; }
  95% { opacity: 0.618; }
  to {
    transform: translateY(-100vh) translateX(34px);
    opacity: 0;
  }
}
</style>
</head>
<body>
<div class="start-ritual" id="startRitual">
  <div class="ritual-text">BREATHE</div>
</div>

<div class="phi-container"></div>
<div class="spectral-aura"></div>

<div class="dna-strand" id="dnaStrand">
  <div class="dna-helix" id="dnaHelix"></div>
</div>

<div class="memory-trace">
  <div class="memory-wave"></div>
</div>

<div class="evolution-state" id="evolutionState">SILENCE</div>

<script>
'use strict';

// ALIVE DJ - Spectral DNA Evolution Engine
class AliveDJ {
  constructor() {
    // Core Audio
    this.ctx = null;
    this.sampleRate = 44100;
    
    // Master Chain
    this.nodes = {};
    this.master = null;
    
    // DNA System - Musical genetics extracted from samples
    this.dna = {
      timbre: [],      // Spectral centroid evolution
      rhythm: [],      // Onset patterns
      harmony: [],     // Pitch class profiles
      dynamics: [],    // Energy contours
      memory: []       // Sample history
    };
    
    // Conductor AI - Manages evolution
    this.conductor = {
      state: 'silence',
      energy: 0,
      tension: 0,
      memory: 0,
      evolution: 0,
      lastSample: 0,
      sampleCooldown: 0
    };
    
    // Sample Bank
    this.samples = [];
    this.maxSamples = 8; // Fibonacci
    this.currentLoop = null;
    
    // Recording
    this.isRecording = false;
    this.recordBuffer = [];
    this.silenceDetector = 0;
    
    // Sequencer
    this.bpm = 89; // Fibonacci starting BPM
    this.step = 0;
    this.phi = 1.618033988749;
    
    // Voice Architecture - Cleaner, constraint-based
    this.voices = {
      bass: { active: false, freq: 55, amp: 0, target: 0 },
      kick: { active: false, amp: 0, target: 0 },
      texture: { active: false, amp: 0, target: 0 },
      harmony: { active: false, notes: [], amp: 0, target: 0 },
      sample: { active: false, amp: 0, target: 0 }
    };
    
    // Musical Constraints
    this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
    this.root = 55; // A1
    
    // UI Elements
    this.elements = {};
    
    this.init();
  }
  
  init() {
    this.elements.startRitual = document.getElementById('startRitual');
    this.elements.evolutionState = document.getElementById('evolutionState');
    this.elements.dnaStrand = document.getElementById('dnaStrand');
    this.elements.dnaHelix = document.getElementById('dnaHelix');
    
    // Create DNA visualization
    this.createDNAVisualization();
    
    // Start on interaction
    this.elements.startRitual.onclick = () => this.start();
    
    // Create harmonic particles
    this.createHarmonicParticles();
  }
  
  createDNAVisualization() {
    const count = 21; // Fibonacci
    for (let i = 0; i < count; i++) {
      const node = document.createElement('div');
      node.className = 'dna-node';
      const angle = (i / count) * Math.PI * 2;
      const y = (i / count) * 100;
      const x = 50 + Math.cos(angle) * 38.2; // Golden ratio
      const z = Math.sin(angle) * 38.2;
      
      node.style.left = `${x}%`;
      node.style.top = `${y}%`;
      node.style.transform = `translateZ(${z}px)`;
      node.style.animationDelay = `${i * 0.0618}s`;
      
      this.elements.dnaHelix.appendChild(node);
    }
  }
  
  createHarmonicParticles() {
    const count = 13; // Fibonacci
    for (let i = 0; i < count; i++) {
      const particle = document.createElement('div');
      particle.className = 'harmonic-particle';
      particle.style.left = `${Math.random() * 100}%`;
      particle.style.animationDelay = `${i * this.phi}s`;
      particle.style.animationDuration = `${8 + i * this.phi}s`;
      document.body.appendChild(particle);
    }
  }
  
  async start() {
    try {
      // Get mic permission first
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: this.sampleRate
        }
      });
      
      // Setup audio context
      this.ctx = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: this.sampleRate
      });
      
      await this.ctx.resume();
      
      this.setupAudioChain();
      this.setupMicCapture(stream);
      
      // Hide start screen
      this.elements.startRitual.classList.add('hidden');
      this.elements.dnaStrand.classList.add('active');
      
      // Start the engine
      this.evolve();
      this.sequence();
      this.render();
      
      // Auto-sampling system
      this.startAutoSampling();
      
    } catch(e) {
      console.error('Failed to initialize:', e);
    }
  }
  
  setupAudioChain() {
    // Master limiter for clean output
    this.nodes.limiter = this.ctx.createDynamicsCompressor();
    this.nodes.limiter.threshold.value = -3;
    this.nodes.limiter.knee.value = 0;
    this.nodes.limiter.ratio.value = 20;
    this.nodes.limiter.attack.value = 0.001;
    this.nodes.limiter.release.value = 0.05;
    
    // Warm saturation
    this.nodes.warm = this.ctx.createWaveShaper();
    this.nodes.warm.curve = this.createWarmthCurve(2);
    this.nodes.warm.oversample = '2x';
    
    // Master gain
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.7;
    
    // Spacial reverb
    this.nodes.space = this.ctx.createConvolver();
    this.nodes.space.buffer = this.createSpaceImpulse(this.phi);
    
    this.nodes.spaceGain = this.ctx.createGain();
    this.nodes.spaceGain.gain.value = 0.2;
    
    // Delay for depth
    this.nodes.delay = this.ctx.createDelay(1);
    this.nodes.delay.delayTime.value = 60 / this.bpm / 8; // Synced
    
    this.nodes.delayGain = this.ctx.createGain();
    this.nodes.delayGain.gain.value = 0.3;
    
    this.nodes.delayFeedback = this.ctx.createGain();
    this.nodes.delayFeedback.gain.value = 0.382; // Golden ratio
    
    // Connect delay feedback
    this.nodes.delay.connect(this.nodes.delayFeedback);
    this.nodes.delayFeedback.connect(this.nodes.delay);
    this.nodes.delay.connect(this.nodes.delayGain);
    
    // Voice gains
    this.nodes.bassGain = this.ctx.createGain();
    this.nodes.kickGain = this.ctx.createGain();
    this.nodes.textureGain = this.ctx.createGain();
    this.nodes.harmonyGain = this.ctx.createGain();
    this.nodes.sampleGain = this.ctx.createGain();
    
    // Set initial levels
    this.nodes.bassGain.gain.value = 0;
    this.nodes.kickGain.gain.value = 0;
    this.nodes.textureGain.gain.value = 0;
    this.nodes.harmonyGain.gain.value = 0;
    this.nodes.sampleGain.gain.value = 0;
    
    // Connect voice chain
    [this.nodes.bassGain, this.nodes.kickGain, this.nodes.textureGain, 
     this.nodes.harmonyGain, this.nodes.sampleGain].forEach(node => {
      node.connect(this.nodes.warm);
      node.connect(this.nodes.space); // Send to reverb
      node.connect(this.nodes.delay); // Send to delay
    });
    
    // Master chain
    this.nodes.warm.connect(this.nodes.limiter);
    this.nodes.space.connect(this.nodes.spaceGain);
    this.nodes.spaceGain.connect(this.nodes.limiter);
    this.nodes.delayGain.connect(this.nodes.limiter);
    this.nodes.limiter.connect(this.master);
    this.master.connect(this.ctx.destination);
    
    // Analysis chain
    this.nodes.analyser = this.ctx.createAnalyser();
    this.nodes.analyser.fftSize = 2048;
    this.nodes.analyser.smoothingTimeConstant = 0.8;
    this.master.connect(this.nodes.analyser);
  }
  
  setupMicCapture(stream) {
    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
    
    // Pre-processing
    this.nodes.micGain = this.ctx.createGain();
    this.nodes.micGain.gain.value = 1;
    
    this.nodes.micFilter = this.ctx.createBiquadFilter();
    this.nodes.micFilter.type = 'highpass';
    this.nodes.micFilter.frequency.value = 80;
    
    // Analysis for auto-sampling
    this.nodes.micAnalyser = this.ctx.createAnalyser();
    this.nodes.micAnalyser.fftSize = 2048;
    
    // Recording processor
    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
    this.nodes.recorder.onaudioprocess = (e) => {
      if (this.isRecording) {
        const input = e.inputBuffer.getChannelData(0);
        this.recordBuffer.push(...input);
        
        // Auto-stop on silence or max length
        const rms = Math.sqrt(input.reduce((sum, x) => sum + x * x, 0) / input.length);
        if (rms < 0.01) {
          this.silenceDetector++;
          if (this.silenceDetector > 10) {
            this.stopRecording();
          }
        } else {
          this.silenceDetector = 0;
        }
        
        if (this.recordBuffer.length > this.sampleRate * 3) { // Max 3 seconds
          this.stopRecording();
        }
      }
    };
    
    // Connect mic chain
    this.nodes.mic.connect(this.nodes.micFilter);
    this.nodes.micFilter.connect(this.nodes.micGain);
    this.nodes.micGain.connect(this.nodes.micAnalyser);
    this.nodes.micGain.connect(this.nodes.recorder);
    this.nodes.recorder.connect(this.ctx.destination); // Required for ScriptProcessor
  }
  
  startAutoSampling() {
    setInterval(() => {
      if (this.conductor.sampleCooldown > 0) {
        this.conductor.sampleCooldown--;
        return;
      }
      
      // Analyze mic input
      const freqData = new Uint8Array(this.nodes.micAnalyser.frequencyBinCount);
      this.nodes.micAnalyser.getByteFrequencyData(freqData);
      
      // Calculate spectral features
      let energy = 0;
      let centroid = 0;
      let flux = 0;
      
      for (let i = 0; i < freqData.length; i++) {
        energy += freqData[i];
        centroid += i * freqData[i];
      }
      
      if (energy > 0) {
        centroid /= energy;
        energy /= freqData.length;
      }
      
      // Detect interesting sounds
      const isInteresting = energy > 50 && centroid > 100 && centroid < 800;
      
      if (isInteresting && !this.isRecording) {
        this.startRecording();
      }
    }, 100);
  }
  
  startRecording() {
    if (this.isRecording) return;
    
    this.isRecording = true;
    this.recordBuffer = [];
    this.silenceDetector = 0;
    this.conductor.sampleCooldown = 30; // 3 second cooldown
    
    console.log('📼 Sampling reality...');
  }
  
  stopRecording() {
    if (!this.isRecording) return;
    
    this.isRecording = false;
    
    if (this.recordBuffer.length > this.sampleRate * 0.1) { // Min 0.1 seconds
      this.processSample(this.recordBuffer);
    }
  }
  
  processSample(rawData) {
    // Create buffer
    const buffer = this.ctx.createBuffer(1, rawData.length, this.sampleRate);
    buffer.getChannelData(0).set(rawData);
    
    // Extract DNA (spectral features)
    const dna = this.extractDNA(rawData);
    
    // Find best loop points using onset detection
    const loopPoints = this.findLoopPoints(rawData);
    
    // Create sample object
    const sample = {
      buffer,
      dna,
      loopStart: loopPoints.start,
      loopEnd: loopPoints.end,
      pitch: dna.pitch || 1,
      energy: dna.energy,
      timestamp: Date.now()
    };
    
    // Add to bank
    this.samples.push(sample);
    if (this.samples.length > this.maxSamples) {
      this.samples.shift(); // Remove oldest
    }
    
    // Update global DNA
    this.updateGlobalDNA(dna);
    
    // Trigger evolution
    this.conductor.lastSample = Date.now();
    this.conductor.evolution += 0.1;
    
    console.log('🧬 DNA extracted:', dna);
  }
  
  extractDNA(data) {
    // Simple but effective spectral analysis
    const fftSize = 2048;
    const fft = new Float32Array(fftSize);
    
    // Poor man's FFT - just get rough spectral shape
    let energy = 0;
    let zeroCrossings = 0;
    let maxAmp = 0;
    
    for (let i = 0; i < data.length; i++) {
      energy += data[i] * data[i];
      maxAmp = Math.max(maxAmp, Math.abs(data[i]));
      if (i > 0 && data[i] * data[i-1] < 0) zeroCrossings++;
    }
    
    energy = Math.sqrt(energy / data.length);
    const pitch = (zeroCrossings / data.length) * this.sampleRate / 2;
    
    // Rhythm detection via onset strength
    const onsets = [];
    const windowSize = 512;
    for (let i = 0; i < data.length - windowSize; i += windowSize) {
      let windowEnergy = 0;
      for (let j = 0; j < windowSize; j++) {
        windowEnergy += data[i + j] * data[i + j];
      }
      onsets.push(Math.sqrt(windowEnergy / windowSize));
    }
    
    // Find peaks in onset function
    const rhythmPeaks = [];
    for (let i = 1; i < onsets.length - 1; i++) {
      if (onsets[i] > onsets[i-1] && onsets[i] > onsets[i+1] && onsets[i] > energy * 1.5) {
        rhythmPeaks.push(i * windowSize / this.sampleRate);
      }
    }
    
    return {
      energy,
      pitch: pitch / 440, // Relative to A440
      brightness: zeroCrossings / data.length,
      rhythm: rhythmPeaks,
      density: rhythmPeaks.length,
      chaos: maxAmp / energy
    };
  }
  
  findLoopPoints(data) {
    // Find zero crossings for clean loops
    const crossings = [];
    for (let i = 1; i < data.length - 1; i++) {
      if (data[i-1] <= 0 && data[i] > 0) {
        crossings.push(i);
      }
    }
    
    if (crossings.length < 2) {
      return { start: 0, end: data.length };
    }
    
    // Find best loop based on golden ratio
    const idealLength = data.length * 0.618;
    let bestStart = crossings[0];
    let bestEnd = crossings[crossings.length - 1];
    let bestDiff = Math.abs(bestEnd - bestStart - idealLength);
    
    for (let i = 0; i < crossings.length - 1; i++) {
      for (let j = i + 1; j < crossings.length; j++) {
        const length = crossings[j] - crossings[i];
        const diff = Math.abs(length - idealLength);
        if (diff < bestDiff) {
          bestDiff = diff;
          bestStart = crossings[i];
          bestEnd = crossings[j];
        }
      }
    }
    
    return { start: bestStart / this.sampleRate, end: bestEnd / this.sampleRate };
  }
  
  updateGlobalDNA(dna) {
    // Rolling average of DNA features
    this.dna.timbre.push(dna.brightness);
    this.dna.rhythm.push(dna.density);
    this.dna.harmony.push(dna.pitch);
    this.dna.dynamics.push(dna.energy);
    this.dna.memory.push(dna.chaos);
    
    // Keep history limited
    const maxHistory = 21; // Fibonacci
    Object.keys(this.dna).forEach(key => {
      if (this.dna[key].length > maxHistory) {
        this.dna[key].shift();
      }
    });
    
    // Update conductor based on DNA
    const avgEnergy = this.dna.dynamics.reduce((a,b) => a+b, 0) / this.dna.dynamics.length || 0;
    const avgDensity = this.dna.rhythm.reduce((a,b) => a+b, 0) / this.dna.rhythm.length || 0;
    
    this.conductor.energy = this.conductor.energy * 0.8 + avgEnergy * 0.2;
    this.conductor.tension = this.conductor.tension * 0.9 + avgDensity * 0.1;
    
    // Adapt BPM to rhythm density
    const targetBPM = 89 + avgDensity * 13; // Fibonacci scaling
    this.bpm = this.bpm * 0.95 + targetBPM * 0.05;
    this.bpm = Math.max(55, Math.min(144, this.bpm)); // Constrain to musical range
  }
  
  evolve() {
    // Evolution heartbeat
    setInterval(() => {
      // Smooth transitions
      Object.keys(this.voices).forEach(voice => {
        const v = this.voices[voice];
        if (v.amp !== undefined) {
          v.amp += (v.target - v.amp) * 0.1;
        }
      });
      
      // Update conductor state
      const timeSinceLastSample = Date.now() - this.conductor.lastSample;
      if (timeSinceLastSample > 10000) {
        this.conductor.memory *= 0.99; // Fade memory
      }
      
      // Determine evolution state
      if (this.samples.length === 0) {
        this.conductor.state = 'silence';
      } else if (this.samples.length < 3) {
        this.conductor.state = 'awakening';
      } else if (this.conductor.energy > 0.5) {
        this.conductor.state = 'dancing';
      } else if (this.conductor.tension > 0.5) {
        this.conductor.state = 'building';
      } else {
        this.conductor.state = 'dreaming';
      }
      
      // Activate voices based on state
      switch(this.conductor.state) {
        case 'silence':
          this.voices.bass.target = 0;
          this.voices.kick.target = 0;
          this.voices.texture.target = 0;
          this.voices.harmony.target = 0;
          this.voices.sample.target = 0;
          break;
          
        case 'awakening':
          this.voices.bass.target = 0.3;
          this.voices.kick.target = 0;
          this.voices.texture.target = 0.2;
          this.voices.harmony.target = 0;
          this.voices.sample.target = 0.5;
          break;
          
        case 'dancing':
          this.voices.bass.target = 0.7;
          this.voices.kick.target = 0.8;
          this.voices.texture.target = 0.3;
          this.voices.harmony.target = 0.4;
          this.voices.sample.target = 0.6;
          break;
          
        case 'building':
          this.voices.bass.target = 0.5;
          this.voices.kick.target = 0.5;
          this.voices.texture.target = 0.6;
          this.voices.harmony.target = 0.7;
          this.voices.sample.target = 0.4;
          break;
          
        case 'dreaming':
          this.voices.bass.target = 0.2;
          this.voices.kick.target = 0;
          this.voices.texture.target = 0.8;
          this.voices.harmony.target = 0.5;
          this.voices.sample.target = 0.3;
          break;
      }
      
      // Update UI
      this.elements.evolutionState.textContent = this.conductor.state;
      this.elements.evolutionState.classList.toggle('pulse', this.conductor.energy > 0.5);
      
    }, 100);
  }
  
  sequence() {
    const tick = () => {
      const beatTime = 60 / this.bpm;
      
      // Play voices
      if (this.voices.kick.amp > 0.1 && this.step % 4 === 0) {
        this.playKick();
      }
      
      if (this.voices.bass.amp > 0.1 && this.step % 2 === 0) {
        this.playBass();
      }
      
      if (this.voices.texture.amp > 0.1 && Math.random() < this.voices.texture.amp) {
        this.playTexture();
      }
      
      if (this.voices.harmony.amp > 0.1 && this.step % 8 === 0) {
        this.playHarmony();
      }
      
      // Sample playback
      if (this.voices.sample.amp > 0.1 && this.samples.length > 0) {
        if (!this.currentLoop || this.step % 16 === 0) {
          this.playSample();
        }
      }
      
      // Advance sequencer
      this.step = (this.step + 1) % 16;
      
      // Schedule next tick
      setTimeout(tick, beatTime * 250); // 16th notes
    };
    
    tick();
  }
  
  playKick() {
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    
    osc.frequency.setValueAtTime(55, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(27.5, this.ctx.currentTime + 0.1);
    
    env.gain.setValueAtTime(this.voices.kick.amp, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
    
    osc.connect(env);
    env.connect(this.nodes.kickGain);
    
    osc.start();
    osc.stop(this.ctx.currentTime + 0.5);
  }
  
  playBass() {
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    // Use scale
    const note = this.scale[this.step % this.scale.length];
    const freq = this.root * Math.pow(2, note / 12);
    
    osc.type = 'sawtooth';
    osc.frequency.value = freq;
    
    filter.type = 'lowpass';
    filter.frequency.value = 200 + this.conductor.energy * 300;
    filter.Q.value = 5;
    
    env.gain.setValueAtTime(this.voices.bass.amp * 0.5, this.ctx.currentTime);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    
    osc.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.bassGain);
    
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
  }
  
  playTexture() {
    // Granular texture from mic input
    const grainDuration = 0.05 + Math.random() * 0.1;
    const osc = this.ctx.createOscillator();
    const env = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    osc.type = 'triangle';
    osc.frequency.value = 200 + Math.random() * 800;
    
    filter.type = 'bandpass';
    filter.frequency.value = 1000 + Math.random() * 2000;
    filter.Q.value = 10;
    
    env.gain.setValueAtTime(0, this.ctx.currentTime);
    env.gain.linearRampToValueAtTime(this.voices.texture.amp * 0.2, this.ctx.currentTime + grainDuration * 0.3);
    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + grainDuration);
    
    osc.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.textureGain);
    
    osc.start();
    osc.stop(this.ctx.currentTime + grainDuration);
  }
  
  playHarmony() {
    // Adaptive harmony based on DNA
    const chordSize = Math.floor(2 + this.conductor.tension * 3);
    
    for (let i = 0; i < chordSize; i++) {
      const osc = this.ctx.createOscillator();
      const env = this.ctx.createGain();
      const filter = this.ctx.createBiquadFilter();
      
      const note = this.scale[(this.step + i * 2) % this.scale.length];
      const freq = this.root * Math.pow(2, (note + 24) / 12); // Two octaves up
      
      osc.type = 'sine';
      osc.frequency.value = freq;
      
      filter.type = 'lowpass';
      filter.frequency.value = 1000;
      
      env.gain.setValueAtTime(0, this.ctx.currentTime);
      env.gain.linearRampToValueAtTime(this.voices.harmony.amp * 0.1, this.ctx.currentTime + 0.5);
      env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
      
      osc.connect(filter);
      filter.connect(env);
      env.connect(this.nodes.harmonyGain);
      
      osc.start();
      osc.stop(this.ctx.currentTime + 2);
    }
  }
  
  playSample() {
    if (this.samples.length === 0) return;
    
    // Stop current loop if playing
    if (this.currentLoop) {
      this.currentLoop.stop();
    }
    
    // Choose sample based on conductor state
    let sample;
    if (this.conductor.state === 'dancing') {
      // Choose high energy sample
      sample = this.samples.reduce((a, b) => a.energy > b.energy ? a : b);
    } else {
      // Choose most recent
      sample = this.samples[this.samples.length - 1];
    }
    
    const source = this.ctx.createBufferSource();
    const env = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    source.buffer = sample.buffer;
    source.loop = true;
    source.loopStart = sample.loopStart;
    source.loopEnd = sample.loopEnd;
    source.playbackRate.value = sample.pitch;
    
    filter.type = 'lowpass';
    filter.frequency.value = 2000 + this.conductor.energy * 3000;
    
    env.gain.value = this.voices.sample.amp * 0.7;
    
    source.connect(filter);
    filter.connect(env);
    env.connect(this.nodes.sampleGain);
    
    source.start(0, sample.loopStart);
    this.currentLoop = source;
    
    // Auto-stop after loop iterations
    setTimeout(() => {
      if (this.currentLoop === source) {
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        setTimeout(() => source.stop(), 1000);
      }
    }, (sample.loopEnd - sample.loopStart) * 8000 / sample.pitch);
  }
  
  createWarmthCurve(amount) {
    const samples = 44100;
    const curve = new Float32Array(samples);
    
    for (let i = 0; i < samples; i++) {
      const x = (i * 2) / samples - 1;
      curve[i] = Math.tanh(x * amount) * 0.95;
    }
    
    return curve;
  }
  
  createSpaceImpulse(seconds) {
    const length = this.sampleRate * seconds;
    const buffer = this.ctx.createBuffer(2, length, this.sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const data = buffer.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        const decay = Math.pow(1 - i / length, 2);
        data[i] = (Math.random() * 2 - 1) * decay * 0.5;
        
        // Early reflections
        if (i < length * 0.1) {
          if (i % Math.floor(length * 0.01) === 0) {
            data[i] += (Math.random() * 2 - 1) * 0.3 * decay;
          }
        }
      }
    }
    
    return buffer;
  }
  
  render() {
    const loop = () => {
      // Update gain nodes smoothly
      this.nodes.bassGain.gain.linearRampToValueAtTime(
        this.voices.bass.amp, 
        this.ctx.currentTime + 0.05
      );
      this.nodes.kickGain.gain.linearRampToValueAtTime(
        this.voices.kick.amp,
        this.ctx.currentTime + 0.05
      );
      this.nodes.textureGain.gain.linearRampToValueAtTime(
        this.voices.texture.amp,
        this.ctx.currentTime + 0.05
      );
      this.nodes.harmonyGain.gain.linearRampToValueAtTime(
        this.voices.harmony.amp,
        this.ctx.currentTime + 0.05
      );
      this.nodes.sampleGain.gain.linearRampToValueAtTime(
        this.voices.sample.amp,
        this.ctx.currentTime + 0.05
      );
      
      // Update delay time to stay synced
      const targetDelay = 60 / this.bpm / 8;
      if (Math.abs(this.nodes.delay.delayTime.value - targetDelay) > 0.01) {
        this.nodes.delay.delayTime.linearRampToValueAtTime(
          targetDelay,
          this.ctx.currentTime + 0.1
        );
      }
      
      // Visual DNA update
      const nodes = this.elements.dnaHelix.children;
      for (let i = 0; i < nodes.length; i++) {
        const node = nodes[i];
        const scale = 1 + this.conductor.energy * 0.5 * Math.sin(Date.now() / 1000 + i * 0.3);
        const brightness = 0.3 + this.conductor.tension * 0.7;
        node.style.transform = `scale(${scale})`;
        node.style.opacity = brightness;
      }
      
      // Create frequency blooms on beats
      if (this.step % 4 === 0 && this.conductor.energy > 0.3) {
        this.createFreqBloom();
      }
      
      requestAnimationFrame(loop);
    };
    
    requestAnimationFrame(loop);
  }
  
  createFreqBloom() {
    const bloom = document.createElement('div');
    bloom.className = 'freq-bloom';
    bloom.style.left = `${38.2 + Math.random() * 23.6}%`; // Golden ratio positioning
    bloom.style.top = `${38.2 + Math.random() * 23.6}%`;
    document.body.appendChild(bloom);
    
    setTimeout(() => bloom.classList.add('active'), 10);
    setTimeout(() => bloom.remove(), 3000);
  }
}

// Initialize
new AliveDJ();
</script>
</body>
</html>
