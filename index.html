<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<title>NEURAL // SEQUENCER</title>
<style>
  :root {
    --bg: #080808;
    --grid: #1a1a1a;
    --neon: #00f3ff;
    --warn: #ff0055;
  }
  
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }
  
  body {
    background: var(--bg);
    color: #fff;
    font-family: 'Courier New', monospace;
    overflow: hidden;
    height: 100vh;
    width: 100vw;
  }

  /* Scanline Overlay */
  body::before {
    content: "";
    position: absolute;
    inset: 0;
    background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%);
    background-size: 100% 4px;
    pointer-events: none;
    z-index: 100;
  }

  .start-overlay {
    position: absolute;
    inset: 0;
    background: var(--bg);
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    z-index: 200;
    transition: opacity 0.5s;
  }
  
  .start-overlay.hidden { opacity: 0; pointer-events: none; }

  .glitch-text {
    font-size: 20px;
    letter-spacing: 4px;
    margin-bottom: 40px;
    text-shadow: 0 0 10px var(--neon);
    animation: glitch 2s infinite;
  }

  .btn-start {
    border: 1px solid var(--neon);
    background: rgba(0, 243, 255, 0.1);
    color: var(--neon);
    padding: 20px 60px;
    font-family: inherit;
    font-size: 14px;
    letter-spacing: 2px;
    cursor: pointer;
    box-shadow: 0 0 15px rgba(0, 243, 255, 0.2);
  }

  /* Heads Up Display */
  .hud {
    position: absolute;
    padding: 20px;
    width: 100%;
    display: flex;
    justify-content: space-between;
    font-size: 10px;
    letter-spacing: 1px;
    z-index: 10;
    color: rgba(255,255,255,0.6);
  }

  .val { color: var(--neon); font-weight: bold; }
  .rec-active .val { color: var(--warn); }

  /* Center Visuals */
  .viewport {
    position: absolute;
    inset: 0;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  canvas {
    width: 100%;
    height: 100%;
  }
  
  .hint {
    position: absolute;
    bottom: 30px;
    width: 100%;
    text-align: center;
    font-size: 10px;
    color: rgba(255,255,255,0.4);
    letter-spacing: 2px;
  }

  @keyframes glitch {
    0% { transform: translate(0); }
    20% { transform: translate(-2px, 2px); }
    40% { transform: translate(-2px, -2px); }
    60% { transform: translate(2px, 2px); }
    80% { transform: translate(2px, -2px); }
    100% { transform: translate(0); }
  }
</style>
</head>
<body>

<div class="start-overlay" id="overlay">
  <div class="glitch-text">SYSTEM // OFFLINE</div>
  <button class="btn-start" id="initBtn">INITIALIZE ENGINE</button>
</div>

<div class="hud">
  <div>
    <div>GRID: <span class="val" id="gridStatus">LOCKED</span></div>
    <div>FILTER: <span class="val" id="filterVal">OPEN</span></div>
  </div>
  <div style="text-align: right;">
    <div>BPM: <span class="val">128</span></div>
    <div>SWING: <span class="val" id="swingVal">0%</span></div>
  </div>
</div>

<div class="viewport">
  <canvas id="scope"></canvas>
</div>

<div class="hint">TAP SCREEN TO CAPTURE â€¢ HOLD STILL TO QUANTIZE</div>

<script>
'use strict';

/* --- THE AUDIO BRAIN --- */
class NeuralSampler {
  constructor() {
    this.ctx = null;
    this.input = null;
    this.recorder = null;
    this.masterGain = null;
    this.filter = null;
    this.delay = null;
    
    // State
    this.isRecording = false;
    this.buffer = [];
    this.slices = []; // Array of {time, amp}
    this.audioBuffer = null;
    
    // Sequencer
    this.isPlaying = false;
    this.step = 0;
    this.nextNoteTime = 0;
    this.tempo = 128;
    this.lookahead = 25.0;
    this.scheduleAheadTime = 0.1;
    
    // Motion Physics
    this.tiltX = 0; // Filter Cutoff
    this.tiltY = 0; // Swing / Chaos
    this.motion = 0; 
    
    // Visuals
    this.canvas = document.getElementById('scope');
    this.drawCtx = this.canvas.getContext('2d');
    this.analyser = null;
    this.dataArray = null;
    
    this.bindEvents();
  }

  async init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    await this.ctx.resume();
    
    // Input Chain
    const stream = await navigator.mediaDevices.getUserMedia({ 
      audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } 
    });
    this.input = this.ctx.createMediaStreamSource(stream);
    
    // Output Chain (The "Future" Sound)
    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.8;
    
    // Lowpass Filter (Controlled by Tilt)
    this.filter = this.ctx.createBiquadFilter();
    this.filter.type = 'lowpass';
    this.filter.frequency.value = 20000;
    this.filter.Q.value = 2; // Resonant peak
    
    // Stereo Delay (Space)
    this.delay = this.ctx.createDelay();
    this.delay.delayTime.value = 0.25; // 1/8th note approx
    const delayFeedback = this.ctx.createGain();
    delayFeedback.gain.value = 0.3;
    
    this.delay.connect(delayFeedback);
    delayFeedback.connect(this.delay);
    
    // Connections
    this.filter.connect(this.masterGain);
    this.filter.connect(this.delay); // Send to delay
    this.delay.connect(this.masterGain); // Return delay
    this.masterGain.connect(this.ctx.destination);
    
    // Analyzer
    this.analyser = this.ctx.createAnalyser();
    this.analyser.fftSize = 1024;
    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
    this.masterGain.connect(this.analyser);
    
    // Recorder
    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
    this.input.connect(this.recorder);
    this.recorder.connect(this.ctx.destination);
    
    this.recorder.onaudioprocess = (e) => {
      if (!this.isRecording) return;
      this.buffer.push(new Float32Array(e.inputBuffer.getChannelData(0)));
    };

    // Start Engine
    document.getElementById('overlay').classList.add('hidden');
    this.resizeCanvas();
    this.drawLoop();
    this.scheduler();
    
    // Initial capture prompt
    setTimeout(() => this.startRecording(), 500);
  }

  bindEvents() {
    document.getElementById('initBtn').onclick = () => this.init();
    
    window.addEventListener('resize', () => this.resizeCanvas());
    
    // Capture Trigger
    document.addEventListener('touchstart', (e) => {
      if (e.target.tagName !== 'BUTTON') this.startRecording();
    });
    document.addEventListener('touchend', () => {
      if (this.isRecording) this.stopRecording();
    });
    
    // Motion
    window.addEventListener('deviceorientation', (e) => {
      // Beta (Front/Back) -> Filter (-90 to 90)
      let beta = e.beta || 0;
      // Gamma (Left/Right) -> Swing/Chaos (-90 to 90)
      let gamma = e.gamma || 0;
      
      this.tiltX = (beta + 90) / 180; // 0 to 1
      this.tiltY = Math.abs(gamma) / 90; // 0 to 1
      
      this.updateEffects();
    });
  }

  updateEffects() {
    if (!this.filter) return;
    
    // Filter Physics: Tilt forward to open, back to muffle
    // Mapping 0-1 to 100Hz - 15000Hz exponentially
    const freq = 100 * Math.pow(100, this.tiltX);
    this.filter.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.1);
    
    // UI Updates
    document.getElementById('filterVal').textContent = freq > 10000 ? 'OPEN' : freq < 500 ? 'SUB' : 'MID';
    document.getElementById('swingVal').textContent = (this.tiltY * 100).toFixed(0) + '%';
    document.getElementById('gridStatus').textContent = this.tiltY < 0.1 ? 'LOCKED' : 'DRIFTING';
  }

  startRecording() {
    this.isRecording = true;
    this.buffer = [];
    document.body.classList.add('rec-active');
    document.getElementById('gridStatus').textContent = "SAMPLING...";
  }

  stopRecording() {
    this.isRecording = false;
    document.body.classList.remove('rec-active');
    this.processAudio();
  }

  processAudio() {
    if (this.buffer.length === 0) return;

    // 1. Flatten Buffer
    const length = this.buffer.length * 4096;
    const rawData = this.ctx.createBuffer(1, length, this.ctx.sampleRate);
    const data = rawData.getChannelData(0);
    let offset = 0;
    for (let chunk of this.buffer) {
      data.set(chunk, offset);
      offset += chunk.length;
    }
    this.audioBuffer = rawData;

    // 2. Intelligent Slicing (The "Future" bit)
    // We scan for peaks and store them with their Amplitude
    this.slices = [];
    const threshold = 0.05;
    const minDist = 0.1; // Minimum silence between hits (sec)
    let lastTime = -1;

    for (let i = 0; i < length; i += 200) {
      const t = i / this.ctx.sampleRate;
      const amp = Math.abs(data[i]);
      
      if (amp > threshold && (t - lastTime > minDist)) {
        this.slices.push({ time: t, amp: amp });
        lastTime = t;
      }
    }

    // 3. Fallback if quiet
    if (this.slices.length < 4) {
      this.slices = [];
      for(let i=0; i<8; i++) this.slices.push({ time: (i*0.25), amp: 0.5 });
    }

    // 4. SORT BY LOUDNESS
    // This allows us to put the "Kick" (loudest) on beat 1
    this.slices.sort((a, b) => b.amp - a.amp);
    
    this.isPlaying = true;
  }

  /* --- SEQUENCER ENGINE --- */
  
  scheduler() {
    if (this.isPlaying) {
      while (this.nextNoteTime < this.ctx.currentTime + this.scheduleAheadTime) {
        this.scheduleNote(this.step, this.nextNoteTime);
        this.nextStep();
      }
    }
    setTimeout(() => this.scheduler(), this.lookahead);
  }

  nextStep() {
    const secondsPerBeat = 60.0 / this.tempo;
    this.nextNoteTime += 0.25 * secondsPerBeat; // 16th notes
    this.step = (this.step + 1) % 16;
  }

  scheduleNote(beatNumber, time) {
    if (!this.audioBuffer || this.slices.length === 0) return;

    // CHAOS CALCULATION
    // If tiltY (side to side) is high, we introduce timing drift (swing)
    // If tiltY is 0, we are perfectly quantized
    const chaos = this.tiltY; 
    const swingOffset = chaos * (Math.random() * 0.05); 
    const finalTime = time + swingOffset;

    const source = this.ctx.createBufferSource();
    source.buffer = this.audioBuffer;
    
    // INTELLIGENT MAPPING
    // We map specific sorted slices to rhythm positions
    // 0 = Loudest (Kick), End = Quietest (HiHat)
    let sliceIndex = 0;

    // A Standard Techno/House Grid Pattern
    // Beats 0, 4, 8, 12 = Kick (Loudest slice)
    // Beats 2, 6, 10, 14 = Snare (2nd Loudest)
    // Others = Random quiet texture
    
    if (beatNumber % 4 === 0) {
      sliceIndex = 0; // The Big Hit
    } else if (beatNumber % 4 === 2) {
      sliceIndex = 1 % this.slices.length; // The Snare
    } else {
      // Random texture from the quiet tail of sounds
      sliceIndex = 2 + Math.floor(Math.random() * (this.slices.length - 2));
      if (sliceIndex >= this.slices.length) sliceIndex = 0;
    }
    
    // If Chaos is high, randomize the slice selection entirely
    if (Math.random() < chaos * 0.5) {
      sliceIndex = Math.floor(Math.random() * this.slices.length);
    }

    const slice = this.slices[sliceIndex];
    const duration = 0.2; // Short grains for tight beat

    // Envelope
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, finalTime);
    gain.gain.linearRampToValueAtTime(1.0, finalTime + 0.005);
    gain.gain.exponentialRampToValueAtTime(0.01, finalTime + duration);

    source.connect(gain);
    gain.connect(this.filter);

    source.start(finalTime, slice.time, duration);
    
    // Trigger Visual
    this.drawCtx.fillStyle = beatNumber % 4 === 0 ? '#00f3ff' : '#333';
  }

  /* --- VISUALS --- */
  resizeCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }

  drawLoop() {
    requestAnimationFrame(() => this.drawLoop());
    const w = this.canvas.width;
    const h = this.canvas.height;
    
    // Fade effect
    this.drawCtx.fillStyle = 'rgba(8, 8, 8, 0.2)';
    this.drawCtx.fillRect(0, 0, w, h);
    
    if (!this.analyser) return;
    this.analyser.getByteTimeDomainData(this.dataArray);
    
    this.drawCtx.lineWidth = 2;
    this.drawCtx.strokeStyle = this.isRecording ? '#ff0055' : '#00f3ff';
    this.drawCtx.beginPath();
    
    const sliceWidth = w * 1.0 / this.dataArray.length;
    let x = 0;
    
    // Circular Scope logic
    const cx = w/2;
    const cy = h/2;
    const radius = Math.min(w,h) * 0.3;
    
    for (let i = 0; i < this.dataArray.length; i++) {
      const v = this.dataArray[i] / 128.0;
      const r = radius * v + (this.tiltY * 50); // Radius expands with chaos
      
      const angle = (i / this.dataArray.length) * Math.PI * 2 + (Date.now() / 1000);
      
      const px = cx + Math.cos(angle) * r;
      const py = cy + Math.sin(angle) * r;
      
      if (i === 0) this.drawCtx.moveTo(px, py);
      else this.drawCtx.lineTo(px, py);
    }
    
    this.drawCtx.closePath();
    this.drawCtx.stroke();
    
    // Draw Grid Lines based on Tilt
    if (this.tiltY < 0.1) {
       this.drawCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
       this.drawCtx.beginPath();
       this.drawCtx.moveTo(cx - 50, cy);
       this.drawCtx.lineTo(cx + 50, cy);
       this.drawCtx.moveTo(cx, cy - 50);
       this.drawCtx.lineTo(cx, cy + 50);
       this.drawCtx.stroke();
    }
  }
}

const sampler = new NeuralSampler();

</script>
</body>
</html>
