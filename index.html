<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Grand Unified Music Project</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 40% 60%, #0a0a1a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
    }
    
    body.transcendent {
      background: radial-gradient(circle at 60% 40%, #080012 0%, #1a0a2e 25%, #2a1a3e 50%, #3a2a4e 75%, #1a0a2e 100%);
      color: #ff88cc;
      filter: blur(0.5px) brightness(1.2);
    }
    
    .app {
      width: 100%;
      max-width: 450px;
      padding: 25px;
      text-align: center;
      backdrop-filter: blur(5px) saturate(180%);
      border-radius: 20px;
      background: rgba(10, 10, 20, 0.1);
    }
    
    .logo {
      font-size: clamp(3.5rem, 14vw, 7rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.7rem;
      animation: pulse 3s ease-in-out infinite;
    }
    
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.08); } }
    
    .tagline { font-size: clamp(1.2rem, 5vw, 1.5rem); opacity: 0.85; margin-bottom: 1rem; font-weight: 300; }
    
    .controls { margin-bottom: 2rem; display: flex; flex-direction: column; gap: 10px; }
    .controls button {
      padding: 12px 25px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 25px;
      font-size: 1rem;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.4s ease;
    }
    .controls button:hover { transform: translateY(-2px); box-shadow: 0 8px 20px rgba(0, 255, 170, 0.5); }
    .controls input, .controls select {
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 170, 0.3);
      background: rgba(0, 255, 170, 0.1);
      color: #00ffaa;
      font-size: 1rem;
    }
    
    .start-btn {
      padding: 22px 45px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 35px;
      font-size: 1.3rem;
      font-weight: 800;
      cursor: pointer;
      transition: all 0.4s ease;
      box-shadow: 0 12px 35px rgba(0, 255, 170, 0.4);
      margin-bottom: 2.5rem;
    }
    
    .start-btn:hover { transform: translateY(-4px); box-shadow: 0 18px 50px rgba(0, 255, 170, 0.6); }
    
    .spatial-viz {
      width: 100%;
      height: 220px;
      border: 3px solid rgba(0, 255, 170, 0.3);
      border-radius: 25px;
      position: relative;
      overflow: hidden;
      background: radial-gradient(circle, rgba(0, 255, 170, 0.05) 0%, rgba(0, 20, 40, 0.05) 100%);
      margin-bottom: 2.5rem;
      transition: all 1s ease;
    }
    
    .spatial-viz.transcendent { border-color: rgba(255, 136, 204, 0.5); background: rgba(255, 136, 204, 0.08); }
    
    .orb {
      position: absolute;
      width: 70px;
      height: 70px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffaa, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.25s ease;
      box-shadow: 0 0 40px rgba(0, 255, 170, 0.6);
      will-change: transform;
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #ff88cc, transparent);
      box-shadow: 0 0 80px rgba(255, 136, 204, 0.8);
      animation: voidPulse 2s ease-in-out infinite;
    }
    
    @keyframes voidPulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.15); } }
    
    .ripple {
      position: absolute;
      width: 20px;
      height: 20px;
      background: radial-gradient(circle, rgba(0, 255, 170, 0.5), transparent);
      border-radius: 50%;
      animation: ripple 1s ease-out;
      transform: translate(-50%, -50%);
    }
    
    @keyframes ripple {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
      100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
    }
    
    .stats { display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; margin-bottom: 2.5rem; }
    .stat { background: rgba(0, 255, 170, 0.15); padding: 15px; border-radius: 15px; border: 2px solid rgba(0, 255, 170, 0.3); }
    .stat-value { font-size: 1.4rem; font-weight: 800; color: #00ffaa; }
    .stat-label { font-size: 0.8rem; opacity: 0.75; margin-top: 4px; }
    
    .status { font-size: 1rem; color: #4ecdc4; opacity: 0.85; animation: statusBreathe 2.5s ease-in-out infinite; }
    @keyframes statusBreathe { 0%, 100% { opacity: 0.85; } 50% { opacity: 1.1; } }
    
    .particles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; opacity: 0; transition: opacity 0.5s ease; }
    .particles.active { opacity: 0.7; }
    .particle { position: absolute; width: 4px; height: 4px; background: radial-gradient(circle, #ff88cc, transparent); border-radius: 50%; animation: float 7s linear infinite; }
    @keyframes float { 0% { transform: translateY(110vh) scale(0); opacity: 0; } 10% { opacity: 0.8; } 90% { opacity: 0.8; } 100% { transform: translateY(-30vh) scale(1.5); opacity: 0; } }
    
    .hidden { display: none !important; }
    .error { background: rgba(255, 107, 107, 0.15); border: 2px solid rgba(255, 107, 107, 0.4); border-radius: 20px; padding: 25px; color: #ff6b6b; margin-top: 25px; }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  
  <div class="app">
    <div class="logo" id="logo">GUMP</div>
    <div class="tagline" id="tagline">Grand Unified Music Project</div>
    <button class="start-btn" id="start">ðŸŽµ Start Spatial Audio</button>
    <div class="controls hidden" id="controls">
      <button id="pause">Pause</button>
      <input type="range" id="bpm-slider" min="60" max="180" value="95">
      <select id="scale-select">
        <option value="major">Major</option>
        <option value="minor">Minor</option>
        <option value="pentatonic">Pentatonic</option>
      </select>
    </div>
    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>
    <div class="stats hidden" id="stats">
      <div class="stat"><div class="stat-value" id="motion">0</div><div class="stat-label">Motion</div></div>
      <div class="stat"><div class="stat-value" id="bpm">95</div><div class="stat-label">BPM</div></div>
      <div class="stat"><div class="stat-value" id="groove">CHILL</div><div class="stat-label">State</div></div>
    </div>
    <div class="status hidden" id="status">ðŸŽµ Flowing with your vibe...</div>
    <div class="error hidden" id="error"></div>
  </div>

  <script>
    class SpatialAI {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 95;
        this.pos = { x: 50, y: 50 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.state = 'CHILL';
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.reverb = null;
        this.songSection = 'INTRO';
        this.layerProgress = 0;
        this.lastStrideTime = 0;
        this.strideInterval = 600;
        this.envDensity = 0;
        this.location = { lat: 0, lon: 0, accuracy: 0 };
        this.distanceTraveled = 0;
        this.lastLocation = null;
        this.oscillatorPool = [];
        this.oscillators = new Set();
        this.lastUpdateTime = 0;
        this.frameCount = 0;
        this.moodFactor = 0;
        this.weather = 'CLEAR';
        this.weatherData = null;
        this.seed = 0;
        this.currentChord = 0;
        this.analyser = null;
        
        this.scales = {
          major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
          minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25],
          pentatonic: [261.63, 311.13, 349.23, 415.30, 466.16]
        };
        this.scale = this.scales.major;
        this.chords = [];
        this.patterns = { kick: [], snare: [], hihat: [], bass: [] };
        
        this.elements = {};
        this.rolloutBuffer = [];
        this.lastReflectionTime = 0;
        this.reflectionInterval = 30000;
        
        this.init();
      }

      init() {
        const ids = ['start', 'viz', 'stats', 'status', 'logo', 'tagline', 'orb', 'motion', 'bpm', 'groove', 'error', 'particles', 'controls', 'pause', 'bpm-slider', 'scale-select'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.start.onclick = () => this.start();
        this.initControls();
        
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            pos => {
              this.location = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
                accuracy: pos.coords.accuracy
              };
              this.fetchWeather();
            },
            err => this.showError('Geolocation error: ' + err.message),
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 5000 }
          );
          navigator.geolocation.watchPosition(
            pos => this.updateLocation(pos),
            err => this.showError('Geolocation error: ' + err.message),
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 5000 }
          );
        }
      }

      initControls() {
        this.elements.pause.onclick = () => {
          this.active = !this.active;
          if (!this.active) this.ctx.suspend();
          else this.ctx.resume();
          this.elements.pause.textContent = this.active ? 'Pause' : 'Resume';
        };

        this.elements.bpmSlider.oninput = (e) => {
          this.bpm = parseInt(e.target.value);
        };

        this.elements.scaleSelect.onchange = (e) => {
          this.scale = this.scales[e.target.value];
          this.chords = this.generateChords();
        };
      }

      initOscillatorPool() {
        for (let i = 0; i < 10; i++) {
          const osc = this.ctx.createOscillator();
          osc.type = 'sine';
          osc.connect(this.reverb);
          this.oscillatorPool.push({ osc, inUse: false });
        }
      }

      getOscillator(type, frequency) {
        const oscData = this.oscillatorPool.find(o => !o.inUse);
        if (!oscData) return null;
        oscData.inUse = true;
        oscData.osc.type = type;
        oscData.osc.frequency.setValueAtTime(frequency, this.ctx.currentTime);
        return oscData;
      }

      releaseOscillator(oscData) {
        oscData.inUse = false;
        try {
          oscData.osc.stop(this.ctx.currentTime);
        } catch (e) {}
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') {
              this.showError('Motion permission denied.');
              return;
            }
          }

          await this.fetchWeather();
          this.generateSongSeed();
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();
          this.initOscillatorPool();
          this.startMicInput();

          this.elements.start.classList.add('hidden');
          ['viz', 'stats', 'status', 'controls'].forEach(id => this.elements[id].classList.remove('hidden'));
          
          this.active = true;
          this.lastMotionTime = Date.now();
          this.startSensors();
          this.startGroove();
          this.animate();
          this.monitorTranscendence();
          console.log(`GUMP started at ${new Date().toLocaleString()}. Weather: ${this.weather}, Mood: ${this.moodFactor.toFixed(2)}`);
        } catch (e) {
          this.showError('Failed to start: ' + e.message);
          console.error(e);
        }
      }

      async startMicInput() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          const source = this.ctx.createMediaStreamSource(stream);
          this.analyser = this.ctx.createAnalyser();
          this.analyser.fftSize = 512;
          source.connect(this.analyser);
          
          const buffer = new Float32Array(this.analyser.frequencyBinCount);
          const checkMic = () => {
            if (!this.active) return;
            this.analyser.getFloatTimeDomainData(buffer);
            const peak = Math.max(...buffer);
            if (peak > 0.1) {
              this.triggerInstantSound('kick808');
              this.createRipple();
            }
            requestAnimationFrame(checkMic);
          };
          checkMic();
        } catch (e) {
          this.showError('Microphone access denied: ' + e.message);
        }
      }

      createRipple() {
        const ripple = document.createElement('div');
        ripple.className = 'ripple';
        ripple.style.left = `${this.pos.x}%`;
        ripple.style.top = `${this.pos.y}%`;
        this.elements.viz.appendChild(ripple);
        setTimeout(() => ripple.remove(), 1000);
      }

      triggerInstantSound(soundType) {
        if (soundType === 'kick808') this.kick808();
        else if (soundType === 'snare') this.snareLayered();
        else if (soundType === 'hihat') this.hihatMetallic();
      }

      async fetchWeather() {
        if (!this.location.lat || !this.location.lon) return;
        try {
          const apiKey = '789e7d7e2ab3c81f42ca93d449c715c6';
          const url = `https://api.openweathermap.org/data/2.5/weather?lat=${this.location.lat}&lon=${this.location.lon}&appid=${apiKey}`;
          const response = await fetch(url);
          if (!response.ok) throw new Error('Failed to fetch weather data');
          this.weatherData = await response.json();
          this.weather = this.weatherData.weather[0].main.toUpperCase();
          this.envDensity = this.calculateEnvDensityFromWeather();
        } catch (e) {
          this.weather = 'CLEAR';
          this.envDensity = 0.5;
          this.showError('Weather API error: Using default weather settings');
          console.error(e);
        }
      }

      calculateEnvDensityFromWeather() {
        if (!this.weatherData) return 0.5;
        const condition = this.weather.toUpperCase();
        const temp = (this.weatherData.main.temp - 273.15) / 40;
        let density = 0.5;
        
        if (condition.includes('RAIN') || condition.includes('STORM')) density = 0.8 + temp * 0.2;
        else if (condition.includes('CLOUD')) density = 0.5 + temp * 0.2;
        else if (condition.includes('CLEAR')) density = 0.3 + temp * 0.2;
        else if (condition.includes('SNOW')) density = 0.7 + temp * 0.2;
        
        return Math.min(1, Math.max(0, density));
      }

      generateSongSeed() {
        const now = new Date();
        const hours = now.getHours();
        const lat = this.location.lat || 0;
        const lon = this.location.lon || 0;
        this.seed = (hours * 3600 + now.getMinutes() * 60 + now.getSeconds()) + Math.abs(lat * lon);
        
        this.moodFactor = hours < 6 || hours > 20 ? 0.3 : hours < 12 ? 0.7 : 1.0;
        if (this.weather.includes('RAIN') || this.weather.includes('STORM')) this.moodFactor *= 0.8;
        else if (this.weather.includes('CLEAR')) this.moodFactor *= 1.2;
        else if (this.weather.includes('CLOUD')) this.moodFactor *= 0.9;
        
        const scaleChoice = Math.floor(this.seed + this.moodFactor * 10) % 3;
        this.scale = scaleChoice === 0 ? this.scales.major : scaleChoice === 1 ? this.scales.minor : this.scales.pentatonic;
        
        this.chords = this.generateChords();
        this.patterns = this.generatePatterns();
        this.bpm = 80 + (this.moodFactor * 40) + (this.seed % 20);
      }

      generateChords() {
        const chords = [];
        const chordCount = 4 + Math.floor((this.seed + this.moodFactor * 10) % 4);
        for (let i = 0; i < chordCount; i++) {
          const root = Math.floor((this.seed + i * 17 + this.moodFactor * 5) % this.scale.length);
          const chord = [root, (root + 2) % this.scale.length, (root + 4) % this.scale.length, (root + 6) % this.scale.length];
          chords.push(chord);
        }
        return chords;
      }

      generatePatterns() {
        const length = 16;
        const patterns = { kick: [], snare: [], hihat: [], bass: [] };
        
        const kickDensity = this.moodFactor * 0.5 + this.envDensity * 0.3;
        const snareDensity = this.moodFactor * 0.4 + this.envDensity * 0.2;
        const hihatDensity = this.moodFactor * 0.6 + this.envDensity * 0.4;
        const bassDensity = this.moodFactor * 0.5 + this.envDensity * 0.3;
        
        for (let i = 0; i < length; i++) {
          patterns.kick.push(Math.random() < kickDensity ? 1 : 0);
          patterns.snare.push(Math.random() < snareDensity ? 1 : 0);
          patterns.hihat.push(Math.random() < hihatDensity ? 1 : 0);
          patterns.bass.push(Math.random() < bassDensity ? 1 : 0);
          
          if (i % 4 === 0) patterns.kick[i] = 1;
          if (i % 8 === 4) patterns.snare[i] = 1;
          if (i % 2 === 0) patterns.hihat[i] = Math.random() < hihatDensity * 1.2 ? 1 : 0;
        }
        
        return patterns;
      }

      startSensors() {
        let lastSensorTime = 0;
        const sensorThrottle = 16;
        const motionSmoothing = 3;
        let motionBuffer = [];
        const motionThreshold = 10;
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - lastSensorTime < sensorThrottle) return;
          lastSensorTime = now;

          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);
          const motionSpike = dx + dy + dz;

          if (motionSpike > motionThreshold) {
            this.triggerInstantSound('kick808');
            this.createRipple();
          }

          motionBuffer.push(Math.min(100, Math.sqrt(dx * dx + dy * dy + dz * dz) * 8));
          if (motionBuffer.length > motionSmoothing) motionBuffer.shift();
          this.motion = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length * 0.5;

          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.rolloutBuffer.push(this.motion);
          if (this.rolloutBuffer.length > 600) this.rolloutBuffer.shift();

          if (this.motion > 5) {
            this.lastMotionTime = now;
          }

          if (this.motion > 5 && now - this.lastStrideTime > this.strideInterval) {
            this.lastStrideTime = now;
            this.updateSongProgress();
            this.updateEnvDensity();
          }

          this.pos.x = Math.max(5, Math.min(95, this.pos.x * 0.9 + (50 + acc.x * 2) * 0.1));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y * 0.9 + (50 + acc.y * 2) * 0.1));

          this.updateState();

          if (now - this.lastReflectionTime > this.reflectionInterval) {
            this.reflect();
            this.lastReflectionTime = now;
          }
        }, { passive: true });
      }

      monitorTranscendence() {
        let lastTranscendenceCheck = 0;
        const check = () => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - lastTranscendenceCheck < 100) {
            requestAnimationFrame(check);
            return;
          }
          lastTranscendenceCheck = now;

          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 800;

          if (shouldTranscend && !this.transcendent) {
            this.enterTranscendence();
            console.log('Entered void state');
          } else if (!shouldTranscend && this.transcendent) {
            this.exitTranscendence();
            console.log('Exited void state');
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 800) / 2000);
            this.deepenVoid();
          }

          requestAnimationFrame(check);
        };
        requestAnimationFrame(check);
      }

      enterTranscendence() {
        this.transcendent = true;
        this.state = 'VOID';
        
        const transcendentElements = [this.elements.logo, this.elements.tagline, this.elements.viz, this.elements.orb];
        transcendentElements.forEach(el => el && el.classList.add('transcendent'));
        document.body.classList.add('transcendent');
        
        this.createParticles();
        this.startHeavenLayers();
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.state = 'CHILL';
        
        const transcendentElements = [this.elements.logo, this.elements.tagline, this.elements.viz, this.elements.orb];
        transcendentElements.forEach(el => el && el.classList.remove('transcendent'));
        document.body.classList.remove('transcendent');
        
        this.clearParticles();
        this.stopHeavenLayers();
        this.oscillators.clear();
      }

      createParticles() {
        const container = this.elements.particles;
        container.classList.add('active');
        
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 6 + 's';
          fragment.appendChild(particle);
        }
        container.appendChild(fragment);
      }

      clearParticles() {
        const container = this.elements.particles;
        container.classList.remove('active');
        setTimeout(() => container.innerHTML = '', 2000);
      }

      createReverb() {
        if (!this.ctx) return;
        this.reverb = this.ctx.createConvolver();
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * (this.weather.includes('RAIN') || this.weather.includes('STORM') ? 4 : 3), this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
          }
        }
        
        this.reverb.buffer = buffer;
        this.reverb.connect(this.ctx.destination);
      }

      deepenVoid() {
        const intensity = this.transcendentIntensity;
        if (intensity > 0.3 && Math.random() < 0.01) this.voidWhisper();
        if (intensity > 0.6 && Math.random() < 0.008) this.voidBell();
        this.transcendentPad();
        this.cosmicDrone();
        
        if (intensity > 0.2) document.body.style.background = `radial-gradient(circle at 60% 40%, #050010 ${intensity * 20}%, #0a0a1e ${intensity * 40}%, #1a0a2e ${intensity * 60}%, #0a0a1e 100%)`;
        if (intensity > 0.5) document.body.style.background = `radial-gradient(circle at 60% 40%, #020008 ${intensity * 15}%, #05050f ${intensity * 30}%, #0a0a1e ${intensity * 50}%, #05050f 80%)`;
      }

      voidWhisper() {
        if (this.oscillators.size >= 20) return;
        const oscData = this.getOscillator('triangle', 100 + Math.random() * 120 * (1 - this.envDensity * 0.5));
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        filter.type = 'bandpass';
        filter.frequency.value = 200 + Math.random() * 80 * (1 + this.envDensity * 0.3);
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.02 * this.transcendentIntensity * (this.weather.includes('RAIN') ? 1.5 : 1), this.ctx.currentTime + 2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
        
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 8);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 8000);
      }

      voidBell() {
        if (this.oscillators.size >= 20) return;
        const freq = [174, 207, 261, 311, 349][Math.floor(Math.random() * 5)] * 0.7 * (1 + this.envDensity * 0.4);
        const oscData = this.getOscillator('sine', freq * (this.weather.includes('CLEAR') ? 1.2 : 1));
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1 * this.transcendentIntensity * (this.weather.includes('RAIN') ? 1.3 : 1), this.ctx.currentTime + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 10);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 10000);
      }

      transcendentPad() {
        if (this.oscillators.size >= 20) return;
        const oscData = this.getOscillator('sine', 0);
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        const noteIndex = this.chords[this.currentChord][Math.floor(Math.random() * 3)];
        osc.frequency.value = this.scale[noteIndex] * 0.6 * (1 + this.envDensity * 0.2);
        filter.type = 'lowpass';
        filter.frequency.value = 250 + this.transcendentIntensity * 100 * (this.weather.includes('CLEAR') ? 1.5 : 1);
        filter.Q.value = 2.5;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity * (this.weather.includes('RAIN') ? 1.5 : 1), this.ctx.currentTime + 2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
        
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 8);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 8000);
      }

      cosmicDrone() {
        if (this.oscillators.size >= 20) return;
        const oscData = this.getOscillator('sawtooth', 0);
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        const noteIndex = this.chords[(this.currentChord + 1) % this.chords.length][0];
        osc.frequency.value = this.scale[noteIndex] * 0.4 * (1 + this.envDensity * 0.1);
        filter.type = 'lowpass';
        filter.frequency.value = 150 + this.transcendentIntensity * 80 * (this.weather.includes('CLOUD') ? 0.8 : 1);
        filter.Q.value = 2;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2 * this.transcendentIntensity * (this.weather.includes('STORM') ? 1.3 : 1), this.ctx.currentTime + 2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
        
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 8);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 8000);
      }

      startHeavenLayers() {
        if (this.oscillators.size >= 20) return;
        const chord = this.chords[this.currentChord];
        chord.forEach(note => {
          if (this.oscillators.size >= 20) return;
          const oscData = this.getOscillator('sine', this.scale[note] * 0.3 * (1 + this.envDensity * 0.5));
          if (!oscData) return;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          filter.type = 'lowpass';
          filter.frequency.value = 250 + this.motion * 1.5 * (1 + this.envDensity * 0.2);
          filter.Q.value = 1.8;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity * (this.weather.includes('CLEAR') ? 1.5 : 1), this.ctx.currentTime + 5);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          
          this.oscillators.add(osc);
        });
      }

      stopHeavenLayers() {
        this.oscillators.forEach(osc => {
          try {
            osc.stop(this.ctx.currentTime + 3);
          } catch (e) {}
        });
        this.oscillators.clear();
        this.oscillatorPool.forEach(oscData => oscData.inUse = false);
      }

      updateLocation(pos) {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        const accuracy = pos.coords.accuracy;

        if (this.lastLocation) {
          const dist = this.haversineDistance(this.lastLocation.lat, this.lastLocation.lon, lat, lon);
          this.distanceTraveled += dist;
        }
        this.lastLocation = { lat, lon };
        this.location = { lat, lon, accuracy };

        const speed = pos.coords.speed || 0;
        const responsiveness = Math.max(0.1, 100 / accuracy);
        this.envDensity = Math.min(1, Math.max(0, this.envDensity + (speed * 0.02 * responsiveness) + (Math.random() * 0.1)));
        
        if (speed > 1) this.bpm = Math.min(150, this.bpm + Math.round(this.envDensity * 5));
      }

      haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const Ï†1 = lat1 * Math.PI / 180;
        const Ï†2 = lat2 * Math.PI / 180;
        const Î”Ï† = (lat2 - lat1) * Math.PI / 180;
        const Î”Î» = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(Î”Ï† / 2) * Math.sin(Î”Ï† / 2) +
                  Math.cos(Ï†1) * Math.cos(Ï†2) *
                  Math.sin(Î”Î» / 2) * Math.sin(Î”Î» / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      updateEnvDensity() {
        const motionFactor = this.motion * 0.01;
        this.envDensity = Math.min(1, Math.max(0, this.envDensity + motionFactor * 0.1 + (Math.random() * 0.05)));
        if (this.weather.includes('RAIN') || this.weather.includes('STORM')) this.envDensity = Math.min(1, this.envDensity + 0.1);
      }

      updateSongProgress() {
        if (this.motion > 5 || this.distanceTraveled > 10) {
          const progressIncrement = 0.1 * (1 + this.envDensity) * (this.weather.includes('STORM') ? 1.5 : 1);
          this.layerProgress = Math.min(10, this.layerProgress + progressIncrement);
          if (this.songSection === 'INTRO' && this.layerProgress >= 2) this.songSection = 'BUILD';
          else if (this.songSection === 'BUILD' && this.layerProgress >= 4) this.songSection = 'CLIMAX';
          else if (this.songSection === 'CLIMAX' && this.layerProgress >= 7) this.songSection = 'RESOLUTION';
          else if (this.songSection === 'RESOLUTION' && this.layerProgress >= 9) this.songSection = 'OUTRO';
        }
      }

      updateState() {
        if (this.transcendent) {
          this.state = ['VOID', 'DARKNESS', 'ETHEREAL', 'INFINITE'][Math.floor(this.transcendentIntensity * 4)];
          this.bpm = Math.round(45 + (this.transcendentIntensity * 35) + (this.motion * 0.15));
          return;
        }

        const targetBPM = 80 + this.motion * 2 + this.envDensity * 20 + (this.distanceTraveled / 100);
        this.bpm = Math.round(this.bpm * 0.95 + targetBPM * 0.05);
        
        if (this.songSection === 'INTRO') this.state = 'CHILL';
        else if (this.songSection === 'BUILD') this.state = 'FLOW';
        else if (this.songSection === 'CLIMAX') this.state = 'ENERGY';
        else if (this.songSection === 'RESOLUTION') this.state = 'ASCENSION';
        else if (this.songSection === 'OUTRO') this.state = 'EUPHORIA';
      }

      startGroove() {
        const tick = () => {
          if (!this.active) return;

          if (this.transcendent) {
            if (this.step % 8 === 0) this.etherealKick();
            if (this.step % 12 === 6 && this.transcendentIntensity > 0.3) this.voidPulse();
            if (this.step % 16 === 0) this.startHeavenLayers();
          } else {
            if (this.patterns.kick[this.step % 16] && this.layerProgress >= 2) this.kick808();
            if (this.patterns.snare[this.step % 16] && this.layerProgress >= 2) this.snareLayered();
            if (this.patterns.hihat[this.step % 16] && this.layerProgress >= 3) this.hihatMetallic();
            if (this.patterns.bass[this.step % 16] && this.layerProgress >= 4) this.bassLayer();
            if (this.step % 8 === 0 && this.layerProgress >= 5) this.vocalLayer();
            if (this.layerProgress >= 6) this.peakLayer();
            if (this.layerProgress >= 7) this.crescendoLayer();
            if (this.layerProgress >= 8) this.finalCrescendo();
            if (this.layerProgress >= 9) this.ultimateCrescendo();
            if (this.layerProgress >= 2) this.ambientPad();
            if (this.layerProgress >= 3) this.secondaryAmbient();
            if (this.layerProgress >= 4) this.tertiaryAmbient();
            if (this.layerProgress >= 5) this.quaternaryAmbient();
          }

          this.step = (this.step + 1) % 32;
          if (this.step === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
            if (this.songSection === 'CLIMAX' || this.songSection === 'RESOLUTION') this.bpm += Math.round(10 * (1 + this.envDensity));
          }

          const interval = Math.max(100, 60000 / this.bpm / 4);
          setTimeout(tick, interval);
        };
        tick();
      }

      kick808() {
        if (this.oscillators.size >= 20) return;
        const subOscData = this.getOscillator('sine', 60 * (1 + this.envDensity * 0.3) * (this.weather.includes('CLEAR') ? 1.2 : 1));
        const clickOscData = this.getOscillator('sine', 500);
        if (!subOscData || !clickOscData) return;
        
        const subOsc = subOscData.osc;
        const clickOsc = clickOscData.osc;
        const gainSub = this.ctx.createGain();
        const gainClick = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const highPass = this.ctx.createBiquadFilter();

        subOsc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.5);
        clickOsc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.05);

        filter.type = 'lowpass';
        filter.frequency.value = 200 + this.motion * 0.5 * (this.weather.includes('RAIN') ? 0.8 : 1);
        filter.Q.value = 2;

        highPass.type = 'highpass';
        highPass.frequency.value = 30;
        highPass.Q.value = 0.5;

        gainSub.gain.setValueAtTime(0.8 * (1 + this.layerProgress * 0.2) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
        gainSub.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);

        gainClick.gain.setValueAtTime(0.5 * (1 + this.layerProgress * 0.2) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
        gainClick.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);

        subOsc.connect(gainSub).connect(highPass).connect(filter);
        clickOsc.connect(gainClick).connect(highPass);
        highPass.connect(filter).connect(this.reverb);

        subOsc.start();
        subOsc.stop(this.ctx.currentTime + 0.5);
        clickOsc.start();
        clickOsc.stop(this.ctx.currentTime + 0.1);

        this.oscillators.add(subOsc);
        this.oscillators.add(clickOsc);
        setTimeout(() => {
          this.oscillators.delete(subOsc);
          this.oscillators.delete(clickOsc);
          this.releaseOscillator(subOscData);
          this.releaseOscillator(clickOscData);
        }, 500);
      }

      snareLayered() {
        if (this.oscillators.size >= 20) return;
        const noise = this.createNoiseBuffer();
        const noiseSource = this.ctx.createBufferSource();
        const toneOscData = this.getOscillator('triangle', 180 * (1 + this.envDensity * 0.3) * (this.weather.includes('CLEAR') ? 1.2 : 1));
        if (!toneOscData) return;
        const toneOsc = toneOscData.osc;
        const noiseGain = this.ctx.createGain();
        const toneGain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        noiseSource.buffer = noise;
        filter.type = 'bandpass';
        filter.frequency.value = 300 + this.motion * 2 * (1 + this.envDensity * 0.2) * (this.weather.includes('CLOUD') ? 0.9 : 1);
        filter.Q.value = 3;

        noiseGain.gain.setValueAtTime(0.6 * (1 + this.layerProgress * 0.3) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);

        toneGain.gain.setValueAtTime(0.4 * (1 + this.layerProgress * 0.3) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
        toneGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

        noiseSource.connect(noiseGain).connect(filter);
        toneOsc.connect(toneGain).connect(filter);
        filter.connect(this.reverb);

        noiseSource.start();
        noiseSource.stop(this.ctx.currentTime + 0.2);
        toneOsc.start();
        toneOsc.stop(this.ctx.currentTime + 0.15);

        this.oscillators.add(noiseSource);
        this.oscillators.add(toneOsc);
        setTimeout(() => {
          this.oscillators.delete(noiseSource);
          this.oscillators.delete(toneOsc);
          this.releaseOscillator(toneOscData);
        }, 200);
      }

      hihatMetallic() {
        if (this.oscillators.size >= 20) return;
        if (Math.random() < 0.4 + this.envDensity * 0.2) {
          const waves = 3 + Math.floor(this.layerProgress);
          for (let i = 0; i < waves && this.oscillators.size < 20; i++) {
            const oscData = this.getOscillator('square', 3000 * Math.pow(1.5, i) * (1 + this.envDensity * 0.1) * (this.weather.includes('CLEAR') ? 1.3 : 1));
            if (!oscData) continue;
            const osc = oscData.osc;
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();

            filter.type = 'highpass';
            filter.frequency.value = 2500 + this.motion * 4;
            filter.Q.value = 0.5;

            gain.gain.setValueAtTime(0.08 / (i + 1) * (1 + this.layerProgress * 0.2) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.1);

            osc.connect(filter).connect(gain).connect(this.reverb);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.1);

            this.oscillators.add(osc);
            setTimeout(() => {
              this.oscillators.delete(osc);
              this.releaseOscillator(oscData);
            }, 100);
          }
        }
      }

      vocalLayer() {
        if (this.oscillators.size >= 20) return;
        if (Math.random() < 0.2 + this.envDensity * 0.3) {
          const oscData = this.getOscillator('sine', 0);
          if (!oscData) return;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const noteIndex = this.chords[this.currentChord][Math.floor(Math.random() * 3) + 1];
          osc.frequency.value = this.scale[noteIndex] * 1.2 * (1 + this.envDensity * 0.2) * (this.weather.includes('CLEAR') ? 1.2 : 1);
          filter.type = 'bandpass';
          filter.frequency.value = 400 + this.motion * 2 * (1 + this.envDensity * 0.2);
          filter.Q.value = 3;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.12 * (1 + this.layerProgress * 0.3) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + 1.5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 4000);
        }
      }

      bassLayer() {
        if (this.oscillators.size >= 20) return;
        const oscData = this.getOscillator('sawtooth', 0);
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        const noteIndex = this.chords[this.currentChord][0];
        osc.frequency.value = this.scale[noteIndex] * 0.5 * (1 + this.envDensity * 0.3) * (this.weather.includes('STORM') ? 1.2 : 1);
        filter.type = 'lowpass';
        filter.frequency.value = 150 + this.motion * 1.5;
        filter.Q.value = 3;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.3 * (1 + this.layerProgress * 0.2) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1);
        
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 1);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 1000);
      }

      peakLayer() {
        if (this.oscillators.size >= 20) return;
        const chord = this.chords[this.currentChord];
        for (let i = 0; i < Math.min(5, 20 - this.oscillators.size); i++) {
          const oscData = this.getOscillator('sine', this.scale[chord[i % chord.length]] * (1 + this.envDensity * 0.2));
          if (!oscData) continue;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          filter.type = 'bandpass';
          filter.frequency.value = 200 + this.motion * 2;
          filter.Q.value = 5;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.1);
          gain.gain.linearRampToValueAtTime(0.4 * (this.layerProgress - 4) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + i * 0.1 + 0.5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + i * 0.1 + 2);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + i * 0.1 + 2);
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 2000);
        }
      }

      crescendoLayer() {
        if (this.oscillators.size >= 20) return;
        const chord = this.chords[this.currentChord].map(i => (i + [0, 4, 7][Math.floor(Math.random() * 3)]) % this.scale.length);
        for (let i = 0; i < Math.min(6, 20 - this.oscillators.size); i++) {
          const oscData = this.getOscillator('sine', this.scale[chord[i % chord.length]] * (1.5 + this.envDensity * 0.3));
          if (!oscData) continue;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          filter.type = 'bandpass';
          filter.frequency.value = 300 + this.motion * 3;
          filter.Q.value = 6;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.15);
          gain.gain.linearRampToValueAtTime(0.5 * (this.layerProgress - 5) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + i * 0.15 + 0.7);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + i * 0.15 + 3);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + i * 0.15 + 3);
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 3000);
        }
      }

      finalCrescendo() {
        if (this.oscillators.size >= 20) return;
        const chord = this.chords[this.currentChord].map(i => (i + [0, 4, 7, 10][Math.floor(Math.random() * 4)]) % this.scale.length);
        for (let i = 0; i < Math.min(8, 20 - this.oscillators.size); i++) {
          const oscData = this.getOscillator('sine', this.scale[chord[i % chord.length]] * (2 + this.envDensity * 0.4));
          if (!oscData) continue;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          filter.type = 'bandpass';
          filter.frequency.value = 400 + this.motion * 4;
          filter.Q.value = 7;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.2);
          gain.gain.linearRampToValueAtTime(0.6 * (this.layerProgress - 6) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + i * 0.2 + 1);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + i * 0.2 + 4);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + i * 0.2 + 4);
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 4000);
        }
      }

      ultimateCrescendo() {
        if (this.oscillators.size >= 20) return;
        const chord = this.chords[this.currentChord].map(i => (i + [0, 4, 7, 10, 14][Math.floor(Math.random() * 5)]) % this.scale.length);
        for (let i = 0; i < Math.min(10, 20 - this.oscillators.size); i++) {
          const oscData = this.getOscillator('sine', this.scale[chord[i % chord.length]] * (2.5 + this.envDensity * 0.5));
          if (!oscData) continue;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          filter.type = 'bandpass';
          filter.frequency.value = 500 + this.motion * 5;
          filter.Q.value = 8;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime + i * 0.25);
          gain.gain.linearRampToValueAtTime(0.7 * (this.layerProgress - 7) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + i * 0.25 + 1.2);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + i * 0.25 + 5);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + i * 0.25 + 5);
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 5000);
        }
      }

      ambientPad() {
        if (this.oscillators.size >= 20) return;
        if (Math.random() < 0.3 + this.envDensity * 0.2) {
          const oscData = this.getOscillator('sawtooth', 0);
          if (!oscData) return;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const noteIndex = this.chords[this.currentChord][Math.floor(Math.random() * 3)];
          osc.frequency.value = this.scale[noteIndex] * 0.8 * (this.weather.includes('CLEAR') ? 1.2 : 1);
          filter.type = 'lowpass';
          filter.frequency.value = 400 + this.motion * 1 * (this.weather.includes('RAIN') ? 0.8 : 1);
          filter.Q.value = 2;
          
          gain.gain.setValueAtTime(0.05 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.08 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + 10);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 20);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 20000);
        }
      }

      secondaryAmbient() {
        if (this.oscillators.size >= 20) return;
        if (Math.random() < 0.25 + this.envDensity * 0.15) {
          const oscData = this.getOscillator('triangle', 0);
          if (!oscData) return;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const noteIndex = this.chords[(this.currentChord + 1) % this.chords.length][Math.floor(Math.random() * 3)];
          osc.frequency.value = this.scale[noteIndex] * 0.7 * (this.weather.includes('CLEAR') ? 1.2 : 1);
          filter.type = 'lowpass';
          filter.frequency.value = 350 + this.motion * 0.8 * (this.weather.includes('RAIN') ? 0.8 : 1);
          filter.Q.value = 1.5;
          
          gain.gain.setValueAtTime(0.04 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.06 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + 12);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 22);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 22000);
        }
      }

      tertiaryAmbient() {
        if (this.oscillators.size >= 20) return;
        if (Math.random() < 0.2 + this.envDensity * 0.1) {
          const oscData = this.getOscillator('sine', 0);
          if (!oscData) return;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const noteIndex = this.chords[(this.currentChord + 2) % this.chords.length][Math.floor(Math.random() * 3)];
          osc.frequency.value = this.scale[noteIndex] * 0.6 * (this.weather.includes('CLEAR') ? 1.2 : 1);
          filter.type = 'lowpass';
          filter.frequency.value = 300 + this.motion * 0.6 * (this.weather.includes('RAIN') ? 0.8 : 1);
          filter.Q.value = 1.2;
          
          gain.gain.setValueAtTime(0.03 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.05 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + 15);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 25);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 25000);
        }
      }

      quaternaryAmbient() {
        if (this.oscillators.size >= 20) return;
        if (Math.random() < 0.15 + this.envDensity * 0.05) {
          const oscData = this.getOscillator('sawtooth', 0);
          if (!oscData) return;
          const osc = oscData.osc;
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const noteIndex = this.chords[(this.currentChord + 3) % this.chords.length][Math.floor(Math.random() * 3)];
          osc.frequency.value = this.scale[noteIndex] * 0.5 * (this.weather.includes('CLEAR') ? 1.2 : 1);
          filter.type = 'lowpass';
          filter.frequency.value = 250 + this.motion * 0.4 * (this.weather.includes('RAIN') ? 0.8 : 1);
          filter.Q.value = 1.0;
          
          gain.gain.setValueAtTime(0.02 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.04 * (1 + this.layerProgress * 0.1) * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime + 18);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 28);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          
          this.oscillators.add(osc);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.releaseOscillator(oscData);
          }, 28000);
        }
      }

      etherealKick() {
        if (this.oscillators.size >= 20) return;
        const oscData = this.getOscillator('sine', 40 * (1 + this.envDensity * 0.3) * (this.weather.includes('STORM') ? 1.3 : 1));
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.5);
        gain.gain.setValueAtTime(0.5 * this.transcendentIntensity * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 1);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 1000);
      }

      voidPulse() {
        if (this.oscillators.size >= 20) return;
        const oscData = this.getOscillator('sawtooth', 20 + this.motion * 0.1 * (1 + this.envDensity * 0.5));
        if (!oscData) return;
        const osc = oscData.osc;
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        filter.type = 'lowpass';
        filter.frequency.value = 50 + this.motion * 0.3 * (1 + this.envDensity * 0.4);
        filter.Q.value = 4;
        
        gain.gain.setValueAtTime(0.6 * this.transcendentIntensity * (this.moodFactor * 0.5 + 0.5), this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
        
        this.oscillators.add(osc);
        setTimeout(() => {
          this.oscillators.delete(osc);
          this.releaseOscillator(oscData);
        }, 1500);
      }

      showError(msg) {
        this.elements.error.textContent = msg;
        this.elements.error.classList.remove('hidden');
      }

      createNoiseBuffer() {
        const bufferSize = this.ctx.sampleRate * 0.2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        return buffer;
      }

      reflect() {
        const avgMotion = this.rolloutBuffer.reduce((a, b) => a + b, 0) / this.rolloutBuffer.length;
        if (avgMotion < 10 && this.layerProgress < 2) this.layerProgress += 0.1;
        else if (avgMotion > 20 && this.bpm < 120) this.bpm += 5;
        else if (this.distanceTraveled > 300 && this.layerProgress < 4) this.layerProgress += 0.2;
        else if (this.distanceTraveled > 500 && this.layerProgress < 7) this.layerProgress += 0.3;
        else if (this.distanceTraveled > 700 && this.layerProgress < 9) this.layerProgress += 0.4;
      }

      animate() {
        const update = () => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - this.lastUpdateTime < 16) {
            requestAnimationFrame(update);
            return;
          }
          this.lastUpdateTime = now;

          const pulse = Math.sin(now * this.bpm / 60000 * Math.PI);
          Object.assign(this.elements.orb.style, {
            transform: `translate(${this.pos.x - 50}%, ${this.pos.y - 50}%) scale(${1 + this.layerProgress * 0.1 + pulse * 0.05})`
          });

          if (this.frameCount % 10 === 0) {
            Object.assign(this.elements, {
              motion: { textContent: Math.round(this.motion) },
              bpm: { textContent: this.bpm },
              groove: { textContent: this.state },
              status: { textContent: `ðŸŽµ ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()} - ${this.weather.toLowerCase()}...` }
            });
          }

          this.frameCount++;
          requestAnimationFrame(update);
        };
        requestAnimationFrame(update);
      }
    }

    new SpatialAI();
  </script>
</body>
</html>
