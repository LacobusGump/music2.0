 <!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>GUMP</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; width:100%; background:#000; overflow:hidden; touch-action:none; }
canvas { position:fixed; inset:0; }
#overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; color:#0ff; font-family:system-ui; font-size:32px; text-align:center; background:rgba(0,0,0,0.98); z-index:10; transition:opacity 4s ease; letter-spacing:4px; text-shadow:0 0 40px #0ff, 0 0 80px #00f; flex-direction:column; }
#overlay.hidden { opacity:0; pointer-events:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">GUMP<br><br>Touch once.<br><br>I am listening.<br><br>Your world becomes the eternal song.</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight;
const overlay = document.getElementById('overlay');
const PI2 = Math.PI * 2;

let mic, meter, fft, waveform;
let pos = {x: canvas.width/2, y: canvas.height/2};
let trail = [];
let vel = {x:0, y:0};
let accel = {x:0, y:0};
let calib = {x: 0, y: 0};
let time = 0;
let energy = 0;
let sustained = 0;
let audioReady = false;
let stars = [];
let melodyMemory = [];
let currentTempo = 80;

const master = new Tone.Gain(0.95).toDestination();
const eternalReverb = new Tone.Reverb({decay: 40, wet: 0.9}).connect(master);
const morphDist = new Tone.Distortion(0.3).connect(eternalReverb);
const evolveFilter = new Tone.Filter({type:'lowpass', frequency:18000, Q:15}).connect(morphDist);
eternalReverb.generate();

const rootBass = new Tone.MonoSynth({oscillator:{type:'triangle'}, envelope:{attack:0.08, decay:1.2}}).connect(evolveFilter);
const harmonyPad = new Tone.PolySynth(Tone.FMSynth, {envelope:{attack:20, decay:10, sustain:0.8, release:40}}).connect(eternalReverb);
harmonyPad.volume.value = -8;
const improvLead = new Tone.Synth({oscillator:{type:'sawtooth16'}, envelope:{attack:0.15, release:3}}).connect(eternalReverb);

const learnedKick = new Tone.MembraneSynth({octaves:8}).connect(evolveFilter);
const learnedSnare = new Tone.NoiseSynth({envelope:{attack:0.005, decay:0.4}}).connect(morphDist);

const memorySeq = new Tone.Sequence((t, note) => {
  improvLead.triggerAttackRelease(note, '8n', t);
  if (Math.random() < 0.35) improvLead.triggerAttackRelease(Tone.Frequency(note).harmonize([4,7])[0], '8n', t + 0.08);
}, [], "8n").start(0);

let zones = [];

class Zone {
  constructor(baseX, baseY, r, hue, effectNode, drift = 160, speed = 0.00026) {
    this.baseX = baseX; this.baseY = baseY;
    this.drift = drift; this.speed = speed;
    this.angle = Math.random() * PI2;
    this.r = r; this.hue = hue;
    this.effect = effectNode;
    this.gain = new Tone.Gain(0);
    this.panner = new Tone.Panner(0).connect(eternalReverb);
    this.effect.connect(this.gain).connect(this.panner);
    this.particles = [];
    this.x = baseX; this.y = baseY;
  }
  drift() {
    this.angle += this.speed;
    this.x = this.baseX + Math.cos(this.angle) * this.drift;
    this.y = this.baseY + Math.sin(this.angle) * this.drift;
  }
  update(prox, pan, input, global) {
    this.drift();
    this.panner.pan.rampTo(pan, 0.3);
    let target = prox * (1.8 + input * 5 + global * 3);
    this.gain.gain.rampTo(target, 0.35);
    if (input > 0.45 && prox > 0.35 && Math.random() < 0.85) {
      for (let i = 0; i < 25; i++) {
        this.particles.push({
          age: 0,
          x: 0,
          y: 0,
          vx: (Math.random() - 0.5) * 40,
          vy: (Math.random() - 0.5) * 40
        });
      }
    }
    this.particles = this.particles.filter(p => {
      p.x += p.vx;
      p.y += p.vy;
      p.vx *= 0.96;
      p.vy *= 0.96;
      return p.age++ < 80;
    });
  }
  draw(prox, input) {
    let pulse = 1 + Math.sin(time * 0.01 + this.hue * 0.003) * 0.8 * prox + input * 1.5;
    let alpha = 0.6 + prox * 0.4 + input * 0.7;

    // Large soft glow
    let glowSize = this.r * 14 * pulse;
    let grad = ctx.createRadialGradient(this.x, this.y, this.r * 0.3, this.x, this.y, glowSize);
    grad.addColorStop(0, `hsla(${this.hue + time * 8 % 360}, 90%, 75%, ${alpha})`);
    grad.addColorStop(0.4, `hsla(${this.hue + 40}, 100%, 65%, ${alpha * 0.6})`);
    grad.addColorStop(1, 'hsla(0,0%,0%,0)');
    ctx.globalAlpha = alpha * 0.7;
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, glowSize, 0, PI2);
    ctx.fill();

    // Core ring
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = `hsla(${this.hue + time * 25 % 360}, 100%, 85%, 1)`;
    ctx.lineWidth = 15 + prox * 80 + input * 60;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r * pulse, 0, PI2);
    ctx.stroke();

    // Inner bright core
    grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r * pulse * 0.7);
    grad.addColorStop(0, `hsla(${this.hue + time * 15 % 360}, 100%, 95%, 1)`);
    grad.addColorStop(1, `hsla(${this.hue}, 100%, 70%, 0)`);
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r * pulse * 0.7, 0, PI2);
    ctx.fill();

    // Particles
    this.particles.forEach(p => {
      let pa = 1 - p.age / 80;
      let psize = (8 + input * 25) * pa;
      ctx.globalAlpha = pa * 0.9;
      ctx.fillStyle = `hsla(${this.hue + p.age * 12}, 100%, 80%, ${pa})`;
      ctx.beginPath();
      ctx.arc(this.x + p.x, this.y + p.y, psize, 0, PI2);
      ctx.fill();
    });
  }
}

let lastEnergy = 0;
function detectOnset() {
  const current = meter.getValue();
  if (current > lastEnergy + 0.25 && current > 0.35) {
    lastEnergy = current;
    return true;
  }
  lastEnergy = current * 0.92;
  return false;
}

function detectPitch() {
  const buffer = waveform.getValue();
  let size = buffer.length;
  let bestLag = -1;
  let bestCorr = 0;
  let rms = 0;
  for (let i = 0; i < size; i++) rms += buffer[i] ** 2;
  rms = Math.sqrt(rms / size);
  if (rms < 0.04) return -1;
  for (let lag = 12; lag < size / 3; lag++) {
    let corr = 0;
    for (let i = 0; i < size - lag; i++) corr += buffer[i] * buffer[i + lag];
    corr /= (size - lag);
    if (corr > bestCorr) { bestCorr = corr; bestLag = lag; }
  }
  if (bestCorr > 0.82 && bestLag > 0) {
    return Tone.context.sampleRate / bestLag;
  }
  return -1;
}

function awaken() {
  overlay.classList.add('hidden');
  loop();
  (async () => {
    try {
      await Tone.start();
      Tone.Transport.bpm.value = currentTempo;
      Tone.Transport.start();
      mic = new Tone.UserMedia();
      await mic.open();
      meter = new Tone.Meter({normalRange: true});
      fft = new Tone.FFT(2048);
      waveform = new Tone.Waveform(4096);
      mic.connect(meter, fft, waveform, evolveFilter);

      // Create effects
      const effects = [
        new Tone.PitchShift(-36),
        new Tone.PitchShift(-24),
        new Tone.PitchShift(-12),
        new Tone.PitchShift(0),
        new Tone.PitchShift(12),
        new Tone.PitchShift(24),
        new Tone.PitchShift(36),
        new Tone.Distortion(1.8),
        new Tone.BitCrusher(6),
        new Tone.Chorus(6, 0.6, 1.2).start(),
        new Tone.FeedbackDelay("8t", 0.75),
        new Tone.Vibrato(8, 0.9)
      ];

      // Create zones
      const hues = [180, 210, 240, 270, 300, 330, 0, 30, 60, 90, 120, 150];
      zones = [
        new Zone(canvas.width*0.05, canvas.height*0.12, 230, hues[0], effects[0], 200, 0.00024),
        new Zone(canvas.width*0.95, canvas.height*0.12, 220, hues[1], effects[1], 180, -0.00026),
        new Zone(canvas.width*0.5, canvas.height*0.15, 240, hues[2], effects[2], 210, 0.00022),
        new Zone(canvas.width*0.15, canvas.height*0.33, 200, hues[3], effects[3], 160, 0.00029),
        new Zone(canvas.width*0.85, canvas.height*0.33, 210, hues[4], effects[4], 190, -0.00025),
        new Zone(canvas.width*0.1, canvas.height*0.55, 190, hues[5], effects[5], 170, 0.00027),
        new Zone(canvas.width*0.9, canvas.height*0.55, 200, hues[6], effects[6], 150, -0.00028),
        new Zone(canvas.width*0.25, canvas.height*0.7, 210, hues[7], effects[7], 140, 0.0003),
        new Zone(canvas.width*0.75, canvas.height*0.7, 190, hues[8], effects[8], 180, -0.00023),
        new Zone(canvas.width*0.5, canvas.height*0.82, 230, hues[9], effects[9], 160, 0.00025),
        new Zone(canvas.width*0.33, canvas.height*0.9, 200, hues[10], effects[10], 130, 0.00031),
        new Zone(canvas.width*0.67, canvas.height*0.9, 210, hues[11], effects[11], 150, -0.00027)
      ];

      // Connect mic to all zone effects
      zones.forEach(z => mic.connect(z.effect));

      // Generate stars
      for (let i = 0; i < 600; i++) {
        stars.push({
          x: Math.random() * canvas.width,
          y: Math.random() * canvas.height,
          s: Math.random() * 2 + 0.5,
          twinkle: Math.random() * PI2
        });
      }

      window.addEventListener('devicemotion', e => {
        if (e.accelerationIncludingGravity) {
          accel.x = e.accelerationIncludingGravity.x || 0;
          accel.y = e.accelerationIncludingGravity.y || 0;
        }
      });
      calib = {x: accel.x, y: accel.y};
      audioReady = true;
    } catch (e) {
      console.log('Silence accepted â€“ composing from inner cosmos');
      audioReady = false;
    }
  })();
}

function loop() {
  time += 0.016;
  ctx.fillStyle = 'rgba(0,0,0,0.09)';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.globalCompositeOperation = 'lighter';

  // Stars
  stars.forEach(s => {
    let alpha = 0.4 + Math.sin(time * 2.5 + s.twinkle) * 0.4;
    ctx.globalAlpha = alpha;
    ctx.fillStyle = '#fff';
    ctx.fillRect(s.x, s.y, s.s, s.s);
  });

  const ax = (accel.x - calib.x) * 30;
  const ay = (accel.y - calib.y) * 30;
  vel.x += ax; vel.y += ay;
  vel.x *= 0.85; vel.y *= 0.85;
  pos.x += vel.x; pos.y += vel.y;
  pos.x = Math.max(150, Math.min(canvas.width - 150, pos.x));
  pos.y = Math.max(150, Math.min(canvas.height - 150, pos.y));

  trail.push({x: pos.x, y: pos.y, age: 0});
  trail = trail.filter(p => p.age++ < 200);

  let input = audioReady ? meter.getValue() : 0.15 + Math.sin(time * 0.25) * 0.1;
  energy = Math.max(energy * 0.92, input);
  sustained += energy > 0.75 ? 0.03 : -0.015;
  sustained = Math.max(0, Math.min(1, sustained));

  if (audioReady) {
    if (detectOnset()) {
      learnedKick.triggerAttackRelease('C1', '8n');
      learnedSnare.triggerAttackRelease('16n', '+0.12');
      currentTempo = Math.min(160, currentTempo * 1.06 + energy * 30);
      Tone.Transport.bpm.rampTo(currentTempo, 3);
    }
    const currentPitch = detectPitch();
    if (currentPitch > 0) {
      let note = Tone.Frequency(currentPitch).toNote();
      melodyMemory.push(note);
      if (melodyMemory.length > 20) melodyMemory.shift();
      memorySeq.values = [...melodyMemory, ...melodyMemory.map(n => Tone.Frequency(n).transpose(Math.random() > 0.5 ? 12 : -12))];
      harmonyPad.triggerAttackRelease([note, Tone.Frequency(note).harmonize([4,7])[0], Tone.Frequency(note).harmonize([4,7,11])[0]], "4m");
      rootBass.triggerAttackRelease(Tone.Frequency(currentPitch / 4), '4n');
    }
  }

  zones.forEach(z => {
    const d = Math.hypot(pos.x - z.x, pos.y - z.y);
    const prox = Math.max(0, 1 - d / z.r);
    const pan = (pos.x - z.x) / canvas.width * 2 - 1;
    z.update(prox, pan, input, sustained);
    z.draw(prox, input);
  });

  // Trail
  trail.forEach(p => {
    let ta = 1 - p.age / 200;
    let ts = 80 * ta + energy * 120;
    ctx.globalAlpha = ta * 0.7;
    ctx.fillStyle = `hsla(${time * 60 + p.age * 3 % 360}, 100%, 75%, ${ta})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, ts, 0, PI2);
    ctx.fill();
  });

  // Central orb
  let centralHue = time * 25 % 360;
  let pulse = 2.5 + Math.sin(time * 0.08) * 1.2 + energy * 10 + sustained * 8;
  let pulseSize = 300 * pulse;
  let grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, pulseSize);
  grad.addColorStop(0, '#fff');
  grad.addColorStop(0.08, `hsla(${centralHue}, 100%, 85%, 1)`);
  grad.addColorStop(0.25, `hsla(${centralHue + 80}, 100%, 70%, 0.9)`);
  grad.addColorStop(0.5, `hsla(${centralHue + 160}, 90%, 60%, 0.5)`);
  grad.addColorStop(1, 'hsla(0,0%,0%,0)');
  ctx.globalAlpha = 1;
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, pulseSize, 0, PI2);
  ctx.fill();

  // Central ring
  ctx.globalAlpha = 0.8;
  ctx.strokeStyle = '#fff';
  ctx.lineWidth = 20 + energy * 40;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, pulseSize * 0.65, 0, PI2);
  ctx.stroke();

  requestAnimationFrame(loop);
}

document.body.addEventListener('touchstart', awaken, {once: true});
document.body.addEventListener('click', awaken, {once: true});
</script>
</body>
</html>
