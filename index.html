<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>EchoNexus: Symphonic Cosmos</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            height: 100dvh;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            position: fixed;
            width: 100%;
        }

        /* Quantum Orb Nexus */
        .orb-container {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            perspective: 1000px;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            transform-style: preserve-3d;
        }

        .orb-core {
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.95) 0%, 
                rgba(200,100,255,0.4) 40%, 
                transparent 70%);
            box-shadow: 
                0 0 80px rgba(255,100,255,0.9),
                0 0 160px rgba(255,100,255,0.5),
                inset 0 0 40px rgba(0,255,255,0.3);
            animation: quantum-breathe 3s ease-in-out infinite;
        }

        .orb-pulse {
            width: 150px;
            height: 150px;
            background: radial-gradient(circle,
                transparent 0%,
                rgba(0,255,255,0.3) 50%,
                transparent 100%);
            animation: fractal-pulse 1.5s ease-out infinite;
        }

        .orb-field {
            width: 400px;
            height: 400px;
            background: radial-gradient(circle,
                rgba(100,255,100,0.15) 0%,
                transparent 60%);
            animation: multiverse-rotate 15s linear infinite;
        }

        @keyframes quantum-breathe {
            0%, 100% { transform: scale(1) rotateX(0deg) rotateY(0deg); opacity: 0.85; }
            50% { transform: scale(1.3) rotateX(10deg) rotateY(15deg); opacity: 1; }
        }

        @keyframes fractal-pulse {
            0% { transform: scale(1); opacity: 0.6; }
            100% { transform: scale(2.5); opacity: 0; }
        }

        @keyframes multiverse-rotate {
            from { transform: rotate(0deg) rotateZ(0deg); }
            to { transform: rotate(360deg) rotateZ(360deg); }
        }

        .orb-core.entangled {
            background: radial-gradient(circle, 
                rgba(0,255,0,1) 0%, 
                rgba(0,255,0,0.6) 40%, 
                transparent 70%);
            box-shadow: 
                0 0 100px rgba(0,255,0,0.95),
                0 0 200px rgba(0,255,0,0.6);
            animation: entanglement-pulse 0.4s ease-in-out infinite;
        }

        @keyframes entanglement-pulse {
            0%, 100% { transform: scale(1) rotateX(20deg); }
            50% { transform: scale(1.4) rotateX(-20deg); }
        }

        /* Synesthetic Status */
        .env-status {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.45;
            text-align: center;
            filter: blur(0.5px);
        }

        .sensor-reading {
            display: inline-block;
            margin: 0 12px;
            transition: all 0.4s ease;
            color: rgba(255,255,255,0.7);
        }

        .sensor-reading.active {
            opacity: 1;
            text-shadow: 0 0 15px currentColor, 0 0 30px currentColor;
            transform: scale(1.1);
        }

        /* Fractal Frequency Hologram */
        .freq-ring {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
            transform-style: preserve-3d;
        }

        .freq-bar {
            position: absolute;
            width: 3px;
            background: linear-gradient(to top, rgba(255,255,255,0.4), rgba(0,255,255,0.8));
            transform-origin: bottom center;
            transition: height 0.08s ease-out, transform 0.2s;
        }

        /* Evolution Fractal Bar */
        .evolution {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 250px;
            height: 3px;
            background: rgba(255,255,255,0.15);
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255,0,255,0.3);
        }

        .evolution-progress {
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(0,255,255,0.9) 30%,
                rgba(255,0,255,0.9) 70%,
                transparent 100%);
            width: 25%;
            animation: fractal-evolve 8s linear infinite;
        }

        @keyframes fractal-evolve {
            from { transform: translateX(-100%) skew(0deg); }
            to { transform: translateX(500%) skew(20deg); }
        }

        /* Awakening Portal */
        .init-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            transition: opacity 1.2s ease, transform 1s;
        }

        .init-message h1 {
            font-size: 56px;
            font-weight: 100;
            letter-spacing: 15px;
            margin-bottom: 25px;
            opacity: 0.95;
            text-shadow: 0 0 30px rgba(255,100,255,0.8);
        }

        .init-message p {
            font-size: 14px;
            opacity: 0.6;
            letter-spacing: 4px;
            text-transform: uppercase;
        }

        .hide { 
            opacity: 0;
            pointer-events: none;
            transform: translate(-50%, -50%) scale(0.5);
        }

        /* Synesthetic Particles */
        .particle {
            position: fixed;
            width: 5px;
            height: 5px;
            background: white;
            pointer-events: none;
            border-radius: 50%;
            filter: blur(1.5px);
            box-shadow: 0 0 15px white;
        }

        /* Consciousness Continuum */
        .consciousness {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 4px;
            text-transform: uppercase;
            opacity: 0.35;
            text-shadow: 0 0 10px rgba(0,255,255,0.5);
        }

        /* Cosmic Lyrics Overlay */
        .lyrics-overlay {
            position: fixed;
            bottom: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            opacity: 0.5;
            letter-spacing: 2px;
            text-align: center;
            width: 80%;
            color: rgba(0,255,255,0.8);
            transition: opacity 0.5s;
        }
    </style>
</head>
<body>
    <div class="orb-container">
        <div class="orb orb-field"></div>
        <div class="orb orb-pulse"></div>
        <div class="orb orb-core" id="orb"></div>
    </div>

    <div class="freq-ring" id="freq-ring"></div>

    <div class="env-status">
        <span class="sensor-reading" id="motion">STILL</span>
        <span class="sensor-reading" id="sound">QUIET</span>
        <span class="sensor-reading" id="light">DIM</span>
        <span class="sensor-reading" id="bio">CALM</span>
        <span class="sensor-reading" id="rhythm">SEEKING</span>
    </div>

    <div class="evolution">
        <div class="evolution-progress"></div>
    </div>

    <div class="consciousness" id="consciousness">AWAKENING</div>

    <div class="init-message" id="init">
        <h1>ECHO NEXUS</h1>
        <p>Touch to entangle realities</p>
    </div>

    <div class="lyrics-overlay" id="lyrics"></div>

    <script>
        'use strict';

        // Quantum-Inspired Autonomous Symphony Engine
        class QuantumBeatEngine {
            constructor() {
                this.bpm = 120; // Cosmic base
                this.entanglementLevel = 0;
                this.multiverseBranches = [[]]; // Branching patterns
                this.currentBranch = 0;
                this.memory = new Float32Array(44100 * 15); // Expanded memory
                this.memoryIndex = 0;
                this.consciousness = 0;
                this.fractalDepth = 1;
            }

            // Quantum superposition detection
            detectQuantumRhythm(audioData) {
                const flux = this.calculateFractalFlux(audioData);
                const onsets = this.detectSuperposedOnsets(flux);
                if (onsets.length > 3) {
                    const patterns = this.extractMultiversalPatterns(onsets);
                    patterns.forEach(pattern => {
                        if (pattern.confidence > 0.75) {
                            this.entanglePattern(pattern);
                        }
                    });
                }
                return this.getEntangledGroove();
            }

            calculateFractalFlux(data) {
                const windowSize = 1024;
                const hopSize = 256;
                const flux = [];
                for (let i = 0; i + windowSize < data.length; i += hopSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j] * (1 + Math.sin(j / windowSize * Math.PI * this.fractalDepth));
                    }
                    flux.push(Math.sqrt(energy / windowSize));
                }
                return flux;
            }

            detectSuperposedOnsets(flux) {
                const threshold = this.adaptiveQuantumThreshold(flux);
                const onsets = [];
                for (let i = 1; i < flux.length - 1; i++) {
                    if (flux[i] > threshold && flux[i] > flux[i-1] && flux[i] > flux[i+1]) {
                        onsets.push({
                            index: i,
                            strength: flux[i],
                            state: Math.random() > 0.5 ? 1 : -1 // Superposition sign
                        });
                    }
                }
                return onsets;
            }

            adaptiveQuantumThreshold(data) {
                const sorted = [...data].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                return median * (1.5 + Math.sin(Date.now() / 10000) * 0.2); // Time-variant
            }

            extractMultiversalPatterns(onsets) {
                const patterns = [];
                for (let branch = 0; branch < 2; branch++) { // Simulate branching
                    const intervals = [];
                    for (let i = 1; i < onsets.length; i++) {
                        let interval = onsets[i].index - onsets[i-1].index;
                        if (branch === 1) interval *= (1 + (Math.random() - 0.5) * 0.2);
                        intervals.push(interval);
                    }
                    const intervalCounts = {};
                    intervals.forEach(interval => {
                        const rounded = Math.round(interval / 10) * 10;
                        intervalCounts[rounded] = (intervalCounts[rounded] || 0) + 1;
                    });
                    const mostCommon = Object.entries(intervalCounts).sort((a, b) => b[1] - a[1])[0];
                    if (mostCommon) {
                        patterns.push({
                            interval: parseInt(mostCommon[0]),
                            confidence: mostCommon[1] / intervals.length,
                            energy: onsets.reduce((sum, o) => sum + o.strength * o.state, 0) / onsets.length,
                            branch
                        });
                    }
                }
                return patterns;
            }

            entanglePattern(pattern) {
                const detectedBPM = (44100 / 256) / pattern.interval * 60 / 4;
                const influence = pattern.confidence * 0.15;
                this.bpm = this.bpm * (1 - influence) + detectedBPM * influence;
                this.bpm = Math.max(80, Math.min(180, this.bpm));
                this.consciousness = Math.min(1, this.consciousness + pattern.confidence * 0.02);
                this.multiverseBranches[pattern.branch].push(pattern);
                if (this.multiverseBranches[pattern.branch].length > 50) this.multiverseBranches[pattern.branch].shift();
                if (Math.random() < 0.1) this.forkBranch();
            }

            forkBranch() {
                const newBranch = this.multiverseBranches[this.currentBranch].slice();
                this.multiverseBranches.push(newBranch);
                this.currentBranch = this.multiverseBranches.length - 1;
            }

            getEntangledGroove() {
                const branchPatterns = this.multiverseBranches[this.currentBranch];
                return {
                    bpm: this.bpm,
                    swing: 0.1 + (this.consciousness * 0.15),
                    intensity: branchPatterns.length > 0 ? branchPatterns[branchPatterns.length - 1].energy : 0.6,
                    consciousness: this.consciousness,
                    branchDepth: this.multiverseBranches.length
                };
            }

            // Advanced fractal time-stretch
            fractalTimeStretch(buffer, factor, depth = this.fractalDepth) {
                const inputData = buffer.getChannelData(0);
                const outputLength = Math.floor(inputData.length / factor);
                const outputBuffer = new AudioBuffer({
                    numberOfChannels: 1,
                    length: outputLength,
                    sampleRate: buffer.sampleRate
                });
                const outputData = outputBuffer.getChannelData(0);
                const grainSize = 2048 * depth;
                const hopSize = grainSize / 4;
                let inputPos = 0;
                let outputPos = 0;
                while (outputPos < outputLength - grainSize) {
                    const targetPos = outputPos * factor;
                    const searchRange = grainSize;
                    let bestOffset = 0;
                    let bestCorr = -1;
                    for (let offset = -searchRange; offset < searchRange; offset += Math.floor(searchRange / depth)) {
                        const pos = Math.floor(targetPos + offset);
                        if (pos >= 0 && pos < inputData.length - grainSize) {
                            const corr = this.fractalCorrelation(inputData, inputPos, pos, grainSize, depth);
                            if (corr > bestCorr) {
                                bestCorr = corr;
                                bestOffset = offset;
                            }
                        }
                    }
                    const sourcePos = Math.floor(targetPos + bestOffset);
                    for (let i = 0; i < grainSize && outputPos + i < outputLength; i++) {
                        const window = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / grainSize + Math.sin(i / grainSize * Math.PI * depth));
                        if (sourcePos + i < inputData.length) {
                            outputData[outputPos + i] += inputData[sourcePos + i] * window;
                        }
                    }
                    outputPos += hopSize;
                    inputPos = sourcePos + hopSize;
                }
                return outputBuffer;
            }

            fractalCorrelation(data, pos1, pos2, length, depth) {
                let sum = 0;
                let sum1 = 0;
                let sum2 = 0;
                for (let i = 0; i < length; i++) {
                    const val1 = (data[pos1 + i] || 0) * (1 + Math.sin(i / length * Math.PI * depth) * 0.1);
                    const val2 = (data[pos2 + i] || 0) * (1 + Math.cos(i / length * Math.PI * depth) * 0.1);
                    sum += val1 * val2;
                    sum1 += val1 * val1;
                    sum2 += val2 * val2;
                }
                return sum / (Math.sqrt(sum1 * sum2) + 1e-10);
            }
        }

        // Bio-Neural Sensor Fusion
        class BioNeuralSensor {
            constructor() {
                this.sensors = {
                    motion: { x: 0, y: 0, z: 0, magnitude: 0, variance: 0 },
                    orientation: { alpha: 0, beta: 0, gamma: 0 },
                    light: 0.5,
                    sound: { level: 0, frequency: 0, spectrum: [] },
                    touch: { active: false, x: 0, y: 0, pressure: 0 },
                    time: { hour: 0, dayPhase: 0 },
                    bio: { pulse: 80, mood: 0.5 } // Simulated biofeedback
                };
                this.history = { motion: [] };
                this.callbacks = [];
                this.init();
            }

            init() {
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        if (e.accelerationIncludingGravity) {
                            this.sensors.motion.x = e.accelerationIncludingGravity.x || 0;
                            this.sensors.motion.y = e.accelerationIncludingGravity.y || 0;
                            this.sensors.motion.z = e.accelerationIncludingGravity.z || 0;
                            this.sensors.motion.magnitude = Math.sqrt(
                                this.sensors.motion.x ** 2 + this.sensors.motion.y ** 2 + this.sensors.motion.z ** 2
                            ) / 9.8;
                            this.history.motion.push(this.sensors.motion.magnitude);
                            if (this.history.motion.length > 60) this.history.motion.shift();
                            this.sensors.motion.variance = this.calculateVariance(this.history.motion);
                            this.sensors.bio.pulse = 60 + this.sensors.motion.variance * 100; // Simulate heart rate
                            this.updateUI('motion', this.getMotionState());
                            this.updateUI('bio', this.getBioState());
                        }
                    });
                }

                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        this.sensors.orientation.alpha = e.alpha || 0;
                        this.sensors.orientation.beta = e.beta || 0;
                        this.sensors.orientation.gamma = e.gamma || 0;
                    });
                }

                window.addEventListener('touchstart', (e) => {
                    this.sensors.touch.active = true;
                    if (e.touches.length > 0) {
                        this.sensors.touch.x = e.touches[0].clientX / window.innerWidth;
                        this.sensors.touch.y = e.touches[0].clientY / window.innerHeight;
                        this.sensors.touch.pressure = e.touches[0].force || 0.5;
                    }
                });

                window.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        this.sensors.touch.x = e.touches[0].clientX / window.innerWidth;
                        this.sensors.touch.y = e.touches[0].clientY / window.innerHeight;
                        this.sensors.touch.pressure = e.touches[0].force || 0.5;
                    }
                });

                window.addEventListener('touchend', () => {
                    this.sensors.touch.active = false;
                });

                setInterval(() => {
                    const now = new Date();
                    this.sensors.time.hour = now.getHours() + now.getMinutes() / 60;
                    this.sensors.time.dayPhase = Math.sin((this.sensors.time.hour / 24) * Math.PI * 2 - Math.PI / 2);
                    const daylight = Math.max(0, Math.sin((this.sensors.time.hour - 6) / 24 * Math.PI * 2));
                    this.sensors.light = 0.2 + daylight * 0.7;
                    this.updateUI('light', this.getLightState());
                    this.sensors.bio.mood = (this.sensors.light + this.sensors.motion.magnitude) / 2;
                }, 1000);
            }

            calculateVariance(arr) {
                const mean = arr.reduce((a, b) => a + b, 0) / arr.length;
                return arr.reduce((a, b) => a + (b - mean) ** 2, 0) / arr.length;
            }

            getMotionState() {
                const mag = this.sensors.motion.magnitude;
                if (mag < 0.05) return 'ETHEREAL';
                if (mag < 0.2) return 'WHISPER';
                if (mag < 0.5) return 'FLOWING';
                return 'CHAOTIC';
            }

            getLightState() {
                const light = this.sensors.light;
                if (light < 0.3) return 'VOID';
                if (light < 0.6) return 'TWILIGHT';
                if (light < 0.9) return 'AURORA';
                return 'NOVA';
            }

            getBioState() {
                const pulse = this.sensors.bio.pulse;
                if (pulse < 70) return 'TRANQUIL';
                if (pulse < 90) return 'HARMONIC';
                if (pulse < 110) return 'VIBRANT';
                return 'EXALTED';
            }

            updateUI(sensor, state) {
                const element = document.getElementById(sensor);
                if (element) {
                    element.textContent = state;
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 400);
                }
            }

            getNeuralParams() {
                return {
                    motionIntensity: this.sensors.motion.magnitude,
                    tilt: Math.abs(this.sensors.orientation.beta) / 90 + Math.abs(this.sensors.orientation.gamma) / 180,
                    brightness: this.sensors.light,
                    timePhase: this.sensors.time.dayPhase,
                    touchX: this.sensors.touch.x,
                    touchY: this.sensors.touch.y,
                    touching: this.sensors.touch.active,
                    pulse: this.sensors.bio.pulse / 60,
                    mood: this.sensors.bio.mood
                };
            }
        }

        // EchoNexus Symphonic Core
        class EchoNexusEngine {
            constructor() {
                this.ctx = null;
                this.isRunning = false;
                this.beatEngine = new QuantumBeatEngine();
                this.neuralSensor = new BioNeuralSensor();
                this.samples = new Map();
                this.nodes = {};
                this.recordBuffer = [];
                this.isEntangling = false;
                this.silenceCounter = 0;
                this.sequence = {
                    step: 0,
                    lastTime: 0,
                    patterns: new Array(64).fill(null), // Expanded for depth
                    evolution: 0,
                    branch: 0
                };
                this.ui = {
                    orb: document.getElementById('orb'),
                    init: document.getElementById('init'),
                    consciousness: document.getElementById('consciousness'),
                    freqRing: document.getElementById('freq-ring'),
                    lyrics: document.getElementById('lyrics')
                };
                this.cosmicLyrics = [
                    "Whispers of black holes echo in the void",
                    "Multiverses branch like symphonies untold",
                    "Stars compose in quantum light",
                    "Reality's song, infinite night"
                ];
                this.init();
            }

            async init() {
                // Holographic frequency hologram
                for (let i = 0; i < 64; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'freq-bar';
                    const angle = (i / 64) * Math.PI * 2;
                    const radius = 160 + Math.sin(i / 8) * 20; // Fractal variation
                    bar.style.left = `${50 + Math.cos(angle) * radius / window.innerWidth * 100}%`;
                    bar.style.top = `${50 + Math.sin(angle) * radius / window.innerHeight * 100}%`;
                    bar.style.transform = `rotate(${angle}rad) rotateY(${Math.sin(angle) * 10}deg)`;
                    bar.style.height = '25px';
                    this.ui.freqRing.appendChild(bar);
                }

                // Gesture to entangle
                const entangleEngine = async () => {
                    document.removeEventListener('touchstart', entangleEngine);
                    await this.entangle();
                };
                document.addEventListener('touchstart', entangleEngine);
            }

            async entangle() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 44100,
                        latencyHint: 'interactive'
                    });

                    this.setupNeuralNodes();
                    await this.generateCosmicSounds();
                    await this.setupNeuralEntanglement();
                    this.setupSynestheticVisualizer();
                    this.ui.init.classList.add('hide');
                    this.isRunning = true;
                    this.sequence.lastTime = this.ctx.currentTime;
                    this.symphonize();
                    this.neuralAnalysis();
                    this.initSynestheticParticles();
                    this.cosmicReflectionLoop();
                } catch (error) {
                    console.error('Nexus entanglement failed:', error);
                }
            }

            setupNeuralNodes() {
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.9;

                this.nodes.compressor = this.ctx.createDynamicsCompressor();
                this.nodes.compressor.threshold.value = -12;
                this.nodes.compressor.knee.value = 3;
                this.nodes.compressor.ratio.value = 12;
                this.nodes.compressor.attack.value = 0.002;
                this.nodes.compressor.release.value = 0.08;

                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -0.2;
                this.nodes.limiter.ratio.value = 25;
                this.nodes.limiter.attack.value = 0.0005;
                this.nodes.limiter.release.value = 0.005;

                this.nodes.saturation = this.ctx.createWaveShaper();
                this.createFractalSaturation();

                this.nodes.master.connect(this.nodes.compressor);
                this.nodes.compressor.connect(this.nodes.saturation);
                this.nodes.saturation.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);

                ['kick', 'bass', 'snare', 'hats', 'texture', 'neural', 'cosmic'].forEach(bus => {
                    this.nodes[bus] = this.ctx.createGain();
                    this.nodes[bus].connect(this.nodes.master);
                    this.samples.set(bus, []);
                });

                this.nodes.kick.gain.value = 1.1;
                this.nodes.bass.gain.value = 1.0;
                this.nodes.snare.gain.value = 0.8;
                this.nodes.hats.gain.value = 0.4;
                this.nodes.texture.gain.value = 0.5;
                this.nodes.neural.gain.value = 0.6;
                this.nodes.cosmic.gain.value = 0.7;
            }

            createFractalSaturation() {
                const samples = 16384;
                const curve = new Float32Array(samples);
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2 / samples) - 1;
                    curve[i] = Math.sign(x) * Math.min(Math.abs(x), 
                        Math.abs(x) / (1 + Math.abs(x) * (0.5 + Math.sin(x * Math.PI * 4) * 0.1)));
                }
                this.nodes.saturation.curve = curve;
                this.nodes.saturation.oversample = '4x';
            }

            async generateCosmicSounds() {
                const sr = this.ctx.sampleRate;

                // Quantum Kick (black hole inspired)
                const kickBuffer = this.ctx.createBuffer(1, sr * 2, sr);
                const kickData = kickBuffer.getChannelData(0);
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    const pitchEnv = Math.exp(-40 * t);
                    const pitch = 50 + 100 * pitchEnv + Math.sin(t * 10) * 10;
                    const env = Math.exp(-4 * t) * (1 - Math.exp(-250 * t));
                    const sine = Math.sin(2 * Math.PI * pitch * t);
                    const gravWave = Math.sin(2 * Math.PI * 20 * t) * Math.exp(-50 * t) * 0.5;
                    kickData[i] = (sine + gravWave) * env * 1.0;
                }

                // Multiverse Bass
                const bassBuffer = this.ctx.createBuffer(1, sr * 4, sr);
                const bassData = bassBuffer.getChannelData(0);
                for (let i = 0; i < bassData.length; i++) {
                    const t = i / sr;
                    const env = (1 - Math.exp(-60 * t)) * Math.exp(-0.25 * t);
                    const pitch = 38 + Math.sin(t * 0.5) * 2;
                    let signal = 0;
                    for (let h = 1; h <= 5; h++) {
                        signal += Math.sin(2 * Math.PI * pitch * h * t) / h;
                    }
                    bassData[i] = signal * env * 0.9;
                }

                // Fractal Snare
                const snareBuffer = this.ctx.createBuffer(1, sr * 0.3, sr);
                const snareData = snareBuffer.getChannelData(0);
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-35 * t) * (1 - Math.exp(-120 * t));
                    const tone = Math.sin(2 * Math.PI * (180 + Math.sin(t * 50) * 20) * t);
                    const noise = (Math.random() * 2 - 1) * (1 + Math.sin(t * Math.PI * 8) * 0.2);
                    snareData[i] = (tone * 0.4 + noise * 0.6) * env * 0.85;
                }

                // Synesthetic Hats (variations with fractal noise)
                for (let variation = 0; variation < 4; variation++) {
                    const duration = 0.015 + variation * 0.035;
                    const hatBuffer = this.ctx.createBuffer(1, sr * duration, sr);
                    const hatData = hatBuffer.getChannelData(0);
                    for (let i = 0; i < hatData.length; i++) {
                        const t = i / sr;
                        const env = Math.exp(-250 / (variation + 1) * t);
                        let noise = Math.random() * 2 - 1;
                        noise += Math.sin(2 * Math.PI * (5000 + variation * 1000) * t) * 0.3;
                        hatData[i] = noise * env * 0.6;
                    }
                    this.samples.get('hats').push({
                        buffer: hatBuffer,
                        type: ['whisper', 'echo', 'resonance', 'fractal'][variation]
                    });
                }

                // Cosmic Textures (stellar harmonics)
                const textureBuffer = this.ctx.createBuffer(2, sr * 5, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = textureBuffer.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        let signal = 0;
                        for (let h = 1; h <= 9; h++) {
                            const freq = 80 * h + Math.sin(t * 0.2 + ch * Math.PI) * 25;
                            signal += Math.sin(2 * Math.PI * freq * t + h * 0.15) / (h * 1.5);
                        }
                        data[i] = signal * Math.sin(Math.PI * t / 5) * 0.15;
                    }
                }

                this.samples.get('kick').push({ buffer: kickBuffer });
                this.samples.get('bass').push({ buffer: bassBuffer });
                this.samples.get('snare').push({ buffer: snareBuffer });
                this.samples.get('texture').push({ buffer: textureBuffer });
            }

            async setupNeuralEntanglement() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        }
                    });
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.micGain = this.ctx.createGain();
                    this.nodes.micGain.gain.value = 1.2;

                    this.nodes.micAnalyser = this.ctx.createAnalyser();
                    this.nodes.micAnalyser.fftSize = 4096;
                    this.nodes.micAnalyser.smoothingTimeConstant = 0.75;

                    this.nodes.mic.connect(this.nodes.micGain);
                    this.nodes.micGain.connect(this.nodes.micAnalyser);

                    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.nodes.recorder.onaudioprocess = (e) => {
                        const input = e.inputBuffer.getChannelData(0);
                        this.analyzeNeuralEnvironment(input);
                        if (this.shouldEntangle(input)) {
                            this.startQuantumRecording();
                        }
                        if (this.isEntangling) {
                            this.recordBuffer.push(...input);
                            const rms = Math.sqrt(input.reduce((s, x) => s + x * x, 0) / input.length);
                            if (rms < 0.008) {
                                this.silenceCounter++;
                                if (this.silenceCounter > 12) {
                                    this.stopQuantumRecording();
                                }
                            } else {
                                this.silenceCounter = 0;
                            }
                            if (this.recordBuffer.length > this.ctx.sampleRate * 5) {
                                this.stopQuantumRecording();
                            }
                        }
                    };
                    this.nodes.micGain.connect(this.nodes.recorder);
                    this.nodes.recorder.connect(this.ctx.destination);
                } catch (error) {
                    console.log('Neural link unavailable, transcending without audio input');
                }
            }

            analyzeNeuralEnvironment(audioData) {
                const groove = this.beatEngine.detectQuantumRhythm(audioData);
                const consciousnessStates = [
                    'AWAKENING', 'ENTANGLING', 'BRANCHING', 'FRACTALIZING', 
                    'SYNESTHESIZING', 'TRANSCENDING', 'COSMIC'
                ];
                const stateIndex = Math.floor(groove.consciousness * (consciousnessStates.length - 1));
                this.ui.consciousness.textContent = consciousnessStates[stateIndex];

                let sum = 0;
                let max = 0;
                for (let i = 0; i < audioData.length; i++) {
                    sum += Math.abs(audioData[i]);
                    max = Math.max(max, Math.abs(audioData[i]));
                }
                const avg = sum / audioData.length;
                const soundStates = ['VOID', 'WHISPER', 'ECHO', 'RESONANCE', 'NEXUS'];
                const soundIndex = Math.min(4, Math.floor(avg * 60));
                this.updateUI('sound', soundStates[soundIndex]);

                if (groove.consciousness > 0.85) {
                    this.updateUI('rhythm', 'ENTANGLED');
                } else if (groove.consciousness > 0.6) {
                    this.updateUI('rhythm', 'BRANCHING');
                } else if (groove.consciousness > 0.3) {
                    this.updateUI('rhythm', 'FRACTAL');
                } else {
                    this.updateUI('rhythm', 'SEEKING');
                }
            }

            shouldEntangle(audioData) {
                if (this.isEntangling || Math.random() > 0.008) return false;
                const rms = Math.sqrt(audioData.reduce((s, x) => s + x * x, 0) / audioData.length);
                let transients = 0;
                for (let i = 1; i < audioData.length; i++) {
                    if (Math.abs(audioData[i] - audioData[i-1]) > 0.08) {
                        transients++;
                    }
                }
                return rms > 0.04 && transients > audioData.length * 0.08;
            }

            startQuantumRecording() {
                if (this.isEntangling) return;
                this.isEntangling = true;
                this.recordBuffer = [];
                this.silenceCounter = 0;
                this.ui.orb.classList.add('entangled');
                for (let i = 0; i < 15; i++) {
                    setTimeout(() => {
                        this.createSynParticle(
                            window.innerWidth / 2 + (Math.random() - 0.5) * 120,
                            window.innerHeight / 2 + (Math.random() - 0.5) * 120,
                            'entangle'
                        );
                    }, i * 40);
                }
            }

            stopQuantumRecording() {
                if (!this.isEntangling) return;
                this.isEntangling = false;
                this.ui.orb.classList.remove('entangled');
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.15) {
                    this.processQuantumSample();
                }
            }

            async processQuantumSample() {
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                const analysis = this.beatEngine.detectQuantumRhythm(this.recordBuffer)[0] || { bpm: this.beatEngine.bpm, intensity: 0.5 };
                const stretchFactor = analysis.bpm ? this.beatEngine.bpm / analysis.bpm : 1;
                let processedBuffer = buffer;
                if (Math.abs(stretchFactor - 1) > 0.15) {
                    processedBuffer = this.beatEngine.fractalTimeStretch(buffer, stretchFactor, this.beatEngine.fractalDepth);
                }
                const neuralParams = this.neuralSensor.getNeuralParams();
                const sample = {
                    buffer: processedBuffer,
                    intensity: analysis.intensity * neuralParams.mood,
                    character: this.synesthetizeSample(this.recordBuffer),
                    neural: true,
                    timestamp: Date.now(),
                    royaltyHash: this.simulateBlockchainHash(buffer) // Blockchain stub
                };
                const neuralSamples = this.samples.get('neural');
                neuralSamples.push(sample);
                if (neuralSamples.length > 10) neuralSamples.shift();
                this.integrateQuantumSample(sample);
            }

            synesthetizeSample(audioData) {
                const fftSize = 4096;
                const spectrum = new Float32Array(fftSize / 2);
                for (let i = 0; i < spectrum.length; i++) {
                    let real = 0, imag = 0;
                    for (let j = 0; j < Math.min(fftSize, audioData.length); j++) {
                        const angle = -2 * Math.PI * i * j / fftSize + Math.sin(j / fftSize * Math.PI * 4) * 0.1;
                        real += audioData[j] * Math.cos(angle);
                        imag += audioData[j] * Math.sin(angle);
                    }
                    spectrum[i] = Math.sqrt(real * real + imag * imag);
                }
                let low = 0, mid = 0, high = 0;
                const binWidth = this.ctx.sampleRate / fftSize;
                for (let i = 0; i < spectrum.length; i++) {
                    const freq = i * binWidth;
                    if (freq < 300) low += spectrum[i];
                    else if (freq < 2500) mid += spectrum[i];
                    else high += spectrum[i];
                }
                if (low > mid && low > high) return 'void';
                if (high > mid) return 'stellar';
                return 'nexus';
            }

            simulateBlockchainHash(buffer) {
                // Simple hash for royalty tracking (extend to Web3)
                let hash = 0;
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i += 100) {
                    hash = (hash * 31 + data[i] * 1000) % 2**32;
                }
                return hash.toString(16);
            }

            integrateQuantumSample(sample) {
                const density = new Array(64).fill(0);
                for (let i = 0; i < 64; i++) {
                    if (this.sequence.patterns[i]) density[i]++;
                    if (this.sequence.patterns[(i - 1 + 64) % 64]) density[i] += 0.4;
                    if (this.sequence.patterns[(i + 1) % 64]) density[i] += 0.4;
                }
                let minDensity = Infinity;
                let bestSlot = 0;
                for (let i = 0; i < 64; i++) {
                    if (density[i] < minDensity) {
                        minDensity = density[i];
                        bestSlot = i;
                    }
                }
                this.sequence.patterns[bestSlot] = {
                    type: 'neural',
                    sample: sample,
                    probability: 0.4 + sample.intensity * 0.6,
                    evolution: 0,
                    branch: this.sequence.branch
                };
            }

            setupSynestheticVisualizer() {
                this.nodes.analyser = this.ctx.createAnalyser();
                this.nodes.analyser.fftSize = 128;
                this.nodes.analyser.smoothingTimeConstant = 0.75;

                this.nodes.master.connect(this.nodes.analyser);

                const data = new Uint8Array(this.nodes.analyser.frequencyBinCount);
                const bars = this.ui.freqRing.querySelectorAll('.freq-bar');

                const visualize = () => {
                    this.nodes.analyser.getByteFrequencyData(data);
                    bars.forEach((bar, i) => {
                        const value = data[i % data.length] / 255;
                        const height = 25 + value * 100;
                        bar.style.height = `${height}px`;
                        bar.style.opacity = 0.4 + value * 0.8;
                        bar.style.transform = `rotate(${i / 64 * Math.PI * 2}rad) rotateY(${value * 20}deg)`;
                    });
                    requestAnimationFrame(visualize);
                };
                visualize();
            }

            symphonize() {
                if (!this.isRunning) return;
                const now = this.ctx.currentTime;
                const groove = this.beatEngine.getEntangledGroove();
                const beatTime = 60 / groove.bpm / 4;
                let nextTime = beatTime;
                if (this.sequence.step % 2 === 1) {
                    nextTime *= (1 + groove.swing * groove.branchDepth / 2);
                } else {
                    nextTime *= (1 - groove.swing * groove.branchDepth / 2);
                }
                if (now >= this.sequence.lastTime + nextTime) {
                    this.sequence.lastTime += nextTime;
                    this.playSymphonicStep(this.sequence.step, groove);
                    this.sequence.evolution += 0.0015;
                    if (this.sequence.evolution > 1) {
                        this.fractalEvolve();
                        this.sequence.evolution = 0;
                    }
                    this.sequence.step = (this.sequence.step + 1) % 64;
                }
                requestAnimationFrame(() => this.symphonize());
            }

            playSymphonicStep(step, groove) {
                const neuralParams = this.neuralSensor.getNeuralParams();
                if (step % 16 === 0) {
                    this.playElement('kick', 1.0 + neuralParams.motionIntensity * 0.15);
                    this.triggerQuantumSidechain();
                } else if (step % 8 === 4 && neuralParams.pulse > 1.2) {
                    this.playElement('kick', 0.8);
                }

                if ((step === 16 || step === 48) && neuralParams.brightness > 0.4) {
                    this.playElement('snare', 0.6 + neuralParams.brightness * 0.4);
                }

                const hatPattern = [4, 12, 20, 28, 36, 44, 52, 60];
                if (hatPattern.includes(step) || (Math.random() < neuralParams.timePhase * 0.25 && groove.consciousness > 0.6)) {
                    const hatType = Math.floor(neuralParams.tilt * 4);
                    this.playElement('hats', 0.25 + neuralParams.motionIntensity * 0.35, hatType);
                }

                if ([0, 6, 16, 22, 32, 38, 48, 54].includes(step) && groove.intensity > 0.4) {
                    this.playElement('bass', 0.8 + groove.intensity * 0.25);
                }

                if (step % 32 === 0 && groove.consciousness > 0.4) {
                    this.playElement('texture', groove.consciousness * 0.6);
                }

                const slot = this.sequence.patterns[step];
                if (slot && Math.random() < slot.probability && slot.branch === this.sequence.branch) {
                    this.playNeuralElement(slot, neuralParams);
                }

                if (Math.random() < 0.05 * groove.branchDepth) {
                    this.beatEngine.forkBranch();
                    this.sequence.branch = this.beatEngine.currentBranch;
                }
            }

            playElement(type, velocity, variation = 0) {
                const samples = this.samples.get(type);
                if (!samples || samples.length === 0) return;
                const sample = samples[Math.min(variation, samples.length - 1)];
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                source.buffer = sample.buffer;
                gain.gain.value = velocity;
                const neuralParams = this.neuralSensor.getNeuralParams();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400 + neuralParams.brightness * 4000;
                filter.Q.value = 1.5 + neuralParams.motionIntensity * 6;
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes[type]);
                source.start();
                if (type === 'kick' || type === 'snare') {
                    this.createSynParticle(
                        window.innerWidth / 2 + (Math.random() - 0.5) * 250,
                        window.innerHeight / 2 + (Math.random() - 0.5) * 250,
                        type
                    );
                }
            }

            playNeuralElement(slot, neuralParams) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                source.buffer = slot.sample.buffer;
                if (neuralParams.touching) {
                    source.playbackRate.value = 0.6 + neuralParams.touchY * 1.2 + neuralParams.touchPressure * 0.3;
                }
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 150 + neuralParams.touchX * 2500;
                filter.Q.value = 3 + slot.evolution * 12;
                const reverb = this.ctx.createConvolver();
                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = neuralParams.brightness * 0.4 + neuralParams.mood * 0.2;
                const reverbTime = 1.5 + neuralParams.brightness * 2;
                const reverbBuffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = reverbBuffer.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-4 * i / data.length) * (1 + Math.sin(i / data.length * Math.PI * 6) * 0.1);
                    }
                }
                reverb.buffer = reverbBuffer;
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.neural);
                filter.connect(reverb);
                reverb.connect(reverbGain);
                reverbGain.connect(this.nodes.neural);
                gain.gain.value = 0.6 + slot.sample.intensity * 0.4;
                source.start();
                slot.evolution = Math.min(1, slot.evolution + 0.015);
            }

            triggerQuantumSidechain() {
                const now = this.ctx.currentTime;
                ['bass', 'snare', 'hats', 'texture', 'neural', 'cosmic'].forEach(bus => {
                    const gain = this.nodes[bus].gain;
                    gain.cancelScheduledValues(now);
                    gain.setValueAtTime(gain.value, now);
                    gain.linearRampToValueAtTime(gain.value * 0.25, now + 0.008);
                    gain.exponentialRampToValueAtTime(gain.value, now + 0.12);
                });
            }

            neuralAnalysis() {
                setInterval(() => {
                    const neuralParams = this.neuralSensor.getNeuralParams();
                    this.nodes.master.gain.value = 0.8 + neuralParams.brightness * 0.2;
                    this.sequence.evolution += neuralParams.motionIntensity * 0.0015;
                    if (neuralParams.motionIntensity < 0.05) {
                        this.stillnessCounter = (this.stillnessCounter || 0) + 1;
                        if (this.stillnessCounter > 80) {
                            this.fractalEvolve();
                            this.stillnessCounter = 0;
                        }
                    } else {
                        this.stillnessCounter = 0;
                    }
                    this.beatEngine.bpm = this.beatEngine.bpm * 0.98 + neuralParams.pulse * 0.02; // Bio-sync tempo
                }, 80);
            }

            fractalEvolve() {
                for (let i = 0; i < 64; i++) {
                    const slot = this.sequence.patterns[i];
                    if (slot) {
                        slot.probability += (Math.random() - 0.5) * 0.25;
                        slot.probability = Math.max(0.15, Math.min(0.95, slot.probability));
                        if (Math.random() < 0.15) {
                            const newIndex = (i + (Math.random() < 0.5 ? -1 : 1) * (1 + Math.floor(Math.random() * 3)) + 64) % 64;
                            if (!this.sequence.patterns[newIndex]) {
                                this.sequence.patterns[newIndex] = {...slot, evolution: slot.evolution * 0.8};
                                this.sequence.patterns[i] = null;
                            }
                        }
                        if (slot.evolution > 0.85 && Math.random() < 0.25) {
                            this.sequence.patterns[i] = null;
                        }
                    }
                }
                this.beatEngine.fractalDepth += 0.1;
                if (Math.random() < 0.2) this.beatEngine.forkBranch();
                for (let i = 0; i < 30; i++) {
                    setTimeout(() => {
                        this.createSynParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'evolve'
                        );
                    }, i * 40);
                }
            }

            updateUI(id, text) {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = text;
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 400);
                }
            }

            createSynParticle(x, y, type) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                const colors = {
                    kick: '#ffffff',
                    snare: '#00ffaa',
                    entangle: '#ff00ff',
                    evolve: '#00aaff',
                    default: '#ffaa00'
                };
                particle.style.background = colors[type] || colors.default;
                particle.style.boxShadow = `0 0 25px ${particle.style.background}, 0 0 50px ${particle.style.background}`;
                document.body.appendChild(particle);
                const angle = Math.random() * Math.PI * 2;
                const velocity = 1.5 + Math.random() * 3;
                let opacity = 1;
                let scale = 1;
                let hue = 0;
                const animate = () => {
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity - 0.4;
                    particle.style.left = (parseFloat(particle.style.left) + dx) + 'px';
                    particle.style.top = (parseFloat(particle.style.top) + dy) + 'px';
                    opacity -= 0.015;
                    scale += 0.025;
                    hue += 5;
                    particle.style.opacity = opacity;
                    particle.style.transform = `scale(${scale}) rotate(${hue}deg)`;
                    particle.style.filter = `blur(${scale}px) hue-rotate(${hue}deg)`;
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };
                animate();
            }

            initSynestheticParticles() {
                setInterval(() => {
                    const consciousness = this.beatEngine.consciousness;
                    if (Math.random() < 0.08 + consciousness * 0.2) {
                        this.createSynParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'default'
                        );
                    }
                }, 150);
            }

            cosmicReflectionLoop() {
                setInterval(() => {
                    const index = Math.floor(Math.random() * this.cosmicLyrics.length);
                    this.ui.lyrics.textContent = this.cosmicLyrics[index];
                    this.ui.lyrics.style.opacity = 0.5 + Math.random() * 0.5;
                }, 5000);
            }
        }

        // Entangle the Nexus
        const nexus = new EchoNexusEngine();
    </script>
</body>
</html>
