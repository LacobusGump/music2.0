<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: system-ui, sans-serif;
        }

        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            z-index: 100; cursor: pointer;
            background: #0a0a0f;
        }
        #enter.off { display: none; }
        #enter .circle {
            width: 120px; height: 120px;
            border-radius: 50%;
            border: 1px solid rgba(255,220,180,0.15);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        #enter:hover .circle { border-color: rgba(255,220,180,0.4); }
        #enter .inner {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(255,220,180,0.08);
        }

        #world {
            position: fixed; inset: 0;
            display: none;
            background: radial-gradient(ellipse at center, #12111a 0%, #0a0a0f 100%);
        }
        #world.on { display: block; }

        canvas { position: fixed; inset: 0; }

        #vibe {
            position: fixed; bottom: 40px; left: 0; right: 0;
            display: flex; justify-content: center; gap: 30px;
            z-index: 50;
        }
        .vibe-btn {
            font-size: 11px;
            color: rgba(255,220,180,0.25);
            background: none; border: none;
            padding: 12px 20px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .vibe-btn.on { color: rgba(255,220,180,0.9); }

        #pulse {
            position: fixed; top: 20px; left: 20px;
            font-size: 9px;
            color: rgba(255,220,180,0.4);
            letter-spacing: 1px;
            line-height: 1.8;
            font-family: monospace;
        }
        #mic-indicator {
            position: fixed; top: 20px; right: 20px;
            width: 10px; height: 10px;
            border-radius: 50%;
            background: rgba(255,100,100,0.2);
            transition: all 0.1s;
        }
        #mic-indicator.active {
            background: rgba(100,255,150,0.8);
            box-shadow: 0 0 10px rgba(100,255,150,0.5);
        }
    </style>
</head>
<body>

<div id="enter">
    <div class="circle"><div class="inner"></div></div>
</div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="vibe">
        <button class="vibe-btn on" data-vibe="dream">DREAM</button>
        <button class="vibe-btn" data-vibe="pulse">PULSE</button>
        <button class="vibe-btn" data-vibe="deep">DEEP</button>
    </div>
    <div id="pulse"></div>
    <div id="mic-indicator"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// GUMP - JAZZ ORCHESTRA
// AI agents that LISTEN to each other and create together.
// ═══════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ─────────────────────────────────────────────────────────────────
// GROQ AI - Each instrument has a mind
// ─────────────────────────────────────────────────────────────────

const _0x = [103,115,107,95,82,113,89,116,105,48,70,116,116,76,117,51,
             113,88,54,69,97,84,88,77,87,71,100,121,98,51,70,89,90,75,
             54,53,89,49,100,54,122,97,72,122,117,70,76,87,57,90,107,55,87,109,87];
let groqKey = String.fromCharCode.apply(null, _0x);

// ─────────────────────────────────────────────────────────────────
// THE STATE - What the world feels like right now
// ─────────────────────────────────────────────────────────────────

const world = {
    x: 0.5,           // Position 0-1
    y: 0.5,
    vx: 0,            // Velocity (for momentum)
    vy: 0,
    energy: 0,        // How much movement (0-1)
    stillness: 0,     // How long still (builds over time)
    time: 0,
    breath: 0,        // Slow oscillation for life
    pulse: 0,         // Fast pulse for rhythm
};

// The shared musical state - how agents "hear" each other
const bandState = {
    drums: { density: 0.5, lastFill: 0, energy: 0.5, pattern: 'steady', swing: 0.1 },
    bass: { register: 0, activity: 0.5, walking: false, lastNote: 0 },
    pad: { voicing: 'close', volume: 0.3, moving: false },
    lead: { active: false, register: 0.5, developing: false, motif: [], lastNote: 0 },

    recentEvents: [],  // What just happened
    tension: 0.5,      // 0-1 building or releasing
    direction: 'floating', // building, releasing, floating
    groove: 0.5,       // How locked in
    micInfluence: 0,   // External sound input
};

let vibe = 'dream';   // Current vibe: dream, pulse, deep
let ctx, master;      // Audio context
let canvas, vc;       // Visual canvas

// ─────────────────────────────────────────────────────────────────
// THE VIBES - Three completely different worlds
// ─────────────────────────────────────────────────────────────────

const VIBES = {
    dream: {
        bpm: 70,
        key: 0,           // C
        scale: [0, 2, 4, 7, 9],  // Pentatonic - universal
        bassOctave: 1,
        padWarmth: 0.8,
        reverbSize: 0.7,
        character: 'warm'
    },
    pulse: {
        bpm: 110,
        key: 5,           // F
        scale: [0, 3, 5, 7, 10],  // Minor pentatonic
        bassOctave: 2,
        padWarmth: 0.4,
        reverbSize: 0.4,
        character: 'driving'
    },
    deep: {
        bpm: 85,
        key: 7,           // G
        scale: [0, 2, 3, 5, 7, 9, 10],  // Dorian - jazzy
        bassOctave: 1,
        padWarmth: 0.6,
        reverbSize: 0.85,
        character: 'deep'
    }
};

// ─────────────────────────────────────────────────────────────────
// THE SOUND ENGINE - Immediate response to movement
// ─────────────────────────────────────────────────────────────────

let bassSynth, padSynth, leadSynth;
let masterGain, reverbGain, compressor, saturation, delayNode, delayGain;
let textureNode, textureGain;
let filterLFO, filterLFOGain, masterFilter;
let sidechain = 1;

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // ── SATURATION - Analog warmth ──
    saturation = ctx.createWaveShaper();
    const satCurve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        // Warm tape-style saturation
        satCurve[i] = Math.tanh(x * 1.5) * 0.9 + x * 0.1;
    }
    saturation.curve = satCurve;
    saturation.oversample = '4x';

    // ── MASTER FILTER - Movement tied to motion ──
    masterFilter = ctx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 18000;
    masterFilter.Q.value = 0.5;

    // Filter LFO for subtle movement
    filterLFO = ctx.createOscillator();
    filterLFO.type = 'sine';
    filterLFO.frequency.value = 0.1;
    filterLFOGain = ctx.createGain();
    filterLFOGain.gain.value = 500;
    filterLFO.connect(filterLFOGain);
    filterLFOGain.connect(masterFilter.frequency);
    filterLFO.start();

    // Master gain
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.85;

    // ── DELAY - Spatial depth ──
    delayNode = ctx.createDelay(1.0);
    delayNode.delayTime.value = 0.375;
    const delayFeedback = ctx.createGain();
    delayFeedback.gain.value = 0.3;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2500;
    delayGain = ctx.createGain();
    delayGain.gain.value = 0.2;

    delayNode.connect(delayFilter);
    delayFilter.connect(delayFeedback);
    delayFeedback.connect(delayNode);
    delayFilter.connect(delayGain);

    // ── REVERB - Space ──
    const reverbBuffer = createReverbBuffer(3.5);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.3;

    // ── COMPRESSOR - Glue ──
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -15;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.002;
    compressor.release.value = 0.1;
    compressor.knee.value = 6;

    // ── TEXTURE - Atmosphere ──
    initTexture();

    // ── ROUTING ──
    // Main path: masterGain -> saturation -> masterFilter -> compressor -> destination
    masterGain.connect(saturation);
    saturation.connect(masterFilter);
    masterFilter.connect(compressor);

    // FX sends
    masterGain.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);

    masterGain.connect(delayNode);
    delayGain.connect(compressor);

    compressor.connect(ctx.destination);

    // Load REAL drum samples
    await loadSamples();

    // Create synths
    initBass();
    initPad();
    initLead();

    // Initialize microphone input
    initMic();

    audioReady = true;
    console.log('Audio ready');
}

// ─────────────────────────────────────────────────────────────────
// MICROPHONE - The world becomes music
// ─────────────────────────────────────────────────────────────────

let micStream, micAnalyser, micData;
let micLevel = 0;
let micLow = 0, micMid = 0, micHigh = 0;  // Frequency bands
let micActive = false;
let micOnset = false;  // Sudden sound detected
let lastMicLevel = 0;

async function initMic() {
    try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const micSource = ctx.createMediaStreamSource(micStream);

        micAnalyser = ctx.createAnalyser();
        micAnalyser.fftSize = 512;
        micData = new Uint8Array(micAnalyser.frequencyBinCount);

        micSource.connect(micAnalyser);
        micActive = true;
        console.log('Mic active');
    } catch (e) {
        console.log('Mic not available:', e.message);
        micActive = false;
    }
}

function updateMic() {
    if (!micActive || !micAnalyser) return;

    micAnalyser.getByteFrequencyData(micData);

    // Split into frequency bands
    const binCount = micData.length;
    const lowEnd = Math.floor(binCount * 0.1);   // 0-10% = bass
    const midEnd = Math.floor(binCount * 0.5);   // 10-50% = mids

    let lowSum = 0, midSum = 0, highSum = 0, total = 0;

    for (let i = 0; i < binCount; i++) {
        const val = micData[i];
        total += val;
        if (i < lowEnd) lowSum += val;
        else if (i < midEnd) midSum += val;
        else highSum += val;
    }

    micLow = lowSum / lowEnd / 255;
    micMid = midSum / (midEnd - lowEnd) / 255;
    micHigh = highSum / (binCount - midEnd) / 255;
    micLevel = total / binCount / 255;

    // Detect sudden onsets (claps, taps, voice starts)
    micOnset = micLevel > lastMicLevel + 0.15 && micLevel > 0.1;
    lastMicLevel = micLevel * 0.9 + lastMicLevel * 0.1;  // Smooth

    // Update bandState for AI
    bandState.micInfluence = micLevel;
}

// ── TEXTURE LAYER - The room is never silent ──
function initTexture() {
    const bufferSize = ctx.sampleRate * 4;
    const noiseBuffer = ctx.createBuffer(2, bufferSize, ctx.sampleRate);

    for (let ch = 0; ch < 2; ch++) {
        const data = noiseBuffer.getChannelData(ch);
        for (let i = 0; i < bufferSize; i++) {
            // Subtle vinyl/tape texture
            const noise = (Math.random() * 2 - 1) * 0.015;
            const crackle = Math.random() < 0.0003 ? (Math.random() - 0.5) * 0.3 : 0;
            data[i] = noise + crackle;
        }
    }

    textureNode = ctx.createBufferSource();
    textureNode.buffer = noiseBuffer;
    textureNode.loop = true;

    const textureFilter = ctx.createBiquadFilter();
    textureFilter.type = 'bandpass';
    textureFilter.frequency.value = 3000;
    textureFilter.Q.value = 0.5;

    textureGain = ctx.createGain();
    textureGain.gain.value = 0.08;

    textureNode.connect(textureFilter);
    textureFilter.connect(textureGain);
    textureGain.connect(masterGain);
    textureNode.start();
}

function createReverbBuffer(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            // Exponential decay with early reflections
            const t = i / ctx.sampleRate;
            const decay = Math.exp(-t / (duration * 0.4));
            const diffusion = (Math.random() * 2 - 1);
            data[i] = diffusion * decay * 0.5;
        }
    }
    return buffer;
}

// ─────────────────────────────────────────────────────────────────
// DRUMS - REAL SAMPLES. Not synthesized garbage.
// ─────────────────────────────────────────────────────────────────

const SAMPLE_URLS = {
    kick: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
    snare: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    hat: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',
    hatOpen: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',
    rim: 'https://cdn.freesound.org/previews/398/398712_183766-lq.mp3',
    perc: 'https://cdn.freesound.org/previews/250/250537_4486188-lq.mp3'
};

let samples = {};
let samplesLoaded = false;

async function loadSamples() {
    const promises = Object.entries(SAMPLE_URLS).map(async ([name, url]) => {
        try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            samples[name] = await ctx.decodeAudioData(arrayBuffer);
            console.log(`Loaded: ${name}`);
        } catch (e) {
            console.error(`Failed to load ${name}:`, e);
            // Create fallback
            samples[name] = createFallbackBuffer(name);
        }
    });

    await Promise.all(promises);
    samplesLoaded = true;
    console.log('All samples loaded');
}

function createFallbackBuffer(name) {
    const length = ctx.sampleRate * 0.3;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    // Basic fallback - better than nothing
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / ctx.sampleRate;
            if (name === 'kick') {
                const pitch = 45 + 100 * Math.exp(-t * 35);
                data[i] = Math.sin(TAU * pitch * t) * Math.exp(-t * 8) * 0.8;
            } else {
                data[i] = (Math.random() * 2 - 1) * Math.exp(-t * 20) * 0.5;
            }
        }
    }
    return buffer;
}

function playDrum(name, volume = 1, pan = 0, pitch = 1) {
    if (!samples[name] || !ctx || !masterGain) return;

    try {
        const source = ctx.createBufferSource();
        source.buffer = samples[name];
        source.playbackRate.value = pitch;

        const gain = ctx.createGain();
        gain.gain.value = volume;

        const panner = ctx.createStereoPanner();
        panner.pan.value = pan;

        source.connect(gain);
        gain.connect(panner);
        panner.connect(masterGain);

        source.start(ctx.currentTime);

        // Trigger sidechain on kick
        if (name === 'kick') {
            sidechain = 0.25;
        }
    } catch (e) {
        console.error('playDrum error:', e);
    }
}

// ─────────────────────────────────────────────────────────────────
// BASS - The foundation. Felt more than heard.
// ─────────────────────────────────────────────────────────────────

let bassOsc, bassGain, bassFilter;

function initBass() {
    bassOsc = ctx.createOscillator();
    bassOsc.type = 'sine';
    bassOsc.frequency.value = 55;

    bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 200;
    bassFilter.Q.value = 1;

    bassGain = ctx.createGain();
    bassGain.gain.value = 0;

    bassOsc.connect(bassFilter);
    bassFilter.connect(bassGain);
    bassGain.connect(masterGain);

    bassOsc.start();
}

function playBassNote(note, velocity = 0.6, duration = 0.5) {
    if (!bassOsc || !ctx) return;

    const v = VIBES[vibe];
    const freq = 55 * Math.pow(2, (v.key + note) / 12) * v.bassOctave;

    const now = ctx.currentTime;

    // Frequency glide
    bassOsc.frequency.setTargetAtTime(freq, now, 0.02);

    // Envelope - punchy attack, smooth release
    bassGain.gain.cancelScheduledValues(now);
    bassGain.gain.setValueAtTime(bassGain.gain.value, now);
    bassGain.gain.linearRampToValueAtTime(velocity * 0.7 * sidechain, now + 0.01);
    bassGain.gain.linearRampToValueAtTime(velocity * 0.5 * sidechain, now + duration * 0.3);
    bassGain.gain.linearRampToValueAtTime(0.001, now + duration);

    // Filter opens with velocity
    bassFilter.frequency.setTargetAtTime(150 + velocity * 200, now, 0.01);
}

// ─────────────────────────────────────────────────────────────────
// PAD - The warmth. Responds to stillness.
// ─────────────────────────────────────────────────────────────────

let padOscs = [], padGain, padFilter;

function initPad() {
    padGain = ctx.createGain();
    padGain.gain.value = 0;

    padFilter = ctx.createBiquadFilter();
    padFilter.type = 'lowpass';
    padFilter.frequency.value = 800;
    padFilter.Q.value = 0.5;

    // 4 oscillators for rich pad
    for (let i = 0; i < 4; i++) {
        const osc = ctx.createOscillator();
        osc.type = i % 2 === 0 ? 'sine' : 'triangle';
        osc.frequency.value = 220;
        osc.detune.value = (i - 1.5) * 8; // Slight detune for warmth

        const oscGain = ctx.createGain();
        oscGain.gain.value = 0.15;

        osc.connect(oscGain);
        oscGain.connect(padFilter);
        osc.start();

        padOscs.push({ osc, gain: oscGain });
    }

    padFilter.connect(padGain);
    padGain.connect(masterGain);
}

function updatePad(chord) {
    const v = VIBES[vibe];
    const baseFreq = 110 * Math.pow(2, v.key / 12);

    padOscs.forEach((p, i) => {
        const note = chord[i % chord.length];
        const freq = baseFreq * Math.pow(2, note / 12);
        p.osc.frequency.setTargetAtTime(freq, ctx.currentTime, 0.3);
    });

    // Pad volume from stillness - reward for being calm
    const targetVol = world.stillness * v.padWarmth * 0.25;
    padGain.gain.setTargetAtTime(targetVol, ctx.currentTime, 0.5);

    // Filter opens with stillness
    padFilter.frequency.setTargetAtTime(400 + world.stillness * 1200, ctx.currentTime, 0.3);
}

// ─────────────────────────────────────────────────────────────────
// LEAD - The melody. Follows your movement.
// ─────────────────────────────────────────────────────────────────

let leadOsc, leadGain, leadFilter;

function initLead() {
    leadOsc = ctx.createOscillator();
    leadOsc.type = 'triangle';
    leadOsc.frequency.value = 440;

    leadFilter = ctx.createBiquadFilter();
    leadFilter.type = 'lowpass';
    leadFilter.frequency.value = 2000;
    leadFilter.Q.value = 2;

    leadGain = ctx.createGain();
    leadGain.gain.value = 0;

    leadOsc.connect(leadFilter);
    leadFilter.connect(leadGain);
    leadGain.connect(masterGain);

    leadOsc.start();
}

function triggerLead(note, velocity = 0.5) {
    if (!leadOsc || !ctx) return;

    const v = VIBES[vibe];
    const freq = 220 * Math.pow(2, (v.key + note) / 12);

    const now = ctx.currentTime;

    leadOsc.frequency.setTargetAtTime(freq, now, 0.02);

    leadGain.gain.cancelScheduledValues(now);
    leadGain.gain.setValueAtTime(0.001, now);
    leadGain.gain.linearRampToValueAtTime(velocity * 0.15, now + 0.01);
    leadGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);

    leadFilter.frequency.setTargetAtTime(1000 + velocity * 3000, now, 0.01);
}

// ─────────────────────────────────────────────────────────────────
// THE RHYTHM - 16th note resolution with swing
// ─────────────────────────────────────────────────────────────────

let tick = 0;  // 16th note counter
let lastTickTime = -1;
let audioReady = false;
let aiLastCall = 0;
const AI_INTERVAL = 2000;  // AI thinks every 2 seconds

// Euclidean rhythm generator - creates natural-feeling patterns
function euclidean(steps, pulses, rotation = 0) {
    if (pulses >= steps) return new Array(steps).fill(1);
    if (pulses === 0) return new Array(steps).fill(0);

    const pattern = [];
    let bucket = 0;
    for (let i = 0; i < steps; i++) {
        bucket += pulses;
        if (bucket >= steps) {
            bucket -= steps;
            pattern.push(1);
        } else {
            pattern.push(0);
        }
    }
    // Rotate
    for (let i = 0; i < rotation; i++) {
        pattern.push(pattern.shift());
    }
    return pattern;
}

// Jazz swing - delays every other 16th note
function getSwingDelay(tickInBeat, swingAmount) {
    // tickInBeat is 0-3 (16ths within a quarter note)
    // Delay the 2nd and 4th 16th notes
    if (tickInBeat === 1 || tickInBeat === 3) {
        return swingAmount * 0.05;  // Up to 50ms swing
    }
    return 0;
}

// ─────────────────────────────────────────────────────────────────
// AI AGENTS - Each instrument has a mind
// ─────────────────────────────────────────────────────────────────

const aiAgents = {
    drums: {
        decision: 'steady',
        options: ['steady', 'push', 'pull-back', 'fill', 'drop', 'accent'],
        lastThink: 0
    },
    bass: {
        decision: 'root',
        options: ['root', 'walk', 'climb', 'descend', 'pedal', 'rest'],
        lastThink: 0
    },
    pad: {
        decision: 'close',
        options: ['close', 'spread', 'shell', 'rich', 'sparse', 'out'],
        lastThink: 0
    },
    lead: {
        decision: 'space',
        options: ['develop', 'contrast', 'space', 'peak', 'echo', 'rest'],
        lastThink: 0
    }
};

async function aiThink(agent, instrument) {
    const now = Date.now();
    if (now - agent.lastThink < AI_INTERVAL) return;
    agent.lastThink = now;

    const prompt = buildPrompt(instrument);

    try {
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${groqKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'llama-3.1-8b-instant',
                messages: [{ role: 'user', content: prompt }],
                max_tokens: 10,
                temperature: 0.7
            })
        });

        const data = await response.json();
        const answer = data.choices?.[0]?.message?.content?.toLowerCase().trim();

        // Find matching option
        for (const opt of agent.options) {
            if (answer && answer.includes(opt)) {
                agent.decision = opt;
                logEvent(instrument, agent.decision);
                break;
            }
        }
    } catch (e) {
        // AI failed, keep current decision
    }
}

function buildPrompt(instrument) {
    const bs = bandState;
    const energyPct = Math.round(world.energy * 100);
    const tensionPct = Math.round(bs.tension * 100);

    const context = `Energy: ${energyPct}%, Tension: ${tensionPct}%, Direction: ${bs.direction}.
Drums: ${aiAgents.drums.decision}. Bass: ${aiAgents.bass.decision}. Lead: ${aiAgents.lead.decision}.
Mic input: ${bs.micInfluence > 0.1 ? 'active' : 'quiet'}. Recent: ${bs.recentEvents.slice(-3).join(', ')}.`;

    const prompts = {
        drums: `You are a jazz drummer. ${context}
What's your next move? Reply ONLY one word: ${aiAgents.drums.options.join(', ')}`,
        bass: `You are a jazz bassist. ${context}
What's your next move? Reply ONLY one word: ${aiAgents.bass.options.join(', ')}`,
        pad: `You are a jazz pianist playing chords. ${context}
What's your next move? Reply ONLY one word: ${aiAgents.pad.options.join(', ')}`,
        lead: `You are a jazz soloist. ${context}
What's your next move? Reply ONLY one word: ${aiAgents.lead.options.join(', ')}`
    };

    return prompts[instrument];
}

function logEvent(instrument, action) {
    bandState.recentEvents.push(`${instrument}:${action}`);
    if (bandState.recentEvents.length > 8) bandState.recentEvents.shift();

    // Update tension based on actions
    if (['push', 'climb', 'develop', 'peak'].includes(action)) {
        bandState.tension = Math.min(1, bandState.tension + 0.1);
        bandState.direction = 'building';
    } else if (['pull-back', 'descend', 'rest', 'space', 'drop'].includes(action)) {
        bandState.tension = Math.max(0, bandState.tension - 0.1);
        bandState.direction = 'releasing';
    }
}

// ─────────────────────────────────────────────────────────────────
// DRUM PATTERNS - Complex, living rhythms
// ─────────────────────────────────────────────────────────────────

// Different groove patterns (16 steps = 1 bar)
const DRUM_PATTERNS = {
    steady: {
        kick:  [1,0,0,0, 0,0,1,0, 0,0,0,0, 0,1,0,0],  // Classic jazz
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],  // 2 and 4
        hat:   [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],  // 8ths
        ghost: [0,0,0,1, 0,0,0,1, 0,0,0,1, 0,0,0,1],  // Ghost snares
    },
    push: {
        kick:  [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0],  // Driving
        snare: [0,0,0,0, 1,0,0,1, 0,0,0,0, 1,0,0,1],  // Pushed snare
        hat:   [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],  // 16ths
        perc:  [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,1,1,0],  // Percussion
    },
    'pull-back': {
        kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],  // Sparse
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],  // Just 2 and 4
        hat:   [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],  // Sparse hats
    },
    fill: {
        kick:  [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        snare: [0,1,1,0, 1,1,0,1, 1,0,1,1, 0,1,1,1],  // Fill pattern
        hat:   [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],
    },
    drop: {
        kick:  [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],  // Nothing
        snare: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
        hat:   [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],  // Just hints
    },
    accent: {
        kick:  [1,0,0,0, 0,0,1,0, 0,0,1,0, 0,0,1,1],  // Accent kicks
        snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
        hat:   [1,0,1,1, 1,0,1,1, 1,0,1,1, 1,0,1,1],  // Syncopated
        rim:   [0,0,0,0, 0,0,0,1, 0,0,0,0, 0,0,1,0],  // Rim accents
    }
};

function updateRhythm() {
    if (!audioReady || !ctx || !samplesLoaded) return;

    const v = VIBES[vibe];
    const tickDuration = 60 / v.bpm / 4;  // 16th note duration
    const now = ctx.currentTime;

    // Initialize on first run
    if (lastTickTime < 0) {
        lastTickTime = now;
        return;
    }

    // Check if it's time for next 16th note
    const elapsed = now - lastTickTime;
    const swingDelay = getSwingDelay(tick % 4, bandState.drums.swing);

    if (elapsed >= tickDuration + swingDelay) {
        lastTickTime = now;
        onTick(tick);
        tick++;
    }

    // Update pulse for visuals (quarter note pulse)
    world.pulse = ((tick % 4) / 4) + (elapsed / tickDuration / 4);

    // Update microphone influence
    updateMic();

    // AI thinking (runs in background, doesn't block)
    const aiNow = Date.now();
    if (aiNow - aiLastCall > AI_INTERVAL / 4) {
        aiLastCall = aiNow;
        const agents = ['drums', 'bass', 'pad', 'lead'];
        const agent = agents[Math.floor(aiNow / (AI_INTERVAL/4)) % 4];
        aiThink(aiAgents[agent], agent);
    }
}

function onTick(tickNum) {
    try {
        const v = VIBES[vibe];
        if (!v) return;

        const bar = Math.floor(tickNum / 16);
        const tickInBar = tickNum % 16;
        const beatInBar = Math.floor(tickInBar / 4);
        const tickInBeat = tickInBar % 4;

        // Get current drum pattern based on AI decision
        const pattern = DRUM_PATTERNS[aiAgents.drums.decision] || DRUM_PATTERNS.steady;

        // ═══ DRUMS ═══
        const baseVel = 0.5 + world.energy * 0.3 + bandState.micInfluence * 0.2;

        // Kick
        if (pattern.kick && pattern.kick[tickInBar]) {
            const vel = baseVel * (tickInBeat === 0 ? 1 : 0.8);
            playDrum('kick', vel, 0, 1);
        }

        // Snare
        if (pattern.snare && pattern.snare[tickInBar]) {
            const vel = baseVel * 0.9;
            const pan = (Math.random() - 0.5) * 0.2;  // Slight random pan
            playDrum('snare', vel, pan, 0.98 + Math.random() * 0.04);
        }

        // Ghost snares (quiet)
        if (pattern.ghost && pattern.ghost[tickInBar]) {
            playDrum('snare', baseVel * 0.25, 0.1, 0.95);
        }

        // Hi-hats
        if (pattern.hat && pattern.hat[tickInBar]) {
            const hatType = Math.random() < 0.1 ? 'hatOpen' : 'hat';
            const hatVel = baseVel * (tickInBeat === 0 ? 0.5 : 0.35);
            const hatPan = 0.3;  // Hats panned right
            playDrum(hatType, hatVel, hatPan, 0.9 + Math.random() * 0.2);
        }

        // Rim
        if (pattern.rim && pattern.rim[tickInBar]) {
            playDrum('rim', baseVel * 0.4, -0.2, 1);
        }

        // Extra percussion
        if (pattern.perc && pattern.perc[tickInBar]) {
            playDrum('perc', baseVel * 0.5, -0.3, 0.8 + Math.random() * 0.4);
        }

        // ═══ BASS - responds to AI decision ═══
        const scale = v.scale;
        const bassDecision = aiAgents.bass.decision;

        if (tickInBeat === 0) {  // On the beat
            if (bassDecision === 'root' && beatInBar === 0) {
                playBassNote(scale[0], 0.7, tickDuration(v) * 8);
            } else if (bassDecision === 'walk') {
                // Walking bass - note every beat
                const walkNote = scale[(beatInBar + bar) % scale.length];
                playBassNote(walkNote, 0.6, tickDuration(v) * 3);
                bandState.bass.walking = true;
            } else if (bassDecision === 'climb' && beatInBar % 2 === 0) {
                const climbNote = scale[Math.min(scale.length - 1, bar % scale.length)] + 12;
                playBassNote(climbNote, 0.5, tickDuration(v) * 4);
            } else if (bassDecision === 'descend' && beatInBar % 2 === 0) {
                const descendNote = scale[scale.length - 1 - (bar % scale.length)];
                playBassNote(descendNote, 0.5, tickDuration(v) * 4);
            } else if (bassDecision === 'pedal') {
                if (beatInBar === 0) playBassNote(scale[0], 0.8, tickDuration(v) * 16);
            }
            // 'rest' = no bass
        }

        // ═══ PAD - responds to stillness and AI ═══
        if (tickInBar === 0) {  // Start of bar
            const padDecision = aiAgents.pad.decision;
            const chordRoot = scale[(bar % 4) * 2 % scale.length];

            let chord;
            switch (padDecision) {
                case 'close':
                    chord = [chordRoot, chordRoot + 3, chordRoot + 7];
                    break;
                case 'spread':
                    chord = [chordRoot, chordRoot + 7, chordRoot + 14, chordRoot + 19];
                    break;
                case 'shell':
                    chord = [chordRoot, chordRoot + 10];  // Root + 7th
                    break;
                case 'rich':
                    chord = [chordRoot, chordRoot + 4, chordRoot + 7, chordRoot + 11, chordRoot + 14];
                    break;
                case 'sparse':
                    chord = [chordRoot + 7];  // Just 5th
                    break;
                case 'out':
                    chord = [chordRoot + 1, chordRoot + 6, chordRoot + 11];  // Tension
                    break;
                default:
                    chord = [chordRoot, chordRoot + 4, chordRoot + 7];
            }
            updatePad(chord);
        }

        // ═══ LEAD - responds to movement, mic, and AI ═══
        const leadDecision = aiAgents.lead.decision;
        const shouldLead = leadDecision !== 'rest' && leadDecision !== 'space';

        if (shouldLead && tickInBeat === 0 && Math.random() < world.energy + micLevel * 0.5) {
            const noteIndex = Math.floor(world.y * scale.length);
            let note = scale[noteIndex];

            if (leadDecision === 'develop' && bandState.lead.motif.length > 0) {
                // Develop previous idea
                const lastNote = bandState.lead.motif[bandState.lead.motif.length - 1];
                note = lastNote + scale[Math.floor(Math.random() * 3)];
            } else if (leadDecision === 'contrast') {
                // Play opposite register
                note = scale[scale.length - 1 - noteIndex] + (world.y < 0.5 ? 12 : 0);
            } else if (leadDecision === 'peak') {
                // High energy notes
                note = scale[scale.length - 1] + 12;
            } else if (leadDecision === 'echo') {
                // Repeat last note
                note = bandState.lead.lastNote || scale[0];
            }

            triggerLead(note, world.energy * 0.8 + micLevel * 0.4);
            bandState.lead.lastNote = note;
            bandState.lead.motif.push(note);
            if (bandState.lead.motif.length > 4) bandState.lead.motif.shift();
        }

        // Mic onset triggers extra lead notes
        if (micOnset && shouldLead && Math.random() < 0.5) {
            const note = scale[Math.floor(Math.random() * scale.length)] + (micHigh > micLow ? 12 : 0);
            setTimeout(() => triggerLead(note, micLevel), 20);
        }

    } catch (e) {
        console.error('onTick error:', e);
    }
}

function tickDuration(v) {
    return 60 / v.bpm / 4;
}

// ─────────────────────────────────────────────────────────────────
// INPUT - Your movement becomes music
// ─────────────────────────────────────────────────────────────────

function onMove(nx, ny) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.vx = world.vx * 0.8 + dx * 0.2;
    world.vy = world.vy * 0.8 + dy * 0.2;

    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.9 + movement * 8);

    // Reset stillness on movement
    if (movement > 0.01) {
        world.stillness = Math.max(0, world.stillness - 0.1);
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    world.x = Math.max(0, Math.min(1, world.x + ax * 0.08));
    world.y = Math.max(0, Math.min(1, world.y - ay * 0.08));

    const movement = Math.sqrt(ax*ax + ay*ay);
    world.energy = Math.min(1, world.energy * 0.85 + movement * 0.4);

    if (movement > 0.05) {
        world.stillness = Math.max(0, world.stillness - 0.05);
    }
}

// ─────────────────────────────────────────────────────────────────
// VISUALS - Minimal. The sound is the focus.
// ─────────────────────────────────────────────────────────────────

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    // Fade
    vc.fillStyle = `rgba(10,10,15,${0.15 + world.energy * 0.1})`;
    vc.fillRect(0, 0, w, h);

    // Center breath
    const breathSize = 50 + Math.sin(world.breath) * 10 + world.pulse * 20;
    const breathAlpha = 0.03 + world.stillness * 0.05;
    vc.strokeStyle = `rgba(255,220,180,${breathAlpha})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w/2, h/2, breathSize, 0, TAU);
    vc.stroke();

    // Tension ring - shows AI state
    const tensionSize = breathSize + 20 + bandState.tension * 40;
    const tensionHue = bandState.direction === 'building' ? '255,180,100' :
                       bandState.direction === 'releasing' ? '100,180,255' : '180,180,200';
    vc.strokeStyle = `rgba(${tensionHue},${bandState.tension * 0.2})`;
    vc.beginPath();
    vc.arc(w/2, h/2, tensionSize, 0, TAU);
    vc.stroke();

    // Energy ring
    if (world.energy > 0.1) {
        const energySize = breathSize + 50 + world.energy * 50;
        vc.strokeStyle = `rgba(255,220,180,${world.energy * 0.15})`;
        vc.beginPath();
        vc.arc(w/2, h/2, energySize, 0, TAU);
        vc.stroke();
    }

    // Mic activity ring
    if (micActive && micLevel > 0.05) {
        const micSize = breathSize + 80 + micLevel * 100;
        vc.strokeStyle = `rgba(100,255,150,${micLevel * 0.3})`;
        vc.lineWidth = 2;
        vc.beginPath();
        vc.arc(w/2, h/2, micSize, 0, TAU);
        vc.stroke();
        vc.lineWidth = 1;
    }

    // Position indicator
    const px = world.x * w;
    const py = world.y * h;
    const pSize = 4 + world.energy * 15;
    vc.fillStyle = `rgba(255,220,180,${0.3 + world.energy * 0.5})`;
    vc.beginPath();
    vc.arc(px, py, pSize, 0, TAU);
    vc.fill();

    // Update mic indicator
    const micEl = document.getElementById('mic-indicator');
    if (micEl) {
        micEl.classList.toggle('active', micActive && micLevel > 0.1);
    }
}

// ─────────────────────────────────────────────────────────────────
// THE LOOP - Everything syncs here
// ─────────────────────────────────────────────────────────────────

function frame() {
    // Update world state
    world.time += 1/60;
    world.breath += 0.02;
    world.energy *= 0.995; // Slow decay
    world.stillness = Math.min(1, world.stillness + 0.005); // Builds when still

    // Motion affects tension
    if (world.energy > 0.5) {
        bandState.tension = Math.min(1, bandState.tension + 0.002);
    } else if (world.energy < 0.2) {
        bandState.tension = Math.max(0, bandState.tension - 0.001);
    }

    // Sidechain recovery
    sidechain = Math.min(1, sidechain + 0.15);

    // Update rhythm
    updateRhythm();

    // Update reverb based on vibe
    if (ctx && reverbGain) {
        const v = VIBES[vibe];
        reverbGain.gain.setTargetAtTime(v.reverbSize * 0.3, ctx.currentTime, 0.1);
    }

    // Draw
    draw();

    // Status - show what AI agents are doing
    const dirSymbol = bandState.direction === 'building' ? '↗' :
                      bandState.direction === 'releasing' ? '↘' : '~';
    const status = `drums: ${aiAgents.drums.decision}
bass: ${aiAgents.bass.decision}
pad: ${aiAgents.pad.decision}
lead: ${aiAgents.lead.decision}
${dirSymbol} ${Math.round(bandState.tension * 100)}%`;

    document.getElementById('pulse').innerHTML = status.replace(/\n/g, '<br>');

    requestAnimationFrame(frame);
}

// ─────────────────────────────────────────────────────────────────
// INIT
// ─────────────────────────────────────────────────────────────────

function initVibeButtons() {
    document.querySelectorAll('.vibe-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.vibe-btn').forEach(b => b.classList.remove('on'));
            btn.classList.add('on');
            vibe = btn.dataset.vibe;
            tick = 0; // Reset tick on vibe change
            lastTickTime = -1;
        });
    });
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    // Request motion permissions on iOS
    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    await initAudio();
    initVisuals();
    initVibeButtons();

    // Input handlers
    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    // Start the loop
    if (ctx.state === 'suspended') await ctx.resume();
    frame();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
