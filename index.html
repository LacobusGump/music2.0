<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP - Motion Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .orb {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.5px);
        }

        .orb.pulse {
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
            50% { transform: translate(-50%, -50%) scale(3); box-shadow: 0 0 30px rgba(255,255,255,0.6); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: rec 1s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        
        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            opacity: 0.5;
            letter-spacing: 0.5px;
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>
    <div class="info">SPACE TO SAMPLE â€¢ CLICK TO START</div>

    <script>
        'use strict';

        // Beat Matcher - finds transients and stretches samples to fit
        class BeatMatcher {
            constructor() {
                this.bpm = 75; // Lo-fi trip hop tempo
            }

            findPeaks(buffer, sr) {
                const data = buffer.getChannelData(0);
                const peaks = [];
                const windowSize = 1024;
                const hop = 512;
                
                for (let i = 0; i < data.length - windowSize; i += hop) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    energy = Math.sqrt(energy / windowSize);
                    
                    if (i > 0 && energy > peaks[peaks.length - 1]?.energy * 1.3 && energy > 0.05) {
                        peaks.push({ time: i / sr, energy, index: i });
                    }
                }
                
                return peaks;
            }

            matchToGrid(peaks, barLength = 4) {
                if (peaks.length < 2) return 1;
                
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i].time - peaks[i - 1].time);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                const beatDuration = 60 / this.bpm;
                
                const divisions = [4, 2, 1, 0.5, 0.25];
                let bestDiv = 1;
                let minDiff = Infinity;
                
                for (const div of divisions) {
                    const targetInterval = beatDuration * div;
                    const diff = Math.abs(avgInterval - targetInterval);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestDiv = div;
                    }
                }
                
                const targetDuration = beatDuration * barLength;
                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                
                return targetDuration / actualDuration;
            }

            chopSample(buffer, peaks, chopsPerBar = 4) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration * 4 / chopsPerBar;
                
                for (let i = 0; i < Math.min(peaks.length - 1, chopsPerBar); i++) {
                    const start = peaks[i].time;
                    const end = Math.min(start + chopLength, buffer.duration);
                    chops.push({ start, end, peak: peaks[i].energy });
                }
                
                return chops;
            }
        }

        // Production Suite - Kanye/Madlib style processing
        class ProductionSuite {
            constructor(ctx) {
                this.ctx = ctx;
                this.setupEffects();
            }

            setupEffects() {
                // Vintage preamp simulation
                this.preamp = this.ctx.createWaveShaper();
                const preampCurve = new Float32Array(65536);
                for (let i = 0; i < 32768; i++) {
                    let x = i / 32768;
                    // Warm saturation curve
                    preampCurve[32768 + i] = Math.tanh(x * 2) * 0.9;
                    preampCurve[32768 - i - 1] = -Math.tanh(x * 2) * 0.9;
                }
                this.preamp.curve = preampCurve;
                this.preamp.oversample = '2x';

                // Analog-style filters
                this.highpass = this.ctx.createBiquadFilter();
                this.highpass.type = 'highpass';
                this.highpass.frequency.value = 20;
                this.highpass.Q.value = 0.7;

                this.lowshelf = this.ctx.createBiquadFilter();
                this.lowshelf.type = 'lowshelf';
                this.lowshelf.frequency.value = 100;
                this.lowshelf.gain.value = 3;

                // Tape saturation
                this.tapeWow = this.ctx.createOscillator();
                this.tapeWow.frequency.value = 0.5;
                this.tapeWow.start();
                
                this.tapeFlutter = this.ctx.createOscillator();
                this.tapeFlutter.frequency.value = 4.3;
                this.tapeFlutter.start();

                // Vinyl dust
                this.vinylNoise = this.createVinylNoise();
            }

            createVinylNoise() {
                const duration = 10;
                const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const data = buffer.getChannelData(channel);
                    for (let i = 0; i < data.length; i++) {
                        // Surface noise
                        data[i] = (Math.random() - 0.5) * 0.005;
                        
                        // Occasional pops
                        if (Math.random() < 0.00001) {
                            data[i] = (Math.random() - 0.5) * 0.1;
                        }
                        
                        // Subtle rumble
                        data[i] += Math.sin(2 * Math.PI * 0.5 * i / this.ctx.sampleRate) * 0.002;
                    }
                }
                
                return buffer;
            }

            processSample(inputBuffer) {
                // Heavy production processing chain
                const sampleRate = inputBuffer.sampleRate;
                const length = inputBuffer.length;
                const outputBuffer = this.ctx.createBuffer(1, length, sampleRate);
                const input = inputBuffer.getChannelData(0);
                const output = outputBuffer.getChannelData(0);

                // 1. Gate and expand dynamics
                let envelope = 0;
                const attack = 0.001;
                const release = 0.05;
                
                for (let i = 0; i < length; i++) {
                    const inputLevel = Math.abs(input[i]);
                    const rate = inputLevel > envelope ? attack : release;
                    envelope += (inputLevel - envelope) * rate;
                    
                    // Gate with soft knee
                    const gateThreshold = 0.02;
                    let gateGain = 1;
                    if (envelope < gateThreshold) {
                        gateGain = Math.pow(envelope / gateThreshold, 2);
                    }
                    
                    output[i] = input[i] * gateGain;
                }

                // 2. EQ and color
                const processed = this.ctx.createBuffer(1, length, sampleRate);
                const processedData = processed.getChannelData(0);
                
                // Simple high-pass to remove DC
                let lastInput = 0;
                let lastOutput = 0;
                const hpFreq = 20 / (sampleRate / 2);
                const rc = 1.0 / (2.0 * Math.PI * hpFreq);
                const alpha = rc / (rc + 1.0);
                
                for (let i = 0; i < length; i++) {
                    processedData[i] = alpha * (lastOutput + output[i] - lastInput);
                    lastInput = output[i];
                    lastOutput = processedData[i];
                }

                // 3. Compression and warmth
                let rms = 0;
                const windowSize = 512;
                
                for (let i = 0; i < length; i++) {
                    // RMS detection
                    const startIdx = Math.max(0, i - windowSize);
                    const endIdx = i;
                    let sum = 0;
                    for (let j = startIdx; j < endIdx; j++) {
                        sum += processedData[j] * processedData[j];
                    }
                    rms = Math.sqrt(sum / (endIdx - startIdx));
                    
                    // Soft knee compression
                    const threshold = 0.3;
                    const ratio = 4;
                    const knee = 0.1;
                    
                    if (rms > threshold - knee) {
                        const excess = rms - threshold;
                        const kneeRatio = Math.min(1, excess / knee);
                        const gain = 1 - (excess * (1 - 1/ratio) * kneeRatio);
                        processedData[i] *= gain;
                    }
                    
                    // Tape-style saturation
                    processedData[i] = Math.tanh(processedData[i] * 1.5) * 0.9;
                }

                // 4. Find good loop points
                const peaks = this.findZeroCrossings(processed);
                let loopStart = 0;
                let loopEnd = length - 1;
                
                if (peaks.length >= 2) {
                    // Find loop points that align with the beat
                    const beatSamples = sampleRate * 60 / 75; // samples per beat at 75 BPM
                    const barSamples = beatSamples * 4;
                    
                    for (let i = 0; i < peaks.length; i++) {
                        if (peaks[i] > barSamples) {
                            loopStart = peaks[i - 1] || 0;
                            
                            // Find end point that's a multiple of bars away
                            for (let j = i; j < peaks.length; j++) {
                                const distance = peaks[j] - loopStart;
                                if (Math.abs(distance - barSamples) < beatSamples * 0.1) {
                                    loopEnd = peaks[j];
                                    break;
                                }
                            }
                            break;
                        }
                    }
                }

                // 5. Create final processed buffer with loop points
                const finalLength = loopEnd - loopStart;
                const finalBuffer = this.ctx.createBuffer(1, finalLength, sampleRate);
                const finalData = finalBuffer.getChannelData(0);
                
                // Copy with fade in/out for smooth looping
                const fadeLength = Math.min(512, finalLength * 0.01);
                for (let i = 0; i < finalLength; i++) {
                    let fadeMult = 1;
                    if (i < fadeLength) {
                        fadeMult = i / fadeLength;
                    } else if (i > finalLength - fadeLength) {
                        fadeMult = (finalLength - i) / fadeLength;
                    }
                    
                    finalData[i] = processedData[loopStart + i] * fadeMult;
                }

                // Normalize
                let maxVal = 0;
                for (let i = 0; i < finalLength; i++) {
                    maxVal = Math.max(maxVal, Math.abs(finalData[i]));
                }
                
                if (maxVal > 0) {
                    const targetLevel = 0.85;
                    const gain = targetLevel / maxVal;
                    for (let i = 0; i < finalLength; i++) {
                        finalData[i] *= gain;
                    }
                }

                return finalBuffer;
            }

            findZeroCrossings(buffer) {
                const data = buffer.getChannelData(0);
                const crossings = [];
                
                for (let i = 1; i < data.length; i++) {
                    if ((data[i-1] < 0 && data[i] >= 0) || (data[i-1] >= 0 && data[i] < 0)) {
                        crossings.push(i);
                    }
                }
                
                return crossings;
            }
        }

        // Main Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.production = null;
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.15 };
                this.orb = document.getElementById('orb');
                this.activeSources = new Map();
                
                // Kanye-style pitch shifts
                this.pitchShifts = [0.5, 0.667, 0.75, 1, 1.5, 2];
                
                // Musical state
                this.currentChord = 0;
                this.chordProgression = [
                    { root: 'C', type: 'min7', bass: 48 },   // Cm7
                    { root: 'F', type: 'maj7', bass: 41 },   // FMaj7
                    { root: 'Ab', type: 'maj7', bass: 44 },  // AbMaj7
                    { root: 'G', type: '7', bass: 43 }       // G7
                ];
                
                document.addEventListener('click', () => this.start());
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 44100 });
                    this.production = new ProductionSuite(this.ctx);
                    
                    // Master chain
                    this.nodes.master = this.ctx.createGain();
                    this.nodes.master.gain.value = 0.8;
                    
                    // Bus compression
                    this.nodes.busComp = this.ctx.createDynamicsCompressor();
                    this.nodes.busComp.threshold.value = -12;
                    this.nodes.busComp.knee.value = 6;
                    this.nodes.busComp.ratio.value = 3;
                    this.nodes.busComp.attack.value = 0.003;
                    this.nodes.busComp.release.value = 0.1;
                    
                    // Master limiter
                    this.nodes.limiter = this.ctx.createDynamicsCompressor();
                    this.nodes.limiter.threshold.value = -1;
                    this.nodes.limiter.knee.value = 0;
                    this.nodes.limiter.ratio.value = 20;
                    this.nodes.limiter.attack.value = 0.001;
                    this.nodes.limiter.release.value = 0.01;
                    
                    // Reverb bus
                    this.nodes.reverb = this.ctx.createConvolver();
                    this.nodes.reverbSend = this.ctx.createGain();
                    this.nodes.reverbSend.gain.value = 0.2;
                    this.nodes.reverbReturn = this.ctx.createGain();
                    this.nodes.reverbReturn.gain.value = 0.3;
                    await this.createReverb();
                    
                    // Create mix busses
                    const busses = {
                        drums: { gain: 0.9, pan: 0 },
                        bass: { gain: 0.85, pan: 0 },
                        samples: { gain: 0.7, pan: 0 },
                        vinyl: { gain: 0.1, pan: 0 }
                    };
                    
                    Object.entries(busses).forEach(([name, config]) => {
                        const bus = this.ctx.createGain();
                        const pan = this.ctx.createStereoPanner();
                        
                        bus.gain.value = config.gain;
                        pan.pan.value = config.pan;
                        
                        bus.connect(pan);
                        pan.connect(this.nodes.busComp);
                        
                        this.nodes[name] = bus;
                        this.samples.set(name, []);
                    });
                    
                    // Connect master chain
                    this.nodes.busComp.connect(this.nodes.master);
                    this.nodes.master.connect(this.nodes.limiter);
                    this.nodes.limiter.connect(this.ctx.destination);
                    
                    // Reverb routing
                    this.nodes.reverbSend.connect(this.nodes.reverb);
                    this.nodes.reverb.connect(this.nodes.reverbReturn);
                    this.nodes.reverbReturn.connect(this.nodes.busComp);
                    
                    // Create sounds
                    await this.createDrums();
                    this.createVinyl();
                    
                    // Mic setup
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.rec = this.ctx.createScriptProcessor(4096, 1, 1);
                    
                    this.nodes.rec.onaudioprocess = e => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            if (this.buffer.length > this.ctx.sampleRate * 8) this.stopRec();
                        }
                    };
                    
                    // Start
                    this.loop();
                    this.seq.last = this.ctx.currentTime;
                    requestAnimationFrame(() => this.tick());
                    
                    document.onkeydown = e => {
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.toggle();
                        }
                    };
                    
                    document.querySelector('.info').style.display = 'none';
                    
                } catch (e) {
                    console.error(e);
                }
            }

            async createReverb() {
                // Hall reverb impulse
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    
                    for (let i = 0; i < length; i++) {
                        // Early reflections
                        if (i < this.ctx.sampleRate * 0.1) {
                            if (i % Math.floor(this.ctx.sampleRate * 0.007) === 0) {
                                channelData[i] = (Math.random() - 0.5) * Math.pow(1 - i / length, 2) * 0.5;
                            }
                        }
                        
                        // Diffuse tail
                        channelData[i] += (Math.random() - 0.5) * Math.pow(1 - i / length, 1.5) * 0.2;
                    }
                }
                
                this.nodes.reverb.buffer = impulse;
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.rec);
                    this.nodes.rec.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.rec);
                this.nodes.rec.disconnect();
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.5) {
                    const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    buf.getChannelData(0).set(this.buffer);
                    
                    // Heavy production processing
                    const processed = this.production.processSample(buf);
                    
                    // Find peaks and match to beat
                    const peaks = this.beatMatcher.findPeaks(processed, this.ctx.sampleRate);
                    const stretch = this.beatMatcher.matchToGrid(peaks);
                    
                    // Kanye-style pitch shift
                    const pitch = this.pitchShifts[Math.floor(Math.random() * this.pitchShifts.length)];
                    
                    // Create chops
                    const chops = this.beatMatcher.chopSample(processed, peaks);
                    
                    const sample = {
                        buffer: processed,
                        rate: stretch * pitch,
                        chops,
                        pitch,
                        evolution: 0
                    };
                    
                    // Add to samples
                    const samples = this.samples.get('samples');
                    if (samples.length >= 4) {
                        const oldest = samples.shift();
                        if (this.activeSources.has(oldest)) {
                            this.activeSources.get(oldest).stop();
                            this.activeSources.delete(oldest);
                        }
                    }
                    samples.push(sample);
                    
                    console.log(`Sample: ${pitch}x pitch, ${stretch.toFixed(2)}x stretch, ${chops.length} chops`);
                }
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // Punchy kick with sub
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.pow(1 - t * 2, 3);
                    const pitch = 60 * Math.exp(-35 * t);
                    const click = Math.sin(2 * Math.PI * 1500 * t) * Math.exp(-100 * t) * 0.3;
                    const sub = Math.sin(2 * Math.PI * pitch * 0.5 * t);
                    kd[i] = (Math.sin(2 * Math.PI * pitch * t) + sub * 0.5 + click) * env;
                }
                
                // Snappy snare
                const snare = this.ctx.createBuffer(1, sr * 0.2, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-20 * t);
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.5;
                    const noise = (Math.random() * 2 - 1) * 0.7;
                    sd[i] = (tone + noise) * env;
                }
                
                // Crispy hat
                const hat = this.ctx.createBuffer(1, sr * 0.05, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-100 * t);
                    let s = (Math.random() * 2 - 1) * env;
                    if (i > 0) s = s * 0.3 + hd[i-1] * 0.7; // Low-pass
                    hd[i] = s;
                }
                
                this.samples.get('drums').push(
                    { type: 'kick', buffer: kick },
                    { type: 'snare', buffer: snare },
                    { type: 'hat', buffer: hat }
                );
            }

            createVinyl() {
                const duration = 10;
                const vinyl = this.ctx.createBuffer(2, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data0 = vinyl.getChannelData(0);
                const data1 = vinyl.getChannelData(1);
                
                for (let i = 0; i < data0.length; i++) {
                    // Surface noise
                    data0[i] = (Math.random() - 0.5) * 0.01;
                    data1[i] = (Math.random() - 0.5) * 0.01;
                    
                    // Crackle
                    if (Math.random() < 0.0001) {
                        data0[i] = (Math.random() - 0.5) * 0.2;
                        data1[i] = (Math.random() - 0.5) * 0.2;
                    }
                    
                    // Low rumble
                    const rumble = Math.sin(2 * Math.PI * 0.5 * i / this.ctx.sampleRate) * 0.005;
                    data0[i] += rumble;
                    data1[i] += rumble;
                }
                
                const playVinyl = () => {
                    const source = this.ctx.createBufferSource();
                    source.buffer = vinyl;
                    source.loop = true;
                    source.connect(this.nodes.vinyl);
                    source.start();
                };
                
                playVinyl();
            }

            tick() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.beatMatcher.bpm / 4;
                
                // Swing timing
                let swing = this.seq.step % 2 === 1 ? beat * (1 + this.seq.swing) : beat * (1 - this.seq.swing);
                
                if (now >= this.seq.last + swing) {
                    this.seq.last = now;
                    
                    // Pulse on downbeat
                    if (this.seq.step % 4 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 300);
                    }
                    
                    // Drum pattern - classic boom bap
                    const drums = this.samples.get('drums');
                    
                    // Kick pattern
                    if ([0, 10].includes(this.seq.step % 16)) {
                        this.playDrum('kick', 0.9);
                    }
                    
                    // Snare pattern
                    if ([4, 12].includes(this.seq.step % 16)) {
                        this.playDrum('snare', 0.7);
                    }
                    
                    // Hi-hat pattern
                    if ([2, 6, 10, 14].includes(this.seq.step % 16)) {
                        this.playDrum('hat', 0.3 + Math.random() * 0.1);
                    }
                    
                    // Bassline
                    if (this.samples.get('samples').length >= 2) {
                        this.playBassline();
                    }
                    
                    // Sample triggering
                    const samples = this.samples.get('samples');
                    if (samples.length > 0) {
                        // Main sample loop
                        if (this.seq.step % 16 === 0) {
                            this.playSample(samples[samples.length - 1]);
                        }
                        
                        // Sample chops for variation
                        if (samples.length > 1 && [6, 14].includes(this.seq.step % 16)) {
                            const chop = Math.floor(Math.random() * samples[0].chops.length);
                            this.playChop(samples[0], chop);
                        }
                    }
                    
                    // Chord progression every 2 bars
                    if (this.seq.step % 32 === 0) {
                        this.currentChord = (this.currentChord + 1) % this.chordProgression.length;
                    }
                    
                    this.seq.step = (this.seq.step + 1) % 64;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            playDrum(type, vel) {
                const drums = this.samples.get('drums');
                const drum = drums.find(d => d.type === type);
                if (!drum) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = drum.buffer;
                gain.gain.value = vel;
                
                // EQ for punch
                filter.type = 'peaking';
                filter.frequency.value = type === 'kick' ? 80 : type === 'snare' ? 200 : 8000;
                filter.Q.value = 2;
                filter.gain.value = 3;
                
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.drums);
                
                // Send snare to reverb
                if (type === 'snare') {
                    gain.connect(this.nodes.reverbSend);
                }
                
                src.start();
            }

            playBassline() {
                const chord = this.chordProgression[this.currentChord];
                const pattern = [0, 0, 7, 5, 3, 3, -2, 0]; // Bassline pattern
                const note = chord.bass + pattern[this.seq.step % 8];
                
                // Multiple oscillators for fat bass
                const oscs = [];
                const gains = [];
                
                for (let i = 0; i < 3; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    
                    osc.type = i === 0 ? 'sine' : 'sawtooth';
                    osc.frequency.value = this.noteToFreq(note - (i === 0 ? 12 : 0)); // Sub an octave down
                    if (i > 0) osc.detune.value = (i - 1.5) * 15; // Detune for width
                    
                    oscs.push(osc);
                    gains.push(gain);
                }
                
                // Filter for character
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 400;
                filter.Q.value = 4;
                
                // Envelope
                const envelope = this.ctx.createGain();
                const now = this.ctx.currentTime;
                const duration = 0.5;
                
                envelope.gain.setValueAtTime(0, now);
                envelope.gain.linearRampToValueAtTime(0.8, now + 0.01);
                envelope.gain.exponentialRampToValueAtTime(0.3, now + 0.1);
                envelope.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                // Filter envelope
                filter.frequency.setValueAtTime(100, now);
                filter.frequency.exponentialRampToValueAtTime(800, now + 0.02);
                filter.frequency.exponentialRampToValueAtTime(200, now + duration);
                
                // Connect
                oscs.forEach((osc, i) => {
                    gains[i].gain.value = i === 0 ? 0.5 : 0.2; // Sub louder
                    osc.connect(gains[i]);
                    gains[i].connect(filter);
                });
                
                filter.connect(envelope);
                envelope.connect(this.nodes.bass);
                
                // Start/stop
                oscs.forEach(osc => {
                    osc.start(now);
                    osc.stop(now + duration);
                });
            }

            playSample(sample) {
                if (this.activeSources.has(sample)) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                const comp = this.ctx.createDynamicsCompressor();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                
                // Dynamic filtering based on evolution
                filter.type = 'lowpass';
                filter.frequency.value = 20000 - (sample.evolution * 10000);
                filter.Q.value = 1 + sample.evolution * 2;
                
                // Per-sample compression
                comp.threshold.value = -18;
                comp.knee.value = 10;
                comp.ratio.value = 3;
                comp.attack.value = 0.003;
                comp.release.value = 0.1;
                
                gain.gain.value = 0.6;
                
                // Sidechain setup
                const sidechain = this.ctx.createGain();
                sidechain.gain.value = 1;
                
                // Connect chain
                src.connect(filter);
                filter.connect(comp);
                comp.connect(sidechain);
                sidechain.connect(gain);
                gain.connect(this.nodes.samples);
                gain.connect(this.nodes.reverbSend);
                
                src.start();
                this.activeSources.set(sample, src);
                
                // Sidechain pumping
                const pump = () => {
                    if (!this.activeSources.has(sample)) return;
                    
                    const now = this.ctx.currentTime;
                    
                    // Duck on kicks
                    if (this.seq.step % 4 === 0) {
                        sidechain.gain.cancelScheduledValues(now);
                        sidechain.gain.setValueAtTime(sidechain.gain.value, now);
                        sidechain.gain.linearRampToValueAtTime(0.3, now + 0.01);
                        sidechain.gain.linearRampToValueAtTime(1, now + 0.15);
                    }
                    
                    // Filter movement
                    const lfo = Math.sin(now * 0.5) * 0.5 + 0.5;
                    filter.frequency.value = 500 + lfo * 5000;
                    
                    requestAnimationFrame(pump);
                };
                pump();
                
                // Evolve sample over time
                setTimeout(() => {
                    sample.evolution = Math.min(sample.evolution + 0.5, 2);
                }, 8000);
            }

            playChop(sample, chopIndex) {
                const chop = sample.chops[chopIndex];
                if (!chop) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                
                // Play specific chop
                const offset = chop.start;
                const duration = chop.end - chop.start;
                
                // Filter sweep
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 5;
                
                gain.gain.value = 0.5;
                
                // Quick envelope
                const now = this.ctx.currentTime;
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.5, now + 0.01);
                gain.gain.linearRampToValueAtTime(0, now + duration * 0.9);
                
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.samples);
                
                src.start(0, offset, duration);
            }

            noteToFreq(note) {
                return 440 * Math.pow(2, (note - 69) / 12);
            }

            loop() {
                // Auto-sample detection
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let silenceCount = 0;
                let recordingTriggered = false;
                
                setInterval(() => {
                    if (this.recording) {
                        recordingTriggered = true;
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    // Look for interesting harmonic content
                    let energy = 0;
                    let harmonics = 0;
                    
                    for (let i = 10; i < 500; i++) {
                        if (data[i] > 100) {
                            energy += data[i];
                            harmonics++;
                        }
                    }
                    
                    // Auto-record if interesting and enough silence has passed
                    if (harmonics > 20 && energy > 2000 && silenceCount > 50 && !recordingTriggered) {
                        this.toggle();
                        silenceCount = 0;
                        recordingTriggered = true;
                        
                        // Reset after cooldown
                        setTimeout(() => {
                            recordingTriggered = false;
                        }, 10000);
                    }
                    
                    // Track silence
                    if (energy < 500) {
                        silenceCount++;
                    } else {
                        silenceCount = 0;
                    }
                    
                }, 100);
            }
        }

        new Engine();
    </script>
</body>
</html>
