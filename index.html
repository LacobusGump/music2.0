<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP 2.0</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      overflow: hidden;
      height: 100vh;
      cursor: none;
      user-select: none;
      -webkit-user-select: none;
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      position: relative;
    }
    
    /* Core Orb - The Heart */
    .core {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 89px;
      height: 89px;
      border-radius: 50%;
      background: radial-gradient(circle, 
        rgba(255,255,255,0.05) 0%, 
        rgba(255,255,255,0.02) 38.2%,
        transparent 61.8%);
      filter: blur(1px);
      transition: all 0.618s cubic-bezier(0.382, 0, 0.618, 1);
      pointer-events: none;
    }
    
    .core.recording {
      background: radial-gradient(circle, 
        rgba(255,100,100,0.2) 0%, 
        rgba(255,0,0,0.05) 38.2%,
        transparent 61.8%);
      animation: recordPulse 0.618s ease-in-out infinite;
    }
    
    .core.pulse {
      animation: corePulse 0.233s ease-out;
    }
    
    @keyframes recordPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1618); }
    }
    
    @keyframes corePulse {
      0% { transform: translate(-50%, -50%) scale(1); filter: blur(1px); }
      50% { transform: translate(-50%, -50%) scale(1.382); filter: blur(0px); }
      100% { transform: translate(-50%, -50%) scale(1); filter: blur(1px); }
    }
    
    /* Sample Memories - Visual Echo */
    .memory {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.13);
      pointer-events: none;
      opacity: 0;
      animation: memoryDrift 21s ease-in-out infinite;
    }
    
    @keyframes memoryDrift {
      0% { 
        transform: translate(0, 0) scale(1); 
        opacity: 0;
      }
      13% { opacity: 0.34; }
      61.8% { 
        transform: translate(var(--mx), var(--my)) scale(2.618); 
        opacity: 0.21;
      }
      100% { 
        transform: translate(calc(var(--mx) * 1.618), calc(var(--my) * 1.618)) scale(0.382); 
        opacity: 0;
      }
    }
    
    /* Frequency Ribbons */
    .ribbon {
      position: fixed;
      bottom: 0;
      width: 1px;
      background: linear-gradient(to top, 
        rgba(255,255,255,0.08), 
        rgba(255,255,255,0.02), 
        transparent);
      transform-origin: bottom center;
      transition: height 0.089s ease-out;
      pointer-events: none;
    }
    
    /* Motion Field */
    .field {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at var(--px, 50%) var(--py, 50%), 
        transparent 13%, 
        rgba(255,255,255,0.003) 34%,
        rgba(0,0,0,0.21) 100%);
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.89;
      transition: background 2.333s ease;
    }
    
    /* Evolution State */
    .state {
      position: fixed;
      bottom: 21px;
      left: 50%;
      transform: translateX(-50%);
      width: 1px;
      height: 1px;
      background: rgba(255,255,255,0.13);
      border-radius: 50%;
      transition: all 3.777s ease;
      pointer-events: none;
    }
    
    .state.evolving {
      width: 144px;
      height: 1px;
      border-radius: 0;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255,255,255,0.08) 38.2%, 
        rgba(255,255,255,0.08) 61.8%, 
        transparent);
    }
    
    /* Start Screen - Minimal */
    .awaken {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 11px;
      letter-spacing: 13px;
      color: rgba(255,255,255,0.08);
      font-weight: 100;
      opacity: 1;
      transition: opacity 2.333s ease;
      pointer-events: none;
      animation: breatheText 5s ease-in-out infinite;
    }
    
    @keyframes breatheText {
      0%, 100% { opacity: 0.08; }
      50% { opacity: 0.21; }
    }
    
    .awaken.hidden {
      opacity: 0;
      pointer-events: none;
    }
    
    /* Hidden Canvas for Audio Analysis */
    canvas { display: none; }
  </style>
</head>
<body>
  <div class="field"></div>
  <div class="core" id="core"></div>
  <div class="state" id="state"></div>
  <div class="awaken" id="awaken">EXIST</div>

  <script>
    'use strict';

    class RealityWeaver {
      constructor() {
        // Constants
        this.φ = 1.618033988749; // Golden ratio
        this.fibSeq = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233];
        
        // Core State
        this.ctx = null;
        this.active = false;
        this.evolution = 0;
        this.complexity = 0;
        
        // Sample Management
        this.samples = [];
        this.sampleGrid = new Array(16).fill(null);
        this.recording = false;
        this.recordBuffer = [];
        this.mic = null;
        this.micAnalyser = null;
        
        // Musical State
        this.bpm = 89;
        this.step = 0;
        this.swing = 0;
        this.rootFreq = 55; // A1
        this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
        this.currentChord = [0, 3, 7];
        
        // Motion & Gesture
        this.motion = { x: 0, y: 0, intensity: 0, pattern: 'still' };
        this.lastMotion = Date.now();
        this.stillness = 0;
        this.gesture = { type: null, confidence: 0 };
        
        // Active Voices & Effects
        this.voices = new Map();
        this.maxVoices = 34;
        this.effects = {
          reverb: null,
          delay: null,
          filter: null,
          distortion: null
        };
        
        // Layer System
        this.layers = {
          pulse: { active: false, gain: 0.8 },     // Kick
          breath: { active: false, gain: 0.3 },    // Hi-hats
          flow: { active: false, gain: 0.6 },      // Bass
          echo: { active: false, gain: 0.4 },      // Snare
          dream: { active: false, gain: 0.2 },     // Pads
          spirit: { active: false, gain: 0.15 },   // Lead
          cosmos: { active: false, gain: 0.1 },    // Atmosphere
          void: { active: false, gain: 0.05 }      // Samples
        };
        
        // Visual Elements
        this.ribbons = [];
        this.memories = [];
        
        // Environmental Awareness
        this.environment = {
          noise: 0,
          harmony: 0,
          rhythm: 0,
          lastPeak: 0
        };
        
        this.init();
      }

      init() {
        // Create visual elements first
        this.createVisuals();
        
        // Single interaction to start
        const start = async (e) => {
          e.preventDefault();
          document.removeEventListener('click', start);
          document.removeEventListener('touchstart', start);
          
          await this.awaken();
        };
        
        document.addEventListener('click', start);
        document.addEventListener('touchstart', start);
        
        // Setup motion detection
        this.setupMotion();
      }

      createVisuals() {
        // Create frequency ribbons
        for (let i = 0; i < 89; i++) {
          const ribbon = document.createElement('div');
          ribbon.className = 'ribbon';
          ribbon.style.left = `${(i / 89) * 100}%`;
          document.body.appendChild(ribbon);
          this.ribbons.push(ribbon);
        }
      }

      async awaken() {
        try {
          // Initialize Web Audio
          this.ctx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 44100,
            latencyHint: 'interactive'
          });
          
          await this.ctx.resume();
          
          // Create audio graph
          await this.setupAudio();
          
          // Start microphone
          await this.setupMicrophone();
          
          // Hide start text
          document.getElementById('awaken').classList.add('hidden');
          document.getElementById('state').classList.add('evolving');
          
          // Begin
          this.active = true;
          this.pulse();
          this.analyze();
          this.evolve();
          
        } catch(e) {
          console.error('Awakening failed:', e);
          // Fallback to non-mic mode
          this.active = true;
          this.pulse();
          this.evolve();
        }
      }

      async setupAudio() {
        // Master bus
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.7;
        
        // Compressor for glue
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -12;
        this.compressor.knee.value = 3;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.1;
        
        // Create reverb
        this.effects.reverb = await this.createReverb();
        this.reverbSend = this.ctx.createGain();
        this.reverbSend.gain.value = 0.2;
        
        // Create delay
        this.effects.delay = this.ctx.createDelay(2);
        this.effects.delay.delayTime.value = 60 / this.bpm / 8; // Dotted eighth
        this.delaySend = this.ctx.createGain();
        this.delaySend.gain.value = 0.15;
        this.delayFeedback = this.ctx.createGain();
        this.delayFeedback.gain.value = 0.4;
        
        // Create filter
        this.effects.filter = this.ctx.createBiquadFilter();
        this.effects.filter.type = 'lowpass';
        this.effects.filter.frequency.value = 8000;
        this.effects.filter.Q.value = 1;
        
        // Connect effects chain
        this.master.connect(this.compressor);
        this.compressor.connect(this.effects.filter);
        this.effects.filter.connect(this.ctx.destination);
        
        // Connect sends
        this.master.connect(this.reverbSend);
        this.reverbSend.connect(this.effects.reverb);
        this.effects.reverb.connect(this.ctx.destination);
        
        this.master.connect(this.delaySend);
        this.delaySend.connect(this.effects.delay);
        this.effects.delay.connect(this.delayFeedback);
        this.delayFeedback.connect(this.effects.delay);
        this.effects.delay.connect(this.ctx.destination);
        
        // Create layer gains
        Object.keys(this.layers).forEach(name => {
          const gain = this.ctx.createGain();
          gain.gain.value = this.layers[name].gain;
          gain.connect(this.master);
          this.layers[name].node = gain;
        });
      }

      async createReverb() {
        const length = this.ctx.sampleRate * 3;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let ch = 0; ch < 2; ch++) {
          const data = impulse.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, 2);
            data[i] = (Math.random() * 2 - 1) * decay * 0.1;
            // Add early reflections
            if (i < 1000) {
              data[i] += (Math.random() * 2 - 1) * 0.2 * Math.exp(-i / 100);
            }
          }
        }
        
        const convolver = this.ctx.createConvolver();
        convolver.buffer = impulse;
        return convolver;
      }

      async setupMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            }
          });
          
          this.mic = this.ctx.createMediaStreamSource(stream);
          this.micAnalyser = this.ctx.createAnalyser();
          this.micAnalyser.fftSize = 2048;
          this.micAnalyser.smoothingTimeConstant = 0.8;
          
          this.mic.connect(this.micAnalyser);
          
          // Recording processor
          this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
          this.recorder.onaudioprocess = (e) => {
            if (this.recording && this.recordBuffer.length < this.ctx.sampleRate * 4) {
              const data = e.inputBuffer.getChannelData(0);
              this.recordBuffer.push(...data);
            }
          };
          
        } catch(e) {
          console.log('Mic access denied, continuing without sampling');
        }
      }

      setupMotion() {
        // Device motion
        if (window.DeviceMotionEvent) {
          window.addEventListener('devicemotion', (e) => {
            if (!e.accelerationIncludingGravity) return;
            
            const acc = e.accelerationIncludingGravity;
            const intensity = Math.sqrt(
              Math.pow(acc.x || 0, 2) + 
              Math.pow(acc.y || 0, 2) + 
              Math.pow(acc.z || 0, 2)
            ) / 10;
            
            this.updateMotion(acc.x || 0, acc.y || 0, intensity);
          });
        }
        
        // Mouse/touch as fallback
        let lastPos = { x: 0, y: 0, time: 0 };
        
        const handleMove = (clientX, clientY) => {
          const now = Date.now();
          const dt = Math.max(1, now - lastPos.time);
          const dx = clientX - lastPos.x;
          const dy = clientY - lastPos.y;
          const intensity = Math.sqrt(dx * dx + dy * dy) / dt * 2;
          
          this.updateMotion(dx / 10, dy / 10, intensity);
          
          // Update field position
          const px = (clientX / window.innerWidth) * 100;
          const py = (clientY / window.innerHeight) * 100;
          document.documentElement.style.setProperty('--px', `${px}%`);
          document.documentElement.style.setProperty('--py', `${py}%`);
          
          lastPos = { x: clientX, y: clientY, time: now };
        };
        
        window.addEventListener('mousemove', (e) => {
          handleMove(e.clientX, e.clientY);
        });
        
        window.addEventListener('touchmove', (e) => {
          if (e.touches.length > 0) {
            handleMove(e.touches[0].clientX, e.touches[0].clientY);
          }
        });
      }

      updateMotion(x, y, intensity) {
        // Smooth motion values
        this.motion.x = this.motion.x * 0.7 + x * 0.3;
        this.motion.y = this.motion.y * 0.7 + y * 0.3;
        this.motion.intensity = this.motion.intensity * 0.8 + intensity * 0.2;
        
        // Track stillness
        if (intensity > 0.1) {
          this.lastMotion = Date.now();
          this.stillness = 0;
        } else {
          this.stillness = (Date.now() - this.lastMotion) / 1000;
        }
        
        // Detect motion patterns
        if (this.stillness > 5) {
          this.motion.pattern = 'void';
        } else if (intensity > 3) {
          this.motion.pattern = 'chaos';
        } else if (intensity > 1.5) {
          this.motion.pattern = 'flow';
        } else if (intensity > 0.5) {
          this.motion.pattern = 'breath';
        } else {
          this.motion.pattern = 'still';
        }
        
        // Update evolution
        this.evolution = Math.min(3, this.evolution + intensity * 0.001);
        
        // Update layer activation
        this.updateLayers();
        
        // Update visuals
        this.updateVisuals();
      }

      updateLayers() {
        const evo = this.evolution;
        const intensity = this.motion.intensity;
        
        // Progressive layer activation
        this.layers.pulse.active = evo > 0 || intensity > 0.1;
        this.layers.breath.active = evo > 0.1 || intensity > 0.2;
        this.layers.flow.active = evo > 0.3 || intensity > 0.5;
        this.layers.echo.active = evo > 0.5 || intensity > 1;
        this.layers.dream.active = evo > 1 || this.motion.pattern === 'flow';
        this.layers.spirit.active = evo > 1.5 || this.motion.pattern === 'chaos';
        this.layers.cosmos.active = evo > 2;
        this.layers.void.active = this.motion.pattern === 'void';
        
        // Adjust BPM based on motion
        const targetBPM = 60 + Math.min(120, intensity * 30 + evo * 20);
        this.bpm = this.bpm * 0.95 + targetBPM * 0.05;
        
        // Update delay time
        if (this.effects.delay) {
          this.effects.delay.delayTime.value = 60 / this.bpm / 8;
        }
      }

      updateVisuals() {
        // Update core orb
        const core = document.getElementById('core');
        const scale = 1 + this.evolution * 0.2 + this.motion.intensity * 0.1;
        const blur = 1 - this.motion.intensity * 0.3;
        core.style.transform = `translate(-50%, -50%) scale(${scale})`;
        core.style.filter = `blur(${Math.max(0, blur)}px)`;
        
        // Update state bar
        const state = document.getElementById('state');
        const width = 1 + this.evolution * 50;
        state.style.width = `${width}px`;
        state.style.opacity = 0.08 + this.evolution * 0.05;
      }

      analyze() {
        if (!this.active || !this.micAnalyser) return;
        
        const freqData = new Uint8Array(this.micAnalyser.frequencyBinCount);
        const timeData = new Uint8Array(this.micAnalyser.frequencyBinCount);
        
        this.micAnalyser.getByteFrequencyData(freqData);
        this.micAnalyser.getByteTimeDomainData(timeData);
        
        // Calculate overall levels
        let sum = 0;
        let peak = 0;
        for (let i = 0; i < freqData.length; i++) {
          sum += freqData[i];
          peak = Math.max(peak, freqData[i]);
        }
        
        this.environment.noise = sum / freqData.length / 255;
        
        // Detect transients
        if (peak > 200 && Date.now() - this.environment.lastPeak > 100) {
          this.environment.lastPeak = Date.now();
          this.environment.rhythm = Math.min(1, this.environment.rhythm + 0.1);
        } else {
          this.environment.rhythm *= 0.99;
        }
        
        // Calculate harmonic content
        let harmony = 0;
        for (let i = 0; i < freqData.length / 4; i++) {
          const freq = i * this.ctx.sampleRate / this.micAnalyser.fftSize;
          if (freq > 80 && freq < 2000) {
            const noteDistance = this.getClosestNoteDistance(freq);
            harmony += (1 - noteDistance) * (freqData[i] / 255);
          }
        }
        this.environment.harmony = harmony / (freqData.length / 4);
        
        // Auto-sample decision
        if (this.environment.harmony > 0.3 && 
            this.environment.rhythm > 0.5 && 
            !this.recording && 
            this.samples.length < 8) {
          this.startRecording();
        }
        
        // Update frequency ribbons
        this.ribbons.forEach((ribbon, i) => {
          const index = Math.floor(i * freqData.length / this.ribbons.length);
          const height = (freqData[index] / 255) * 100;
          ribbon.style.height = `${height}px`;
          ribbon.style.opacity = 0.3 + (freqData[index] / 255) * 0.7;
        });
        
        requestAnimationFrame(() => this.analyze());
      }

      getClosestNoteDistance(freq) {
        const noteFreqs = [];
        for (let octave = 1; octave < 7; octave++) {
          for (let note of this.scale) {
            noteFreqs.push(this.rootFreq * Math.pow(2, octave + note / 12));
          }
        }
        
        let minDistance = 1;
        for (let noteFreq of noteFreqs) {
          const ratio = freq / noteFreq;
          const cents = 1200 * Math.log2(ratio);
          const distance = Math.abs(cents) / 100; // Distance in semitones
          minDistance = Math.min(minDistance, Math.min(distance, 1));
        }
        
        return minDistance;
      }

      startRecording() {
        if (!this.mic || this.recording) return;
        
        this.recording = true;
        this.recordBuffer = [];
        this.mic.connect(this.recorder);
        this.recorder.connect(this.ctx.destination);
        
        document.getElementById('core').classList.add('recording');
        
        // Auto-stop after 2 seconds
        setTimeout(() => this.stopRecording(), 2000);
      }

      stopRecording() {
        if (!this.recording) return;
        
        this.recording = false;
        if (this.mic && this.recorder) {
          this.mic.disconnect(this.recorder);
          this.recorder.disconnect();
        }
        
        document.getElementById('core').classList.remove('recording');
        
        if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
          this.processSample(this.recordBuffer);
        }
      }

      processSample(data) {
        // Create buffer
        const buffer = this.ctx.createBuffer(1, data.length, this.ctx.sampleRate);
        buffer.getChannelData(0).set(data);
        
        // Analyze sample
        const peaks = this.findPeaks(data);
        const pitch = this.detectPitch(data);
        
        // Store sample
        const sample = {
          buffer,
          peaks,
          pitch,
          energy: Math.sqrt(data.reduce((s, x) => s + x * x, 0) / data.length),
          timestamp: Date.now()
        };
        
        this.samples.push(sample);
        if (this.samples.length > 8) {
          this.samples.shift();
        }
        
        // Add to grid
        const gridPos = Math.floor(Math.random() * this.sampleGrid.length);
        this.sampleGrid[gridPos] = sample;
        
        // Create visual memory
        this.createMemory();
        
        // Increase complexity
        this.complexity = Math.min(1, this.complexity + 0.1);
      }

      findPeaks(data) {
        const peaks = [];
        const threshold = 0.3;
        
        for (let i = 1000; i < data.length - 1000; i++) {
          if (Math.abs(data[i]) > threshold &&
              Math.abs(data[i]) > Math.abs(data[i - 1]) &&
              Math.abs(data[i]) > Math.abs(data[i + 1])) {
            peaks.push({
              index: i,
              time: i / this.ctx.sampleRate,
              value: data[i]
            });
            i += 1000; // Skip ahead to avoid duplicate peaks
          }
        }
        
        return peaks;
      }

      detectPitch(data) {
        // Simple autocorrelation
        let maxCorr = 0;
        let bestLag = 0;
        
        for (let lag = Math.floor(this.ctx.sampleRate / 400); 
             lag < Math.floor(this.ctx.sampleRate / 80); 
             lag++) {
          let corr = 0;
          for (let i = 0; i < data.length - lag; i++) {
            corr += data[i] * data[i + lag];
          }
          if (corr > maxCorr) {
            maxCorr = corr;
            bestLag = lag;
          }
        }
        
        return bestLag > 0 ? this.ctx.sampleRate / bestLag : 0;
      }

      createMemory() {
        const memory = document.createElement('div');
        memory.className = 'memory';
        
        // Position based on fibonacci spiral
        const angle = this.samples.length * Math.PI * this.φ;
        const radius = 20 + this.samples.length * 10;
        const x = 50 + Math.cos(angle) * radius;
        const y = 50 + Math.sin(angle) * radius;
        
        memory.style.left = `${x}%`;
        memory.style.top = `${y}%`;
        memory.style.setProperty('--mx', `${Math.cos(angle) * 50}px`);
        memory.style.setProperty('--my', `${Math.sin(angle) * 50}px`);
        memory.style.animationDelay = `${Math.random() * 5}s`;
        
        document.body.appendChild(memory);
        this.memories.push(memory);
        
        // Clean old memories
        if (this.memories.length > 21) {
          const old = this.memories.shift();
          old.remove();
        }
      }

      pulse() {
        if (!this.active) return;
        
        // Play current step
        this.playStep();
        
        // Advance sequencer
        this.step = (this.step + 1) % 16;
        
        // Visual pulse on downbeat
        if (this.step % 4 === 0) {
          document.getElementById('core').classList.add('pulse');
          setTimeout(() => {
            document.getElementById('core').classList.remove('pulse');
          }, 200);
        }
        
        // Update chord progression
        if (this.step === 0) {
          this.updateHarmony();
        }
        
        // Calculate next step time with swing
        const beatTime = 60 / this.bpm / 4;
        const swingAmount = this.step % 2 === 1 ? 0.1 : -0.1;
        const nextTime = beatTime * 1000 * (1 + swingAmount * this.swing);
        
        setTimeout(() => this.pulse(), nextTime);
      }

      playStep() {
        const s = this.step;
        
        // Drum pattern
        if (this.layers.pulse.active) {
          if (s % 4 === 0) this.playKick();
          if (s === 4 || s === 12) this.playKickGhost();
        }
        
        if (this.layers.breath.active) {
          if (s % 2 === 0) this.playHat(s % 4 === 2);
        }
        
        if (this.layers.flow.active) {
          if (s % 4 === 0) this.playBass();
        }
        
        if (this.layers.echo.active) {
          if (s === 4 || s === 12) this.playSnare();
        }
        
        // Melodic elements
        if (this.layers.dream.active && s % 8 === 0) {
          this.playPad();
        }
        
        if (this.layers.spirit.active && Math.random() < 0.1) {
          this.playLead();
        }
        
        if (this.layers.cosmos.active && s === 0) {
          this.playAtmosphere();
        }
        
        // Sample playback
        if (this.layers.void.active || this.complexity > 0.5) {
          const gridSample = this.sampleGrid[s];
          if (gridSample && Math.random() < 0.3) {
            this.playSample(gridSample);
          }
        }
        
        // Clean up old voices
        this.cleanVoices();
      }

      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const now = this.ctx.currentTime;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(55, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
        
        gain.gain.setValueAtTime(1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        
        osc.connect(gain);
        gain.connect(this.layers.pulse.node);
        
        osc.start(now);
        osc.stop(now + 0.5);
        
        this.trackVoice('kick', osc, now + 0.5);
      }

      playKickGhost() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const now = this.ctx.currentTime;
        
        osc.type = 'sine';
        osc.frequency.value = 45;
        
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.connect(gain);
        gain.connect(this.layers.pulse.node);
        
        osc.start(now);
        osc.stop(now + 0.2);
        
        this.trackVoice('kick-ghost', osc, now + 0.2);
      }

      playHat(open = false) {
        const buffer = this.ctx.createBuffer(1, open ? 8000 : 2000, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (open ? 2000 : 500));
        }
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const now = this.ctx.currentTime;
        
        source.buffer = buffer;
        
        filter.type = 'highpass';
        filter.frequency.value = open ? 5000 : 8000;
        
        gain.gain.value = open ? 0.2 : 0.15;
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.layers.breath.node);
        
        source.start(now);
        
        this.trackVoice('hat', source, now + 1);
      }

      playSnare() {
        const osc = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const now = this.ctx.currentTime;
        
        // Tone
        osc.type = 'triangle';
        osc.frequency.value = 200;
        
        // Noise
        const noiseBuffer = this.ctx.createBuffer(1, 4000, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / 1000);
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 200;
        
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.2);
        
        osc.connect(gain);
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.layers.echo.node);
        
        osc.start(now);
        osc.stop(now + 0.2);
        noise.start(now);
        
        this.trackVoice('snare', osc, now + 0.2);
      }

      playBass() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const now = this.ctx.currentTime;
        
        const note = this.currentChord[0];
        const freq = this.rootFreq * Math.pow(2, note / 12);
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 2, now);
        filter.frequency.exponentialRampToValueAtTime(freq * 8, now + 0.01);
        filter.frequency.exponentialRampToValueAtTime(freq * 2, now + 0.5);
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0.4, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.layers.flow.node);
        
        osc.start(now);
        osc.stop(now + 1);
        
        this.trackVoice('bass', osc, now + 1);
      }

      playPad() {
        const now = this.ctx.currentTime;
        
        this.currentChord.forEach((note, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const freq = this.rootFreq * Math.pow(2, (note + 12) / 12);
          
          osc.type = 'sine';
          osc.frequency.value = freq * (1 + i * 0.01); // Slight detune
          
          filter.type = 'lowpass';
          filter.frequency.value = 1000;
          
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.1, now + 2);
          gain.gain.linearRampToValueAtTime(0.08, now + 4);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 8);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.layers.dream.node);
          gain.connect(this.reverbSend);
          
          osc.start(now);
          osc.stop(now + 8);
          
          this.trackVoice(`pad-${i}`, osc, now + 8);
        });
      }

      playLead() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const vibrato = this.ctx.createOscillator();
        const vibratoGain = this.ctx.createGain();
        const now = this.ctx.currentTime;
        
        // Random note from scale
        const note = this.scale[Math.floor(Math.random() * this.scale.length)] + 24;
        const freq = this.rootFreq * Math.pow(2, note / 12);
        
        osc.type = 'square';
        osc.frequency.value = freq;
        
        // Vibrato
        vibrato.type = 'sine';
        vibrato.frequency.value = 5;
        vibratoGain.gain.value = 10;
        
        vibrato.connect(vibratoGain);
        vibratoGain.connect(osc.frequency);
        
        filter.type = 'lowpass';
        filter.frequency.value = freq * 4;
        filter.Q.value = 2;
        
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.layers.spirit.node);
        gain.connect(this.delaySend);
        
        osc.start(now);
        osc.stop(now + 0.5);
        vibrato.start(now);
        vibrato.stop(now + 0.5);
        
        this.trackVoice('lead', osc, now + 0.5);
      }

      playAtmosphere() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        const now = this.ctx.currentTime;
        
        osc.type = 'sine';
        osc.frequency.value = this.rootFreq / 2;
        
        // LFO for filter
        lfo.type = 'sine';
        lfo.frequency.value = 0.1;
        lfoGain.gain.value = 500;
        
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(0.05, now + 4);
        gain.gain.linearRampToValueAtTime(0.03, now + 8);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 12);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.layers.cosmos.node);
        gain.connect(this.reverbSend);
        
        osc.start(now);
        osc.stop(now + 12);
        lfo.start(now);
        lfo.stop(now + 12);
        
        this.trackVoice('atmosphere', osc, now + 12);
      }

      playSample(sample) {
        if (!sample || !sample.buffer) return;
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const now = this.ctx.currentTime;
        
        source.buffer = sample.buffer;
        
        // Pitch to match key
        if (sample.pitch > 0) {
          const targetPitch = this.rootFreq * Math.pow(2, this.currentChord[0] / 12);
          source.playbackRate.value = targetPitch / sample.pitch;
        }
        
        filter.type = 'bandpass';
        filter.frequency.value = 1000;
        filter.Q.value = 1;
        
        gain.gain.value = 0.2 * sample.energy;
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.layers.void.active ? this.layers.void.node : this.layers.cosmos.node);
        gain.connect(this.delaySend);
        
        source.start(now);
        
        this.trackVoice('sample', source, now + sample.buffer.duration);
      }

      updateHarmony() {
        // Chord progression
        const progressions = [
          [0, 3, 7],    // i
          [5, 8, 12],   // iv
          [7, 10, 14],  // v
          [3, 7, 10],   // III
        ];
        
        const index = Math.floor(this.step / 16) % progressions.length;
        this.currentChord = progressions[index];
        
        // Add complexity based on evolution
        if (this.evolution > 1) {
          this.currentChord.push(10); // Add 7th
        }
        if (this.evolution > 2) {
          this.currentChord.push(14); // Add 9th
        }
      }

      trackVoice(id, node, endTime) {
        this.voices.set(id + Date.now(), {
          node,
          endTime
        });
        
        // Limit voices
        if (this.voices.size > this.maxVoices) {
          const oldest = Array.from(this.voices.entries())[0];
          try {
            oldest[1].node.stop();
          } catch(e) {}
          this.voices.delete(oldest[0]);
        }
      }

      cleanVoices() {
        const now = this.ctx.currentTime;
        for (let [id, voice] of this.voices.entries()) {
          if (voice.endTime < now) {
            this.voices.delete(id);
          }
        }
      }

      evolve() {
        if (!this.active) return;
        
        // Natural evolution
        this.evolution = Math.min(3, this.evolution + 0.0001);
        
        // Complexity decay
        this.complexity *= 0.9999;
        
        // Swing variation
        this.swing = Math.sin(Date.now() / 10000) * 0.3;
        
        // Filter modulation
        if (this.effects.filter) {
          const cutoff = 2000 + Math.sin(Date.now() / 3000) * 1000 + this.evolution * 2000;
          this.effects.filter.frequency.value = cutoff;
        }
        
        requestAnimationFrame(() => this.evolve());
      }
    }

    // Initialize
    const reality = new RealityWeaver();
  </script>
</body>
</html>
