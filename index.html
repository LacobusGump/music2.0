<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="microphone=(self)">
    <title>AURORA: Symbiotic Sonic Weaver v10 - Quantum Lo-Fi Trap Mic Symbiosis Revolution</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: rgba(255,255,255,0.7);
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            text-align: center;
            z-index: 1;
        }
        .awaken-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 18px;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .awaken-btn:hover {
            border-color: #fff;
            transform: scale(1.05);
        }
        .status {
            font-size: 12px;
            margin-top: 20px;
            opacity: 0.6;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="awaken-btn" id="awaken">AWAKEN THE VORTEX</button>
        <div class="status" id="status">VOID AWAITS SYMBIOSIS</div>
    </div>

    <script>
        // Global Singularity: Mutating State Cosmos
        let aurora = {}; // The singularity entity, holding all in chaotic unity

        // Poetic Annotation: Genesis of the Vortex
        /*
        Void stirs in silence,
        Threads of sound weave emergent,
        Chaos births symphony.
        */

        class AuroraWeaver {
            constructor() {
                this.ctx = null;
                this.active = false;
                this.masterGain = null;
                this.analyzer = null;
                this.dataArray = null;
                this.timeDomainData = null;
                this.microphone = null;
                this.recorder = null;
                this.dummyGain = null;
                this.sampleBuffer = [];
                this.processedSamples = [];
                this.layers = []; // {buffer, source, gain, pan, effects}
                this.tempo = 75;
                this.motion = 0;
                this.velocity = {x: 0, y: 0};
                this.pos = {x: 50, y: 50};
                this.lmState = {
                    mood: 'neutral', // neutral, aggressive, mellow, chaotic, rhythmic
                    energy: 0,
                    complexity: 0,
                    spectralCentroid: 0,
                    onsetDensity: 0,
                    harmony: 0 // consonance measure
                };
                this.autotuneScale = [0, 3, 5, 7, 10]; // Blues pentatonic for Kanye vibe
                this.keyRoot = 0; // C
                this.elements = {
                    awaken: document.getElementById('awaken'),
                    status: document.getElementById('status')
                };
                this.lastSampleTime = 0;
                this.samplingInterval = 1000; // ms between auto-samples
                this.maxSampleDuration = 3; // seconds
                this.beatStep = 0;
                this.patternLength = 32; // 32 steps for complexity
                this.fractalSeed = Math.random();
                this.elements.awaken.onclick = () => this.awaken();
            }

            async awaken() {
                try {
                    this.ctx = new AudioContext();
                    await this.ctx.resume(); // Ensure context is running
                    this.masterGain = this.ctx.createGain();
                    this.masterGain.gain.value = 0.7;
                    this.masterGain.connect(this.ctx.destination);

                    this.analyzer = this.ctx.createAnalyser();
                    this.analyzer.fftSize = 2048;
                    this.dataArray = new Uint8Array(this.analyzer.frequencyBinCount);
                    this.timeDomainData = new Float32Array(this.analyzer.fftSize);
                    this.masterGain.connect(this.analyzer);
                    this.analyzer.connect(this.ctx.destination); // For analysis

                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    this.microphone = this.ctx.createMediaStreamSource(stream);

                    // Recorder for samples
                    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.microphone.connect(this.recorder);
                    this.dummyGain = this.ctx.createGain();
                    this.dummyGain.gain.value = 0;
                    this.recorder.connect(this.dummyGain);
                    this.dummyGain.connect(this.ctx.destination);
                    this.recorder.onaudioprocess = this.processAudio.bind(this);

                    this.active = true;
                    this.elements.awaken.style.display = 'none';
                    this.elements.status.textContent = 'SYMBIOTIC WEAVING INITIATED';
                    this.setupMotion();
                    this.createDefaultSamples(); // Add initial sounds
                    this.sequencerLoop();
                    this.analysisLoop();
                } catch (e) {
                    console.error('Weaver Awakening Failed:', e);
                    this.elements.status.textContent = 'SYMBIOSIS DENIED: ' + e.message;
                }
            }

            createDefaultSamples() {
                // Create a simple sine wave tone
                const toneLength = this.ctx.sampleRate * 0.5; // 0.5 sec
                const toneBuffer = this.ctx.createBuffer(1, toneLength, this.ctx.sampleRate);
                const toneData = toneBuffer.getChannelData(0);
                for (let i = 0; i < toneLength; i++) {
                    toneData[i] = Math.sin(2 * Math.PI * 440 * i / this.ctx.sampleRate) * 0.5; // A4 tone
                }
                this.processedSamples.push(toneBuffer);

                // Create a noise burst for percussion
                const noiseLength = this.ctx.sampleRate * 0.1; // 0.1 sec
                const noiseBuffer = this.ctx.createBuffer(1, noiseLength, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseLength; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * 0.5; // White noise
                }
                this.processedSamples.push(noiseBuffer);

                // Create a bass tone
                const bassLength = this.ctx.sampleRate * 0.5;
                const bassBuffer = this.ctx.createBuffer(1, bassLength, this.ctx.sampleRate);
                const bassData = bassBuffer.getChannelData(0);
                for (let i = 0; i < bassLength; i++) {
                    bassData[i] = Math.sin(2 * Math.PI * 110 * i / this.ctx.sampleRate) * 0.5; // A2 bass
                }
                this.processedSamples.push(bassBuffer);

                this.updateLayers();
            }

            setupMotion() {
                let lastTime = Date.now();
                const motionHandler = (e) => {
                    const now = Date.now();
                    const dt = now - lastTime;
                    lastTime = now;

                    let dx = 0, dy = 0;
                    if (e.type === 'mousemove') {
                        this.pos.x = (e.clientX / window.innerWidth) * 100;
                        this.pos.y = (e.clientY / window.innerHeight) * 100;
                        dx = e.movementX;
                    dy = e.movementY;
                    } else if (e.accelerationIncludingGravity) {
                        const acc = e.accelerationIncludingGravity;
                        dx = acc.x || 0;
                        dy = acc.y || 0;
                    }

                    this.velocity.x = dx / dt * 1000;
                    this.velocity.y = dy / dt * 1000;
                    this.motion = Math.sqrt(this.velocity.x**2 + this.velocity.y**2);

                    this.modulateFromMotion();
                };

                document.addEventListener('mousemove', motionHandler);
                window.addEventListener('devicemotion', motionHandler);
            }

            modulateFromMotion() {
                this.tempo = 80 + this.motion * 0.5; // Scale tempo 80-160ish
                this.tempo = Math.max(60, Math.min(180, this.tempo));
                this.lmState.complexity = this.motion / 20; // 0-1

                // Modulate effects: filter cutoff from y, reverb from x
                this.layers.forEach(layer => {
                    if (layer.filter) {
                        layer.filter.frequency.value = 200 + (this.pos.y / 100) * 8000;
                    }
                    if (layer.pan) {
                        layer.pan.pan.value = (this.pos.x / 50) - 1;
                    }
                });
            }

            processAudio(e) {
                if (!this.active) return;

                const input = e.inputBuffer.getChannelData(0);
                const rms = this.rootMeanSquare(input);
                const now = Date.now();

                if (rms > 0.05 && now - this.lastSampleTime > this.samplingInterval) { // Auto-sample on sound
                    this.sampleBuffer.push(...input);
                    if (this.sampleBuffer.length > this.ctx.sampleRate * this.maxSampleDuration) {
                        this.processSample();
                        this.sampleBuffer = [];
                        this.lastSampleTime = now;
                    }
                } else if (this.sampleBuffer.length > 0 && rms < 0.02) { // End sample on silence
                    this.processSample();
                    this.sampleBuffer = [];
                    this.lastSampleTime = now;
                }
            }

            rootMeanSquare(data) {
                let sum = 0;
                for (let val of data) sum += val * val;
                return Math.sqrt(sum / data.length);
            }

            async processSample() {
                if (this.sampleBuffer.length < this.ctx.sampleRate * 0.5) return; // Min length

                const buffer = this.ctx.createBuffer(1, this.sampleBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.sampleBuffer);

                this.analyzeSample(buffer);

                const chops = this.chopOnOnsets(buffer);

                for (let chop of chops) {
                    const tuned = await this.autotuneChop(chop);
                    this.processedSamples.push(tuned);
                    if (this.processedSamples.length > 32) this.processedSamples.shift(); // Keep recent
                }

                this.updateLayers();
            }

            analyzeSample(buffer) {
                const data = buffer.getChannelData(0);
                let energy = 0;

                for (let val of data) energy += val * val;
                this.lmState.energy = Math.sqrt(energy / data.length);

                const onsets = this.getPeaksAtThreshold(data, 0.1).length / (buffer.duration);
                this.lmState.onsetDensity = onsets;

                const pitch = this.detectPitch(data);
                this.lmState.harmony = 1 / (Math.abs(pitch - this.snapToScale(pitch)) + 1);

                this.lmState.spectralCentroid = pitch > 0 ? pitch * 5 + Math.random() * 500 : 2000 + Math.random() * 2000;

                if (this.lmState.energy > 0.2 && this.lmState.onsetDensity > 5) this.lmState.mood = 'aggressive';
                else if (this.lmState.energy < 0.05) this.lmState.mood = 'mellow';
                else if (this.lmState.onsetDensity > 10) this.lmState.mood = 'chaotic';
                else if (this.lmState.spectralCentroid < 1000) this.lmState.mood = 'dark';
                else this.lmState.mood = 'rhythmic';

                this.elements.status.textContent = `MOOD: ${this.lmState.mood.toUpperCase()} | ENERGY: ${this.lmState.energy.toFixed(2)} | TEMPO: ${Math.round(this.tempo)}`;
            }

            chopOnOnsets(buffer) {
                const data = buffer.getChannelData(0);
                const peaks = this.getPeaksAtThreshold(data, 0.15); // Threshold for onsets
                const chops = [];
                let start = 0;
                peaks.forEach(peak => {
                    const length = peak - start;
                    if (length > this.ctx.sampleRate * 0.1) { // Min chop length
                        const chop = this.ctx.createBuffer(1, length, this.ctx.sampleRate);
                        chop.getChannelData(0).set(data.subarray(start,peak));
                        chops.push(chop);
                    }
                    start = peak;
                });
                // Last chop
                if (data.length - start > this.ctx.sampleRate * 0.1) {
                    const chop = this.ctx.createBuffer(1, data.length - start, this.ctx.sampleRate);
                    chop.getChannelData(0).set(data.subarray(start));
                    chops.push(chop);
                }
                return chops;
            }

            getPeaksAtThreshold(data, threshold) {
                const peaks = [];
                const length = data.length;
                for (let i = 0; i < length;) {
                    if (Math.abs(data[i]) > threshold) { // Use abs for positive/negative peaks
                        peaks.push(i);
                        i += Math.floor(this.ctx.sampleRate * 0.05); // Skip 50ms
                    }
                    i++;
                }
                return peaks;
            }

            async autotuneChop(chop) {
                const data = chop.getChannelData(0);
                let pitch = this.detectPitch(data);
                if (pitch > 0) {
                    const target = this.snapToScale(pitch);
                    const factor = target / pitch;

                    // Simple pitch shift via playback rate in offline context
                    const newLength = Math.floor(chop.length / factor);
                    const offline = new OfflineAudioContext(1, newLength, this.ctx.sampleRate);
                    const source = offline.createBufferSource();
                    source.buffer = chop;
                    source.playbackRate.value = factor;
                    source.connect(offline.destination);
                    source.start(0);
                    return await offline.startRendering();
                }
                return chop;
            }

            detectPitch(data) {
                const sampleRate = this.ctx.sampleRate;
                const minFreq = 50;
                const maxFreq = 1000;
                let size = data.length;

                // Limit analysis size to prevent heavy computation
                const maxAnalysisSize = 8192;
                if (size > maxAnalysisSize) {
                    const start = Math.floor((size - maxAnalysisSize) / 2);
                    data = data.subarray(start, start + maxAnalysisSize);
                    size = maxAnalysisSize;
                }

                const minLag = Math.ceil(sampleRate / maxFreq);
                const maxLag = Math.floor(sampleRate / minFreq);

                const ac = new Array(maxLag + 1).fill(0);

                for (let lag = minLag; lag <= maxLag; lag++) {
                    let sum = 0;
                    for (let j = 0; j < size - lag; j++) {
                        sum += data[j] * data[j + lag];
                    }
                    ac[lag] = sum / (size - lag); // Normalize
                }

                let maxValue = -Infinity;
                let bestLag = -1;

                for (let lag = minLag; lag <= maxLag; lag++) {
                    if (ac[lag] > maxValue) {
                        maxValue = ac[lag];
                        bestLag = lag;
                    }
                }

                if (bestLag > 0 && maxValue > 0.2) { // Threshold for reliable detection
                    return sampleRate / bestLag;
                }
                return -1;
            }

            snapToScale(pitch) {
                if (pitch <= 0) return 440; // Default to A4 if no pitch
                const midi = 69 + 12 * Math.log2(pitch / 440);
                const scaleMidi = this.autotuneScale.map(s => s + this.keyRoot + 60); // C4 base
                const closest = scaleMidi.reduce((prev, curr) => Math.abs(curr - midi) < Math.abs(prev - midi) ? curr : prev);
                return 440 * Math.pow(2, (closest - 69) / 12);
            }

            updateLayers() {
                // Stop and clear old layers
                this.layers.forEach(layer => {
                    if (layer.source) layer.source.stop();
                });
                this.layers = [];

                // Create new layers from recent samples
                this.processedSamples.slice(-8).forEach((sample, i) => {
                    if (!sample) return;
                    const source = this.ctx.createBufferSource();
                    source.buffer = sample;
                    source.loop = true;

                    const gain = this.ctx.createGain();
                    gain.gain.value = 0.5 - i * 0.05;

                    const pan = this.ctx.createStereoPanner();
                    pan.pan.value = (i % 2 === 0 ? -0.5 : 0.5);

                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'lowpass';
                    filter.frequency.value = 500 + i * 500;

                    source.connect(filter).connect(pan).connect(gain).connect(this.masterGain);
                    source.start();

                    this.layers.push({source, gain, pan, filter});
                });
            }

            sequencerLoop() {
                const stepDuration = 60 / this.tempo / 4 * 1000; // 16th note ms
                setTimeout(() => {
                    this.playBeatStep();
                    this.sequencerLoop();
                }, stepDuration);
            }

            playBeatStep() {
                const pattern = this.generateFractalPattern();
                if (pattern[this.beatStep % this.patternLength]) {
                    const sampleIndex = Math.floor(Math.random() * this.processedSamples.length);
                    const sample = this.processedSamples[sampleIndex];
                    if (sample) {
                        const source = this.ctx.createBufferSource();
                        source.buffer = sample;
                        source.connect(this.masterGain);
                        source.start(0);
                    }
                }
                this.beatStep++;
            }

            generateFractalPattern() {
                const pattern = new Array(this.patternLength).fill(0);
                // Sierpinski-like fractal for rhythm
                for (let i = 0; i < this.patternLength; i++) {
                    pattern[i] = (i & (i >> Math.floor(this.lmState.complexity * 4 + 1))) === 0 ? 1 : 0;
                }
                // Modulate by mood
                if (this.lmState.mood === 'aggressive') {
                    pattern.forEach((v, idx) => { if (idx % 2 === 0) pattern[idx] = 1; });
                } else if (this.lmState.mood === 'mellow') {
                    pattern.forEach((v, idx) => { if (idx % 4 !== 0) pattern[idx] = 0; });
                }
                return pattern;
            }

            analysisLoop() {
                requestAnimationFrame(this.analysisLoop.bind(this));
                if (!this.active) return;

                this.analyzer.getByteFrequencyData(this.dataArray);
                this.analyzer.getFloatTimeDomainData(this.timeDomainData);

                // Update LM from real-time audio
                let energy = 0;
                for (let val of this.timeDomainData) energy += val * val;
                this.lmState.energy = Math.sqrt(energy / this.timeDomainData.length);

                // Spectral centroid
                let num = 0, den = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    num += i * this.dataArray[i];
                    den += this.dataArray[i];
                }
                this.lmState.spectralCentroid = den > 0 ? (num / den) * (this.ctx.sampleRate / 2 / this.dataArray.length) : 0;
            }
        }

        new AuroraWeaver();
    </script>
</body>
</html>
