<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 21px;
            --fib34: 34px;
            --fib55: 55px;
            --fib89: 89px;
            --fib144: 144px;
            --fib233: 144px;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }
        /* Fibonacci spiral visualization */
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }
        #spiral.active {
            opacity: 0.03;
        }
        /* Ghost title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }
        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }
        /* Start circle - golden ratio proportions */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.03) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }
        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }
        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }
        /* Main interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }
        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        /* Record button */
        .record-button {
            position: fixed;
            bottom: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib89);
            height: var(--fib89);
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.13);
            cursor: pointer;
            transition: all 0.382s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .record-button.recording {
            background: rgba(255,0,0,0.21);
            border-color: rgba(255,0,0,0.34);
            animation: recordPulse 1.618s ease-in-out infinite;
        }
        @keyframes recordPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.13); }
        }
        .record-dot {
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: rgba(255,255,255,0.21);
            transition: all 0.382s ease;
        }
        .record-button.recording .record-dot {
            background: rgba(255,0,0,0.618);
            border-radius: var(--fib3);
        }
        /* Motion indicator */
        .motion-field {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            line-height: var(--phi);
        }
        .motion-value {
            font-size: var(--fib13);
            opacity: 0.618;
        }
        /* Outfit selector */
        .outfits {
            position: fixed;
            top: var(--fib55);
            right: var(--fib55);
            display: grid;
            gap: var(--fib8);
            grid-template-columns: repeat(2, var(--fib55));
        }
        .outfit {
            width: var(--fib55);
            height: var(--fib55);
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            cursor: pointer;
            transition: all 0.382s ease;
            position: relative;
            overflow: hidden;
        }
        .outfit:hover {
            border-color: rgba(255,255,255,0.21);
            background: rgba(255,255,255,0.05);
        }
        .outfit.active {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.08);
        }
        .outfit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: var(--outfit-color, rgba(255,255,255,0.21));
            transition: all 0.382s ease;
        }
        .outfit.cosmic::after { --outfit-color: rgba(138,43,226,0.618); }
        .outfit.urban::after { --outfit-color: rgba(255,140,0,0.618); }
        .outfit.nature::after { --outfit-color: rgba(34,139,34,0.618); }
        .outfit.minimal::after { --outfit-color: rgba(255,255,255,0.382); }
        /* Sample slots - 4 elements */
        .sample-slots {
            position: fixed;
            bottom: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--fib13);
        }
        .sample-slot {
            width: var(--fib55);
            height: var(--fib13);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
            transition: all 0.382s ease;
            cursor: pointer;
        }
        .sample-slot.filled {
            border-color: rgba(255,255,255,0.21);
            background: rgba(255,255,255,0.08);
        }
        .sample-slot.playing {
            border-color: rgba(255,255,255,0.55);
            box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.21);
        }
        .sample-slot.selected {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.13);
        }
        .sample-slot::before {
            content: attr(data-type);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib5);
            letter-spacing: var(--fib2);
            opacity: 0.382;
            text-transform: uppercase;
        }
        .sample-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.618;
        }
        /* Processing indicator */
        .processing {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.382s ease;
        }
        .processing.active {
            opacity: 0.618;
        }
        /* BPM indicator */
        .bpm-indicator {
            position: fixed;
            bottom: var(--fib55);
            right: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            text-align: right;
        }
        .bpm-value {
            font-size: var(--fib21);
            opacity: 0.618;
        }
        /* Canvas layers */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #spiral { z-index: 1; }
        #visualizer { z-index: 2; opacity: 0.21; }
        #particles { z-index: 3; opacity: 0.34; }
        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            animation: loading 1.618s ease-in-out infinite;
        }
        @keyframes loading {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.382; }
        }
        /* Recording indicator */
        .recording-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -150%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            transition: opacity 0.382s ease;
            color: rgba(255,100,100,0.8);
        }
        .recording-indicator.active {
            opacity: 1;
            animation: recordBlink 1s ease-in-out infinite;
        }
        @keyframes recordBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        /* AI DJ indicator */
        .ai-dj-status {
            position: fixed;
            top: 50%;
            left: var(--fib55);
            transform: translateY(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            writing-mode: vertical-rl;
            text-orientation: mixed;
        }
        .ai-dj-mood {
            font-size: var(--fib13);
            opacity: 0.618;
            transition: all 0.618s ease;
        }
        .ai-dj-mood.excited {
            color: rgba(255,140,0,0.8);
        }
        .ai-dj-mood.chill {
            color: rgba(138,43,226,0.8);
        }
        .ai-dj-mood.groovy {
            color: rgba(34,139,34,0.8);
        }
    </style>
</head>
<body>
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
    
    <div class="title">Gump by James McCandless</div>
    
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
    
    <div class="interface" id="interface">
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
        </div>
        
        <div class="outfits">
            <div class="outfit cosmic active" data-outfit="cosmic"></div>
            <div class="outfit urban" data-outfit="urban"></div>
            <div class="outfit nature" data-outfit="nature"></div>
            <div class="outfit minimal" data-outfit="minimal"></div>
        </div>
        
        <div class="record-button" id="recordButton">
            <div class="record-dot"></div>
        </div>
        
        <div class="sample-slots">
            <div class="sample-slot" data-type="drums" data-index="0">
                <canvas class="sample-waveform" id="waveform0"></canvas>
            </div>
            <div class="sample-slot" data-type="bass" data-index="1">
                <canvas class="sample-waveform" id="waveform1"></canvas>
            </div>
            <div class="sample-slot" data-type="melody" data-index="2">
                <canvas class="sample-waveform" id="waveform2"></canvas>
            </div>
            <div class="sample-slot" data-type="lead" data-index="3">
                <canvas class="sample-waveform" id="waveform3"></canvas>
            </div>
        </div>
        
        <div class="bpm-indicator">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">89</div>
        </div>
        
        <div class="ai-dj-status">
            <div>AI-DJ</div>
            <div class="ai-dj-mood" id="aiDJMood">NEUTRAL</div>
        </div>
        
        <div class="processing" id="processing">ANALYZING...</div>
        <div class="recording-indicator" id="recordingIndicator">RECORDING</div>
    </div>
    
    <div class="loading" id="loading">AWAKENING...</div>
    <script>
        // Gump: Universal Song Engine with Fixed AI Sampler
        class GumpEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.masterGain = null;
                this.compressor = null;
                this.reverb = null;
                this.delay = null;
                this.analyser = null;
                
                // Fixed sampler system using MediaRecorder
                this.sampler = {
                    slots: [
                        { type: 'drums', filled: false, buffer: null, analysis: null, source: null, gainNode: null, currentPattern: null },
                        { type: 'bass', filled: false, buffer: null, analysis: null, source: null, gainNode: null, currentPattern: null },
                        { type: 'melody', filled: false, buffer: null, analysis: null, source: null, gainNode: null, currentPattern: null },
                        { type: 'lead', filled: false, buffer: null, analysis: null, source: null, gainNode: null, currentPattern: null }
                    ],
                    selectedSlot: 0,
                    isRecording: false,
                    mediaRecorder: null,
                    recordedChunks: [],
                    stream: null,
                    quantizeGrid: 16 // 16th notes
                };
                
                // Motion & Environment
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: [],
                    pattern: 'still',
                    intensity: 0,
                    direction: { x: 0, y: 0 },
                    lastAccel: { x: 0, y: 0, z: 0 }
                };
                
                // Musical state
                this.outfit = 'cosmic';
                this.phi = 1.618033988749;
                this.bpm = 89; // Fibonacci
                this.currentBeat = 0;
                this.swing = 0.05;
                this.key = 'A';
                this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
                
                // Timing
                this.scheduler = {
                    nextNoteTime: 0,
                    scheduleAheadTime: 0.1,
                    lookahead: 25.0,
                    timerId: null
                };
                
                // Playback tracking for loops
                this.activeSources = new Map();
                
                // Visual elements
                this.elements = {};
                this.canvases = {};
                
                // Initialize
                this.init();
            }
            
            init() {
                // Cache DOM elements
                ['start', 'interface', 'loading', 'motionValue', 'recordButton',
                 'processing', 'bpmValue', 'recordingIndicator', 'aiDJMood'].forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });
                
                // Cache canvases
                ['spiral', 'visualizer', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                });
                
                // Sample slot waveform canvases
                for (let i = 0; i < 4; i++) {
                    const canvas = document.getElementById(`waveform${i}`);
                    this.canvases[`waveform${i}`] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                }
                
                // Event listeners
                this.elements.start.addEventListener('click', () => this.begin());
                this.elements.recordButton.addEventListener('click', () => this.toggleRecording());
                
                // Sample slot selection
                document.querySelectorAll('.sample-slot').forEach((el, index) => {
                    el.addEventListener('click', (e) => {
                        // If clicking on a filled slot while not recording, toggle playback
                        if (!this.sampler.isRecording && this.sampler.slots[index].filled) {
                            this.toggleSlotPlayback(index);
                        } else if (!this.sampler.isRecording) {
                            // Select slot for next recording
                            document.querySelectorAll('.sample-slot').forEach(s => s.classList.remove('selected'));
                            el.classList.add('selected');
                            this.sampler.selectedSlot = index;
                        }
                    });
                });
                
                // Outfit selection
                document.querySelectorAll('.outfit').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.outfit').forEach(o => o.classList.remove('active'));
                        e.target.classList.add('active');
                        this.outfit = e.target.dataset.outfit;
                        this.updateOutfitParameters();
                    });
                });
                
                // Resize handling
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
                
                // Draw initial spiral
                this.drawFibonacciSpiral();
            }
            
            resizeCanvases() {
                Object.values(this.canvases).forEach(({ canvas }) => {
                    if (canvas.id.startsWith('waveform')) {
                        canvas.width = canvas.parentElement.offsetWidth;
                        canvas.height = canvas.parentElement.offsetHeight;
                    } else {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }
                });
            }
            
            drawFibonacciSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 400;
                
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                
                let a = 0, b = 1;
                let angle = 0;
                
                for (let i = 0; i < 13; i++) {
                    const radius = b * scale;
                    
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(angle) * a * scale,
                        centerY + Math.sin(angle) * a * scale,
                        radius,
                        angle,
                        angle + Math.PI / 2
                    );
                    ctx.stroke();
                    
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                }
            }
            
            async begin() {
                this.elements.loading.style.display = 'block';
                this.elements.start.style.display = 'none';
                
                try {
                    // Request permissions
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                    
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    // Get microphone access
                    this.sampler.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            channelCount: 2,
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    // Setup everything
                    this.setupAudioChain();
                    this.setupMotionDetection();
                    
                    // Start interface
                    this.elements.loading.style.display = 'none';
                    this.elements.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');
                    
                    // Start the engine
                    this.startEngine();
                    
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.elements.loading.textContent = 'PERMISSION NEEDED';
                }
            }
            
            setupAudioChain() {
                // Master compression
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -6;
                this.compressor.knee.value = 6;
                this.compressor.ratio.value = 8;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                
                // Master gain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.7;
                
                // Reverb
                this.reverb = this.ctx.createConvolver();
                this.createReverbImpulse();
                
                // Delay
                this.delay = this.ctx.createDelay(1.0);
                this.delay.delayTime.value = 0.375; // 3/8 for triplet feel
                this.delayFeedback = this.ctx.createGain();
                this.delayFeedback.gain.value = 0.4;
                this.delayGain = this.ctx.createGain();
                this.delayGain.gain.value = 0.3;
                
                // Analyser
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.85;
                
                // Connect effects chain
                this.delay.connect(this.delayFeedback);
                this.delayFeedback.connect(this.delay);
                this.delay.connect(this.delayGain);
                
                // Master chain
                this.masterGain.connect(this.compressor);
                this.masterGain.connect(this.reverb);
                this.masterGain.connect(this.delay);
                
                this.compressor.connect(this.analyser);
                this.reverb.connect(this.analyser);
                this.delayGain.connect(this.analyser);
                
                this.analyser.connect(this.ctx.destination);
            }
            
            createReverbImpulse() {
                const length = this.ctx.sampleRate * 2.5;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2.5);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.25;
                        
                        // Add early reflections
                        if (i < 1000 && i % 100 === 0) {
                            channelData[i] += (Math.random() * 2 - 1) * 0.5 * decay;
                        }
                    }
                }
                
                this.reverb.buffer = impulse;
            }
            
            setupMotionDetection() {
                // Device motion
                window.addEventListener('devicemotion', (e) => {
                    if (!e.accelerationIncludingGravity) return;
                    
                    const { x, y, z } = e.accelerationIncludingGravity;
                    const dx = Math.abs(x - this.motion.lastAccel.x);
                    const dy = Math.abs(y - this.motion.lastAccel.y);
                    const dz = Math.abs(z - this.motion.lastAccel.z);
                    
                    const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    this.updateMotion(magnitude);
                    
                    this.motion.direction = { x: x / 10, y: y / 10 };
                    this.motion.lastAccel = { x, y, z };
                });
                
                // Mouse fallback with better tracking
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', (e) => {
                    const now = performance.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                    
                    this.updateMotion(velocity * 15);
                    
                    this.motion.direction = {
                        x: (e.clientX / window.innerWidth - 0.5) * 2,
                        y: (e.clientY / window.innerHeight - 0.5) * 2
                    };
                    
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                });
            }
            
            updateMotion(value) {
                this.motion.current = value;
                this.motion.smoothed = this.motion.smoothed * 0.85 + value * 0.15;
                
                this.motion.history.push(this.motion.smoothed);
                if (this.motion.history.length > 89) {
                    this.motion.history.shift();
                }
                
                // Analyze pattern
                const avg = this.motion.history.reduce((a, b) => a + b, 0) / this.motion.history.length;
                const variance = this.motion.history.reduce((sum, m) => sum + Math.abs(m - avg), 0) / this.motion.history.length;
                
                this.motion.intensity = Math.min(1, variance / 5);
                
                if (avg < 0.5) this.motion.pattern = 'still';
                else if (variance < 1) this.motion.pattern = 'steady';
                else if (variance < 3) this.motion.pattern = 'flowing';
                else this.motion.pattern = 'chaotic';
                
                // Update UI
                this.elements.motionValue.textContent = this.motion.smoothed.toFixed(3);
                
                // Modulate BPM based on motion (but keep it musical)
                const targetBPM = 89 + Math.floor(this.motion.smoothed * 8) * 5;
                this.bpm = Math.round(this.bpm * 0.95 + targetBPM * 0.05);
                this.elements.bpmValue.textContent = this.bpm;
            }
            
            toggleRecording() {
                if (this.sampler.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
            
            startRecording() {
                // Setup MediaRecorder
                const options = {
                    mimeType: 'audio/webm;codecs=opus'
                };
                
                try {
                    this.sampler.mediaRecorder = new MediaRecorder(this.sampler.stream, options);
                    this.sampler.recordedChunks = [];
                    
                    this.sampler.mediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            this.sampler.recordedChunks.push(e.data);
                        }
                    };
                    
                    this.sampler.mediaRecorder.onstop = () => {
                        this.processRecording();
                    };
                    
                    // Start recording
                    this.sampler.isRecording = true;
                    this.sampler.mediaRecorder.start();
                    
                    // Update UI
                    this.elements.recordButton.classList.add('recording');
                    this.elements.recordingIndicator.classList.add('active');
                    
                } catch (error) {
                    console.error('Failed to start recording:', error);
                }
            }
            
            stopRecording() {
                if (this.sampler.mediaRecorder && this.sampler.mediaRecorder.state === 'recording') {
                    this.sampler.isRecording = false;
                    this.sampler.mediaRecorder.stop();
                    
                    // Update UI
                    this.elements.recordButton.classList.remove('recording');
                    this.elements.recordingIndicator.classList.remove('active');
                }
            }
            
            async processRecording() {
                this.elements.processing.classList.add('active');
                
                try {
                    // Create blob from chunks
                    const blob = new Blob(this.sampler.recordedChunks, { type: 'audio/webm' });
                    
                    // Convert to ArrayBuffer
                    const arrayBuffer = await blob.arrayBuffer();
                    
                    // Decode audio data
                    const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
                    
                    // Process the audio
                    await this.analyzeAndStoreRecording(audioBuffer);
                    
                } catch (error) {
                    console.error('Failed to process recording:', error);
                }
                
                this.elements.processing.classList.remove('active');
            }
            
            async analyzeAndStoreRecording(audioBuffer) {
                if (audioBuffer.duration < 0.1) return; // Too short
                
                // Get the audio data
                const channelData = audioBuffer.getChannelData(0);
                
                // Deep musical analysis
                const analysis = await this.analyzeRecording(channelData, audioBuffer);
                
                // Extract musical moments
                const musicalMoments = await this.findMusicalMoments(channelData, analysis);
                
                // Determine which slot type this should be
                const slotType = this.categorizeSound(analysis);
                
                // Find appropriate slot or use selected one
                let targetSlot = this.sampler.selectedSlot;
                
                // Process for the specific slot type
                const processedBuffer = await this.processForSlot(audioBuffer, analysis, slotType);
                
                // Create intelligent slices and patterns
                const slices = await this.createIntelligentSlices(processedBuffer, analysis, musicalMoments);
                
                // Store in slot with enhanced data
                const slot = this.sampler.slots[targetSlot];
                slot.filled = true;
                slot.buffer = processedBuffer;
                slot.analysis = analysis;
                slot.musicalMoments = musicalMoments;
                slot.slices = slices;
                slot.currentPattern = this.generateInitialPattern(analysis, slotType);
                slot.variations = this.createVariations(slot.currentPattern);
                
                // Update UI
                const slotElement = document.querySelectorAll('.sample-slot')[targetSlot];
                slotElement.classList.add('filled');
                slotElement.classList.remove('selected');
                this.drawWaveform(targetSlot, processedBuffer);
                
                // Auto-play the new sample
                if (!this.activeSources.has(targetSlot)) {
                    this.startSlotPlayback(targetSlot);
                }
                
                // Start AI DJ for this slot
                this.initializeAIDJ(targetSlot);
            }
            
            async analyzeRecording(data, buffer) {
                const analysis = {
                    // Timing
                    duration: buffer.duration,
                    tempo: null,
                    beats: [],
                    onsets: [],
                    
                    // Frequency
                    pitch: null,
                    harmonics: [],
                    spectralCentroid: 0,
                    
                    // Dynamics
                    rms: 0,
                    peak: 0,
                    dynamicRange: 0,
                    
                    // Character
                    brightness: 0,
                    noisiness: 0,
                    tonality: 0
                };
                
                // Peak detection for rhythm
                analysis.peak = Math.max(...data.map(Math.abs));
                
                // RMS for overall level
                analysis.rms = Math.sqrt(data.reduce((sum, x) => sum + x * x, 0) / data.length);
                
                // Onset detection
                const onsets = this.detectOnsets(data);
                analysis.onsets = onsets;
                
                // Tempo detection from onsets
                if (onsets.length > 3) {
                    const intervals = [];
                    for (let i = 1; i < onsets.length; i++) {
                        intervals.push(onsets[i] - onsets[i-1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                    const samplesPerBeat = avgInterval;
                    const beatsPerSecond = this.ctx.sampleRate / samplesPerBeat;
                    analysis.tempo = beatsPerSecond * 60;
                }
                
                // Spectral analysis
                analysis.spectralCentroid = await this.analyzeSpectrum(buffer);
                
                // Brightness (high frequency content)
                analysis.brightness = Math.min(1, analysis.spectralCentroid / 5000);
                
                // Pitch detection using autocorrelation
                analysis.pitch = this.detectPitch(data);
                
                // Tonality vs noisiness
                const zeroCrossings = this.countZeroCrossings(data);
                analysis.noisiness = Math.min(1, zeroCrossings / (data.length * 0.5));
                analysis.tonality = 1 - analysis.noisiness;
                
                return analysis;
            }
            
            async analyzeSpectrum(buffer) {
                const offlineCtx = new OfflineAudioContext(1, buffer.length, buffer.sampleRate);
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const analyser = offlineCtx.createAnalyser();
                analyser.fftSize = 2048;
                
                source.connect(analyser);
                analyser.connect(offlineCtx.destination);
                source.start();
                
                const rendered = await offlineCtx.startRendering();
                
                const fftData = new Float32Array(analyser.frequencyBinCount);
                analyser.getFloatFrequencyData(fftData);
                
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 0; i < analyser.frequencyBinCount; i++) {
                    const magnitude = Math.pow(10, fftData[i] / 20);
                    const frequency = i * offlineCtx.sampleRate / analyser.fftSize;
                    weightedSum += magnitude * frequency;
                    magnitudeSum += magnitude;
                }
                
                return magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
            }
            
            detectOnsets(data) {
                const windowSize = 1024;
                const hopSize = 512;
                const onsets = [];
                
                // Energy-based onset detection
                let previousEnergy = 0;
                
                for (let i = 0; i < data.length - windowSize; i += hopSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    
                    const energyDiff = energy - previousEnergy;
                    if (energyDiff > previousEnergy * 0.3 && energy > 0.01) {
                        onsets.push(i);
                    }
                    
                    previousEnergy = energy;
                }
                
                return onsets;
            }
            
            detectPitch(data) {
                // Autocorrelation-based pitch detection
                const minPeriod = Math.floor(this.ctx.sampleRate / 800); // 800 Hz max
                const maxPeriod = Math.floor(this.ctx.sampleRate / 80); // 80 Hz min
                
                const sampleLength = Math.min(data.length, this.ctx.sampleRate * 1); // 1 second window
                const start = Math.floor((data.length - sampleLength) / 2);
                
                let maxCorrelation = 0;
                let bestPeriod = 0;
                
                for (let period = minPeriod; period < maxPeriod && period < sampleLength / 2; period++) {
                    let correlation = 0;
                    for (let i = start; i < start + sampleLength - period; i++) {
                        correlation += data[i] * data[i + period];
                    }
                    correlation /= sampleLength - period;
                    
                    if (correlation > maxCorrelation) {
                        maxCorrelation = correlation;
                        bestPeriod = period;
                    }
                }
                
                return bestPeriod > 0 ? this.ctx.sampleRate / bestPeriod : 0;
            }
            
            countZeroCrossings(data) {
                let crossings = 0;
                for (let i = 1; i < data.length; i++) {
                    if ((data[i-1] >= 0) !== (data[i] >= 0)) {
                        crossings++;
                    }
                }
                return crossings;
            }
            
            async findMusicalMoments(data, analysis) {
                const moments = {
                    peaks: [],
                    valleys: [],
                    rhythmicPoints: [],
                    melodicPhrases: [],
                    transients: [],
                    silences: []
                };
                
                // Find peaks and valleys with musical significance
                const windowSize = 512;
                const threshold = analysis.rms * 0.5;
                
                for (let i = windowSize; i < data.length - windowSize; i += windowSize / 4) {
                    const window = data.slice(i - windowSize/2, i + windowSize/2);
                    const energy = Math.sqrt(window.reduce((sum, x) => sum + x * x, 0) / windowSize);
                    
                    // Peak detection
                    if (energy > threshold * 2) {
                        // Check if it's a local maximum
                        const prevEnergy = Math.sqrt(
                            data.slice(i - windowSize, i).reduce((sum, x) => sum + x * x, 0) / windowSize
                        );
                        const nextEnergy = Math.sqrt(
                            data.slice(i, i + windowSize).reduce((sum, x) => sum + x * x, 0) / windowSize
                        );
                        
                        if (energy > prevEnergy && energy > nextEnergy) {
                            moments.peaks.push({
                                position: i,
                                energy: energy,
                                sharpness: (energy - prevEnergy) + (energy - nextEnergy),
                                time: i / this.ctx.sampleRate
                            });
                        }
                    }
                    
                    // Valley detection (quiet moments)
                    if (energy < threshold * 0.2) {
                        moments.valleys.push({
                            position: i,
                            energy: energy,
                            duration: windowSize / this.ctx.sampleRate,
                            time: i / this.ctx.sampleRate
                        });
                    }
                }
                
                // Find rhythmic points using onset detection refinement
                for (let onset of analysis.onsets) {
                    // Analyze the attack characteristics
                    const attackWindow = 256;
                    if (onset + attackWindow < data.length) {
                        const attackData = data.slice(onset, onset + attackWindow);
                        const attackSlope = this.calculateAttackSlope(attackData);
                        
                        moments.rhythmicPoints.push({
                            position: onset,
                            strength: attackSlope,
                            time: onset / this.ctx.sampleRate,
                            type: attackSlope > 10 ? 'hard' : 'soft'
                        });
                    }
                }
                
                // Find melodic phrases using pitch tracking
                if (analysis.pitch > 0) {
                    const pitchContour = await this.trackPitchContour(data);
                    const phrases = this.segmentMelodicPhrases(pitchContour);
                    moments.melodicPhrases = phrases;
                }
                
                // Detect transients (sudden changes)
                const transientThreshold = analysis.peak * 0.3;
                for (let i = 1; i < data.length - 1; i++) {
                    const diff = Math.abs(data[i] - data[i-1]);
                    if (diff > transientThreshold) {
                        moments.transients.push({
                            position: i,
                            magnitude: diff,
                            time: i / this.ctx.sampleRate
                        });
                    }
                }
                
                // Intelligent grouping of moments into musical sections
                moments.musicalSections = this.groupMomentsIntoSections(moments, analysis);
                
                return moments;
            }
            
            calculateAttackSlope(attackData) {
                // Calculate the slope of the attack
                let maxSlope = 0;
                for (let i = 1; i < attackData.length; i++) {
                    const slope = Math.abs(attackData[i] - attackData[i-1]);
                    maxSlope = Math.max(maxSlope, slope);
                }
                return maxSlope * 1000; // Scale for easier comparison
            }
            
            async trackPitchContour(data) {
                const contour = [];
                const hopSize = 512;
                const windowSize = 2048;
                
                for (let i = 0; i < data.length - windowSize; i += hopSize) {
                    const window = data.slice(i, i + windowSize);
                    const pitch = this.detectPitch(window);
                    contour.push({
                        time: i / this.ctx.sampleRate,
                        pitch: pitch,
                        confidence: pitch > 0 ? this.calculatePitchConfidence(window, pitch) : 0
                    });
                }
                
                return contour;
            }
            
            calculatePitchConfidence(window, detectedPitch) {
                // Simple confidence metric based on periodicity
                if (detectedPitch === 0) return 0;
                
                const period = Math.round(this.ctx.sampleRate / detectedPitch);
                if (period >= window.length / 2) return 0;
                
                let correlation = 0;
                let count = 0;
                
                for (let i = 0; i < window.length - period; i++) {
                    correlation += window[i] * window[i + period];
                    count++;
                }
                
                return Math.max(0, Math.min(1, correlation / count * 10));
            }
            
            segmentMelodicPhrases(pitchContour) {
                const phrases = [];
                let currentPhrase = null;
                const minPhraseLength = 0.1; // seconds
                
                for (let i = 0; i < pitchContour.length; i++) {
                    const point = pitchContour[i];
                    
                    if (point.confidence > 0.5) {
                        if (!currentPhrase) {
                            currentPhrase = {
                                startTime: point.time,
                                pitches: [point.pitch],
                                confidences: [point.confidence]
                            };
                        } else {
                            currentPhrase.pitches.push(point.pitch);
                            currentPhrase.confidences.push(point.confidence);
                        }
                    } else if (currentPhrase) {
                        currentPhrase.endTime = pitchContour[i-1].time;
                        if (currentPhrase.endTime - currentPhrase.startTime >= minPhraseLength) {
                            phrases.push(currentPhrase);
                        }
                        currentPhrase = null;
                    }
                }
                
                return phrases;
            }
            
            groupMomentsIntoSections(moments, analysis) {
                const sections = [];
                const sectionDuration = 60 / this.bpm; // One beat
                const totalDuration = analysis.duration;
                
                for (let time = 0; time < totalDuration; time += sectionDuration) {
                    const section = {
                        startTime: time,
                        endTime: Math.min(time + sectionDuration, totalDuration),
                        peaks: moments.peaks.filter(p => p.time >= time && p.time < time + sectionDuration),
                        rhythmic: moments.rhythmicPoints.filter(r => r.time >= time && r.time < time + sectionDuration),
                        energy: 0,
                        character: 'neutral'
                    };
                    
                    // Calculate section energy
                    section.energy = section.peaks.reduce((sum, p) => sum + p.energy, 0) / Math.max(1, section.peaks.length);
                    
                    // Determine character
                    if (section.rhythmic.length > 2) section.character = 'rhythmic';
                    else if (section.peaks.length > 1) section.character = 'dynamic';
                    else if (section.energy < analysis.rms * 0.3) section.character = 'quiet';
                    else section.character = 'sustained';
                    
                    sections.push(section);
                }
                
                return sections;
            }
            
            async createIntelligentSlices(buffer, analysis, musicalMoments) {
                const slices = [];
                const data = buffer.getChannelData(0);
                
                // Create slices based on musical sections
                for (let section of musicalMoments.musicalSections) {
                    const startSample = Math.floor(section.startTime * this.ctx.sampleRate);
                    const endSample = Math.floor(section.endTime * this.ctx.sampleRate);
                    
                    if (startSample < data.length && endSample <= data.length) {
                        const sliceLength = endSample - startSample;
                        const sliceBuffer = this.ctx.createBuffer(1, sliceLength, buffer.sampleRate);
                        const sliceData = sliceBuffer.getChannelData(0);
                        
                        // Copy with fade in/out
                        const fadeLength = Math.min(64, sliceLength / 10);
                        for (let i = 0; i < sliceLength; i++) {
                            let sample = data[startSample + i];
                            
                            // Fade in
                            if (i < fadeLength) {
                                sample *= i / fadeLength;
                            }
                            // Fade out
                            else if (i > sliceLength - fadeLength) {
                                sample *= (sliceLength - i) / fadeLength;
                            }
                            
                            sliceData[i] = sample;
                        }
                        
                        slices.push({
                            buffer: sliceBuffer,
                            startTime: section.startTime,
                            duration: section.endTime - section.startTime,
                            energy: section.energy,
                            character: section.character,
                            peaks: section.peaks.length,
                            rhythmicStrength: section.rhythmic.reduce((sum, r) => sum + r.strength, 0)
                        });
                    }
                }
                
                // Also create micro-slices from individual transients for glitch effects
                const glitchSlices = [];
                for (let transient of musicalMoments.transients.slice(0, 16)) { // Limit to 16
                    const start = Math.max(0, transient.position - 64);
                    const length = 128;
                    
                    if (start + length < data.length) {
                        const glitchBuffer = this.ctx.createBuffer(1, length, buffer.sampleRate);
                        const glitchData = glitchBuffer.getChannelData(0);
                        
                        for (let i = 0; i < length; i++) {
                            glitchData[i] = data[start + i];
                        }
                        
                        glitchSlices.push({
                            buffer: glitchBuffer,
                            type: 'glitch',
                            magnitude: transient.magnitude
                        });
                    }
                }
                
                return { main: slices, glitch: glitchSlices };
            }
            
            generateInitialPattern(analysis, slotType) {
                const pattern = new Array(16).fill(0);
                
                // Generate patterns based on slot type and analysis
                switch (slotType) {
                    case 'drums':
                        // Create drum patterns based on detected rhythm
                        pattern[0] = 1;  // Kick on 1
                        pattern[4] = 0.5; // Ghost note
                        pattern[8] = 0.8; // Snare
                        pattern[12] = 0.3; // Ghost
                        
                        // Add hi-hat pattern based on energy
                        if (analysis.brightness > 0.5) {
                            for (let i = 0; i < 16; i += 2) {
                                pattern[i] = Math.max(pattern[i], 0.4);
                            }
                        }
                        break;
                        
                    case 'bass':
                        // Bass pattern following root notes
                        pattern[0] = 1;
                        pattern[6] = 0.7;
                        pattern[10] = 0.5;
                        if (analysis.tonality > 0.7) {
                            pattern[3] = 0.3;
                            pattern[13] = 0.4;
                        }
                        break;
                        
                    case 'melody':
                        // Melodic pattern based on phrase detection
                        if (analysis.onsets.length > 0) {
                            // Map onsets to 16th note grid
                            const beatLength = 60 / this.bpm / 4;
                            analysis.onsets.forEach(onset => {
                                const beatPos = (onset / this.ctx.sampleRate) / beatLength;
                                const gridPos = Math.round(beatPos) % 16;
                                pattern[gridPos] = 0.8;
                            });
                        } else {
                            // Default melodic pattern
                            pattern[0] = 1;
                            pattern[3] = 0.6;
                            pattern[7] = 0.8;
                            pattern[11] = 0.4;
                        }
                        break;
                        
                    case 'lead':
                        // Sparse lead pattern
                        pattern[0] = 1;
                        pattern[7] = 0.7;
                        pattern[12] = 0.5;
                        break;
                }
                
                return pattern;
            }
            
            createVariations(basePattern) {
                const variations = [];
                
                // Variation 1: Inverse
                variations.push(basePattern.map(v => v > 0 ? 1 - v : 0));
                
                // Variation 2: Shifted
                const shifted = [...basePattern];
                shifted.push(shifted.shift());
                variations.push(shifted);
                
                // Variation 3: Density increase
                variations.push(basePattern.map((v, i) => 
                    v > 0 ? v : (i % 4 === 2 ? 0.3 : 0)
                ));
                
                // Variation 4: Syncopated
                variations.push(basePattern.map((v, i) => 
                    i % 3 === 1 ? Math.min(1, v + 0.3) : v * 0.7
                ));
                
                return variations;
            }
            
            initializeAIDJ(slotIndex) {
                const slot = this.sampler.slots[slotIndex];
                
                // AI DJ state for this slot
                slot.aiDJ = {
                    active: true,
                    mood: 'neutral',
                    energy: 0.5,
                    complexity: 0.5,
                    lastChange: this.ctx.currentTime,
                    changeInterval: 8, // bars
                    currentVariation: 0,
                    effects: {
                        filter: { freq: 1000, res: 1 },
                        delay: { amount: 0, time: 0.375 },
                        reverb: { amount: 0 },
                        gate: { threshold: 0 }
                    }
                };
                
                // Start the AI DJ process for this slot
                this.runAIDJ(slotIndex);
            }
            
            runAIDJ(slotIndex) {
                const slot = this.sampler.slots[slotIndex];
                if (!slot.aiDJ || !slot.aiDJ.active) return;
                
                const beatLength = 60 / this.bpm;
                const barLength = beatLength * 4;
                const checkInterval = barLength * 1000; // Check every bar
                
                const djProcess = () => {
                    if (!slot.filled || !this.activeSources.has(slotIndex)) return;
                    
                    const now = this.ctx.currentTime;
                    const timeSinceChange = now - slot.aiDJ.lastChange;
                    
                    // Analyze current state
                    const currentEnergy = this.calculateCurrentEnergy();
                    const crowdResponse = this.motion.intensity;
                    
                    // Decision making
                    if (timeSinceChange > barLength * slot.aiDJ.changeInterval) {
                        // Time for a change
                        this.makeAIDJDecision(slotIndex, currentEnergy, crowdResponse);
                        slot.aiDJ.lastChange = now;
                    }
                    
                    // Apply continuous modulation
                    this.applyAIDJModulation(slotIndex);
                    
                    // Schedule next check
                    if (slot.aiDJ.active) {
                        setTimeout(djProcess, checkInterval);
                    }
                };
                
                djProcess();
            }
            
            calculateCurrentEnergy() {
                // Analyze current mix energy
                let energy = 0;
                let activeCount = 0;
                
                this.activeSources.forEach((nodes, idx) => {
                    const slot = this.sampler.slots[idx];
                    if (slot.analysis) {
                        energy += slot.analysis.rms;
                        activeCount++;
                    }
                });
                
                return activeCount > 0 ? energy / activeCount : 0;
            }
            
            makeAIDJDecision(slotIndex, currentEnergy, crowdResponse) {
                const slot = this.sampler.slots[slotIndex];
                const aiDJ = slot.aiDJ;
                
                // Mood analysis
                if (crowdResponse > 0.7) {
                    aiDJ.mood = 'excited';
                    aiDJ.energy = Math.min(1, aiDJ.energy + 0.1);
                } else if (crowdResponse < 0.3) {
                    aiDJ.mood = 'chill';
                    aiDJ.energy = Math.max(0.2, aiDJ.energy - 0.1);
                } else {
                    aiDJ.mood = 'groovy';
                    aiDJ.energy = 0.5 + Math.sin(this.ctx.currentTime * 0.1) * 0.2;
                }
                
                // Update UI
                if (this.elements.aiDJMood) {
                    this.elements.aiDJMood.textContent = aiDJ.mood.toUpperCase();
                    this.elements.aiDJMood.className = `ai-dj-mood ${aiDJ.mood}`;
                }
                
                // Pattern variation decision
                if (Math.random() < 0.7) { // 70% chance to change pattern
                    aiDJ.currentVariation = (aiDJ.currentVariation + 1) % slot.variations.length;
                    slot.currentPattern = slot.variations[aiDJ.currentVariation];
                }
                
                // Effect changes based on mood
                switch (aiDJ.mood) {
                    case 'excited':
                        aiDJ.effects.filter.freq = 2000 + Math.random() * 3000;
                        aiDJ.effects.filter.res = 5 + Math.random() * 10;
                        aiDJ.effects.delay.amount = Math.random() * 0.3;
                        aiDJ.changeInterval = 4; // Change more frequently
                        break;
                        
                    case 'chill':
                        aiDJ.effects.filter.freq = 500 + Math.random() * 1000;
                        aiDJ.effects.filter.res = 1 + Math.random() * 3;
                        aiDJ.effects.reverb.amount = 0.3 + Math.random() * 0.3;
                        aiDJ.changeInterval = 16; // Change less frequently
                        break;
                        
                    case 'groovy':
                        aiDJ.effects.filter.freq = 1000 + Math.sin(this.ctx.currentTime) * 500;
                        aiDJ.effects.delay.amount = 0.2;
                        aiDJ.effects.delay.time = Math.random() < 0.5 ? 0.375 : 0.25;
                        aiDJ.changeInterval = 8;
                        break;
                }
                
                // Complexity adjustment
                if (this.activeSources.size > 2) {
                    // Simplify when many elements playing
                    aiDJ.complexity = Math.max(0.3, aiDJ.complexity - 0.1);
                } else {
                    // Add complexity when sparse
                    aiDJ.complexity = Math.min(0.9, aiDJ.complexity + 0.1);
                }
            }
            
            applyAIDJModulation(slotIndex) {
                const nodes = this.activeSources.get(slotIndex);
                if (!nodes) return;
                
                const slot = this.sampler.slots[slotIndex];
                const aiDJ = slot.aiDJ;
                
                // Apply filter modulation
                if (nodes.filterNode) {
                    const targetFreq = aiDJ.effects.filter.freq * (1 + this.motion.smoothed * 0.5);
                    nodes.filterNode.frequency.linearRampToValueAtTime(
                        targetFreq,
                        this.ctx.currentTime + 0.1
                    );
                    nodes.filterNode.Q.linearRampToValueAtTime(
                        aiDJ.effects.filter.res,
                        this.ctx.currentTime + 0.1
                    );
                }
                
                // Apply gain modulation based on energy
                if (nodes.gainNode) {
                    const baseGain = { drums: 0.8, bass: 0.7, melody: 0.6, lead: 0.5 }[slot.type] || 0.6;
                    const targetGain = baseGain * aiDJ.energy * (0.8 + Math.sin(this.ctx.currentTime * 0.5) * 0.2);
                    nodes.gainNode.gain.linearRampToValueAtTime(
                        targetGain,
                        this.ctx.currentTime + 0.05
                    );
                }
            }
            
            categorizeSound(analysis) {
                // Smart categorization based on audio features
                const centroid = analysis.spectralCentroid;
                const tonality = analysis.tonality;
                const hasRhythm = analysis.onsets.length > 4;
                
                if (centroid < 200 && tonality > 0.7) {
                    return 'bass';
                } else if (centroid > 2000 && hasRhythm && tonality < 0.3) {
                    return 'drums';
                } else if (centroid > 800 && tonality > 0.6) {
                    return 'lead';
                } else {
                    return 'melody';
                }
            }
            
            async processForSlot(buffer, analysis, slotType) {
                // Calculate loop length based on BPM
                const beatLength = 60 / this.bpm; // seconds per beat
                const barLength = beatLength * 4; // 4/4 time
                
                // Determine optimal loop length (1, 2, or 4 bars)
                let targetBars = 1;
                if (buffer.duration > barLength * 3) targetBars = 4;
                else if (buffer.duration > barLength * 1.5) targetBars = 2;
                
                const targetLength = barLength * targetBars;
                
                // Create a perfectly looped buffer
                const loopedBuffer = this.createPerfectLoop(buffer, targetLength);
                
                // Apply type-specific processing
                return await this.applyTypeProcessing(loopedBuffer, slotType);
            }
            
            createPerfectLoop(buffer, targetLength) {
                const sampleRate = buffer.sampleRate;
                const targetSamples = Math.floor(targetLength * sampleRate);
                const sourceSamples = buffer.length;
                
                // Create new buffer
                const loopBuffer = this.ctx.createBuffer(
                    buffer.numberOfChannels,
                    targetSamples,
                    sampleRate
                );
                
                for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                    const sourceData = buffer.getChannelData(channel);
                    const loopData = loopBuffer.getChannelData(channel);
                    
                    if (sourceSamples >= targetSamples) {
                        // Trim to target length with crossfade
                        const fadeLength = Math.floor(sampleRate * 0.01); // 10ms fade
                        
                        // Copy main portion
                        for (let i = 0; i < targetSamples - fadeLength; i++) {
                            loopData[i] = sourceData[i];
                        }
                        
                        // Crossfade at loop point
                        for (let i = 0; i < fadeLength; i++) {
                            const fadeIn = i / fadeLength;
                            const fadeOut = 1 - fadeIn;
                            loopData[targetSamples - fadeLength + i] = 
                                sourceData[targetSamples - fadeLength + i] * fadeOut +
                                sourceData[i] * fadeIn;
                        }
                    } else {
                        // Loop to fill target length
                        for (let i = 0; i < targetSamples; i++) {
                            loopData[i] = sourceData[i % sourceSamples];
                        }
                    }
                }
                
                return loopBuffer;
            }
            
            async applyTypeProcessing(buffer, slotType) {
                const offlineCtx = new OfflineAudioContext(
                    buffer.numberOfChannels,
                    buffer.length,
                    buffer.sampleRate
                );
                
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                
                let lastNode = source;
                
                // Apply type-specific effects
                switch (slotType) {
                    case 'drums':
                        const drumComp = offlineCtx.createDynamicsCompressor();
                        drumComp.threshold.value = -12;
                        drumComp.knee.value = 2;
                        drumComp.ratio.value = 8;
                        drumComp.attack.value = 0.001;
                        drumComp.release.value = 0.1;
                        lastNode.connect(drumComp);
                        lastNode = drumComp;
                        break;
                        
                    case 'bass':
                        const bassFilter = offlineCtx.createBiquadFilter();
                        bassFilter.type = 'lowpass';
                        bassFilter.frequency.value = 300;
                        bassFilter.Q.value = 2;
                        lastNode.connect(bassFilter);
                        lastNode = bassFilter;
                        break;
                        
                    case 'melody':
                        const melodyFilter = offlineCtx.createBiquadFilter();
                        melodyFilter.type = 'bandpass';
                        melodyFilter.frequency.value = 800;
                        melodyFilter.Q.value = 1;
                        lastNode.connect(melodyFilter);
                        lastNode = melodyFilter;
                        break;
                        
                    case 'lead':
                        const leadFilter = offlineCtx.createBiquadFilter();
                        leadFilter.type = 'highpass';
                        leadFilter.frequency.value = 200;
                        leadFilter.Q.value = 0.7;
                        lastNode.connect(leadFilter);
                        lastNode = leadFilter;
                        break;
                }
                
                lastNode.connect(offlineCtx.destination);
                source.start();
                
                return await offlineCtx.startRendering();
            }
            
            drawWaveform(slotIndex, buffer) {
                const { ctx, canvas } = this.canvases[`waveform${slotIndex}`];
                const data = buffer.getChannelData(0);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.618)';
                ctx.lineWidth = 1;
                
                const step = Math.ceil(data.length / canvas.width);
                const amp = canvas.height / 2;
                
                ctx.beginPath();
                for (let i = 0; i < canvas.width; i++) {
                    const index = i * step;
                    const value = data[index] || 0;
                    const y = amp + value * amp * 0.8;
                    
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
            }
            
            toggleSlotPlayback(slotIndex) {
                if (this.activeSources.has(slotIndex)) {
                    this.stopSlotPlayback(slotIndex);
                } else {
                    this.startSlotPlayback(slotIndex);
                }
            }
            
            startSlotPlayback(slotIndex) {
                const slot = this.sampler.slots[slotIndex];
                if (!slot.filled || !slot.buffer) return;
                
                // Create nodes
                const gainNode = this.ctx.createGain();
                const filterNode = this.ctx.createBiquadFilter();
                const delayNode = this.ctx.createDelay(1);
                const delayGain = this.ctx.createGain();
                const delayFeedback = this.ctx.createGain();
                
                // Setup filter based on slot type
                filterNode.type = 'lowpass';
                filterNode.frequency.value = 20000;
                filterNode.Q.value = 1;
                
                // Setup delay
                delayNode.delayTime.value = 0.375;
                delayFeedback.gain.value = 0.3;
                delayGain.gain.value = 0;
                
                // Set gain based on slot type
                const gains = { drums: 0.8, bass: 0.7, melody: 0.6, lead: 0.5 };
                gainNode.gain.value = gains[slot.type] || 0.6;
                
                // Connect effects chain
                filterNode.connect(gainNode);
                gainNode.connect(this.masterGain);
                
                // Delay chain
                gainNode.connect(delayNode);
                delayNode.connect(delayFeedback);
                delayFeedback.connect(delayNode);
                delayNode.connect(delayGain);
                delayGain.connect(this.masterGain);
                
                // Store node references
                const nodeGroup = {
                    gainNode,
                    filterNode,
                    delayNode,
                    delayGain,
                    delayFeedback,
                    sources: new Map(),
                    nextStepTime: this.getNextBeatTime()
                };
                
                this.activeSources.set(slotIndex, nodeGroup);
                
                // Start pattern playback
                this.scheduleSlotPattern(slotIndex);
                
                // Update UI
                document.querySelectorAll('.sample-slot')[slotIndex].classList.add('playing');
            }
            
            scheduleSlotPattern(slotIndex) {
                const slot = this.sampler.slots[slotIndex];
                const nodeGroup = this.activeSources.get(slotIndex);
                if (!slot || !nodeGroup) return;
                
                const scheduleAhead = () => {
                    if (!this.activeSources.has(slotIndex)) return;
                    
                    const currentTime = this.ctx.currentTime;
                    const beatLength = 60 / this.bpm / 4; // 16th note
                    
                    // Schedule ahead
                    while (nodeGroup.nextStepTime < currentTime + 0.1) {
                        const stepIndex = this.currentBeat % 16;
                        const velocity = slot.currentPattern[stepIndex];
                        
                        if (velocity > 0) {
                            this.triggerSlotSound(slotIndex, nodeGroup.nextStepTime, velocity);
                        }
                        
                        nodeGroup.nextStepTime += beatLength;
                    }
                    
                    // Continue scheduling
                    setTimeout(scheduleAhead, 25);
                };
                
                scheduleAhead();
            }
            
            triggerSlotSound(slotIndex, when, velocity) {
                const slot = this.sampler.slots[slotIndex];
                const nodeGroup = this.activeSources.get(slotIndex);
                if (!slot || !nodeGroup) return;
                
                // Choose which slice to play
                let bufferToPlay = slot.buffer;
                
                if (slot.slices && slot.slices.main.length > 0) {
                    // Intelligent slice selection based on AI DJ state
                    if (slot.aiDJ && slot.aiDJ.complexity > 0.7 && Math.random() < 0.3) {
                        // Sometimes play a different slice for variation
                        const sliceIndex = Math.floor(Math.random() * slot.slices.main.length);
                        bufferToPlay = slot.slices.main[sliceIndex].buffer;
                    } else if (slot.aiDJ && slot.aiDJ.mood === 'excited' && Math.random() < 0.1) {
                        // Occasionally throw in a glitch
                        if (slot.slices.glitch.length > 0) {
                            const glitchIndex = Math.floor(Math.random() * slot.slices.glitch.length);
                            bufferToPlay = slot.slices.glitch[glitchIndex].buffer;
                        }
                    } else {
                        // Play the main slice that matches current energy
                        const targetEnergy = slot.aiDJ ? slot.aiDJ.energy : 0.5;
                        let bestSlice = slot.slices.main[0];
                        let bestDiff = Math.abs(bestSlice.energy - targetEnergy);
                        
                        for (let slice of slot.slices.main) {
                            const diff = Math.abs(slice.energy - targetEnergy);
                            if (diff < bestDiff) {
                                bestDiff = diff;
                                bestSlice = slice;
                            }
                        }
                        
                        bufferToPlay = bestSlice.buffer;
                    }
                }
                
                // Create and play source
                const source = this.ctx.createBufferSource();
                source.buffer = bufferToPlay;
                
                // Apply playback variations
                const pitchVariation = slot.aiDJ && slot.aiDJ.mood === 'excited' ? 
                    (Math.random() - 0.5) * 0.1 : 0;
                source.playbackRate.value = 1 + pitchVariation;
                
                // Apply velocity
                const velocityGain = this.ctx.createGain();
                velocityGain.gain.value = velocity * (0.8 + Math.random() * 0.2);
                
                // Connect
                source.connect(velocityGain);
                velocityGain.connect(nodeGroup.filterNode);
                
                // Start
                source.start(when);
                
                // Store reference for potential stopping
                const sourceId = Date.now() + Math.random();
                nodeGroup.sources.set(sourceId, source);
                
                source.onended = () => {
                    nodeGroup.sources.delete(sourceId);
                };
                
                // Visual feedback
                const slotElement = document.querySelectorAll('.sample-slot')[slotIndex];
                setTimeout(() => {
                    slotElement.style.filter = `brightness(${1 + velocity * 0.5})`;
                    setTimeout(() => {
                        slotElement.style.filter = 'brightness(1)';
                    }, 50);
                }, (when - this.ctx.currentTime) * 1000);
            }
            
            stopSlotPlayback(slotIndex) {
                const nodeGroup = this.activeSources.get(slotIndex);
                if (nodeGroup) {
                    // Stop all sources
                    nodeGroup.sources.forEach(source => {
                        try {
                            source.stop();
                        } catch (e) {
                            // Source may have already stopped
                        }
                    });
                    
                    // Clean up
                    this.activeSources.delete(slotIndex);
                    
                    const slot = this.sampler.slots[slotIndex];
                    if (slot.aiDJ) {
                        slot.aiDJ.active = false;
                    }
                    
                    // Update UI
                    document.querySelectorAll('.sample-slot')[slotIndex].classList.remove('playing');
                }
            }
            
            getNextBeatTime() {
                const beatLength = 60 / this.bpm;
                const currentTime = this.ctx.currentTime;
                const beatsSinceStart = currentTime / beatLength;
                const nextBeat = Math.ceil(beatsSinceStart) * beatLength;
                return nextBeat;
            }
            
            updateOutfitParameters() {
                // Adjust musical parameters based on outfit
                switch (this.outfit) {
                    case 'cosmic':
                        this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
                        this.swing = 0.05;
                        break;
                    case 'urban':
                        this.scale = [0, 3, 5, 6, 7, 10]; // Blues scale
                        this.swing = 0.15;
                        break;
                    case 'nature':
                        this.scale = [0, 2, 4, 5, 7, 9, 11]; // Major scale
                        this.swing = 0.1;
                        break;
                    case 'minimal':
                        this.scale = [0, 2, 5, 7, 9]; // Pentatonic
                        this.swing = 0;
                        break;
                }
                
                // Apply filter changes to active samples
                this.activeSources.forEach((nodes, slotIndex) => {
                    const slot = this.sampler.slots[slotIndex];
                    if (nodes.filterNode) {
                        const filterFreqs = {
                            cosmic: 2000,
                            urban: 5000,
                            nature: 3000,
                            minimal: 1000
                        };
                        nodes.filterNode.frequency.linearRampToValueAtTime(
                            filterFreqs[this.outfit],
                            this.ctx.currentTime + 0.5
                        );
                    }
                });
            }
            
            startEngine() {
                // Start scheduler
                this.startScheduler();
                
                // Start visualizations
                this.animate();
                
                // Generate atmospheric base
                this.generateAtmosphere();
            }
            
            startScheduler() {
                const scheduleNote = () => {
                    // Schedule notes
                    while (this.scheduler.nextNoteTime < this.ctx.currentTime + this.scheduler.scheduleAheadTime) {
                        this.scheduleStep();
                        this.nextNote();
                    }
                    
                    // Apply motion modulation to active samples
                    this.modulateActiveSamples();
                    
                    this.scheduler.timerId = setTimeout(scheduleNote, this.scheduler.lookahead);
                };
                
                this.scheduler.nextNoteTime = this.ctx.currentTime;
                scheduleNote();
            }
            
            scheduleStep() {
                const stepTime = this.scheduler.nextNoteTime;
                
                // Visual feedback for beat
                if (this.currentBeat % 16 === 0) {
                    this.activeSources.forEach((nodes, slotIndex) => {
                        const slotElement = document.querySelectorAll('.sample-slot')[slotIndex];
                        slotElement.style.transform = 'scale(1.05)';
                        setTimeout(() => {
                            slotElement.style.transform = 'scale(1)';
                        }, 100);
                    });
                }
                
                // Generative elements based on motion
                if (this.motion.intensity > 0.3 && this.currentBeat % 4 === 0) {
                    this.playGenerativeNote(stepTime);
                }
            }
            
            modulateActiveSamples() {
                this.activeSources.forEach((nodeGroup, slotIndex) => {
                    const slot = this.sampler.slots[slotIndex];
                    
                    // Modulate filter based on motion and AI DJ state
                    if (nodeGroup.filterNode) {
                        let targetFreq = 1000 + slotIndex * 500;
                        
                        if (slot.aiDJ) {
                            targetFreq = slot.aiDJ.effects.filter.freq;
                        }
                        
                        // Add motion modulation
                        targetFreq += this.motion.smoothed * 2000;
                        
                        nodeGroup.filterNode.frequency.linearRampToValueAtTime(
                            targetFreq,
                            this.ctx.currentTime + 0.1
                        );
                        
                        // Resonance based on motion intensity and AI state
                        const targetQ = slot.aiDJ ? 
                            slot.aiDJ.effects.filter.res : 
                            (1 + this.motion.intensity * 5);
                            
                        nodeGroup.filterNode.Q.linearRampToValueAtTime(
                            targetQ,
                            this.ctx.currentTime + 0.1
                        );
                    }
                    
                    // Modulate delay based on AI DJ
                    if (nodeGroup.delayGain && slot.aiDJ) {
                        nodeGroup.delayGain.gain.linearRampToValueAtTime(
                            slot.aiDJ.effects.delay.amount,
                            this.ctx.currentTime + 0.1
                        );
                        
                        nodeGroup.delayNode.delayTime.linearRampToValueAtTime(
                            slot.aiDJ.effects.delay.time,
                            this.ctx.currentTime + 0.1
                        );
                    }
                    
                    // Overall gain modulation
                    if (nodeGroup.gainNode) {
                        const baseGain = { drums: 0.8, bass: 0.7, melody: 0.6, lead: 0.5 }[slot.type] || 0.6;
                        let modGain = baseGain;
                        
                        if (slot.aiDJ) {
                            modGain *= slot.aiDJ.energy;
                        }
                        
                        // Add subtle pumping effect
                        const pump = Math.sin(this.currentBeat * Math.PI / 8) * 0.1 + 0.9;
                        modGain *= pump;
                        
                        nodeGroup.gainNode.gain.linearRampToValueAtTime(
                            modGain,
                            this.ctx.currentTime + 0.05
                        );
                    }
                });
            }
            
            playGenerativeNote(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                // Pick note from scale based on motion
                const noteIndex = Math.floor(this.motion.direction.x * this.scale.length + this.scale.length / 2);
                const note = this.scale[Math.abs(noteIndex) % this.scale.length];
                const octave = 3 + Math.floor(this.motion.direction.y + 1);
                
                const frequency = 440 * Math.pow(2, (note - 9) / 12 + (octave - 4));
                
                osc.type = 'sine';
                osc.frequency.value = frequency;
                
                filter.type = 'bandpass';
                filter.frequency.value = frequency;
                filter.Q.value = 5 + this.motion.intensity * 10;
                
                const now = when || this.ctx.currentTime;
                const duration = 0.1 + this.motion.intensity * 0.3;
                
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1 * (1 - this.motion.intensity * 0.5), now + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);
                
                osc.start(now);
                osc.stop(now + duration);
            }
            
            nextNote() {
                const secondsPerBeat = 60.0 / this.bpm / 4; // 16th notes
                this.scheduler.nextNoteTime += secondsPerBeat;
                
                // Apply swing
                if (this.currentBeat % 2 === 1) {
                    this.scheduler.nextNoteTime += secondsPerBeat * this.swing;
                }
                
                this.currentBeat++;
            }
            
            generateAtmosphere() {
                const createDrone = () => {
                    if (!this.ctx) return;
                    
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    const baseFreq = 55 * Math.pow(2, this.scale[0] / 12); // Root note
                    
                    osc1.type = 'triangle';
                    osc1.frequency.value = baseFreq;
                    osc1.detune.value = this.motion.smoothed * 5;
                    
                    osc2.type = 'triangle';
                    osc2.frequency.value = baseFreq * this.phi;
                    osc2.detune.value = -this.motion.smoothed * 5;
                    
                    filter.type = 'lowpass';
                    filter.frequency.value = 200 + this.motion.smoothed * 100;
                    filter.Q.value = 5;
                    
                    const now = this.ctx.currentTime;
                    const duration = 13;
                    
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.05, now + 3);
                    gain.gain.setValueAtTime(0.05, now + duration - 3);
                    gain.gain.linearRampToValueAtTime(0, now + duration);
                    
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.reverb);
                    
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + duration);
                    osc2.stop(now + duration);
                    
                    setTimeout(createDrone, 8000);
                };
                
                createDrone();
            }
            
            animate() {
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    this.drawVisualizer();
                    this.drawParticles();
                };
                
                draw();
            }
            
            drawVisualizer() {
                const { ctx, canvas } = this.canvases.visualizer;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                this.analyser.getByteFrequencyData(dataArray);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / bufferLength * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height * 0.7;
                    
                    const hue = (i / bufferLength) * 360 + this.currentBeat;
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                    
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            }
            
            drawParticles() {
                const { ctx, canvas } = this.canvases.particles;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Fibonacci particles
                const count = 8 + Math.floor(this.motion.intensity * 13);
                const time = Date.now() * 0.001;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + time * 0.1;
                    const radius = 50 + this.motion.smoothed * 100 + Math.sin(time + i) * 20;
                    
                    const x = canvas.width / 2 + Math.cos(angle) * radius;
                    const y = canvas.height / 2 + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + this.motion.intensity * 2, 0, Math.PI * 2);
                    
                    const alpha = 0.3 + this.motion.intensity * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fill();
                }
            }
        }
        
        // Initialize
        const gump = new GumpEngine();
    </script>
</body>
</html>
