<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>REALITY SYNTHESIZER</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      overflow: hidden;
      height: 100vh;
      cursor: none;
      font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
      position: relative;
      touch-action: none;
    }
    
    /* Neural visualization */
    #neural-field {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0.15;
    }
    
    .neural-node {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(255, 255, 255, 0.5);
      border-radius: 50%;
      pointer-events: none;
    }
    
    .neural-connection {
      position: absolute;
      height: 1px;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transform-origin: left center;
      pointer-events: none;
    }
    
    /* Core breathing element */
    #core {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 144px;
      height: 144px;
      pointer-events: none;
    }
    
    .core-ring {
      position: absolute;
      border-radius: 50%;
      border: 1px solid rgba(255, 255, 255, 0.03);
      animation: rotate 60s linear infinite;
    }
    
    .core-ring:nth-child(1) { 
      width: 34px; height: 34px; 
      top: 55px; left: 55px;
      animation-duration: 21s;
      border-color: rgba(255, 255, 255, 0.08);
    }
    
    .core-ring:nth-child(2) { 
      width: 55px; height: 55px; 
      top: 44.5px; left: 44.5px;
      animation-duration: 34s;
      animation-direction: reverse;
    }
    
    .core-ring:nth-child(3) { 
      width: 89px; height: 89px; 
      top: 27.5px; left: 27.5px;
      animation-duration: 55s;
    }
    
    .core-ring:nth-child(4) { 
      width: 144px; height: 144px; 
      top: 0; left: 0;
      animation-duration: 89s;
      animation-direction: reverse;
    }
    
    .core-ring.active {
      border-color: rgba(255, 255, 255, 0.2);
      box-shadow: 0 0 20px rgba(255, 255, 255, 0.1);
    }
    
    .core-ring.recording {
      border-color: rgba(255, 100, 100, 0.3);
      box-shadow: 0 0 30px rgba(255, 0, 0, 0.2);
    }
    
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    /* Sample visualization */
    .sample-ghost {
      position: absolute;
      width: 5px;
      height: 5px;
      background: radial-gradient(circle, rgba(255,255,255,0.3), transparent);
      border-radius: 50%;
      pointer-events: none;
      animation: ghost-float 13s ease-in-out infinite;
    }
    
    @keyframes ghost-float {
      0%, 100% { 
        transform: translate(0, 0) scale(1); 
        opacity: 0;
      }
      20% { opacity: 0.5; }
      50% { 
        transform: translate(var(--dx), var(--dy)) scale(2); 
        opacity: 0.3;
      }
      80% { opacity: 0; }
    }
    
    /* Waveform display */
    #waveform {
      position: fixed;
      bottom: 89px;
      left: 50%;
      transform: translateX(-50%);
      width: 377px;
      height: 55px;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1px;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    #waveform.visible {
      opacity: 0.3;
    }
    
    .wave-bar {
      width: 1px;
      background: rgba(255, 255, 255, 0.5);
      transition: height 0.05s ease;
    }
    
    /* Status indicators */
    #status {
      position: fixed;
      top: 34px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 21px;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    #status.visible {
      opacity: 0.5;
    }
    
    .indicator {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.1);
      transition: all 0.3s ease;
    }
    
    .indicator.active {
      background: rgba(255, 255, 255, 0.5);
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.3);
    }
    
    /* Minimal text */
    #message {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 13px;
      letter-spacing: 8px;
      color: rgba(255, 255, 255, 0.1);
      font-weight: 100;
      transition: all 3s ease;
      pointer-events: none;
      text-align: center;
      white-space: nowrap;
    }
    
    #message.hidden {
      opacity: 0;
      letter-spacing: 21px;
      filter: blur(5px);
    }
    
    /* Motion trail */
    .motion-trail {
      position: fixed;
      width: 3px;
      height: 3px;
      background: rgba(255, 255, 255, 0.2);
      border-radius: 50%;
      pointer-events: none;
      animation: trail-fade 2s ease-out forwards;
    }
    
    @keyframes trail-fade {
      to { 
        transform: scale(3);
        opacity: 0;
      }
    }
    
    /* Spectrum */
    #spectrum {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 144px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      pointer-events: none;
      opacity: 0.15;
    }
    
    .spectrum-bar {
      flex: 1;
      max-width: 3px;
      background: linear-gradient(to top, 
        rgba(255, 255, 255, 0.1),
        rgba(255, 255, 255, 0.05),
        transparent
      );
      margin: 0 1px;
      transition: height 0.05s ease;
    }
  </style>
</head>
<body>
  <div id="neural-field"></div>
  <div id="core">
    <div class="core-ring"></div>
    <div class="core-ring"></div>
    <div class="core-ring"></div>
    <div class="core-ring"></div>
  </div>
  <div id="status">
    <div class="indicator" data-layer="rhythm"></div>
    <div class="indicator" data-layer="harmony"></div>
    <div class="indicator" data-layer="melody"></div>
    <div class="indicator" data-layer="texture"></div>
    <div class="indicator" data-layer="space"></div>
  </div>
  <div id="waveform"></div>
  <div id="spectrum"></div>
  <div id="message">TOUCH THE VOID</div>

  <script>
    'use strict';

    // ============================================
    // REALITY SYNTHESIZER - Professional Audio Engine
    // ============================================
    
    class RealitySynthesizer {
      constructor() {
        // Core audio context
        this.ctx = null;
        this.isActive = false;
        
        // Timing and tempo
        this.bpm = 120;
        this.currentStep = 0;
        this.currentBar = 0;
        this.stepTime = 0;
        this.nextStepTime = 0;
        this.lookahead = 25.0; // ms
        this.scheduleAheadTime = 0.1; // seconds
        this.timerWorker = null;
        
        // Musical parameters
        this.rootNote = 48; // C3 in MIDI
        this.scale = [0, 2, 3, 5, 7, 8, 10, 12]; // Natural minor + octave
        this.currentChord = [0, 3, 7];
        this.chordProgression = [
          [0, 3, 7, 10],    // Cm7
          [5, 8, 12, 15],   // Fm7
          [7, 10, 14, 17],  // Gm7
          [3, 7, 10, 14]    // Eb M7
        ];
        this.currentChordIndex = 0;
        
        // Sample management
        this.sampleBank = [];
        this.recordingBuffer = [];
        this.isRecording = false;
        this.recordingStartTime = 0;
        this.maxSamples = 16;
        this.sampleSlots = new Array(16).fill(null);
        this.grainCloud = [];
        
        // Motion and gesture tracking
        this.motion = {
          current: { x: 0, y: 0, z: 0 },
          velocity: { x: 0, y: 0, z: 0 },
          acceleration: { x: 0, y: 0, z: 0 },
          intensity: 0,
          pattern: 'still',
          history: []
        };
        
        // Evolution parameters
        this.evolution = {
          complexity: 0,
          density: 0.2,
          chaos: 0,
          harmony: 1,
          space: 0.3,
          time: 0
        };
        
        // Layer states
        this.layers = {
          rhythm: {
            active: true,
            elements: ['kick', 'snare', 'hihat', 'perc'],
            intensity: 0.8,
            pattern: 0,
            variations: []
          },
          harmony: {
            active: false,
            elements: ['bass', 'chords', 'pad'],
            intensity: 0.6,
            voicing: 'close'
          },
          melody: {
            active: false,
            elements: ['lead', 'arp', 'counter'],
            intensity: 0.4,
            phrases: []
          },
          texture: {
            active: false,
            elements: ['noise', 'grain', 'field'],
            intensity: 0.3
          },
          space: {
            active: false,
            elements: ['reverb', 'delay', 'chorus'],
            intensity: 0.5
          }
        };
        
        // Audio nodes
        this.nodes = {
          master: null,
          limiter: null,
          analyser: null,
          layers: {},
          effects: {},
          buses: {}
        };
        
        // Voice allocation
        this.voices = new Map();
        this.maxVoices = 64;
        this.voicePool = [];
        
        // Pattern sequences
        this.patterns = {
          kick: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
          snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
          hihat: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
          bass: [1,0,0,1, 0,0,1,0, 1,0,0,0, 1,0,1,0]
        };
        
        // Visual elements
        this.visuals = {
          neuralNodes: [],
          connections: [],
          ghosts: [],
          trails: []
        };
        
        // Initialize everything
        this.init();
      }

      // ============================================
      // INITIALIZATION
      // ============================================
      
      async init() {
        // Create neural field visualization
        this.createNeuralField();
        
        // Create waveform display
        this.createWaveform();
        
        // Create spectrum analyzer
        this.createSpectrum();
        
        // Setup interaction handlers
        this.setupInteraction();
        
        // Setup motion detection
        this.setupMotionDetection();
      }

      createNeuralField() {
        const field = document.getElementById('neural-field');
        const nodeCount = 21;
        
        // Create nodes
        for (let i = 0; i < nodeCount; i++) {
          const node = document.createElement('div');
          node.className = 'neural-node';
          node.style.left = Math.random() * 100 + '%';
          node.style.top = Math.random() * 100 + '%';
          field.appendChild(node);
          
          this.visuals.neuralNodes.push({
            element: node,
            x: parseFloat(node.style.left),
            y: parseFloat(node.style.top),
            connections: []
          });
        }
        
        // Create connections
        for (let i = 0; i < nodeCount; i++) {
          for (let j = i + 1; j < nodeCount; j++) {
            if (Math.random() < 0.1) { // 10% chance of connection
              const connection = document.createElement('div');
              connection.className = 'neural-connection';
              field.appendChild(connection);
              
              this.visuals.connections.push({
                element: connection,
                from: i,
                to: j
              });
              
              this.updateConnection(connection, i, j);
            }
          }
        }
      }

      updateConnection(element, fromIndex, toIndex) {
        const from = this.visuals.neuralNodes[fromIndex];
        const to = this.visuals.neuralNodes[toIndex];
        
        const dx = to.x - from.x;
        const dy = to.y - from.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * 180 / Math.PI;
        
        element.style.left = from.x + '%';
        element.style.top = from.y + '%';
        element.style.width = distance + '%';
        element.style.transform = `rotate(${angle}deg)`;
      }

      createWaveform() {
        const waveform = document.getElementById('waveform');
        for (let i = 0; i < 144; i++) {
          const bar = document.createElement('div');
          bar.className = 'wave-bar';
          bar.style.height = '2px';
          waveform.appendChild(bar);
        }
      }

      createSpectrum() {
        const spectrum = document.getElementById('spectrum');
        for (let i = 0; i < 89; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.height = '0px';
          spectrum.appendChild(bar);
        }
      }

      setupInteraction() {
        const startEngine = async (e) => {
          e.preventDefault();
          document.removeEventListener('click', startEngine);
          document.removeEventListener('touchstart', startEngine);
          
          await this.startEngine();
        };
        
        document.addEventListener('click', startEngine);
        document.addEventListener('touchstart', startEngine);
      }

      // ============================================
      // AUDIO ENGINE INITIALIZATION
      // ============================================
      
      async startEngine() {
        try {
          // Create audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 48000,
            latencyHint: 'interactive'
          });
          
          await this.ctx.resume();
          
          // Setup audio graph
          await this.setupAudioGraph();
          
          // Setup microphone input
          await this.setupMicrophone();
          
          // Setup timer worker for accurate timing
          this.setupTimerWorker();
          
          // Update UI
          document.getElementById('message').classList.add('hidden');
          document.getElementById('status').classList.add('visible');
          document.getElementById('waveform').classList.add('visible');
          
          // Start the engine
          this.isActive = true;
          this.scheduler();
          this.animate();
          
          console.log('Reality Synthesizer initialized');
          
        } catch (error) {
          console.error('Failed to initialize audio engine:', error);
        }
      }

      async setupAudioGraph() {
        // Master limiter
        this.nodes.limiter = this.ctx.createDynamicsCompressor();
        this.nodes.limiter.threshold.value = -1;
        this.nodes.limiter.knee.value = 0;
        this.nodes.limiter.ratio.value = 20;
        this.nodes.limiter.attack.value = 0.001;
        this.nodes.limiter.release.value = 0.05;
        
        // Master gain
        this.nodes.master = this.ctx.createGain();
        this.nodes.master.gain.value = 0.8;
        
        // Analyser for visualization
        this.nodes.analyser = this.ctx.createAnalyser();
        this.nodes.analyser.fftSize = 2048;
        this.nodes.analyser.smoothingTimeConstant = 0.8;
        
        // Create buses
        this.nodes.buses = {
          drum: this.ctx.createGain(),
          bass: this.ctx.createGain(),
          mid: this.ctx.createGain(),
          high: this.ctx.createGain(),
          fx: this.ctx.createGain()
        };
        
        // Set bus levels
        this.nodes.buses.drum.gain.value = 0.9;
        this.nodes.buses.bass.gain.value = 0.8;
        this.nodes.buses.mid.gain.value = 0.6;
        this.nodes.buses.high.gain.value = 0.5;
        this.nodes.buses.fx.gain.value = 0.3;
        
        // Create effects
        await this.setupEffects();
        
        // Connect main signal path
        Object.values(this.nodes.buses).forEach(bus => {
          bus.connect(this.nodes.master);
        });
        
        this.nodes.master.connect(this.nodes.limiter);
        this.nodes.limiter.connect(this.nodes.analyser);
        this.nodes.analyser.connect(this.ctx.destination);
      }

      async setupEffects() {
        // Main reverb - convolution
        const reverbImpulse = await this.createReverbImpulse(3, 0.7);
        this.nodes.effects.reverb = this.ctx.createConvolver();
        this.nodes.effects.reverb.buffer = reverbImpulse;
        
        this.nodes.effects.reverbSend = this.ctx.createGain();
        this.nodes.effects.reverbSend.gain.value = 0.3;
        this.nodes.effects.reverbReturn = this.ctx.createGain();
        this.nodes.effects.reverbReturn.gain.value = 0.4;
        
        // Delay
        this.nodes.effects.delay = this.ctx.createDelay(2);
        this.nodes.effects.delay.delayTime.value = 0.375; // Dotted eighth at 120 BPM
        
        this.nodes.effects.delaySend = this.ctx.createGain();
        this.nodes.effects.delaySend.gain.value = 0.3;
        this.nodes.effects.delayFeedback = this.ctx.createGain();
        this.nodes.effects.delayFeedback.gain.value = 0.4;
        this.nodes.effects.delayReturn = this.ctx.createGain();
        this.nodes.effects.delayReturn.gain.value = 0.3;
        
        // Filter for delay
        this.nodes.effects.delayFilter = this.ctx.createBiquadFilter();
        this.nodes.effects.delayFilter.type = 'highpass';
        this.nodes.effects.delayFilter.frequency.value = 400;
        
        // Chorus/Flanger
        this.nodes.effects.chorus = this.ctx.createDelay(0.05);
        this.nodes.effects.chorusLFO = this.ctx.createOscillator();
        this.nodes.effects.chorusDepth = this.ctx.createGain();
        this.nodes.effects.chorusDepth.gain.value = 0.002;
        this.nodes.effects.chorusLFO.frequency.value = 0.5;
        this.nodes.effects.chorusLFO.connect(this.nodes.effects.chorusDepth);
        this.nodes.effects.chorusDepth.connect(this.nodes.effects.chorus.delayTime);
        this.nodes.effects.chorusLFO.start();
        
        // Distortion
        this.nodes.effects.distortion = this.ctx.createWaveShaper();
        this.nodes.effects.distortion.curve = this.makeDistortionCurve(20);
        this.nodes.effects.distortion.oversample = '4x';
        
        // Connect effects chains
        this.nodes.effects.reverbSend.connect(this.nodes.effects.reverb);
        this.nodes.effects.reverb.connect(this.nodes.effects.reverbReturn);
        this.nodes.effects.reverbReturn.connect(this.nodes.buses.fx);
        
        this.nodes.effects.delaySend.connect(this.nodes.effects.delay);
        this.nodes.effects.delay.connect(this.nodes.effects.delayFilter);
        this.nodes.effects.delayFilter.connect(this.nodes.effects.delayFeedback);
        this.nodes.effects.delayFeedback.connect(this.nodes.effects.delay);
        this.nodes.effects.delayFilter.connect(this.nodes.effects.delayReturn);
        this.nodes.effects.delayReturn.connect(this.nodes.buses.fx);
        
        // Create send connections from buses
        this.nodes.buses.mid.connect(this.nodes.effects.reverbSend);
        this.nodes.buses.high.connect(this.nodes.effects.reverbSend);
        this.nodes.buses.high.connect(this.nodes.effects.delaySend);
      }

      async createReverbImpulse(duration, decay) {
        const length = this.ctx.sampleRate * duration;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          
          for (let i = 0; i < length; i++) {
            // Exponential decay
            const envelope = Math.pow(1 - i / length, decay);
            
            // Early reflections
            if (i < this.ctx.sampleRate * 0.1) {
              const earlyReflection = Math.sin(i * 0.01) * 0.5;
              channelData[i] = (Math.random() * 2 - 1 + earlyReflection) * envelope * 0.5;
            } else {
              // Diffuse reverb tail
              channelData[i] = (Math.random() * 2 - 1) * envelope * 0.2;
            }
            
            // Add some resonances
            if (i % Math.floor(this.ctx.sampleRate / 440) === 0) {
              channelData[i] += Math.sin(i * 0.1) * envelope * 0.1;
            }
          }
        }
        
        return impulse;
      }

      makeDistortionCurve(amount) {
        const samples = 44100;
        const curve = new Float32Array(samples);
        const deg = Math.PI / 180;
        
        for (let i = 0; i < samples; i++) {
          const x = (i * 2) / samples - 1;
          curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
        }
        
        return curve;
      }

      // ============================================
      // MICROPHONE AND SAMPLING
      // ============================================
      
      async setupMicrophone() {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false,
              sampleRate: 48000
            }
          });
          
          this.micSource = this.ctx.createMediaStreamSource(stream);
          this.micAnalyser = this.ctx.createAnalyser();
          this.micAnalyser.fftSize = 4096;
          this.micAnalyser.smoothingTimeConstant = 0.8;
          
          // Create recording processor
          this.recordProcessor = this.ctx.createScriptProcessor(4096, 1, 1);
          this.recordProcessor.onaudioprocess = (e) => {
            if (this.isRecording) {
              const inputData = e.inputBuffer.getChannelData(0);
              this.recordingBuffer.push(...inputData);
              
              // Auto-stop after 4 seconds
              if (this.recordingBuffer.length > this.ctx.sampleRate * 4) {
                this.stopRecording();
              }
            }
          };
          
          // Setup analysis chain
          this.micSource.connect(this.micAnalyser);
          
          // Start environmental analysis
          this.analyzeEnvironment();
          
        } catch (error) {
          console.log('Microphone access denied, continuing without sampling');
        }
      }

      analyzeEnvironment() {
        if (!this.isActive || !this.micAnalyser) return;
        
        const freqData = new Float32Array(this.micAnalyser.frequencyBinCount);
        this.micAnalyser.getFloatFrequencyData(freqData);
        
        // Calculate spectral characteristics
        let spectralCentroid = 0;
        let totalEnergy = 0;
        
        for (let i = 0; i < freqData.length; i++) {
          const magnitude = Math.pow(10, freqData[i] / 20);
          const frequency = i * this.ctx.sampleRate / (this.micAnalyser.fftSize);
          
          spectralCentroid += frequency * magnitude;
          totalEnergy += magnitude;
        }
        
        if (totalEnergy > 0) {
          spectralCentroid /= totalEnergy;
        }
        
        // Detect interesting sounds
        const brightness = spectralCentroid / 5000; // Normalized brightness
        const loudness = totalEnergy / freqData.length;
        
        // Auto-record decision
        if (brightness > 0.5 && loudness > 0.01 && !this.isRecording && this.sampleBank.length < this.maxSamples) {
          this.startRecording();
        }
        
        // Update evolution based on environment
        this.evolution.harmony = this.evolution.harmony * 0.95 + brightness * 0.05;
        this.evolution.chaos = this.evolution.chaos * 0.95 + (loudness > 0.1 ? 0.1 : 0) * 0.05;
        
        requestAnimationFrame(() => this.analyzeEnvironment());
      }

      startRecording() {
        if (!this.micSource || this.isRecording) return;
        
        console.log('Recording started...');
        this.isRecording = true;
        this.recordingBuffer = [];
        this.recordingStartTime = this.ctx.currentTime;
        
        this.micSource.connect(this.recordProcessor);
        this.recordProcessor.connect(this.ctx.destination);
        
        // Visual feedback
        document.querySelectorAll('.core-ring').forEach(ring => {
          ring.classList.add('recording');
        });
      }

      stopRecording() {
        if (!this.isRecording) return;
        
        console.log('Recording stopped. Processing sample...');
        this.isRecording = false;
        
        if (this.micSource && this.recordProcessor) {
          this.micSource.disconnect(this.recordProcessor);
          this.recordProcessor.disconnect();
        }
        
        // Visual feedback
        document.querySelectorAll('.core-ring').forEach(ring => {
          ring.classList.remove('recording');
        });
        
        // Process the recorded sample
        if (this.recordingBuffer.length > this.ctx.sampleRate * 0.1) {
          this.processSample(this.recordingBuffer);
        }
      }

      processSample(audioData) {
        // Create audio buffer
        const buffer = this.ctx.createBuffer(1, audioData.length, this.ctx.sampleRate);
        const channelData = buffer.getChannelData(0);
        
        // Normalize audio
        let maxAmplitude = 0;
        for (let i = 0; i < audioData.length; i++) {
          maxAmplitude = Math.max(maxAmplitude, Math.abs(audioData[i]));
        }
        
        if (maxAmplitude > 0) {
          for (let i = 0; i < audioData.length; i++) {
            channelData[i] = audioData[i] / maxAmplitude * 0.8;
          }
        }
        
        // Analyze sample characteristics
        const analysis = this.analyzeSample(channelData);
        
        // Create sample object
        const sample = {
          buffer: buffer,
          analysis: analysis,
          timestamp: Date.now(),
          duration: buffer.duration,
          grains: this.createGrains(buffer)
        };
        
        // Add to sample bank
        this.sampleBank.push(sample);
        if (this.sampleBank.length > this.maxSamples) {
          this.sampleBank.shift();
        }
        
        // Assign to a slot
        const emptySlot = this.sampleSlots.findIndex(s => s === null);
        if (emptySlot !== -1) {
          this.sampleSlots[emptySlot] = sample;
        } else {
          // Replace oldest sample
          this.sampleSlots[Math.floor(Math.random() * this.sampleSlots.length)] = sample;
        }
        
        // Create visual representation
        this.createSampleGhost(sample);
        
        console.log('Sample processed:', analysis);
      }

      analyzeSample(audioData) {
        const sampleRate = this.ctx.sampleRate;
        
        // Find tempo through autocorrelation
        const tempo = this.detectTempo(audioData, sampleRate);
        
        // Find pitch through FFT peak detection
        const pitch = this.detectPitch(audioData, sampleRate);
        
        // Find transients
        const transients = this.detectTransients(audioData, sampleRate);
        
        // Calculate spectral characteristics
        const spectral = this.calculateSpectralFeatures(audioData, sampleRate);
        
        return {
          tempo: tempo,
          pitch: pitch,
          transients: transients,
          spectral: spectral,
          energy: this.calculateRMS(audioData)
        };
      }

      detectTempo(audioData, sampleRate) {
        // Simple onset detection and tempo estimation
        const windowSize = 2048;
        const hopSize = 512;
        const onsets = [];
        
        for (let i = 0; i < audioData.length - windowSize; i += hopSize) {
          let energy = 0;
          for (let j = 0; j < windowSize; j++) {
            energy += audioData[i + j] * audioData[i + j];
          }
          
          if (i > 0 && energy > onsets[onsets.length - 1] * 1.5) {
            onsets.push({ time: i / sampleRate, energy: energy });
          }
        }
        
        // Calculate intervals between onsets
        if (onsets.length > 2) {
          const intervals = [];
          for (let i = 1; i < onsets.length; i++) {
            intervals.push(onsets[i].time - onsets[i - 1].time);
          }
          
          // Find most common interval (mode)
          intervals.sort((a, b) => a - b);
          const medianInterval = intervals[Math.floor(intervals.length / 2)];
          const estimatedBPM = 60 / medianInterval;
          
          // Snap to nearest reasonable BPM
          return Math.round(estimatedBPM / 5) * 5;
        }
        
        return this.bpm; // Default to current BPM
      }

      detectPitch(audioData, sampleRate) {
        // Autocorrelation for pitch detection
        const minPeriod = Math.floor(sampleRate / 800); // 800 Hz max
        const maxPeriod = Math.floor(sampleRate / 50);  // 50 Hz min
        
        let maxCorrelation = 0;
        let bestPeriod = 0;
        
        for (let period = minPeriod; period < maxPeriod && period < audioData.length / 2; period++) {
          let correlation = 0;
          
          for (let i = 0; i < audioData.length - period; i++) {
            correlation += audioData[i] * audioData[i + period];
          }
          
          correlation /= audioData.length - period;
          
          if (correlation > maxCorrelation) {
            maxCorrelation = correlation;
            bestPeriod = period;
          }
        }
        
        if (bestPeriod > 0 && maxCorrelation > 0.3) {
          const frequency = sampleRate / bestPeriod;
          return this.frequencyToMIDI(frequency);
        }
        
        return null;
      }

      detectTransients(audioData, sampleRate) {
        const transients = [];
        const windowSize = 256;
        const threshold = 0.3;
        
        for (let i = windowSize; i < audioData.length - windowSize; i++) {
          const prevEnergy = this.calculateRMS(audioData.slice(i - windowSize, i));
          const currEnergy = this.calculateRMS(audioData.slice(i, i + windowSize));
          
          if (currEnergy > prevEnergy * 2 && currEnergy > threshold) {
            transients.push({
              position: i,
              time: i / sampleRate,
              strength: currEnergy
            });
            i += windowSize; // Skip ahead to avoid duplicates
          }
        }
        
        return transients;
      }

      calculateSpectralFeatures(audioData, sampleRate) {
        // Simplified spectral analysis
        const fftSize = 2048;
        const fft = new Float32Array(fftSize);
        
        // Window the audio data
        for (let i = 0; i < Math.min(fftSize, audioData.length); i++) {
          const window = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / fftSize); // Hanning window
          fft[i] = audioData[i] * window;
        }
        
        // Would normally do FFT here, but for simplicity, we'll estimate
        return {
          brightness: Math.random() * 0.5 + 0.5, // Placeholder
          noisiness: Math.random() * 0.3,
          inharmonicity: Math.random() * 0.2
        };
      }

      calculateRMS(audioData) {
        let sum = 0;
        for (let i = 0; i < audioData.length; i++) {
          sum += audioData[i] * audioData[i];
        }
        return Math.sqrt(sum / audioData.length);
      }

      frequencyToMIDI(frequency) {
        return Math.round(69 + 12 * Math.log2(frequency / 440));
      }

      createGrains(buffer) {
        const grains = [];
        const grainSize = 0.05; // 50ms grains
        const grainCount = Math.floor(buffer.duration / grainSize);
        
        for (let i = 0; i < Math.min(grainCount, 32); i++) {
          grains.push({
            start: i * grainSize,
            duration: grainSize,
            pitch: 1.0,
            amplitude: 1.0
          });
        }
        
        return grains;
      }

      createSampleGhost(sample) {
        const ghost = document.createElement('div');
        ghost.className = 'sample-ghost';
        
        // Position based on sample characteristics
        const angle = (sample.analysis.pitch || 60) / 127 * Math.PI * 2;
        const radius = 100 + sample.analysis.energy * 200;
        
        ghost.style.left = `${50 + Math.cos(angle) * radius / window.innerWidth * 100}%`;
        ghost.style.top = `${50 + Math.sin(angle) * radius / window.innerHeight * 100}%`;
        ghost.style.setProperty('--dx', `${Math.cos(angle) * 50}px`);
        ghost.style.setProperty('--dy', `${Math.sin(angle) * 50}px`);
        
        document.body.appendChild(ghost);
        
        // Remove after animation
        setTimeout(() => ghost.remove(), 13000);
      }

      // ============================================
      // MOTION DETECTION
      // ============================================
      
      setupMotionDetection() {
        // Device motion for mobile
        if (window.DeviceMotionEvent) {
          window.addEventListener('devicemotion', (e) => {
            if (!e.accelerationIncludingGravity) return;
            
            const acc = e.accelerationIncludingGravity;
            this.updateMotion(
              acc.x || 0,
              acc.y || 0,
              acc.z || 0
            );
          });
        }
        
        // Mouse/touch for desktop
        let lastPos = { x: 0, y: 0, time: Date.now() };
        
        const handleMotion = (clientX, clientY) => {
          const now = Date.now();
          const dt = (now - lastPos.time) / 1000;
          
          if (dt > 0) {
            const dx = (clientX - lastPos.x) / window.innerWidth;
            const dy = (clientY - lastPos.y) / window.innerHeight;
            
            this.updateMotion(dx / dt, dy / dt, 0);
            
            // Create motion trail
            if (Math.abs(dx) + Math.abs(dy) > 0.01) {
              this.createMotionTrail(clientX, clientY);
            }
          }
          
          lastPos = { x: clientX, y: clientY, time: now };
        };
        
        window.addEventListener('mousemove', (e) => {
          handleMotion(e.clientX, e.clientY);
        });
        
        window.addEventListener('touchmove', (e) => {
          if (e.touches.length > 0) {
            handleMotion(e.touches[0].clientX, e.touches[0].clientY);
          }
        });
      }

      updateMotion(x, y, z) {
        // Update acceleration
        this.motion.acceleration.x = x - this.motion.velocity.x;
        this.motion.acceleration.y = y - this.motion.velocity.y;
        this.motion.acceleration.z = z - this.motion.velocity.z;
        
        // Update velocity
        this.motion.velocity.x = this.motion.velocity.x * 0.9 + x * 0.1;
        this.motion.velocity.y = this.motion.velocity.y * 0.9 + y * 0.1;
        this.motion.velocity.z = this.motion.velocity.z * 0.9 + z * 0.1;
        
        // Calculate intensity
        this.motion.intensity = Math.sqrt(
          this.motion.velocity.x ** 2 +
          this.motion.velocity.y ** 2 +
          this.motion.velocity.z ** 2
        );
        
        // Add to history
        this.motion.history.push(this.motion.intensity);
        if (this.motion.history.length > 60) {
          this.motion.history.shift();
        }
        
        // Detect patterns
        this.detectMotionPattern();
        
        // Update evolution
        this.updateEvolution();
        
        // Update layer states
        this.updateLayers();
      }

      detectMotionPattern() {
        const recent = this.motion.history.slice(-30);
        const average = recent.reduce((a, b) => a + b, 0) / recent.length;
        const variance = recent.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) / recent.length;
        
        if (average < 0.1) {
          this.motion.pattern = 'still';
        } else if (variance < 0.01) {
          this.motion.pattern = 'steady';
        } else if (variance < 0.1) {
          this.motion.pattern = 'flowing';
        } else if (variance < 0.5) {
          this.motion.pattern = 'dynamic';
        } else {
          this.motion.pattern = 'chaotic';
        }
      }

      updateEvolution() {
        const rate = 0.01;
        
        // Update complexity based on motion
        this.evolution.complexity = Math.min(1, this.evolution.complexity + this.motion.intensity * rate);
        
        // Natural decay
        this.evolution.complexity *= 0.995;
        
        // Update density
        this.evolution.density = 0.2 + this.evolution.complexity * 0.6;
        
        // Update space
        this.evolution.space = Math.min(1, this.evolution.space + (this.motion.pattern === 'flowing' ? 0.01 : -0.005));
        
        // Time progression
        this.evolution.time += 0.001;
      }

      updateLayers() {
        // Rhythm layer - always active but varies in complexity
        this.layers.rhythm.intensity = 0.5 + this.evolution.complexity * 0.5;
        this.layers.rhythm.pattern = Math.floor(this.evolution.complexity * 4);
        
        // Harmony layer
        this.layers.harmony.active = this.evolution.complexity > 0.2;
        this.layers.harmony.intensity = this.evolution.complexity * 0.8;
        
        // Melody layer
        this.layers.melody.active = this.evolution.complexity > 0.4;
        this.layers.melody.intensity = (this.evolution.complexity - 0.4) * 1.5;
        
        // Texture layer
        this.layers.texture.active = this.evolution.complexity > 0.3 || this.motion.pattern === 'chaotic';
        this.layers.texture.intensity = this.evolution.chaos;
        
        // Space layer
        this.layers.space.active = this.evolution.space > 0.3;
        this.layers.space.intensity = this.evolution.space;
        
        // Update UI indicators
        this.updateIndicators();
      }

      updateIndicators() {
        document.querySelectorAll('.indicator').forEach(indicator => {
          const layer = indicator.dataset.layer;
          if (this.layers[layer] && this.layers[layer].active) {
            indicator.classList.add('active');
            indicator.style.opacity = 0.3 + this.layers[layer].intensity * 0.7;
          } else {
            indicator.classList.remove('active');
          }
        });
      }

      createMotionTrail(x, y) {
        const trail = document.createElement('div');
        trail.className = 'motion-trail';
        trail.style.left = x + 'px';
        trail.style.top = y + 'px';
        document.body.appendChild(trail);
        
        setTimeout(() => trail.remove(), 2000);
      }

      // ============================================
      // SCHEDULING AND SEQUENCING
      // ============================================
      
      setupTimerWorker() {
        // Use setTimeout for scheduling (Web Worker would be better for production)
        this.timerWorker = () => {
          if (!this.isActive) return;
          
          this.scheduler();
          setTimeout(this.timerWorker, this.lookahead);
        };
        
        this.timerWorker();
      }

      scheduler() {
        while (this.nextStepTime < this.ctx.currentTime + this.scheduleAheadTime) {
          this.scheduleStep(this.currentStep, this.nextStepTime);
          this.nextStep();
        }
      }

      nextStep() {
        const secondsPerBeat = 60.0 / this.bpm;
        this.nextStepTime += 0.25 * secondsPerBeat; // 16th notes
        
        this.currentStep++;
        if (this.currentStep === 16) {
          this.currentStep = 0;
          this.currentBar++;
          
          if (this.currentBar % 4 === 0) {
            this.nextPhrase();
          }
        }
      }

      nextPhrase() {
        // Progress chord
        this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
        this.currentChord = this.chordProgression[this.currentChordIndex];
        
        // Evolve patterns
        this.evolvePatterns();
        
        // Potentially trigger samples
        if (Math.random() < this.evolution.complexity) {
          this.triggerRandomSample();
        }
      }

      evolvePatterns() {
        // Evolve drum patterns based on complexity
        if (this.evolution.complexity > 0.5) {
          // Add variations
          const variation = Math.random();
          if (variation < 0.2) {
            // Add ghost notes
            this.patterns.kick[2] = Math.random() < 0.5 ? 0.5 : 0;
            this.patterns.kick[10] = Math.random() < 0.5 ? 0.5 : 0;
          }
          if (variation < 0.4) {
            // Vary hi-hats
            for (let i = 0; i < 16; i++) {
              this.patterns.hihat[i] = Math.random() < 0.7 ? 1 : 0;
            }
          }
        }
      }

      scheduleStep(step, time) {
        // Drums
        if (this.layers.rhythm.active) {
          this.scheduleDrums(step, time);
        }
        
        // Bass
        if (this.layers.harmony.active && this.patterns.bass[step]) {
          this.scheduleBass(step, time);
        }
        
        // Chords
        if (this.layers.harmony.active && step % 4 === 0) {
          this.scheduleChord(time);
        }
        
        // Melody
        if (this.layers.melody.active && Math.random() < this.layers.melody.intensity) {
          this.scheduleMelody(step, time);
        }
        
        // Texture
        if (this.layers.texture.active && Math.random() < 0.1) {
          this.scheduleTexture(time);
        }
        
        // Sample triggers
        if (this.sampleSlots[step] && Math.random() < this.evolution.density) {
          this.scheduleSample(this.sampleSlots[step], time);
        }
      }

      scheduleDrums(step, time) {
        // Kick
        if (this.patterns.kick[step]) {
          const velocity = typeof this.patterns.kick[step] === 'number' ? this.patterns.kick[step] : 1;
          this.playKick(time, velocity);
        }
        
        // Snare
        if (this.patterns.snare[step]) {
          this.playSnare(time);
        }
        
        // Hi-hat
        if (this.patterns.hihat[step]) {
          this.playHiHat(time, Math.random() < 0.2);
        }
        
        // Percussion
        if (Math.random() < this.evolution.complexity * 0.2) {
          this.playPercussion(time);
        }
      }

      // ============================================
      // SOUND SYNTHESIS
      // ============================================
      
      playKick(time, velocity = 1) {
        // Main tone oscillator
        const toneOsc = this.ctx.createOscillator();
        const toneGain = this.ctx.createGain();
        
        toneOsc.type = 'sine';
        toneOsc.frequency.setValueAtTime(60, time);
        toneOsc.frequency.exponentialRampToValueAtTime(35, time + 0.08);
        
        // Click/attack
        const clickOsc = this.ctx.createOscillator();
        const clickGain = this.ctx.createGain();
        
        clickOsc.type = 'square';
        clickOsc.frequency.value = 200;
        
        clickGain.gain.setValueAtTime(0.5 * velocity, time);
        clickGain.gain.exponentialRampToValueAtTime(0.01, time + 0.005);
        
        // Sub bass
        const subOsc = this.ctx.createOscillator();
        const subGain = this.ctx.createGain();
        
        subOsc.type = 'sine';
        subOsc.frequency.value = 30;
        
        subGain.gain.setValueAtTime(0.7 * velocity, time);
        subGain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
        
        // Main envelope
        toneGain.gain.setValueAtTime(velocity, time);
        toneGain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
        
        // Distortion for punch
        const distortion = this.ctx.createWaveShaper();
        distortion.curve = this.makeDistortionCurve(10);
        
        // Connect and play
        toneOsc.connect(toneGain);
        clickOsc.connect(clickGain);
        subOsc.connect(subGain);
        
        toneGain.connect(distortion);
        clickGain.connect(distortion);
        subGain.connect(this.nodes.buses.drum);
        distortion.connect(this.nodes.buses.drum);
        
        toneOsc.start(time);
        toneOsc.stop(time + 0.5);
        clickOsc.start(time);
        clickOsc.stop(time + 0.005);
        subOsc.start(time);
        subOsc.stop(time + 0.3);
      }

      playSnare(time) {
        // Tone component
        const toneOsc1 = this.ctx.createOscillator();
        const toneOsc2 = this.ctx.createOscillator();
        const toneGain = this.ctx.createGain();
        
        toneOsc1.type = 'triangle';
        toneOsc1.frequency.value = 200;
        toneOsc2.type = 'triangle';
        toneOsc2.frequency.value = 300;
        
        // Noise component
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 0.5);
        }
        
        const noiseSource = this.ctx.createBufferSource();
        noiseSource.buffer = noiseBuffer;
        
        const noiseGain = this.ctx.createGain();
        const noiseFilter = this.ctx.createBiquadFilter();
        
        noiseFilter.type = 'highpass';
        noiseFilter.frequency.value = 2000;
        noiseFilter.Q.value = 0.5;
        
        // Envelopes
        toneGain.gain.setValueAtTime(0.3, time);
        toneGain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
        
        noiseGain.gain.setValueAtTime(0.3, time);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
        
        // Connect
        toneOsc1.connect(toneGain);
        toneOsc2.connect(toneGain);
        toneGain.connect(this.nodes.buses.drum);
        
        noiseSource.connect(noiseFilter);
        noiseFilter.connect(noiseGain);
        noiseGain.connect(this.nodes.buses.drum);
        
        // Play
        toneOsc1.start(time);
        toneOsc1.stop(time + 0.1);
        toneOsc2.start(time);
        toneOsc2.stop(time + 0.1);
        noiseSource.start(time);
      }

      playHiHat(time, open = false) {
        const duration = open ? 0.3 : 0.05;
        
        // Create noise
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, open ? 2 : 0.5);
        }
        
        const source = this.ctx.createBufferSource();
        source.buffer = noiseBuffer;
        
        // Filters
        const highpass = this.ctx.createBiquadFilter();
        highpass.type = 'highpass';
        highpass.frequency.value = 7000;
        highpass.Q.value = 0.5;
        
        const bandpass = this.ctx.createBiquadFilter();
        bandpass.type = 'bandpass';
        bandpass.frequency.value = 10000;
        bandpass.Q.value = 1;
        
        // Gain
        const gain = this.ctx.createGain();
        gain.gain.value = open ? 0.15 : 0.1;
        
        // Connect
        source.connect(highpass);
        highpass.connect(bandpass);
        bandpass.connect(gain);
        gain.connect(this.nodes.buses.drum);
        
        // Play
        source.start(time);
      }

      playPercussion(time) {
        // Random percussion sounds
        const type = Math.floor(Math.random() * 3);
        
        switch (type) {
          case 0: // Conga
            this.playConga(time);
            break;
          case 1: // Rimshot
            this.playRimshot(time);
            break;
          case 2: // Shaker
            this.playShaker(time);
            break;
        }
      }

      playConga(time) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(180, time);
        osc.frequency.exponentialRampToValueAtTime(120, time + 0.02);
        
        filter.type = 'bandpass';
        filter.frequency.value = 200;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0.2, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.buses.drum);
        
        osc.start(time);
        osc.stop(time + 0.1);
      }

      playRimshot(time) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'square';
        osc.frequency.value = 800;
        
        gain.gain.setValueAtTime(0.1, time);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.02);
        
        osc.connect(gain);
        gain.connect(this.nodes.buses.drum);
        
        osc.start(time);
        osc.stop(time + 0.02);
      }

      playShaker(time) {
        const duration = 0.03;
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.1;
        }
        
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'highpass';
        filter.frequency.value = 5000;
        
        source.connect(filter);
        filter.connect(this.nodes.buses.drum);
        
        source.start(time);
      }

      scheduleBass(step, time) {
        const osc = this.ctx.createOscillator();
        const subOsc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        // Note selection
        const noteIndex = step % 4;
        const note = this.currentChord[noteIndex % this.currentChord.length];
        const frequency = this.midiToFrequency(this.rootNote + note - 24); // Two octaves down
        
        // Main oscillator
        osc.type = 'sawtooth';
        osc.frequency.value = frequency;
        
        // Sub oscillator
        subOsc.type = 'sine';
        subOsc.frequency.value = frequency / 2;
        
        // Filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(frequency * 2, time);
        filter.frequency.exponentialRampToValueAtTime(frequency * 8, time + 0.01);
        filter.frequency.exponentialRampToValueAtTime(frequency * 2, time + 0.2);
        filter.Q.value = 5 + this.evolution.complexity * 10;
        
        // Envelope
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.3, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
        
        // Connect
        osc.connect(filter);
        subOsc.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.buses.bass);
        
        // Play
        osc.start(time);
        osc.stop(time + 0.5);
        subOsc.start(time);
        subOsc.stop(time + 0.5);
      }

      scheduleChord(time) {
        const voices = 3 + Math.floor(this.evolution.complexity * 2);
        
        for (let i = 0; i < voices; i++) {
          const note = this.currentChord[i % this.currentChord.length];
          const octave = Math.floor(i / this.currentChord.length);
          const frequency = this.midiToFrequency(this.rootNote + note + octave * 12);
          
          this.playChordVoice(frequency, time, i);
        }
      }

      playChordVoice(frequency, time, voiceIndex) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const pan = this.ctx.createStereoPanner();
        
        // Oscillator
        osc.type = ['sine', 'triangle', 'sawtooth'][voiceIndex % 3];
        osc.frequency.value = frequency * (1 + (Math.random() - 0.5) * 0.01); // Slight detune
        
        // Filter
        filter.type = 'lowpass';
        filter.frequency.value = 2000 + voiceIndex * 500;
        filter.Q.value = 1;
        
        // Pan
        pan.pan.value = (voiceIndex - 1.5) * 0.3;
        
        // Envelope
        const attack = 0.1 + Math.random() * 0.2;
        const release = 2 + Math.random() * 2;
        
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.1, time + attack);
        gain.gain.setValueAtTime(0.08, time + attack + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.01, time + release);
        
        // Connect
        osc.connect(filter);
        filter.connect(pan);
        pan.connect(gain);
        gain.connect(this.nodes.buses.mid);
        gain.connect(this.nodes.effects.reverbSend);
        
        // Play
        osc.start(time);
        osc.stop(time + release);
      }

      scheduleMelody(step, time) {
        // Generate melodic phrase based on scale and current chord
        const note = this.scale[Math.floor(Math.random() * this.scale.length)];
        const octave = Math.random() < 0.7 ? 12 : 24;
        const frequency = this.midiToFrequency(this.rootNote + note + octave);
        
        this.playMelodyNote(frequency, time);
      }

      playMelodyNote(frequency, time) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const vibrato = this.ctx.createOscillator();
        const vibratoGain = this.ctx.createGain();
        
        // Main oscillator
        osc.type = 'square';
        osc.frequency.value = frequency;
        
        // Vibrato
        vibrato.type = 'sine';
        vibrato.frequency.value = 4 + Math.random() * 2;
        vibratoGain.gain.value = 5;
        vibrato.connect(vibratoGain);
        vibratoGain.connect(osc.frequency);
        
        // Filter
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(frequency * 2, time);
        filter.frequency.exponentialRampToValueAtTime(frequency * 6, time + 0.05);
        filter.frequency.exponentialRampToValueAtTime(frequency * 2, time + 0.2);
        filter.Q.value = 3;
        
        // Envelope
        const duration = 0.1 + Math.random() * 0.3;
        gain.gain.setValueAtTime(0, time);
        gain.gain.linearRampToValueAtTime(0.15, time + 0.01);
        gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
        
        // Connect
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.buses.high);
        gain.connect(this.nodes.effects.delaySend);
        
        // Play
        osc.start(time);
        osc.stop(time + duration);
        vibrato.start(time);
        vibrato.stop(time + duration);
      }

      scheduleTexture(time) {
        // Granular texture from noise
        const grainCount = 5 + Math.floor(Math.random() * 10);
        
        for (let i = 0; i < grainCount; i++) {
          const grainTime = time + i * 0.01 + Math.random() * 0.02;
          this.playGrain(grainTime);
        }
      }

      playGrain(time) {
        const duration = 0.01 + Math.random() * 0.05;
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Create grain envelope
        for (let i = 0; i < data.length; i++) {
          const envelope = Math.sin(Math.PI * i / data.length);
          data[i] = (Math.random() * 2 - 1) * envelope * 0.05;
        }
        
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 200 + Math.random() * 5000;
        filter.Q.value = 10;
        
        const pan = this.ctx.createStereoPanner();
        pan.pan.value = (Math.random() - 0.5) * 2;
        
        source.connect(filter);
        filter.connect(pan);
        pan.connect(this.nodes.buses.fx);
        
        source.start(time);
      }

      scheduleSample(sample, time) {
        if (!sample || !sample.buffer) return;
        
        const source = this.ctx.createBufferSource();
        source.buffer = sample.buffer;
        
        // Pitch adjustment based on analysis
        if (sample.analysis.pitch) {
          const targetPitch = this.rootNote + this.currentChord[0];
          const pitchRatio = this.midiToFrequency(targetPitch) / this.midiToFrequency(sample.analysis.pitch);
          source.playbackRate.value = pitchRatio;
        }
        
        // Apply effects based on evolution
        const gain = this.ctx.createGain();
        gain.gain.value = 0.3 * sample.analysis.energy;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + this.evolution.complexity * 3000;
        filter.Q.value = 2;
        
        // Granular playback if chaotic
        if (this.motion.pattern === 'chaotic' && sample.grains.length > 0) {
          const grain = sample.grains[Math.floor(Math.random() * sample.grains.length)];
          source.loopStart = grain.start;
          source.loopEnd = grain.start + grain.duration;
          source.loop = true;
        }
        
        // Connect
        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.buses.fx);
        gain.connect(this.nodes.effects.reverbSend);
        
        // Play
        source.start(time);
        
        if (!source.loop) {
          source.stop(time + sample.duration);
        } else {
          source.stop(time + 0.5);
        }
      }

      triggerRandomSample() {
        if (this.sampleBank.length === 0) return;
        
        const sample = this.sampleBank[Math.floor(Math.random() * this.sampleBank.length)];
        this.scheduleSample(sample, this.ctx.currentTime);
      }

      midiToFrequency(midiNote) {
        return 440 * Math.pow(2, (midiNote - 69) / 12);
      }

      // ============================================
      // ANIMATION AND VISUALIZATION
      // ============================================
      
      animate() {
        if (!this.isActive) return;
        
        // Update spectrum visualization
        if (this.nodes.analyser) {
          const bufferLength = this.nodes.analyser.frequencyBinCount;
          const dataArray = new Uint8Array(bufferLength);
          this.nodes.analyser.getByteFrequencyData(dataArray);
          
          // Update spectrum bars
          const bars = document.querySelectorAll('.spectrum-bar');
          const barCount = bars.length;
          
          for (let i = 0; i < barCount; i++) {
            const index = Math.floor(i * bufferLength / barCount);
            const value = dataArray[index] / 255;
            bars[i].style.height = (value * 144) + 'px';
            bars[i].style.opacity = 0.1 + value * 0.4;
          }
          
          // Update waveform
          this.nodes.analyser.getByteTimeDomainData(dataArray);
          const waveformBars = document.querySelectorAll('.wave-bar');
          const step = Math.floor(bufferLength / waveformBars.length);
          
          for (let i = 0; i < waveformBars.length; i++) {
            const value = (dataArray[i * step] - 128) / 128;
            waveformBars[i].style.height = Math.abs(value) * 50 + 'px';
          }
        }
        
        // Update neural field
        this.updateNeuralField();
        
        // Update core rings
        this.updateCoreRings();
        
        // Update BPM based on evolution
        this.bpm = 100 + this.evolution.complexity * 40 + Math.sin(this.evolution.time) * 10;
        
        requestAnimationFrame(() => this.animate());
      }

      updateNeuralField() {
        // Animate neural nodes based on audio activity
        this.visuals.neuralNodes.forEach((node, i) => {
          const phase = this.evolution.time + i * 0.1;
          const drift = Math.sin(phase) * 2;
          
          node.element.style.transform = `translate(${drift}px, ${Math.cos(phase) * 2}px)`;
          node.element.style.opacity = 0.3 + Math.sin(phase * 2) * 0.2 + this.evolution.complexity * 0.3;
        });
        
        // Update connections
        this.visuals.connections.forEach((conn, i) => {
          const opacity = 0.05 + this.evolution.complexity * 0.1 + Math.sin(this.evolution.time * 2 + i) * 0.05;
          conn.element.style.opacity = opacity;
        });
      }

      updateCoreRings() {
        const rings = document.querySelectorAll('.core-ring');
        
        rings.forEach((ring, i) => {
          if (this.layers[Object.keys(this.layers)[i]]) {
            const layer = this.layers[Object.keys(this.layers)[i]];
            if (layer.active) {
              ring.classList.add('active');
              ring.style.opacity = 0.3 + layer.intensity * 0.7;
            } else {
              ring.classList.remove('active');
              ring.style.opacity = 0.1;
            }
          }
        });
      }
    }

    // Initialize the synthesizer
    const synthesizer = new RealitySynthesizer();
  </script>
</body>
</html>
