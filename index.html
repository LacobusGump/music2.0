<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        .orb {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.5px);
        }

        .orb.pulse {
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
            50% { transform: translate(-50%, -50%) scale(3); box-shadow: 0 0 30px rgba(255,255,255,0.6); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: rec 1s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }

        .orb.motion {
            background: radial-gradient(circle, rgba(100,255,100,0.8) 0%, rgba(0,255,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(0,255,0,0.5);
        }

        .info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 11px;
            opacity: 0.5;
            letter-spacing: 0.5px;
        }

        .tempo {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 14px;
            opacity: 0.7;
            font-family: monospace;
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>
    <div class="info">SPACE TO SAMPLE • MOVE TO CONTROL TEMPO • CLICK TO START</div>
    <div class="tempo" id="tempo">BPM: --</div>

    <script>
        'use strict';

        // Motion Controller
        class MotionController {
            constructor(onTempoChange) {
                this.onTempoChange = onTempoChange;
                this.baseAccel = null;
                this.smoothedAccel = 0;
                this.lastUpdate = 0;
                this.motionActive = false;
                this.calibrating = false;
                this.calibrationSamples = [];
                this.alpha = 0.08;
            }

            async init() {
                if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                    const permission = await DeviceMotionEvent.requestPermission();
                    if (permission !== 'granted') return false;
                }

                window.addEventListener('devicemotion', (e) => this.handleMotion(e), { passive: true });
                this.calibrate();
                return true;
            }

            calibrate() {
                this.calibrating = true;
                this.calibrationSamples = [];
                
                setTimeout(() => {
                    if (this.calibrationSamples.length > 0) {
                        this.baseAccel = this.calibrationSamples.reduce((a, b) => a + b) / this.calibrationSamples.length;
                        console.log(`Motion calibrated: ${this.baseAccel.toFixed(2)}`);
                    }
                    this.calibrating = false;
                    this.motionActive = true;
                }, 2000);
            }

            handleMotion(event) {
                const now = Date.now();
                if (now - this.lastUpdate < 50) return;
                this.lastUpdate = now;

                const accel = event.accelerationIncludingGravity;
                if (!accel || accel.x === null) return;

                const totalAccel = Math.sqrt(accel.x * accel.x + accel.y * accel.y + accel.z * accel.z);

                if (this.calibrating) {
                    this.calibrationSamples.push(totalAccel);
                    return;
                }

                if (!this.motionActive || this.baseAccel === null) return;

                this.smoothedAccel = this.alpha * totalAccel + (1 - this.alpha) * this.smoothedAccel;
                const motionDelta = Math.abs(this.smoothedAccel - this.baseAccel);
                const normalizedMotion = Math.min(motionDelta / 3, 1);
                const bpm = 65 + (normalizedMotion * 55); // 65-120 BPM range

                this.onTempoChange(Math.round(bpm));
            }
        }

        // Beat Matcher
        class BeatMatcher {
            constructor() {
                this.bpm = 75;
                this.targetBpm = 75;
                this.bpmSmooth = 0.015;
            }

            setBpm(newBpm) {
                this.targetBpm = Math.max(50, Math.min(140, newBpm));
            }

            updateBpm() {
                this.bpm += (this.targetBpm - this.bpm) * this.bpmSmooth;
            }

            findPeaks(buffer, sr) {
                const data = buffer.getChannelData(0);
                const peaks = [];
                const windowSize = 1024;
                const hop = 512;
                
                for (let i = 0; i < data.length - windowSize; i += hop) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    energy = Math.sqrt(energy / windowSize);
                    
                    if (i > 0 && energy > peaks[peaks.length - 1]?.energy * 1.3 && energy > 0.05) {
                        peaks.push({ time: i / sr, energy, index: i });
                    }
                }
                
                return peaks;
            }

            matchToGrid(peaks, barLength = 4) {
                if (peaks.length < 2) return 1;
                
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i].time - peaks[i - 1].time);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                const beatDuration = 60 / this.bpm;
                
                const divisions = [4, 2, 1, 0.5, 0.25];
                let bestDiv = 1;
                let minDiff = Infinity;
                
                for (const div of divisions) {
                    const targetInterval = beatDuration * div;
                    const diff = Math.abs(avgInterval - targetInterval);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestDiv = div;
                    }
                }
                
                const targetDuration = beatDuration * barLength;
                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                
                return targetDuration / actualDuration;
            }

            chopSample(buffer, peaks, chopsPerBar = 4) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration * 4 / chopsPerBar;
                
                for (let i = 0; i < Math.min(peaks.length - 1, chopsPerBar); i++) {
                    const start = peaks[i].time;
                    const end = Math.min(start + chopLength, buffer.duration);
                    chops.push({ start, end, peak: peaks[i].energy });
                }
                
                return chops;
            }
        }

        // 2025 Kanye Bass Synth
        class YeezusBass {
            constructor(ctx) {
                this.ctx = ctx;
                this.activeVoices = new Map();
                // Updated bass patterns - more aggressive
                this.patterns = [
                    // Pattern 1 - Dark and heavy
                    { notes: [36, 36, 31, 43, 38, 38, 31, 36], triggers: [1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0] },
                    // Pattern 2 - Yeezus style
                    { notes: [31, 31, 36, 38, 31, 31, 43, 36], triggers: [1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0] },
                ];
                this.currentPattern = 0;
            }

            midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }

            play(step, output, bpm) {
                const pattern = this.patterns[this.currentPattern];
                if (!pattern.triggers[step % 16]) return;
                
                const noteIndex = Math.floor(step / 2) % pattern.notes.length;
                const midi = pattern.notes[noteIndex];
                const freq = this.midiToFreq(midi);
                
                // Kill previous voice
                if (this.activeVoices.has(midi)) {
                    this.activeVoices.get(midi).stop(this.ctx.currentTime);
                    this.activeVoices.delete(midi);
                }

                const voice = this.createYeezusVoice(freq, output, bpm);
                this.activeVoices.set(midi, voice);
            }

            createYeezusVoice(freq, output, bpm) {
                const now = this.ctx.currentTime;
                const duration = 60 / bpm / 4 * 1.5;
                
                // Triple 808 stack - the Kanye way
                const sub808 = this.ctx.createOscillator();
                const mid808 = this.ctx.createOscillator();
                const top808 = this.ctx.createOscillator();
                
                const subGain = this.ctx.createGain();
                const midGain = this.ctx.createGain();
                const topGain = this.ctx.createGain();
                
                // 808 characteristics - reduced levels
                sub808.type = 'sine';
                sub808.frequency.value = freq * 0.5;
                subGain.gain.value = 0.4; // Reduced from 0.8
                
                mid808.type = 'sine';
                mid808.frequency.value = freq;
                midGain.gain.value = 0.3; // Reduced from 0.6
                
                top808.type = 'triangle';
                top808.frequency.value = freq * 2;
                topGain.gain.value = 0.15; // Reduced from 0.3
                
                // Gentler distortion
                const distortion = this.ctx.createWaveShaper();
                const distortionCurve = new Float32Array(256);
                for (let i = 0; i < 128; i++) {
                    const x = i / 128;
                    // Much gentler distortion curve
                    distortionCurve[128 + i] = Math.tanh(x * 1.5) * 0.7; // Reduced drive
                    distortionCurve[128 - i - 1] = -Math.tanh(x * 1.5) * 0.7;
                }
                distortion.curve = distortionCurve;
                distortion.oversample = '2x'; // Reduced oversampling
                
                // Multiple filters for character
                const lowpass = this.ctx.createBiquadFilter();
                lowpass.type = 'lowpass';
                lowpass.frequency.value = 120;
                lowpass.Q.value = 4; // Reduced Q
                
                const highpass = this.ctx.createBiquadFilter();
                highpass.type = 'highpass';
                highpass.frequency.value = 30;
                highpass.Q.value = 1;
                
                // Envelope with punch
                const envelope = this.ctx.createGain();
                envelope.gain.setValueAtTime(0, now);
                envelope.gain.linearRampToValueAtTime(1, now + 0.002); // Ultra fast attack
                envelope.gain.exponentialRampToValueAtTime(0.7, now + 0.05);
                envelope.gain.exponentialRampToValueAtTime(0.3, now + duration * 0.3);
                envelope.gain.exponentialRampToValueAtTime(0.01, now + duration);
                
                // Filter automation for movement
                lowpass.frequency.setValueAtTime(80, now);
                lowpass.frequency.exponentialRampToValueAtTime(200, now + 0.01);
                lowpass.frequency.exponentialRampToValueAtTime(120, now + duration * 0.2);
                lowpass.frequency.exponentialRampToValueAtTime(60, now + duration);
                
                // 808 pitch bend
                const pitchBend = -12; // Octave down sweep
                sub808.frequency.exponentialRampToValueAtTime(freq * 0.5 * Math.pow(2, pitchBend/12), now + duration * 0.8);
                mid808.frequency.exponentialRampToValueAtTime(freq * Math.pow(2, pitchBend/12), now + duration * 0.8);
                
                // Connect the monster
                sub808.connect(subGain);
                mid808.connect(midGain);
                top808.connect(topGain);
                
                subGain.connect(distortion);
                midGain.connect(distortion);
                topGain.connect(distortion);
                
                distortion.connect(highpass);
                highpass.connect(lowpass);
                lowpass.connect(envelope);
                envelope.connect(output);
                
                // Start and schedule stop
                [sub808, mid808, top808].forEach(osc => {
                    osc.start(now);
                    osc.stop(now + duration);
                });
                
                return { stop: (when) => [sub808, mid808, top808].forEach(osc => osc.stop(when)) };
            }

            switchPattern() {
                this.currentPattern = (this.currentPattern + 1) % this.patterns.length;
            }
        }

        // Massive 808 Drum Synth - Completely Rebuilt
        class Massive808Drums {
            constructor(ctx) {
                this.ctx = ctx;
                this.createProfessional808s();
            }

            async createProfessional808s() {
                const sr = this.ctx.sampleRate;
                
                // MASSIVE 808 KICK - Multi-layered approach
                this.kick = this.ctx.createBuffer(1, sr * 1.2, sr); // Longer for full tail
                const kickData = this.kick.getChannelData(0);
                
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    
                    // Sub layer - pure sine wave foundation (30-60Hz)
                    const subEnv = Math.exp(-3 * t) * (1 - Math.exp(-40 * t));
                    const subFreq = 45 * (1 - 0.8 * Math.exp(-8 * t)); // Pitch drop
                    const sub = Math.sin(2 * Math.PI * subFreq * t) * subEnv;
                    
                    // Body layer - where the punch lives (60-200Hz)
                    const bodyEnv = Math.exp(-6 * t) * (1 - Math.exp(-30 * t));
                    const bodyFreq = 85 * (1 - 0.7 * Math.exp(-12 * t));
                    const body = Math.sin(2 * Math.PI * bodyFreq * t) * bodyEnv;
                    
                    // Click layer - transient attack (1-8kHz)
                    const clickEnv = Math.exp(-80 * t);
                    const click = Math.sin(2 * Math.PI * 4000 * t) * clickEnv;
                    
                    // Harmonic distortion layer
                    const harmEnv = Math.exp(-15 * t);
                    const harm = Math.sin(2 * Math.PI * bodyFreq * 2 * t) * harmEnv * 0.3;
                    
                    // Mix layers with proper levels
                    let signal = sub * 0.7 + body * 0.5 + click * 0.2 + harm * 0.1;
                    
                    // Gentle saturation - not aggressive clipping
                    signal = Math.tanh(signal * 0.8) * 0.9;
                    
                    kickData[i] = signal;
                }
                
                // CRISPY SNARE - Layered synthesis
                this.snare = this.ctx.createBuffer(1, sr * 0.3, sr);
                const snareData = this.snare.getChannelData(0);
                
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    
                    // Fundamental tone (200Hz)
                    const toneEnv = Math.exp(-20 * t);
                    const tone = Math.sin(2 * Math.PI * 200 * t) * toneEnv;
                    
                    // Body resonance (400Hz)
                    const bodyEnv = Math.exp(-15 * t);
                    const body = Math.sin(2 * Math.PI * 400 * t) * bodyEnv;
                    
                    // Crack (2-6kHz)
                    const crackEnv = Math.exp(-35 * t);
                    let crack = 0;
                    for (let h = 20; h < 60; h++) {
                        crack += Math.sin(2 * Math.PI * h * 100 * t) * crackEnv / h;
                    }
                    
                    // High-freq noise (8-15kHz)
                    const noiseEnv = Math.exp(-25 * t);
                    const noise = (Math.random() * 2 - 1) * noiseEnv;
                    
                    // Mix with proper balance
                    let signal = tone * 0.4 + body * 0.3 + crack * 0.2 + noise * 0.3;
                    
                    // Gentle compression simulation
                    signal = Math.tanh(signal * 0.7) * 0.8;
                    
                    snareData[i] = signal;
                }
                
                // PROFESSIONAL HI-HAT
                this.hat = this.ctx.createBuffer(1, sr * 0.08, sr);
                const hatData = this.hat.getChannelData(0);
                
                for (let i = 0; i < hatData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-60 * t);
                    
                    // Multiple filtered noise sources
                    let signal = 0;
                    
                    // High-frequency content (8-16kHz)
                    for (let band = 0; band < 6; band++) {
                        const freq = 8000 + band * 1500;
                        const bandNoise = (Math.random() * 2 - 1) * env;
                        signal += bandNoise * Math.sin(2 * Math.PI * freq * t) * 0.15;
                    }
                    
                    // Metallic resonance
                    const metallic = Math.sin(2 * Math.PI * 12000 * t) * env * 0.2;
                    signal += metallic;
                    
                    // Smooth the harsh edges
                    if (i > 3) {
                        signal = signal * 0.4 + hatData[i-1] * 0.3 + hatData[i-2] * 0.2 + hatData[i-3] * 0.1;
                    }
                    
                    hatData[i] = signal * 0.6;
                }

                console.log('Professional 808 drums created');
            }

            play808Kick(output, velocity = 1.0) {
                if (!this.kick) return;
                
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                // Professional EQ chain for kick
                const lowShelf = this.ctx.createBiquadFilter();
                lowShelf.type = 'lowshelf';
                lowShelf.frequency.value = 60;
                lowShelf.gain.value = 3; // Boost the sub
                
                const lowMid = this.ctx.createBiquadFilter();
                lowMid.type = 'peaking';
                lowMid.frequency.value = 100;
                lowMid.Q.value = 1.2;
                lowMid.gain.value = 2; // Punch
                
                const highCut = this.ctx.createBiquadFilter();
                highCut.type = 'lowpass';
                highCut.frequency.value = 8000;
                highCut.Q.value = 0.7;
                
                // Gentle compression
                const compressor = this.ctx.createDynamicsCompressor();
                compressor.threshold.value = -18;
                compressor.knee.value = 6;
                compressor.ratio.value = 4;
                compressor.attack.value = 0.001;
                compressor.release.value = 0.1;
                
                source.buffer = this.kick;
                gain.gain.value = velocity * 0.8; // Controlled level
                
                // Signal chain
                source.connect(lowShelf);
                lowShelf.connect(lowMid);
                lowMid.connect(highCut);
                highCut.connect(compressor);
                compressor.connect(gain);
                gain.connect(output);
                
                source.start();
            }

            playSnare(output, velocity = 1.0) {
                if (!this.snare) return;
                
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                // Snare EQ
                const presence = this.ctx.createBiquadFilter();
                presence.type = 'peaking';
                presence.frequency.value = 2500;
                presence.Q.value = 1.5;
                presence.gain.value = 4; // Cut through mix
                
                const airBand = this.ctx.createBiquadFilter();
                airBand.type = 'highshelf';
                airBand.frequency.value = 8000;
                airBand.gain.value = 2; // Air and sparkle
                
                source.buffer = this.snare;
                gain.gain.value = velocity * 0.7;
                
                source.connect(presence);
                presence.connect(airBand);
                airBand.connect(gain);
                gain.connect(output);
                
                source.start();
            }

            playHat(output, velocity = 1.0) {
                if (!this.hat) return;
                
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                // Hat EQ - just high shelf for sparkle
                const sparkle = this.ctx.createBiquadFilter();
                sparkle.type = 'highshelf';
                sparkle.frequency.value = 12000;
                sparkle.gain.value = 2;
                
                source.buffer = this.hat;
                gain.gain.value = velocity * 0.4 + (Math.random() - 0.5) * 0.1; // Humanization
                
                source.connect(sparkle);
                sparkle.connect(gain);
                gain.connect(output);
                
                source.start();
            }
        }

        // Lo-fi processor
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
            }

            process(source) {
                // Bitcrusher for digital grit
                const bitcrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                const bits = 10; // Less extreme than before
                const normFreq = 0.4;
                
                let phaser = 0;
                bitcrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    for (let i = 0; i < input.length; i++) {
                        phaser += normFreq;
                        if (phaser >= 1) {
                            phaser -= 1;
                            const step = Math.pow(0.5, bits);
                            output[i] = step * Math.floor(input[i] / step + 0.5);
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };
                
                // Warm analog filter
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 4000;
                filter.Q.value = 0.8;
                
                // Tube-style saturation
                const waveshaper = this.ctx.createWaveShaper();
                const curve = new Float32Array(256);
                for (let i = 0; i < 128; i++) {
                    const x = i / 128;
                    curve[128 + i] = Math.tanh(x * 1.5) * 0.9;
                    curve[128 - i - 1] = -Math.tanh(x * 1.5) * 0.9;
                }
                waveshaper.curve = curve;
                
                source.connect(bitcrusher);
                bitcrusher.connect(filter);
                filter.connect(waveshaper);
                
                return waveshaper;
            }
        }

        // Main Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.yeezusBass = null;
                this.drumSynth = null;
                this.motionController = null;
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.1 };
                this.orb = document.getElementById('orb');
                this.tempoDisplay = document.getElementById('tempo');
                this.bassActive = false;
                this.warmupBeats = 0;
                
                // Kanye-style pitch shifts
                this.pitchShifts = [0.5, 0.667, 0.75, 1, 1.5, 2];
                
                document.addEventListener('click', () => this.start());
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 44100 });
                    this.lofi = new LoFi(this.ctx);
                    this.yeezusBass = new YeezusBass(this.ctx);
                    this.drumSynth = new Massive808Drums(this.ctx); // New drum synth
                    
                    // Motion control
                    this.motionController = new MotionController((bpm) => {
                        this.beatMatcher.setBpm(bpm);
                        this.tempoDisplay.textContent = `BPM: ${bpm}`;
                        
                        if (bpm > 75) {
                            this.orb.classList.add('motion');
                        } else {
                            this.orb.classList.remove('motion');
                        }
                    });
                    
                    await this.motionController.init();
                    
                    // Professional master chain - COMPLETELY REWORKED
                    this.nodes.master = this.ctx.createGain();
                    this.nodes.master.gain.value = 0.7; // Reduced master level
                    
                    // Master bus compressor - gentler settings
                    this.nodes.busComp = this.ctx.createDynamicsCompressor();
                    this.nodes.busComp.threshold.value = -18; // Higher threshold
                    this.nodes.busComp.knee.value = 6; // Softer knee
                    this.nodes.busComp.ratio.value = 3; // Lower ratio
                    this.nodes.busComp.attack.value = 0.008; // Slower attack
                    this.nodes.busComp.release.value = 0.2; // Longer release
                    
                    // Gentler tape saturation
                    this.nodes.tape = this.ctx.createWaveShaper();
                    const tapeCurve = new Float32Array(256);
                    for (let i = 0; i < 128; i++) {
                        const x = i / 128;
                        tapeCurve[128 + i] = Math.tanh(x * 1.2) * 0.85; // Much gentler
                        tapeCurve[128 - i - 1] = -Math.tanh(x * 1.2) * 0.85;
                    }
                    this.nodes.tape.curve = tapeCurve;
                    
                    // Final limiter - safety net only
                    this.nodes.limiter = this.ctx.createDynamicsCompressor();
                    this.nodes.limiter.threshold.value = -2; // High threshold
                    this.nodes.limiter.knee.value = 0;
                    this.nodes.limiter.ratio.value = 12; // Hard limiting only for peaks
                    this.nodes.limiter.attack.value = 0.001;
                    this.nodes.limiter.release.value = 0.01;
                    
                    // Create mix busses with PROPER levels for 808s
                    const busses = {
                        drums: { gain: 0.85 }, // Slightly reduced
                        bass: { gain: 0.7 },   // Reduced bass level
                        sample: { gain: 0.6 }, // Reduced sample level
                        vinyl: { gain: 0.04 }  // Much quieter vinyl
                    };
                    
                    Object.entries(busses).forEach(([name, config]) => {
                        this.nodes[name] = this.ctx.createGain();
                        this.nodes[name].gain.value = config.gain;
                        this.nodes[name].connect(this.nodes.busComp);
                        this.samples.set(name, []);
                    });
                    
                    // Connect master chain properly
                    this.nodes.busComp.connect(this.nodes.tape);
                    this.nodes.tape.connect(this.nodes.master);
                    this.nodes.master.connect(this.nodes.limiter);
                    this.nodes.limiter.connect(this.ctx.destination);
                    
                    // Create vinyl atmosphere
                    this.createVinyl();
                    
                    // Mic setup
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.rec = this.ctx.createScriptProcessor(4096, 1, 1);
                    
                    this.nodes.rec.onaudioprocess = e => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            if (this.buffer.length > this.ctx.sampleRate * 8) this.stopRec();
                        }
                    };
                    
                    // Start the engine
                    this.loop();
                    this.seq.last = this.ctx.currentTime;
                    requestAnimationFrame(() => this.tick());
                    
                    document.onkeydown = e => {
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.toggle();
                        }
                    };
                    
                    document.querySelector('.info').style.display = 'none';
                    
                } catch (e) {
                    console.error(e);
                }
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.rec);
                    this.nodes.rec.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.rec);
                this.nodes.rec.disconnect();
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.5) {
                    const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    buf.getChannelData(0).set(this.buffer);
                    
                    // Find peaks and match to beat
                    const peaks = this.beatMatcher.findPeaks(buf, this.ctx.sampleRate);
                    const stretch = this.beatMatcher.matchToGrid(peaks);
                    
                    // Kanye-style pitch shift
                    const pitch = this.pitchShifts[Math.floor(Math.random() * this.pitchShifts.length)];
                    
                    // Create chops
                    const chops = this.beatMatcher.chopSample(buf, peaks);
                    
                    const sample = {
                        buffer: buf,
                        rate: stretch * pitch,
                        chops,
                        pitch
                    };
                    
                    // Add to samples
                    const samples = this.samples.get('sample');
                    if (samples.length >= 2) samples.shift();
                    samples.push(sample);
                    
                    console.log(`Sample: ${pitch}x pitch, ${stretch.toFixed(2)}x stretch`);
                }
            }

            createVinyl() {
                const duration = 10;
                const vinyl = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = vinyl.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Surface noise - much more subtle
                    data[i] = (Math.random() - 0.5) * 0.008;
                    
                    // Occasional pops - very rare
                    if (Math.random() < 0.00004) {
                        data[i] = (Math.random() - 0.5) * 0.1;
                    }
                    
                    // Very low rumble - barely audible
                    data[i] += Math.sin(2 * Math.PI * 0.3 * i / this.ctx.sampleRate) * 0.004;
                }
                
                const playVinyl = () => {
                    const source = this.ctx.createBufferSource();
                    source.buffer = vinyl;
                    source.loop = true;
                    source.connect(this.nodes.vinyl);
                    source.start();
                };
                
                playVinyl();
            }

            tick() {
                if (!this.ctx) return;
                
                // Smooth BPM changes
                this.beatMatcher.updateBpm();
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.beatMatcher.bpm / 4;
                
                // Swing timing - less aggressive
                let swing = this.seq.step % 2 === 1 ? beat * (1 + this.seq.swing) : beat * (1 - this.seq.swing);
                
                if (now >= this.seq.last + swing) {
                    this.seq.last = now;
                    this.warmupBeats++;
                    
                    // Pulse on downbeat
                    if (this.seq.step % 4 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 300);
                    }
                    
                    // PROFESSIONAL MASSIVE 808 DRUM PATTERNS
                    
                    // Kick pattern - massive and controlled
                    if ([0, 10].includes(this.seq.step % 16)) {
                        this.drumSynth.play808Kick(this.nodes.drums, 1.0);
                    }
                    
                    // Snare pattern - crispy and punchy
                    if ([4, 12].includes(this.seq.step % 16)) {
                        this.drumSynth.playSnare(this.nodes.drums, 0.9);
                    }
                    // Ghost snares for groove
                    if ([6, 14].includes(this.seq.step % 16) && Math.random() > 0.4) {
                        this.drumSynth.playSnare(this.nodes.drums, 0.3);
                    }
                    
                    // Hi-hat pattern - crispy and controlled
                    if ([2, 5, 6, 9, 10, 13, 14].includes(this.seq.step % 16)) {
                        this.drumSynth.playHat(this.nodes.drums, 0.6 + Math.random() * 0.2);
                    }
                    
                    // Bass starts after warmup (6 bars)
                    if (this.warmupBeats > 96 && !this.bassActive) {
                        this.bassActive = true;
                        console.log('808 Bass activated');
                    }
                    
                    // Play bass when active
                    if (this.bassActive) {
                        this.yeezusBass.play(this.seq.step, this.nodes.bass, this.beatMatcher.bpm);
                        
                        // Switch bass patterns every 4 bars
                        if (this.seq.step % 64 === 0) {
                            this.yeezusBass.switchPattern();
                        }
                    }
                    
                    // Sample playback
                    const samples = this.samples.get('sample');
                    if (samples.length > 0 && this.seq.step % 16 === 0) {
                        this.playSample(samples[0]);
                    }
                    
                    this.seq.step = (this.seq.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            playSample(sample) {
                // Kanye-style sample manipulation
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                const comp = this.ctx.createDynamicsCompressor();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                src.loopStart = 0;
                src.loopEnd = Math.min(sample.buffer.duration, 60 / this.beatMatcher.bpm * 4);
                
                // Dynamic filter based on motion
                filter.type = 'lowpass';
                filter.frequency.value = 3000;
                filter.Q.value = 1.5;
                
                // Sample compression - gentler
                comp.threshold.value = -20; // Higher threshold
                comp.knee.value = 6;
                comp.ratio.value = 3; // Lower ratio
                comp.attack.value = 0.005;
                comp.release.value = 0.15;
                
                // Automated filter movement
                const sweepTime = 8;
                const motionMod = this.beatMatcher.bpm / 75;
                filter.frequency.setValueAtTime(1500, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(6000 * motionMod, this.ctx.currentTime + sweepTime / 2);
                filter.frequency.linearRampToValueAtTime(1500, this.ctx.currentTime + sweepTime);
                
                gain.gain.value = 0.6; // Reduced level
                
                // Sidechain pumping - gentler
                const sidechain = () => {
                    if (!src.playbackState || src.playbackState === 'finished') return;
                    
                    // Subtle sidechain on kicks
                    if (this.seq.step === 0 || this.seq.step === 10) {
                        const duckAmount = 0.3 + (this.beatMatcher.bpm - 75) / 400; // Much gentler
                        gain.gain.cancelScheduledValues(this.ctx.currentTime);
                        gain.gain.setValueAtTime(duckAmount, this.ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 0.15);
                    }
                    
                    setTimeout(sidechain, 60000 / this.beatMatcher.bpm / 4);
                };
                
                // Lo-fi processing
                const processed = this.lofi.process(src);
                processed.connect(comp);
                comp.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample);
                
                src.start();
                sidechain();
                
                // Stop previous sample
                if (this.currentSample) {
                    this.currentSample.stop();
                }
                this.currentSample = src;
            }

            loop() {
                // Intelligent auto-sampling
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                let silenceCount = 0;
                
                setInterval(() => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    // Analyze for musical content
                    let harmonics = 0;
                    let energy = 0;
                    let lowEnd = 0;
                    
                    for (let i = 10; i < 100; i++) {
                        if (data[i] > 120) {
                            harmonics++;
                            energy += data[i];
                        }
                    }
                    
                    // Check for low end content
                    for (let i = 0; i < 20; i++) {
                        lowEnd += data[i];
                    }
                    
                    // Auto-record if musically interesting
                    const threshold = this.beatMatcher.bpm > 85 ? 12 : 18;
                    const energyThreshold = this.beatMatcher.bpm > 85 ? 1200 : 1800;
                    
                    if (harmonics > threshold && energy > energyThreshold && lowEnd > 500 && silenceCount > 30) {
                        this.toggle();
                        cooldown = 150; // 3 second cooldown
                        silenceCount = 0;
                    }
                    
                    // Track silence for better triggering
                    if (energy < 400) {
                        silenceCount++;
                    } else {
                        silenceCount = 0;
                    }
                    
                }, 20);
            }
        }

        new Engine();
