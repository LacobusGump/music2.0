<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OMNI // NEURAL ENGINE</title>
    <style>
        :root { --glow: #00ff41; --bg: #010201; --panel: rgba(20,20,20,0.9); }
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'IBM Plex Mono', monospace; }
        body { background: var(--bg); color: var(--glow); height: 100vh; overflow: hidden; font-size: 12px; }
        
        /* THE COMMAND CENTER */
        #viewport { position: absolute; inset: 0; z-index: 1; filter: contrast(1.2) brightness(1.1); }
        .overlay { position: absolute; inset: 0; z-index: 10; pointer-events: none; display: flex; flex-direction: column; padding: 25px; }
        
        .matrix-ui { border: 1px solid rgba(0,255,65,0.2); background: var(--panel); padding: 15px; width: 320px; backdrop-filter: blur(10px); }
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; text-transform: uppercase; font-size: 9px; }
        .val { color: #fff; text-shadow: 0 0 5px var(--glow); }

        .system-logs { margin-top: auto; height: 120px; overflow: hidden; opacity: 0.6; }
        
        .init-sequence { 
            position: absolute; inset: 0; background: #000; z-index: 100; 
            display: flex; align-items: center; justify-content: center; flex-direction: column;
        }
        
        .btn-engage {
            pointer-events: auto; background: none; border: 1px solid var(--glow); color: var(--glow);
            padding: 30px 60px; cursor: pointer; font-size: 16px; letter-spacing: 8px;
            box-shadow: 0 0 20px rgba(0,255,65,0.2); transition: 0.3s;
        }
        .btn-engage:hover { background: var(--glow); color: #000; }

        /* THE VISUALIZER SPECTRUM */
        .freq-bar { position: absolute; bottom: 0; background: var(--glow); width: 1px; opacity: 0.3; }
        
        .pulse { animation: pulse 2s infinite; }
        @keyframes pulse { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }
    </style>
</head>
<body>

<div class="init-sequence" id="bootLayer">
    <div style="margin-bottom: 20px; letter-spacing: 4px;">KERNEL V.9.02 // READY</div>
    <button class="btn-engage" id="bootBtn">ENGAGE OMNI</button>
</div>

<canvas id="viewport"></canvas>

<div class="overlay">
    <div class="matrix-ui">
        <div class="stat-row"><span>Logic State:</span><span class="val" id="st-logic">EVOLVING</span></div>
        <div class="stat-row"><span>Buffer Depth:</span><span class="val" id="st-buffer">0ms</span></div>
        <div class="stat-row"><span>Entropy Index:</span><span class="val" id="st-entropy">0.00</span></div>
        <div class="stat-row"><span>Spectral Flux:</span><span class="val" id="st-flux">STABLE</span></div>
        <div style="height: 1px; background: rgba(0,255,65,0.3); margin: 10px 0;"></div>
        <div class="stat-row"><span>Neural Seed:</span><span class="val" id="st-seed">0x882A</span></div>
    </div>

    <div class="system-logs" id="logs"></div>
</div>

<script>
/** * OMNI-ENGINE: HYPER-ENGINEERED GENERATIVE SIGNAL PROCESSOR
 * Core Concepts: Euclidean Sequencing, Spectral Analysis, Non-Deterministic Loop Branching
 */

class OmniEngine {
    constructor() {
        this.ctx = null;
        this.analyser = null;
        this.master = null;
        this.limiter = null;
        
        // Advanced DSP Nodes
        this.convolver = null;
        this.grainCloud = [];
        this.ringBuffer = null;
        this.bufferPointer = 0;
        this.maxBufferSize = 0; // Set on init
        
        // Genetic Sequencer Data
        this.tempo = 124;
        this.stepCount = 0;
        this.euclideanWeights = [13, 8, 5]; // Prime distribution
        this.logicState = 'DORMANT';
        
        this.motion = { alpha: 0, beta: 0, gamma: 0, velocity: 0 };
    }

    async boot() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.maxBufferSize = this.ctx.sampleRate * 4; // 4 seconds of memory
        
        // SIGNAL CHAIN: [Source] -> [Granulator] -> [Filter] -> [Delay] -> [Limiter] -> [Out]
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.setValueAtTime(-1, this.ctx.currentTime);
        this.limiter.knee.setValueAtTime(40, this.ctx.currentTime);
        this.limiter.ratio.setValueAtTime(12, this.ctx.currentTime);
        this.limiter.connect(this.ctx.destination);

        this.master = this.ctx.createGain();
        this.master.connect(this.limiter);

        // Global Space
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.buildSpace(2.5, 0.8);
        const verbGain = this.ctx.createGain();
        verbGain.gain.value = 0.3;
        this.master.connect(this.convolver);
        this.convolver.connect(verbGain);
        verbGain.connect(this.limiter);

        const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false } });
        this.input = this.ctx.createMediaStreamSource(stream);
        
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 4096;
        this.input.connect(this.analyser);

        this.setupSensors();
        this.log("KERNEL INITIALIZED. BOOTING NEURAL LAYERS...");
        
        // Recursive Analysis & Recording
        this.continuousSampling();
        this.renderLoop();
        this.mainSequence();
        
        this.logicState = 'ACTIVE';
        document.getElementById('st-logic').textContent = 'NEURAL_FLOW';
    }

    // Mathematical realization of an acoustic space
    buildSpace(dur, decayRate) {
        const len = this.ctx.sampleRate * dur;
        const buf = this.ctx.createBuffer(2, len, this.ctx.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
            const data = buf.getChannelData(ch);
            for (let i = 0; i < len; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, decayRate);
            }
        }
        return buf;
    }

    setupSensors() {
        window.addEventListener('deviceorientation', (e) => {
            const delta = Math.abs(e.beta - this.motion.beta) + Math.abs(e.gamma - this.motion.gamma);
            this.motion = { alpha: e.alpha, beta: e.beta, gamma: e.gamma, velocity: delta };
            document.getElementById('st-entropy').textContent = (delta / 10).toFixed(4);
        });
    }

    log(msg) {
        const l = document.getElementById('logs');
        const d = document.createElement('div');
        d.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
        l.prepend(d);
    }

    async continuousSampling() {
        const recNode = this.ctx.createScriptProcessor(4096, 1, 1);
        this.input.connect(recNode);
        recNode.connect(this.ctx.destination);

        const internalBuffer = new Float32Array(this.maxBufferSize);
        let ptr = 0;

        recNode.onaudioprocess = (e) => {
            const inputData = e.inputBuffer.getChannelData(0);
            internalBuffer.set(inputData, ptr);
            ptr = (ptr + inputData.length) % this.maxBufferSize;
            
            // Periodically promote internal data to an AudioBuffer
            if (ptr % 16384 === 0) {
                const newBuf = this.ctx.createBuffer(1, this.maxBufferSize, this.ctx.sampleRate);
                newBuf.copyToChannel(internalBuffer, 0);
                this.ringBuffer = newBuf;
                document.getElementById('st-buffer').textContent = '4000ms';
            }
        };
    }

    // EUCLIDEAN SEQUENCER LOGIC
    // Generates a rhythm based on Bjorklund's algorithm
    mainSequence() {
        const lookahead = 0.1;
        const bpm = this.tempo + (this.motion.velocity * 0.5);
        const stepTime = (60 / bpm) / 4; // 16th notes

        const pulse = () => {
            if (this.ringBuffer) {
                this.stepCount++;
                
                // Poly-metric Layering
                if (this.stepCount % 4 === 0) this.trigger('SUB_BASS', 1.0, 0.4);
                if ((this.stepCount * 7) % 13 < 4) this.trigger('GLITCH_PERC', 2.2, 0.1);
                if (this.motion.velocity > 5 && this.stepCount % 3 === 0) this.trigger('SPECTRAL_GRAIN', 0.5, 0.8);
            }
            setTimeout(pulse, stepTime * 1000);
        };
        pulse();
    }

    trigger(type, rate, dur) {
        const now = this.ctx.currentTime;
        const src = this.ctx.createBufferSource();
        src.buffer = this.ringBuffer;
        
        // RANDOMIZED SPATIAL POSITIONING
        const panner = this.ctx.createPanner();
        panner.setPosition(Math.sin(now) * 2, 0, Math.cos(now) * 2);

        // SPECTRAL FILTERING
        const filter = this.ctx.createBiquadFilter();
        filter.type = type === 'SUB_BASS' ? 'lowpass' : 'bandpass';
        filter.frequency.setValueAtTime(type === 'SUB_BASS' ? 150 : 2000 + (Math.random() * 3000), now);
        filter.Q.value = 15;

        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(type === 'SUB_BASS' ? 0.8 : 0.3, now + 0.005);
        gain.gain.exponentialRampToValueAtTime(0.001, now + dur);

        // Dynamic Playback Speed based on Sensor Gravity (beta)
        src.playbackRate.value = rate + (this.motion.beta / 180);
        
        src.connect(filter);
        filter.connect(panner);
        panner.connect(gain);
        gain.connect(this.master);

        // Find a random transient point in the 4s buffer
        const offset = Math.random() * (this.maxBufferSize / this.ctx.sampleRate - dur);
        src.start(now, offset, dur);
    }

    renderLoop() {
        const canvas = document.getElementById('viewport');
        const g = canvas.getContext('2d');
        const data = new Uint8Array(this.analyser.frequencyBinCount);

        const draw = () => {
            requestAnimationFrame(draw);
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            this.analyser.getByteFrequencyData(data);

            g.fillStyle = 'black';
            g.fillRect(0, 0, canvas.width, canvas.height);

            // DRAW NEURAL GRID
            g.strokeStyle = 'rgba(0, 255, 65, 0.1)';
            const cols = 10, rows = 10;
            for(let i=0; i<=cols; i++) {
                g.beginPath();
                g.moveTo(i * (canvas.width/cols), 0);
                g.lineTo(i * (canvas.width/cols), canvas.height);
                g.stroke();
            }

            // DRAW SPECTRAL FLUX
            g.beginPath();
            g.strokeStyle = '#00ff41';
            g.lineWidth = 2;
            for(let i=0; i<data.length; i++) {
                const x = (i / data.length) * canvas.width;
                const y = (data[i] / 255) * canvas.height;
                if(i===0) g.moveTo(x, canvas.height - y);
                else g.lineTo(x, canvas.height - y);
            }
            g.stroke();
            
            // MOTION VORTEX
            g.beginPath();
            g.arc(canvas.width/2, canvas.height/2, this.motion.velocity * 5, 0, Math.PI*2);
            g.stroke();
        };
        draw();
    }
}

const engine = new OmniEngine();
document.getElementById('bootBtn').onclick = () => {
    document.getElementById('bootLayer').style.display = 'none';
    engine.boot();
};

</script>
</body>
</html>
