<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 1s}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.3);transition:0.5s}
        #enter:hover div{border-color:rgba(255,255,255,0.4);color:rgba(255,255,255,0.6);transform:scale(1.05)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// The field is alive. It remembers. It breathes with you.

const TAU = Math.PI * 2;

// ============ THE LIVING FIELD ============

let ctx, master;
let field = {
    x: 0.5, y: 0.5,           // Position
    vx: 0, vy: 0,             // Velocity
    ax: 0, ay: 0,             // Acceleration (for transients)
    energy: 0,                 // Movement energy
    stillness: 0,              // How long still
    memory: [],                // Trail of where you've been
    maxMemory: 120,            // ~2 seconds at 60fps
    breath: 0,                 // Breathing cycle
    time: 0                    // Total time
};

let voices = [];
let sub = null;
let shimmer = null;
let texture = null;
let verb, dly;
let canvas, vc;
let running = false;

// The harmonic series - the DNA of all sound
const HARMONICS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const BASE = 55; // A1 - you feel it in your chest

// ============ INITIALIZATION ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master chain
    master = ctx.createGain();
    master.gain.value = 0.7;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -20;
    comp.ratio.value = 6;
    comp.attack.value = 0.003;
    comp.release.value = 0.25;

    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -3;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.1;

    // Reverb - the space you exist in
    verb = createReverb();

    // Delay - your echoes
    dly = createDelay();

    // Connect master chain
    master.connect(comp);
    comp.connect(limiter);
    limiter.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    // Create the layers
    createSub();
    createHarmonics();
    createShimmer();
    createTexture();

    // Canvas
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function createReverb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.4;

    // Long, diffuse reverb - like being inside sound
    const times = [0.02, 0.05, 0.08, 0.13, 0.21, 0.34, 0.55, 0.89, 1.2, 1.6];
    times.forEach((t, i) => {
        const d = ctx.createDelay(2);
        d.delayTime.value = t + Math.random() * 0.01; // Slight randomness for diffusion
        const g = ctx.createGain();
        g.gain.value = 0.35 * Math.pow(0.8, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 6000 - i * 500;
        const f2 = ctx.createBiquadFilter();
        f2.type = 'highpass';
        f2.frequency.value = 80;
        input.connect(d);
        d.connect(f);
        f.connect(f2);
        f2.connect(g);
        g.connect(output);
        // Feedback into verb for density
        if (i > 3) {
            const fb = ctx.createGain();
            fb.gain.value = 0.15;
            g.connect(fb);
            fb.connect(input);
        }
    });

    return { input, output };
}

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.3;

    // Ping-pong delay
    const delayL = ctx.createDelay(2);
    const delayR = ctx.createDelay(2);
    delayL.delayTime.value = 0.375; // Dotted eighth at ~80bpm
    delayR.delayTime.value = 0.5;   // Quarter

    const fbL = ctx.createGain();
    const fbR = ctx.createGain();
    fbL.gain.value = 0.4;
    fbR.gain.value = 0.35;

    const filterL = ctx.createBiquadFilter();
    const filterR = ctx.createBiquadFilter();
    filterL.type = filterR.type = 'lowpass';
    filterL.frequency.value = filterR.frequency.value = 2500;

    const panL = ctx.createStereoPanner();
    const panR = ctx.createStereoPanner();
    panL.pan.value = -0.7;
    panR.pan.value = 0.7;

    input.connect(delayL);
    delayL.connect(filterL);
    filterL.connect(fbL);
    fbL.connect(delayR);
    delayR.connect(filterR);
    filterR.connect(fbR);
    fbR.connect(delayL);

    filterL.connect(panL);
    filterR.connect(panR);
    panL.connect(output);
    panR.connect(output);

    return { input, output, delayL, delayR, fbL, fbR };
}

// ============ THE SUB ============
// The foundation. You feel it before you hear it.

function createSub() {
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.value = BASE / 2; // Octave below root
    osc2.type = 'sine';
    osc2.frequency.value = BASE / 2 * 1.001; // Slow beating

    filter.type = 'lowpass';
    filter.frequency.value = 100;
    gain.gain.value = 0;

    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    osc.start();
    osc2.start();

    sub = { osc, osc2, gain, filter };
}

// ============ THE HARMONICS ============
// The spectrum of overtones. Your position reveals different colors.

function createHarmonics() {
    HARMONICS.forEach((ratio, i) => {
        const freq = BASE * ratio;

        // Main oscillator
        const osc = ctx.createOscillator();
        osc.type = i < 4 ? 'sine' : 'triangle'; // Lower = purer, higher = richer

        // FM modulator for movement
        const mod = ctx.createOscillator();
        const modGain = ctx.createGain();
        mod.type = 'sine';
        mod.frequency.value = freq * (i % 3 === 0 ? 2 : i % 3 === 1 ? 3 : 1.5);
        modGain.gain.value = 0; // FM depth controlled by movement

        mod.connect(modGain);
        modGain.connect(osc.frequency);
        osc.frequency.value = freq;

        // Filter per voice
        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 1 + i * 0.3;

        // Gain
        const gain = ctx.createGain();
        gain.gain.value = 0;

        // Panning - spread across stereo field
        const pan = ctx.createStereoPanner();
        pan.pan.value = ((i % 2 === 0 ? 1 : -1) * (i / HARMONICS.length) * 0.8);

        // Connect
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(pan);
        pan.connect(master);
        pan.connect(verb.input);
        pan.connect(dly.input);

        osc.start();
        mod.start();

        voices.push({ osc, mod, modGain, filter, gain, pan, freq, ratio, index: i });
    });
}

// ============ THE SHIMMER ============
// High harmonics that appear with energy. Sparkle.

function createShimmer() {
    const oscs = [];
    const output = ctx.createGain();
    output.gain.value = 0;

    // High, clustered frequencies
    [16, 17, 18, 19, 20, 24, 25, 32].forEach((ratio, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = BASE * ratio + Math.random() * 10;

        const g = ctx.createGain();
        g.gain.value = 0.1 / 8;

        const pan = ctx.createStereoPanner();
        pan.pan.value = Math.random() * 2 - 1;

        osc.connect(g);
        g.connect(pan);
        pan.connect(output);
        osc.start();
        oscs.push({ osc, gain: g, pan });
    });

    output.connect(master);
    output.connect(verb.input);

    shimmer = { oscs, output };
}

// ============ THE TEXTURE ============
// Filtered noise that breathes. The air around the sound.

function createTexture() {
    // Noise source
    const bufferSize = ctx.sampleRate * 2;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const source = ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;

    const filter = ctx.createBiquadFilter();
    filter.type = 'bandpass';
    filter.frequency.value = 400;
    filter.Q.value = 2;

    const filter2 = ctx.createBiquadFilter();
    filter2.type = 'lowpass';
    filter2.frequency.value = 2000;

    const gain = ctx.createGain();
    gain.gain.value = 0;

    source.connect(filter);
    filter.connect(filter2);
    filter2.connect(gain);
    gain.connect(master);
    gain.connect(verb.input);

    source.start();

    texture = { source, filter, filter2, gain };
}

// ============ THE SHAPING ============
// Every frame, the field responds to you.

function shapeField() {
    const now = ctx.currentTime;
    const t = field.time;

    // Update physics
    const prevVx = field.vx;
    const prevVy = field.vy;
    field.ax = field.vx - prevVx;
    field.ay = field.vy - prevVy;

    // Energy from velocity
    const rawEnergy = Math.sqrt(field.vx*field.vx + field.vy*field.vy);
    field.energy = field.energy * 0.92 + rawEnergy * 0.4;

    // Stillness accumulates when not moving
    if (rawEnergy < 0.01) {
        field.stillness = Math.min(5, field.stillness + 0.016);
    } else {
        field.stillness = field.stillness * 0.95;
    }

    // Breath - slow oscillation
    field.breath = Math.sin(t * 0.3) * 0.5 + 0.5;

    // Memory - trail of positions
    field.memory.unshift({ x: field.x, y: field.y, energy: field.energy, t: now });
    if (field.memory.length > field.maxMemory) field.memory.pop();

    // ============ SHAPE THE SUB ============
    // Always present, swells with stillness
    const subAmp = 0.15 + field.stillness * 0.1 + field.breath * 0.05;
    sub.gain.gain.linearRampToValueAtTime(subAmp, now + 0.1);
    // Sub follows Y slightly - lower = more sub
    const subFreq = (BASE / 2) * (1 - field.y * 0.1);
    sub.osc.frequency.linearRampToValueAtTime(subFreq, now + 0.2);
    sub.osc2.frequency.linearRampToValueAtTime(subFreq * 1.001, now + 0.2);

    // ============ SHAPE THE HARMONICS ============
    voices.forEach((v, i) => {
        // Position determines which harmonics sing
        // Create multiple "zones" across X axis
        const zones = 3;
        const zone = Math.floor(field.x * zones);
        const zoneProgress = (field.x * zones) % 1;

        // Each harmonic belongs to certain zones
        const harmonicZone = i % zones;
        const inZone = harmonicZone === zone || harmonicZone === (zone + 1) % zones;
        const zoneAffinity = inZone ? 1 - Math.abs(zoneProgress - 0.5) * 2 : 0;

        // Y position opens the harmonics
        const yOpen = field.y;

        // Higher harmonics need more Y to open
        const harmonicThreshold = i / HARMONICS.length * 0.7;
        const harmonicPresence = Math.max(0, yOpen - harmonicThreshold) / (1 - harmonicThreshold);

        // Combine for amplitude
        const baseAmp = zoneAffinity * harmonicPresence * 0.12;
        const energyBoost = field.energy * 0.08;
        const breathMod = 1 + field.breath * 0.1;
        const amp = (baseAmp + energyBoost) * breathMod;

        v.gain.gain.linearRampToValueAtTime(amp, now + 0.08);

        // Filter follows Y and energy
        const filterBase = 200 + yOpen * 3000 + field.energy * 2000;
        v.filter.frequency.linearRampToValueAtTime(filterBase, now + 0.1);

        // FM depth from movement - movement adds richness
        const fmDepth = field.energy * v.freq * 0.5;
        v.modGain.gain.linearRampToValueAtTime(fmDepth, now + 0.05);

        // Subtle pitch drift from velocity
        const drift = 1 + field.vx * 0.01 * Math.sin(i);
        v.osc.frequency.linearRampToValueAtTime(v.freq * drift, now + 0.1);

        // Pan follows movement
        const basePan = ((i % 2 === 0 ? 1 : -1) * (i / HARMONICS.length) * 0.6);
        const panMod = field.vx * 0.4;
        v.pan.pan.linearRampToValueAtTime(
            Math.max(-1, Math.min(1, basePan + panMod)),
            now + 0.08
        );
    });

    // ============ SHAPE THE SHIMMER ============
    // Appears with energy
    const shimmerAmp = Math.pow(field.energy, 1.5) * 0.3;
    shimmer.output.gain.linearRampToValueAtTime(shimmerAmp, now + 0.1);

    // Shimmer frequencies drift with movement
    shimmer.oscs.forEach((s, i) => {
        const baseFreq = BASE * [16, 17, 18, 19, 20, 24, 25, 32][i];
        const drift = 1 + Math.sin(t * 2 + i) * 0.02 + field.vx * 0.05;
        s.osc.frequency.linearRampToValueAtTime(baseFreq * drift, now + 0.15);
    });

    // ============ SHAPE THE TEXTURE ============
    // Breathes with stillness
    const textureAmp = 0.02 + field.stillness * 0.03;
    texture.gain.gain.linearRampToValueAtTime(textureAmp, now + 0.2);

    // Filter follows position
    const textureFreq = 200 + field.y * 800 + field.breath * 200;
    texture.filter.frequency.linearRampToValueAtTime(textureFreq, now + 0.15);
    texture.filter2.frequency.linearRampToValueAtTime(1000 + field.y * 3000, now + 0.15);

    // ============ SHAPE THE SPACE ============
    // Reverb blooms with stillness
    const verbAmount = 0.3 + field.stillness * 0.2;
    verb.output.gain.linearRampToValueAtTime(verbAmount, now + 0.3);

    // Delay feedback with energy
    const delayFb = 0.3 + field.energy * 0.25;
    dly.fbL.gain.linearRampToValueAtTime(delayFb, now + 0.1);
    dly.fbR.gain.linearRampToValueAtTime(delayFb * 0.9, now + 0.1);

    // Delay time shifts slightly with movement
    const dlyTime = 0.375 + field.vx * 0.05;
    dly.delayL.delayTime.linearRampToValueAtTime(dlyTime, now + 0.2);
    dly.delayR.delayTime.linearRampToValueAtTime(dlyTime * 1.33, now + 0.2);
}

// ============ INPUT ============

function onMove(nx, ny) {
    nx = Math.max(0, Math.min(1, nx));
    ny = Math.max(0, Math.min(1, ny));

    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = field.x * 0.7 + nx * 0.3;
    field.y = field.y * 0.7 + ny * 0.3;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 8;
    const ay = (a.y || 0) / 8;

    field.vx = field.vx * 0.7 + ax * 0.3;
    field.vy = field.vy * 0.7 + ay * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.08));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.08));
}

function onOrientation(e) {
    const gx = Math.max(-1, Math.min(1, (e.gamma || 0) / 40));
    const gy = Math.max(-1, Math.min(1, (e.beta || 0) / 40 - 1));

    const nx = (gx + 1) / 2;
    const ny = (1 - gy) / 2;

    onMove(nx, ny);
}

// ============ VISUALIZATION ============

function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const t = field.time;

    // Fade - slower when still (let trails linger)
    const fadeSpeed = 0.06 + field.energy * 0.04 - field.stillness * 0.02;
    vc.fillStyle = `rgba(0, 0, 0, ${Math.max(0.02, fadeSpeed)})`;
    vc.fillRect(0, 0, w, h);

    const cx = field.x * w;
    const cy = (1 - field.y) * h;

    // Draw memory trail
    if (field.memory.length > 1) {
        vc.beginPath();
        vc.moveTo(field.memory[0].x * w, (1 - field.memory[0].y) * h);
        for (let i = 1; i < field.memory.length; i++) {
            const m = field.memory[i];
            const age = i / field.memory.length;
            vc.lineTo(m.x * w, (1 - m.y) * h);
        }
        const trailGrad = vc.createLinearGradient(
            field.memory[0].x * w, (1 - field.memory[0].y) * h,
            field.memory[field.memory.length-1].x * w, (1 - field.memory[field.memory.length-1].y) * h
        );
        trailGrad.addColorStop(0, `rgba(255, 255, 255, ${0.2 + field.energy * 0.3})`);
        trailGrad.addColorStop(1, 'rgba(255, 255, 255, 0)');
        vc.strokeStyle = trailGrad;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Harmonic visualization - vertical bands that glow
    voices.forEach((v, i) => {
        const amp = v.gain.gain.value;
        if (amp < 0.003) return;

        const vx = ((i + 0.5) / voices.length) * w;

        // Vertical line
        const lineHeight = amp * h * 0.8;
        const gradient = vc.createLinearGradient(vx, h/2 - lineHeight/2, vx, h/2 + lineHeight/2);
        const hue = 220 - i * 8;
        gradient.addColorStop(0, 'transparent');
        gradient.addColorStop(0.3, `hsla(${hue}, 70%, ${50 + amp * 40}%, ${amp * 0.8})`);
        gradient.addColorStop(0.5, `hsla(${hue}, 80%, ${60 + amp * 30}%, ${amp})`);
        gradient.addColorStop(0.7, `hsla(${hue}, 70%, ${50 + amp * 40}%, ${amp * 0.8})`);
        gradient.addColorStop(1, 'transparent');

        vc.beginPath();
        vc.moveTo(vx, h/2 - lineHeight/2);
        vc.lineTo(vx, h/2 + lineHeight/2);
        vc.strokeStyle = gradient;
        vc.lineWidth = 8 + amp * 30;
        vc.lineCap = 'round';
        vc.stroke();
    });

    // Shimmer particles
    if (field.energy > 0.1) {
        const numParticles = Math.floor(field.energy * 20);
        for (let i = 0; i < numParticles; i++) {
            const px = cx + (Math.random() - 0.5) * 200 * field.energy;
            const py = cy + (Math.random() - 0.5) * 200 * field.energy;
            const size = Math.random() * 2 + 1;
            vc.beginPath();
            vc.arc(px, py, size, 0, TAU);
            vc.fillStyle = `rgba(255, 255, 255, ${Math.random() * 0.5})`;
            vc.fill();
        }
    }

    // Core presence
    const coreR = 15 + field.energy * 40 + field.breath * 10;
    const coreGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    coreGrad.addColorStop(0, `rgba(255, 255, 255, ${0.4 + field.energy * 0.4})`);
    coreGrad.addColorStop(0.4, `rgba(200, 220, 255, ${0.2 + field.energy * 0.2})`);
    coreGrad.addColorStop(1, 'transparent');
    vc.fillStyle = coreGrad;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, TAU);
    vc.fill();

    // Stillness bloom - grows when still
    if (field.stillness > 0.5) {
        const bloomR = 50 + field.stillness * 100;
        const bloomGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, bloomR);
        const bloomAlpha = Math.min(0.15, (field.stillness - 0.5) * 0.1);
        bloomGrad.addColorStop(0, 'transparent');
        bloomGrad.addColorStop(0.5, `rgba(100, 150, 255, ${bloomAlpha})`);
        bloomGrad.addColorStop(1, 'transparent');
        vc.fillStyle = bloomGrad;
        vc.beginPath();
        vc.arc(cx, cy, bloomR, 0, TAU);
        vc.fill();
    }
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    field.time += 0.016;
    shapeField();
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, 1 - e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
