<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AURORA: Symbiotic Sonic Weaver v4 - Emergent Lo-Fi Trap Alchemist</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: rgba(255,255,255,0.7);
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            text-align: center;
            z-index: 1;
        }
        .awaken-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 18px;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .awaken-btn:hover {
            border-color: #fff;
            transform: scale(1.05);
        }
        .status {
            font-size: 12px;
            margin-top: 20px;
            opacity: 0.6;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="awaken-btn" id="awaken">AWAKEN THE ALCHEMIST</button>
        <div class="status" id="status">STATIC AWAITS TRANSMUTATION</div>
    </div>

    <script>
        // Global Nebula: Chaotic Sonic Mutations
        let aurora = {}; // The alchemist entity, pulsing with emergent audio life

        // Poetic Annotation: Alchemy's Dawn
        /*
        From void's static hum,
        Trap's heartbeat rises slow,
        Lo-fi empire reigns.
        */

        function initiateAlchemist() {
            aurora = {
                ctx: null,
                active: false,
                masterGain: null,
                analyzer: null,
                dataArray: null,
                timeDomainData: null,
                microphone: null,
                recorder: null,
                dummyGain: null,
                sampleBuffer: [],
                processedSamples: [],
                layers: [], // Expanded: {buffer, source, gain, pan, filter, delay, reverb, distortion, compressor}
                tempo: 75, // Lo-fi trap sweet spot
                lmState: {
                    mood: 'static', // Evolves: static -> chaotic -> rhythmic -> trap
                    energy: 0,
                    complexity: 1, // Starts high for static, decreases for structure
                    spectralCentroid: 0,
                    onsetDensity: 0,
                    harmony: 0,
                    evolutionTime: 0, // Time-based progression
                    gumpTriggered: false
                },
                autotuneScale: [0, 3, 5, 7, 10], // Minor pentatonic for trap vibes
                keyRoot: 2, // D minor for deep, moody trap
                elements: {
                    awaken: document.getElementById('awaken'),
                    status: document.getElementById('status')
                },
                lastSampleTime: 0,
                samplingInterval: 300, // Faster for responsive sampling
                maxSampleDuration: 4,
                beatStep: 0,
                patternLength: 64,
                fractalSeed: Math.random() * 1000,
                geneticPatterns: [], // Evolving trap rhythms
                threshold: 0.03, // Tuned for better sampling
                sensitivity: 1.2,
                evolutionInterval: 5000 // Evolve every 5s
            };

            aurora.elements.awaken.onclick = () => awakenAlchemist();
        }

        async function awakenAlchemist() {
            try {
                aurora.ctx = new AudioContext();
                await aurora.ctx.resume();
                aurora.masterGain = aurora.ctx.createGain();
                aurora.masterGain.gain.value = 0.8;
                aurora.masterGain.connect(aurora.ctx.destination);

                aurora.analyzer = aurora.ctx.createAnalyser();
                aurora.analyzer.fftSize = 4096;
                aurora.dataArray = new Uint8Array(aurora.analyzer.frequencyBinCount);
                aurora.timeDomainData = new Float32Array(aurora.analyzer.fftSize);
                aurora.masterGain.connect(aurora.analyzer);
                aurora.analyzer.connect(aurora.ctx.destination);

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                aurora.microphone = aurora.ctx.createMediaStreamSource(stream);

                aurora.recorder = aurora.ctx.createScriptProcessor(8192, 1, 1);
                aurora.microphone.connect(aurora.recorder);
                aurora.dummyGain = aurora.ctx.createGain();
                aurora.dummyGain.gain.value = 0;
                aurora.recorder.connect(aurora.dummyGain);
                aurora.dummyGain.connect(aurora.ctx.destination);
                aurora.recorder.onaudioprocess = processAudio.bind(aurora);

                aurora.active = true;
                aurora.elements.awaken.style.display = 'none';
                aurora.elements.status.textContent = 'STATIC TRANSMUTING...';
                generateInitialStatic();
                initializeGeneticPatterns();
                sequencerLoop();
                analysisLoop();
                evolutionLoop();
            } catch (e) {
                console.error('Alchemist Awakening Shattered:', e);
                aurora.elements.status.textContent = 'TRANSMUTATION DENIED: ' + e.message;
            }
        }

        // Poetic Annotation: Primordial Static Birth
        /*
        Hiss of vinyl ghosts,
        Tape's ancient whisper fades,
        Beats emerge from void.
        */

        function generateInitialStatic() {
            // Procedural lo-fi static: vinyl crackle, tape hiss, white noise
            const sampleRate = aurora.ctx.sampleRate;
            const staticTypes = ['crackle', 'hiss', 'static', 'lowHum'];
            staticTypes.forEach(type => {
                const length = sampleRate * (2 + Math.random() * 3);
                const buffer = aurora.ctx.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    switch (type) {
                        case 'crackle':
                            data[i] = (Math.random() < 0.01 ? Math.random() * 0.2 : 0) * Math.pow(1 - i / length, 2);
                            break;
                        case 'hiss':
                            data[i] = (Math.random() * 2 - 1) * 0.05;
                            break;
                        case 'static':
                            data[i] = mandelbrotNoise(i / sampleRate, aurora.fractalSeed) * 0.1;
                            break;
                        case 'lowHum':
                            data[i] = Math.sin(2 * Math.PI * 60 * i / sampleRate) * 0.03;
                            break;
                    }
                }
                aurora.processedSamples.push(buffer);
            });
            generateTrapEssentials();
            updateLayers();
        }

        function generateTrapEssentials() {
            // Procedural trap elements: 808 kick, snare, hi-hat, pad
            const sampleRate = aurora.ctx.sampleRate;
            const trapTypes = ['808kick', 'snare', 'hihat', 'pad', 'bassline'];
            trapTypes.forEach(type => {
                let length, data;
                switch (type) {
                    case '808kick':
                        length = sampleRate * 0.8;
                        const buffer = aurora.ctx.createBuffer(1, length, sampleRate);
                        data = buffer.getChannelData(0);
                        for (let i = 0; i < length; i++) {
                            const t = i / sampleRate;
                            data[i] = Math.sin(2 * Math.PI * (60 - 30 * t) * t) * Math.exp(-t * 5) * 0.8;
                        }
                        aurora.processedSamples.push(buffer);
                        break;
                    case 'snare':
                        length = sampleRate * 0.3;
                        const snareBuffer = aurora.ctx.createBuffer(1, length, sampleRate);
                        data = snareBuffer.getChannelData(0);
                        for (let i = 0; i < length; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.1)) * 0.6;
                        }
                        aurora.processedSamples.push(snareBuffer);
                        break;
                    case 'hihat':
                        length = sampleRate * 0.1;
                        const hatBuffer = aurora.ctx.createBuffer(1, length, sampleRate);
                        data = hatBuffer.getChannelData(0);
                        for (let i = 0; i < length; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (sampleRate * 0.02)) * 0.4;
                        }
                        aurora.processedSamples.push(hatBuffer);
                        break;
                    case 'pad':
                        length = sampleRate * 4;
                        const padBuffer = aurora.ctx.createBuffer(1, length, sampleRate);
                        data = padBuffer.getChannelData(0);
                        for (let i = 0; i < length; i++) {
                            data[i] = 0;
                            [1, 1.5, 2].forEach(h => {
                                data[i] += Math.sin(2 * Math.PI * 110 * h * i / sampleRate) / h * Math.exp(-i / (sampleRate * 2)) * 0.3;
                            });
                        }
                        aurora.processedSamples.push(padBuffer);
                        break;
                    case 'bassline':
                        length = sampleRate * 1;
                        const bassBuffer = aurora.ctx.createBuffer(1, length, sampleRate);
                        data = bassBuffer.getChannelData(0);
                        for (let i = 0; i < length; i++) {
                            const t = i / sampleRate;
                            data[i] = Math.sin(2 * Math.PI * (55 - 20 * t) * t) * Math.exp(-t * 3) * 0.7;
                        }
                        aurora.processedSamples.push(bassBuffer);
                        break;
                }
            });
        }

        function processAudio(e) {
            if (!aurora.active) return;
            const input = e.inputBuffer.getChannelData(0);
            const rms = rootMeanSquare(input);
            const now = Date.now();

            if (rms > aurora.threshold && now - aurora.lastSampleTime > aurora.samplingInterval) {
                aurora.sampleBuffer.push(...input);
                if (aurora.sampleBuffer.length > aurora.ctx.sampleRate * aurora.maxSampleDuration) {
                    processSample();
                    aurora.sampleBuffer = [];
                    aurora.lastSampleTime = now;
                }
            } else if (aurora.sampleBuffer.length > 0 && rms < aurora.threshold / 3) {
                processSample();
                aurora.sampleBuffer = [];
                aurora.lastSampleTime = now;
            }
        }

        function rootMeanSquare(data) {
            let sum = 0;
            data.forEach(val => sum += val * val);
            return Math.sqrt(sum / data.length);
        }

        async function processSample() {
            if (aurora.sampleBuffer.length < aurora.ctx.sampleRate * 0.4) return; // Enforce min for valid samples

            const buffer = aurora.ctx.createBuffer(1, aurora.sampleBuffer.length, aurora.ctx.sampleRate);
            buffer.getChannelData(0).set(aurora.sampleBuffer);

            analyzeSample(buffer);

            const chops = chopOnOnsets(buffer);

            const processedChops = await Promise.all(chops.map(chop => autotuneAndEffectChop(chop)));
            processedChops.forEach(tuned => aurora.processedSamples.push(tuned));
            if (aurora.processedSamples.length > 64) aurora.processedSamples.splice(0, aurora.processedSamples.length - 64);

            updateLayers();
        }

        function analyzeSample(buffer) {
            const data = buffer.getChannelData(0);
            let energy = 0;
            data.forEach(val => energy += val * val);
            aurora.lmState.energy = Math.sqrt(energy / data.length);

            const onsets = getPeaksAtThreshold(data, 0.08).length / buffer.duration;
            aurora.lmState.onsetDensity = onsets;

            const pitch = detectPitch(data);
            aurora.lmState.harmony = pitch > 0 ? 1 / (Math.abs(pitch - snapToScale(pitch)) + 0.1) : 0;

            let num = 0, den = 0;
            for (let i = 0; i < data.length / 2; i++) {
                num += i * Math.abs(data[i]);
                den += Math.abs(data[i]);
            }
            aurora.lmState.spectralCentroid = den > 0 ? num / den * (aurora.ctx.sampleRate / data.length) : 0;

            // Easter egg: Detect "Gump" via pitch sequence ~392 Hz (G)
            if (pitch > 380 && pitch < 400 && !aurora.lmState.gumpTriggered) {
                aurora.lmState.gumpTriggered = true;
                aurora.lmState.mood = 'trap';
                aurora.lmState.complexity = 0.3;
                aurora.elements.status.textContent = 'GUMP SUMMONS TRAP EMPIRE';
            }

            updateMood();
            aurora.elements.status.textContent = `MOOD: ${aurora.lmState.mood.toUpperCase()} | ENERGY: ${aurora.lmState.energy.toFixed(2)} | TEMPO: ${Math.round(aurora.tempo)}`;
        }

        function updateMood() {
            const evol = aurora.lmState.evolutionTime / 60; // Minutes
            aurora.lmState.complexity = Math.max(0.2, 1 - evol * 0.1); // Decrease over time
            if (evol < 1 || aurora.lmState.mood === 'static') aurora.lmState.mood = 'static';
            else if (evol < 2) aurora.lmState.mood = 'chaotic';
            else if (evol < 3) aurora.lmState.mood = 'rhythmic';
            else aurora.lmState.mood = 'trap';

            if (aurora.lmState.energy > 0.25 && aurora.lmState.onsetDensity > 6) aurora.lmState.mood = 'chaotic';
            if (aurora.lmState.harmony > 0.7) aurora.lmState.mood = 'rhythmic';
        }

        function chopOnOnsets(buffer) {
            const data = buffer.getChannelData(0);
            const peaks = getPeaksAtThreshold(data, 0.1);
            const chops = [];
            let start = 0;
            peaks.forEach(peak => {
                const length = peak - start;
                if (length > aurora.ctx.sampleRate * 0.08) {
                    const chop = aurora.ctx.createBuffer(1, length, aurora.ctx.sampleRate);
                    chop.getChannelData(0).set(data.subarray(start, peak));
                    chops.push(chop);
                }
                start = peak;
            });
            const lastLength = data.length - start;
            if (lastLength > aurora.ctx.sampleRate * 0.08) {
                const chop = aurora.ctx.createBuffer(1, lastLength, aurora.ctx.sampleRate);
                chop.getChannelData(0).set(data.subarray(start));
                chops.push(chop);
            }
            return chops.length > 0 ? chops : [buffer]; // Fallback to whole if no chops
        }

        function getPeaksAtThreshold(data, threshold) {
            const peaks = [];
            const length = data.length;
            let i = 0;
            while (i < length) {
                if (Math.abs(data[i]) > threshold) {
                    peaks.push(i);
                    i += Math.floor(aurora.ctx.sampleRate * 0.04);
                }
                i++;
            }
            return peaks;
        }

        async function autotuneAndEffectChop(chop) {
            let pitch = detectPitch(chop.getChannelData(0));
            if (pitch > 0) {
                const target = snapToScale(pitch);
                const factor = target / pitch;

                const newLength = Math.floor(chop.length / factor);
                const offline = new OfflineAudioContext(1, newLength, aurora.ctx.sampleRate);
                const source = offline.createBufferSource();
                source.buffer = chop;
                source.playbackRate.value = factor;

                // Lo-fi effects: saturation, low-pass, reverb
                const distortion = offline.createWaveShaper();
                distortion.curve = makeDistortionCurve(2 + aurora.lmState.energy * 3); // Tape saturation
                const filter = offline.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3000 - aurora.lmState.complexity * 2000;
                const delay = offline.createDelay(0.3);
                delay.delayTime.value = 0.1 + aurora.lmState.complexity * 0.1;
                const reverb = offline.createConvolver();
                reverb.buffer = generateReverbImpulse();

                source.connect(distortion).connect(filter).connect(delay).connect(reverb).connect(offline.destination);
                source.start(0);
                return await offline.startRendering();
            }
            return chop;
        }

        function generateReverbImpulse() {
            const length = aurora.ctx.sampleRate * 3;
            const buffer = aurora.ctx.createBuffer(1, length, aurora.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < length; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3) * 0.5;
            }
            return buffer;
        }

        function detectPitch(data) {
            // Enhanced with better normalization and threshold
            const sampleRate = aurora.ctx.sampleRate;
            const minFreq = 30;
            const maxFreq = 1500;
            let size = data.length;
            if (size > 16384) {
                data = data.subarray(0, 16384);
                size = 16384;
            }
            const minLag = Math.ceil(sampleRate / maxFreq);
            const maxLag = Math.floor(sampleRate / minFreq);
            const ac = new Array(maxLag + 1).fill(0);

            let energy = 0;
            data.forEach(v => energy += v * v);
            if (Math.sqrt(energy / size) < 0.02) return -1; // Too quiet

            for (let lag = minLag; lag <= maxLag; lag++) {
                let sum = 0;
                for (let j = 0; j < size - lag; j++) {
                    sum += data[j] * data[j + lag];
                }
                ac[lag] = sum / (size - lag);
            }

            let maxValue = -Infinity;
            let bestLag = -1;
            for (let lag = minLag; lag <= maxLag; lag++) {
                if (ac[lag] > maxValue) {
                    maxValue = ac[lag];
                    bestLag = lag;
                }
            }
            if (bestLag > 0 && maxValue > 0.25) {
                const a = ac[bestLag - 1] || 0;
                const b = ac[bestLag];
                const c = ac[bestLag + 1] || 0;
                const delta = b > 0 ? (a - c) / (2 * (a - 2 * b + c)) : 0;
                return sampleRate / (bestLag + delta);
            }
            return -1;
        }

        function snapToScale(pitch) {
            if (pitch <= 0) return 110; // Low A for trap bass
            const midi = 69 + 12 * Math.log2(pitch / 440);
            const scaleMidi = aurora.autotuneScale.map(s => s + aurora.keyRoot + 36); // Low octave for trap
            let closest = scaleMidi.reduce((prev, curr) => Math.abs(curr - midi) < Math.abs(prev - midi) ? curr : prev);
            return 440 * Math.pow(2, (closest - 69) / 12);
        }

        function makeDistortionCurve(amount) {
            const k = amount;
            const n = 44100;
            const curve = new Float32Array(n);
            for (let i = 0; i < n; ++i) {
                const x = i * 2 / n - 1;
                curve[i] = Math.tanh(k * x); // Soft saturation for lo-fi
            }
            return curve;
        }

        function updateLayers() {
            aurora.layers.forEach(layer => {
                if (layer.source) layer.source.stop();
            });
            aurora.layers = [];

            // Layer blending: More static early, more trap later
            const staticCount = Math.floor(aurora.processedSamples.length * aurora.lmState.complexity);
            const trapCount = aurora.processedSamples.length - staticCount;
            aurora.processedSamples.slice(0, staticCount).forEach((sample, i) => addLayer(sample, i, 'static'));
            aurora.processedSamples.slice(-trapCount).forEach((sample, i) => addLayer(sample, i, 'trap'));

            function addLayer(sample, i, type) {
                if (!sample) return;
                const source = aurora.ctx.createBufferSource();
                source.buffer = sample;
                source.loop = true;

                const gain = aurora.ctx.createGain();
                gain.gain.value = (type === 'static' ? 0.3 : 0.5) - i * 0.01;

                const pan = aurora.ctx.createStereoPanner();
                pan.pan.value = Math.sin(i / aurora.processedSamples.length * Math.PI);

                const filter = aurora.ctx.createBiquadFilter();
                filter.type = type === 'static' ? 'highpass' : 'lowpass';
                filter.frequency.value = type === 'static' ? 5000 + i * 100 : 2000 - aurora.lmState.complexity * 1000;
                filter.Q.value = 0.5 + aurora.lmState.onsetDensity / 10;

                const delay = aurora.ctx.createDelay(0.5);
                delay.delayTime.value = 0.05 + aurora.lmState.complexity * 0.2;

                const distortion = aurora.ctx.createWaveShaper();
                distortion.curve = makeDistortionCurve(1 + aurora.lmState.energy * 4);

                const reverb = aurora.ctx.createConvolver();
                reverb.buffer = generateReverbImpulse();

                const compressor = aurora.ctx.createDynamicsCompressor();
                compressor.threshold.value = -24;
                compressor.ratio.value = 12;

                source.connect(filter).connect(distortion).connect(delay).connect(reverb).connect(pan).connect(gain).connect(compressor).connect(aurora.masterGain);
                source.start();

                aurora.layers.push({source, gain, pan, filter, delay, distortion, reverb, compressor});
            }
        }

        function sequencerLoop() {
            const stepDuration = 60 / aurora.tempo / 8 * 1000; // 32nd notes, trap triplets via patterns
            setTimeout(() => {
                playBeatStep();
                sequencerLoop();
            }, stepDuration);
        }

        function playBeatStep() {
            const pattern = aurora.geneticPatterns[0] || generateTrapPattern();
            if (pattern[aurora.beatStep % aurora.patternLength]) {
                const isTrap = aurora.lmState.mood === 'trap' || aurora.lmState.mood === 'rhythmic';
                const sampleIndex = isTrap ? Math.floor(aurora.processedSamples.length / 2 + Math.random() * aurora.processedSamples.length / 2) : Math.floor(Math.random() * aurora.processedSamples.length / 2);
                const sample = aurora.processedSamples[sampleIndex];
                if (sample) {
                    const source = aurora.ctx.createBufferSource();
                    source.buffer = sample;
                    const gain = aurora.ctx.createGain();
                    gain.gain.value = 0.5 + aurora.lmState.energy * 0.3;
                    source.connect(gain).connect(aurora.masterGain);
                    source.start(0);
                }
            }
            aurora.beatStep++;
        }

        // Poetic Annotation: Trap Rhythms Evolve
        /*
        Triplets pulse like rain,
        808s thunder deep,
        Static yields to groove.
        */

        function generateTrapPattern() {
            const pattern = new Array(aurora.patternLength).fill(0);
            // Trap structure: Kick on 1, snare on 3, hi-hats triplets
            for (let i = 0; i < aurora.patternLength; i++) {
                if (i % 16 === 0) pattern[i] = 1; // Kick
                if (i % 16 === 8) pattern[i] = 1; // Snare
                if (i % (16 / 3) < 1) pattern[i] = 1; // Triplet hats approx
            }
            // Modulate by mood
            if (aurora.lmState.mood === 'static') pattern.fill(Math.random() < 0.1 ? 1 : 0);
            if (aurora.lmState.mood === 'chaotic') pattern.map((v, i) => Math.random() < 0.4 ? 1 : 0);
            if (aurora.lmState.mood === 'rhythmic') pattern.map((v, i) => i % 4 === 0 ? 1 : v);
            return pattern;
        }

        function initializeGeneticPatterns() {
            aurora.geneticPatterns = [];
            for (let i = 0; i < 5; i++) {
                aurora.geneticPatterns.push(generateTrapPattern());
            }
        }

        function evolutionLoop() {
            setTimeout(() => {
                evolvePatterns();
                aurora.lmState.evolutionTime += aurora.evolutionInterval / 1000;
                updateMood();
                updateLayers(); // Re-layer on evolution
                evolutionLoop();
            }, aurora.evolutionInterval);
        }

        function evolvePatterns() {
            const fitness = pat => {
                const density = pat.reduce((a, b) => a + b, 0) / aurora.patternLength;
                return Math.abs(density - (1 - aurora.lmState.complexity)); // Favor structure as complexity drops
            };
            aurora.geneticPatterns.sort((a, b) => fitness(a) - fitness(b));
            const elite = aurora.geneticPatterns.slice(0, 2);

            const newPop = [...elite];
            while (newPop.length < 5) {
                const p1 = elite[Math.floor(Math.random() * elite.length)];
                const p2 = aurora.geneticPatterns[Math.floor(Math.random() * aurora.geneticPatterns.length)];
                const child = [];
                for (let i = 0; i < aurora.patternLength; i++) {
                    child[i] = Math.random() < 0.6 ? p1[i] : p2[i];
                    if (Math.random() < 0.03) child[i] = 1 - child[i]; // Low mutation for stability
                }
                newPop.push(child);
            }
            aurora.geneticPatterns = newPop;
        }

        function analysisLoop() {
            requestAnimationFrame(analysisLoop);
            if (!aurora.active) return;

            aurora.analyzer.getByteFrequencyData(aurora.dataArray);
            aurora.analyzer.getFloatTimeDomainData(aurora.timeDomainData);

            let energy = 0;
            aurora.timeDomainData.forEach(val => energy += val * val);
            aurora.lmState.energy = Math.sqrt(energy / aurora.timeDomainData.length);

            let num = 0, den = 0;
            aurora.dataArray.forEach((val, i) => {
                num += i * val;
                den += val;
            });
            aurora.lmState.spectralCentroid = den > 0 ? (num / den) * (aurora.ctx.sampleRate / 2 / aurora.dataArray.length) : 0;

            // Auto-sample if quiet for too long
            if (aurora.lmState.energy < 0.01 && Date.now() - aurora.lastSampleTime > 5000) {
                aurora.lastSampleTime = Date.now();
                generateTrapEssentials(); // Inject more elements
            }
        }

        function mandelbrotNoise(t, seed) {
            let x = t * 3 - 1.5 + seed;
            let y = Math.cos(t * Math.PI * 2);
            let zx = 0, zy = 0;
            let iter = 0;
            const maxIter = 30;
            while (zx * zx + zy * zy < 4 && iter < maxIter) {
                const xt = zx * zx - zy * zy + x;
                zy = 2 * zx * zy + y;
                zx = xt;
                iter++;
            }
            return (iter / maxIter) * 2 - 1;
        }

        // Self-Testing: Play evolving sequence on load if possible
        function selfTest() {
            console.log('Alchemist Self-Test: Listen for static evolving to trap beats.');
        }

        initiateAlchemist();
        selfTest();
    </script>
</body>
</html>
