<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ALIVE</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      overflow: hidden;
      height: 100vh;
      cursor: none;
      user-select: none;
      -webkit-user-select: none;
      font-family: -apple-system, system-ui, sans-serif;
    }
    
    /* Golden Spiral Container */
    .fibonacci-field {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 89vmin; /* Fibonacci number */
      height: 89vmin;
      pointer-events: none;
    }
    
    /* Core Visualization - Golden Ratio Proportions */
    .nucleus {
      position: absolute;
      top: 38.2%; /* Golden ratio percentage */
      left: 38.2%;
      width: 23.6%; /* Another golden ratio division */
      height: 23.6%;
      border-radius: 50%;
      background: radial-gradient(circle, 
        rgba(255,255,255,0.03) 0%, 
        transparent 61.8%);
      filter: blur(0.5px);
      transition: all 2.333s cubic-bezier(0.382, 0, 0.618, 1);
    }
    
    .nucleus.sampling {
      background: radial-gradient(circle, 
        rgba(255,255,255,0.08) 0%, 
        rgba(255,255,255,0.02) 38.2%,
        transparent 61.8%);
      animation: breathe 3.777s ease-in-out infinite;
    }
    
    @keyframes breathe {
      0%, 100% { transform: scale(1); }
      38.2% { transform: scale(1.0618); }
      61.8% { transform: scale(0.9382); }
    }
    
    /* Fibonacci Rings - Sound Layers */
    .ring {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      border-radius: 50%;
      border: 0.618px solid rgba(255,255,255,0.02);
      pointer-events: none;
      opacity: 0;
      transition: opacity 1.618s ease, border-color 0.618s ease;
    }
    
    .ring.active {
      opacity: 1;
      animation: rotate 21.34s linear infinite;
    }
    
    @keyframes rotate {
      from { transform: translate(-50%, -50%) rotate(0deg); }
      to { transform: translate(-50%, -50%) rotate(360deg); }
    }
    
    /* Spectral Ribbons - Fibonacci Spirals */
    .ribbon {
      position: absolute;
      width: 1px;
      background: linear-gradient(transparent, rgba(255,255,255,0.03), transparent);
      transform-origin: center bottom;
      pointer-events: none;
      opacity: 0;
      transition: opacity 2.333s ease;
    }
    
    .ribbon.visible {
      opacity: 1;
    }
    
    /* Sample Ghosts - Captured Sounds */
    .ghost {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.13);
      pointer-events: none;
      animation: drift 13.21s ease-in-out infinite;
    }
    
    @keyframes drift {
      0%, 100% { 
        transform: translate(0, 0) scale(1); 
        opacity: 0;
      }
      21% { opacity: 0.34; }
      61.8% { 
        transform: translate(var(--dx), var(--dy)) scale(1.618); 
        opacity: 0.55;
      }
      89% { opacity: 0; }
    }
    
    /* Evolution Indicator - Minimal State */
    .evolution-trace {
      position: fixed;
      bottom: 3.4vh;
      left: 50%;
      transform: translateX(-50%);
      width: 144px; /* Fibonacci number */
      height: 1px;
      background: linear-gradient(90deg, 
        transparent, 
        rgba(255,255,255,0.08) 38.2%, 
        rgba(255,255,255,0.08) 61.8%, 
        transparent);
      opacity: 0;
      transition: opacity 3.777s ease;
    }
    
    .evolution-trace.visible {
      opacity: 1;
    }
    
    /* Activation Prompt - Only shown at start */
    .awaken {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 13px;
      letter-spacing: 8px;
      color: rgba(255,255,255,0.13);
      font-weight: 100;
      opacity: 1;
      transition: opacity 3.777s ease;
      pointer-events: none;
      text-align: center;
    }
    
    .awaken.hidden {
      opacity: 0;
    }
    
    /* Dimensional Veil - Environmental Response */
    .veil {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: radial-gradient(circle at var(--mx, 50%) var(--my, 50%), 
        transparent 21.34%, 
        rgba(255,255,255,0.008) 61.8%,
        rgba(0,0,0,0.34) 100%);
      pointer-events: none;
      mix-blend-mode: screen;
      opacity: 0.618;
    }
    
    /* Hidden but essential */
    canvas { display: none; }
  </style>
</head>
<body>
  <div class="veil"></div>
  <div class="fibonacci-field" id="field">
    <div class="nucleus" id="nucleus"></div>
  </div>
  <div class="evolution-trace" id="trace"></div>
  <div class="awaken" id="awaken">BREATHE</div>

  <script>
    'use strict';

    class AliveDJ {
      constructor() {
        this.φ = 1.618033988749; // Golden ratio
        this.ctx = null;
        this.active = false;
        this.evolution = 0;
        this.samples = [];
        this.currentSample = null;
        this.isRecording = false;
        this.recordBuffer = [];
        
        // Motion tracking
        this.motion = { x: 0, y: 0, z: 0, intensity: 0 };
        this.lastMotion = Date.now();
        this.stillness = 0;
        
        // Musical state
        this.bpm = 89; // Fibonacci number
        this.step = 0;
        this.phrase = 0;
        this.key = 432 / this.φ; // ~267Hz, harmonically tuned
        
        // Layers - Fibonacci sequence depths
        this.layers = {
          pulse: { active: false, depth: 1 },
          breath: { active: false, depth: 1 },
          flow: { active: false, depth: 2 },
          echo: { active: false, depth: 3 },
          dream: { active: false, depth: 5 },
          spirit: { active: false, depth: 8 },
          cosmos: { active: false, depth: 13 },
          void: { active: false, depth: 21 }
        };
        
        // Sample intelligence
        this.sampleMemory = [];
        this.samplePatterns = [];
        this.beatGrid = new Array(144).fill(null); // Fibonacci grid
        
        // Visual elements
        this.rings = [];
        this.ribbons = [];
        this.ghosts = [];
        
        // Environmental awareness
        this.environment = {
          time: new Date().getHours(),
          noise: 0,
          harmony: 0,
          resonance: 0
        };
        
        this.init();
      }

      init() {
        // Single click/touch to start
        const start = async () => {
          document.removeEventListener('click', start);
          document.removeEventListener('touchstart', start);
          
          await this.awaken();
        };
        
        document.addEventListener('click', start);
        document.addEventListener('touchstart', start);
        
        // Motion detection
        this.setupMotion();
        
        // Create visual elements
        this.createFibonacciField();
      }

      async awaken() {
        try {
          // Audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)({
            sampleRate: 44100,
            latencyHint: 'interactive'
          });
          
          // Master chain - minimal, clean
          this.master = this.ctx.createGain();
          this.master.gain.value = 0.618;
          
          this.compressor = this.ctx.createDynamicsCompressor();
          this.compressor.threshold.value = -12;
          this.compressor.ratio.value = this.φ * 2;
          
          this.reverb = this.ctx.createConvolver();
          this.reverb.buffer = this.createGoldenReverb();
          
          this.reverbSend = this.ctx.createGain();
          this.reverbSend.gain.value = 0.382;
          
          // Connect chain
          this.master.connect(this.compressor);
          this.compressor.connect(this.ctx.destination);
          this.master.connect(this.reverbSend);
          this.reverbSend.connect(this.reverb);
          this.reverb.connect(this.ctx.destination);
          
          // Microphone - the soul of the system
          const stream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false,
              sampleRate: 44100
            }
          });
          
          this.mic = this.ctx.createMediaStreamSource(stream);
          this.analyzer = this.ctx.createAnalyser();
          this.analyzer.fftSize = 2048;
          this.analyzer.smoothingTimeConstant = 0.618;
          
          this.mic.connect(this.analyzer);
          
          // Start listening
          this.listenToReality();
          
          // Hide prompt
          document.getElementById('awaken').classList.add('hidden');
          document.getElementById('trace').classList.add('visible');
          
          this.active = true;
          this.pulse();
          this.evolve();
          
        } catch(e) {
          console.error('Failed to awaken:', e);
        }
      }

      createGoldenReverb() {
        const length = this.ctx.sampleRate * 2.333;
        const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let ch = 0; ch < 2; ch++) {
          const data = buffer.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, this.φ);
            const spiral = Math.sin(i / (this.ctx.sampleRate / 432) * Math.PI * 2);
            data[i] = (Math.random() * 2 - 1) * decay * spiral * 0.1618;
          }
        }
        
        return buffer;
      }

      createFibonacciField() {
        const field = document.getElementById('field');
        
        // Create rings - Fibonacci sequence
        const fibSizes = [21, 34, 55, 89, 144, 233, 377];
        fibSizes.forEach((size, i) => {
          const ring = document.createElement('div');
          ring.className = 'ring';
          ring.style.width = `${size}%`;
          ring.style.height = `${size}%`;
          ring.style.animationDuration = `${size * 0.0618}s`;
          ring.style.animationDelay = `${i * 0.618}s`;
          field.appendChild(ring);
          this.rings.push(ring);
        });
        
        // Create ribbons - golden spiral
        for (let i = 0; i < 34; i++) {
          const ribbon = document.createElement('div');
          ribbon.className = 'ribbon';
          const angle = (i / 34) * Math.PI * 2;
          const radius = 38.2 + i * 1.618;
          ribbon.style.left = `${50 + Math.cos(angle) * radius}%`;
          ribbon.style.top = `${50 + Math.sin(angle) * radius}%`;
          ribbon.style.height = `${radius * 0.618}%`;
          ribbon.style.transform = `rotate(${angle * 180 / Math.PI}deg)`;
          field.appendChild(ribbon);
          this.ribbons.push(ribbon);
        }
      }

      setupMotion() {
        // Device motion
        window.addEventListener('devicemotion', e => {
          if (!e.accelerationIncludingGravity) return;
          
          const acc = e.accelerationIncludingGravity;
          const intensity = Math.sqrt(
            Math.pow(acc.x || 0, 2) + 
            Math.pow(acc.y || 0, 2) + 
            Math.pow(acc.z || 0, 2)
          ) / 10;
          
          this.updateMotion(acc.x || 0, acc.y || 0, intensity);
        });
        
        // Mouse as fallback
        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          const dx = e.clientX - lastMouse.x;
          const dy = e.clientY - lastMouse.y;
          const intensity = Math.sqrt(dx * dx + dy * dy) / dt;
          
          this.updateMotion(
            dx / 10,
            dy / 10, 
            intensity
          );
          
          // Update veil
          document.documentElement.style.setProperty('--mx', `${e.clientX / window.innerWidth * 100}%`);
          document.documentElement.style.setProperty('--my', `${e.clientY / window.innerHeight * 100}%`);
          
          lastMouse = { x: e.clientX, y: e.clientY, time: now };
        });
      }

      updateMotion(x, y, intensity) {
        this.motion.x = x;
        this.motion.y = y;
        this.motion.intensity = this.motion.intensity * 0.618 + intensity * 0.382;
        
        if (intensity > 0.1) {
          this.lastMotion = Date.now();
          this.stillness = 0;
        } else {
          this.stillness = (Date.now() - this.lastMotion) / 1000;
        }
        
        // Evolve based on motion patterns
        this.evolution += intensity * 0.00618;
        
        // Update layer activation - fibonacci thresholds
        this.layers.pulse.active = this.evolution > 0;
        this.layers.breath.active = this.evolution > 0.0618;
        this.layers.flow.active = this.evolution > 0.1618;
        this.layers.echo.active = this.evolution > 0.382;
        this.layers.dream.active = this.evolution > 0.618;
        this.layers.spirit.active = this.evolution > 1;
        this.layers.cosmos.active = this.evolution > 1.618;
        this.layers.void.active = this.stillness > 13;
        
        // Visual feedback
        this.updateVisuals();
      }

      updateVisuals() {
        const nucleus = document.getElementById('nucleus');
        
        // Nucleus responds to evolution
        const scale = 1 + this.evolution * 0.0618;
        const blur = 0.5 + this.motion.intensity * 2;
        nucleus.style.transform = `scale(${scale})`;
        nucleus.style.filter = `blur(${blur}px)`;
        
        // Activate rings based on layers
        Object.keys(this.layers).forEach((layer, i) => {
          if (this.rings[i]) {
            this.rings[i].classList.toggle('active', this.layers[layer].active);
            if (this.layers[layer].active) {
              const opacity = 0.0382 + this.layers[layer].depth * 0.00618;
              this.rings[i].style.borderColor = `rgba(255,255,255,${opacity})`;
            }
          }
        });
        
        // Ribbons respond to motion
        this.ribbons.forEach((ribbon, i) => {
          const show = this.motion.intensity > (i * 0.0382);
          ribbon.classList.toggle('visible', show);
        });
        
        // Evolution trace
        const trace = document.getElementById('trace');
        trace.style.width = `${89 + this.evolution * 55}px`;
        trace.style.opacity = 0.08 + this.evolution * 0.05;
      }

      listenToReality() {
        const processor = this.ctx.createScriptProcessor(8192, 1, 1);
        const dataArray = new Float32Array(this.analyzer.frequencyBinCount);
        
        processor.onaudioprocess = () => {
          if (!this.active) return;
          
          this.analyzer.getFloatFrequencyData(dataArray);
          
          // Analyze environmental harmony
          let harmony = 0;
          let noise = 0;
          for (let i = 0; i < dataArray.length; i++) {
            const freq = i * this.ctx.sampleRate / this.analyzer.fftSize;
            const amplitude = Math.pow(10, dataArray[i] / 20);
            
            // Check for harmonic frequencies (multiples of base frequency)
            if (freq > 80 && freq < 2000) {
              const harmonic = freq / this.key;
              const nearestHarmonic = Math.round(harmonic);
              const harmonicity = 1 - Math.abs(harmonic - nearestHarmonic);
              harmony += harmonicity * amplitude;
            }
            
            noise += amplitude;
          }
          
          this.environment.harmony = harmony;
          this.environment.noise = noise;
          
          // Auto-sample interesting sounds
          if (harmony > 0.382 && !this.isRecording && this.samples.length < 13) {
            this.startSampling();
          }
        };
        
        this.mic.connect(processor);
        processor.connect(this.ctx.destination);
        
        // Sample recording processor
        this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
        this.recorder.onaudioprocess = e => {
          if (this.isRecording) {
            const data = e.inputBuffer.getChannelData(0);
            this.recordBuffer.push(...data);
            
            // Auto-stop after golden duration
            if (this.recordBuffer.length > this.ctx.sampleRate * 2.333) {
              this.stopSampling();
            }
          }
        };
      }

      startSampling() {
        if (this.isRecording) return;
        
        this.isRecording = true;
        this.recordBuffer = [];
        this.mic.connect(this.recorder);
        this.recorder.connect(this.ctx.destination);
        
        document.getElementById('nucleus').classList.add('sampling');
        
        // Auto-stop if nothing interesting
        setTimeout(() => {
          if (this.isRecording && this.recordBuffer.length < this.ctx.sampleRate * 0.382) {
            this.stopSampling();
          }
        }, 618);
      }

      stopSampling() {
        if (!this.isRecording) return;
        
        this.isRecording = false;
        this.mic.disconnect(this.recorder);
        this.recorder.disconnect();
        
        document.getElementById('nucleus').classList.remove('sampling');
        
        if (this.recordBuffer.length > this.ctx.sampleRate * 0.1618) {
          this.processSample(this.recordBuffer);
        }
      }

      processSample(data) {
        const buffer = this.ctx.createBuffer(1, data.length, this.ctx.sampleRate);
        buffer.getChannelData(0).set(data);
        
        // Analyze for beat detection
        const peaks = this.findPeaks(data);
        const rhythm = this.findRhythm(peaks);
        
        // Create AI-interpreted sample
        const sample = {
          buffer,
          peaks,
          rhythm,
          pitch: this.detectPitch(data),
          energy: this.calculateEnergy(data),
          timestamp: Date.now(),
          evolution: this.evolution
        };
        
        this.samples.push(sample);
        if (this.samples.length > 21) this.samples.shift(); // Fibonacci limit
        
        // Add to beat grid
        this.addToGrid(sample);
        
        // Create ghost visualization
        this.createGhost();
      }

      findPeaks(data) {
        const peaks = [];
        const threshold = this.calculateDynamicThreshold(data);
        
        for (let i = 1; i < data.length - 1; i++) {
          if (data[i] > threshold && 
              data[i] > data[i - 1] && 
              data[i] > data[i + 1]) {
            peaks.push({
              index: i,
              time: i / this.ctx.sampleRate,
              amplitude: data[i]
            });
          }
        }
        
        return peaks;
      }

      calculateDynamicThreshold(data) {
        const sorted = [...data].sort((a, b) => b - a);
        return sorted[Math.floor(sorted.length * 0.0618)]; // Golden ratio percentile
      }

      findRhythm(peaks) {
        if (peaks.length < 2) return null;
        
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
          intervals.push(peaks[i].time - peaks[i - 1].time);
        }
        
        // Find most common interval (likely beat)
        const sorted = [...intervals].sort((a, b) => a - b);
        const median = sorted[Math.floor(sorted.length / 2)];
        
        return {
          tempo: 60 / median,
          intervals,
          confidence: this.calculateRhythmConfidence(intervals, median)
        };
      }

      calculateRhythmConfidence(intervals, median) {
        const variance = intervals.reduce((sum, interval) => {
          return sum + Math.pow(interval - median, 2);
        }, 0) / intervals.length;
        
        return 1 / (1 + variance);
      }

      detectPitch(data) {
        // Autocorrelation for pitch detection
        const correlations = [];
        const minPeriod = Math.floor(this.ctx.sampleRate / 800); // ~800Hz max
        const maxPeriod = Math.floor(this.ctx.sampleRate / 80); // ~80Hz min
        
        for (let lag = minPeriod; lag < maxPeriod; lag++) {
          let correlation = 0;
          for (let i = 0; i < data.length - lag; i++) {
            correlation += data[i] * data[i + lag];
          }
          correlations.push({ lag, correlation });
        }
        
        const peak = correlations.reduce((max, c) => 
          c.correlation > max.correlation ? c : max
        );
        
        return this.ctx.sampleRate / peak.lag;
      }

      calculateEnergy(data) {
        return Math.sqrt(data.reduce((sum, x) => sum + x * x, 0) / data.length);
      }

      addToGrid(sample) {
        // Place sample in fibonacci grid position
        const gridPos = Math.floor(this.evolution * 89) % 144;
        this.beatGrid[gridPos] = sample;
        
        // Find patterns
        this.findPatterns();
      }

      findPatterns() {
        // Look for fibonacci sequences in the grid
        const fibSteps = [1, 1, 2, 3, 5, 8, 13, 21, 34];
        const patterns = [];
        
        for (let start = 0; start < this.beatGrid.length; start++) {
          if (!this.beatGrid[start]) continue;
          
          const pattern = [start];
          for (const step of fibSteps) {
            const next = (start + step) % this.beatGrid.length;
            if (this.beatGrid[next]) {
              pattern.push(next);
            }
          }
          
          if (pattern.length > 3) {
            patterns.push(pattern);
          }
        }
        
        this.samplePatterns = patterns;
      }

      createGhost() {
        const field = document.getElementById('field');
        const ghost = document.createElement('div');
        ghost.className = 'ghost';
        
        // Position based on golden spiral
        const angle = this.samples.length * this.φ * Math.PI;
        const radius = 13 + this.samples.length * 3.4;
        ghost.style.left = `${50 + Math.cos(angle) * radius}%`;
        ghost.style.top = `${50 + Math.sin(angle) * radius}%`;
        ghost.style.setProperty('--dx', `${Math.cos(angle) * 34}px`);
        ghost.style.setProperty('--dy', `${Math.sin(angle) * 34}px`);
        ghost.style.animationDelay = `${Math.random() * 8}s`;
        
        field.appendChild(ghost);
        this.ghosts.push(ghost);
        
        // Clean old ghosts
        if (this.ghosts.length > 34) {
          const old = this.ghosts.shift();
          old.remove();
        }
      }

      pulse() {
        if (!this.active) return;
        
        const beatTime = 60 / this.bpm;
        
        // Play current step
        this.playStep();
        
        // Advance
        this.step = (this.step + 1) % 144;
        if (this.step % 34 === 0) {
          this.phrase = (this.phrase + 1) % 8;
          this.evolveMusically();
        }
        
        // Next pulse - with slight humanization
        const swing = this.step % 2 === 0 ? 1 : 1.0618;
        setTimeout(() => this.pulse(), beatTime * 1000 * swing);
      }

      playStep() {
        const gridSample = this.beatGrid[this.step];
        
        // Layered playback based on evolution
        if (this.layers.pulse.active) {
          this.playPulse();
        }
        
        if (this.layers.breath.active && this.step % 8 === 0) {
          this.playBreath();
        }
        
        if (this.layers.flow.active && gridSample) {
          this.playSample(gridSample, 'flow');
        }
        
        if (this.layers.echo.active && this.step % 13 === 0) {
          const echoSample = this.samples[Math.floor(Math.random() * this.samples.length)];
          if (echoSample) this.playSample(echoSample, 'echo');
        }
        
        if (this.layers.dream.active && this.step % 21 === 0) {
          this.playDreamscape();
        }
        
        if (this.layers.spirit.active && this.step % 34 === 0) {
          this.playSpirit();
        }
        
        if (this.layers.cosmos.active && this.step % 55 === 0) {
          this.playCosmos();
        }
        
        if (this.layers.void.active) {
          this.playVoid();
        }
      }

      playPulse() {
        const osc = this.ctx.createOscillator();
        const env = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = this.key / Math.pow(2, 2); // Two octaves down
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.0618, this.ctx.currentTime + 0.01);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.618);
        
        osc.connect(env).connect(this.master);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.618);
      }

      playBreath() {
        const osc = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        // Create noise
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 1.618, this.ctx.sampleRate);
        const data = noiseBuffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.0618;
        }
        noise.buffer = noiseBuffer;
        
        osc.type = 'sine';
        osc.frequency.value = this.key * this.φ;
        
        filter.type = 'bandpass';
        filter.frequency.value = this.key * 2;
        filter.Q.value = this.φ;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.0382, this.ctx.currentTime + 0.618);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.618);
        
        osc.connect(filter);
        noise.connect(filter);
        filter.connect(env).connect(this.master);
        
        osc.start();
        noise.start();
        osc.stop(this.ctx.currentTime + 1.618);
        noise.stop(this.ctx.currentTime + 1.618);
      }

      playSample(sample, mode = 'normal') {
        const source = this.ctx.createBufferSource();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        source.buffer = sample.buffer;
        
        // Pitch adjustment based on detected pitch
        if (sample.pitch && mode === 'flow') {
          const pitchRatio = this.key / sample.pitch;
          source.playbackRate.value = pitchRatio;
        } else if (mode === 'echo') {
          source.playbackRate.value = 0.618; // Golden slowdown
        }
        
        filter.type = 'lowpass';
        filter.frequency.value = mode === 'echo' ? 800 : 2000;
        filter.Q.value = this.φ;
        
        const gainValue = mode === 'echo' ? 0.0382 : 0.0618;
        env.gain.setValueAtTime(gainValue, this.ctx.currentTime);
        
        if (mode === 'echo') {
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3.777);
        }
        
        source.connect(filter).connect(env).connect(this.master);
        source.start();
        
        // Loop if in void state
        if (this.layers.void.active) {
          source.loop = true;
          source.loopStart = 0;
          source.loopEnd = sample.buffer.duration * 0.618;
        }
      }

      playDreamscape() {
        // Harmonic series based on golden ratio
        for (let i = 0; i < 5; i++) {
          const osc = this.ctx.createOscillator();
          const env = this.ctx.createGain();
          const pan = this.ctx.createStereoPanner();
          
          osc.type = 'sine';
          osc.frequency.value = this.key * Math.pow(this.φ, i);
          
          pan.pan.value = Math.cos(i * this.φ) * 0.618;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.0234 / (i + 1), this.ctx.currentTime + 2.333);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8.0);
          
          osc.connect(pan).connect(env).connect(this.reverbSend);
          osc.start();
          osc.stop(this.ctx.currentTime + 8.0);
        }
      }

      playSpirit() {
        // Shepard tone with golden ratio
        for (let octave = 0; octave < 7; octave++) {
          const osc = this.ctx.createOscillator();
          const env = this.ctx.createGain();
          
          osc.type = 'triangle';
          const freq = this.key * Math.pow(2, octave - 3);
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(freq * this.φ, this.ctx.currentTime + 5.5);
          
          const amplitude = Math.sin((octave / 7) * Math.PI) * 0.0382;
          env.gain.setValueAtTime(amplitude, this.ctx.currentTime);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 5.5);
          
          osc.connect(env).connect(this.master);
          osc.start();
          osc.stop(this.ctx.currentTime + 5.5);
        }
      }

      playCosmos() {
        // Generative harmonics from samples
        if (this.samples.length > 3) {
          const cosmicSamples = this.samples.slice(-3);
          
          cosmicSamples.forEach((sample, i) => {
            const source = this.ctx.createBufferSource();
            const env = this.ctx.createGain();
            const delay = this.ctx.createDelay(2.333);
            const feedback = this.ctx.createGain();
            
            source.buffer = sample.buffer;
            source.playbackRate.value = Math.pow(this.φ, i - 1);
            
            delay.delayTime.value = (i + 1) * 0.382;
            feedback.gain.value = 0.382;
            
            env.gain.value = 0.0382 / (i + 1);
            
            source.connect(env);
            env.connect(delay);
            delay.connect(feedback);
            feedback.connect(delay);
            delay.connect(this.reverbSend);
            env.connect(this.master);
            
            source.start(this.ctx.currentTime + i * 0.618);
          });
        }
      }

      playVoid() {
        // Ambient drone from accumulated samples
        const drone = this.ctx.createOscillator();
        const env = this.ctx.createGain();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        drone.type = 'sine';
        drone.frequency.value = this.key / 4;
        
        lfo.type = 'sine';
        lfo.frequency.value = 0.0618; // Very slow
        lfoGain.gain.value = 5;
        
        lfo.connect(lfoGain).connect(drone.frequency);
        
        env.gain.value = 0.0134;
        
        drone.connect(env).connect(this.reverbSend);
        drone.start();
        lfo.start();
        
        // Stop after one cycle
        setTimeout(() => {
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          drone.stop(this.ctx.currentTime + 2);
          lfo.stop(this.ctx.currentTime + 2);
        }, 13000);
      }

      evolveMusically() {
        // Adjust BPM based on energy
        const avgEnergy = this.samples.reduce((sum, s) => sum + s.energy, 0) / this.samples.length || 0.5;
        this.bpm = 55 + avgEnergy * 89; // Range: 55-144 (Fibonacci numbers)
        
        // Transpose based on time of day
        const hour = new Date().getHours();
        const dayPhase = Math.sin((hour / 24) * Math.PI * 2);
        this.key = (432 / this.φ) * Math.pow(2, dayPhase * 0.25); // ±quarter tone variation
        
        // Update visual evolution
        if (this.evolution > 2.618) {
          this.transcend();
        }
      }

      transcend() {
        // Reset with learned patterns
        const knowledge = {
          patterns: this.samplePatterns,
          samples: this.samples.slice(-8), // Keep best samples
          evolution: this.evolution
        };
        
        // Reset evolution but keep knowledge
        this.evolution = 1;
        this.beatGrid = new Array(144).fill(null);
        
        // Reintegrate knowledge
        knowledge.samples.forEach((sample, i) => {
          const pos = i * 21 % 144; // Fibonacci spacing
          this.beatGrid[pos] = sample;
        });
        
        console.log('Transcended with', knowledge.patterns.length, 'patterns learned');
      }

      evolve() {
        if (!this.active) return;
        
        // Natural evolution based on time
        this.evolution += 0.000618;
        
        // Check environment periodically
        if (Math.random() < 0.0618) {
          this.senseEnvironment();
        }
        
        requestAnimationFrame(() => this.evolve());
      }

      senseEnvironment() {
        // Time-based evolution
        const hour = new Date().getHours();
        const timeEvolution = Math.abs(12 - hour) / 12; // Peak at noon/midnight
        
        // Complexity based on sample diversity
        const pitchDiversity = new Set(this.samples.map(s => Math.round(s.pitch / 10))).size;
        const rhythmDiversity = new Set(this.samples.map(s => Math.round(s.rhythm?.tempo || 0))).size;
        const complexity = (pitchDiversity + rhythmDiversity) / 20;
        
        // Adjust evolution rate
        this.evolution += (timeEvolution + complexity) * 0.00618;
        
        // Environmental response
        if (this.stillness > 21) {
          // Deep meditation state
          this.layers.void.active = true;
        } else if (this.stillness > 13) {
          // Rest state - slow evolution
          this.evolution *= 0.9382;
        }
      }
    }

    // Initialize
    new AliveDJ();
  </script>
</body>
</html>
