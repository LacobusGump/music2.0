<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gump</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        #fibCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.03;
        }

        .ghost-title {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            opacity: 0;
            letter-spacing: 21px;
            font-weight: 100;
            animation: ghostAppear 5s ease-out forwards;
            pointer-events: none;
            white-space: nowrap;
        }

        @keyframes ghostAppear {
            0% { opacity: 0; }
            50% { opacity: 0.08; }
            100% { opacity: 0; }
        }

        #initTouch {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            cursor: pointer;
            z-index: 1000;
        }

        #recordOrb {
            position: absolute;
            width: 55px;
            height: 55px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.618s ease;
            display: none;
            top: 61.8%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #recordOrb.active {
            background: rgba(255, 0, 0, 0.13);
            border-color: rgba(255, 0, 0, 0.34);
        }

        #recordOrb::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 89px;
            height: 89px;
            border: 1px solid rgba(255, 255, 255, 0.03);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            animation: fibPulse 8s ease-in-out infinite;
        }

        #recordOrb.active::before {
            animation: fibPulseActive 1.618s ease-in-out infinite;
        }

        @keyframes fibPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.03; }
            50% { transform: translate(-50%, -50%) scale(1.618); opacity: 0; }
        }

        @keyframes fibPulseActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.13; }
            50% { transform: translate(-50%, -50%) scale(1.618); opacity: 0; }
        }

        .outfit-dots {
            position: absolute;
            top: 34px;
            right: 34px;
            display: none;
        }

        .dot {
            width: 5px;
            height: 5px;
            background: rgba(255, 255, 255, 0.13);
            border-radius: 50%;
            margin: 8px 0;
            cursor: pointer;
            transition: all 0.618s ease;
        }

        .dot.active {
            background: rgba(255, 255, 255, 0.34);
            transform: scale(1.618);
        }

        .motion-trace {
            position: absolute;
            width: 2px;
            height: 2px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 50%;
            pointer-events: none;
            animation: fadeTrace 3s ease-out forwards;
        }

        @keyframes fadeTrace {
            0% { opacity: 0.13; transform: scale(1); }
            100% { opacity: 0; transform: scale(0.618); }
        }
    </style>
</head>
<body>
    <canvas id="fibCanvas"></canvas>
    <div class="ghost-title">Gump by James McCandless</div>
    
    <div id="initTouch"></div>
    <div id="recordOrb"></div>
    
    <div class="outfit-dots">
        <div class="dot active" data-outfit="0"></div>
        <div class="dot" data-outfit="1"></div>
        <div class="dot" data-outfit="2"></div>
        <div class="dot" data-outfit="3"></div>
    </div>

    <script>
        // Fibonacci constants
        const PHI = 1.618033988749895;
        const FIB = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597];
        
        // Core audio engine
        let ctx, master, comp, analyser;
        let voices = new Map();
        let recorder, recording = false;
        let chunks = [];
        
        // Environmental state
        let motion = { x: 0, y: 0, z: 0, total: 0 };
        let location = null;
        let outfit = 0;
        let lastTouch = { x: window.innerWidth / 2, y: window.innerHeight / 2 };
        
        // Outfit harmonic definitions (based on Fibonacci ratios)
        const outfits = [
            { name: 'cosmic', ratios: [1, PHI, PHI**2, PHI**3], color: 'hsl(233, 89%, 50%)' },
            { name: 'urban', ratios: [1, 1.414, 2, 2.828], color: 'hsl(0, 0%, 50%)' },
            { name: 'nature', ratios: [1, 1.5, 2.25, 3.375], color: 'hsl(144, 55%, 50%)' },
            { name: 'minimal', ratios: [1, 2, 3, 5], color: 'hsl(0, 0%, 89%)' }
        ];
        
        // Fibonacci spiral canvas
        const canvas = document.getElementById('fibCanvas');
        const canvasCtx = canvas.getContext('2d');
        
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            drawFibonacciSpiral();
        }
        
        function drawFibonacciSpiral() {
            const cx = canvas.width / 2;
            const cy = canvas.height / 2;
            canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
            canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
            canvasCtx.lineWidth = 1;
            
            // Draw golden spiral
            canvasCtx.beginPath();
            for (let i = 0; i < 1000; i++) {
                const angle = i * 0.1;
                const radius = Math.pow(PHI, angle / (2 * Math.PI)) * 2;
                const x = cx + radius * Math.cos(angle);
                const y = cy + radius * Math.sin(angle);
                
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
            }
            canvasCtx.stroke();
        }
        
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Initialize audio system
        async function initAudio() {
            ctx = new (window.AudioContext || window.webkitAudioContext)();
            
            master = ctx.createGain();
            master.gain.value = 0.21;
            
            comp = ctx.createDynamicsCompressor();
            comp.threshold.value = -34;
            comp.knee.value = 21;
            comp.ratio.value = 8;
            comp.attack.value = 0.003;
            comp.release.value = 0.144;
            
            analyser = ctx.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.89;
            
            master.connect(comp);
            comp.connect(analyser);
            analyser.connect(ctx.destination);
            
            // Setup permissions
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                setupRecording(stream);
                
                if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
                    await DeviceMotionEvent.requestPermission();
                }
                
                window.addEventListener('devicemotion', handleMotion);
                window.addEventListener('deviceorientation', handleOrientation);
                
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(pos => {
                        location = pos.coords;
                    });
                }
            } catch (e) {
                console.log('Permissions:', e);
            }
            
            // Start the eternal song
            beginUniversalHarmony();
        }
        
        // Universal harmony generator
        function beginUniversalHarmony() {
            const now = ctx.currentTime;
            const hour = new Date().getHours();
            const dayPhase = (hour / 24) * Math.PI * 2;
            
            // Base frequency influenced by time
            const cosmic = 55 * Math.pow(2, Math.sin(dayPhase) * 0.5); // A1 with variation
            
            // Create Fibonacci-spaced harmonics
            FIB.slice(2, 8).forEach((fib, i) => {
                setTimeout(() => {
                    const freq = cosmic * (1 + fib / 100);
                    createVoice(freq, i);
                }, fib * 89); // Fibonacci timing
            });
            
            // Recursive generation
            setTimeout(beginUniversalHarmony, 13000);
        }
        
        // Voice creation with sacred geometry
        function createVoice(freq, index) {
            const id = `voice_${Date.now()}_${index}`;
            const voice = {};
            
            // Oscillator bank (3 detuned for richness)
            voice.oscs = [];
            for (let i = 0; i < 3; i++) {
                const osc = ctx.createOscillator();
                const gain = ctx.createGain();
                const filter = ctx.createBiquadFilter();
                
                osc.type = ['sine', 'triangle', 'sine'][i];
                osc.frequency.value = freq * (1 + (i - 1) * 0.0089); // Slight detune
                
                filter.type = 'lowpass';
                filter.frequency.value = freq * outfits[outfit].ratios[2];
                filter.Q.value = 3.14;
                
                gain.gain.setValueAtTime(0, ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.034 / (i + 1), ctx.currentTime + 1.618);
                gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 8);
                
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(master);
                
                osc.start();
                osc.stop(ctx.currentTime + 8);
                
                voice.oscs.push({ osc, gain, filter });
            }
            
            voices.set(id, voice);
            
            // Cleanup
            setTimeout(() => voices.delete(id), 8000);
        }
        
        // Motion handling
        function handleMotion(e) {
            if (e.accelerationIncludingGravity) {
                motion.x = e.accelerationIncludingGravity.x || 0;
                motion.y = e.accelerationIncludingGravity.y || 0;
                motion.z = e.accelerationIncludingGravity.z || 0;
                motion.total = Math.sqrt(motion.x**2 + motion.y**2 + motion.z**2);
                
                // Modulate active voices
                voices.forEach(voice => {
                    voice.oscs.forEach((osc, i) => {
                        const modAmount = motion.total / 20;
                        osc.gain.gain.linearRampToValueAtTime(
                            osc.gain.gain.value * (1 + modAmount),
                            ctx.currentTime + 0.089
                        );
                    });
                });
                
                // Create motion trace
                if (Math.random() < 0.08) {
                    createMotionTrace(lastTouch.x, lastTouch.y);
                }
            }
        }
        
        function handleOrientation(e) {
            if (e.alpha !== null) {
                // Use orientation for panning
                const pan = (e.gamma / 90);
                voices.forEach(voice => {
                    if (!voice.panner) {
                        voice.panner = ctx.createStereoPanner();
                        voice.oscs[0].gain.disconnect();
                        voice.oscs[0].gain.connect(voice.panner);
                        voice.panner.connect(master);
                    }
                    voice.panner.pan.linearRampToValueAtTime(pan, ctx.currentTime + 0.5);
                });
            }
        }
        
        // Recording setup
        function setupRecording(stream) {
            recorder = new MediaRecorder(stream);
            
            recorder.ondataavailable = e => chunks.push(e.data);
            
            recorder.onstop = async () => {
                const blob = new Blob(chunks, { type: 'audio/wav' });
                chunks = [];
                await processWorldSound(blob);
            };
        }
        
        // Process recorded world sounds
        async function processWorldSound(blob) {
            const buffer = await blob.arrayBuffer();
            const audioBuffer = await ctx.decodeAudioData(buffer);
            const data = audioBuffer.getChannelData(0);
            
            // Spectral analysis
            const spectral = analyzeSpectrum(data);
            const rhythm = extractRhythm(data);
            
            // Generate response based on world sound
            generateWorldResponse(spectral, rhythm);
        }
        
        // Advanced spectral analysis
        function analyzeSpectrum(data) {
            const fftSize = 2048;
            const hop = 512;
            const windows = Math.floor((data.length - fftSize) / hop);
            const spectral = [];
            
            for (let w = 0; w < windows; w++) {
                const segment = data.slice(w * hop, w * hop + fftSize);
                const spectrum = fft(segment);
                spectral.push(findPeaks(spectrum));
            }
            
            return spectral;
        }
        
        // Simple FFT placeholder (would use real FFT in production)
        function fft(data) {
            // Simplified - would use actual FFT
            const spectrum = new Float32Array(data.length / 2);
            for (let i = 0; i < spectrum.length; i++) {
                spectrum[i] = Math.abs(data[i * 2]);
            }
            return spectrum;
        }
        
        // Peak detection
        function findPeaks(spectrum) {
            const peaks = [];
            const threshold = Math.max(...spectrum) * 0.3;
            
            for (let i = 1; i < spectrum.length - 1; i++) {
                if (spectrum[i] > threshold && 
                    spectrum[i] > spectrum[i-1] && 
                    spectrum[i] > spectrum[i+1]) {
                    peaks.push({ bin: i, magnitude: spectrum[i] });
                }
            }
            
            return peaks.slice(0, 8); // Top 8 peaks
        }
        
        // Rhythm extraction
        function extractRhythm(data) {
            const envelope = new Float32Array(Math.floor(data.length / 441));
            
            // Simple envelope follower
            for (let i = 0; i < envelope.length; i++) {
                let sum = 0;
                for (let j = 0; j < 441; j++) {
                    sum += Math.abs(data[i * 441 + j]);
                }
                envelope[i] = sum / 441;
            }
            
            // Find onsets
            const onsets = [];
            for (let i = 1; i < envelope.length; i++) {
                if (envelope[i] > envelope[i-1] * 1.5 && envelope[i] > 0.1) {
                    onsets.push(i * 441 / ctx.sampleRate);
                }
            }
            
            return onsets;
        }
        
        // Generate response to world
        function generateWorldResponse(spectral, rhythm) {
            // Create rhythmic pattern from detected onsets
            rhythm.forEach((onset, i) => {
                setTimeout(() => {
                    // Percussive element
                    const noise = ctx.createBufferSource();
                    const noiseBuffer = ctx.createBuffer(1, 4410, ctx.sampleRate);
                    const data = noiseBuffer.getChannelData(0);
                    
                    for (let i = 0; i < 4410; i++) {
                        data[i] = (Math.random() - 0.5) * Math.exp(-i / 1000);
                    }
                    
                    noise.buffer = noiseBuffer;
                    
                    const filter = ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 200 + (i % 8) * 100;
                    filter.Q.value = 10;
                    
                    const gain = ctx.createGain();
                    gain.gain.setValueAtTime(0.13, ctx.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.1);
                    
                    noise.connect(filter);
                    filter.connect(gain);
                    gain.connect(master);
                    
                    noise.start();
                }, onset * 1000);
            });
            
            // Harmonic response from spectral peaks
            spectral.forEach((frame, frameIndex) => {
                setTimeout(() => {
                    frame.forEach((peak, peakIndex) => {
                        const freq = (peak.bin * ctx.sampleRate) / 2048;
                        const adjusted = quantizeToScale(freq);
                        
                        if (adjusted > 80 && adjusted < 2000) {
                            createResonance(adjusted, peak.magnitude);
                        }
                    });
                }, frameIndex * 100);
            });
        }
        
        // Quantize frequency to current outfit scale
        function quantizeToScale(freq) {
            const baseFreq = 110; // A2
            const ratios = outfits[outfit].ratios;
            
            // Find octave
            let octave = 0;
            let f = freq;
            while (f > baseFreq * 2) {
                f /= 2;
                octave++;
            }
            while (f < baseFreq) {
                f *= 2;
                octave--;
            }
            
            // Find closest ratio
            let closest = ratios[0];
            let minDiff = Math.abs(f - baseFreq * ratios[0]);
            
            for (const ratio of ratios) {
                const diff = Math.abs(f - baseFreq * ratio);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = ratio;
                }
            }
            
            return baseFreq * closest * Math.pow(2, octave);
        }
        
        // Create resonant response
        function createResonance(freq, magnitude) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            const filter = ctx.createBiquadFilter();
            
            osc.frequency.value = freq;
            osc.type = 'sine';
            
            filter.type = 'bandpass';
            filter.frequency.value = freq;
            filter.Q.value = 20;
            
            const amp = magnitude * 0.05;
            gain.gain.setValueAtTime(0, ctx.currentTime);
            gain.gain.linearRampToValueAtTime(amp, ctx.currentTime + 0.05);
            gain.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 2);
            
            osc.connect(filter);
            filter.connect(gain);
            gain.connect(master);
            
            osc.start();
            osc.stop(ctx.currentTime + 2);
        }
        
        // Motion trace visual
        function createMotionTrace(x, y) {
            const trace = document.createElement('div');
            trace.className = 'motion-trace';
            trace.style.left = x + 'px';
            trace.style.top = y + 'px';
            document.body.appendChild(trace);
            
            setTimeout(() => trace.remove(), 3000);
        }
        
        // Touch/click handling
        document.addEventListener('touchmove', e => {
            if (e.touches[0]) {
                lastTouch.x = e.touches[0].clientX;
                lastTouch.y = e.touches[0].clientY;
            }
        });
        
        document.addEventListener('mousemove', e => {
            lastTouch.x = e.clientX;
            lastTouch.y = e.clientY;
        });
        
        // Initialize on first interaction
        document.getElementById('initTouch').addEventListener('click', async () => {
            await initAudio();
            
            document.getElementById('initTouch').remove();
            document.getElementById('recordOrb').style.display = 'block';
            document.querySelector('.outfit-dots').style.display = 'block';
            
            // Simulate motion for desktop
            if (!window.DeviceMotionEvent || !window.mobile) {
                setInterval(() => {
                    const t = Date.now() * 0.001;
                    motion.x = Math.sin(t * 0.618) * 5;
                    motion.y = Math.cos(t * 0.377) * 5;
                    motion.z = Math.sin(t * 0.233) * 3;
                    motion.total = Math.sqrt(motion.x**2 + motion.y**2 + motion.z**2);
                    
                    // Trigger motion events
                    handleMotion({ accelerationIncludingGravity: motion });
                }, 89);
            }
        });
        
        // Record button
        document.getElementById('recordOrb').addEventListener('click', () => {
            if (!recording) {
                recorder.start();
                recording = true;
                document.getElementById('recordOrb').classList.add('active');
            } else {
                recorder.stop();
                recording = false;
                document.getElementById('recordOrb').classList.remove('active');
            }
        });
        
        // Outfit selection
        document.querySelectorAll('.dot').forEach((dot, i) => {
            dot.addEventListener('click', () => {
                document.querySelectorAll('.dot').forEach(d => d.classList.remove('active'));
                dot.classList.add('active');
                outfit = i;
                
                // Trigger harmonic shift
                const baseFreq = 110 * Math.pow(PHI, i);
                outfits[outfit].ratios.forEach((ratio, j) => {
                    setTimeout(() => {
                        createVoice(baseFreq * ratio, j);
                    }, FIB[j + 2] * 34);
                });
            });
        });
        
        // Eternal visual update
        function updateVisual() {
            if (!analyser) {
                requestAnimationFrame(updateVisual);
                return;
            }
            
            const data = new Uint8Array(analyser.frequencyBinCount);
            analyser.getByteFrequencyData(data);
            
            // Modulate canvas opacity based on overall energy
            const energy = data.reduce((a, b) => a + b, 0) / data.length;
            canvas.style.opacity = 0.03 + (energy / 255) * 0.05;
            
            requestAnimationFrame(updateVisual);
        }
        
        updateVisual();
    </script>
</body>
</html>
