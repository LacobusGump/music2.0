<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Spatial Motion AI Music</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, sans-serif;
      background: radial-gradient(circle at 30% 20%, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .app {
      width: 100%;
      max-width: 380px;
      padding: 24px;
      text-align: center;
    }
    
    .logo {
      font-size: clamp(3.5rem, 15vw, 7rem);
      font-weight: 900;
      background: linear-gradient(135deg, #00ffaa 0%, #ff6b6b 50%, #4ecdc4 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 8px;
      animation: pulse 3s ease-in-out infinite;
      text-shadow: 0 0 60px rgba(0,255,170,0.3);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1) rotate(0deg); }
      50% { transform: scale(1.08) rotate(1deg); }
    }
    
    .tagline {
      font-size: clamp(0.95rem, 4vw, 1.1rem);
      opacity: 0.85;
      margin-bottom: 40px;
      font-weight: 300;
      letter-spacing: 0.5px;
    }
    
    .start-btn {
      padding: 22px 48px;
      background: linear-gradient(135deg, #00ffaa 0%, #4ecdc4 100%);
      color: #000;
      border: none;
      border-radius: 50px;
      font-size: 1.25rem;
      font-weight: 800;
      cursor: pointer;
      transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
      box-shadow: 0 12px 35px rgba(0,255,170,0.35);
      margin-bottom: 32px;
      letter-spacing: 1px;
    }
    
    .start-btn:hover { 
      transform: translateY(-5px) scale(1.05);
      box-shadow: 0 20px 50px rgba(0,255,170,0.6);
    }
    
    .void {
      width: 100%;
      height: 280px;
      border: 2px solid rgba(0,255,170,0.15);
      border-radius: 30px;
      position: relative;
      overflow: hidden;
      background: 
        radial-gradient(circle at 20% 50%, rgba(0,255,170,0.04) 0%, transparent 50%),
        radial-gradient(circle at 80% 50%, rgba(78,205,196,0.04) 0%, transparent 50%);
      margin-bottom: 28px;
      backdrop-filter: blur(5px);
    }
    
    .orb {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #00ffaa 0%, rgba(0,255,170,0.3) 60%, transparent 100%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.08s cubic-bezier(0.23, 1, 0.32, 1);
      box-shadow: 
        0 0 40px rgba(0,255,170,0.6),
        inset 0 0 20px rgba(255,255,255,0.1);
      animation: orbFloat 4s ease-in-out infinite;
    }
    
    @keyframes orbFloat {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
    }
    
    .wave {
      position: absolute;
      width: 200px;
      height: 200px;
      border: 1px solid rgba(0,255,170,0.2);
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      animation: waveExpand 2s ease-out infinite;
    }
    
    @keyframes waveExpand {
      0% { transform: translate(-50%, -50%) scale(0.3); opacity: 0.8; }
      100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 16px;
      margin-bottom: 28px;
    }
    
    .stat {
      background: rgba(0,255,170,0.08);
      padding: 16px 12px;
      border-radius: 20px;
      border: 1px solid rgba(0,255,170,0.25);
      backdrop-filter: blur(15px);
      transition: all 0.3s ease;
    }
    
    .stat:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 25px rgba(0,255,170,0.15);
    }
    
    .stat-value {
      font-size: 1.4rem;
      font-weight: 800;
      color: #00ffaa;
      margin-bottom: 4px;
    }
    
    .stat-label {
      font-size: 0.75rem;
      opacity: 0.75;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .status {
      font-size: 1rem;
      color: #4ecdc4;
      opacity: 0.9;
      animation: breathe 2.5s ease-in-out infinite;
      font-weight: 500;
    }
    
    @keyframes breathe {
      0%, 100% { opacity: 0.9; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }
    
    .hidden { display: none !important; }
    
    .error {
      background: rgba(255,107,107,0.12);
      border: 1px solid rgba(255,107,107,0.4);
      border-radius: 20px;
      padding: 24px;
      color: #ff6b6b;
      margin-top: 24px;
      font-weight: 500;
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="logo">GUMP</div>
    <div class="tagline">Your Life, Soundtracked by AI</div>
    
    <button class="start-btn" id="start">ðŸŽµ Enter The Void</button>
    
    <div class="void hidden" id="void">
      <div class="orb" id="orb"></div>
      <div class="wave" id="wave"></div>
    </div>
    
    <div class="stats hidden" id="stats">
      <div class="stat">
        <div class="stat-value" id="motion">0</div>
        <div class="stat-label">Motion</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bpm">95</div>
        <div class="stat-label">BPM</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="mood">VOID</div>
        <div class="stat-label">Mood</div>
      </div>
    </div>
    
    <div class="status hidden" id="status">ðŸŒŒ Interpreting reality...</div>
    
    <div class="error hidden" id="error">
      Motion sensors unavailable. Please use a mobile device.
    </div>
  </div>

  <script>
    class VoidEngine {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 95;
        this.mood = 'VOID';
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.intensity = 0;
        this.harmonics = [];
        this.lastBeat = 0;
        
        // Musical DNA
        this.scales = {
          void: [261.63, 293.66, 329.63, 392.00, 440.00, 523.25],
          flow: [220, 246.94, 277.18, 329.63, 369.99, 415.30],
          storm: [174.61, 196.00, 220.00, 261.63, 293.66, 349.23]
        };
        
        this.rhythms = {
          void: [1,0,0,0,0,0,1,0,0,0,0,0,1,0,0,0],
          flow: [1,0,1,0,0,1,0,0,1,0,0,1,0,1,0,0],
          storm: [1,1,0,1,1,0,1,0,1,1,0,0,1,0,1,1]
        };
        
        this.init();
      }
      
      init() {
        document.getElementById('start').onclick = () => this.enter();
      }
      
      async enter() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') throw new Error('Permission denied');
          }
          
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          
          document.getElementById('start').classList.add('hidden');
          ['void', 'stats', 'status'].forEach(id => 
            document.getElementById(id).classList.remove('hidden')
          );
          
          this.active = true;
          this.startSensing();
          this.startVoid();
          this.animate();
          
        } catch (error) {
          this.error('Motion sensors unavailable. Please use a mobile device.');
        }
      }
      
      startSensing() {
        let lastTime = performance.now();
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const now = performance.now();
          const dt = (now - lastTime) / 1000;
          lastTime = now;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          
          // Calculate motion intensity
          const dx = acc.x - this.lastAccel.x;
          const dy = acc.y - this.lastAccel.y;
          const dz = acc.z - this.lastAccel.z;
          
          const jerk = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.motion = Math.min(100, jerk * 25);
          this.intensity = this.motion / 100;
          
          // Update spatial position with physics
          this.velocity.x += dx * dt * 10;
          this.velocity.y += dy * dt * 10;
          this.velocity.x *= 0.9; // Damping
          this.velocity.y *= 0.9;
          
          this.pos.x = Math.max(5, Math.min(95, this.pos.x + this.velocity.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y + this.velocity.y));
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
          
          // Interpret the world
          this.interpret();
          
        }, { passive: true });
      }
      
      interpret() {
        // Instant world-to-music interpretation
        if (this.intensity < 0.2) {
          this.mood = 'VOID';
          this.bpm = 75 + this.intensity * 30;
        } else if (this.intensity < 0.6) {
          this.mood = 'FLOW';
          this.bpm = 90 + this.intensity * 25;
        } else {
          this.mood = 'STORM';
          this.bpm = 110 + this.intensity * 20;
        }
        
        // Spatial harmonics based on position
        this.harmonics = [
          440 * (1 + (this.pos.x - 50) / 200),
          523.25 * (1 + (this.pos.y - 50) / 200),
          659.25 * (1 + this.intensity * 0.5)
        ];
        
        // Spontaneous musical events
        if (Math.random() < this.intensity * 0.3) {
          this.spatialBurst();
        }
      }
      
      startVoid() {
        const loop = () => {
          if (!this.active) return;
          
          const now = this.ctx.currentTime;
          const beatInterval = 60 / this.bpm;
          
          if (now - this.lastBeat >= beatInterval) {
            this.generateBeat();
            this.lastBeat = now;
            this.step = (this.step + 1) % 16;
          }
          
          requestAnimationFrame(loop);
        };
        
        loop();
      }
      
      generateBeat() {
        const rhythm = this.rhythms[this.mood.toLowerCase()];
        const scale = this.scales[this.mood.toLowerCase()];
        
        // Kick pattern
        if (rhythm[this.step] && Math.random() < 0.8 + this.intensity * 0.2) {
          this.kick();
        }
        
        // Snare on off-beats
        if (this.step % 4 === 2 && this.intensity > 0.2) {
          this.snare();
        }
        
        // Melodic elements
        if (Math.random() < this.intensity * 0.4) {
          const note = scale[Math.floor(Math.random() * scale.length)];
          this.tone(note * (0.5 + Math.random() * 0.5));
        }
        
        // Ambient void sounds
        if (this.mood === 'VOID' && Math.random() < 0.3) {
          this.voidWhisper();
        }
      }
      
      kick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);
        
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        
        gain.gain.setValueAtTime(0.7 + this.intensity * 0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        osc.connect(filter).connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
      }
      
      snare() {
        const noise = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
        const data = noise.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.1));
        }
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const panner = this.ctx.createStereoPanner();
        
        source.buffer = noise;
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + this.intensity * 500;
        panner.pan.value = (this.pos.x - 50) / 100;
        
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        source.connect(filter).connect(gain).connect(panner).connect(this.ctx.destination);
        source.start();
      }
      
      tone(freq) {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();
        
        osc.frequency.value = freq;
        osc.type = this.mood === 'VOID' ? 'sine' : this.mood === 'FLOW' ? 'triangle' : 'sawtooth';
        
        panner.pan.value = (this.pos.x - 50) / 100;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1 + this.intensity * 0.2, this.ctx.currentTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        osc.connect(gain).connect(panner).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }
      
      voidWhisper() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.frequency.value = 80 + Math.random() * 40;
        osc.type = 'sine';
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
        
        osc.connect(filter).connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 3);
      }
      
      spatialBurst() {
        this.harmonics.forEach((freq, i) => {
          setTimeout(() => {
            this.tone(freq * (0.8 + Math.random() * 0.4));
          }, i * 50);
        });
      }
      
      animate() {
        if (!this.active) return;
        
        const orb = document.getElementById('orb');
        const scale = 1 + this.intensity * 0.8;
        const glow = 0.4 + this.intensity * 0.6;
        
        orb.style.left = `${this.pos.x}%`;
        orb.style.top = `${this.pos.y}%`;
        orb.style.transform = `translate(-50%, -50%) scale(${scale})`;
        orb.style.boxShadow = `
          0 0 ${40 + this.intensity * 60}px rgba(0,255,170,${glow}),
          inset 0 0 20px rgba(255,255,255,0.1)
        `;
        
        // Update stats
        document.getElementById('motion').textContent = Math.round(this.motion);
        document.getElementById('bpm').textContent = Math.round(this.bpm);
        document.getElementById('mood').textContent = this.mood;
        
        requestAnimationFrame(() => this.animate());
      }
      
      error(message) {
        document.getElementById('start').classList.add('hidden');
        const error = document.getElementById('error');
        error.textContent = message;
        error.classList.remove('hidden');
      }
    }
    
    // Initialize the void
    new VoidEngine();
  </script>
</body>
</html>
