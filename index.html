<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>NEUROMANCER - Environmental Music AI</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  user-select: none;
  overscroll-behavior: none;
}
:root {
  --quantum-blue: #00ffff;
  --neural-purple: #ff00ff;
  --plasma-green: #00ff00;
  --void-black: #000000;
  --ghost-white: rgba(255,255,255,0.03);
  --electric-red: #ff0040;
  --gold: #ffd700;
  --safe-area-top: env(safe-area-inset-top);
  --safe-area-bottom: env(safe-area-inset-bottom);
}
body {
  background: var(--void-black);
  color: #fff;
  overflow: hidden;
  height: 100vh;
  height: 100dvh;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  position: fixed;
  width: 100%;
  touch-action: none;
}
/* Quantum Field Background */
#quantumField {
  position: fixed;
  inset: 0;
  pointer-events: none;
  transition: all 3s cubic-bezier(0.4, 0, 0.2, 1);
}
.quantum-layer {
  position: absolute;
  inset: 0;
  opacity: 0.3;
}
.quantum-layer:nth-child(1) {
  background: radial-gradient(ellipse at 25% 25%,
    rgba(0, 255, 255, 0.1) 0%,
    transparent 50%);
  animation: rotate-slow 30s linear infinite;
}
.quantum-layer:nth-child(2) {
  background: radial-gradient(ellipse at 75% 75%,
    rgba(255, 0, 255, 0.08) 0%,
    transparent 50%);
  animation: rotate-slow 40s linear infinite reverse;
}
.quantum-layer:nth-child(3) {
  background: radial-gradient(circle at center,
    transparent 0%,
    rgba(0, 255, 0, 0.03) 40%,
    transparent 70%);
  animation: pulse-slow 8s ease-in-out infinite;
}
@keyframes rotate-slow {
  to { transform: rotate(360deg); }
}
@keyframes pulse-slow {
  0%, 100% { transform: scale(1); opacity: 0.3; }
  50% { transform: scale(1.2); opacity: 0.6; }
}
/* Neural Particle System */
#particleCanvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.8;
}
/* 3D Spatial Visualizer */
#spatialCanvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.7;
  mix-blend-mode: screen;
}
/* Waveform Display */
#waveformCanvas {
  position: fixed;
  top: calc(var(--safe-area-top) + 80px);
  left: 10px;
  right: 10px;
  height: 60px;
  pointer-events: none;
  opacity: 0.6;
  filter: drop-shadow(0 0 10px var(--quantum-blue));
}
/* HUD Elements */
.hud-top {
  position: fixed;
  top: var(--safe-area-top);
  left: 0;
  right: 0;
  padding: 15px;
  background: linear-gradient(to bottom,
    rgba(0, 0, 0, 0.8),
    transparent);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  z-index: 100;
}
.state-display {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.current-state {
  font-size: 18px;
  letter-spacing: 4px;
  font-weight: 100;
  color: var(--quantum-blue);
  text-shadow: 0 0 20px currentColor;
}
.state-subtitle {
  font-size: 9px;
  opacity: 0.5;
  letter-spacing: 2px;
}
.metrics-display {
  display: flex;
  flex-direction: column;
  gap: 3px;
  text-align: right;
  font-size: 9px;
  font-family: monospace;
  opacity: 0.6;
}
.metric {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}
.metric-value {
  color: var(--plasma-green);
  min-width: 40px;
}
/* Motion & Energy Meters */
.energy-container {
  position: fixed;
  left: 15px;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 200px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 2px;
  overflow: hidden;
}
.energy-bar {
  position: absolute;
  bottom: 0;
  width: 100%;
  background: linear-gradient(to top,
    var(--plasma-green),
    var(--quantum-blue),
    var(--neural-purple));
  transition: height 0.2s ease;
  box-shadow: 0 0 20px currentColor;
}
.motion-orb {
  position: fixed;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center,
    rgba(0, 255, 255, 0.1),
    transparent);
}
.motion-core {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--quantum-blue);
  transition: all 0.1s ease;
  box-shadow: 0 0 20px currentColor;
}
/* Sample Matrix */
.sample-matrix {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 20px;
  padding: 20px;
}
.sample-node {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  transition: all 0.3s ease;
  cursor: pointer;
  background: radial-gradient(circle at 30% 30%,
    rgba(0, 0, 0, 0.5),
    rgba(0, 0, 0, 0.8));
}
.sample-node.recording {
  animation: record-pulse 1s ease-in-out infinite;
  border-color: var(--electric-red);
  background: radial-gradient(circle at center,
    rgba(255, 0, 64, 0.2),
    transparent);
}
.sample-node.loaded {
  border-color: var(--plasma-green);
  background: radial-gradient(circle at center,
    rgba(0, 255, 0, 0.1),
    transparent);
}
.sample-node.playing {
  animation: play-burst 0.3s ease;
  border-color: var(--quantum-blue);
  box-shadow: 0 0 30px var(--quantum-blue),
         inset 0 0 20px var(--quantum-blue);
}
.sample-node.processing {
  animation: process-spin 1s linear infinite;
  border-color: var(--gold);
}
@keyframes record-pulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 var(--electric-red); }
  50% { transform: scale(1.1); box-shadow: 0 0 20px 5px var(--electric-red); }
}
@keyframes play-burst {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}
@keyframes process-spin {
  to { transform: rotate(360deg); }
}
.sample-visual {
  position: absolute;
  inset: 5px;
  border-radius: 50%;
  overflow: hidden;
}
.sample-canvas {
  width: 100%;
  height: 100%;
}
.sample-number {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px;
  opacity: 0.3;
  pointer-events: none;
}
/* Neural Network Visualization */
.neural-network {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 120px);
  left: 50%;
  transform: translateX(-50%);
  width: 250px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.4;
  pointer-events: none;
}
.neural-node {
  width: 8px;
  height: 8px;
  background: var(--quantum-blue);
  border-radius: 50%;
  position: absolute;
  opacity: 0.3;
}
.neural-connection {
  position: absolute;
  height: 1px;
  background: linear-gradient(90deg,
    transparent,
    var(--quantum-blue),
    transparent);
  transform-origin: left center;
  opacity: 0.2;
}
/* Journey Timeline */
.journey-container {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 100px);
  left: 30px;
  right: 30px;
}
.journey-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
  font-size: 9px;
  opacity: 0.5;
}
.journey-timeline {
  height: 3px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}
.journey-progress {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg,
    var(--plasma-green),
    var(--quantum-blue),
    var(--neural-purple),
    var(--electric-red));
  transition: width 1s linear;
  box-shadow: 0 0 10px currentColor;
}
.journey-markers {
  position: absolute;
  inset: 0;
  display: flex;
}
.journey-marker {
  flex: 1;
  border-right: 1px solid rgba(255, 255, 255, 0.2);
}
/* Control Panel */
.control-panel {
  position: fixed;
  bottom: var(--safe-area-bottom);
  left: 0;
  right: 0;
  height: 90px;
  background: linear-gradient(to top,
    rgba(0, 0, 0, 0.9),
    rgba(0, 0, 0, 0.5),
    transparent);
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 20px;
  z-index: 100;
}
.control-group {
  display: flex;
  gap: 15px;
}
.control-btn {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
}
.control-btn.active {
  border-color: var(--quantum-blue);
  background: rgba(0, 255, 255, 0.1);
  box-shadow: 0 0 20px var(--quantum-blue),
         inset 0 0 10px var(--quantum-blue);
}
.control-btn.main {
  width: 60px;
  height: 60px;
  border-width: 2px;
  font-size: 10px;
}
.control-btn.recording {
  animation: record-glow 1s ease-in-out infinite;
  border-color: var(--electric-red);
  background: rgba(255, 0, 64, 0.2);
}
@keyframes record-glow {
  0%, 100% { box-shadow: 0 0 10px var(--electric-red); }
  50% { box-shadow: 0 0 30px var(--electric-red), 0 0 50px var(--electric-red); }
}
/* Effect Indicators */
.effects-row {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 95px);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
}
.effect-indicator {
  width: 30px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  transition: all 0.3s ease;
}
.effect-indicator.active {
  background: var(--quantum-blue);
  box-shadow: 0 0 10px var(--quantum-blue);
}
/* Permission Overlay */
.permission-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center,
    rgba(0, 0, 0, 0.95),
    var(--void-black));
  z-index: 10000;
  gap: 30px;
  padding: 40px;
  text-align: center;
  transition: opacity 0.5s ease;
}
.permission-overlay.hidden {
  opacity: 0;
  pointer-events: none;
}
.logo-container {
  position: relative;
  width: 150px;
  height: 150px;
}
.logo-ring {
  position: absolute;
  inset: 0;
  border: 1px solid var(--quantum-blue);
  border-radius: 50%;
  opacity: 0.3;
  animation: expand-ring 3s ease-in-out infinite;
}
.logo-ring:nth-child(2) {
  animation-delay: 1s;
}
.logo-ring:nth-child(3) {
  animation-delay: 2s;
}
@keyframes expand-ring {
  0% { transform: scale(0.8); opacity: 0; }
  50% { opacity: 0.5; }
  100% { transform: scale(1.5); opacity: 0; }
}
.logo-core {
  position: absolute;
  inset: 30%;
  background: radial-gradient(circle at center,
    var(--quantum-blue),
    transparent);
  border-radius: 50%;
  animation: pulse-core 2s ease-in-out infinite;
}
@keyframes pulse-core {
  0%, 100% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
}
.permission-title {
  font-size: 24px;
  letter-spacing: 8px;
  font-weight: 100;
  color: var(--quantum-blue);
  margin-left: 8px;
}
.permission-subtitle {
  font-size: 10px;
  letter-spacing: 3px;
  opacity: 0.5;
  margin-top: -20px;
}
.permission-text {
  font-size: 12px;
  line-height: 1.8;
  opacity: 0.7;
  max-width: 280px;
}
.permission-btn {
  padding: 15px 40px;
  border: 1px solid var(--quantum-blue);
  background: transparent;
  color: var(--quantum-blue);
  border-radius: 30px;
  font-size: 11px;
  letter-spacing: 3px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}
.permission-btn:before {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center,
    var(--quantum-blue),
    transparent);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.permission-btn:hover:before {
  opacity: 0.1;
}
.permission-btn:active {
  transform: scale(0.98);
}
/* Loading State */
.loading-dna {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;
  z-index: 10001;
}
.loading-dna.active {
  display: block;
}
.dna-helix {
  width: 100px;
  height: 200px;
  position: relative;
}
.dna-strand {
  position: absolute;
  width: 100%;
  height: 100%;
}
.dna-dot {
  position: absolute;
  width: 8px;
  height: 8px;
  background: var(--quantum-blue);
  border-radius: 50%;
  box-shadow: 0 0 10px currentColor;
}
/* Notification System */
.notification {
  position: fixed;
  top: calc(var(--safe-area-top) + 150px);
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 20px;
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--quantum-blue);
  border-radius: 20px;
  font-size: 11px;
  letter-spacing: 2px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease, transform 0.3s ease;
  z-index: 1000;
  text-align: center;
  backdrop-filter: blur(10px);
}
.notification.visible {
  opacity: 0.9;
  transform: translateX(-50%) translateY(20px);
}
/* Touch Ripples */
.touch-ripple {
  position: fixed;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid var(--quantum-blue);
  pointer-events: none;
  animation: ripple-out 0.6s ease-out forwards;
  z-index: 9999;
  transform: translate(-50%, -50%);
}
@keyframes ripple-out {
  to {
    transform: translate(-50%, -50%) scale(2.5);
    opacity: 0;
  }
}
/* Responsive adjustments */
@media (max-height: 600px) {
  .sample-matrix { gap: 15px; }
  .sample-node { width: 50px; height: 50px; }
  .control-panel { height: 70px; }
  .control-btn { width: 40px; height: 40px; }
  .control-btn.main { width: 50px; height: 50px; }
}
@media (min-width: 768px) {
  .sample-matrix { gap: 30px; }
  .sample-node { width: 80px; height: 80px; }
}
/* Debug Panel */
.debug-panel {
  position: fixed;
  top: calc(var(--safe-area-top) + 10px);
  right: 10px;
  background: rgba(0, 0, 0, 0.8);
  padding: 10px;
  border-radius: 5px;
  font-family: monospace;
  font-size: 8px;
  display: none;
  z-index: 10000;
  color: white;
  opacity: 0.7;
}
.debug-panel.visible {
  display: block;
}
</style>
</head>
<body>

<div id="quantumField">
  <div class="quantum-layer"></div>
  <div class="quantum-layer"></div>
  <div class="quantum-layer"></div>
</div>
<canvas id="particleCanvas"></canvas>
<canvas id="spatialCanvas"></canvas>
<canvas id="waveformCanvas"></canvas>

<div class="hud-top">
  <div class="state-display">
    <div class="current-state" id="currentState">VOID</div>
    <div class="state-subtitle" id="stateSubtitle">awaiting input</div>
  </div>
  <div class="metrics-display">
    <div class="metric">
      <span>BPM</span>
      <span class="metric-value" id="bpmValue">120</span>
    </div>
    <div class="metric">
      <span>ENERGY</span>
      <span class="metric-value" id="energyValue">0.00</span>
    </div>
    <div class="metric">
      <span>SAMPLES</span>
      <span class="metric-value" id="samplesValue">0/9</span>
    </div>
  </div>
</div>

<div class="energy-container">
  <div class="energy-bar" id="energyBar"></div>
</div>

<div class="motion-orb">
  <div class="motion-core" id="motionCore"></div>
</div>

<div class="sample-matrix" id="sampleMatrix">
  </div>

<div class="neural-network" id="neuralNetwork"></div>

<div class="journey-container">
  <div class="journey-info">
    <span id="journeyTime">00:00</span>
    <span id="journeyPhase">INTRODUCTION</span>
    <span>25:00</span>
  </div>
  <div class="journey-timeline">
    <div class="journey-progress" id="journeyProgress"></div>
    <div class="journey-markers">
      <div class="journey-marker"></div><div class="journey-marker"></div><div class="journey-marker"></div><div class="journey-marker"></div><div class="journey-marker"></div>
    </div>
  </div>
</div>

<div class="effects-row">
  <div class="effect-indicator" id="fxReverb"></div>
  <div class="effect-indicator" id="fxDelay"></div>
  <div class="effect-indicator" id="fxFilter"></div>
  <div class="effect-indicator" id="fxGrain"></div>
  <div class="effect-indicator" id="fxPitch"></div>
</div>

<div class="control-panel">
  <div class="control-group">
    <div class="control-btn" id="btnTap">TAP</div>
    <div class="control-btn" id="btnLoop">LOOP</div>
  </div>
  <div class="control-btn main" id="btnRecord">REC</div>
  <div class="control-group">
    <div class="control-btn active" id="btnAI">AI</div>
    <div class="control-btn" id="btnFX">FX</div>
  </div>
</div>

<div class="notification" id="notification"></div>

<div class="permission-overlay" id="permissionOverlay">
  <div class="logo-container">
    <div class="logo-ring"></div><div class="logo-ring"></div><div class="logo-ring"></div>
    <div class="logo-core"></div>
  </div>
  <div>
    <div class="permission-title">NEUROMANCER</div>
    <div class="permission-subtitle">ENVIRONMENTAL MUSIC AI</div>
  </div>
  <div class="permission-text">
    Your movement and environment will shape a unique 25-minute musical journey. This experience uses your microphone and motion sensors to create real-time adaptive music.
  </div>
  <button class="permission-btn" id="startBtn">BEGIN JOURNEY</button>
</div>

<div class="debug-panel" id="debugPanel">
  <div>Motion: <span id="debugMotion">0.00</span></div>
  <div>Accel: <span id="debugAccel">0,0,0</span></div>
  <div>Energy: <span id="debugEnergy">0.00</span></div>
  <div>State: <span id="debugState">init</span></div>
  <div>Beat: <span id="debugBeat">0.0</span></div>
</div>

<script>
'use strict';

// --- Main App Class ---
class NeuromancerEngine {
  constructor() {
    this.config = {
      sampleRate: 48000,
      baseBPM: 120,
      sampleDuration: 2000, // 2 seconds
      maxSamples: 9,
      journeyDuration: 25 * 60 * 1000, // 25 minutes
      fftSize: 1024,
      scheduleAheadTime: 0.1,
      motionSmoothingFactor: 0.95,
      motionThreshold: 0.1,
    };
    
    this.state = {
      isInitialized: false,
      currentState: 'void',
      journeyStartTime: null,
      motionLevel: 0,
      energy: 0,
      bpm: this.config.baseBPM,
      beatDuration: 60 / this.config.baseBPM,
      nextNoteTime: 0,
      samples: new Map(),
      isRecording: false,
      aiDjActive: true,
      loopMode: false,
      activeFx: 'reverb',
      lastAccel: { x: 0, y: 0, z: 0, t: Date.now() },
    };
    
    this.audio = {};
    this.ui = {};
    this.visuals = {};
    this.tapTempo = { taps: [], lastTap: 0 };

    this.init();
  }

  init() {
    this.setupDOM();
    this.setupEventListeners();
    this.visuals = new VisualsManager(this.ui, this.state);
    
    // Debug toggle
    let pressCount = 0;
    document.addEventListener('click', (e) => {
        if (e.target.id === 'currentState') {
            pressCount++;
            if (pressCount > 5) {
                this.ui.debug.panel.classList.toggle('visible');
                pressCount = 0;
            }
        } else {
            pressCount = 0;
        }
    });
  }

  setupDOM() {
    this.ui = {
      permissionOverlay: document.getElementById('permissionOverlay'),
      notification: document.getElementById('notification'),
      currentState: document.getElementById('currentState'),
      stateSubtitle: document.getElementById('stateSubtitle'),
      bpmValue: document.getElementById('bpmValue'),
      energyValue: document.getElementById('energyValue'),
      samplesValue: document.getElementById('samplesValue'),
      energyBar: document.getElementById('energyBar'),
      motionCore: document.getElementById('motionCore'),
      sampleMatrix: document.getElementById('sampleMatrix'),
      journeyProgress: document.getElementById('journeyProgress'),
      journeyTime: document.getElementById('journeyTime'),
      journeyPhase: document.getElementById('journeyPhase'),
      btnRecord: document.getElementById('btnRecord'),
      btnTap: document.getElementById('btnTap'),
      btnLoop: document.getElementById('btnLoop'),
      btnAI: document.getElementById('btnAI'),
      btnFX: document.getElementById('btnFX'),
      fxIndicators: {
        reverb: document.getElementById('fxReverb'),
        delay: document.getElementById('fxDelay'),
        filter: document.getElementById('fxFilter'),
        grain: document.getElementById('fxGrain'),
        pitch: document.getElementById('fxPitch'),
      },
      debug: {
        panel: document.getElementById('debugPanel'),
        motion: document.getElementById('debugMotion'),
        accel: document.getElementById('debugAccel'),
        energy: document.getElementById('debugEnergy'),
        state: document.getElementById('debugState'),
        beat: document.getElementById('debugBeat'),
      },
    };

    // Generate sample nodes
    for (let i = 0; i < this.config.maxSamples; i++) {
        const node = document.createElement('div');
        node.className = 'sample-node';
        node.dataset.slot = i;
        node.innerHTML = `<div class="sample-visual"><canvas class="sample-canvas"></canvas></div><span class="sample-number">${i+1}</span>`;
        this.ui.sampleMatrix.appendChild(node);
    }
    this.ui.sampleNodes = document.querySelectorAll('.sample-node');
  }

  setupEventListeners() {
    document.getElementById('startBtn').addEventListener('click', () => this.requestPermissions());
    this.ui.btnRecord.addEventListener('click', () => this.handleRecordButton());
    this.ui.btnTap.addEventListener('click', () => this.handleTapTempo());
    this.ui.btnLoop.addEventListener('click', () => this.toggleLoopMode());
    this.ui.btnAI.addEventListener('click', () => this.toggleAIDJ());
    this.ui.btnFX.addEventListener('click', () => this.cycleEffects());
    
    this.ui.sampleNodes.forEach(node => {
      node.addEventListener('click', (e) => {
        this.handleSampleTouch(parseInt(node.dataset.slot));
        this.createTouchRipple(e);
      });
    });

    document.body.addEventListener('click', (e) => {
        if (!e.target.closest('.control-btn, .sample-node, .permission-btn')) {
            this.createTouchRipple(e);
        }
    });
  }

  async requestPermissions() {
    if (this.state.isInitialized) return;
    this.showNotification('INITIALIZING SYSTEM...');
    
    try {
      // Audio Permissions
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      
      // Motion Permissions (for iOS 13+)
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const permission = await DeviceMotionEvent.requestPermission();
        if (permission !== 'granted') {
          throw new Error('Motion permission not granted.');
        }
      }
      
      this.initAudioSystem(stream);
      this.setupMotionDetection();
      this.startJourney();

    } catch (err) {
      console.error("Permission Error:", err);
      this.showNotification('ERROR: PERMISSIONS REQUIRED', 5000, true);
    }
  }

  async initAudioSystem(stream) {
    this.audio.context = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: this.config.sampleRate });
    await this.audio.context.resume();

    // Create the recorder worklet
    const recorderWorkletCode = `
      class RecorderProcessor extends AudioWorkletProcessor {
        constructor() {
          super();
          this.buffer = [];
          this.maxSize = ${this.config.sampleRate * (this.config.sampleDuration / 1000)};
          this.isRecording = false;
          this.port.onmessage = (event) => {
              if (event.data.command === 'start') {
                  this.isRecording = true;
              }
              if (event.data.command === 'stop') {
                  this.isRecording = false;
                  this.port.postMessage({ buffer: this.buffer.slice(0) });
                  this.buffer = [];
              }
          };
        }

        process(inputs, outputs, parameters) {
          if (this.isRecording) {
            const input = inputs[0][0];
            if (this.buffer.length < this.maxSize) {
                this.buffer.push(...input);
            } else {
                this.isRecording = false; // Auto-stop
                this.port.postMessage({ buffer: this.buffer.slice(0) });
                this.buffer = [];
            }
          }
          return true;
        }
      }
      registerProcessor('recorder-processor', RecorderProcessor);
    `;
    const blob = new Blob([recorderWorkletCode], { type: 'application/javascript' });
    const workletURL = URL.createObjectURL(blob);
    await this.audio.context.audioWorklet.addModule(workletURL);
    
    this.audio.recorderNode = new AudioWorkletNode(this.audio.context, 'recorder-processor');
    this.audio.recorderNode.port.onmessage = (e) => this.processSample(e.data.buffer);
    
    this.audio.micInput = this.audio.context.createMediaStreamSource(stream);
    this.audio.analyser = this.audio.context.createAnalyser();
    this.audio.analyser.fftSize = this.config.fftSize;
    this.audio.masterGain = this.audio.context.createGain();
    this.audio.masterGain.gain.value = 0.8;
    
    // FX Nodes
    this.audio.fx = {};
    this.audio.fx.reverb = this.audio.context.createConvolver();
    this.audio.fx.reverb.buffer = this.createImpulseResponse();
    this.audio.fx.delay = this.audio.context.createDelay(5.0);
    this.audio.fx.delayFeedback = this.audio.context.createGain();
    this.audio.fx.delayFeedback.gain.value = 0.5;
    this.audio.fx.filter = this.audio.context.createBiquadFilter();
    this.audio.fx.filter.type = 'lowpass';
    this.audio.fx.filter.frequency.value = 5000;
    this.audio.fx.sendGain = this.audio.context.createGain();
    this.audio.fx.sendGain.gain.value = 0.3;

    // Connections
    this.audio.micInput.connect(this.audio.recorderNode);
    this.audio.masterGain.connect(this.audio.fx.sendGain);
    this.audio.masterGain.connect(this.audio.context.destination);
    
    // FX Chain
    this.audio.fx.sendGain.connect(this.audio.fx.reverb);
    this.audio.fx.reverb.connect(this.audio.context.destination);
    
    this.audio.fx.sendGain.connect(this.audio.fx.delay);
    this.audio.fx.delay.connect(this.audio.fx.delayFeedback);
    this.audio.fx.delayFeedback.connect(this.audio.fx.delay);
    this.audio.fx.delay.connect(this.audio.context.destination);
  }

  setupMotionDetection() {
    window.addEventListener('devicemotion', (e) => {
        if (!this.state.lastAccel.x) { // First event
            this.state.lastAccel = { x: e.acceleration.x, y: e.acceleration.y, z: e.acceleration.z, t: Date.now() };
            return;
        }

        const now = Date.now();
        const dt = (now - this.state.lastAccel.t) / 1000;
        const dx = e.acceleration.x - this.state.lastAccel.x;
        const dy = e.acceleration.y - this.state.lastAccel.y;
        const dz = e.acceleration.z - this.state.lastAccel.z;

        const jerk = Math.sqrt(dx*dx + dy*dy + dz*dz) / dt;
        const normalizedJerk = Math.min(jerk / 500, 1.0); // Normalize based on empirical max
        
        this.state.motionLevel = (this.state.motionLevel * this.config.motionSmoothingFactor) + (normalizedJerk * (1 - this.config.motionSmoothingFactor));
        this.state.lastAccel = { x: e.acceleration.x, y: e.acceleration.y, z: e.acceleration.z, t: now };

        this.ui.debug.accel.textContent = `${e.acceleration.x.toFixed(1)},${e.acceleration.y.toFixed(1)},${e.acceleration.z.toFixed(1)}`;
    });
  }

  startJourney() {
    this.state.isInitialized = true;
    this.state.journeyStartTime = this.audio.context.currentTime;
    
    this.ui.permissionOverlay.classList.add('hidden');
    this.showNotification('JOURNEY BEGUN', 2000);
    this.updateState('calm');

    this.scheduler();
    requestAnimationFrame(() => this.mainLoop());
  }

  mainLoop() {
    const elapsed = (this.audio.context.currentTime - this.state.journeyStartTime) * 1000;
    
    while (this.state.nextNoteTime < this.audio.context.currentTime + this.config.scheduleAheadTime) {
      if (this.state.aiDjActive) {
        this.aiScheduler(this.state.nextNoteTime);
      }
      this.state.nextNoteTime += this.state.beatDuration;
    }

    this.updateJourney(elapsed);
    this.updateEnergy();
    this.updateUI();
    this.visuals.render(this.audio.analyser);
    
    requestAnimationFrame(() => this.mainLoop());
  }

  scheduler() {
      // Metronome-like scheduler
  }

  updateState(newState = null) {
    if (newState) {
        this.state.currentState = newState;
    } else {
        // Dynamic state changes based on energy
        if (this.state.energy > 0.8) this.state.currentState = 'peak';
        else if (this.state.energy > 0.5) this.state.currentState = 'building';
        else if (this.state.energy > 0.1) this.state.currentState = 'calm';
        else this.state.currentState = 'void';
    }
  }

  updateEnergy() {
      const motionEnergy = this.state.motionLevel * 0.7;
      const sampleEnergy = (this.state.samples.size / this.config.maxSamples) * 0.3;
      const combinedEnergy = Math.min(motionEnergy + sampleEnergy, 1.0);
      
      // Smooth energy change
      this.state.energy = this.state.energy * 0.98 + combinedEnergy * 0.02;
      this.updateState(); // Update state based on new energy
  }

  updateJourney(elapsed) {
      const progress = Math.min(elapsed / this.config.journeyDuration, 1.0);
      
      // Update Journey Phases
      const phases = ['INTRO', 'DEVELOPMENT', 'CLIMAX', 'RESOLUTION', 'FADE OUT'];
      const phaseIndex = Math.floor(progress * phases.length);
      this.ui.journeyPhase.textContent = phases[phaseIndex];
      this.ui.journeyProgress.style.width = `${progress * 100}%`;

      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      this.ui.journeyTime.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
  }
  
  updateUI() {
    this.ui.currentState.textContent = this.state.currentState.toUpperCase();
    this.ui.stateSubtitle.textContent = this.state.isRecording ? 'RECORDING' : `ENERGY: ${this.state.energy.toFixed(2)}`;
    this.ui.bpmValue.textContent = Math.round(this.state.bpm);
    this.ui.energyValue.textContent = this.state.energy.toFixed(2);
    this.ui.samplesValue.textContent = `${this.state.samples.size}/${this.config.maxSamples}`;
    this.ui.energyBar.style.height = `${this.state.energy * 100}%`;
    this.ui.motionCore.style.transform = `scale(${1 + this.state.motionLevel * 2})`;
    this.ui.motionCore.style.opacity = 0.5 + this.state.motionLevel * 0.5;
    this.ui.btnAI.classList.toggle('active', this.state.aiDjActive);
    this.ui.btnLoop.classList.toggle('active', this.state.loopMode);

    // Update FX indicators
    for (const fx in this.ui.fxIndicators) {
        this.ui.fxIndicators[fx].classList.toggle('active', this.state.activeFx === fx);
    }

    // Debug Panel Update
    this.ui.debug.motion.textContent = this.state.motionLevel.toFixed(2);
    this.ui.debug.energy.textContent = this.state.energy.toFixed(2);
    this.ui.debug.state.textContent = this.state.currentState;
    const beatProgress = ((this.audio.context.currentTime - this.state.journeyStartTime) % this.state.beatDuration) / this.state.beatDuration;
    this.ui.debug.beat.textContent = beatProgress.toFixed(2);
  }

  handleRecordButton() {
    if (this.state.isRecording) return;
    
    if (this.state.samples.size >= this.config.maxSamples) {
        this.showNotification("SAMPLE SLOTS FULL", 2000, true);
        return;
    }
    
    this.state.isRecording = true;
    this.currentRecordingSlot = this.findNextSampleSlot();
    this.ui.sampleNodes[this.currentRecordingSlot].classList.add('recording');
    this.ui.btnRecord.classList.add('recording');
    
    this.audio.recorderNode.port.postMessage({ command: 'start' });

    setTimeout(() => {
        if (this.state.isRecording) {
            this.audio.recorderNode.port.postMessage({ command: 'stop' });
            this.state.isRecording = false;
            this.ui.sampleNodes[this.currentRecordingSlot].classList.remove('recording');
            this.ui.btnRecord.classList.remove('recording');
        }
    }, this.config.sampleDuration);
  }
  
  findNextSampleSlot() {
      for (let i = 0; i < this.config.maxSamples; i++) {
          if (!this.state.samples.has(i)) return i;
      }
      return 0; // Fallback
  }

  processSample(rawBuffer) {
    const audioBuffer = this.audio.context.createBuffer(1, rawBuffer.length, this.audio.context.sampleRate);
    audioBuffer.copyToChannel(new Float32Array(rawBuffer), 0);
    
    const slot = this.currentRecordingSlot;
    const sample = {
        buffer: audioBuffer,
        analysis: this.analyzeSample(audioBuffer),
        playCount: 0,
    };
    this.state.samples.set(slot, sample);
    
    this.ui.sampleNodes[slot].classList.add('loaded');
    this.visuals.drawSampleWaveform(slot, audioBuffer);
    this.showNotification(`SAMPLE ${slot + 1} CAPTURED`, 1500);
  }
  
  analyzeSample(buffer) {
      // A simple analysis for now
      const data = buffer.getChannelData(0);
      let rms = 0;
      for (let i = 0; i < data.length; i++) {
          rms += data[i] * data[i];
      }
      rms = Math.sqrt(rms / data.length);
      return { loudness: rms };
  }

  handleSampleTouch(slot) {
    if (this.state.samples.has(slot)) {
        this.playSample(slot, this.audio.context.currentTime);
    } else {
        this.handleRecordButton(); // If slot is empty, trigger recording
    }
  }

  playSample(slot, time, playbackRate = 1.0, gain = 1.0) {
    if (!this.state.samples.has(slot)) return;

    const source = this.audio.context.createBufferSource();
    source.buffer = this.state.samples.get(slot).buffer;
    source.playbackRate.value = playbackRate;
    
    const gainNode = this.audio.context.createGain();
    gainNode.gain.value = gain;

    source.connect(gainNode).connect(this.audio.masterGain);
    source.start(time);

    this.ui.sampleNodes[slot].classList.add('playing');
    setTimeout(() => this.ui.sampleNodes[slot].classList.remove('playing'), 200);
  }

  aiScheduler(time) {
      const beatPattern = Math.floor(((time - this.state.journeyStartTime) / this.state.beatDuration)) % 16; // 4 bars

      if (this.state.samples.size === 0) return;

      const availableSamples = Array.from(this.state.samples.keys());

      // Simple logic based on state
      let playChance = 0.1;
      if (this.state.currentState === 'calm') playChance = 0.2;
      if (this.state.currentState === 'building') playChance = 0.5;
      if (this.state.currentState === 'peak') playChance = 0.8;
      
      if (beatPattern % 4 === 0 && Math.random() < playChance) { // On the downbeat
          const randomSlot = availableSamples[Math.floor(Math.random() * availableSamples.length)];
          this.playSample(randomSlot, time);
      } else if (Math.random() < playChance / 4) { // Off-beats
          const randomSlot = availableSamples[Math.floor(Math.random() * availableSamples.length)];
          const rate = this.state.loopMode ? (Math.random() > 0.5 ? 2.0 : 0.5) : 1.0;
          this.playSample(randomSlot, time, rate, 0.5);
      }
  }

  handleTapTempo() {
      const now = this.audio.context.currentTime;
      if (this.tapTempo.lastTap) {
          const interval = now - this.tapTempo.lastTap;
          if (interval < 2.0) { // Max 2 seconds between taps
              this.tapTempo.taps.push(interval);
              if (this.tapTempo.taps.length > 3) {
                  this.tapTempo.taps.shift(); // Keep last 3 taps
              }
              const avgInterval = this.tapTempo.taps.reduce((a, b) => a + b, 0) / this.tapTempo.taps.length;
              this.state.bpm = 60 / avgInterval;
              this.state.beatDuration = avgInterval;
          } else {
              this.tapTempo.taps = []; // Reset if too long
          }
      }
      this.tapTempo.lastTap = now;
      this.showNotification(`BPM: ${Math.round(this.state.bpm)}`, 1000);
  }

  toggleLoopMode() {
      this.state.loopMode = !this.state.loopMode;
      this.showNotification(`LOOP MODE: ${this.state.loopMode ? 'ON' : 'OFF'}`, 1500);
  }

  toggleAIDJ() {
      this.state.aiDjActive = !this.state.aiDjActive;
      this.showNotification(`AI DJ: ${this.state.aiDjActive ? 'ACTIVE' : 'MUTED'}`, 1500);
  }
  
  cycleEffects() {
      const fxList = ['reverb', 'delay', 'filter', 'grain', 'pitch'];
      const currentIndex = fxList.indexOf(this.state.activeFx);
      const nextIndex = (currentIndex + 1) % fxList.length;
      this.state.activeFx = fxList[nextIndex];
      this.showNotification(`FX: ${this.state.activeFx.toUpperCase()}`, 1500);
      // In a full version, you would re-route the audio graph here.
  }
  
  createTouchRipple(e) {
      const ripple = document.createElement('div');
      ripple.className = 'touch-ripple';
      document.body.appendChild(ripple);
      ripple.style.left = `${e.clientX}px`;
      ripple.style.top = `${e.clientY}px`;
      setTimeout(() => ripple.remove(), 600);
  }

  showNotification(message, duration = 3000, isError = false) {
    this.ui.notification.textContent = message;
    this.ui.notification.style.borderColor = isError ? 'var(--electric-red)' : 'var(--quantum-blue)';
    this.ui.notification.classList.add('visible');
    setTimeout(() => this.ui.notification.classList.remove('visible'), duration);
  }
  
  createImpulseResponse() {
    const sr = this.audio.context.sampleRate;
    const duration = 2;
    const decay = 3;
    const buffer = this.audio.context.createBuffer(2, sr * duration, sr);
    for (let c = 0; c < 2; c++) {
      const channel = buffer.getChannelData(c);
      for (let i = 0; i < channel.length; i++) {
        channel[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / channel.length, decay);
      }
    }
    return buffer;
  }
}

// --- Visuals Manager Class ---
class VisualsManager {
    constructor(ui, state) {
        this.ui = ui;
        this.state = state;
        this.canvases = {
            particle: document.getElementById('particleCanvas'),
            spatial: document.getElementById('spatialCanvas'),
            waveform: document.getElementById('waveformCanvas'),
        };
        this.contexts = {
            particle: this.canvases.particle.getContext('2d'),
            spatial: this.canvases.spatial.getContext('2d'),
            waveform: this.canvases.waveform.getContext('2d'),
        };
        this.particles = [];
        this.resizeCanvases();
        window.addEventListener('resize', () => this.resizeCanvases());
    }
    
    resizeCanvases() {
        Object.values(this.canvases).forEach(canvas => {
            canvas.width = canvas.offsetWidth * window.devicePixelRatio;
            canvas.height = canvas.offsetHeight * window.devicePixelRatio;
        });
    }

    render(analyser) {
        this.clearCanvases();
        if (analyser) {
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);
            analyser.getByteTimeDomainData(dataArray);
            this.drawWaveform(dataArray, bufferLength);
        }
        this.drawParticles();
        this.drawSpatial();
    }
    
    clearCanvases() {
        this.contexts.particle.clearRect(0, 0, this.canvases.particle.width, this.canvases.particle.height);
        this.contexts.spatial.clearRect(0, 0, this.canvases.spatial.width, this.canvases.spatial.height);
    }
    
    drawWaveform(dataArray, bufferLength) {
        const ctx = this.contexts.waveform;
        const w = this.canvases.waveform.width;
        const h = this.canvases.waveform.height;
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
        ctx.beginPath();

        const sliceWidth = w * 1.0 / bufferLength;
        let x = 0;

        for (let i = 0; i < bufferLength; i++) {
            const v = dataArray[i] / 128.0;
            const y = v * h / 2;
            if (i === 0) {
                ctx.moveTo(x, y);
            } else {
                ctx.lineTo(x, y);
            }
            x += sliceWidth;
        }
        ctx.lineTo(w, h / 2);
        ctx.stroke();
    }
    
    drawSampleWaveform(slot, buffer) {
        const canvas = this.ui.sampleNodes[slot].querySelector('.sample-canvas');
        const ctx = canvas.getContext('2d');
        const dpr = window.devicePixelRatio;
        canvas.width = canvas.offsetWidth * dpr;
        canvas.height = canvas.offsetHeight * dpr;
        ctx.scale(dpr, dpr);

        const data = buffer.getChannelData(0);
        const w = canvas.offsetWidth;
        const h = canvas.offsetHeight;
        
        ctx.lineWidth = 1;
        ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
        ctx.beginPath();
        const sliceWidth = w / data.length;
        for (let i = 0; i < data.length; i++) {
            const x = i * sliceWidth;
            const y = (data[i] * h / 2) + h / 2;
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    drawParticles() {
        if (Math.random() < this.state.energy * 0.5) {
            this.particles.push({
                x: Math.random() * this.canvases.particle.width,
                y: Math.random() * this.canvases.particle.height,
                vx: (Math.random() - 0.5) * 2,
                vy: (Math.random() - 0.5) * 2,
                life: 100
            });
        }

        const ctx = this.contexts.particle;
        this.particles = this.particles.filter(p => p.life > 0);
        this.particles.forEach(p => {
            p.x += p.vx;
            p.y += p.vy;
            p.life--;
            ctx.fillStyle = `rgba(0, 255, 255, ${p.life / 100})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }

    drawSpatial() {
        // Placeholder for a more complex spatial visualizer
        const ctx = this.contexts.spatial;
        ctx.fillStyle = `rgba(255, 0, 255, ${this.state.motionLevel * 0.1})`;
        ctx.beginPath();
        ctx.arc(this.canvases.spatial.width / 2, this.canvases.spatial.height / 2, this.state.motionLevel * 200, 0, Math.PI*2);
        ctx.fill();
    }
}

// --- Initialize the App ---
window.addEventListener('load', () => {
  new NeuromancerEngine();
});
</script>
</body>
</html>
