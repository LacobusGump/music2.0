<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Grand Unified Music Project</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body {
      @apply bg-gradient-to-br from-gray-900 via-indigo-900 to-gray-800 text-green-400 overflow-hidden h-screen flex flex-col items-center justify-between transition-all duration-1000;
    }
    body.transcendent {
      @apply bg-gradient-to-br from-black via-purple-900 to-indigo-900 text-pink-400 filter blur-sm brightness-125;
    }
    .app {
      @apply w-full max-w-2xl p-4 sm:p-6 rounded-xl bg-gray-800/30 backdrop-blur-md shadow-lg;
    }
    .logo {
      @apply text-4xl sm:text-5xl md:text-7xl font-extrabold bg-gradient-to-r from-green-400 to-teal-400 bg-clip-text text-transparent animate-pulse;
    }
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    .tagline { @apply text-base sm:text-lg md:text-xl opacity-80 mb-4 sm:mb-6 font-light; }
    .controls { @apply flex flex-wrap gap-2 sm:gap-4 mb-4 sm:mb-6; }
    .btn {
      @apply px-4 sm:px-6 py-2 sm:py-3 rounded-full font-bold text-black shadow-md transition-all duration-300 hover:-translate-y-1 hover:shadow-lg;
    }
    .start-btn { @apply bg-gradient-to-r from-green-400 to-teal-400; }
    .contemplative-btn { @apply bg-gradient-to-r from-red-400 to-yellow-500; }
    .evolutionary-btn { @apply bg-gradient-to-r from-teal-400 to-cyan-500; }
    .spatial-viz {
      @apply w-full h-48 sm:h-64 border-2 border-green-400/30 rounded-xl relative overflow-hidden bg-gradient-to-br from-green-400/10 to-gray-900/10 mb-4 sm:mb-6 transition-all duration-1000;
    }
    .spatial-viz.transcendent { @apply border-pink-400/50 bg-pink-400/20; }
    .orb {
      @apply absolute w-12 sm:w-16 h-12 sm:h-16 rounded-full bg-gradient-to-r from-green-400 to-transparent transition-all duration-300 shadow-lg;
      top: 50%; left: 50%; transform: translate(-50%, -50%);
    }
    .orb.transcendent { @apply bg-gradient-to-r from-pink-400 to-transparent shadow-pink-400/50; }
    .stats { @apply grid grid-cols-2 sm:grid-cols-4 gap-2 sm:gap-4 mb-4 sm:mb-6; }
    .stat {
      @apply p-2 sm:p-4 rounded-lg border-2 border-green-400/30 bg-green-400/15 transition-all duration-300;
    }
    .stat.transcendent { @apply border-pink-400/30 bg-pink-400/15; }
    .stat-value { @apply text-lg sm:text-xl font-bold text-green-400; }
    .stat.transcendent .stat-value { @apply text-pink-400; }
    .stat-label { @apply text-xs opacity-75 mt-1; }
    .status { @apply text-sm sm:text-base text-teal-400 opacity-80 animate-breathe mb-4 sm:mb-6; }
    @keyframes breathe { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }
    .particles { @apply fixed inset-0 pointer-events-none z-[-1] opacity-0 transition-opacity duration-500; }
    .particles.active { @apply opacity-70; }
    .particle {
      @apply absolute w-1 h-1 bg-gradient-to-r from-pink-400 to-transparent rounded-full animate-float;
    }
    @keyframes float {
      0% { transform: translateY(110vh) scale(0); opacity: 0; }
      10% { opacity: 0.8; }
      90% { opacity: 0.8; }
      100% { transform: translateY(-30vh) scale(1.5); opacity: 0; }
    }
    .hidden { @apply hidden; }
    .error {
      @apply bg-red-400/15 border-2 border-red-400/40 rounded-lg p-2 sm:p-3 text-red-400 mt-2 sm:mt-4 text-left;
    }
    .canvas-container { @apply w-full h-40 sm:h-52 mb-4 sm:mb-6 relative; }
    canvas {
      @apply w-full h-full bg-gray-900/20 rounded-lg;
    }
    @media (max-width: 640px) {
      .app { @apply max-w-lg; }
      .logo { @apply text-3xl; }
      .stats { @apply grid-cols-2; }
    }
  </style>
</head>
<body>
  <div class="particles" id="particles"></div>
  
  <div class="app">
    <div class="header">
      <div class="logo" id="logo">GUMP</div>
      <div class="tagline" id="tagline">Grand Unified Music Project</div>
    </div>
    <div class="controls">
      <button class="start-btn btn" id="start">ðŸŽµ Start Spatial Audio</button>
      <button class="contemplative-btn btn" id="contemplative">ðŸŒŒ Contemplative Drift</button>
      <button class="evolutionary-btn btn" id="evolutionary">ðŸŒŠ Evolutionary Surge</button>
    </div>
    <div class="canvas-container">
      <canvas id="visualizer"></canvas>
    </div>
    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>
    <div class="stats hidden" id="stats">
      <div class="stat"><div class="stat-value" id="motion">0</div><div class="stat-label">Motion</div></div>
      <div class="stat"><div class="stat-value" id="bpm">90</div><div class="stat-label">BPM</div></div>
      <div class="stat"><div class="stat-value" id="groove">CHILL</div><div class="stat-label">State</div></div>
      <div class="stat"><div class="stat-value" id="section">INTRO</div><div class="stat-label">Section</div></div>
    </div>
    <div class="status hidden" id="status">ðŸŽµ Flowing with your vibe...</div>
    <div class="error hidden" id="error"></div>
  </div>

  <script>
    class AudioAgent {
      constructor(ctx, reverb, id, baseFreq, role) {
        this.ctx = ctx;
        this.reverb = reverb;
        this.id = id; // 0=kick, 1=bass, 2=hihat, 3=melody, 4=pad, 5=ambient, 6=perc
        this.baseFreq = baseFreq;
        this.role = role;
        this.traits = {
          pitchShift: 0,
          rhythmFactor: 1,
          volume: 0.1,
          activeThreshold: [0.1, 0.2, 0.4, 0.6, 0.8, 0.9, 1.0][id],
          waveform: this.role === 'melody' ? 'sine' : this.role === 'pad' ? 'sawtooth' : this.role === 'ambient' ? 'triangle' : ['sawtooth', 'square'][id % 2]
        };
        this.active = false;
        this.gain = ctx.createGain();
        this.gain.connect(reverb);
        this.oscillators = new Set();
        this.filter = ctx.createBiquadFilter();
      }

      activate() {
        this.active = true;
        this.gain.gain.value = this.traits.volume;
        this.filter.connect(this.gain);
      }

      evolve(motion, rampLevel, envDensity, locationData, contemplativeDrift, evolutionarySurge) {
        if (!this.active || rampLevel < this.traits.activeThreshold || Math.random() > 0.6) return;

        const motionImpact = motion > 15 ? 0.15 : motion < 5 ? -0.1 : 0;
        this.traits.pitchShift = Math.max(-0.4, Math.min(0.6, this.traits.pitchShift + motionImpact * 0.03 * envDensity));

        const speedFactor = locationData.speed > 0.5 ? 0.08 : 0;
        let volumeAdjust = rampLevel * 0.12 + speedFactor;
        if (contemplativeDrift) volumeAdjust *= 0.85;
        if (evolutionarySurge) volumeAdjust *= 1.15;
        this.traits.volume = Math.min(0.8, Math.max(0.05, this.traits.volume + volumeAdjust));

        const duration = this.role === 'kick' ? 0.35 : this.role === 'pad' ? 2.0 : this.role === 'ambient' ? 3.0 : 0.25;
        if (Math.random() > 0.3 || this.role === 'kick' || this.role === 'ambient') this.play(duration);
      }

      conjugate(partner) {
        if (partner && partner !== this && Math.random() < 0.25) {
          this.traits.rhythmFactor = partner.traits.rhythmFactor * (1 + (Math.random() - 0.5) * 0.25);
          partner.traits.pitchShift += (this.traits.pitchShift - partner.traits.pitchShift) * 0.2;
        }
      }

      play(duration) {
        if (!this.active || !this.ctx) return;

        try {
          const osc = this.ctx.createOscillator();
          osc.type = this.traits.waveform;
          osc.frequency.value = this.baseFreq * (1 + this.traits.pitchShift * (this.role === 'kick' ? 0.5 : 0.4));

          this.filter.type = this.role === 'pad' || this.role === 'ambient' ? 'lowpass' : 'bandpass';
          this.filter.frequency.value = this.role === 'pad' || this.role === 'ambient' ? 450 + this.traits.pitchShift * 250 : 250 + this.traits.pitchShift * 150;
          this.filter.Q.value = this.role === 'pad' || this.role === 'ambient' ? 1.8 : 5;

          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(this.traits.volume, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

          osc.connect(this.filter).connect(gain).connect(this.gain);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);

          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), duration * 1000 + 200);
        } catch (e) {
          console.error(`Play error for ${this.role}: ${e.message}`);
        }
      }

      deactivate() {
        this.oscillators.forEach(osc => {
          try { osc.stop(this.ctx.currentTime + 0.3); } catch (e) { console.warn(`Deactivate error: ${e.message}`); }
        });
        this.oscillators.clear();
        this.active = false;
      }
    }

    class GUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 90;
        this.pos = { x: 50, y: 50, z: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.state = 'CHILL';
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.lastUpdateTime = 0;
        this.frameCount = 0;
        this.reverb = null;
        this.agents = [];
        this.oscillators = new Set();
        this.rampLevel = 0;
        this.envDensity = 0;
        this.locationData = { lat: 0, lon: 0, speed: 0, accuracy: 100 };
        this.contemplativeDrift = false;
        this.evolutionarySurge = false;
        this.songHistory = [];
        this.visualizer = null;

        this.scale = [130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94, 261.63, 293.66, 329.63];
        this.chords = [[0, 2, 4], [5, 0, 2], [3, 5, 0], [4, 6, 1], [2, 4, 6], [1, 3, 5]];
        this.currentChord = 0;
        this.patterns = {
          kick: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
          hihat: [1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
          snare: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0],
          perc: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
        };
        this.songSection = 'INTRO';
        this.layerProgress = 0;
        this.lastStrideTime = 0;
        this.strideInterval = 500;

        this.elements = {};
        this.init();
        this.loadState();
      }

      init() {
        const ids = ['start', 'viz', 'stats', 'status', 'logo', 'tagline', 'orb', 'motion', 'bpm', 'groove', 'error', 'particles', 'contemplative', 'evolutionary', 'section', 'visualizer'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));

        this.elements.start.onclick = () => this.start();
        this.elements.contemplative.onclick = () => this.toggleContemplativeDrift();
        this.elements.evolutionary.onclick = () => this.toggleEvolutionarySurge();

        this.visualizer = new Visualizer(this.elements.visualizer);
        this.setupEventListeners();
      }

      setupEventListeners() {
        window.addEventListener('resize', () => this.visualizer.resize());
        window.addEventListener('beforeunload', () => this.cleanup());
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') {
              this.handleError('Motion permission denied. Enable device motion.');
              return;
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume(); // Ensure user interaction triggers audio
          this.createReverb();

          this.elements.start.classList.add('hidden');
          ['viz', 'stats', 'status'].forEach(id => this.elements[id].classList.remove('hidden'));

          this.active = true;
          this.spawnAgents();
          this.startSensors();
          this.startGroove();
          this.animate();
          this.monitorTranscendence();
          this.startVisualization();
        } catch (e) {
          this.handleError(`Startup failed: ${e.message}`);
        }
      }

      spawnAgents() {
        const roles = ['kick', 'bass', 'hihat', 'melody', 'pad', 'ambient', 'perc'];
        const baseFreqs = this.scale.slice(0, 7);
        roles.forEach((role, idx) => {
          const agent = new AudioAgent(this.ctx, this.reverb, idx, baseFreqs[idx], role);
          agent.activate();
          this.agents.push(agent);
        });
      }

      startSensors() {
        let lastSensorTime = 0;
        const throttleMs = 30;

        window.addEventListener('devicemotion', e => {
          if (!this.active) return;

          const now = Date.now();
          if (now - lastSensorTime < throttleMs) return;
          lastSensorTime = now;

          const acc = e.accelerationIncludingGravity || { x: 0, y: 0, z: 0 };
          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);

          this.motion = Math.min(120, Math.sqrt(dx * dx + dy * dy + dz * dz) * 3.5);
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };

          if (this.motion > 5 && now - this.lastStrideTime > this.strideInterval) {
            this.lastStrideTime = now;
            this.updateSongProgress();
            this.updateEnvDensity();
            this.evolveAgents();
          }

          if (this.motion > 5) this.lastMotionTime = now;

          this.pos.x = Math.max(5, Math.min(95, this.pos.x * 0.85 + (50 + acc.x) * 0.15));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y * 0.85 + (50 + acc.y) * 0.15));
          this.pos.z = Math.max(-60, Math.min(60, this.pos.z * 0.9 + (acc.z * 3) * 0.1));

          this.updateState();
          this.visualizer.update(this.motion, this.pos);
        }, { passive: true });
      }

      toggleContemplativeDrift() {
        this.contemplativeDrift = !this.contemplativeDrift;
        this.elements.contemplative.style.background = this.contemplativeDrift ? 'linear-gradient(45deg, #ffaa00, #ff6b6b)' : 'linear-gradient(45deg, #ff6b6b, #ffaa00)';
        if (this.contemplativeDrift) {
          this.bpm = Math.max(55, this.bpm - 8);
          this.agents.forEach(agent => agent.traits.volume *= 0.85);
        } else {
          this.bpm = Math.min(160, this.bpm + 8);
          this.agents.forEach(agent => agent.traits.volume /= 0.85);
        }
        this.updateState();
      }

      toggleEvolutionarySurge() {
        this.evolutionarySurge = !this.evolutionarySurge;
        this.elements.evolutionary.style.background = this.evolutionarySurge ? 'linear-gradient(45deg, #45b7d1, #4ecdc4)' : 'linear-gradient(45deg, #4ecdc4, #45b7d1)';
        if (this.evolutionarySurge) this.performEvolutionarySurge();
      }

      performEvolutionarySurge() {
        if (!this.evolutionarySurge) return;
        this.bpm = Math.min(160, this.bpm + 12);
        this.agents.forEach(agent => agent.traits.volume = Math.min(0.9, agent.traits.volume * 1.2));
        this.updateState();
        setTimeout(() => this.performEvolutionarySurge(), 4000);
      }

      monitorTranscendence() {
        let lastCheck = 0;
        const check = () => {
          if (!this.active) return;

          const now = Date.now();
          if (now - lastCheck < 100) {
            requestAnimationFrame(check);
            return;
          }
          lastCheck = now;

          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 1000;

          if (shouldTranscend && !this.transcendent) this.enterTranscendence();
          else if (!shouldTranscend && this.transcendent) this.exitTranscendence();

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 1000) / 3500);
            this.deepenVoid();
          }

          requestAnimationFrame(check);
        };
        requestAnimationFrame(check);
      }

      enterTranscendence() {
        this.transcendent = true;
        this.state = 'VOID';
        const elements = [this.elements.logo, this.elements.tagline, this.elements.viz, this.elements.orb];
        elements.forEach(el => el?.classList.add('transcendent'));
        document.body.classList.add('transcendent');
        this.createParticles();
        this.startHeavenLayers();
        this.saveState();
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.state = 'CHILL';
        const elements = [this.elements.logo, this.elements.tagline, this.elements.viz, this.elements.orb];
        elements.forEach(el => el?.classList.remove('transcendent'));
        document.body.classList.remove('transcendent');
        this.clearParticles();
        this.stopHeavenLayers();
        this.agents.forEach(agent => agent.deactivate());
        this.saveState();
      }

      createParticles() {
        const container = this.elements.particles;
        if (!container) return;
        container.classList.add('active');
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 40; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = `${Math.random() * 100}%`;
          particle.style.animationDelay = `${Math.random() * 9}s`;
          fragment.appendChild(particle);
        }
        container.appendChild(fragment);
      }

      clearParticles() {
        const container = this.elements.particles;
        if (!container) return;
        container.classList.remove('active');
        setTimeout(() => container.innerHTML = '', 3000);
      }

      createReverb() {
        if (!this.ctx) return;
        try {
          this.reverb = this.ctx.createConvolver();
          const length = this.ctx.sampleRate * 3.5;
          const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
          for (let c = 0; c < 2; c++) {
            const data = buffer.getChannelData(c);
            for (let i = 0; i < data.length; i++) {
              data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2.8);
            }
          }
          this.reverb.buffer = buffer;
          this.reverb.connect(this.ctx.destination);
        } catch (e) {
          this.handleError(`Reverb creation failed: ${e.message}`);
        }
      }

      deepenVoid() {
        const intensity = this.transcendentIntensity;
        if (intensity > 0.3 && Math.random() < 0.01) this.voidWhisper();
        if (intensity > 0.6 && Math.random() < 0.007) this.voidBell();
        if (intensity > 0.2) {
          const depth = Math.floor(intensity * 40);
          document.body.style.background = `radial-gradient(circle at 60% 40%, #040008 ${depth}%, #0a0a1e 70%, #1a0a2e 95%, #0a0a1e 100%)`;
        }
      }

      voidWhisper() {
        if (!this.ctx) return;
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          osc.type = 'triangle';
          osc.frequency.value = 60 + Math.random() * 140;
          filter.type = 'bandpass';
          filter.frequency.value = 120 + Math.random() * 120;
          filter.Q.value = 4;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.02 * this.transcendentIntensity, this.ctx.currentTime + 2);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 7);
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 7);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 7500);
        } catch (e) {
          console.warn('Void whisper error:', e);
        }
      }

      voidBell() {
        if (!this.ctx) return;
        try {
          const freq = [174, 207, 261][Math.floor(Math.random() * 3)] * 0.4;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.08 * this.transcendentIntensity, this.ctx.currentTime + 0.4);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
          osc.connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 8);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 8500);
        } catch (e) {
          console.warn('Void bell error:', e);
        }
      }

      startHeavenLayers() {
        if (!this.ctx) return;
        try {
          const chord = this.chords[this.currentChord];
          chord.forEach(note => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            osc.type = 'sine';
            osc.frequency.value = this.scale[note] * 0.2;
            filter.type = 'lowpass';
            filter.frequency.value = 180 + this.motion * 0.4;
            filter.Q.value = 1.0;
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity, this.ctx.currentTime + 6);
            osc.connect(filter).connect(gain).connect(this.reverb);
            osc.start();
            this.oscillators.add(osc);
          });
        } catch (e) {
          console.warn('Heaven layers error:', e);
        }
      }

      stopHeavenLayers() {
        this.oscillators.forEach(osc => {
          try { osc.stop(this.ctx.currentTime + 3); } catch (e) { console.warn('Stop error:', e); }
        });
        this.oscillators.clear();
      }

      updateLocation(position) {
        this.locationData.lat = position.coords.latitude;
        this.locationData.lon = position.coords.longitude;
        this.locationData.speed = position.coords.speed || 0;
        this.locationData.accuracy = position.coords.accuracy || 100;
        const responsiveness = Math.max(0.1, 100 / this.locationData.accuracy);

        this.envDensity = Math.min(1, Math.max(0, this.envDensity + (this.locationData.speed * 0.012 * responsiveness)));
        this.rampLevel = Math.min(1, this.rampLevel + (this.locationData.speed * 0.025 * responsiveness));

        if (this.locationData.speed > 0.5) {
          this.bpm = Math.min(160, this.bpm + Math.round(this.envDensity * 4));
        }
      }

      updateEnvDensity() {
        const motionFactor = this.motion * 0.005;
        const locationFactor = this.locationData.speed * 0.008;
        this.envDensity = Math.max(0, Math.min(1, this.envDensity + (motionFactor + locationFactor) * 0.12 + (Math.random() - 0.5) * 0.02));
      }

      updateSongProgress() {
        if (this.motion > 5 || this.locationData.speed > 0.5) {
          this.layerProgress += 0.05;
          if (this.songSection === 'INTRO' && this.layerProgress >= 18) {
            this.songSection = 'BUILD';
            this.layerProgress = 0;
          } else if (this.songSection === 'BUILD' && this.layerProgress >= 35) {
            this.songSection = 'MAIN';
            this.layerProgress = 0;
          } else if (this.songSection === 'MAIN' && this.layerProgress >= 50) {
            this.songSection = 'OUTRO';
            this.layerProgress = 0;
          } else if (this.songSection === 'OUTRO' && this.layerProgress >= 70) {
            this.songSection = 'INTRO';
            this.layerProgress = 0;
            this.currentChord = (this.currentChord + 1) % this.chords.length;
          }
        }
      }

      evolveAgents() {
        this.agents.forEach((agent, idx) => {
          if (this.songSection === 'INTRO' && idx === 0) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData, this.contemplativeDrift, this.evolutionarySurge);
          else if (this.songSection === 'BUILD' && idx < 3) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData, this.contemplativeDrift, this.evolutionarySurge);
          else if (this.songSection === 'MAIN' && idx < 5) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData, this.contemplativeDrift, this.evolutionarySurge);
          else if (this.songSection === 'OUTRO' && idx < 7) agent.evolve(this.motion, this.rampLevel, this.envDensity, this.locationData, this.contemplativeDrift, this.evolutionarySurge);
        });
      }

      updateStatus() {
        if (this.contemplativeDrift) this.elements.status.textContent = `ðŸŽµ Contemplative Drift... ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()}`;
        else if (this.evolutionarySurge) this.elements.status.textContent = `ðŸŽµ Evolutionary Surge... ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()}`;
        else this.elements.status.textContent = `ðŸŽµ ${this.state.toLowerCase()} - ${this.songSection.toLowerCase()}...`;
      }

      updateState() {
        if (this.transcendent) {
          const states = ['VOID', 'DARKNESS', 'ETHEREAL', 'INFINITE', 'TRANSCENDENCE', 'UNITY'];
          this.state = states[Math.floor(this.transcendentIntensity * states.length)];
          this.bpm = Math.round(50 + (this.transcendentIntensity * 50) + (this.motion * 0.2));
        } else {
          const targetBPM = 80 + this.motion * 1.8 + this.envDensity * 20 + (this.locationData.speed * 12);
          this.bpm = Math.round(this.bpm * 0.9 + targetBPM * 0.1);
          this.state = this.motion < 8 ? 'CHILL' : this.motion < 20 ? 'FLOW' : this.motion < 40 ? 'ENERGY' : this.motion < 80 ? 'PEAK' : 'EXPLOSION';
        }

        if (this.frameCount % 15 === 0) {
          this.elements.bpm.textContent = this.bpm;
          this.elements.groove.textContent = this.state;
          this.elements.section.textContent = this.songSection;
          this.updateStatus();
          this.elements.motion.textContent = Math.round(this.motion);
          this.songHistory.push({ time: Date.now(), state: this.state, section: this.songSection, bpm: this.bpm });
          if (this.songHistory.length > 150) this.songHistory.shift();
        }
      }

      startGroove() {
        const tick = () => {
          if (!this.active) return;

          if (this.transcendent) {
            if (this.step % 8 === 0) this.etherealKick();
            if (this.step % 12 === 6 && this.transcendentIntensity > 0.3) this.voidPulse();
          } else {
            const beat = this.step % 16;
            this.agents.forEach((agent, idx) => {
              if (this.songSection === 'INTRO' && idx === 0 && this.patterns.kick[beat]) agent.play(0.35);
              if (this.songSection === 'BUILD' && idx < 3 && (this.patterns.kick[beat] || this.patterns.hihat[beat] || beat % 4 === 2)) agent.play(0.25);
              if (this.songSection === 'MAIN' && idx < 5 && (this.patterns.kick[beat] || this.patterns.hihat[beat] || this.patterns.snare[beat] || beat % 2 === 0)) agent.play(0.25);
              if (this.songSection === 'OUTRO' && idx < 7 && (beat % 4 === 0 || this.patterns.hihat[beat] || this.patterns.perc[beat])) agent.play(0.25);
            });
          }

          this.step = (this.step + 1) % 32;
          if (this.step === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
            if (this.contemplativeDrift) this.adjustForContemplativeDrift();
          }

          const interval = Math.max(40, 60000 / this.bpm / 4);
          setTimeout(tick, interval);
        };
        tick();
      }

      adjustForContemplativeDrift() {
        if (this.contemplativeDrift) {
          this.bpm = Math.max(55, this.bpm - 8);
          this.agents.forEach(agent => agent.traits.volume *= 0.85);
        }
      }

      etherealKick() {
        if (!this.ctx) return;
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(35, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(18, this.ctx.currentTime + 0.6);
          gain.gain.setValueAtTime(0.45 * this.transcendentIntensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.2);
          osc.connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.2);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1300);
        } catch (e) {
          console.warn('Ethereal kick error:', e);
        }
      }

      voidPulse() {
        if (!this.ctx) return;
        try {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          osc.type = 'sawtooth';
          osc.frequency.value = 18 + this.motion * 0.12;
          filter.type = 'lowpass';
          filter.frequency.value = 45 + this.motion * 0.35;
          filter.Q.value = 2.5;
          gain.gain.setValueAtTime(0.6 * this.transcendentIntensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.8);
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.8);
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 2000);
        } catch (e) {
          console.warn('Void pulse error:', e);
        }
      }

      startVisualization() {
        this.visualizer.start(this.ctx);
      }

      animate() {
        const update = () => {
          if (!this.active) return;

          const now = Date.now();
          if (now - this.lastUpdateTime < 25) {
            requestAnimationFrame(update);
            return;
          }
          this.lastUpdateTime = now;

          this.elements.orb.style.transform = `translate(${this.pos.x - 50}%, ${this.pos.y - 50}%) scale(${1 + this.motion * 0.02}) rotate(${this.pos.z}deg)`;
          this.visualizer.render(this.motion, this.bpm, this.pos);

          this.frameCount++;
          requestAnimationFrame(update);
        };
        requestAnimationFrame(update);
      }

      handleError(message) {
        const errorDiv = this.elements.error;
        errorDiv.textContent = `${new Date().toLocaleTimeString()} - ${message}`;
        errorDiv.classList.remove('hidden');
        setTimeout(() => errorDiv.classList.add('hidden'), 6000);
      }

      saveState() {
        const state = {
          bpm: this.bpm,
          state: this.state,
          section: this.songSection,
          rampLevel: this.rampLevel,
          envDensity: this.envDensity,
          locationData: this.locationData,
          songHistory: this.songHistory
        };
        localStorage.setItem('gumpState', JSON.stringify(state));
      }

      loadState() {
        const savedState = localStorage.getItem('gumpState');
        if (savedState) {
          const state = JSON.parse(savedState);
          this.bpm = state.bpm || 90;
          this.state = state.state || 'CHILL';
          this.songSection = state.section || 'INTRO';
          this.rampLevel = state.rampLevel || 0;
          this.envDensity = state.envDensity || 0;
          this.locationData = state.locationData || { lat: 0, lon: 0, speed: 0, accuracy: 100 };
          this.songHistory = state.songHistory || [];
        }
      }

      cleanup() {
        this.active = false;
        this.agents.forEach(agent => agent.deactivate());
        this.oscillators.forEach(osc => {
          try { osc.stop(); } catch (e) { console.warn('Cleanup osc error:', e); }
        });
        this.oscillators.clear();
        this.stopHeavenLayers();
        this.saveState();
      }
    }

    class Visualizer {
      constructor(canvas) {
        this.canvas = canvas;
        this.ctx = canvas.getContext('2d');
        this.width = canvas.width;
        this.height = canvas.height;
        this.resize();
      }

      resize() {
        this.width = this.canvas.parentElement.clientWidth;
        this.height = 200;
        this.canvas.width = this.width * devicePixelRatio;
        this.canvas.height = this.height * devicePixelRatio;
        this.ctx.scale(devicePixelRatio, devicePixelRatio);
      }

      start(audioCtx) {
        this.analyser = audioCtx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.bufferLength = this.analyser.frequencyBinCount;
        this.dataArray = new Uint8Array(this.bufferLength);
        gump.agents.forEach(agent => agent.gain.connect(this.analyser));
        this.analyser.connect(audioCtx.destination);
      }

      update(motion, pos) {
        this.motion = motion;
        this.pos = pos;
      }

      render(motion, bpm, pos) {
        this.ctx.clearRect(0, 0, this.width, this.height);
        this.analyser.getByteFrequencyData(this.dataArray);

        const barWidth = (this.width / this.bufferLength) * 3;
        let x = 0;

        this.ctx.fillStyle = `rgba(0, 255, 170, ${Math.min(0.6, motion / 120)})`;
        for (let i = 0; i < this.bufferLength; i++) {
          const barHeight = (this.dataArray[i] / 255) * (this.height * 0.85);
          this.ctx.fillRect(x, this.height - barHeight, barWidth, barHeight);
          x += barWidth + 1;
        }

        this.ctx.beginPath();
        this.ctx.arc(this.width * (pos.x / 100), this.height * (1 - pos.y / 100), 12 + (motion / 12), 0, Math.PI * 2);
        this.ctx.fillStyle = 'rgba(0, 255, 170, 0.8)';
        this.ctx.fill();
        this.ctx.closePath();

        this.ctx.fillStyle = '#00ffaa';
        this.ctx.font = '18px sans-serif';
        this.ctx.fillText(`BPM: ${bpm}`, 15, 30);
        this.ctx.fillText(`State: ${gump.state}`, 15, 50);
      }
    }

    const gump = new GUMP();
  </script>
</body>
</html>
