<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Rebuilt Cinematic Void Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 3px;
      backdrop-filter: blur(15px);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
      transform: scale(1.1);
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.4) 40%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 60px rgba(255,255,255,0.6);
      backdrop-filter: blur(8px);
      filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));
    }
    
    .orb.pulse {
      transform: translate(-50%, -50%) scale(1.5);
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff4500 0%, rgba(255,69,0,0.5) 40%, transparent 80%);
      box-shadow: 0 0 80px rgba(255,69,0,0.8);
      filter: drop-shadow(0 0 30px rgba(255,69,0,0.4));
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #1e90ff 0%, rgba(30,144,255,0.5) 40%, transparent 80%);
      box-shadow: 0 0 100px rgba(30,144,255,0.8);
      filter: drop-shadow(0 0 40px rgba(30,144,255,0.4));
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #8a2be2 0%, #ff1493 30%, #ffd700 60%, transparent 90%);
      box-shadow: 0 0 140px rgba(138,43,226,0.9);
      filter: drop-shadow(0 0 50px rgba(255,20,147,0.6));
    }
    
    .orb.dimensional {
      background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, #ffff00 50%, #00ff00 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(0,255,255,1);
      filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
    }
    
    .orb.void {
      opacity: 0.5;
      box-shadow: 0 0 100px rgba(255,215,0,0.6);
      filter: drop-shadow(0 0 40px rgba(255,215,0,0.4));
    }
    
    .ui-minimal {
      position: fixed;
      top: 15px;
      left: 15px;
      font-size: 9px;
      color: rgba(255,255,255,0.6);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.2);
      padding: 8px 12px;
      border-radius: 4px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .ui-minimal:hover {
      color: rgba(255,255,255,0.9);
      background: rgba(0,0,0,0.4);
    }
    
    .stage-name {
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 4px;
      font-weight: bold;
    }
    
    .metric {
      margin: 2px 0;
      font-size: 8px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: normal;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.7) 100%);
      opacity: 0;
      transition: opacity 4s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.4);
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: normal;
    }
    
    .theme-text.visible { opacity: 1; }

    .waveform {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
      pointer-events: none;
      z-index: 3;
      opacity: 0.6;
    }
    
    .wave-bar {
      position: absolute;
      bottom: 0;
      width: 16px;
      background: linear-gradient(0deg, rgba(255,255,255,0.6), rgba(255,255,255,0.1));
      border-radius: 2px 2px 0 0;
      transition: height 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }

    .orb::after {
      content: '';
      position: absolute;
      top: -100px;
      left: -100px;
      width: 235px;
      height: 235px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.05) 0%, transparent 70%);
      opacity: 0.5;
      transition: opacity 0.5s ease, transform 0.5s ease;
    }

    .orb.pulse::after {
      opacity: 0.8;
      transform: scale(1.2);
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-minimal" id="uiMinimal">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">BPM: <span id="bpmDisplay">60</span> | VOICES: <span id="voiceCount">0</span></div>
      <div class="metric">INTENSITY: <span id="intensityDisplay">0%</span></div>
    </div>
    
    <div class="waveform" id="waveform"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class RebuiltVoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        this.bpm = 60;
        this.step = 0;
        
        this.motion = 0;
        this.intensity = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.firstMovement = false;
        
        this.stage = 'SILENCE';
        this.totalMotion = 0;
        this.lastEvolutionTime = 0;
        
        this.noMotionCounter = 0;
        
        this.masterGain = null;
        this.limiter = null;
        this.compressor = null;
        this.masterEQ = null;
        this.reverb = null;
        this.delay = null;
        
        this.layers = ['kick', 'bass', 'pad', 'lead', 'atmosphere'];
        this.layerGains = {};
        this.layerCompressors = {};
        this.layerEQs = {};
        this.layerPanners = {};
        
        this.key = 'C';
        this.mode = 'major';
        this.scale = [0, 2, 4, 5, 7, 9, 11];
        this.chordProgression = [[0, 4, 7], [5, 9, 0], [7, 11, 2], [0, 4, 7]];
        this.currentChordIndex = 0;
        
        this.elements = {};
        this.waveBars = [];
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'bpmDisplay', 'voiceCount', 'intensityDisplay', 'uiMinimal',
         'cinematicOverlay', 'themeText', 'waveform', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupWaveformVisualizer();
      }

      setupWaveformVisualizer() {
        for (let i = 0; i < 16; i++) {
          const bar = document.createElement('div');
          bar.className = 'wave-bar';
          bar.style.left = (i * (100 / 16)) + '%';
          bar.style.width = (100 / 16) + '%';
          bar.style.height = '0px';
          this.elements.waveform.appendChild(bar);
          this.waveBars.push(bar);
        }
      }

      async start() {
        try {
          this.ctx = new AudioContext();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setupMotionDetection();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 5000);
          }, 1500);

          this.active = true;
          this.startSequencer();
          this.animate();
        } catch (e) {
          console.error('Failed to start engine:', e);
        }
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 512;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -3;
        this.limiter.knee.value = 1;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0;
        this.limiter.release.value = 0.1;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 10;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        
        this.masterEQ = this.ctx.createBiquadFilter();
        this.masterEQ.type = 'highshelf';
        this.masterEQ.frequency.value = 10000;
        this.masterEQ.gain.value = 2;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8;
        
        this.reverb = this.ctx.createConvolver();
        this.reverb.buffer = this.createReverbBuffer(2.5);
        const reverbGain = this.ctx.createGain();
        reverbGain.gain.value = 0.15;
        this.reverb.connect(reverbGain);
        reverbGain.connect(this.compressor);
        
        this.delay = this.ctx.createDelay(0.5);
        this.delay.delayTime.value = 0.375;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.3;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.1;
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        delayMix.connect(this.compressor);
        
        this.layers.forEach(layer => {
          this.layerGains[layer] = this.ctx.createGain();
          this.layerCompressors[layer] = this.ctx.createDynamicsCompressor();
          this.layerEQs[layer] = this.createLayerEQ(layer);
          this.layerPanners[layer] = this.ctx.createPanner();
          this.layerPanners[layer].panningModel = 'HRTF';
          this.layerPanners[layer].distanceModel = 'linear';
          this.layerPanners[layer].refDistance = 1;
          this.layerPanners[layer].maxDistance = 100;
          this.layerPanners[layer].rolloffFactor = 1;
          
          this.layerGains[layer].connect(this.layerCompressors[layer]);
          this.layerCompressors[layer].connect(this.layerEQs[layer]);
          this.layerEQs[layer].connect(this.layerPanners[layer]);
          this.layerPanners[layer].connect(this.compressor);
          
          if (['pad', 'atmosphere', 'lead'].includes(layer)) {
            const send = this.ctx.createGain();
            send.gain.value = 0.2;
            this.layerPanners[layer].connect(send);
            send.connect(this.reverb);
          }
          
          if (['lead'].includes(layer)) {
            const send = this.ctx.createGain();
            send.gain.value = 0.15;
            this.layerPanners[layer].connect(send);
            send.connect(this.delay);
          }
        });
        
        this.compressor.connect(this.masterEQ);
        this.masterEQ.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      createReverbBuffer(length) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * length, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
          }
        }
        return buffer;
      }

      createLayerEQ(layer) {
        const eq = this.ctx.createGain(); // Placeholder for chain
        // Add EQ bands based on layer
        let low = this.ctx.createBiquadFilter();
        low.type = 'lowshelf';
        low.frequency.value = 250;
        low.gain.value = layer === 'kick' || layer === 'bass' ? 3 : layer === 'hihat' ? -6 : 0;
        
        let mid = this.ctx.createBiquadFilter();
        mid.type = 'peaking';
        mid.frequency.value = 1000;
        mid.Q.value = 1;
        mid.gain.value = layer === 'lead' ? 2 : layer === 'pad' ? -2 : 0;
        
        let high = this.ctx.createBiquadFilter();
        high.type = 'highshelf';
        high.frequency.value = 5000;
        high.gain.value = layer === 'atmosphere' ? 3 : layer === 'bass' ? -4 : 0;
        
        eq.connect(low);
        low.connect(mid);
        mid.connect(high);
        
        return eq;
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc) return;
          
          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.motion = this.motion * 0.9 + newMotion * 0.1;
          this.motionHistory.push(this.motion);
          if (this.motionHistory.length > 20) this.motionHistory.shift();
          
          this.intensity = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
          
          this.lastAccel = acc;
          if (this.motion > 1 && !this.firstMovement) {
            this.firstMovement = true;
            this.stage = 'ACTIVE';
          }
        });
        
        // Mouse fallback
        let lastMouse = { x: 0, y: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          const dx = e.clientX - lastMouse.x;
          const dy = e.clientY - lastMouse.y;
          const newMotion = Math.sqrt(dx*dx + dy*dy) * 0.1;
          this.motion = this.motion * 0.9 + newMotion * 0.1;
          lastMouse = { x: e.clientX, y: e.clientY };
          this.pos.x = (e.clientX / window.innerWidth) * 100;
          this.pos.y = (e.clientY / window.innerHeight) * 100;
        });
      }

      startSequencer() {
        const interval = 60 / this.bpm * 1000 / 4; // Quarter note
        setInterval(() => {
          if (!this.active) return;
          this.playStep();
          this.updateLayers();
          this.updateUI();
          this.step = (this.step + 1) % 16;
        }, interval);
      }

      updateLayers() {
        const i = this.intensity;
        this.layerGains.kick.gain.value = i > 1 ? 1 : 0;
        this.layerGains.bass.gain.value = i > 1.5 ? 0.8 : 0;
        this.layerGains.pad.gain.value = i < 2 ? 0.6 : 0.4;
        this.layerGains.lead.gain.value = i > 2 ? 0.7 : 0;
        this.layerGains.atmosphere.gain.value = i < 1.5 ? 0.5 : 0.3;
      }

      playStep() {
        const now = this.ctx.currentTime;
        if (this.step % 4 === 0) this.playKick(now);
        if (this.step % 2 === 0) this.playBass(now);
        if (this.step % 8 === 0) this.playPad(now);
        if (this.step % 4 === 2) this.playLead(now);
        if (this.step % 16 === 0) this.playAtmosphere(now);
      }

      playKick(now) {
        if (this.layerGains.kick.gain.value === 0) return;
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.05);
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(1, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.connect(gain);
        gain.connect(this.layerGains.kick);
        osc.start(now);
        osc.stop(now + 0.3);
      }

      playBass(now) {
        if (this.layerGains.bass.gain.value === 0) return;
        const note = this.scale[0];
        const freq = this.noteToFreq(note, 2);
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.8, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.layerGains.bass);
        osc.start(now);
        osc.stop(now + 0.5);
      }

      playPad(now) {
        if (this.layerGains.pad.gain.value === 0) return;
        const chord = this.chordProgression[this.currentChordIndex];
        chord.forEach(note => {
          const freq = this.noteToFreq(note, 3);
          const osc = this.ctx.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = freq;
          
          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0, now);
          gain.gain.linearRampToValueAtTime(0.3, now + 2);
          gain.gain.exponentialRampToValueAtTime(0.001, now + 8);
          
          osc.connect(gain);
          gain.connect(this.layerGains.pad);
          osc.start(now);
          osc.stop(now + 8);
        });
        this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
      }

      playLead(now) {
        if (this.layerGains.lead.gain.value === 0) return;
        const note = this.scale[Math.floor(Math.random() * this.scale.length)];
        const freq = this.noteToFreq(note, 5);
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.5, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 1);
        
        osc.connect(gain);
        gain.connect(this.layerGains.lead);
        osc.start(now);
        osc.stop(now + 1);
      }

      playAtmosphere(now) {
        if (this.layerGains.atmosphere.gain.value === 0) return;
        const freq = 200 + Math.random() * 400;
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + 4);
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 500;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.layerGains.atmosphere);
        osc.start(now);
        osc.stop(now + 4);
      }

      noteToFreq(note, octave) {
        return 440 * Math.pow(2, (note + (octave - 4) * 12) / 12);
      }

      updateUI() {
        this.elements.stageName.textContent = this.stage;
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.intensityDisplay.textContent = Math.round(this.intensity * 10) + '%';
        
        this.analyser.getByteFrequencyData(this.dataArray);
        this.waveBars.forEach((bar, i) => {
          const avg = Array.from(this.dataArray.slice(i * 32, (i+1)*32)).reduce((a,b) => a+b, 0) / 32;
          bar.style.height = (avg / 255 * 60) + 'px';
        });
      }

      animate() {
        requestAnimationFrame(this.animate.bind(this));
        if (!this.active) return;
        
        this.elements.orb.style.left = this.pos.x + '%';
        this.elements.orb.style.top = this.pos.y + '%';
        
        this.bpm = 60 + this.intensity * 10;
      }
    }

    new RebuiltVoidEngine();
  </script>
</body>
</html>
