<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;color:#fff;font-family:system-ui;height:100vh;overflow:hidden;touch-action:none}
        #start{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;z-index:10}
        #start.off{display:none}
        .title{font-size:10px;letter-spacing:8px;opacity:0.4}
        .sub{font-size:20px;font-weight:200;letter-spacing:3px}
        button{width:100px;height:100px;border-radius:50%;background:transparent;border:1px solid #0fa;color:#0fa;font:inherit;font-size:9px;letter-spacing:2px;cursor:pointer;transition:0.3s}
        button:hover{background:#0fa;color:#000}
        .hint{font-size:9px;opacity:0.25;text-align:center;max-width:200px;line-height:1.5}
        #app{display:none;height:100vh}
        #app.on{display:block}
        canvas{position:fixed;inset:0;width:100%;height:100%}
        .hud{position:fixed;font-size:8px;letter-spacing:1px;opacity:0.3;z-index:5}
        .tl{top:16px;left:16px}
        .tr{top:16px;right:16px;text-align:right}
        .bl{bottom:16px;left:16px}
        .br{bottom:16px;right:16px;text-align:right}
        .v{font-size:11px;margin-top:3px;opacity:0.7}
    </style>
</head>
<body>
<div id="start">
    <div class="title">GUMP</div>
    <div class="sub">Grand Unified Music Project</div>
    <button id="go">ENTER</button>
    <div class="hint">Move through space. You are the instrument.</div>
</div>
<div id="app">
    <canvas id="c"></canvas>
    <div class="hud tl"><div>FIELD</div><div class="v" id="fld">0</div></div>
    <div class="hud tr"><div>FLOW</div><div class="v" id="flw">0</div></div>
    <div class="hud bl"><div>HARMONIC</div><div class="v" id="hrm">1</div></div>
    <div class="hud br"><div>DENSITY</div><div class="v" id="dns">0</div></div>
</div>
<script>
// GUMP - Grand Unified Music Project
// Space and time unified through movement

const PHI = 1.618033988749;
const HARMONIC_SERIES = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];

// State - position in the unified field
const F = {
    x: 0, y: 0, z: 0,           // spatial position (-1 to 1)
    vx: 0, vy: 0, vz: 0,        // velocity
    speed: 0,                    // magnitude
    phase: 0,                    // temporal phase
    density: 0,                  // event density
    harmonic: 1,                 // current harmonic emphasis
    field: 0                     // field intensity
};

let ctx, out;
let drones = [];
let running = false;

// The fundamental frequency - everything derives from this
const ROOT = 55; // A1 - low, powerful

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Simple, clean output
    out = ctx.createGain();
    out.gain.value = 0.6;

    // Gentle compression
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.ratio.value = 4;
    comp.attack.value = 0.01;
    comp.release.value = 0.3;

    // Warmth
    const warm = ctx.createBiquadFilter();
    warm.type = 'lowshelf';
    warm.frequency.value = 200;
    warm.gain.value = 3;

    out.connect(warm);
    warm.connect(comp);
    comp.connect(ctx.destination);

    // Create the drone field - harmonics of the root
    createDroneField();

    // Start the unified loop
    tick();
}

function createDroneField() {
    // 8 drones based on harmonic series
    // Position in space controls which harmonics are audible

    for (let i = 0; i < 8; i++) {
        const harmonic = HARMONIC_SERIES[i];
        const freq = ROOT * harmonic;

        // Each drone has multiple detuned oscillators for richness
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const gain = ctx.createGain();
        const pan = ctx.createStereoPanner();
        const filter = ctx.createBiquadFilter();

        osc1.type = 'sine';
        osc1.frequency.value = freq;

        osc2.type = 'sine';
        osc2.frequency.value = freq * 1.001; // slight detune

        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 1;

        gain.gain.value = 0; // start silent

        // Higher harmonics pan wider
        pan.pan.value = (i % 2 === 0 ? 1 : -1) * (i / 16);

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(pan);
        pan.connect(out);

        osc1.start();
        osc2.start();

        drones.push({ osc1, osc2, gain, filter, pan, harmonic, freq });
    }
}

function updateDrones() {
    const now = ctx.currentTime;

    drones.forEach((d, i) => {
        // Position in space determines harmonic mix
        // x-axis: odd vs even harmonics
        // y-axis: low vs high harmonics
        // z-axis (speed): attack/presence

        const isOdd = d.harmonic % 2 === 1;
        const oddEvenMix = isOdd ? (1 + F.x) / 2 : (1 - F.x) / 2;

        const heightFactor = i < 4 ? (1 - F.y) / 2 : (1 + F.y) / 2;

        const presence = 0.15 + F.speed * 0.4;

        // Combined amplitude
        let amp = oddEvenMix * heightFactor * presence;

        // Fundamental always present
        if (i === 0) amp = Math.max(amp, 0.2);

        // Higher harmonics quieter
        amp *= 1 / Math.sqrt(d.harmonic);

        // Smooth transition
        d.gain.gain.linearRampToValueAtTime(amp, now + 0.1);

        // Filter opens with speed
        const filterFreq = d.freq * (1 + F.speed * 3);
        d.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.1);

        // Subtle pitch bend based on position
        const bendCents = F.x * 10 + F.y * 5;
        const bendRatio = Math.pow(2, bendCents / 1200);
        d.osc1.frequency.linearRampToValueAtTime(d.freq * bendRatio, now + 0.1);
        d.osc2.frequency.linearRampToValueAtTime(d.freq * 1.001 * bendRatio, now + 0.1);
    });
}

// Rhythmic events - triggered by movement
let lastPulse = 0;
let pulseInterval = 0.5;

function pulse() {
    if (!ctx || F.speed < 0.05) return;

    const now = ctx.currentTime;

    // Pulse interval based on speed - faster movement = faster rhythm
    // But quantized to musical intervals using PHI
    const baseInterval = 0.8 / (1 + F.speed * 2);
    pulseInterval = baseInterval * Math.pow(PHI, Math.floor(F.density * 3) - 1);
    pulseInterval = Math.max(0.1, Math.min(2, pulseInterval));

    if (now - lastPulse < pulseInterval) return;
    lastPulse = now;

    // Choose harmonic based on position
    const harmonicIndex = Math.floor((F.y + 1) * 4) % 8;
    const freq = ROOT * HARMONIC_SERIES[harmonicIndex + 1];

    // Pluck sound
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // Waveform based on x position
    osc.type = F.x > 0 ? 'triangle' : 'sine';
    osc.frequency.value = freq * (F.y > 0 ? 2 : 1);

    filter.type = 'lowpass';
    filter.frequency.value = 1000 + F.speed * 3000;
    filter.Q.value = 2;

    // Quick attack, PHI-based decay
    const decay = 0.1 + (1 - F.speed) * 0.4;
    gain.gain.setValueAtTime(0.3 * F.speed, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + decay);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(out);

    osc.start(now);
    osc.stop(now + decay + 0.1);

    // Occasional harmony note
    if (Math.random() < F.density * 0.3) {
        setTimeout(() => {
            if (!ctx) return;
            const osc2 = ctx.createOscillator();
            const g2 = ctx.createGain();
            osc2.type = 'sine';
            // Perfect fifth or octave
            osc2.frequency.value = freq * (Math.random() > 0.5 ? 1.5 : 2);
            g2.gain.setValueAtTime(0.1, ctx.currentTime);
            g2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + decay * PHI);
            osc2.connect(g2);
            g2.connect(out);
            osc2.start();
            osc2.stop(ctx.currentTime + decay * PHI + 0.1);
        }, pulseInterval * 500 * (1 / PHI));
    }
}

// Motion handlers
function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    // Velocity from acceleration
    F.vx = F.vx * 0.8 + (a.x || 0) * 0.02;
    F.vy = F.vy * 0.8 + (a.y || 0) * 0.02;
    F.vz = F.vz * 0.8 + (a.z || 0) * 0.02;

    // Speed magnitude
    F.speed = Math.sqrt(F.vx*F.vx + F.vy*F.vy + F.vz*F.vz);
    F.speed = Math.min(1, F.speed / 3);

    // Density accumulates with movement
    F.density = F.density * 0.99 + F.speed * 0.01;
}

function onOrientation(e) {
    // Position in space from orientation
    F.x = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    F.y = Math.max(-1, Math.min(1, (e.beta || 0) / 45 - 1));

    // Field intensity from compass
    F.field = (e.alpha || 0) / 360;
}

// Mouse/touch fallback
function onPointer(x, y) {
    const px = (x / window.innerWidth) * 2 - 1;
    const py = 1 - (y / window.innerHeight) * 2;

    // Velocity from movement
    F.vx = F.vx * 0.7 + (px - F.x) * 0.3;
    F.vy = F.vy * 0.7 + (py - F.y) * 0.3;

    F.x = px;
    F.y = py;

    F.speed = Math.sqrt(F.vx*F.vx + F.vy*F.vy);
    F.speed = Math.min(1, F.speed * 3);

    F.density = F.density * 0.98 + F.speed * 0.02;
}

// Visualization
let vc;
function initViz() {
    const canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const canvas = document.getElementById('c');
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade based on density
    vc.fillStyle = `rgba(0,0,0,${0.05 + (1-F.density) * 0.1})`;
    vc.fillRect(0, 0, w, h);

    // Center follows position
    const cx = w/2 + F.x * w * 0.3;
    const cy = h/2 - F.y * h * 0.3;

    // Harmonic rings
    drones.forEach((d, i) => {
        const r = 20 + i * 25 + F.speed * 20;
        const alpha = d.gain.gain.value * 2;

        if (alpha > 0.01) {
            vc.beginPath();
            vc.arc(cx, cy, r, 0, Math.PI * 2);
            vc.strokeStyle = `hsla(${160 + i * 15}, 60%, 50%, ${alpha})`;
            vc.lineWidth = 1 + F.speed * 2;
            vc.stroke();
        }
    });

    // Core glow
    const gr = vc.createRadialGradient(cx, cy, 0, cx, cy, 50 + F.speed * 50);
    gr.addColorStop(0, `rgba(0,255,170,${0.3 + F.speed * 0.3})`);
    gr.addColorStop(1, 'transparent');
    vc.fillStyle = gr;
    vc.fillRect(0, 0, w, h);
}

function updateUI() {
    document.getElementById('fld').textContent = F.field.toFixed(2);
    document.getElementById('flw').textContent = F.speed.toFixed(2);
    document.getElementById('hrm').textContent = Math.floor((F.y + 1) * 4) + 1;
    document.getElementById('dns').textContent = F.density.toFixed(2);
}

// Main loop
function tick() {
    if (!running) return;

    F.phase += 0.01 * (1 + F.speed);

    updateDrones();
    pulse();
    draw();
    updateUI();

    requestAnimationFrame(tick);
}

// Start
async function start() {
    document.getElementById('start').classList.add('off');
    document.getElementById('app').classList.add('on');

    // Request motion permission (iOS)
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);
    document.addEventListener('mousemove', e => onPointer(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        onPointer(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    init();
    initViz();
    running = true;
}

document.getElementById('go').addEventListener('click', start);
</script>
</body>
</html>
