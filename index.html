<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0a0f;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: system-ui, sans-serif;
        }

        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            z-index: 100; cursor: pointer;
            background: #0a0a0f;
        }
        #enter.off { display: none; }
        #enter .circle {
            width: 120px; height: 120px;
            border-radius: 50%;
            border: 1px solid rgba(255,220,180,0.15);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.3s;
        }
        #enter:hover .circle { border-color: rgba(255,220,180,0.4); }
        #enter .inner {
            width: 40px; height: 40px;
            border-radius: 50%;
            background: rgba(255,220,180,0.08);
        }

        #world {
            position: fixed; inset: 0;
            display: none;
            background: radial-gradient(ellipse at center, #12111a 0%, #0a0a0f 100%);
        }
        #world.on { display: block; }

        canvas { position: fixed; inset: 0; }

        #vibe {
            position: fixed; bottom: 40px; left: 0; right: 0;
            display: flex; justify-content: center; gap: 30px;
            z-index: 50;
        }
        .vibe-btn {
            font-size: 11px;
            color: rgba(255,220,180,0.25);
            background: none; border: none;
            padding: 12px 20px;
            cursor: pointer;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .vibe-btn.on { color: rgba(255,220,180,0.9); }

        #pulse {
            position: fixed; top: 20px; left: 20px;
            font-size: 10px;
            color: rgba(255,220,180,0.3);
            letter-spacing: 1px;
        }
    </style>
</head>
<body>

<div id="enter">
    <div class="circle"><div class="inner"></div></div>
</div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="vibe">
        <button class="vibe-btn on" data-vibe="dream">DREAM</button>
        <button class="vibe-btn" data-vibe="pulse">PULSE</button>
        <button class="vibe-btn" data-vibe="deep">DEEP</button>
    </div>
    <div id="pulse"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════
// GUMP - The Universal Song
// Your movement is the music. The music is your movement.
// ═══════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ─────────────────────────────────────────────────────────────────
// THE STATE - What the world feels like right now
// ─────────────────────────────────────────────────────────────────

const world = {
    x: 0.5,           // Position 0-1
    y: 0.5,
    vx: 0,            // Velocity (for momentum)
    vy: 0,
    energy: 0,        // How much movement (0-1)
    stillness: 0,     // How long still (builds over time)
    time: 0,
    breath: 0,        // Slow oscillation for life
    pulse: 0,         // Fast pulse for rhythm
};

let vibe = 'dream';   // Current vibe: dream, pulse, deep
let ctx, master;      // Audio context
let canvas, vc;       // Visual canvas

// ─────────────────────────────────────────────────────────────────
// THE VIBES - Three completely different worlds
// ─────────────────────────────────────────────────────────────────

const VIBES = {
    dream: {
        bpm: 70,
        key: 0,           // C
        scale: [0, 2, 4, 7, 9],  // Pentatonic - universal
        bassOctave: 1,
        padWarmth: 0.8,
        reverbSize: 0.7,
        character: 'warm'
    },
    pulse: {
        bpm: 110,
        key: 5,           // F
        scale: [0, 3, 5, 7, 10],  // Minor pentatonic
        bassOctave: 2,
        padWarmth: 0.4,
        reverbSize: 0.4,
        character: 'driving'
    },
    deep: {
        bpm: 85,
        key: 7,           // G
        scale: [0, 2, 3, 5, 7, 9, 10],  // Dorian - jazzy
        bassOctave: 1,
        padWarmth: 0.6,
        reverbSize: 0.85,
        character: 'deep'
    }
};

// ─────────────────────────────────────────────────────────────────
// THE SOUND ENGINE - Immediate response to movement
// ─────────────────────────────────────────────────────────────────

let kickBuffer, snareBuffer, hatBuffer;
let bassSynth, padSynth, leadSynth;
let masterGain, reverbGain, compressor;
let sidechain = 1;

function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master chain
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.8;

    // Compressor for glue
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -12;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.15;

    // Reverb
    const reverbBuffer = createReverbBuffer(3.0);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.25;

    // Routing
    masterGain.connect(compressor);
    masterGain.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);
    compressor.connect(ctx.destination);

    // Create drum sounds
    kickBuffer = createKick();
    snareBuffer = createSnare();
    hatBuffer = createHat();

    // Create synths
    initBass();
    initPad();
    initLead();
}

function createReverbBuffer(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            // Exponential decay with early reflections
            const t = i / ctx.sampleRate;
            const decay = Math.exp(-t / (duration * 0.4));
            const diffusion = (Math.random() * 2 - 1);
            data[i] = diffusion * decay * 0.5;
        }
    }
    return buffer;
}

// ─────────────────────────────────────────────────────────────────
// DRUMS - The heartbeat. Must feel IMMEDIATE.
// ─────────────────────────────────────────────────────────────────

function createKick() {
    const length = ctx.sampleRate * 0.5;
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < length; i++) {
        const t = i / ctx.sampleRate;
        // Pitch drops from 150hz to 40hz
        const pitch = 40 + 110 * Math.exp(-t * 40);
        // Clean sine with fast attack
        const osc = Math.sin(TAU * pitch * t);
        // Punchy envelope
        const env = Math.exp(-t * 8) * Math.min(1, t * 500);
        // Subtle click
        const click = Math.exp(-t * 100) * 0.3;

        data[i] = (osc * env + click) * 0.9;
    }
    return buffer;
}

function createSnare() {
    const length = ctx.sampleRate * 0.3;
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < length; i++) {
        const t = i / ctx.sampleRate;
        // Tone + noise
        const tone = Math.sin(TAU * 180 * t) * Math.exp(-t * 30);
        const noise = (Math.random() * 2 - 1) * Math.exp(-t * 15);

        data[i] = (tone * 0.4 + noise * 0.6) * 0.7;
    }
    return buffer;
}

function createHat() {
    const length = ctx.sampleRate * 0.1;
    const buffer = ctx.createBuffer(1, length, ctx.sampleRate);
    const data = buffer.getChannelData(0);

    for (let i = 0; i < length; i++) {
        const t = i / ctx.sampleRate;
        // High frequency noise
        const noise = (Math.random() * 2 - 1) * Math.exp(-t * 50);
        data[i] = noise * 0.3;
    }
    return buffer;
}

function playDrum(buffer, volume = 1, when = 0) {
    const source = ctx.createBufferSource();
    source.buffer = buffer;

    const gain = ctx.createGain();
    gain.gain.value = volume;

    source.connect(gain);
    gain.connect(masterGain);

    source.start(ctx.currentTime + when);

    // Trigger sidechain
    if (buffer === kickBuffer) {
        sidechain = 0.3;
    }
}

// ─────────────────────────────────────────────────────────────────
// BASS - The foundation. Felt more than heard.
// ─────────────────────────────────────────────────────────────────

let bassOsc, bassGain, bassFilter;

function initBass() {
    bassOsc = ctx.createOscillator();
    bassOsc.type = 'sine';
    bassOsc.frequency.value = 55;

    bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 200;
    bassFilter.Q.value = 1;

    bassGain = ctx.createGain();
    bassGain.gain.value = 0;

    bassOsc.connect(bassFilter);
    bassFilter.connect(bassGain);
    bassGain.connect(masterGain);

    bassOsc.start();
}

function playBassNote(note, velocity = 0.6, duration = 0.5) {
    const v = VIBES[vibe];
    const freq = 55 * Math.pow(2, (v.key + note) / 12) * v.bassOctave;

    const now = ctx.currentTime;

    // Frequency glide
    bassOsc.frequency.setTargetAtTime(freq, now, 0.02);

    // Envelope - punchy attack, smooth release
    bassGain.gain.cancelScheduledValues(now);
    bassGain.gain.setValueAtTime(bassGain.gain.value, now);
    bassGain.gain.linearRampToValueAtTime(velocity * 0.7 * sidechain, now + 0.01);
    bassGain.gain.linearRampToValueAtTime(velocity * 0.5 * sidechain, now + duration * 0.3);
    bassGain.gain.linearRampToValueAtTime(0.001, now + duration);

    // Filter opens with velocity
    bassFilter.frequency.setTargetAtTime(150 + velocity * 200, now, 0.01);
}

// ─────────────────────────────────────────────────────────────────
// PAD - The warmth. Responds to stillness.
// ─────────────────────────────────────────────────────────────────

let padOscs = [], padGain, padFilter;

function initPad() {
    padGain = ctx.createGain();
    padGain.gain.value = 0;

    padFilter = ctx.createBiquadFilter();
    padFilter.type = 'lowpass';
    padFilter.frequency.value = 800;
    padFilter.Q.value = 0.5;

    // 4 oscillators for rich pad
    for (let i = 0; i < 4; i++) {
        const osc = ctx.createOscillator();
        osc.type = i % 2 === 0 ? 'sine' : 'triangle';
        osc.frequency.value = 220;
        osc.detune.value = (i - 1.5) * 8; // Slight detune for warmth

        const oscGain = ctx.createGain();
        oscGain.gain.value = 0.15;

        osc.connect(oscGain);
        oscGain.connect(padFilter);
        osc.start();

        padOscs.push({ osc, gain: oscGain });
    }

    padFilter.connect(padGain);
    padGain.connect(masterGain);
}

function updatePad(chord) {
    const v = VIBES[vibe];
    const baseFreq = 110 * Math.pow(2, v.key / 12);

    padOscs.forEach((p, i) => {
        const note = chord[i % chord.length];
        const freq = baseFreq * Math.pow(2, note / 12);
        p.osc.frequency.setTargetAtTime(freq, ctx.currentTime, 0.3);
    });

    // Pad volume from stillness - reward for being calm
    const targetVol = world.stillness * v.padWarmth * 0.25;
    padGain.gain.setTargetAtTime(targetVol, ctx.currentTime, 0.5);

    // Filter opens with stillness
    padFilter.frequency.setTargetAtTime(400 + world.stillness * 1200, ctx.currentTime, 0.3);
}

// ─────────────────────────────────────────────────────────────────
// LEAD - The melody. Follows your movement.
// ─────────────────────────────────────────────────────────────────

let leadOsc, leadGain, leadFilter;

function initLead() {
    leadOsc = ctx.createOscillator();
    leadOsc.type = 'triangle';
    leadOsc.frequency.value = 440;

    leadFilter = ctx.createBiquadFilter();
    leadFilter.type = 'lowpass';
    leadFilter.frequency.value = 2000;
    leadFilter.Q.value = 2;

    leadGain = ctx.createGain();
    leadGain.gain.value = 0;

    leadOsc.connect(leadFilter);
    leadFilter.connect(leadGain);
    leadGain.connect(masterGain);

    leadOsc.start();
}

function triggerLead(note, velocity = 0.5) {
    const v = VIBES[vibe];
    const freq = 220 * Math.pow(2, (v.key + note) / 12);

    const now = ctx.currentTime;

    leadOsc.frequency.setTargetAtTime(freq, now, 0.02);

    leadGain.gain.cancelScheduledValues(now);
    leadGain.gain.setValueAtTime(0.001, now);
    leadGain.gain.linearRampToValueAtTime(velocity * 0.15, now + 0.01);
    leadGain.gain.exponentialRampToValueAtTime(0.001, now + 0.8);

    leadFilter.frequency.setTargetAtTime(1000 + velocity * 3000, now, 0.01);
}

// ─────────────────────────────────────────────────────────────────
// THE RHYTHM - The heartbeat that everything syncs to
// ─────────────────────────────────────────────────────────────────

let beat = 0;
let lastBeatTime = 0;

function updateRhythm() {
    const v = VIBES[vibe];
    const beatDuration = 60 / v.bpm;
    const now = ctx.currentTime;

    if (now - lastBeatTime >= beatDuration) {
        lastBeatTime = now;
        onBeat(beat);
        beat++;
    }

    // Update pulse for visuals
    world.pulse = (now - lastBeatTime) / beatDuration;
}

function onBeat(beatNum) {
    const v = VIBES[vibe];
    const bar = Math.floor(beatNum / 4);
    const beatInBar = beatNum % 4;

    // ── KICK on 1 and 3 ──
    if (beatInBar === 0 || beatInBar === 2) {
        const kickVel = 0.7 + world.energy * 0.3;
        playDrum(kickBuffer, kickVel);
    }

    // ── SNARE on 2 and 4 ──
    if (beatInBar === 1 || beatInBar === 3) {
        const snareVel = 0.5 + world.energy * 0.3;
        playDrum(snareBuffer, snareVel);
    }

    // ── HATS - density from energy ──
    if (world.energy > 0.2 || beatInBar % 2 === 0) {
        const hatVel = 0.2 + world.energy * 0.3;
        playDrum(hatBuffer, hatVel);
    }

    // ── BASS - root on 1, movement on 3 ──
    const scale = v.scale;
    if (beatInBar === 0) {
        playBassNote(scale[0], 0.7, 60/v.bpm * 2);
    } else if (beatInBar === 2 && world.energy > 0.3) {
        // Fifth or octave based on energy
        const bassNote = world.energy > 0.6 ? 12 : scale[Math.floor(scale.length/2)];
        playBassNote(bassNote, 0.5, 60/v.bpm);
    }

    // ── PAD - update chord based on bar ──
    if (beatInBar === 0) {
        const chordRoot = scale[(bar % 4) * 2 % scale.length];
        const chord = [chordRoot, chordRoot + scale[2], chordRoot + scale[4], chordRoot + 12];
        updatePad(chord);
    }

    // ── LEAD - triggered by MOVEMENT ──
    if (world.energy > 0.15 && Math.random() < world.energy) {
        // Pick note from scale based on Y position
        const noteIndex = Math.floor(world.y * scale.length);
        const note = scale[noteIndex] + (world.y > 0.7 ? 12 : 0);
        triggerLead(note, world.energy);
    }
}

// ─────────────────────────────────────────────────────────────────
// INPUT - Your movement becomes music
// ─────────────────────────────────────────────────────────────────

function onMove(nx, ny) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.vx = world.vx * 0.8 + dx * 0.2;
    world.vy = world.vy * 0.8 + dy * 0.2;

    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.9 + movement * 8);

    // Reset stillness on movement
    if (movement > 0.01) {
        world.stillness = Math.max(0, world.stillness - 0.1);
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    world.x = Math.max(0, Math.min(1, world.x + ax * 0.08));
    world.y = Math.max(0, Math.min(1, world.y - ay * 0.08));

    const movement = Math.sqrt(ax*ax + ay*ay);
    world.energy = Math.min(1, world.energy * 0.85 + movement * 0.4);

    if (movement > 0.05) {
        world.stillness = Math.max(0, world.stillness - 0.05);
    }
}

// ─────────────────────────────────────────────────────────────────
// VISUALS - Minimal. The sound is the focus.
// ─────────────────────────────────────────────────────────────────

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    // Fade
    vc.fillStyle = `rgba(10,10,15,${0.15 + world.energy * 0.1})`;
    vc.fillRect(0, 0, w, h);

    // Center breath
    const breathSize = 50 + Math.sin(world.breath) * 10 + world.pulse * 20;
    const breathAlpha = 0.03 + world.stillness * 0.05;
    vc.strokeStyle = `rgba(255,220,180,${breathAlpha})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w/2, h/2, breathSize, 0, TAU);
    vc.stroke();

    // Energy ring
    if (world.energy > 0.1) {
        const energySize = breathSize + 30 + world.energy * 50;
        vc.strokeStyle = `rgba(255,220,180,${world.energy * 0.15})`;
        vc.beginPath();
        vc.arc(w/2, h/2, energySize, 0, TAU);
        vc.stroke();
    }

    // Position indicator
    const px = world.x * w;
    const py = world.y * h;
    const pSize = 4 + world.energy * 15;
    vc.fillStyle = `rgba(255,220,180,${0.3 + world.energy * 0.5})`;
    vc.beginPath();
    vc.arc(px, py, pSize, 0, TAU);
    vc.fill();
}

// ─────────────────────────────────────────────────────────────────
// THE LOOP - Everything syncs here
// ─────────────────────────────────────────────────────────────────

function tick() {
    // Update world state
    world.time += 1/60;
    world.breath += 0.02;
    world.energy *= 0.995; // Slow decay
    world.stillness = Math.min(1, world.stillness + 0.005); // Builds when still

    // Sidechain recovery
    sidechain = Math.min(1, sidechain + 0.15);

    // Update rhythm
    updateRhythm();

    // Update reverb based on vibe
    const v = VIBES[vibe];
    reverbGain.gain.setTargetAtTime(v.reverbSize * 0.3, ctx.currentTime, 0.1);

    // Draw
    draw();

    // Status
    document.getElementById('pulse').textContent =
        `${vibe} · ${Math.round(world.energy * 100)}%`;

    requestAnimationFrame(tick);
}

// ─────────────────────────────────────────────────────────────────
// INIT
// ─────────────────────────────────────────────────────────────────

function initVibeButtons() {
    document.querySelectorAll('.vibe-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            document.querySelectorAll('.vibe-btn').forEach(b => b.classList.remove('on'));
            btn.classList.add('on');
            vibe = btn.dataset.vibe;
            beat = 0; // Reset beat on vibe change
        });
    });
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    // Request motion permissions on iOS
    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    initAudio();
    initVisuals();
    initVibeButtons();

    // Input handlers
    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    // Start the loop
    if (ctx.state === 'suspended') await ctx.resume();
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
