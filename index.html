<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        #orb {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,1), rgba(255,255,255,0.2));
            box-shadow: 0 0 120px rgba(255,255,255,0.8), 
                        0 0 60px rgba(255,255,255,0.6),
                        inset -10px -10px 20px rgba(0,0,0,0.3);
            transition: all 0.15s ease-out;
            z-index: 1000;
            pointer-events: none;
        }

        #orb.recording {
            background: radial-gradient(circle at 30% 30%, #ff0000, #660000);
            box-shadow: 0 0 150px #ff0000, 
                        0 0 80px #ff0000,
                        inset -10px -10px 20px rgba(0,0,0,0.5);
            transform: scale(1.2);
        }

        #orb.beat {
            transform: scale(1.3);
            box-shadow: 0 0 200px rgba(255,255,255,1), 
                        0 0 100px rgba(255,255,255,0.8);
        }

        .status {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
            text-transform: uppercase;
        }

        .status.visible {
            opacity: 0.7;
        }

        .hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 2s;
            text-transform: uppercase;
        }

        .hint.visible {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div id="orb"></div>
    <div id="status" class="status"></div>
    <div id="hint" class="hint">Click anywhere to begin</div>

    <script>
        'use strict';

        // The beat machine that actually slaps
        class GUMP {
            constructor() {
                this.ctx = null;
                this.isInitialized = false;
                this.isRecording = false;
                this.recordBuffer = [];
                this.samples = new Map();
                this.loops = [];
                
                // Tempo and swing
                this.bpm = 72; // That slow, heavy Kanye tempo
                this.swing = 0.15;
                this.currentStep = 0;
                
                // Visual elements
                this.orb = document.getElementById('orb');
                this.status = document.getElementById('status');
                this.hint = document.getElementById('hint');
                
                // Track mouse
                document.addEventListener('mousemove', (e) => {
                    this.orb.style.left = e.clientX + 'px';
                    this.orb.style.top = e.clientY + 'px';
                });
                
                // Init on click
                document.addEventListener('click', () => this.init());
                
                // Show hint
                setTimeout(() => this.hint.classList.add('visible'), 500);
            }

            async init() {
                if (this.isInitialized) {
                    this.toggleRecording();
                    return;
                }

                try {
                    // Create audio context with optimal settings
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });

                    // Build the signal chain
                    this.buildMasterChain();
                    
                    // Create drum sounds
                    this.createDrumKit();
                    
                    // Setup microphone
                    await this.setupMicrophone();
                    
                    // Create the intro sequence
                    this.scheduleIntro();
                    
                    // Setup keyboard controls
                    this.setupControls();
                    
                    this.isInitialized = true;
                    this.hint.textContent = 'Space to sample â€¢ Hold to clear';
                    
                    console.log('GUMP initialized - let\'s make beats');

                } catch (err) {
                    console.error('Failed to initialize:', err);
                    this.status.textContent = 'Failed to initialize';
                    this.status.classList.add('visible');
                }
            }

            buildMasterChain() {
                // Master gain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.95;

                // Bus compressor for glue
                this.busComp = this.ctx.createDynamicsCompressor();
                this.busComp.threshold.value = -8;
                this.busComp.knee.value = 3;
                this.busComp.ratio.value = 4;
                this.busComp.attack.value = 0.01;
                this.busComp.release.value = 0.1;

                // Warmth - low shelf EQ
                this.warmth = this.ctx.createBiquadFilter();
                this.warmth.type = 'lowshelf';
                this.warmth.frequency.value = 150;
                this.warmth.gain.value = 4;

                // Presence - high shelf EQ
                this.presence = this.ctx.createBiquadFilter();
                this.presence.type = 'highshelf';
                this.presence.frequency.value = 8000;
                this.presence.gain.value = 3;

                // Soft clipper using waveshaper
                this.clipper = this.ctx.createWaveShaper();
                this.clipper.curve = this.makeSoftClipCurve();
                this.clipper.oversample = '2x';

                // Final limiter
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -1;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                // Connect the chain
                this.master.connect(this.busComp);
                this.busComp.connect(this.warmth);
                this.warmth.connect(this.presence);
                this.presence.connect(this.clipper);
                this.clipper.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);

                // Create separate buses
                this.drumBus = this.ctx.createGain();
                this.drumBus.gain.value = 1;
                this.drumBus.connect(this.master);

                this.sampleBus = this.ctx.createGain();
                this.sampleBus.gain.value = 0.8;
                this.sampleBus.connect(this.master);
            }

            makeSoftClipCurve() {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    // Soft clipping formula
                    curve[i] = Math.sign(x) * Math.min(Math.abs(x), 0.9 + 0.1 * Math.tanh(10 * (Math.abs(x) - 0.9)));
                }
                
                return curve;
            }

            createDrumKit() {
                // Store drum sounds
                this.drums = {
                    kick: this.synthesizeKick(),
                    snare: this.synthesizeSnare(),
                    hihat: this.synthesizeHihat(),
                    openhat: this.synthesizeOpenHat(),
                    clap: this.synthesizeClap(),
                    perc: this.synthesizePerc()
                };
            }

            synthesizeKick() {
                const duration = 0.8;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Pitch envelope: starts at 120Hz, drops to 45Hz
                    const pitch = 120 * Math.exp(-35 * t) + 45;
                    
                    // Amplitude envelope with punch
                    const amp = Math.exp(-3 * t) * (1 - 0.5 * t);
                    
                    // Main tone
                    let sample = Math.sin(2 * Math.PI * pitch * t) * amp;
                    
                    // Add click for punch (first 5ms)
                    if (t < 0.005) {
                        sample += Math.sin(2 * Math.PI * 4000 * t) * (1 - t * 200) * 0.3;
                    }
                    
                    // Add harmonics for beef
                    sample += Math.sin(4 * Math.PI * pitch * t) * amp * 0.15;
                    
                    // Soft clip
                    data[i] = Math.tanh(sample * 1.5) * 0.9;
                }
                
                return buffer;
            }

            synthesizeSnare() {
                const duration = 0.2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Envelope
                    const env = Math.exp(-35 * t);
                    
                    // Tone component (200Hz and 250Hz for body)
                    const tone = (Math.sin(2 * Math.PI * 200 * t) + 
                                 Math.sin(2 * Math.PI * 250 * t)) * 0.3;
                    
                    // Noise component
                    const noise = (Math.random() * 2 - 1) * 0.7;
                    
                    // Mix and apply envelope
                    data[i] = (tone + noise) * env * 0.8;
                    
                    // Add snap in first 2ms
                    if (t < 0.002) {
                        data[i] += Math.sin(2 * Math.PI * 1500 * t) * (1 - t * 500) * 0.5;
                    }
                }
                
                return buffer;
            }

            synthesizeHihat() {
                const duration = 0.05;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-200 * t);
                    
                    // High-passed noise
                    let sample = (Math.random() * 2 - 1);
                    
                    // Simple high-pass filter simulation
                    if (i > 0) {
                        sample = sample - data[i - 1] * 0.95;
                    }
                    
                    data[i] = sample * env * 0.8;
                }
                
                return buffer;
            }

            synthesizeOpenHat() {
                const duration = 0.3;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-6 * t);
                    
                    // Metallic noise
                    let sample = (Math.random() * 2 - 1);
                    
                    // Add some ringing
                    sample += Math.sin(2 * Math.PI * 5000 * t) * 0.1;
                    sample += Math.sin(2 * Math.PI * 7500 * t) * 0.05;
                    
                    // High-pass
                    if (i > 0) {
                        sample = sample - data[i - 1] * 0.9;
                    }
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeClap() {
                const duration = 0.15;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Multiple short bursts to simulate clap
                const clapTimes = [0, 0.01, 0.025];
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    let sample = 0;
                    
                    for (const clapTime of clapTimes) {
                        if (t >= clapTime && t < clapTime + 0.02) {
                            const localT = t - clapTime;
                            const env = Math.exp(-100 * localT);
                            sample += (Math.random() * 2 - 1) * env;
                        }
                    }
                    
                    data[i] = sample * 0.7;
                }
                
                return buffer;
            }

            synthesizePerc() {
                const duration = 0.1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-50 * t);
                    
                    // Wood block sound
                    const freq = 800 + Math.sin(2 * Math.PI * 20 * t) * 200;
                    let sample = Math.sin(2 * Math.PI * freq * t);
                    
                    // Add click
                    if (t < 0.002) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 500);
                    }
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            async setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.micSource = this.ctx.createMediaStreamSource(stream);
                    
                    // Create a script processor for recording
                    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.recorder.onaudioprocess = (e) => {
                        if (this.isRecording) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            this.recordBuffer.push(...inputData);
                            
                            // Auto-stop after 8 seconds
                            if (this.recordBuffer.length > this.ctx.sampleRate * 8) {
                                this.stopRecording();
                            }
                        }
                    };
                    
                } catch (err) {
                    console.log('Microphone not available');
                    this.hint.textContent = 'Click to play';
                }
            }

            scheduleIntro() {
                const startTime = this.ctx.currentTime + 0.1;
                const beat = 60 / this.bpm;
                
                // Epic 8-bar intro that builds
                const intro = [
                    // Bar 1 - Sparse kick
                    { time: 0, sound: 'kick', vel: 0.6 },
                    { time: beat * 2, sound: 'kick', vel: 0.4 },
                    
                    // Bar 2 - Add ghost kicks
                    { time: beat * 4, sound: 'kick', vel: 0.8 },
                    { time: beat * 5.5, sound: 'kick', vel: 0.3 },
                    { time: beat * 6, sound: 'kick', vel: 0.5 },
                    
                    // Bar 3 - Introduce hats
                    { time: beat * 8, sound: 'kick', vel: 0.9 },
                    { time: beat * 8.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 9, sound: 'hihat', vel: 0.4 },
                    { time: beat * 9.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 10, sound: 'kick', vel: 0.5 },
                    { time: beat * 10.5, sound: 'hihat', vel: 0.4 },
                    
                    // Bar 4 - Build tension
                    { time: beat * 12, sound: 'kick', vel: 1 },
                    { time: beat * 12.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 13, sound: 'snare', vel: 0.6 },
                    { time: beat * 13.5, sound: 'hihat', vel: 0.4 },
                    { time: beat * 14, sound: 'kick', vel: 0.7 },
                    { time: beat * 14.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 15, sound: 'snare', vel: 0.5 },
                    { time: beat * 15.5, sound: 'snare', vel: 0.4 },
                    
                    // Bar 5-8 - Full pattern drops
                ];
                
                // Schedule intro hits
                intro.forEach(hit => {
                    this.scheduleSound(hit.sound, startTime + hit.time, hit.vel);
                });
                
                // Start main loop after intro
                setTimeout(() => {
                    this.startMainLoop();
                }, beat * 16 * 1000);
            }

            scheduleSound(sound, time, velocity = 1) {
                const source = this.ctx.createBufferSource();
                const gainNode = this.ctx.createGain();
                
                source.buffer = this.drums[sound];
                gainNode.gain.value = velocity;
                
                // Add slight pitch variation for life
                source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.02;
                
                source.connect(gainNode);
                gainNode.connect(this.drumBus);
                
                source.start(time);
                
                // Visual feedback
                const delay = (time - this.ctx.currentTime) * 1000;
                if (delay >= 0 && delay < 100) {
                    setTimeout(() => {
                        this.orb.classList.add('beat');
                        setTimeout(() => this.orb.classList.remove('beat'), 50);
                    }, delay);
                }
            }

            startMainLoop() {
                const beat = 60 / this.bpm;
                const sixteenth = beat / 4;
                let nextTime = this.ctx.currentTime;
                
                // Main pattern - that bounce
                const pattern = {
                    kick: [0, 10, 20, 22],
                    snare: [8, 24],
                    hihat: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
                    openhat: [14, 30],
                    clap: [8, 24],
                    perc: [5, 13, 21, 29]
                };
                
                const loop = () => {
                    const currentTime = this.ctx.currentTime;
                    
                    // Schedule ahead
                    while (nextTime < currentTime + 0.1) {
                        const step = this.currentStep % 32;
                        
                        // Apply swing to off-beats
                        let swingOffset = 0;
                        if (step % 2 === 1) {
                            swingOffset = sixteenth * this.swing;
                        }
                        
                        // Schedule hits
                        Object.entries(pattern).forEach(([sound, steps]) => {
                            if (steps.includes(step)) {
                                let velocity = 0.8;
                                
                                // Velocity variations
                                if (sound === 'hihat') {
                                    velocity = step % 4 === 0 ? 0.6 : 0.4;
                                } else if (sound === 'kick' && step === 0) {
                                    velocity = 1;
                                }
                                
                                this.scheduleSound(sound, nextTime + swingOffset, velocity);
                            }
                        });
                        
                        // Trigger samples
                        if (step === 0 && this.loops.length > 0) {
                            this.triggerSampleLoop(nextTime);
                        }
                        
                        this.currentStep++;
                        nextTime += sixteenth;
                    }
                    
                    requestAnimationFrame(loop);
                };
                
                loop();
            }

            toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                if (!this.micSource) return;
                
                this.isRecording = true;
                this.recordBuffer = [];
                this.orb.classList.add('recording');
                this.status.textContent = 'Recording...';
                this.status.classList.add('visible');
                
                // Connect mic to recorder
                this.micSource.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
            }

            stopRecording() {
                this.isRecording = false;
                this.orb.classList.remove('recording');
                this.status.classList.remove('visible');
                
                // Disconnect
                try {
                    this.micSource.disconnect(this.recorder);
                    this.recorder.disconnect();
                } catch (e) {}
                
                // Process if we have enough audio
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                    this.processSample();
                }
            }

            processSample() {
                // Create buffer from recording
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                // Find loop points (4 bars)
                const barLength = this.ctx.sampleRate * 60 / this.bpm * 4;
                const loopLength = Math.min(buffer.length, barLength);
                
                // Create perfectly looped buffer
                const loopBuffer = this.ctx.createBuffer(1, Math.floor(loopLength), this.ctx.sampleRate);
                const sourceData = buffer.getChannelData(0);
                const loopData = loopBuffer.getChannelData(0);
                
                // Copy with crossfade at loop point
                const fadeLength = 100; // samples
                for (let i = 0; i < loopLength; i++) {
                    let sample = sourceData[i];
                    
                    // Fade in
                    if (i < fadeLength) {
                        sample *= i / fadeLength;
                    }
                    
                    // Fade out
                    if (i > loopLength - fadeLength) {
                        sample *= (loopLength - i) / fadeLength;
                    }
                    
                    loopData[i] = sample;
                }
                
                // Store the loop
                this.loops.push({
                    buffer: loopBuffer,
                    playing: null
                });
                
                // Keep only last 4 loops
                if (this.loops.length > 4) {
                    const removed = this.loops.shift();
                    if (removed.playing) {
                        removed.playing.stop();
                    }
                }
                
                this.status.textContent = `Sample ${this.loops.length} ready`;
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }

            triggerSampleLoop(time) {
                // Play all loops
                this.loops.forEach((loop, index) => {
                    // Stop previous instance
                    if (loop.playing) {
                        loop.playing.stop(time);
                    }
                    
                    // Create new source
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    source.buffer = loop.buffer;
                    source.loop = true;
                    
                    // Different processing for each layer
                    filter.type = 'lowpass';
                    filter.frequency.value = 20000 - (index * 3000);
                    filter.Q.value = 1;
                    
                    // Gain based on layer
                    gainNode.gain.value = 0.7 - (index * 0.1);
                    
                    // Connect
                    source.connect(filter);
                    filter.connect(gainNode);
                    gainNode.connect(this.sampleBus);
                    
                    source.start(time);
                    loop.playing = source;
                    
                    // Add movement to filter
                    const lfoRate = 0.1 + (index * 0.05);
                    const animateFilter = () => {
                        if (loop.playing === source) {
                            const now = this.ctx.currentTime;
                            const mod = Math.sin(now * lfoRate) * 0.5 + 0.5;
                            filter.frequency.value = 2000 + mod * (18000 - index * 3000);
                            requestAnimationFrame(animateFilter);
                        }
                    };
                    animateFilter();
                });
            }

            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        this.toggleRecording();
                    }
                });
                
                // Hold space to clear samples
                let spaceHoldTimer;
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.repeat) {
                        spaceHoldTimer = setTimeout(() => {
                            this.clearSamples();
                        }, 1000);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        clearTimeout(spaceHoldTimer);
                    }
                });
            }

            clearSamples() {
                this.loops.forEach(loop => {
                    if (loop.playing) {
                        loop.playing.stop();
                    }
                });
                this.loops = [];
                
                this.status.textContent = 'Samples cleared';
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }
        }

        // Initialize GUMP
        const gump = new GUMP();
    </script>
</body>
</html>
