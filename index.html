<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI DJ Live Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
            --fib233: 144px;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }
        /* Fibonacci spiral visualization */
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }
        #spiral.active {
            opacity: 0.03;
        }
        /* Ghost title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }
        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }
        /* Start circle - golden ratio proportions */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.03) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }
        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }
        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }
        /* Main interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }
        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        /* Record button */
        .record-button {
            position: fixed;
            bottom: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib89);
            height: var(--fib89);
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.13);
            cursor: pointer;
            transition: all 0.382s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .record-button.recording {
            background: rgba(255,0,0,0.21);
            border-color: rgba(255,0,0,0.34);
            animation: recordPulse 1.618s ease-in-out infinite;
        }
        @keyframes recordPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.13); }
        }
        .record-dot {
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: rgba(255,255,255,0.21);
            transition: all 0.382s ease;
        }
        .record-button.recording .record-dot {
            background: rgba(255,0,0,0.618);
        }
        /* Motion indicator */
        .motion-field {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            line-height: var(--phi);
        }
        .motion-value {
            font-size: var(--fib13);
            opacity: 0.618;
        }
        /* Outfit selector */
        .outfits {
            position: fixed;
            top: var(--fib55);
            right: var(--fib55);
            display: grid;
            gap: var(--fib8);
            grid-template-columns: repeat(2, var(--fib55));
        }
        .outfit {
            width: var(--fib55);
            height: var(--fib55);
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            cursor: pointer;
            transition: all 0.382s ease;
            position: relative;
            overflow: hidden;
        }
        .outfit:hover {
            border-color: rgba(255,255,255,0.21);
            background: rgba(255,255,255,0.05);
        }
        .outfit.active {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.08);
        }
        .outfit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: var(--outfit-color, rgba(255,255,255,0.21));
            transition: all 0.382s ease;
        }
        .outfit.cosmic::after { --outfit-color: rgba(138,43,226,0.618); }
        .outfit.urban::after { --outfit-color: rgba(255,140,0,0.618); }
        .outfit.nature::after { --outfit-color: rgba(34,139,34,0.618); }
        .outfit.minimal::after { --outfit-color: rgba(255,255,255,0.382); }
        /* Sample slots - 4 elements */
        .sample-slots {
            position: fixed;
            bottom: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--fib13);
        }
        .sample-slot {
            width: var(--fib55);
            height: var(--fib13);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
            transition: all 0.382s ease;
        }
        .sample-slot.filled {
            border-color: rgba(255,255,255,0.21);
        }
        .sample-slot.playing {
            border-color: rgba(255,255,255,0.55);
            box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.21);
        }
        .sample-slot::before {
            content: attr(data-type);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib5);
            letter-spacing: var(--fib2);
            opacity: 0.382;
            text-transform: uppercase;
        }
        .sample-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.618;
        }
        /* Processing indicator */
        .processing {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.382s ease;
        }
        .processing.active {
            opacity: 0.618;
        }
        /* BPM indicator */
        .bpm-indicator {
            position: fixed;
            bottom: var(--fib55);
            right: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            text-align: right;
        }
        .bpm-value {
            font-size: var(--fib21);
            opacity: 0.618;
        }
        /* Canvas layers */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #spiral { z-index: 1; }
        #visualizer { z-index: 2; opacity: 0.21; }
        #particles { z-index: 3; opacity: 0.34; }
        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            animation: loading 1.618s ease-in-out infinite;
        }
        @keyframes loading {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.382; }
        }
    </style>
</head>
<body>
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
   
    <div class="title">AI DJ Live Sampler</div>
   
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
   
    <div class="interface" id="interface">
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
        </div>
       
        <div class="outfits">
            <div class="outfit cosmic active" data-outfit="cosmic"></div>
            <div class="outfit urban" data-outfit="urban"></div>
            <div class="outfit nature" data-outfit="nature"></div>
            <div class="outfit minimal" data-outfit="minimal"></div>
        </div>
       
        <div class="record-button" id="recordButton">
            <div class="record-dot"></div>
        </div>
       
        <div class="sample-slots">
            <div class="sample-slot" data-type="drums" data-index="0">
                <canvas class="sample-waveform" id="waveform0"></canvas>
            </div>
            <div class="sample-slot" data-type="bass" data-index="1">
                <canvas class="sample-waveform" id="waveform1"></canvas>
            </div>
            <div class="sample-slot" data-type="melody" data-index="2">
                <canvas class="sample-waveform" id="waveform2"></canvas>
            </div>
            <div class="sample-slot" data-type="lead" data-index="3">
                <canvas class="sample-waveform" id="waveform3"></canvas>
            </div>
        </div>
       
        <div class="bpm-indicator">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">120</div>
        </div>
       
        <div class="processing" id="processing">ANALYZING...</div>
    </div>
   
    <div class="loading" id="loading">AWAKENING...</div>
    <script>
        // AI DJ Live Sampler with Advanced Visuals and Auto Building
        class AIDJEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.masterGain = null;
                this.compressor = null;
                this.reverb = null;
                this.delay = null;
                this.analyser = null;
               
                // Advanced sampler system
                this.sampler = {
                    slots: [
                        { type: 'drums', filled: false, buffer: null, analysis: null, player: null },
                        { type: 'bass', filled: false, buffer: null, analysis: null, player: null },
                        { type: 'melody', filled: false, buffer: null, analysis: null, player: null },
                        { type: 'lead', filled: false, buffer: null, analysis: null, player: null }
                    ],
                    currentSlot: 0,
                    isRecordingClip: false,
                    clipData: [],
                    recordStartTime: 0,
                    stream: null,
                    source: null,
                    processor: null,
                    quantizeGrid: 16 // 16th notes
                };
               
                // Motion & Environment
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: [],
                    pattern: 'still',
                    intensity: 0,
                    direction: { x: 0, y: 0 },
                    lastAccel: { x: 0, y: 0, z: 0 }
                };
               
                // Musical state
                this.outfit = 'cosmic';
                this.phi = 1.618033988749;
                this.bpm = 120; // Default
                this.currentBeat = 0;
                this.swing = 0.05;
                this.key = 'A';
                this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
               
                // Timing
                this.scheduler = {
                    nextNoteTime: 0,
                    scheduleAheadTime: 0.1,
                    lookahead: 25.0,
                    timerId: null
                };
               
                // Stadium beat
                this.stadiumBeatActive = false;
                this.drumPatterns = {
                    kick: [1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], // Stomping on 1,3,5,7
                    clap: [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0], // Claps on off-beats
                    tom: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1] // Rolling tribal toms
                };
               
                // Visual elements
                this.elements = {};
                this.canvases = {};
               
                // Initialize
                this.init();
            }
           
            init() {
                // Cache DOM elements
                ['start', 'interface', 'loading', 'motionValue', 'recordButton',
                 'processing', 'bpmValue'].forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });
               
                // Cache canvases
                ['spiral', 'visualizer', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                });
               
                // Sample slot waveform canvases
                for (let i = 0; i < 4; i++) {
                    const canvas = document.getElementById(`waveform${i}`);
                    this.canvases[`waveform${i}`] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                }
               
                // Event listeners
                this.elements.start.addEventListener('click', () => this.begin());
               
                // Outfit selection
                document.querySelectorAll('.outfit').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.outfit').forEach(o => o.classList.remove('active'));
                        e.target.classList.add('active');
                        this.outfit = e.target.dataset.outfit;
                        this.updateOutfitParameters();
                    });
                });
               
                // Resize handling
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
               
                // Draw initial spiral
                this.drawFibonacciSpiral();
            }
           
            resizeCanvases() {
                Object.values(this.canvases).forEach(({ canvas }) => {
                    if (canvas.id.startsWith('waveform')) {
                        canvas.width = canvas.parentElement.offsetWidth;
                        canvas.height = canvas.parentElement.offsetHeight;
                    } else {
                        canvas.width = window.innerWidth;
                        canvas.height = window.innerHeight;
                    }
                });
            }
           
            drawFibonacciSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 400;
               
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
               
                let a = 0, b = 1;
                let angle = 0;
               
                for (let i = 0; i < 13; i++) {
                    const radius = b * scale;
                   
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(angle) * a * scale,
                        centerY + Math.sin(angle) * a * scale,
                        radius,
                        angle,
                        angle + Math.PI / 2
                    );
                    ctx.stroke();
                   
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                }
            }
           
            async begin() {
                this.elements.loading.style.display = 'block';
                this.elements.start.style.display = 'none';
               
                try {
                    // Request permissions
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                   
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                   
                    // Get microphone access
                    this.sampler.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                   
                    // Setup everything
                    this.setupAudioChain();
                    this.setupMotionDetection();
                    this.setupSampler();
                   
                    // Start interface
                    this.elements.loading.style.display = 'none';
                    this.elements.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');
                   
                    // Start the engine
                    this.startEngine();
                   
                    // Start automatic building
                    this.startBuilding();
                   
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.elements.loading.textContent = 'PERMISSION NEEDED';
                }
            }
           
            setupAudioChain() {
                // Master compression
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -6;
                this.compressor.knee.value = 6;
                this.compressor.ratio.value = 8;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
               
                // Master gain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.7;
               
                // Reverb with stadium feel
                this.reverb = this.ctx.createConvolver();
                this.createStadiumReverbImpulse();
               
                // Delay
                this.delay = this.ctx.createDelay(1.0);
                this.delay.delayTime.value = 0.375; // 3/8 for triplet feel
                this.delayFeedback = this.ctx.createGain();
                this.delayFeedback.gain.value = 0.4;
                this.delayGain = this.ctx.createGain();
                this.delayGain.gain.value = 0.3;
               
                // Analyser
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.85;
               
                // Connect effects chain
                this.delay.connect(this.delayFeedback);
                this.delayFeedback.connect(this.delay);
                this.delay.connect(this.delayGain);
               
                // Master chain
                this.masterGain.connect(this.compressor);
                this.masterGain.connect(this.reverb);
                this.masterGain.connect(this.delay);
               
                this.compressor.connect(this.analyser);
                this.reverb.connect(this.analyser);
                this.delayGain.connect(this.analyser);
               
                this.analyser.connect(this.ctx.destination);
            }
           
            createStadiumReverbImpulse() {
                const length = this.ctx.sampleRate * 4; // Longer for stadium
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
               
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 1.5); // Slower decay
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.4;
                       
                        // Add echoes for stadium
                        if (i % Math.floor(this.ctx.sampleRate * 0.05) === 0) {
                            channelData[i] += (Math.random() * 2 - 1) * 0.6 * decay;
                        }
                    }
                }
               
                this.reverb.buffer = impulse;
            }
           
            setupMotionDetection() {
                // Device motion
                window.addEventListener('devicemotion', (e) => {
                    if (!e.accelerationIncludingGravity) return;
                   
                    const { x, y, z } = e.accelerationIncludingGravity;
                    const dx = Math.abs(x - this.motion.lastAccel.x);
                    const dy = Math.abs(y - this.motion.lastAccel.y);
                    const dz = Math.abs(z - this.motion.lastAccel.z);
                   
                    const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    this.updateMotion(magnitude);
                   
                    this.motion.direction = { x: x / 10, y: y / 10 };
                    this.motion.lastAccel = { x, y, z };
                });
               
                // Mouse fallback with better tracking
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', (e) => {
                    const now = performance.now();
                    const dt = Math.max(1, now - lastMouse.time);
                   
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                   
                    this.updateMotion(velocity * 15);
                   
                    this.motion.direction = {
                        x: (e.clientX / window.innerWidth - 0.5) * 2,
                        y: (e.clientY / window.innerHeight - 0.5) * 2
                    };
                   
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                });
            }
           
            updateMotion(value) {
                this.motion.current = value;
                this.motion.smoothed = this.motion.smoothed * 0.85 + value * 0.15;
               
                this.motion.history.push(this.motion.smoothed);
                if (this.motion.history.length > 89) {
                    this.motion.history.shift();
                }
               
                // Analyze pattern
                const avg = this.motion.history.reduce((a, b) => a + b, 0) / this.motion.history.length;
                const variance = this.motion.history.reduce((sum, m) => sum + Math.abs(m - avg), 0) / this.motion.history.length;
               
                this.motion.intensity = Math.min(1, variance / 5);
               
                if (avg < 0.5) this.motion.pattern = 'still';
                else if (variance < 1) this.motion.pattern = 'steady';
                else if (variance < 3) this.motion.pattern = 'flowing';
                else this.motion.pattern = 'chaotic';
               
                // Update UI
                this.elements.motionValue.textContent = this.motion.smoothed.toFixed(3);
               
                // Modulate BPM based on motion
                const targetBPM = 120 + Math.floor(this.motion.smoothed * 8) * 5;
                this.bpm = Math.round(this.bpm * 0.95 + targetBPM * 0.05);
                this.elements.bpmValue.textContent = this.bpm;
            }
           
            setupSampler() {
                // Create source from microphone
                this.sampler.source = this.ctx.createMediaStreamSource(this.sampler.stream);
               
                // Create script processor for recording
                this.sampler.processor = this.ctx.createScriptProcessor(4096, 1, 1);
               
                // Pre-recording analysis node
                this.inputAnalyser = this.ctx.createAnalyser();
                this.inputAnalyser.fftSize = 2048;
                this.inputAnalyser.smoothingTimeConstant = 0.8;
               
                // Connect for monitoring
                this.sampler.source.connect(this.inputAnalyser);
               
                this.sampler.processor.onaudioprocess = (e) => {
                    if (this.sampler.isRecordingClip) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        this.sampler.clipData.push(...inputData);
                    }
                };
               
                // Connect processor
                this.sampler.source.connect(this.sampler.processor);
                this.sampler.processor.connect(this.ctx.destination); // Required for processor
            }
           
            startBuilding() {
                // Automatically build layers
                this.buildNextLayer();
            }
           
            buildNextLayer() {
                // Check if all slots filled
                if (this.sampler.slots.every(slot => slot.filled)) return;
               
                this.startClipRecording();
            }
           
            startClipRecording() {
                this.sampler.clipData = [];
                this.sampler.isRecordingClip = true;
                this.elements.recordButton.classList.add('recording');
               
                // Random duration 1-4 seconds
                const duration = (Math.random() * 3 + 1) * 1000;
                setTimeout(() => this.stopClipRecording(), duration);
            }
           
            async stopClipRecording() {
                this.sampler.isRecordingClip = false;
                this.elements.recordButton.classList.remove('recording');
               
                // Process the recorded clip
                if (this.sampler.clipData.length > 0) {
                    this.elements.processing.classList.add('active');
                    await this.processRecording();
                    this.elements.processing.classList.remove('active');
                }
               
                // Continue building after short delay
                setTimeout(() => this.buildNextLayer(), 1000);
            }
           
            async processRecording() {
                const recordData = new Float32Array(this.sampler.clipData);
                if (recordData.length < this.ctx.sampleRate * 0.1) return; // Too short
               
                // Create audio buffer
                const buffer = this.ctx.createBuffer(1, recordData.length, this.ctx.sampleRate);
                const channelData = buffer.getChannelData(0);
                channelData.set(recordData);
               
                // Analyze the recording
                const analysis = await this.analyzeRecording(recordData, buffer);
               
                // Determine which slot type this should be
                const slotType = this.categorizeSound(analysis);
                let targetSlot = -1;
               
                // Find appropriate empty slot
                for (let i = 0; i < 4; i++) {
                    if (this.sampler.slots[i].type === slotType && !this.sampler.slots[i].filled) {
                        targetSlot = i;
                        break;
                    }
                }
                if (targetSlot === -1) {
                    // Find any empty slot
                    targetSlot = this.sampler.slots.findIndex(slot => !slot.filled);
                }
                if (targetSlot === -1) return; // All filled
               
                // Process and store
                const processedBuffer = await this.processForSlot(buffer, analysis, slotType);
               
                // Store in slot
                const slot = this.sampler.slots[targetSlot];
                slot.filled = true;
                slot.buffer = processedBuffer;
                slot.analysis = analysis;
               
                // Create player
                slot.player = this.createSlotPlayer(targetSlot, slotType, analysis);
               
                // Update UI
                document.querySelectorAll('.sample-slot')[targetSlot].classList.add('filled');
                this.drawWaveform(targetSlot, processedBuffer);
               
                // Start playing
                this.scheduleSlot(targetSlot);
               
                // Check for stadium beat drop
                const filledCount = this.sampler.slots.filter(slot => slot.filled).length;
                if (filledCount >= 3 && !this.stadiumBeatActive) {
                    this.stadiumBeatActive = true;
                    // Increase reverb for stadium feel
                    this.reverbSend = this.ctx.createGain();
                    this.reverbSend.gain.value = 0.5;
                    this.masterGain.connect(this.reverbSend);
                    this.reverbSend.connect(this.reverb);
                }
            }
           
            async analyzeRecording(data, buffer) {
                const analysis = {
                    duration: buffer.duration,
                    tempo: null,
                    beats: [],
                    onsets: [],
                    pitch: null,
                    harmonics: [],
                    spectralCentroid: 0,
                    rms: 0,
                    peak: 0,
                    dynamicRange: 0,
                    brightness: 0,
                    noisiness: 0,
                    tonality: 0
                };
               
                // Peak detection
                analysis.peak = Math.max(...data.map(Math.abs));
               
                // RMS
                analysis.rms = Math.sqrt(data.reduce((sum, x) => sum + x * x, 0) / data.length);
               
                // Onset detection
                analysis.onsets = this.detectOnsets(data);
               
                // Tempo detection
                if (analysis.onsets.length > 3) {
                    const intervals = [];
                    for (let i = 1; i < analysis.onsets.length; i++) {
                        intervals.push(analysis.onsets[i] - analysis.onsets[i-1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    const samplesPerBeat = avgInterval;
                    const beatsPerSecond = this.ctx.sampleRate / samplesPerBeat;
                    analysis.tempo = beatsPerSecond * 60;
                }
               
                // Spectral analysis
                const fftSize = 2048;
                const offlineCtx = new OfflineAudioContext(1, buffer.length, this.ctx.sampleRate);
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const analyser = offlineCtx.createAnalyser();
                analyser.fftSize = fftSize;
                source.connect(analyser);
                analyser.connect(offlineCtx.destination);
                source.start();
               
                await offlineCtx.startRendering();
                const fft = new Float32Array(fftSize / 2);
                analyser.getFloatFrequencyData(fft);
               
                // Spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
                for (let i = 0; i < fft.length; i++) {
                    const magnitude = Math.pow(10, fft[i] / 20);
                    const frequency = (i * this.ctx.sampleRate) / fftSize;
                    weightedSum += magnitude * frequency;
                    magnitudeSum += magnitude;
                }
                analysis.spectralCentroid = weightedSum / magnitudeSum || 0;
               
                // Brightness
                analysis.brightness = analysis.spectralCentroid / 1000;
               
                // Pitch
                analysis.pitch = this.detectPitch(data);
               
                // Noisiness
                const zeroCrossings = this.countZeroCrossings(data);
                analysis.noisiness = Math.min(1, zeroCrossings / (data.length * 0.5));
                analysis.tonality = 1 - analysis.noisiness;
               
                return analysis;
            }
           
            detectOnsets(data) {
                const windowSize = 1024;
                const hopSize = 512;
                const onsets = [];
               
                let previousEnergy = 0;
               
                for (let i = 0; i < data.length - windowSize; i += hopSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                   
                    const energyDiff = energy - previousEnergy;
                    if (energyDiff > previousEnergy * 0.3 && energy > 0.01) {
                        onsets.push(i);
                    }
                   
                    previousEnergy = energy;
                }
               
                return onsets;
            }
           
            detectPitch(data) {
                const minPeriod = Math.floor(this.ctx.sampleRate / 800);
                const maxPeriod = Math.floor(this.ctx.sampleRate / 80);
               
                let maxCorrelation = 0;
                let bestPeriod = 0;
               
                for (let period = minPeriod; period < maxPeriod && period < data.length / 2; period++) {
                    let correlation = 0;
                    for (let i = 0; i < data.length - period; i++) {
                        correlation += data[i] * data[i + period];
                    }
                    correlation /= data.length - period;
                   
                    if (correlation > maxCorrelation) {
                        maxCorrelation = correlation;
                        bestPeriod = period;
                    }
                }
               
                return bestPeriod > 0 ? this.ctx.sampleRate / bestPeriod : 0;
            }
           
            countZeroCrossings(data) {
                let crossings = 0;
                for (let i = 1; i < data.length; i++) {
                    if ((data[i-1] >= 0) !== (data[i] >= 0)) {
                        crossings++;
                    }
                }
                return crossings;
            }
           
            categorizeSound(analysis) {
                const centroid = analysis.spectralCentroid;
                const tonality = analysis.tonality;
                const hasRhythm = analysis.onsets.length > 4;
               
                if (centroid < 200 && tonality > 0.7) {
                    return 'bass';
                } else if (centroid > 2000 && hasRhythm && tonality < 0.3) {
                    return 'drums';
                } else if (centroid > 800 && tonality > 0.6) {
                    return 'lead';
                } else {
                    return 'melody';
                }
            }
           
            async processForSlot(buffer, analysis, slotType) {
                // High fidelity processing
                const processedBuffer = this.ctx.createBuffer(
                    buffer.numberOfChannels,
                    buffer.length,
                    buffer.sampleRate
                );
               
                // Copy data
                for (let channel = 0; channel < buffer.numberOfChannels; channel++) {
                    processedBuffer.copyToChannel(buffer.getChannelData(channel), channel);
                }
               
                // Apply type-specific high-fid processing
                switch (slotType) {
                    case 'drums':
                        return this.processDrums(processedBuffer, analysis);
                    case 'bass':
                        return this.processBass(processedBuffer, analysis);
                    case 'melody':
                        return this.processMelody(processedBuffer, analysis);
                    case 'lead':
                        return this.processLead(processedBuffer, analysis);
                }
               
                return processedBuffer;
            }
           
            processDrums(buffer, analysis) {
                const data = buffer.getChannelData(0);
               
                // Loop optimization for seamless
                const beatLength = this.ctx.sampleRate * 60 / this.bpm / 4;
                const targetLength = Math.round(beatLength * 16);
               
                let bestLoopEnd = Math.min(targetLength, data.length);
                let bestCorrelation = 0;
               
                const searchWindow = beatLength * 2;
                for (let i = Math.max(0, targetLength - searchWindow); i < Math.min(targetLength + searchWindow, data.length); i++) {
                    let correlation = 0;
                    const compareLength = Math.min(1024, i);
                   
                    for (let j = 0; j < compareLength; j++) {
                        correlation += data[j] * data[i - compareLength + j];
                    }
                   
                    if (correlation > bestCorrelation) {
                        bestCorrelation = correlation;
                        bestLoopEnd = i;
                    }
                }
               
                const loopedBuffer = this.ctx.createBuffer(1, bestLoopEnd, buffer.sampleRate);
                loopedBuffer.getChannelData(0).set(data.subarray(0, bestLoopEnd));
               
                // Apply compression for punch
                // Simulated: normalize
                let max = 0;
                for (let i = 0; i < bestLoopEnd; i++) {
                    max = Math.max(max, Math.abs(loopedBuffer.getChannelData(0)[i]));
                }
                if (max > 0) {
                    const gain = 1 / max;
                    for (let i = 0; i < bestLoopEnd; i++) {
                        loopedBuffer.getChannelData(0)[i] *= gain;
                    }
                }
               
                return loopedBuffer;
            }
           
            processBass(buffer, analysis) {
                const data = buffer.getChannelData(0);
               
                // Pitch correction
                if (analysis.pitch > 0) {
                    const nearestNote = this.getNearestNote(analysis.pitch);
                    const pitchRatio = nearestNote.frequency / analysis.pitch;
                   
                    const resampledLength = Math.floor(buffer.length / pitchRatio);
                    const resampledBuffer = this.ctx.createBuffer(1, resampledLength, buffer.sampleRate);
                    const resampledData = resampledBuffer.getChannelData(0);
                   
                    for (let i = 0; i < resampledLength; i++) {
                        const sourceIndex = i * pitchRatio;
                        const index = Math.floor(sourceIndex);
                        const fraction = sourceIndex - index;
                       
                        if (index < data.length - 1) {
                            resampledData[i] = data[index] * (1 - fraction) + data[index + 1] * fraction;
                        } else {
                            resampledData[i] = data[index] || 0;
                        }
                    }
                   
                    return resampledBuffer;
                }
               
                return buffer;
            }
           
            processMelody(buffer, analysis) {
                // Slice best phrase
                const slices = this.sliceMelodicContent(buffer, analysis);
               
                if (slices.length > 0) {
                    const bestSlice = slices[0];
                    const sliceBuffer = this.ctx.createBuffer(
                        1,
                        bestSlice.end - bestSlice.start,
                        buffer.sampleRate
                    );
                   
                    const data = buffer.getChannelData(0);
                    const sliceData = sliceBuffer.getChannelData(0);
                   
                    for (let i = 0; i < sliceData.length; i++) {
                        sliceData[i] = data[bestSlice.start + i];
                    }
                   
                    return sliceBuffer;
                }
               
                return buffer;
            }
           
            processLead(buffer, analysis) {
                // Add slight saturation for fidelity
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    const x = data[i];
                    data[i] = x < 0 ? -Math.pow(Math.abs(x), 0.8) : Math.pow(x, 0.8);
                }
                return buffer;
            }
           
            getNearestNote(frequency) {
                const A4 = 440;
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
               
                const semitones = 12 * Math.log2(frequency / A4);
                const nearestSemitone = Math.round(semitones);
               
                const nearestFrequency = A4 * Math.pow(2, nearestSemitone / 12);
               
                const noteIndex = (nearestSemitone + 9 + 48) % 12;
                const octave = Math.floor((nearestSemitone + 9 + 48) / 12) - 1;
               
                return {
                    frequency: nearestFrequency,
                    note: noteNames[noteIndex],
                    octave: octave
                };
            }
           
            sliceMelodicContent(buffer, analysis) {
                const slices = [];
                const data = buffer.getChannelData(0);
               
                for (let i = 0; i < analysis.onsets.length - 1; i++) {
                    const start = analysis.onsets[i];
                    const end = analysis.onsets[i + 1];
                   
                    let energy = 0;
                    for (let j = start; j < end && j < data.length; j++) {
                        energy += data[j] * data[j];
                    }
                   
                    if (energy > 0.001) {
                        slices.push({
                            start,
                            end,
                            energy,
                            duration: (end - start) / this.ctx.sampleRate
                        });
                    }
                }
               
                slices.sort((a, b) => b.energy - a.energy);
               
                return slices;
            }
           
            createSlotPlayer(slotIndex, slotType, analysis) {
                const player = {
                    slotIndex,
                    slotType,
                    analysis,
                    isPlaying: false,
                    nextPlayTime: 0,
                    playbackRate: 1,
                    gain: 0.7,
                    pattern: this.getPatternForType(slotType),
                    currentStep: 0
                };
               
                // Adjust playback rate to match BPM
                if (analysis.tempo) {
                    player.playbackRate = analysis.tempo / this.bpm;
                }
               
                return player;
            }
           
            getPatternForType(type) {
                switch (type) {
                    case 'drums':
                        return [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,1,0];
                    case 'bass':
                        return [1,0,0,1, 0,0,1,0, 1,0,0,0, 1,0,0,0];
                    case 'melody':
                        return [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0];
                    case 'lead':
                        return [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0];
                    default:
                        return [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0];
                }
            }
           
            scheduleSlot(slotIndex) {
                const slot = this.sampler.slots[slotIndex];
                if (!slot.filled || !slot.player) return;
               
                slot.player.isPlaying = true;
            }
           
            drawWaveform(slotIndex, buffer) {
                const { ctx, canvas } = this.canvases[`waveform${slotIndex}`];
                const data = buffer.getChannelData(0);
               
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.618)';
                ctx.lineWidth = 1;
               
                const step = Math.ceil(data.length / canvas.width);
                const amp = canvas.height / 2;
               
                ctx.beginPath();
                for (let i = 0; i < canvas.width; i++) {
                    const index = i * step;
                    const value = data[Math.min(index, data.length - 1)] || 0;
                    const y = amp + value * amp * 0.8;
                   
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
            }
           
            updateOutfitParameters() {
                switch (this.outfit) {
                    case 'cosmic':
                        this.scale = [0, 2, 3, 5, 7, 8, 10];
                        this.swing = 0.05;
                        break;
                    case 'urban':
                        this.scale = [0, 3, 5, 6, 7, 10];
                        this.swing = 0.15;
                        break;
                    case 'nature':
                        this.scale = [0, 2, 4, 5, 7, 9, 11];
                        this.swing = 0.1;
                        break;
                    case 'minimal':
                        this.scale = [0, 2, 5, 7, 9];
                        this.swing = 0;
                        break;
                }
            }
           
            startEngine() {
                // Start scheduler
                this.startScheduler();
               
                // Start visualizations
                this.animate();
               
                // Generate atmospheric base
                this.generateAtmosphere();
            }
           
            startScheduler() {
                const scheduleNote = () => {
                    while (this.scheduler.nextNoteTime < this.ctx.currentTime + this.scheduler.scheduleAheadTime) {
                        this.scheduleStep();
                        this.nextNote();
                    }
                    this.scheduler.timerId = setTimeout(scheduleNote, this.scheduler.lookahead);
                };
               
                this.scheduler.nextNoteTime = this.ctx.currentTime;
                scheduleNote();
            }
           
            scheduleStep() {
                const stepTime = this.scheduler.nextNoteTime;
               
                // Play each active slot
                this.sampler.slots.forEach((slot, index) => {
                    if (slot.filled && slot.player && slot.player.isPlaying) {
                        const pattern = slot.player.pattern;
                        const step = this.currentBeat % 16;
                       
                        if (pattern[step] === 1) {
                            this.playSlot(index, stepTime);
                        }
                    }
                });
               
                // Stadium beat if active
                if (this.stadiumBeatActive) {
                    const step = this.currentBeat % 16;
                   
                    if (this.drumPatterns.kick[step]) this.playKick(stepTime);
                    if (this.drumPatterns.clap[step]) this.playClap(stepTime);
                    if (this.drumPatterns.tom[step]) this.playTom(stepTime);
                }
               
                // Generative notes
                if (this.motion.intensity > 0.3 && this.currentBeat % 4 === 0) {
                    this.playGenerativeNote(stepTime);
                }
            }
           
            playSlot(slotIndex, when) {
                const slot = this.sampler.slots[slotIndex];
                if (!slot.buffer) return;
               
                const source = this.ctx.createBufferSource();
                source.buffer = slot.buffer;
                source.loop = true;
               
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                const motionMod = 1 + this.motion.intensity * 0.5;
                source.playbackRate.value = slot.player.playbackRate * motionMod;
               
                filter.type = 'lowpass';
                filter.frequency.value = 1000 + this.motion.smoothed * 1000;
                filter.Q.value = 1 + this.motion.intensity * 5;
               
                gain.gain.value = slot.player.gain * (0.7 + this.motion.intensity * 0.3);
               
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
               
                source.start(when);
               
                // UI feedback
                const slotElement = document.querySelectorAll('.sample-slot')[slotIndex];
                slotElement.classList.add('playing');
                setTimeout(() => slotElement.classList.remove('playing'), 100);
            }
           
            playKick(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
               
                osc.type = 'sine';
                osc.frequency.setValueAtTime(150, when);
                osc.frequency.exponentialRampToValueAtTime(0.01, when + 0.5);
               
                gain.gain.setValueAtTime(1, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.5);
               
                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);
               
                osc.start(when);
                osc.stop(when + 0.5);
            }
           
            playClap(when) {
                const noise = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;
               
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 0.5;
               
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.5, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.2);
               
                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);
               
                noise.start(when);
                noise.stop(when + 0.2);
            }
           
            playTom(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
               
                osc.type = 'sine';
                osc.frequency.setValueAtTime(200 + Math.random() * 100, when);
                osc.frequency.exponentialRampToValueAtTime(0.01, when + 0.3);
               
                gain.gain.setValueAtTime(0.7, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.3);
               
                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);
               
                osc.start(when);
                osc.stop(when + 0.3);
            }
           
            playGenerativeNote(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                const noteIndex = Math.floor(this.motion.direction.x * this.scale.length + this.scale.length / 2);
                const note = this.scale[Math.abs(noteIndex) % this.scale.length];
                const octave = 3 + Math.floor(this.motion.direction.y + 1);
               
                const frequency = 440 * Math.pow(2, (note - 9) / 12 + (octave - 4));
               
                osc.type = 'sine';
                osc.frequency.value = frequency;
               
                filter.type = 'bandpass';
                filter.frequency.value = frequency;
                filter.Q.value = 5 + this.motion.intensity * 10;
               
                const duration = 0.1 + this.motion.intensity * 0.3;
               
                gain.gain.setValueAtTime(0, when);
                gain.gain.linearRampToValueAtTime(0.1 * (1 - this.motion.intensity * 0.5), when + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.001, when + duration);
               
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);
               
                osc.start(when);
                osc.stop(when + duration);
            }
           
            nextNote() {
                const secondsPerBeat = 60.0 / this.bpm / 4;
                this.scheduler.nextNoteTime += secondsPerBeat;
               
                if (this.currentBeat % 2 === 1) {
                    this.scheduler.nextNoteTime += secondsPerBeat * this.swing;
                }
               
                this.currentBeat++;
            }
           
            generateAtmosphere() {
                const createDrone = () => {
                    if (!this.ctx) return;
                   
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                   
                    const baseFreq = 55 * Math.pow(2, this.scale[0] / 12);
                   
                    osc1.type = 'triangle';
                    osc1.frequency.value = baseFreq;
                    osc1.detune.value = this.motion.smoothed * 5;
                   
                    osc2.type = 'triangle';
                    osc2.frequency.value = baseFreq * this.phi;
                    osc2.detune.value = -this.motion.smoothed * 5;
                   
                    filter.type = 'lowpass';
                    filter.frequency.value = 200 + this.motion.smoothed * 100;
                    filter.Q.value = 5;
                   
                    const now = this.ctx.currentTime;
                    const duration = 13;
                   
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.05, now + 3);
                    gain.gain.setValueAtTime(0.05, now + duration - 3);
                    gain.gain.linearRampToValueAtTime(0, now + duration);
                   
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.reverb);
                   
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + duration);
                    osc2.stop(now + duration);
                   
                    setTimeout(createDrone, 8000);
                };
               
                createDrone();
            }
           
            animate() {
                const draw = () => {
                    requestAnimationFrame(draw);
                   
                    this.drawVisualizer();
                    this.drawParticles();
                };
               
                draw();
            }
           
            drawVisualizer() {
                const { ctx, canvas } = this.canvases.visualizer;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
               
                this.analyser.getByteFrequencyData(dataArray);
               
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
               
                const barWidth = canvas.width / bufferLength * 2.5;
                let x = 0;
               
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height * 0.7;
                   
                    const hue = (i / bufferLength) * 360 + this.currentBeat;
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                   
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                   
                    x += barWidth + 1;
                }
            }
           
            drawParticles() {
                const { ctx, canvas } = this.canvases.particles;
               
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
               
                const count = 8 + Math.floor(this.motion.intensity * 13);
                const time = Date.now() * 0.001;
               
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + time * 0.1;
                    const radius = 50 + this.motion.smoothed * 100 + Math.sin(time + i) * 20;
                   
                    const x = canvas.width / 2 + Math.cos(angle) * radius;
                    const y = canvas.height / 2 + Math.sin(angle) * radius;
                   
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + this.motion.intensity * 2, 0, Math.PI * 2);
                   
                    const alpha = 0.3 + this.motion.intensity * 0.5;
                    ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    ctx.fill();
                }
            }
        }
       
        // Initialize
        const aiDj = new AIDJEngine();
    </script>
</body>
</html>
