<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;color:#fff;font-family:system-ui;height:100vh;overflow:hidden;touch-action:none}
        #start{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;z-index:10}
        #start.off{display:none}
        .title{font-size:10px;letter-spacing:8px;opacity:0.4}
        .sub{font-size:20px;font-weight:200;letter-spacing:3px}
        button{width:100px;height:100px;border-radius:50%;background:transparent;border:1px solid #0fa;color:#0fa;font:inherit;font-size:9px;letter-spacing:2px;cursor:pointer;transition:0.3s}
        button:hover{background:#0fa;color:#000}
        .hint{font-size:9px;opacity:0.25;text-align:center;max-width:200px;line-height:1.5}
        #app{display:none;height:100vh}
        #app.on{display:block}
        canvas{position:fixed;inset:0;width:100%;height:100%}
        .hud{position:fixed;font-size:8px;letter-spacing:1px;opacity:0.3;z-index:5}
        .tl{top:16px;left:16px}
        .tr{top:16px;right:16px;text-align:right}
        .bl{bottom:16px;left:16px}
        .br{bottom:16px;right:16px;text-align:right}
        .v{font-size:11px;margin-top:3px;opacity:0.7}
    </style>
</head>
<body>
<div id="start">
    <div class="title">GUMP</div>
    <div class="sub">Grand Unified Music Project</div>
    <button id="go">ENTER</button>
    <div class="hint">Move through space. You are the instrument.</div>
</div>
<div id="app">
    <canvas id="c"></canvas>
    <div class="hud tl"><div>MODE</div><div class="v" id="mode">BUILDING</div></div>
    <div class="hud tr"><div>FLOW</div><div class="v" id="flw">0</div></div>
    <div class="hud bl"><div>LAYERS</div><div class="v" id="layers">0</div></div>
    <div class="hud br"><div>BEAT</div><div class="v" id="beat">1</div></div>
</div>
<script>
// GUMP - Grand Unified Music Project
// Space and time unified through movement

const PHI = 1.618033988749;
const HARMONIC_SERIES = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16];

// State - position in the unified field
const F = {
    x: 0, y: 0, z: 0,           // spatial position (-1 to 1)
    vx: 0, vy: 0, vz: 0,        // velocity
    speed: 0,                    // magnitude
    phase: 0,                    // temporal phase
    density: 0,                  // event density
    harmonic: 1,                 // current harmonic emphasis
    field: 0                     // field intensity
};

// Memory - the song builds itself
const M = {
    mode: 'building',           // 'building' or 'looping'
    tape: [],                   // recorded snapshots
    loopLen: 8,                 // beats in the base loop
    beatTime: 0.5,              // seconds per beat (PHI-derived)
    playhead: 0,                // current position in loop
    lastBeat: 0,                // last beat timestamp
    layers: [],                 // additional recorded layers
    activeLayer: null,          // layer being recorded now
    blend: 0.6                  // how much loop vs live (0=all live, 1=all loop)
};

let ctx, out;
let drones = [];
let running = false;

// The fundamental frequency - everything derives from this
const ROOT = 55; // A1 - low, powerful

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Simple, clean output
    out = ctx.createGain();
    out.gain.value = 0.6;

    // Gentle compression
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.ratio.value = 4;
    comp.attack.value = 0.01;
    comp.release.value = 0.3;

    // Warmth
    const warm = ctx.createBiquadFilter();
    warm.type = 'lowshelf';
    warm.frequency.value = 200;
    warm.gain.value = 3;

    out.connect(warm);
    warm.connect(comp);
    comp.connect(ctx.destination);

    // Create the drone field - harmonics of the root
    createDroneField();
}

function createDroneField() {
    // 8 drones based on harmonic series
    // Position in space controls which harmonics are audible

    for (let i = 0; i < 8; i++) {
        const harmonic = HARMONIC_SERIES[i];
        const freq = ROOT * harmonic;

        // Each drone has multiple detuned oscillators for richness
        const osc1 = ctx.createOscillator();
        const osc2 = ctx.createOscillator();
        const gain = ctx.createGain();
        const pan = ctx.createStereoPanner();
        const filter = ctx.createBiquadFilter();

        osc1.type = 'sine';
        osc1.frequency.value = freq;

        osc2.type = 'sine';
        osc2.frequency.value = freq * 1.001; // slight detune

        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 1;

        gain.gain.value = 0; // start silent

        // Higher harmonics pan wider
        pan.pan.value = (i % 2 === 0 ? 1 : -1) * (i / 16);

        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain);
        gain.connect(pan);
        pan.connect(out);

        osc1.start();
        osc2.start();

        drones.push({ osc1, osc2, gain, filter, pan, harmonic, freq });
    }
}

// Snapshot the current state for recording
function snapshot() {
    return {
        x: F.x, y: F.y,
        speed: F.speed,
        density: F.density,
        amps: drones.map(d => d.gain.gain.value)
    };
}

// Memory system - record and playback
function updateMemory() {
    const now = ctx.currentTime;

    // Beat clock
    if (now - M.lastBeat >= M.beatTime) {
        M.lastBeat = now;

        if (M.mode === 'building') {
            // Record this beat
            M.tape.push(snapshot());

            // Check if base loop is complete
            if (M.tape.length >= M.loopLen) {
                M.mode = 'looping';
                M.playhead = 0;
            }
        } else {
            // Advance playhead
            M.playhead = (M.playhead + 1) % M.loopLen;

            // Record to active layer if exists
            if (M.activeLayer) {
                M.activeLayer.push(snapshot());
                if (M.activeLayer.length >= M.loopLen) {
                    M.layers.push(M.activeLayer);
                    M.activeLayer = null;
                    // Limit layers to prevent chaos
                    if (M.layers.length > 3) M.layers.shift();
                }
            }
        }
    }
}

// Get the blended state from memory + live input
function getBlendedState() {
    if (M.mode === 'building' || M.tape.length === 0) {
        return { x: F.x, y: F.y, speed: F.speed };
    }

    // Get recorded state at playhead
    const rec = M.tape[M.playhead];

    // Blend recorded with live
    const live = 1 - M.blend;
    const loop = M.blend;

    let x = rec.x * loop + F.x * live;
    let y = rec.y * loop + F.y * live;
    let speed = rec.speed * loop + F.speed * live;

    // Add layers on top
    M.layers.forEach((layer, li) => {
        const ls = layer[M.playhead];
        const layerWeight = 0.3 / (li + 1); // each layer quieter
        x += ls.x * layerWeight;
        y += ls.y * layerWeight;
        speed += ls.speed * layerWeight;
    });

    return { x: Math.max(-1, Math.min(1, x)), y: Math.max(-1, Math.min(1, y)), speed: Math.min(1, speed) };
}

function updateDrones() {
    const now = ctx.currentTime;

    // Get blended state (loop + live)
    const S = getBlendedState();

    drones.forEach((d, i) => {
        // Position in space determines harmonic mix
        // x-axis: odd vs even harmonics
        // y-axis: low vs high harmonics
        // z-axis (speed): attack/presence

        const isOdd = d.harmonic % 2 === 1;
        const oddEvenMix = isOdd ? (1 + S.x) / 2 : (1 - S.x) / 2;

        const heightFactor = i < 4 ? (1 - S.y) / 2 : (1 + S.y) / 2;

        const presence = 0.15 + S.speed * 0.4;

        // Combined amplitude
        let amp = oddEvenMix * heightFactor * presence;

        // Fundamental always present
        if (i === 0) amp = Math.max(amp, 0.2);

        // Higher harmonics quieter
        amp *= 1 / Math.sqrt(d.harmonic);

        // Smooth transition
        d.gain.gain.linearRampToValueAtTime(amp, now + 0.1);

        // Filter opens with speed
        const filterFreq = d.freq * (1 + S.speed * 3);
        d.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.1);

        // Subtle pitch bend based on position
        const bendCents = S.x * 10 + S.y * 5;
        const bendRatio = Math.pow(2, bendCents / 1200);
        d.osc1.frequency.linearRampToValueAtTime(d.freq * bendRatio, now + 0.1);
        d.osc2.frequency.linearRampToValueAtTime(d.freq * 1.001 * bendRatio, now + 0.1);
    });
}

// Rhythmic events - triggered by movement
let lastPulse = 0;
let pulseInterval = 0.5;

function pulse() {
    if (!ctx || F.speed < 0.05) return;

    const now = ctx.currentTime;

    // Pulse interval based on speed - faster movement = faster rhythm
    // But quantized to musical intervals using PHI
    const baseInterval = 0.8 / (1 + F.speed * 2);
    pulseInterval = baseInterval * Math.pow(PHI, Math.floor(F.density * 3) - 1);
    pulseInterval = Math.max(0.1, Math.min(2, pulseInterval));

    if (now - lastPulse < pulseInterval) return;
    lastPulse = now;

    // Choose harmonic based on position
    const harmonicIndex = Math.floor((F.y + 1) * 4) % 8;
    const freq = ROOT * HARMONIC_SERIES[harmonicIndex + 1];

    // Pluck sound
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // Waveform based on x position
    osc.type = F.x > 0 ? 'triangle' : 'sine';
    osc.frequency.value = freq * (F.y > 0 ? 2 : 1);

    filter.type = 'lowpass';
    filter.frequency.value = 1000 + F.speed * 3000;
    filter.Q.value = 2;

    // Quick attack, PHI-based decay
    const decay = 0.1 + (1 - F.speed) * 0.4;
    gain.gain.setValueAtTime(0.3 * F.speed, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + decay);

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(out);

    osc.start(now);
    osc.stop(now + decay + 0.1);

    // Occasional harmony note
    if (Math.random() < F.density * 0.3) {
        setTimeout(() => {
            if (!ctx) return;
            const osc2 = ctx.createOscillator();
            const g2 = ctx.createGain();
            osc2.type = 'sine';
            // Perfect fifth or octave
            osc2.frequency.value = freq * (Math.random() > 0.5 ? 1.5 : 2);
            g2.gain.setValueAtTime(0.1, ctx.currentTime);
            g2.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + decay * PHI);
            osc2.connect(g2);
            g2.connect(out);
            osc2.start();
            osc2.stop(ctx.currentTime + decay * PHI + 0.1);
        }, pulseInterval * 500 * (1 / PHI));
    }
}

// Motion handlers
function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    // Velocity from acceleration
    F.vx = F.vx * 0.8 + (a.x || 0) * 0.02;
    F.vy = F.vy * 0.8 + (a.y || 0) * 0.02;
    F.vz = F.vz * 0.8 + (a.z || 0) * 0.02;

    // Speed magnitude
    F.speed = Math.sqrt(F.vx*F.vx + F.vy*F.vy + F.vz*F.vz);
    F.speed = Math.min(1, F.speed / 3);

    // Density accumulates with movement
    F.density = F.density * 0.99 + F.speed * 0.01;
}

function onOrientation(e) {
    // Position in space from orientation
    F.x = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    F.y = Math.max(-1, Math.min(1, (e.beta || 0) / 45 - 1));

    // Field intensity from compass
    F.field = (e.alpha || 0) / 360;
}

// Mouse/touch fallback
function onPointer(x, y) {
    const px = (x / window.innerWidth) * 2 - 1;
    const py = 1 - (y / window.innerHeight) * 2;

    // Velocity from movement
    F.vx = F.vx * 0.7 + (px - F.x) * 0.3;
    F.vy = F.vy * 0.7 + (py - F.y) * 0.3;

    F.x = px;
    F.y = py;

    F.speed = Math.sqrt(F.vx*F.vx + F.vy*F.vy);
    F.speed = Math.min(1, F.speed * 3);

    F.density = F.density * 0.98 + F.speed * 0.02;
}

// Visualization
let vc;
function initViz() {
    const canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const canvas = document.getElementById('c');
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade based on density
    vc.fillStyle = `rgba(0,0,0,${0.05 + (1-F.density) * 0.1})`;
    vc.fillRect(0, 0, w, h);

    // Center follows blended position
    const S = getBlendedState();
    const cx = w/2 + S.x * w * 0.3;
    const cy = h/2 - S.y * h * 0.3;

    // Loop progress ring (outer)
    if (M.mode === 'looping' || M.tape.length > 0) {
        const loopR = Math.min(w, h) * 0.4;
        const progress = M.mode === 'building'
            ? M.tape.length / M.loopLen
            : M.playhead / M.loopLen;

        vc.beginPath();
        vc.arc(w/2, h/2, loopR, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
        vc.strokeStyle = M.mode === 'building' ? 'rgba(255,100,100,0.3)' : 'rgba(0,255,170,0.2)';
        vc.lineWidth = 3;
        vc.stroke();

        // Layer rings
        M.layers.forEach((_, i) => {
            vc.beginPath();
            vc.arc(w/2, h/2, loopR - 10 - i * 8, 0, Math.PI * 2);
            vc.strokeStyle = `rgba(0,255,170,${0.1 + i * 0.05})`;
            vc.lineWidth = 2;
            vc.stroke();
        });

        // Recording indicator
        if (M.activeLayer) {
            const recProgress = M.activeLayer.length / M.loopLen;
            vc.beginPath();
            vc.arc(w/2, h/2, loopR - 10 - M.layers.length * 8, -Math.PI/2, -Math.PI/2 + recProgress * Math.PI * 2);
            vc.strokeStyle = 'rgba(255,100,100,0.5)';
            vc.lineWidth = 2;
            vc.stroke();
        }
    }

    // Harmonic rings
    drones.forEach((d, i) => {
        const r = 20 + i * 25 + S.speed * 20;
        const alpha = d.gain.gain.value * 2;

        if (alpha > 0.01) {
            vc.beginPath();
            vc.arc(cx, cy, r, 0, Math.PI * 2);
            vc.strokeStyle = `hsla(${160 + i * 15}, 60%, 50%, ${alpha})`;
            vc.lineWidth = 1 + S.speed * 2;
            vc.stroke();
        }
    });

    // Core glow
    const gr = vc.createRadialGradient(cx, cy, 0, cx, cy, 50 + S.speed * 50);
    gr.addColorStop(0, `rgba(0,255,170,${0.3 + S.speed * 0.3})`);
    gr.addColorStop(1, 'transparent');
    vc.fillStyle = gr;
    vc.fillRect(0, 0, w, h);
}

function updateUI() {
    const modeText = M.mode === 'building'
        ? `BUILDING ${M.tape.length}/${M.loopLen}`
        : (M.activeLayer ? 'RECORDING' : 'LOOPING');
    document.getElementById('mode').textContent = modeText;
    document.getElementById('flw').textContent = F.speed.toFixed(2);
    document.getElementById('layers').textContent = M.layers.length + (M.activeLayer ? '+1' : '');
    document.getElementById('beat').textContent = M.playhead + 1;
}

// Main loop
function tick() {
    if (!running) return;

    F.phase += 0.01 * (1 + F.speed);

    updateMemory();

    // Auto-start new layer recording when significant movement in loop mode
    if (M.mode === 'looping' && !M.activeLayer && F.speed > 0.3) {
        M.activeLayer = [];
    }

    updateDrones();
    pulse();
    draw();
    updateUI();

    requestAnimationFrame(tick);
}

// Start
async function start() {
    document.getElementById('start').classList.add('off');
    document.getElementById('app').classList.add('on');

    // Request motion permission (iOS)
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);
    document.addEventListener('mousemove', e => onPointer(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        onPointer(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    init();
    initViz();
    running = true;
    tick();
}

document.getElementById('go').addEventListener('click', start);
</script>
</body>
</html>
