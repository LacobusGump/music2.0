<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>NEUROMANCER</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  user-select: none;
  overscroll-behavior: none;
}

body {
  background: #000;
  color: #fff;
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
  overflow: hidden;
  height: 100vh;
  height: 100dvh;
  position: fixed;
  width: 100%;
  touch-action: none;
}

/* Pure minimalist interface */
#universe {
  position: fixed;
  inset: 0;
  background: radial-gradient(ellipse at center, #0a0a0a 0%, #000 100%);
}

#canvas {
  position: fixed;
  inset: 0;
  opacity: 0.9;
}

/* Single status indicator */
#status {
  position: fixed;
  top: 20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 10px;
  letter-spacing: 3px;
  opacity: 0.3;
  text-transform: uppercase;
  transition: opacity 0.5s;
  z-index: 100;
}

#status.active {
  opacity: 0.8;
}

/* Energy orb - the only visual control */
#orb {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 120px;
  height: 120px;
  border-radius: 50%;
  background: radial-gradient(circle at 30% 30%, 
    rgba(0, 255, 255, 0.2),
    rgba(0, 255, 255, 0.05),
    transparent);
  border: 1px solid rgba(0, 255, 255, 0.1);
  cursor: pointer;
  transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
  z-index: 50;
}

#orb.recording {
  background: radial-gradient(circle at 30% 30%, 
    rgba(255, 0, 64, 0.4),
    rgba(255, 0, 64, 0.1),
    transparent);
  border-color: rgba(255, 0, 64, 0.5);
  animation: pulse 1s ease-in-out infinite;
}

#orb.processing {
  background: radial-gradient(circle at center, 
    rgba(255, 215, 0, 0.3),
    transparent);
  border-color: rgba(255, 215, 0, 0.3);
  animation: rotate 2s linear infinite;
}

@keyframes pulse {
  0%, 100% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.1); }
}

@keyframes rotate {
  to { transform: translate(-50%, -50%) rotate(360deg); }
}

/* Neural feedback visualization */
.neural-pulse {
  position: fixed;
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 1px solid rgba(0, 255, 255, 0.3);
  pointer-events: none;
  animation: expand 2s ease-out forwards;
}

@keyframes expand {
  to {
    width: 300px;
    height: 300px;
    opacity: 0;
  }
}

/* Minimal permission screen */
#gate {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: #000;
  z-index: 1000;
  cursor: pointer;
}

#gate.hidden {
  display: none;
}

#gate-text {
  font-size: 11px;
  letter-spacing: 4px;
  opacity: 0.5;
  animation: breathe 3s ease-in-out infinite;
}

@keyframes breathe {
  0%, 100% { opacity: 0.3; }
  50% { opacity: 0.8; }
}

/* Quantum particles */
.particle {
  position: fixed;
  width: 2px;
  height: 2px;
  background: #0ff;
  border-radius: 50%;
  pointer-events: none;
  opacity: 0;
}

/* Debug (hidden by default) */
#debug {
  position: fixed;
  bottom: 10px;
  right: 10px;
  font-size: 8px;
  font-family: monospace;
  opacity: 0.3;
  display: none;
  text-align: right;
  line-height: 1.4;
}

#debug.visible {
  display: block;
}

/* No UI clutter, pure experience */
</style>
</head>
<body>

<div id="universe"></div>
<canvas id="canvas"></canvas>
<div id="status">initializing</div>
<div id="orb"></div>

<div id="gate">
  <div id="gate-text">TAP TO BEGIN</div>
</div>

<div id="debug">
  <div>motion: <span id="debug-motion">0.00</span></div>
  <div>energy: <span id="debug-energy">0.00</span></div>
  <div>samples: <span id="debug-samples">0</span></div>
  <div>state: <span id="debug-state">void</span></div>
  <div>bpm: <span id="debug-bpm">0</span></div>
</div>

<script>
'use strict';

// NEUROMANCER v3.0 - Pure AI Music Engine
// Stripped down, focused, future-forward

class Neuromancer {
  constructor() {
    this.ctx = null;
    this.analyzer = null;
    this.nodes = {};
    
    // Core state - minimal
    this.state = {
      active: false,
      recording: false,
      motion: 0,
      energy: 0,
      chaos: 0,
      samples: [],
      currentState: 'void',
      bpm: 90,
      phase: 0
    };
    
    // Audio buffers
    this.recordBuffer = [];
    this.sampleBank = [];
    
    // Motion tracking
    this.motionHistory = [];
    this.lastAccel = { x: 0, y: 0, z: 0 };
    
    // Visual
    this.canvas = document.getElementById('canvas');
    this.canvasCtx = this.canvas.getContext('2d');
    this.particles = [];
    
    // Simplified config
    this.config = {
      sampleDuration: 2000, // 2 second samples
      maxSamples: 9,
      smoothing: 0.85
    };
    
    // Neural network for pattern generation
    this.neural = {
      weights: [],
      patterns: [],
      memory: []
    };
    
    this.init();
  }
  
  async init() {
    // Setup canvas
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());
    
    // Single tap to start
    document.getElementById('gate').addEventListener('click', () => this.start());
    
    // Orb is the only control - tap to sample
    document.getElementById('orb').addEventListener('click', () => this.handleOrb());
    
    // Debug toggle
    document.addEventListener('keydown', e => {
      if (e.key === 'd') document.getElementById('debug').classList.toggle('visible');
    });
    
    // Initialize neural patterns
    this.initializeNeural();
    
    // Start render loop
    this.render();
  }
  
  resizeCanvas() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  }
  
  async start() {
    document.getElementById('gate').classList.add('hidden');
    document.getElementById('status').textContent = 'awakening';
    
    try {
      // Create audio context
      this.ctx = new (window.AudioContext || window.webkitAudioContext)({
        latencyHint: 'interactive',
        sampleRate: 48000
      });
      
      // Get microphone
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false
        }
      });
      
      this.setupAudio(stream);
      this.setupMotion();
      
      // Start the engine
      this.state.active = true;
      this.startEngine();
      
      document.getElementById('status').textContent = 'listening';
      
    } catch(e) {
      console.error('Init failed:', e);
      // Fallback to synthesis-only mode
      this.startSynthOnly();
    }
  }
  
  setupAudio(stream) {
    // Minimal audio graph
    this.nodes.input = this.ctx.createMediaStreamSource(stream);
    this.nodes.analyser = this.ctx.createAnalyser();
    this.nodes.analyser.fftSize = 2048;
    this.nodes.analyser.smoothingTimeConstant = this.config.smoothing;
    
    // Recording processor
    this.nodes.recorder = this.ctx.createScriptProcessor(2048, 1, 1);
    this.nodes.recorder.onaudioprocess = (e) => {
      if (this.state.recording) {
        const data = e.inputBuffer.getChannelData(0);
        this.recordBuffer.push(...data);
      }
    };
    
    // Master output
    this.nodes.master = this.ctx.createGain();
    this.nodes.master.gain.value = 0.7;
    
    this.nodes.compressor = this.ctx.createDynamicsCompressor();
    this.nodes.compressor.threshold.value = -12;
    this.nodes.compressor.knee.value = 30;
    this.nodes.compressor.ratio.value = 12;
    
    // Spatial convolution reverb
    this.nodes.reverb = this.ctx.createConvolver();
    this.nodes.reverbGain = this.ctx.createGain();
    this.nodes.reverbGain.gain.value = 0.3;
    
    // Generate IR
    const length = this.ctx.sampleRate * 3;
    const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
    for (let channel = 0; channel < 2; channel++) {
      const data = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
      }
    }
    this.nodes.reverb.buffer = impulse;
    
    // Connect graph
    this.nodes.input.connect(this.nodes.analyser);
    this.nodes.input.connect(this.nodes.recorder);
    this.nodes.recorder.connect(this.ctx.destination); // Silent
    
    this.nodes.master.connect(this.nodes.compressor);
    this.nodes.compressor.connect(this.ctx.destination);
    
    this.nodes.reverb.connect(this.nodes.reverbGain);
    this.nodes.reverbGain.connect(this.nodes.compressor);
    
    this.analyzer = this.nodes.analyser;
  }
  
  async startSynthOnly() {
    // Minimal synth-only mode
    this.ctx = new AudioContext();
    
    this.nodes.master = this.ctx.createGain();
    this.nodes.master.gain.value = 0.7;
    this.nodes.master.connect(this.ctx.destination);
    
    this.state.active = true;
    this.startEngine();
    
    document.getElementById('status').textContent = 'synthesis mode';
  }
  
  setupMotion() {
    // Simplified motion detection
    const handleMotion = (e) => {
      const acc = e.accelerationIncludingGravity || e.acceleration;
      if (!acc) return;
      
      const dx = Math.abs(acc.x - this.lastAccel.x);
      const dy = Math.abs(acc.y - this.lastAccel.y);
      const dz = Math.abs(acc.z - this.lastAccel.z);
      
      const motion = Math.min(1, (dx + dy + dz) / 20);
      this.state.motion = this.state.motion * 0.9 + motion * 0.1;
      
      this.lastAccel = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
    };
    
    // iOS permission
    if (DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
      DeviceMotionEvent.requestPermission().then(response => {
        if (response === 'granted') {
          window.addEventListener('devicemotion', handleMotion);
        }
      });
    } else {
      window.addEventListener('devicemotion', handleMotion);
    }
    
    // Touch fallback
    let lastTouch = { x: 0, y: 0 };
    document.addEventListener('touchmove', (e) => {
      const touch = e.touches[0];
      const dx = Math.abs(touch.clientX - lastTouch.x);
      const dy = Math.abs(touch.clientY - lastTouch.y);
      const motion = Math.min(1, (dx + dy) / 50);
      this.state.motion = this.state.motion * 0.95 + motion * 0.05;
      lastTouch = { x: touch.clientX, y: touch.clientY };
    });
  }
  
  initializeNeural() {
    // Initialize simple neural pattern generator
    for (let i = 0; i < 16; i++) {
      this.neural.weights.push(Math.random());
      this.neural.patterns.push({
        rhythm: Array(16).fill(0).map(() => Math.random() > 0.7),
        pitch: Array(8).fill(0).map(() => Math.floor(Math.random() * 12))
      });
    }
  }
  
  startEngine() {
    // Main engine loop - simplified
    let nextNoteTime = this.ctx.currentTime;
    let currentNote = 0;
    
    const schedule = () => {
      const lookahead = 0.1;
      
      while (nextNoteTime < this.ctx.currentTime + lookahead) {
        // AI decides what to play
        this.aiCompose(currentNote, nextNoteTime);
        
        // Advance
        const secondsPerBeat = 60 / this.state.bpm / 4;
        nextNoteTime += secondsPerBeat;
        
        currentNote = (currentNote + 1) % 16;
        
        if (currentNote === 0) {
          this.onBar();
        }
      }
      
      if (this.state.active) {
        requestAnimationFrame(schedule);
      }
    };
    
    schedule();
    
    // Auto-sampling AI
    this.startAutoSampler();
  }
  
  aiCompose(step, time) {
    // Neural network decides what to play based on current state
    const pattern = this.neural.patterns[step % this.neural.patterns.length];
    
    // Evolve patterns based on motion
    if (Math.random() < this.state.motion * 0.1) {
      pattern.rhythm[step % 16] = !pattern.rhythm[step % 16];
    }
    
    // State machine
    if (this.state.energy > 0.7) {
      this.state.currentState = 'chaos';
    } else if (this.state.energy > 0.5) {
      this.state.currentState = 'elevated';
    } else if (this.state.energy > 0.2) {
      this.state.currentState = 'rhythmic';
    } else {
      this.state.currentState = 'ambient';
    }
    
    // Generate based on state
    switch(this.state.currentState) {
      case 'ambient':
        if (step % 8 === 0) this.playTone(time, 110 * (1 + pattern.pitch[0] / 12));
        break;
        
      case 'rhythmic':
        if (pattern.rhythm[step]) this.playKick(time);
        if (step % 4 === 2) this.playHat(time);
        if (step === 0 && this.sampleBank.length > 0) {
          this.playSample(0, time);
        }
        break;
        
      case 'elevated':
        if (step % 2 === 0) this.playKick(time);
        if (pattern.rhythm[step]) this.playHat(time);
        this.sampleBank.forEach((sample, i) => {
          if (step % (4 + i) === 0) this.playSample(i, time);
        });
        break;
        
      case 'chaos':
        // Full chaos mode - random everything
        if (Math.random() > 0.5) this.playKick(time);
        if (Math.random() > 0.6) this.playHat(time);
        if (Math.random() > 0.7 && this.sampleBank.length > 0) {
          this.playSample(Math.floor(Math.random() * this.sampleBank.length), time);
        }
        if (Math.random() > 0.8) {
          this.playTone(time, 55 * Math.pow(2, Math.random() * 4));
        }
        break;
    }
  }
  
  playKick(time) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.frequency.setValueAtTime(60, time);
    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
    
    gain.gain.setValueAtTime(0.7 * this.state.energy, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
    
    osc.connect(gain);
    gain.connect(this.nodes.master);
    
    osc.start(time);
    osc.stop(time + 0.5);
  }
  
  playHat(time) {
    const buffer = this.ctx.createBuffer(1, 0.05 * this.ctx.sampleRate, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
    }
    
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 8000;
    
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0.1, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
    
    source.connect(filter);
    filter.connect(gain);
    gain.connect(this.nodes.master);
    
    source.start(time);
  }
  
  playTone(time, freq) {
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.value = freq;
    
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.05, time + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, time + 1);
    
    osc.connect(gain);
    gain.connect(this.nodes.reverb);
    gain.connect(this.nodes.master);
    
    osc.start(time);
    osc.stop(time + 1);
  }
  
  playSample(index, time) {
    if (!this.sampleBank[index]) return;
    
    const source = this.ctx.createBufferSource();
    source.buffer = this.sampleBank[index];
    
    // Pitch shift based on motion
    source.playbackRate.value = 1 + (this.state.motion - 0.5) * 0.5;
    
    const gain = this.ctx.createGain();
    gain.gain.value = 0.5;
    
    source.connect(gain);
    gain.connect(this.nodes.reverb);
    gain.connect(this.nodes.master);
    
    source.start(time);
    
    // Visual feedback
    this.createPulse();
  }
  
  onBar() {
    // Update energy
    this.state.energy = this.state.energy * 0.9 + this.state.motion * 0.1;
    
    // Update BPM based on energy
    const targetBPM = 80 + this.state.energy * 80;
    this.state.bpm = this.state.bpm * 0.95 + targetBPM * 0.05;
    
    // Update debug
    document.getElementById('debug-motion').textContent = this.state.motion.toFixed(2);
    document.getElementById('debug-energy').textContent = this.state.energy.toFixed(2);
    document.getElementById('debug-samples').textContent = this.sampleBank.length;
    document.getElementById('debug-state').textContent = this.state.currentState;
    document.getElementById('debug-bpm').textContent = Math.round(this.state.bpm);
    
    // Status
    if (this.state.currentState !== 'ambient') {
      document.getElementById('status').textContent = this.state.currentState;
      document.getElementById('status').classList.add('active');
      setTimeout(() => {
        document.getElementById('status').classList.remove('active');
      }, 500);
    }
  }
  
  startAutoSampler() {
    // AI decides when to sample
    setInterval(() => {
      if (this.state.recording || this.sampleBank.length >= this.config.maxSamples) return;
      
      // Sample when energy is interesting
      if (Math.random() < this.state.energy * 0.3) {
        this.autoSample();
      }
    }, 5000);
  }
  
  autoSample() {
    if (!this.nodes.input) return;
    
    this.state.recording = true;
    this.recordBuffer = [];
    
    document.getElementById('orb').classList.add('recording');
    document.getElementById('status').textContent = 'sampling environment';
    
    setTimeout(() => {
      this.processRecording();
    }, this.config.sampleDuration);
  }
  
  handleOrb() {
    if (this.state.recording) {
      // Stop early
      this.processRecording();
    } else {
      // Manual sample
      this.autoSample();
    }
  }
  
  processRecording() {
    this.state.recording = false;
    document.getElementById('orb').classList.remove('recording');
    
    if (this.recordBuffer.length === 0) return;
    
    document.getElementById('orb').classList.add('processing');
    
    // Convert to audio buffer
    const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    // Process with AI enhancement
    for (let i = 0; i < this.recordBuffer.length; i++) {
      let sample = this.recordBuffer[i];
      
      // Noise gate
      if (Math.abs(sample) < 0.01) sample = 0;
      
      // Compression
      sample = Math.tanh(sample * 3) * 0.5;
      
      // Fade edges
      const fadeLength = 1000;
      if (i < fadeLength) {
        sample *= i / fadeLength;
      } else if (i > this.recordBuffer.length - fadeLength) {
        sample *= (this.recordBuffer.length - i) / fadeLength;
      }
      
      data[i] = sample;
    }
    
    // Add to bank
    if (this.sampleBank.length >= this.config.maxSamples) {
      this.sampleBank.shift(); // Remove oldest
    }
    this.sampleBank.push(buffer);
    
    // Neural network learns from sample
    this.learnFromSample(this.recordBuffer);
    
    setTimeout(() => {
      document.getElementById('orb').classList.remove('processing');
      document.getElementById('status').textContent = `sample ${this.sampleBank.length} captured`;
    }, 500);
    
    this.createPulse();
  }
  
  learnFromSample(data) {
    // Analyze sample and update neural patterns
    let energy = 0;
    let zeroCrossings = 0;
    
    for (let i = 1; i < data.length; i++) {
      energy += Math.abs(data[i]);
      if (data[i-1] < 0 && data[i] > 0) zeroCrossings++;
    }
    
    energy /= data.length;
    
    // Mutate patterns based on analysis
    const patternIndex = this.sampleBank.length % this.neural.patterns.length;
    const pattern = this.neural.patterns[patternIndex];
    
    // More energy = more rhythm hits
    for (let i = 0; i < pattern.rhythm.length; i++) {
      if (Math.random() < energy * 10) {
        pattern.rhythm[i] = true;
      }
    }
    
    // Update chaos based on zero crossings (complexity)
    this.state.chaos = Math.min(1, zeroCrossings / 1000);
  }
  
  createPulse() {
    const pulse = document.createElement('div');
    pulse.className = 'neural-pulse';
    pulse.style.top = '50%';
    pulse.style.left = '50%';
    pulse.style.transform = 'translate(-50%, -50%)';
    document.body.appendChild(pulse);
    
    setTimeout(() => pulse.remove(), 2000);
  }
  
  render() {
    // Minimal visualization
    const ctx = this.canvasCtx;
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // Energy visualization
    if (this.analyzer) {
      const data = new Uint8Array(128);
      this.analyzer.getByteFrequencyData(data);
      
      ctx.strokeStyle = `rgba(0, 255, 255, ${0.1 + this.state.energy * 0.5})`;
      ctx.lineWidth = 1;
      ctx.beginPath();
      
      const centerX = this.canvas.width / 2;
      const centerY = this.canvas.height / 2;
      
      for (let i = 0; i < data.length; i++) {
        const angle = (i / data.length) * Math.PI * 2;
        const radius = 60 + (data[i] / 255) * 100 * this.state.energy;
        const x = centerX + Math.cos(angle) * radius;
        const y = centerY + Math.sin(angle) * radius;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      
      ctx.closePath();
      ctx.stroke();
    }
    
    // Update orb size based on energy
    const orb = document.getElementById('orb');
    const scale = 1 + this.state.energy * 0.5;
    orb.style.transform = `translate(-50%, -50%) scale(${scale})`;
    orb.style.opacity = 0.3 + this.state.energy * 0.7;
    
    requestAnimationFrame(() => this.render());
  }
}

// Initialize
const neuromancer = new Neuromancer();

</script>

</body>
</html>
