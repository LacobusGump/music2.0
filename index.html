<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="microphone=(self)">
    <title>GUMP: Environmental Sampling EDM Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,20,20,0.1) 0%, transparent 70%);
            border: 3px solid rgba(255,20,20,0.4);
            color: #ff1414;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(255,20,20,0.8);
            background: radial-gradient(circle, rgba(255,20,20,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        .btn-text {
            font-size: 20px;
            margin-bottom: 8px;
        }

        .btn-subtext {
            font-size: 11px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255,20,20,0.3);
            }
            50% {
                transform: scale(1.06);
                box-shadow: 0 0 80px rgba(255,20,20,0.6);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff1414 0%, rgba(255,20,20,0.4) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 50px rgba(255,20,20,0.6);
            backdrop-filter: blur(8px);
            will-change: transform;
            z-index: 10;
        }

        .orb.pulse {
            animation: beatPulse 0.15s ease-out;
        }

        @keyframes beatPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.8); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.sampling {
            background: radial-gradient(circle, #ff6600 0%, rgba(255,102,0,0.5) 50%, transparent 80%);
            box-shadow: 0 0 70px rgba(255,102,0,0.8);
        }

        .orb.chopping {
            background: radial-gradient(circle, #00ff88 0%, rgba(0,255,136,0.5) 50%, transparent 80%);
            box-shadow: 0 0 90px rgba(0,255,136,0.9);
        }

        .orb.flipping {
            background: radial-gradient(circle, #8800ff 0%, rgba(136,0,255,0.5) 50%, transparent 80%);
            box-shadow: 0 0 120px rgba(136,0,255,1);
        }

        .orb.dropping {
            background: radial-gradient(circle, #ffff00 0%, #ff0080 30%, #00ffff 60%, transparent 90%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 100px rgba(255,0,128,0.8));
        }

        .hidden {
            display: none !important;
        }

        .sample-viz {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 280px;
            height: 100px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,20,20,0.3);
            border-radius: 12px;
            padding: 12px;
            font-size: 11px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .sample-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .btn-subtext {
            font-size: 11px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
        }

        .btn-details {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .waveform {
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,20,20,0.2);
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #ff1414, #ff6600, #ffff00);
            transition: height 0.08s ease;
            border-radius: 1px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .control-section {
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 10px;
            color: #ff6600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .slider {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff1414, #ff6600);
            border-radius: 3px;
            transition: width 0.2s ease;
        }

        .slider-thumb {
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            transform: translateX(-50%);
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,20,20,0.6);
            animation: float 6s linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-10vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .layer-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            z-index: 100;
        }

        .layer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            min-width: 140px;
        }

        .layer.active {
            background: rgba(255,20,20,0.2);
            border: 1px solid rgba(255,20,20,0.4);
        }

        .layer-name {
            font-weight: bold;
            color: #ff6600;
        }

        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            max-width: 200px;
            z-index: 100;
        }

        .instruction-group {
            margin-bottom: 8px;
        }

        .instruction-title {
            color: #ff6600;
            font-weight: bold;
            margin-bottom: 4px;
        }

        kbd {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            margin-right: 4px;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            <div class="btn-text">START ENGINE</div>
            <div class="btn-subtext">SAMPLE THE WORLD<br>BUILD THE BEAT</div>
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
        
        <div id="sampleViz" class="sample-viz hidden">
            <div class="sample-info">
                <span id="sampleStatus">LISTENING...</span>
                <span id="sampleCount">0 SAMPLES</span>
            </div>
            <div class="sample-details">
                <span id="bpmDisplay">140 BPM</span>
                <span id="stageDisplay">LISTENING</span>
                <span id="motionDisplay">CALM</span>
            </div>
            <div class="waveform" id="waveform"></div>
        </div>

        <div id="controls" class="controls hidden">
            <div class="control-section">
                <div class="control-label">Sampling</div>
                <div class="control-row">
                    <span>Threshold</span>
                    <div class="slider" data-param="threshold">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Sensitivity</span>
                    <div class="slider" data-param="sensitivity">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
            <div class="control-section">
                <div class="control-label">Evolution</div>
                <div class="control-row">
                    <span>Chaos</span>
                    <div class="slider" data-param="chaos">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Speed</span>
                    <div class="slider" data-param="speed">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="layerStatus" class="layer-status hidden">
            <div style="font-weight: bold; margin-bottom: 8px; color: #ff6600;">SAMPLE LAYERS</div>
            <div class="layer" data-layer="kick">
                <span class="layer-name">KICK</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="snare">
                <span class="layer-name">SNARE</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="hats">
                <span class="layer-name">HATS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="bass">
                <span class="layer-name">BASS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="lead">
                <span class="layer-name">LEAD</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="fx">
                <span class="layer-name">FX</span>
                <span class="layer-count">0</span>
            </div>
        </div>

        <div id="instructions" class="instructions hidden">
            <div class="instruction-group">
                <div class="instruction-title">Controls</div>
                <div><kbd>SPACE</kbd> Sample</div>
                <div><kbd>C</kbd> Chop</div>
                <div><kbd>F</kbd> Flip</div>
                <div><kbd>P</kbd> Pitch</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Layers</div>
                <div><kbd>1-6</kbd> Trigger</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Motion</div>
                <div>Move device or mouse</div>
            </div>
        </div>
    </div>

    <script>
        'use strict';

        class GUMPEngine {
            constructor() {
                // Core
                this.ctx = null;
                this.active = false;
                this.nodes = {};
                
                // Recording
                this.recorder = {
                    active: false,
                    buffer: [],
                    startTime: 0,
                    maxDuration: 3000
                };
                
                // Samples
                this.samples = [];
                this.maxSamples = 12;
                this.layers = {};
                
                // Sequencer
                this.seq = {
                    bpm: 140,
                    step: 0,
                    playing: false,
                    lastTime: 0,
                    patterns: {}
                };
                
                // Motion
                this.motion = {
                    value: 0,
                    history: new Float32Array(60),
                    index: 0,
                    pattern: 'calm'
                };
                
                // UI Cache
                this.ui = {};
                this.stage = 'LISTENING';
                
                // Performance
                this.raf = null;
                this.worker = null;
                
                this.init();
            }

            init() {
                // Cache DOM elements
                const ids = ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'sampleViz',
                    'sampleStatus', 'sampleCount', 'bpmDisplay', 'stageDisplay', 
                    'motionDisplay', 'waveform', 'controls', 'layerStatus', 'instructions'];
                
                ids.forEach(id => {
                    this.ui[id] = document.getElementById(id);
                });
                
                // Pre-create waveform bars
                const frag = document.createDocumentFragment();
                for (let i = 0; i < 60; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.left = `${i * 1.67}%`;
                    bar.style.width = '1.33%';
                    frag.appendChild(bar);
                }
                this.ui.waveform.appendChild(frag);
                this.waveformBars = this.ui.waveform.querySelectorAll('.waveform-bar');
                
                // Event listeners
                this.ui.startBtn.onclick = () => this.start();
                this.setupControls();
                this.setupInput();
                
                // Pre-compile patterns
                this.compilePatterns();
            }

            setupControls() {
                const sliders = document.querySelectorAll('.slider');
                const params = { threshold: 0.15, sensitivity: 0.5, chaos: 0.2, speed: 0.5 };
                
                sliders.forEach(slider => {
                    const param = slider.dataset.param;
                    const fill = slider.querySelector('.slider-fill');
                    const thumb = slider.querySelector('.slider-thumb');
                    const value = params[param];
                    
                    fill.style.width = `${value * 100}%`;
                    thumb.style.left = `${value * 100}%`;
                    
                    let active = false;
                    
                    const update = (e) => {
                        if (!active) return;
                        const rect = slider.getBoundingClientRect();
                        const x = Math.max(0, Math.min(e.clientX - rect.left, rect.width));
                        const val = x / rect.width;
                        
                        fill.style.width = `${val * 100}%`;
                        thumb.style.left = `${val * 100}%`;
                        
                        // Direct parameter updates
                        if (param === 'speed') this.seq.bpm = 100 + val * 100;
                        else if (param === 'threshold') this.threshold = 0.01 + val * 0.1;
                        else if (param === 'sensitivity') this.cooldown = 500 + (1 - val) * 3000;
                        else if (param === 'chaos') this.chaos = val;
                    };
                    
                    slider.onmousedown = (e) => {
                        active = true;
                        update(e);
                        document.onmousemove = update;
                        document.onmouseup = () => {
                            active = false;
                            document.onmousemove = null;
                            document.onmouseup = null;
                        };
                    };
                });
            }

            setupInput() {
                // Keyboard
                const keys = {
                    ' ': () => this.toggleRecording(),
                    'c': () => this.playRandom('chop'),
                    'f': () => this.playRandom('flip'),
                    'p': () => this.playRandom('pitch'),
                    '1': () => this.triggerLayer('kick'),
                    '2': () => this.triggerLayer('snare'),
                    '3': () => this.triggerLayer('hats'),
                    '4': () => this.triggerLayer('bass'),
                    '5': () => this.triggerLayer('lead'),
                    '6': () => this.triggerLayer('fx')
                };
                
                document.onkeydown = (e) => {
                    if (!this.active || e.repeat) return;
                    const fn = keys[e.key.toLowerCase()];
                    if (fn) {
                        e.preventDefault();
                        fn();
                    }
                };
                
                // Motion tracking
                let lastMove = 0;
                document.onmousemove = (e) => {
                    if (!this.active) return;
                    
                    const now = performance.now();
                    if (now - lastMove < 16) return; // 60fps cap
                    lastMove = now;
                    
                    const x = e.clientX / window.innerWidth;
                    const y = e.clientY / window.innerHeight;
                    
                    if (this.lastX !== undefined) {
                        const dx = x - this.lastX;
                        const dy = y - this.lastY;
                        const vel = Math.sqrt(dx * dx + dy * dy) * 60;
                        this.updateMotion(vel);
                    }
                    
                    this.lastX = x;
                    this.lastY = y;
                    this.ui.orb.style.left = `${x * 100}%`;
                    this.ui.orb.style.top = `${y * 100}%`;
                };
                
                // Device motion
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        if (!this.active || !e.accelerationIncludingGravity) return;
                        const {x, y, z} = e.accelerationIncludingGravity;
                        const mag = Math.sqrt(x*x + y*y + z*z) * 0.1;
                        this.updateMotion(mag);
                    });
                }
            }

            updateMotion(value) {
                this.motion.value = this.motion.value * 0.8 + value * 0.2;
                this.motion.history[this.motion.index] = this.motion.value;
                this.motion.index = (this.motion.index + 1) % 60;
                
                const avg = this.motion.history.reduce((a, b) => a + b) / 60;
                
                if (avg > 3) this.motion.pattern = 'chaotic';
                else if (avg > 1.5) this.motion.pattern = 'active';
                else if (avg > 0.5) this.motion.pattern = 'rhythmic';
                else this.motion.pattern = 'calm';
            }

            async start() {
                try {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Setup audio nodes
                    this.setupAudio();
                    
                    // Create drums
                    await this.createDrums();
                    
                    // Get mic
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.setupMic(stream);
                    
                    // Show UI
                    this.ui.startScreen.classList.add('hidden');
                    this.ui.evolutionSpace.classList.add('active');
                    ['sampleViz', 'controls', 'layerStatus', 'instructions'].forEach(id => {
                        this.ui[id].classList.remove('hidden');
                    });
                    
                    this.active = true;
                    this.motion.history.fill(0.1);
                    
                    // Start loops
                    this.startVis();
                    this.startSeq();
                    
                    console.log('ðŸŽµ ENGINE STARTED');
                    
                } catch (e) {
                    console.error('Start failed:', e);
                    alert('Failed to start: ' + e.message);
                }
            }

            setupAudio() {
                const {ctx} = this;
                
                // Master chain
                this.nodes.master = ctx.createGain();
                this.nodes.master.gain.value = 0.8;
                
                this.nodes.comp = ctx.createDynamicsCompressor();
                this.nodes.comp.threshold.value = -12;
                this.nodes.comp.knee.value = 2;
                this.nodes.comp.ratio.value = 4;
                this.nodes.comp.attack.value = 0.003;
                this.nodes.comp.release.value = 0.1;
                
                this.nodes.eq = ctx.createBiquadFilter();
                this.nodes.eq.type = 'highshelf';
                this.nodes.eq.frequency.value = 8000;
                this.nodes.eq.gain.value = 2;
                
                this.nodes.limit = ctx.createDynamicsCompressor();
                this.nodes.limit.threshold.value = -0.5;
                this.nodes.limit.knee.value = 0;
                this.nodes.limit.ratio.value = 20;
                this.nodes.limit.attack.value = 0.001;
                this.nodes.limit.release.value = 0.05;
                
                this.nodes.master.connect(this.nodes.comp);
                this.nodes.comp.connect(this.nodes.eq);
                this.nodes.eq.connect(this.nodes.limit);
                this.nodes.limit.connect(ctx.destination);
                
                // Layer channels
                const gains = {kick: 1, snare: 0.85, hats: 0.5, bass: 0.9, lead: 0.7, fx: 0.6};
                
                Object.keys(gains).forEach(name => {
                    const gain = ctx.createGain();
                    gain.gain.value = gains[name];
                    gain.connect(this.nodes.master);
                    
                    this.layers[name] = {
                        gain,
                        samples: []
                    };
                });
            }

            async createDrums() {
                const {ctx} = this;
                const sr = ctx.sampleRate;
                
                // 808 Kick
                const kick = ctx.createBuffer(2, sr * 0.8, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = kick.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        const env = t < 0.01 ? t / 0.01 : Math.exp(-2.5 * (t - 0.01));
                        const pitch = 50 * Math.exp(-35 * t) + 25;
                        
                        let s = Math.sin(2 * Math.PI * pitch * t) * 0.8;
                        s += Math.sin(4 * Math.PI * pitch * t) * 0.15 * Math.exp(-50 * t);
                        
                        if (t < 0.005) {
                            const click = (Math.random() * 2 - 1) * 0.3 * (1 - t / 0.005);
                            s += click + Math.sin(2 * Math.PI * 200 * t) * 0.3 * (1 - t / 0.005);
                        }
                        
                        data[i] = Math.tanh(s * 1.5) * env;
                    }
                }
                
                // Trap Snare
                const snare = ctx.createBuffer(2, sr * 0.25, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = snare.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        const env = (t < 0.003 ? t / 0.003 : 1) * Math.exp(-12 * t);
                        
                        const tone = Math.sin(2 * Math.PI * 220 * t) * 0.3;
                        const noise = (Math.random() * 2 - 1) * 0.5;
                        const sizzle = (Math.random() * 2 - 1) * 0.2 * Math.exp(-30 * t);
                        
                        data[i] = Math.tanh((tone * Math.exp(-15 * t) + noise * Math.exp(-8 * t) + sizzle) * 2) * 0.8 * env;
                    }
                }
                
                // Hi-Hat
                const hat = ctx.createBuffer(2, sr * 0.08, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = hat.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        let s = 0;
                        
                        [6000, 8000, 10000, 12000, 14000].forEach((f, j) => {
                            s += Math.sin(2 * Math.PI * f * (1 + Math.random() * 0.02 - 0.01) * t) * (0.2 / (j + 1));
                        });
                        
                        s = (s + (Math.random() * 2 - 1) * 0.3) * Math.exp(-80 * t) * 0.6;
                        
                        if (ch === 1 && i > 10) {
                            s = data[i-10] * 0.1 + s * 0.9;
                        }
                        
                        data[i] = s;
                    }
                }
                
                // Sub Bass
                const sub = ctx.createBuffer(2, sr * 2, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = sub.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        const fade = Math.min(1, t / 0.01) * (t > 1.8 ? Math.max(0, 1 - (t - 1.8) / 0.2) : 1);
                        data[i] = Math.sin(2 * Math.PI * 55 * (1 + Math.sin(2 * Math.PI * 5 * t) * 0.01) * t) * fade * 0.7;
                    }
                }
                
                // Add initial samples
                const drums = [
                    {buffer: kick, layer: 'kick', analysis: {energy: 'high', pitch: null}},
                    {buffer: snare, layer: 'snare', analysis: {energy: 'medium', pitch: null}},
                    {buffer: hat, layer: 'hats', analysis: {energy: 'low', pitch: null}},
                    {buffer: sub, layer: 'bass', analysis: {energy: 'medium', pitch: 55}}
                ];
                
                drums.forEach(({buffer, layer, analysis}) => {
                    const sample = {
                        id: `${layer}_${Date.now()}`,
                        buffer,
                        duration: buffer.duration,
                        analysis,
                        rate: 1
                    };
                    this.samples.push(sample);
                    this.layers[layer].samples.push(sample);
                });
                
                this.updateStage();
            }

            setupMic(stream) {
                const {ctx} = this;
                
                this.nodes.mic = ctx.createMediaStreamSource(stream);
                this.nodes.analyser = ctx.createAnalyser();
                this.nodes.analyser.fftSize = 2048;
                this.nodes.analyser.smoothingTimeConstant = 0.3;
                
                this.micData = new Uint8Array(this.nodes.analyser.frequencyBinCount);
                this.nodes.mic.connect(this.nodes.analyser);
                
                // Recording processor
                this.nodes.recorder = ctx.createScriptProcessor(4096, 1, 1);
                this.nodes.recorder.onaudioprocess = (e) => {
                    if (!this.recorder.active) return;
                    
                    const data = e.inputBuffer.getChannelData(0);
                    this.recorder.buffer.push(...data);
                    
                    if (this.recorder.buffer.length > ctx.sampleRate * 3) {
                        this.stopRecording();
                    }
                };
                
                // Thresholds
                this.threshold = 0.02;
                this.cooldown = 2000;
                this.lastSample = 0;
            }

            toggleRecording() {
                if (this.recorder.active) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                if (this.recorder.active) return;
                
                this.recorder.active = true;
                this.recorder.buffer = [];
                this.recorder.startTime = Date.now();
                this.lastSample = Date.now();
                
                this.nodes.mic.connect(this.nodes.recorder);
                this.nodes.recorder.connect(this.ctx.destination);
                
                console.log('ðŸŽ¤ Recording...');
            }

            stopRecording() {
                if (!this.recorder.active) return;
                
                this.recorder.active = false;
                this.nodes.mic.disconnect(this.nodes.recorder);
                this.nodes.recorder.disconnect();
                
                if (this.recorder.buffer.length > 0) {
                    this.createSample();
                }
                
                console.log('âœ… Recording stopped');
            }

            createSample() {
                const {ctx} = this;
                const buffer = ctx.createBuffer(1, this.recorder.buffer.length, ctx.sampleRate);
                buffer.getChannelData(0).set(this.recorder.buffer);
                
                const analysis = this.analyze(buffer);
                
                const sample = {
                    id: `rec_${Date.now()}`,
                    buffer,
                    duration: buffer.duration,
                    analysis,
                    rate: 1
                };
                
                // Autotune if pitched
                if (analysis.pitch) {
                    const target = this.quantizePitch(analysis.pitch);
                    sample.rate = target / analysis.pitch;
                }
                
                // Maintain max samples
                if (this.samples.length >= this.maxSamples) {
                    const old = this.samples.shift();
                    Object.values(this.layers).forEach(layer => {
                        layer.samples = layer.samples.filter(s => s.id !== old.id);
                    });
                }
                
                this.samples.push(sample);
                
                // Categorize
                const category = this.categorize(analysis);
                this.layers[category].samples.push(sample);
                
                this.updateStage();
                console.log(`ðŸ“š Sample added to ${category}`);
            }

            analyze(buffer) {
                const data = buffer.getChannelData(0);
                const len = data.length;
                
                // RMS
                let rms = 0;
                for (let i = 0; i < len; i++) {
                    rms += data[i] * data[i];
                }
                rms = Math.sqrt(rms / len);
                
                // Zero crossings
                let zc = 0;
                for (let i = 1; i < len; i++) {
                    if ((data[i] >= 0) !== (data[i-1] >= 0)) zc++;
                }
                const zcr = zc / buffer.duration;
                
                // Pitch detection (simplified autocorrelation)
                let pitch = null;
                if (len > 512) {
                    const maxLag = Math.min(len >> 1, 1000);
                    const minLag = 20;
                    let maxCorr = 0;
                    let bestLag = -1;
                    
                    for (let lag = minLag; lag < maxLag; lag++) {
                        let corr = 0;
                        for (let i = 0; i < len - lag; i++) {
                            corr += data[i] * data[i + lag];
                        }
                        if (corr > maxCorr) {
                            maxCorr = corr;
                            bestLag = lag;
                        }
                    }
                    
                    if (maxCorr > rms * rms * len * 0.3 && bestLag > 0) {
                        pitch = this.ctx.sampleRate / bestLag;
                    }
                }
                
                return {
                    rms,
                    zcr,
                    energy: rms > 0.1 ? 'high' : rms > 0.03 ? 'medium' : 'low',
                    brightness: zcr > 3000 ? 'bright' : 'dark',
                    pitch,
                    duration: buffer.duration
                };
            }

            categorize(analysis) {
                const {energy, brightness, pitch, duration, zcr} = analysis;
                
                if (energy === 'high' && brightness === 'dark' && duration < 0.5) return 'kick';
                if (energy === 'medium' && zcr > 2000 && zcr < 5000) return 'snare';
                if (brightness === 'bright' && duration < 0.1) return 'hats';
                if (pitch && pitch < 200 && duration > 0.5) return 'bass';
                if (pitch && pitch > 200 && pitch < 1000) return 'lead';
                
                return 'fx';
            }

            quantizePitch(freq) {
                // A minor scale
                const scale = [0, 2, 3, 5, 7, 8, 10];
                const midi = 69 + 12 * Math.log2(freq / 440);
                const note = Math.round(midi);
                const octave = Math.floor(note / 12);
                const degree = note % 12;
                
                let closest = scale[0];
                let minDiff = Math.abs(degree - closest);
                
                for (let s of scale) {
                    const diff = Math.abs(degree - s);
                    if (diff < minDiff) {
                        minDiff = diff;
                        closest = s;
                    }
                }
                
                return 440 * Math.pow(2, (octave * 12 + closest - 69) / 12);
            }

            compilePatterns() {
                // Pre-compile beat patterns for performance
                this.seq.patterns = {
                    listening: {
                        kick: [0, 16],
                        hats: [8, 24]
                    },
                    sampling: {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [4, 12, 20, 28]
                    },
                    chopping: {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [2, 6, 10, 14, 18, 22, 26, 30],
                        bass: [0, 16]
                    },
                    flipping: {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [0, 4, 8, 12, 16, 20, 24, 28],
                        bass: [0, 16],
                        lead: [4, 12, 20, 28]
                    },
                    dropping: {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
                        bass: [0, 16],
                        lead: [4, 12, 20, 28],
                        fx: [0, 8, 16, 24]
                    }
                };
            }

            startVis() {
                const loop = () => {
                    if (!this.active) return;

                    this.analyzer.getFloatTimeDomainData(this.timeDomainData);
                    
                    // Update waveform
                    let rms = 0;
                    for (let val of this.timeDomainData) rms += val * val;
                    rms = Math.sqrt(rms / this.timeDomainData.length) * this.sensitivity;
                    this.lmState.energy = rms;
                    
                    const now = Date.now();
                    if (rms > this.threshold && !this.isRecording && now - this.lastSampleTime > this.samplingInterval) {
                        this.recordingChunks = [];
                        this.recorder.start();
                        this.isRecording = true;
                        console.log('Sampling Started');
                    } else if (rms < this.threshold / 2 && this.isRecording) {
                        this.recorder.stop();
                        this.isRecording = false;
                        this.lastSampleTime = now;
                        console.log('Sampling Stopped');
                    }

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }

            sequencerLoop() {
                const stepDuration = 60 / this.tempo / 4 * 1000; // 16th note ms
                setTimeout(() => {
                    this.playBeatStep();
                    this.sequencerLoop();
                }, stepDuration);
            }

            playBeatStep() {
                const pattern = this.generateFractalPattern();
                if (pattern[this.beatStep % this.patternLength]) {
                    const sampleIndex = Math.floor(Math.random() * this.processedSamples.length);
                    const sample = this.processedSamples[sampleIndex];
                    if (sample) {
                        const source = this.ctx.createBufferSource();
                        source.buffer = sample;
                        source.connect(this.masterGain);
                        source.start(0);
                    }
                }
                this.beatStep++;
            }

            generateFractalPattern() {
                const pattern = new Array(this.patternLength).fill(0);
                // Sierpinski-like fractal for rhythm
                for (let i = 0; i < this.patternLength; i++) {
                    pattern[i] = (i & (i >> Math.floor(this.lmState.complexity * 4 + 1))) === 0 ? 1 : 0;
                }
                // Modulate by mood
                if (this.lmState.mood === 'aggressive') {
                    pattern.forEach((v, idx) => { if (idx % 2 === 0) pattern[idx] = 1; });
                } else if (this.lmState.mood === 'mellow') {
                    pattern.forEach((v, idx) => { if (idx % 4 !== 0) pattern[idx] = 0; });
                }
                return pattern;
            }

            analysisLoop() {
                requestAnimationFrame(this.analysisLoop.bind(this));
                if (!this.active) return;

                this.analyzer.getByteFrequencyData(this.dataArray);
                this.analyzer.getFloatTimeDomainData(this.timeDomainData);

                // Update LM from real-time audio
                let energy = 0;
                for (let val of this.timeDomainData) energy += val * val;
                this.lmState.energy = Math.sqrt(energy / this.timeDomainData.length);

                // Spectral centroid
                let num = 0, den = 0;
                for (let i = 0; i < this.dataArray.length; i++) {
                    num += i * this.dataArray[i];
                    den += this.dataArray[i];
                }
                this.lmState.spectralCentroid = den > 0 ? (num / den) * (this.ctx.sampleRate / 2 / this.dataArray.length) : 0;
            }
        }

        new GUMPEngine();
    </script>
</body>
</html>
