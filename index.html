<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP Orchestra</title>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@3.11.0/dist/tf.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/es6/core.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@magenta/music@1.23.1/es6/music_rnn.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #08080c;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: system-ui, -apple-system, sans-serif;
            color: rgba(200,180,255,0.8);
        }
        canvas { position: fixed; inset: 0; z-index: 0; }

        #enter {
            position: fixed; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 100; cursor: pointer; background: #08080c;
            gap: 21px;
        }
        #enter.off { display: none; }
        #enter h1 { font-size: 13px; letter-spacing: 4px; font-weight: 300; opacity: 0.6; }
        #enter i {
            width: 89px; height: 89px; border-radius: 50%;
            border: 1px solid rgba(200,180,255,0.15);
            display: flex; align-items: center; justify-content: center;
        }
        #enter i::after {
            content: ''; width: 34px; height: 34px; border-radius: 50%;
            border: 1px solid rgba(200,180,255,0.25);
        }

        #loading {
            position: fixed; inset: 0;
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 99; background: #08080c;
            gap: 13px;
        }
        #loading.off { display: none; }
        #loading .status { font-size: 10px; letter-spacing: 2px; opacity: 0.5; }
        #loading .agents { font-size: 9px; opacity: 0.3; margin-top: 21px; }

        #agents {
            position: fixed; top: 13px; left: 13px; right: 13px;
            display: flex; justify-content: center; gap: 21px;
            z-index: 50; flex-wrap: wrap;
        }
        .agent-badge {
            font-size: 8px; letter-spacing: 2px;
            padding: 5px 10px; border-radius: 13px;
            background: rgba(200,180,255,0.05);
            border: 1px solid rgba(200,180,255,0.1);
            opacity: 0.4; transition: all 0.3s;
        }
        .agent-badge.active {
            opacity: 1;
            background: rgba(200,180,255,0.1);
            border-color: rgba(200,180,255,0.3);
        }
        .agent-badge.listening {
            box-shadow: 0 0 8px rgba(200,180,255,0.2);
        }
    </style>
</head>
<body>
<div id="enter">
    <h1>GUMP ORCHESTRA</h1>
    <i></i>
</div>

<div id="loading" class="off">
    <div class="status" id="load-status">initializing...</div>
    <div class="agents">drums 路 bass 路 keys 路 lead 路 voice</div>
</div>

<div id="agents" style="display:none">
    <div class="agent-badge" id="agent-drums">DRUMS</div>
    <div class="agent-badge" id="agent-bass">BASS</div>
    <div class="agent-badge" id="agent-keys">KEYS</div>
    <div class="agent-badge" id="agent-lead">LEAD</div>
    <div class="agent-badge" id="agent-voice">VOICE</div>
</div>

<canvas id="c"></canvas>

<script>
// ============================================================
// GUMP ORCHESTRA - AI Agents Playing Together
// Each agent listens to the others and reacts like a jazz musician
// ============================================================

const TAU = Math.PI * 2;

let ctx, master, canvas, vc;
let running = false;

// ============ SHARED MUSICAL STATE ============
// This is what all agents can "hear" - like being in the same room

const SharedState = {
    // Time
    bpm: 85,
    beat: 0,
    bar: 0,
    phrase: 0,

    // Harmony
    key: 0,           // Root note (0-11)
    mode: 'minor',    // minor, major, dorian, etc.
    chord: [0, 3, 7], // Current chord tones
    chordName: 'Am',

    // Energy from motion
    energy: 0,
    direction: { x: 0, y: 0 },
    intensity: 0.4,

    // What each agent is currently playing (so others can hear)
    playing: {
        drums: { kick: false, snare: false, hat: false, pattern: null },
        bass: { note: null, octave: 2, playing: false },
        keys: { notes: [], voicing: null },
        lead: { note: null, playing: false, phrase: [] },
        voice: { note: null, vowel: 'a', playing: false }
    },

    // Conversation - agents can signal intentions
    signals: {
        buildUp: 0,      // 0-1, someone wants to build
        dropHint: 0,     // 0-1, someone's about to drop
        space: 0,        // 0-1, someone wants others to leave room
        callResponse: null // { from: 'lead', phrase: [...] }
    }
};

// ============ MOTION INPUT ============

const Motion = {
    x: 0.5,
    y: 0.5,
    vx: 0,
    vy: 0,
    energy: 0,
    peak: 0,

    update(nx, ny) {
        const dx = nx - this.x;
        const dy = ny - this.y;
        this.vx = this.vx * 0.7 + dx * 0.3;
        this.vy = this.vy * 0.7 + dy * 0.3;
        this.x += dx * 0.15;
        this.y += dy * 0.15;
        this.energy = this.energy * 0.85 + Math.sqrt(dx*dx + dy*dy) * 3;
        this.peak = Math.max(this.peak * 0.97, this.energy);

        SharedState.energy = this.energy;
        SharedState.direction = { x: this.vx, y: this.vy };
        SharedState.intensity = SharedState.intensity * 0.95 + this.peak * 0.05;
        SharedState.intensity = Math.max(0.2, Math.min(1, SharedState.intensity));
    }
};

// ============ AGENT BASE CLASS ============

class Agent {
    constructor(name, personality) {
        this.name = name;
        this.personality = {
            reactivity: 0.5,    // How quickly they respond to others
            density: 0.5,       // How much they play
            adventurousness: 0.5, // How far they stray from safe choices
            listening: 0.5,     // How much they follow vs lead
            ...personality
        };
        this.active = false;
        this.lastAction = 0;
    }

    // What this agent hears from others
    listen() {
        return {
            drums: SharedState.playing.drums,
            bass: SharedState.playing.bass,
            keys: SharedState.playing.keys,
            lead: SharedState.playing.lead,
            voice: SharedState.playing.voice,
            energy: SharedState.energy,
            intensity: SharedState.intensity,
            chord: SharedState.chord,
            signals: SharedState.signals
        };
    }

    // Should this agent play right now?
    shouldPlay() {
        const heard = this.listen();
        const baseChance = this.personality.density;
        const energyMod = heard.intensity * this.personality.reactivity;
        return Math.random() < (baseChance * 0.5 + energyMod * 0.5);
    }

    // Announce what we're playing
    broadcast(data) {
        SharedState.playing[this.name] = { ...SharedState.playing[this.name], ...data };
    }

    // Signal an intention to other agents
    signal(type, value) {
        SharedState.signals[type] = value;
    }

    tick(time) {
        // Override in subclass
    }

    updateBadge() {
        const el = document.getElementById(`agent-${this.name}`);
        if (el) {
            el.classList.toggle('active', this.active);
            el.classList.toggle('listening', this.personality.listening > 0.6);
        }
    }
}

// ============ DRUM AGENT ============

class DrumAgent extends Agent {
    constructor() {
        super('drums', {
            reactivity: 0.7,
            density: 0.8,
            adventurousness: 0.3,
            listening: 0.4
        });

        this.samples = {};
        this.pattern = null;
        this.step = 0;
        this.lastStep = 0;
        this.patternMemory = []; // Remember patterns that worked
        this.aiModel = null;
    }

    async init(audioCtx) {
        this.ctx = audioCtx;
        this.bus = audioCtx.createGain();
        this.bus.gain.value = 0.75;

        // Load samples
        const urls = {
            kick: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
            snare: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
            hat: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',
            rim: 'https://cdn.freesound.org/previews/209/209890_3797507-lq.mp3',
            tom: 'https://cdn.freesound.org/previews/110/110011_1537491-lq.mp3'
        };

        for (const [name, url] of Object.entries(urls)) {
            try {
                const res = await fetch(url);
                this.samples[name] = await audioCtx.decodeAudioData(await res.arrayBuffer());
            } catch (e) {
                this.samples[name] = this.createFallback(name);
            }
        }

        // Try to load Magenta DrumsRNN
        try {
            this.aiModel = new music_rnn.MusicRNN(
                'https://storage.googleapis.com/magentadata/js/checkpoints/music_rnn/drum_kit_rnn'
            );
            await this.aiModel.initialize();
            console.log('Drum AI ready');
        } catch (e) {
            console.warn('Drum AI unavailable, using generative fallback');
        }

        this.generatePattern();
    }

    createFallback(name) {
        const sr = this.ctx.sampleRate;
        const len = sr * 0.3;
        const buf = this.ctx.createBuffer(2, len, sr);
        for (let ch = 0; ch < 2; ch++) {
            const d = buf.getChannelData(ch);
            if (name === 'kick') {
                for (let i = 0; i < len; i++) {
                    const t = i / sr;
                    d[i] = Math.sin(TAU * (120 * Math.exp(-t * 25) + 40) * t) * Math.exp(-t * 10) * 0.8;
                }
            } else if (name === 'snare') {
                for (let i = 0; i < len; i++) {
                    const t = i / sr;
                    d[i] = ((Math.random() * 2 - 1) * 0.6 + Math.sin(TAU * 180 * t) * 0.3) * Math.exp(-t * 15);
                }
            } else {
                for (let i = 0; i < len * 0.1; i++) {
                    const t = i / sr;
                    d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40) * 0.3;
                }
            }
        }
        return buf;
    }

    async generatePattern() {
        const heard = this.listen();

        // Listen to what others are doing
        const bassPlaying = heard.bass.playing;
        const intensity = heard.intensity;

        // Decide on pattern density based on what we hear
        let kickDensity = 3 + Math.round(intensity * 2);
        let hatDensity = 0.4 + intensity * 0.4;

        // If bass is busy, leave more space
        if (bassPlaying) {
            kickDensity = Math.max(2, kickDensity - 1);
        }

        // If someone signals "space", back off
        if (heard.signals.space > 0.5) {
            kickDensity = 2;
            hatDensity *= 0.5;
        }

        // Generate pattern
        this.pattern = {
            kicks: this.euclidean(16, kickDensity, SharedState.bar % 5),
            snares: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hats: Array(16).fill(0).map(() => Math.random() < hatDensity ? 0.3 + Math.random() * 0.3 : 0),
            swing: 0.12
        };

        // Add variation in later phrases
        if (SharedState.phrase === 3) this.pattern.snares[10] = 0.5;
        if (SharedState.phrase === 7) this.pattern.snares[14] = 0.6;

        this.broadcast({ pattern: this.pattern });
    }

    euclidean(steps, pulses, rotation = 0) {
        const pattern = [];
        let bucket = 0;
        for (let i = 0; i < steps; i++) {
            bucket += pulses;
            pattern.push(bucket >= steps ? (bucket -= steps, 1) : 0);
        }
        for (let i = 0; i < rotation; i++) pattern.push(pattern.shift());
        return pattern;
    }

    play(sample, opts = {}) {
        if (!this.samples[sample]) return;
        const src = this.ctx.createBufferSource();
        src.buffer = this.samples[sample];
        if (opts.pitch) src.playbackRate.value = Math.pow(2, opts.pitch / 12);

        const g = this.ctx.createGain();
        g.gain.value = opts.vol || 0.8;

        if (opts.pan) {
            const p = this.ctx.createStereoPanner();
            p.pan.value = opts.pan;
            src.connect(p).connect(g);
        } else {
            src.connect(g);
        }

        g.connect(this.bus);
        src.start(this.ctx.currentTime + (opts.delay || 0));
    }

    tick(time) {
        const stepDur = 60 / SharedState.bpm / 4;

        if (time - this.lastStep >= stepDur) {
            this.lastStep = time;

            if (this.step % 16 === 0) {
                SharedState.bar++;
                SharedState.phrase = SharedState.bar % 8;
                this.generatePattern();
            }

            if (!this.pattern) return;

            const s = this.step % 16;
            const sw = s % 2 === 1 ? stepDur * this.pattern.swing : 0;

            // KICK
            if (this.pattern.kicks[s]) {
                this.play('kick', { vol: 0.85 + SharedState.intensity * 0.15, delay: sw });
                this.broadcast({ kick: true });
                this.active = true;
            } else {
                this.broadcast({ kick: false });
            }

            // SNARE
            if (this.pattern.snares[s]) {
                this.play('snare', {
                    vol: this.pattern.snares[s] * (0.7 + SharedState.intensity * 0.25),
                    delay: sw,
                    pan: (Math.random() - 0.5) * 0.1
                });
                this.broadcast({ snare: true });
            } else {
                this.broadcast({ snare: false });
            }

            // HATS
            if (this.pattern.hats[s]) {
                this.play('hat', {
                    vol: this.pattern.hats[s] * 0.6,
                    delay: sw,
                    pan: (Math.random() - 0.5) * 0.4
                });
                this.broadcast({ hat: true });
            } else {
                this.broadcast({ hat: false });
            }

            SharedState.beat = s;
            this.step++;

            if (s === 15) this.active = false;
        }

        this.updateBadge();
    }
}

// ============ BASS AGENT ============

class BassAgent extends Agent {
    constructor() {
        super('bass', {
            reactivity: 0.6,
            density: 0.7,
            adventurousness: 0.4,
            listening: 0.7 // Bass listens a lot to drums
        });

        this.osc1 = null;
        this.osc2 = null;
        this.filter = null;
        this.gain = null;
        this.currentNote = 0;
        this.pattern = [0, 0, 5, 3];
        this.step = 0;
        this.lastStep = 0;
    }

    async init(audioCtx) {
        this.ctx = audioCtx;
        this.bus = audioCtx.createGain();
        this.bus.gain.value = 0.6;

        this.osc1 = audioCtx.createOscillator();
        this.osc2 = audioCtx.createOscillator();
        this.osc1.type = 'sine';
        this.osc2.type = 'triangle';
        this.osc1.frequency.value = 55;
        this.osc2.frequency.value = 55;
        this.osc2.detune.value = 5;

        this.filter = audioCtx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 400;
        this.filter.Q.value = 2;

        this.gain = audioCtx.createGain();
        this.gain.gain.value = 0;

        const mix = audioCtx.createGain();
        mix.gain.value = 0.5;
        this.osc1.connect(mix);
        this.osc2.connect(mix);
        mix.connect(this.filter).connect(this.gain).connect(this.bus);

        this.osc1.start();
        this.osc2.start();
    }

    decideNextNote() {
        const heard = this.listen();
        const chord = heard.chord;

        // Listen to drums - if kick just hit, consider root
        if (heard.drums.kick) {
            if (Math.random() < 0.6) return 0; // Play root on kick
        }

        // Listen to keys - try to complement their voicing
        if (heard.keys.notes.length > 0) {
            // Find a note that's NOT in the keys voicing
            const keysNotes = heard.keys.notes.map(n => n % 12);
            const options = chord.filter(n => !keysNotes.includes(n % 12));
            if (options.length > 0) {
                return options[Math.floor(Math.random() * options.length)];
            }
        }

        // Default: walk through chord tones
        const walkOptions = [0, chord[1] || 3, chord[2] || 7, 5, -5, 7];
        return walkOptions[Math.floor(Math.random() * walkOptions.length)];
    }

    tick(time) {
        const heard = this.listen();
        const stepDur = 60 / SharedState.bpm / 2; // 8th notes

        if (time - this.lastStep >= stepDur) {
            this.lastStep = time;

            // Decide note based on what we hear
            if (this.step % 4 === 0 || Math.random() < this.personality.adventurousness * 0.3) {
                this.currentNote = this.decideNextNote();
            }

            // Respond to intensity
            const shouldPlay = heard.intensity > 0.2 || heard.drums.kick;

            if (shouldPlay) {
                // Y position shifts root
                const rootShift = (1 - Motion.y) * 0.4;
                const baseFreq = 55 * Math.pow(2, SharedState.key / 12);
                const freq = baseFreq * Math.pow(2, this.currentNote / 12 + rootShift);

                this.osc1.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.02);
                this.osc2.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.02);

                this.broadcast({ note: this.currentNote, playing: true });
                this.active = true;
            }

            this.step++;
        }

        // Filter responds to energy
        const filterFreq = 200 + heard.energy * 600 + heard.intensity * 300;
        this.filter.frequency.linearRampToValueAtTime(filterFreq, this.ctx.currentTime + 0.05);

        // Volume
        const vol = heard.intensity > 0.15 ? 0.5 : 0.2;
        this.gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.1);

        if (heard.intensity < 0.1) {
            this.active = false;
            this.broadcast({ playing: false });
        }

        this.updateBadge();
    }
}

// ============ KEYS AGENT ============

class KeysAgent extends Agent {
    constructor() {
        super('keys', {
            reactivity: 0.5,
            density: 0.6,
            adventurousness: 0.5,
            listening: 0.8 // Keys listen to everyone
        });

        this.oscs = [];
        this.filter = null;
        this.gain = null;
        this.currentVoicing = [];
    }

    async init(audioCtx) {
        this.ctx = audioCtx;
        this.bus = audioCtx.createGain();
        this.bus.gain.value = 0.4;

        this.filter = audioCtx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 2000;

        this.gain = audioCtx.createGain();
        this.gain.gain.value = 0;

        // Create 4 oscillators for chords
        for (let i = 0; i < 4; i++) {
            const osc = audioCtx.createOscillator();
            osc.type = i < 2 ? 'sine' : 'triangle';
            osc.frequency.value = 220;
            const g = audioCtx.createGain();
            g.gain.value = 0.12;
            osc.connect(g).connect(this.filter);
            osc.start();
            this.oscs.push({ osc, gain: g });
        }

        this.filter.connect(this.gain).connect(this.bus);
    }

    generateVoicing() {
        const heard = this.listen();
        const chord = heard.chord;
        const bassNote = heard.bass.note;

        // Build a voicing that complements the bass
        let voicing = [];

        // If bass has the root, we can skip it
        if (bassNote === 0 || bassNote === null) {
            voicing = [chord[1] || 3, chord[2] || 7, 12, (chord[1] || 3) + 12];
        } else {
            // Include root since bass doesn't have it
            voicing = [0, chord[1] || 3, chord[2] || 7, 12];
        }

        // Add some color based on adventurousness
        if (Math.random() < this.personality.adventurousness) {
            // Add extensions
            const extensions = [9, 11, 13, 14];
            voicing[3] = extensions[Math.floor(Math.random() * extensions.length)];
        }

        return voicing;
    }

    tick(time) {
        const heard = this.listen();

        // Update voicing each bar
        if (SharedState.beat === 0) {
            this.currentVoicing = this.generateVoicing();
            this.broadcast({ voicing: this.currentVoicing, notes: this.currentVoicing });
        }

        // Set frequencies
        const baseFreq = 220 * Math.pow(2, SharedState.key / 12);
        this.oscs.forEach((o, i) => {
            const note = this.currentVoicing[i] || 0;
            const freq = baseFreq * Math.pow(2, note / 12);
            o.osc.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.15);
        });

        // Volume based on stillness (keys swell when you stop moving)
        const stillness = 1 - Math.min(1, heard.energy * 4);
        const targetVol = stillness * 0.2 * heard.intensity;
        this.gain.gain.linearRampToValueAtTime(targetVol, this.ctx.currentTime + 0.2);

        // Filter
        const filterFreq = 1200 + stillness * 1500 + heard.energy * 500;
        this.filter.frequency.linearRampToValueAtTime(filterFreq, this.ctx.currentTime + 0.1);

        this.active = targetVol > 0.02;
        this.broadcast({ notes: this.currentVoicing });
        this.updateBadge();
    }
}

// ============ LEAD AGENT ============

class LeadAgent extends Agent {
    constructor() {
        super('lead', {
            reactivity: 0.8,
            density: 0.4,
            adventurousness: 0.6,
            listening: 0.6
        });

        this.osc = null;
        this.filter = null;
        this.gain = null;
        this.vibrato = null;
        this.vibratoGain = null;
        this.currentPhrase = [];
        this.phraseIndex = 0;
        this.lastNote = 0;
        this.aiModel = null;
    }

    async init(audioCtx) {
        this.ctx = audioCtx;
        this.bus = audioCtx.createGain();
        this.bus.gain.value = 0.35;

        this.osc = audioCtx.createOscillator();
        this.osc.type = 'sawtooth';
        this.osc.frequency.value = 440;

        this.filter = audioCtx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 2500;
        this.filter.Q.value = 3;

        this.gain = audioCtx.createGain();
        this.gain.gain.value = 0;

        this.vibrato = audioCtx.createOscillator();
        this.vibrato.frequency.value = 5;
        this.vibratoGain = audioCtx.createGain();
        this.vibratoGain.gain.value = 0;
        this.vibrato.connect(this.vibratoGain).connect(this.osc.frequency);
        this.vibrato.start();

        this.osc.connect(this.filter).connect(this.gain).connect(this.bus);
        this.osc.start();

        // Try to load Magenta MelodyRNN
        try {
            this.aiModel = new music_rnn.MusicRNN(
                'https://storage.googleapis.com/magentadata/js/checkpoints/music_rnn/melody_rnn'
            );
            await this.aiModel.initialize();
            console.log('Melody AI ready');
        } catch (e) {
            console.warn('Melody AI unavailable');
        }
    }

    generatePhrase() {
        const heard = this.listen();
        const chord = heard.chord;
        const scale = [0, 2, 3, 5, 7, 8, 10]; // Minor scale

        // Listen to what keys are playing - avoid those notes initially
        const keysNotes = (heard.keys.notes || []).map(n => n % 12);

        // Build a phrase
        const phraseLength = 4 + Math.floor(Math.random() * 5);
        const phrase = [];

        let currentNote = this.lastNote;

        for (let i = 0; i < phraseLength; i++) {
            // Decide direction
            let step;
            if (Math.random() < 0.3) {
                // Jump to chord tone
                step = chord[Math.floor(Math.random() * chord.length)] - currentNote;
            } else {
                // Step motion
                step = Math.floor(Math.random() * 5) - 2; // -2 to +2
            }

            currentNote += step;
            currentNote = Math.max(-12, Math.min(24, currentNote));

            phrase.push({
                note: currentNote,
                duration: Math.random() < 0.3 ? 2 : 1 // Some notes are longer
            });
        }

        this.lastNote = currentNote;
        return phrase;
    }

    tick(time) {
        const heard = this.listen();

        // Lead plays when there's motion
        const shouldPlay = heard.energy > 0.03 && heard.intensity > 0.35;

        if (shouldPlay) {
            // Generate new phrase if needed
            if (this.currentPhrase.length === 0 || this.phraseIndex >= this.currentPhrase.length) {
                this.currentPhrase = this.generatePhrase();
                this.phraseIndex = 0;
                this.broadcast({ phrase: this.currentPhrase });

                // Signal call-response opportunity
                this.signal('callResponse', { from: 'lead', phrase: this.currentPhrase });
            }

            // Play current note
            const noteData = this.currentPhrase[this.phraseIndex];
            if (noteData) {
                // X position shifts pitch
                const xShift = (Motion.x - 0.5) * 12;
                const baseFreq = 440 * Math.pow(2, SharedState.key / 12);
                const freq = baseFreq * Math.pow(2, (noteData.note + xShift) / 12);

                this.osc.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.05);
                this.broadcast({ note: noteData.note, playing: true });
            }

            // Advance phrase on beats
            if (SharedState.beat % 2 === 0) {
                this.phraseIndex++;
            }

            // Vibrato
            this.vibratoGain.gain.value = heard.intensity * 10;

            // Filter opens with energy
            const filterFreq = 1500 + heard.energy * 2000 + heard.intensity * 1000;
            this.filter.frequency.linearRampToValueAtTime(filterFreq, this.ctx.currentTime + 0.05);

            // Volume
            this.gain.gain.linearRampToValueAtTime(0.15 * heard.intensity, this.ctx.currentTime + 0.1);
            this.active = true;
        } else {
            this.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.2);
            this.active = false;
            this.broadcast({ playing: false });
            this.currentPhrase = [];
        }

        this.updateBadge();
    }
}

// ============ VOICE AGENT ============

class VoiceAgent extends Agent {
    constructor() {
        super('voice', {
            reactivity: 0.4,
            density: 0.3,
            adventurousness: 0.3,
            listening: 0.9 // Voice listens to everyone before entering
        });

        this.oscs = [];
        this.formantFilters = [];
        this.gain = null;
        this.currentVowel = 'a';
    }

    // Formant frequencies for vowels
    static VOWELS = {
        a: { f1: 800, f2: 1200, f3: 2500 },
        e: { f1: 400, f2: 2000, f3: 2600 },
        i: { f1: 300, f2: 2300, f3: 3000 },
        o: { f1: 500, f2: 900, f3: 2400 },
        u: { f1: 350, f2: 700, f3: 2400 }
    };

    async init(audioCtx) {
        this.ctx = audioCtx;
        this.bus = audioCtx.createGain();
        this.bus.gain.value = 0.35;

        this.gain = audioCtx.createGain();
        this.gain.gain.value = 0;

        // Create carrier oscillators (sawtooth rich in harmonics)
        for (let i = 0; i < 2; i++) {
            const osc = audioCtx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = 220;
            osc.detune.value = i * 5;
            this.oscs.push(osc);
        }

        // Create formant filters
        for (let i = 0; i < 3; i++) {
            const filter = audioCtx.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = VoiceAgent.VOWELS.a[`f${i+1}`];
            filter.Q.value = 10 + i * 5;

            const filterGain = audioCtx.createGain();
            filterGain.gain.value = 0.2 / (i + 1);

            this.formantFilters.push({ filter, gain: filterGain });
        }

        // Connect: oscs -> formants -> gain -> bus
        const oscMix = audioCtx.createGain();
        oscMix.gain.value = 0.3;
        this.oscs.forEach(osc => osc.connect(oscMix));

        this.formantFilters.forEach(({ filter, gain }) => {
            oscMix.connect(filter);
            filter.connect(gain);
            gain.connect(this.gain);
        });

        this.gain.connect(this.bus);
        this.oscs.forEach(osc => osc.start());
    }

    chooseVowel() {
        const heard = this.listen();

        // Choose vowel based on position
        const x = Motion.x;
        if (x < 0.2) return 'a';
        if (x < 0.4) return 'e';
        if (x < 0.6) return 'i';
        if (x < 0.8) return 'o';
        return 'u';
    }

    tick(time) {
        const heard = this.listen();

        // Voice enters on stillness when intensity is high
        // Voice responds to call-response from lead
        const stillness = 1 - Math.min(1, heard.energy * 3);
        const leadCalled = heard.signals.callResponse?.from === 'lead';

        const shouldSing = (stillness > 0.5 && heard.intensity > 0.45) || leadCalled;

        if (shouldSing) {
            // Choose vowel based on position
            this.currentVowel = this.chooseVowel();
            const vowel = VoiceAgent.VOWELS[this.currentVowel];

            // Set formant frequencies (morphing)
            this.formantFilters.forEach(({ filter }, i) => {
                const targetFreq = vowel[`f${i+1}`];
                filter.frequency.linearRampToValueAtTime(targetFreq, this.ctx.currentTime + 0.15);
            });

            // Pitch: follow chord root, Y controls octave
            const chord = heard.chord;
            const rootNote = chord[0];
            const octaveShift = (1 - Motion.y) * 0.5;
            const baseFreq = 220 * Math.pow(2, SharedState.key / 12 + octaveShift);
            const freq = baseFreq * Math.pow(2, rootNote / 12);

            this.oscs.forEach(osc => {
                osc.frequency.linearRampToValueAtTime(freq, this.ctx.currentTime + 0.1);
            });

            // Volume
            const vol = stillness * 0.2 * heard.intensity;
            this.gain.gain.linearRampToValueAtTime(vol, this.ctx.currentTime + 0.2);

            this.active = true;
            this.broadcast({ note: rootNote, vowel: this.currentVowel, playing: true });
        } else {
            this.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.3);
            this.active = false;
            this.broadcast({ playing: false });
        }

        this.updateBadge();
    }
}

// ============ MASTER FX ============

let masterBus, reverb, reverbWet, delay, delayWet, compressor, limiter;

function initMasterFX(audioCtx) {
    masterBus = audioCtx.createGain();
    masterBus.gain.value = 1;

    // Saturation
    const sat = audioCtx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        curve[i] = Math.tanh((i / 32768 - 1) * 1.4) * 0.95;
    }
    sat.curve = curve;
    sat.oversample = '2x';

    // Reverb
    reverb = audioCtx.createConvolver();
    const reverbLen = audioCtx.sampleRate * 2.5;
    const reverbBuf = audioCtx.createBuffer(2, reverbLen, audioCtx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = reverbBuf.getChannelData(ch);
        for (let i = 0; i < reverbLen; i++) {
            d[i] = (Math.random() * 2 - 1) * Math.exp(-i / audioCtx.sampleRate / 1.3) * 0.4;
        }
    }
    reverb.buffer = reverbBuf;
    reverbWet = audioCtx.createGain();
    reverbWet.gain.value = 0.22;

    // Delay
    delay = audioCtx.createDelay(1);
    delay.delayTime.value = 60 / SharedState.bpm * 0.75; // Dotted 8th
    const delayFb = audioCtx.createGain();
    delayFb.gain.value = 0.3;
    const delayFilter = audioCtx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2500;
    delay.connect(delayFilter).connect(delayFb).connect(delay);
    delayWet = audioCtx.createGain();
    delayWet.gain.value = 0.15;
    delayFilter.connect(delayWet);

    // Compressor
    compressor = audioCtx.createDynamicsCompressor();
    compressor.threshold.value = -12;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.12;

    // Limiter
    limiter = audioCtx.createDynamicsCompressor();
    limiter.threshold.value = -1;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;

    // Master out
    master = audioCtx.createGain();
    master.gain.value = 0.85;

    // Routing
    masterBus.connect(sat).connect(compressor);
    masterBus.connect(reverb); reverb.connect(reverbWet);
    masterBus.connect(delay);
    [compressor, reverbWet, delayWet].forEach(n => n.connect(limiter));
    limiter.connect(master).connect(audioCtx.destination);

    return masterBus;
}

// ============ ORCHESTRA ============

const Orchestra = {
    agents: {},

    async init(audioCtx) {
        const masterOut = initMasterFX(audioCtx);

        // Create agents
        this.agents.drums = new DrumAgent();
        this.agents.bass = new BassAgent();
        this.agents.keys = new KeysAgent();
        this.agents.lead = new LeadAgent();
        this.agents.voice = new VoiceAgent();

        // Initialize each agent
        const status = document.getElementById('load-status');

        for (const [name, agent] of Object.entries(this.agents)) {
            status.textContent = `loading ${name}...`;
            await agent.init(audioCtx);
            agent.bus.connect(masterOut);
        }

        status.textContent = 'ready';
    },

    tick(time) {
        // Update each agent
        for (const agent of Object.values(this.agents)) {
            agent.tick(time);
        }

        // Update shared harmony periodically
        if (SharedState.beat === 0) {
            this.updateHarmony();
        }
    },

    updateHarmony() {
        // Progress chord every few bars
        const progressions = {
            minor: [
                { chord: [0, 3, 7], name: 'Am' },
                { chord: [5, 8, 12], name: 'Dm' },
                { chord: [3, 7, 10], name: 'C' },
                { chord: [7, 10, 14], name: 'Em' }
            ]
        };

        const prog = progressions[SharedState.mode];
        const chordIndex = SharedState.bar % prog.length;
        SharedState.chord = prog[chordIndex].chord;
        SharedState.chordName = prog[chordIndex].name;
    }
};

// ============ VISUALS ============

function resize() {
    const dpr = devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    vc.fillStyle = `rgba(8,8,12,${0.1 + SharedState.intensity * 0.04})`;
    vc.fillRect(0, 0, w, h);

    // Center - conductor position
    const cx = w / 2, cy = h / 2;

    // Draw agent activity as rings
    const agents = ['drums', 'bass', 'keys', 'lead', 'voice'];
    agents.forEach((name, i) => {
        const agent = Orchestra.agents[name];
        if (agent && agent.active) {
            const r = 30 + i * 25;
            const alpha = 0.1 + (agent.active ? 0.15 : 0);
            vc.strokeStyle = `rgba(200,180,255,${alpha})`;
            vc.lineWidth = 1;
            vc.beginPath();
            vc.arc(cx, cy, r, 0, TAU);
            vc.stroke();
        }
    });

    // Beat pulse
    const beatPhase = (SharedState.beat % 4) / 4;
    const pulseR = 20 + (1 - beatPhase) * 15 * SharedState.intensity;
    vc.fillStyle = `rgba(200,180,255,${0.03 + (1 - beatPhase) * 0.05})`;
    vc.beginPath();
    vc.arc(cx, cy, pulseR, 0, TAU);
    vc.fill();

    // Motion cursor
    const mx = Motion.x * w, my = Motion.y * h;
    vc.fillStyle = `rgba(220,200,255,${0.2 + Motion.energy * 0.5})`;
    vc.beginPath();
    vc.arc(mx, my, 5 + Motion.energy * 15, 0, TAU);
    vc.fill();

    // Chord indicator
    vc.fillStyle = 'rgba(200,180,255,0.15)';
    vc.font = '10px system-ui';
    vc.fillText(SharedState.chordName, 15, h - 15);
}

// ============ MAIN ============

let audioCtx;

async function init() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    await Orchestra.init(audioCtx);

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    addEventListener('resize', resize);

    document.getElementById('loading').classList.add('off');
    document.getElementById('agents').style.display = 'flex';
}

function tick() {
    if (!running) return;

    Motion.energy *= 0.96;
    Orchestra.tick(audioCtx.currentTime);
    draw();

    requestAnimationFrame(tick);
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('loading').classList.remove('off');

    // Request permissions
    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch (e) {}
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
    }

    await init();

    // Input handlers
    addEventListener('devicemotion', e => {
        const a = e.accelerationIncludingGravity;
        if (!a) return;
        const ax = (a.x || 0) / 10;
        const ay = (a.y || 0) / 10;
        Motion.update(
            Math.max(0, Math.min(1, Motion.x + ax * 0.08)),
            Math.max(0, Math.min(1, Motion.y - ay * 0.08))
        );
    });

    addEventListener('deviceorientation', e => {
        const gx = (e.gamma || 0) / 45;
        const gy = (e.beta || 0) / 45 - 0.5;
        Motion.update((gx + 1) / 2, (1 - gy) / 2);
    });

    canvas.addEventListener('mousemove', e => {
        Motion.update(e.clientX / innerWidth, e.clientY / innerHeight);
    });

    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        Motion.update(e.touches[0].clientX / innerWidth, e.touches[0].clientY / innerHeight);
    }, { passive: false });

    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        Motion.update(e.touches[0].clientX / innerWidth, e.touches[0].clientY / innerHeight);
    }, { passive: false });

    if (audioCtx.state === 'suspended') await audioCtx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
