<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Weather + Spatial AI Music</title>
  <style>
    /* FULL Claude-level CSS with themes (storm, rain, void, etc.) would go here */
    /* Placeholder for brevity, but you already have this covered in your template */
  </style>
</head>
<body>
  <!-- UI Elements from Claude version -->
  <div class="app">
    <div class="logo">GUMP</div>
    <div class="tagline">Your Life, Soundtracked by AI</div>
    <div class="weather-status" id="weather">üå§Ô∏è Loading weather...</div>

    <button class="start-btn" id="start">üéµ Start Spatial Audio</button>

    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>

    <div class="stats hidden" id="stats">
      <div class="stat"><div class="stat-value" id="motion">0</div><div class="stat-label">Motion</div></div>
      <div class="stat"><div class="stat-value" id="bpm">95</div><div class="stat-label">BPM</div></div>
      <div class="stat"><div class="stat-value" id="groove">CHILL</div><div class="stat-label">Groove</div></div>
      <div class="stat"><div class="stat-value" id="weather-mode">CLEAR</div><div class="stat-label">Weather</div></div>
    </div>

    <div class="status hidden" id="status">üéµ Flowing with your vibe...</div>
    <div class="error hidden" id="error"></div>
  </div>

  <script>
// CLAUDE-GRADE FULL ENGINE DROP

class Gump {
  constructor() {
    this.ctx = null;
    this.motion = 0;
    this.bpm = 90;
    this.last = { x: 0, y: 0, z: 0 };
    this.pos = { x: 50, y: 50 };
    this.step = 0;
    this.motionHistory = [];
    this.voidMode = false;
    this.weather = 'clear';
    this.active = false;

    this.weatherGain = null;
    this.ambientGain = null;
    this.voidOscs = [];
    this.chordIndex = 0;
    this.bassIndex = 0;

    this.swing = [0, 0.1, 0, 0.15, 0, 0.08, 0, 0.12];
    this.patterns = {
      kick: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
      snare: [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
      hat: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
    };

    this.bassNotes = [55, 65, 73.4, 82.4];
    this.chords = [
      [261.63, 329.63, 392.00], // C major
      [293.66, 369.99, 440.00], // D minor
      [329.63, 415.30, 493.88], // E minor
      [349.23, 440.00, 523.25]  // F major
    ];

    this.init();
  }

  init() {
    document.getElementById('start').addEventListener('click', () => this.start());
    this.getWeather();
  }

  async getWeather() {
    try {
      const pos = await new Promise((res, rej) => navigator.geolocation.getCurrentPosition(res, rej));
      const r = await fetch(`https://api.openweathermap.org/data/2.5/weather?lat=${pos.coords.latitude}&lon=${pos.coords.longitude}&appid=demo&units=metric`);
      const data = await r.json();
      const condition = data.weather[0].main.toLowerCase();
      if (condition.includes('storm')) this.weather = 'storm';
      else if (condition.includes('rain')) this.weather = 'rain';
      else if (condition.includes('snow')) this.weather = 'snow';
      else this.weather = 'clear';
      document.getElementById('weather-mode').textContent = this.weather.toUpperCase();
    } catch (e) {
      this.weather = 'clear';
      document.getElementById('weather-mode').textContent = 'CLEAR';
    }
  }

  async start() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    await this.ctx.resume();
    this.ambientGain = this.ctx.createGain();
    this.weatherGain = this.ctx.createGain();
    this.ambientGain.connect(this.ctx.destination);
    this.weatherGain.connect(this.ctx.destination);

    ['start', 'viz', 'stats', 'status'].forEach(id => {
      document.getElementById(id).classList.toggle('hidden');
    });

    this.active = true;
    this.startSensors();
    this.startGroove();
    this.startWeatherAudio();
  }

  startSensors() {
    window.addEventListener('devicemotion', e => {
      const acc = e.accelerationIncludingGravity;
      if (!acc) return;
      const dx = acc.x - this.last.x;
      const dy = acc.y - this.last.y;
      const dz = acc.z - this.last.z;
      this.motion = Math.min(100, Math.sqrt(dx * dx + dy * dy + dz * dz) * 10);
      this.motionHistory.push(this.motion);
      if (this.motionHistory.length > 30) this.motionHistory.shift();
      this.last = { x: acc.x, y: acc.y, z: acc.z };

      this.pos.x = 50 + acc.x * 5;
      this.pos.y = 50 + acc.y * 5;

      this.checkVoid();
      this.updateGroove();
      this.updateVisual();
    }, true);
  }

  checkVoid() {
    const avg = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
    if (avg < 4 && this.motionHistory.length > 20 && !this.voidMode) this.enterVoid();
    else if (avg > 10 && this.voidMode) this.exitVoid();
  }

  enterVoid() {
    this.voidMode = true;
    this.groove = 'VOID';
    document.getElementById('status').textContent = '‚ú® Floating in the void...';
    this.startVoidAmbient();
  }

  exitVoid() {
    this.voidMode = false;
    document.getElementById('status').textContent = 'üéµ Flowing with your vibe...';
    this.stopVoidAmbient();
  }

  updateVisual() {
    const orb = document.getElementById('orb');
    orb.style.left = `${this.pos.x}%`;
    orb.style.top = `${this.pos.y}%`;
    document.getElementById('motion').textContent = Math.round(this.motion);
    document.getElementById('bpm').textContent = Math.round(this.bpm);
    document.getElementById('groove').textContent = this.groove;
  }

  startVoidAmbient() {
    [220, 277, 330, 415].forEach(freq => {
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      osc.type = 'sine';
      osc.frequency.value = freq;
      gain.gain.value = 0.03;
      osc.connect(gain).connect(this.ambientGain);
      osc.start();
      this.voidOscs.push(osc);
    });
    this.ambientGain.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 2);
  }

  stopVoidAmbient() {
    this.ambientGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
    this.voidOscs.forEach(o => o.stop());
    this.voidOscs = [];
  }

  updateGroove() {
    if (this.voidMode) return;
    if (this.motion < 20) { this.groove = 'CHILL'; this.bpm = 85; }
    else if (this.motion < 60) { this.groove = 'POCKET'; this.bpm = 95; }
    else { this.groove = 'BOUNCE'; this.bpm = 110; }
  }

  startGroove() {
    const loop = () => {
      if (!this.active) return;
      if (!this.voidMode) this.playStep();
      this.step = (this.step + 1) % 16;
      if (this.step % 8 === 0) this.bassIndex = (this.bassIndex + 1) % this.bassNotes.length;
      if (this.step % 4 === 0) this.chordIndex = (this.chordIndex + 1) % this.chords.length;

      const swing = this.swing[this.step % 8] * 50;
      setTimeout(loop, (60000 / this.bpm / 4) + swing);
    };
    loop();
  }

  playStep() {
    const i = this.step;
    if (this.patterns.kick[i]) this.kick();
    if (this.patterns.snare[i]) this.snare();
    if (this.patterns.hat[i]) this.hat();
    if (i % 4 === 0) this.chord();
    if (i % 8 === 4) this.bass();
    if (this.motion > 50 && Math.random() < 0.1) this.spatialHit();
  }

  kick() {
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.frequency.setValueAtTime(80, this.ctx.currentTime);
    o.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.2);
    g.gain.setValueAtTime(1, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    o.connect(g).connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + 0.3);
  }

  snare() {
    const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.1));
    }
    const source = this.ctx.createBufferSource();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    source.buffer = buffer;
    filter.type = 'bandpass';
    filter.frequency.value = 1000;
    gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
    source.connect(filter).connect(gain).connect(this.ctx.destination);
    source.start();
  }

  hat() {
    const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.02));
    }
    const source = this.ctx.createBufferSource();
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    const panner = this.ctx.createStereoPanner();
    filter.type = 'highpass';
    filter.frequency.value = 8000;
    panner.pan.value = (this.pos.x - 50) / 50;
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
    source.buffer = buffer;
    source.connect(filter).connect(gain).connect(panner).connect(this.ctx.destination);
    source.start();
  }

  chord() {
    const chord = this.chords[this.chordIndex];
    const panner = this.ctx.createStereoPanner();
    panner.pan.value = (this.pos.x - 50) / 50;
    chord.forEach(freq => {
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      o.frequency.value = freq;
      o.type = 'sine';
      g.gain.setValueAtTime(0.1, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
      o.connect(g).connect(panner).connect(this.ctx.destination);
      o.start(); o.stop(this.ctx.currentTime + 0.4);
    });
  }

  bass() {
    const o = this.ctx.createOscillator();
    const g = this.ctx.createGain();
    o.type = 'sine';
    o.frequency.value = this.bassNotes[this.bassIndex];
    g.gain.setValueAtTime(0.3, this.ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
    o.connect(g).connect(this.ctx.destination);
    o.start(); o.stop(this.ctx.currentTime + 0.4);
  }

  spatialHit() {
    const freqs = [600, 800, 1000];
    freqs.forEach((freq, i) => {
      const o = this.ctx.createOscillator();
      const g = this.ctx.createGain();
      const p = this.ctx.createStereoPanner();
      o.type = 'sine';
      o.frequency.value = freq;
      p.pan.value = ((this.pos.x - 50) / 50) * (i - 1);
      g.gain.setValueAtTime(0.15, this.ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3 + i * 0.1);
      o.connect(g).connect(p).connect(this.ctx.destination);
      o.start();
      o.stop(this.ctx.currentTime + 0.3 + i * 0.1);
    });
  }

  startWeatherAudio() {
    if (this.weather === 'rain') this.rain();
    else if (this.weather === 'storm') this.storm();
    else if (this.weather === 'snow') this.snow();
  }

  rain() {
    for (let i = 0; i < 8; i++) {
      const o = this.ctx.createBufferSource();
      const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
      const d = buffer.getChannelData(0);
      for (let j = 0; j < d.length; j++) d[j] = Math.random() * 0.2 * Math.exp(-j / (d.length * 0.2));
      o.buffer = buffer;
      o.loop = true;
      const g = this.ctx.createGain();
      g.gain.value = 0.02 + Math.random() * 0.01;
      o.connect(g).connect(this.weatherGain);
      o.start();
    }
    this.weatherGain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 2);
  }

  storm() {
    this.rain();
    const wind = this.ctx.createOscillator();
    wind.type = 'sine';
    wind.frequency.value = 40;
    const g = this.ctx.createGain();
    g.gain.value = 0.1;
    wind.connect(g).connect(this.weatherGain);
    wind.start();
  }

  snow() {
    const o = this.ctx.createOscillator();
    o.type = 'sine';
    o.frequency.value = 1200;
    const g = this.ctx.createGain();
    g.gain.value = 0.03;
    o.connect(g).connect(this.weatherGain);
    o.start();
    this.weatherGain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 3);
  }
}

new Gump();
</script>
</body>
</html>
