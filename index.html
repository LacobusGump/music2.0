<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP - Reality to Music</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        /* Fibonacci-based layout */
        .container {
            width: 89vw;
            height: 55vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Init button */
        .init {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 21px 34px;
            font-size: 13px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .init:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.05);
        }

        /* Main interface (hidden until init) */
        .interface {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }

        /* Status */
        .status {
            position: absolute;
            top: 0;
            left: 0;
            font-size: 11px;
            letter-spacing: 2px;
            opacity: 0.5;
        }

        /* BPM */
        .bpm {
            position: absolute;
            top: 0;
            right: 0;
            font-size: 34px;
            font-weight: 100;
            opacity: 0.8;
        }

        .bpm-label {
            font-size: 11px;
            opacity: 0.5;
        }

        /* Waveform visualization */
        .waveform {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 610px;
            height: 377px;
            opacity: 0.3;
        }

        /* Energy meter */
        .energy {
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 233px;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .energy-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
            transition: width 0.3s;
        }
        
        /* Phase indicator */
        .energy.intro .energy-fill {
            background: linear-gradient(90deg, #0066ff, #00aaff);
        }
        
        .energy.buildup .energy-fill {
            background: linear-gradient(90deg, #00ff00, #ffff00);
        }
        
        .energy.peak .energy-fill {
            background: linear-gradient(90deg, #ff0000, #ff00ff, #00ffff);
        }
        
        .energy.breakdown .energy-fill {
            background: linear-gradient(90deg, #ff00ff, #6600ff);
        }
        
        .energy.outro .energy-fill {
            background: linear-gradient(90deg, #0066ff, #000033);
        }

        /* Sample indicators */
        .samples {
            position: absolute;
            bottom: 34px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 13px;
        }

        .sample-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.1);
            transition: all 0.3s;
        }

        .sample-dot.active {
            background: rgba(255, 255, 255, 0.8);
            box-shadow: 0 0 13px rgba(255, 255, 255, 0.5);
        }

        /* Debug info */
        .debug {
            position: absolute;
            bottom: 0;
            left: 0;
            font-size: 10px;
            font-family: monospace;
            opacity: 0.3;
        }
        
        /* Test capture button */
        .test-capture {
            position: absolute;
            top: 34px;
            left: 0;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: rgba(255, 255, 255, 0.5);
            padding: 5px 8px;
            font-size: 10px;
            cursor: pointer;
            display: none;
        }
        
        .test-capture:hover {
            border-color: rgba(255, 255, 255, 0.5);
        }
        
        /* Help text */
        .help {
            position: absolute;
            top: 60px;
            left: 0;
            font-size: 9px;
            opacity: 0.3;
            line-height: 1.4;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="init" id="initBtn">INITIALIZE</button>
        
        <div class="interface" id="interface">
            <div class="status" id="status">LISTENING</div>
            <div class="bpm">
                <div class="bpm-label">BPM</div>
                <div id="bpmValue">105</div>
            </div>
            
            <button class="test-capture" id="testCapture">TEST CAPTURE</button>
            
            <div class="help" id="help">
                SPACE: Test capture<br>
                T: Tap tempo<br>
                Make sounds near mic to capture
            </div>
            
            <canvas class="waveform" id="waveform" width="610" height="377"></canvas>
            
            <div class="samples" id="samples"></div>
            
            <div class="energy">
                <div class="energy-fill" id="energyFill"></div>
            </div>
            
            <div class="kick-flash" id="kickFlash"></div>
            
            <div class="debug" id="debug"></div>
        </div>
    </div>

    <script>
        class GumpDJ {
            constructor() {
                // Core audio
                this.ctx = null;
                this.input = null;
                this.analyser = null;
                this.recorder = null;
                
                // Master output
                this.master = null;
                this.limiter = null;
                
                // Recording buffer (30 seconds)
                this.bufferSize = 0;
                this.recordBuffer = null;
                this.writePos = 0;
                
                // Beat engine
                this.bpm = 105;
                this.nextKick = 0;
                this.kickPlaying = false;
                this.tapTimes = [];
                this.lastTap = 0;
                
                // Sample banks
                this.samples = {
                    bass: [],
                    mid: [],
                    high: [],
                    texture: []
                };
                
                // Performance evolution
                this.evolution = {
                    phase: 'intro', // intro, buildup, peak, breakdown, outro
                    intensity: 0.2,
                    samplePlayback: []
                };
                
                // FX buses
                this.fx = {};
                
                // Analysis
                this.fftData = null;
                this.spectralCentroid = 0;
                this.spectralFlux = 0;
                this.previousSpectrum = null;
                
                // Performance state
                this.energy = 0;
                this.captureCount = 0;
                this.lastCaptureTime = 0;
                
                // UI
                this.ui = {
                    init: document.getElementById('initBtn'),
                    interface: document.getElementById('interface'),
                    status: document.getElementById('status'),
                    bpm: document.getElementById('bpmValue'),
                    waveform: document.getElementById('waveform'),
                    samples: document.getElementById('samples'),
                    energyFill: document.getElementById('energyFill'),
                    debug: document.getElementById('debug'),
                    testCapture: document.getElementById('testCapture'),
                    help: document.getElementById('help'),
                    kickFlash: document.getElementById('kickFlash')
                };
                
                // Create sample indicators
                for (let i = 0; i < 21; i++) {
                    const dot = document.createElement('div');
                    dot.className = 'sample-dot';
                    this.ui.samples.appendChild(dot);
                }
                
                this.ui.init.addEventListener('click', () => this.initialize());
            }
            
            async initialize() {
                try {
                    // Create audio context (with resume for Chrome)
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'playback',
                        sampleRate: 44100
                    });
                    
                    // Resume context if suspended
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                    
                    this.ui.debug.textContent = 'Audio context: ' + this.ctx.state;
                    
                    // Get microphone with specific constraints
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        } 
                    });
                    
                    this.ui.debug.textContent = 'Mic access granted, tracks: ' + stream.getAudioTracks().length;
                    
                    // Setup audio chain
                    this.setupAudio(stream);
                    
                    // Show interface
                    this.ui.init.style.display = 'none';
                    this.ui.interface.style.display = 'block';
                    
                    // Start the engine
                    this.start();
                    
                } catch (err) {
                    console.error('Init failed:', err);
                    this.ui.debug.textContent = 'Error: ' + err.message;
                    
                    if (err.name === 'NotAllowedError') {
                        alert('Microphone access denied. Please allow microphone access and reload.');
                    } else if (err.name === 'NotFoundError') {
                        alert('No microphone found. Please connect a microphone.');
                    } else {
                        alert('Error: ' + err.message);
                    }
                }
            }
            
            setupAudio(stream) {
                // Input from mic
                this.input = this.ctx.createMediaStreamSource(stream);
                
                // Analyser for visualization
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                this.fftData = new Uint8Array(this.analyser.frequencyBinCount);
                this.previousSpectrum = new Float32Array(this.analyser.frequencyBinCount);
                
                // Recording buffer
                this.bufferSize = this.ctx.sampleRate * 30;
                this.recordBuffer = new Float32Array(this.bufferSize);
                
                // Script processor for recording (using larger buffer for stability)
                try {
                    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                } catch (e) {
                    // Fallback for older browsers
                    this.recorder = this.ctx.createJavaScriptNode(4096, 1, 1);
                }
                
                this.recorder.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    this.recordAudio(input);
                };
                
                // Master chain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.9;
                
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -3;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.05;
                
                // Setup FX
                this.setupFX();
                
                // Connect input chain
                this.input.connect(this.analyser);
                this.input.connect(this.recorder);
                
                // IMPORTANT: Script processor needs output connection to work
                const silentGain = this.ctx.createGain();
                silentGain.gain.value = 0; // Mute the monitoring
                this.recorder.connect(silentGain);
                silentGain.connect(this.ctx.destination);
                
                // Connect output chain
                this.master.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);
                
                this.ui.debug.textContent = 'Audio chain ready, sample rate: ' + this.ctx.sampleRate;
            }
            
            setupFX() {
                // Sidechain compressor
                this.fx.sidechain = this.ctx.createGain();
                this.fx.sidechain.gain.value = 1;
                
                // Simple reverb using delay network
                this.fx.reverb = this.createReverb();
                this.fx.reverbSend = this.ctx.createGain();
                this.fx.reverbSend.gain.value = 0.3;
                
                // Delay
                this.fx.delay = this.ctx.createDelay(1);
                this.fx.delay.delayTime.value = 60 / this.bpm / 4; // 1/16 note
                this.fx.delayFeedback = this.ctx.createGain();
                this.fx.delayFeedback.gain.value = 0.5;
                this.fx.delaySend = this.ctx.createGain();
                this.fx.delaySend.gain.value = 0.2;
                
                // Filter
                this.fx.filter = this.ctx.createBiquadFilter();
                this.fx.filter.type = 'lowpass';
                this.fx.filter.frequency.value = 20000;
                
                // Connect FX
                this.fx.sidechain.connect(this.fx.filter);
                this.fx.filter.connect(this.master);
                
                // Reverb send
                this.fx.sidechain.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb.input);
                this.fx.reverb.output.connect(this.master);
                
                // Delay send
                this.fx.sidechain.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delay);
                this.fx.delay.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delay);
                this.fx.delay.connect(this.master);
            }
            
            createReverb() {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                output.gain.value = 0.5; // Reduce reverb output
                
                // Simple delay network reverb
                const delays = [0.03, 0.05, 0.07, 0.11];
                const gains = [0.7, 0.6, 0.5, 0.4];
                
                delays.forEach((delayTime, i) => {
                    const delay = this.ctx.createDelay(1);
                    const gain = this.ctx.createGain();
                    const feedback = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                    
                    delay.delayTime.value = delayTime * (1 + i * 0.1); // Slightly different times
                    gain.gain.value = gains[i];
                    feedback.gain.value = 0.4; // Reduced feedback
                    
                    // Add damping filter
                    filter.type = 'lowpass';
                    filter.frequency.value = 3000 - (i * 500);
                    
                    input.connect(delay);
                    delay.connect(filter);
                    filter.connect(gain);
                    filter.connect(feedback);
                    feedback.connect(delay);
                    gain.connect(output);
                });
                
                return { input, output };
            }
            
            recordAudio(input) {
                // Check if we're getting actual audio
                let hasSignal = false;
                let maxLevel = 0;
                for (let i = 0; i < input.length; i++) {
                    const level = Math.abs(input[i]);
                    maxLevel = Math.max(maxLevel, level);
                    if (level > 0.001) {
                        hasSignal = true;
                    }
                }
                
                // Write to circular buffer regardless
                for (let i = 0; i < input.length; i++) {
                    this.recordBuffer[this.writePos] = input[i];
                    this.writePos = (this.writePos + 1) % this.bufferSize;
                }
                
                // Analyze
                this.analyser.getByteFrequencyData(this.fftData);
                this.analyze();
                
                // Detect interesting moments
                if (this.detectCapture()) {
                    this.capture();
                } else if (!hasSignal && Math.random() < 0.001 && this.captureCount > 5) {
                    // Occasionally capture silence as texture after we have some samples
                    this.captureSilence();
                }
                
                // Update debug info periodically
                if (Math.random() < 0.05) {
                    const maxFFT = Math.max(...this.fftData);
                    this.ui.debug.textContent = `Level: ${maxLevel.toFixed(3)}, FFT: ${maxFFT}, Flux: ${this.spectralFlux.toFixed(2)}`;
                }
            }
            
            captureSilence() {
                // Create texture from noise floor
                const duration = 0.5 + Math.random() * 0.5;
                const samples = Math.floor(this.ctx.sampleRate * duration);
                const buffer = this.ctx.createBuffer(1, samples, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Copy recent silence with amplification
                const start = (this.writePos - samples + this.bufferSize) % this.bufferSize;
                for (let i = 0; i < samples; i++) {
                    const pos = (start + i) % this.bufferSize;
                    // Amplify noise floor and add slight randomization
                    data[i] = this.recordBuffer[pos] * 100 + (Math.random() - 0.5) * 0.01;
                    
                    // Apply window
                    const window = Math.sin(Math.PI * i / samples);
                    data[i] *= window;
                }
                
                // Set as texture type
                this.spectralCentroid = 10000; // Force high frequency classification
                this.processSample(buffer);
                
                this.ui.status.textContent = `CAPTURED: ${this.captureCount} (silence as texture)`;
            }
            
            analyze() {
                // Check if we have valid FFT data
                const maxValue = Math.max(...this.fftData);
                if (maxValue === 0) {
                    // No frequency data yet
                    return;
                }
                
                // Spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 0; i < this.fftData.length; i++) {
                    const magnitude = this.fftData[i] / 255;
                    const frequency = i * this.ctx.sampleRate / (2 * this.fftData.length);
                    weightedSum += frequency * magnitude;
                    magnitudeSum += magnitude;
                }
                
                this.spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                
                // Spectral flux - with safety check
                let flux = 0;
                if (this.previousSpectrum[0] !== undefined) {
                    for (let i = 0; i < this.fftData.length; i++) {
                        const current = this.fftData[i] / 255;
                        const previous = this.previousSpectrum[i] || 0;
                        const diff = current - previous;
                        if (diff > 0) flux += diff;
                        this.previousSpectrum[i] = current;
                    }
                } else {
                    // Initialize previous spectrum
                    for (let i = 0; i < this.fftData.length; i++) {
                        this.previousSpectrum[i] = this.fftData[i] / 255;
                    }
                }
                this.spectralFlux = flux;
            }
            
            detectCapture() {
                // More sensitive detection with multiple criteria
                const threshold = 0.2 - (this.energy * 0.15);
                const fluxTriggered = this.spectralFlux > threshold;
                const centroidValid = this.spectralCentroid > 50 && this.spectralCentroid < 20000;
                
                // Check for sufficient signal level
                const avgLevel = this.fftData.reduce((a, b) => a + b, 0) / this.fftData.length;
                const hasSignal = avgLevel > 5; // Lower threshold
                
                // Debug output occasionally
                if (Math.random() < 0.02) {
                    this.ui.debug.textContent = `Flux: ${this.spectralFlux.toFixed(2)}, Threshold: ${threshold.toFixed(2)}, Avg: ${avgLevel.toFixed(0)}`;
                }
                
                return fluxTriggered && centroidValid && hasSignal;
            }
            
            capture() {
                // Prevent capturing too frequently
                const now = Date.now();
                if (this.lastCaptureTime && (now - this.lastCaptureTime) < 500) {
                    return; // Wait at least 500ms between captures
                }
                this.lastCaptureTime = now;
                
                // Determine capture length based on spectral flux
                const baseLength = 0.1;
                const maxLength = 2.0;
                const normalizedFlux = Math.min(1, this.spectralFlux / 5); // Normalize flux
                const length = baseLength + (normalizedFlux * (maxLength - baseLength));
                const samples = Math.floor(this.ctx.sampleRate * length);
                
                // Create buffer
                const buffer = this.ctx.createBuffer(1, samples, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Copy from circular buffer with window function
                const start = (this.writePos - samples + this.bufferSize) % this.bufferSize;
                for (let i = 0; i < samples; i++) {
                    const pos = (start + i) % this.bufferSize;
                    // Apply simple fade in/out
                    let window = 1;
                    if (i < 100) window = i / 100;
                    if (i > samples - 100) window = (samples - i) / 100;
                    data[i] = this.recordBuffer[pos] * window;
                }
                
                // Process and categorize
                this.processSample(buffer);
                
                // Update UI
                this.updateSampleIndicator();
                
                // Update energy
                this.energy = Math.min(1, this.energy + 0.1);
                this.updateEnergy();
                
                this.captureCount++;
                this.ui.status.textContent = `CAPTURED: ${this.captureCount}`;
            }
            
            processSample(buffer) {
                // Normalize the buffer
                const data = buffer.getChannelData(0);
                let maxAmp = 0;
                for (let i = 0; i < data.length; i++) {
                    maxAmp = Math.max(maxAmp, Math.abs(data[i]));
                }
                
                if (maxAmp > 0 && maxAmp < 0.9) {
                    // Normalize to 0.7 peak
                    const gain = 0.7 / maxAmp;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= gain;
                    }
                }
                
                // Categorize by frequency content
                let category;
                if (this.spectralCentroid < 200) {
                    category = 'bass';
                } else if (this.spectralCentroid < 2000) {
                    category = 'mid';
                } else if (this.spectralCentroid < 8000) {
                    category = 'high';
                } else {
                    category = 'texture';
                }
                
                // Store sample
                this.samples[category].push({
                    buffer: buffer,
                    centroid: this.spectralCentroid,
                    timestamp: Date.now()
                });
                
                // Limit samples per category
                if (this.samples[category].length > 8) {
                    this.samples[category].shift();
                }
                
                // Play immediately with processing
                this.playSample(buffer, category);
            }
            
            playSample(buffer, category) {
                if (!buffer || buffer.length === 0) return;
                
                const now = this.ctx.currentTime;
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                
                // Create processing chain
                const inputGain = this.ctx.createGain();
                const env = this.ctx.createGain();
                
                // Advanced category-specific processing
                let processedNode = inputGain;
                
                switch(category) {
                    case 'bass':
                        // Sub bass processing
                        source.playbackRate.value = 0.5; // Octave down
                        
                        // Add harmonics
                        const bassWaveshaper = this.ctx.createWaveShaper();
                        bassWaveshaper.curve = this.createHarmonicCurve(3);
                        
                        // Heavy lowpass
                        const bassFilter = this.ctx.createBiquadFilter();
                        bassFilter.type = 'lowpass';
                        bassFilter.frequency.value = 200;
                        bassFilter.Q.value = 5;
                        
                        inputGain.connect(bassWaveshaper);
                        bassWaveshaper.connect(bassFilter);
                        processedNode = bassFilter;
                        break;
                        
                    case 'mid':
                        // Harmonic processing
                        source.playbackRate.value = this.quantizePitch();
                        
                        // Resonant filter sweep
                        const midFilter = this.ctx.createBiquadFilter();
                        midFilter.type = 'bandpass';
                        midFilter.frequency.value = 1000;
                        midFilter.Q.value = 10;
                        
                        // Automate filter
                        midFilter.frequency.setValueAtTime(500, now);
                        midFilter.frequency.exponentialRampToValueAtTime(2000, now + buffer.duration);
                        
                        inputGain.connect(midFilter);
                        processedNode = midFilter;
                        break;
                        
                    case 'high':
                        // Crystalline processing
                        source.playbackRate.value = 2; // Octave up
                        
                        // Ring modulation for alien effect
                        const ringMod = this.ctx.createGain();
                        const modOsc = this.ctx.createOscillator();
                        modOsc.frequency.value = 700 + Math.random() * 300;
                        
                        ringMod.gain.value = 0;
                        modOsc.connect(ringMod.gain);
                        inputGain.connect(ringMod);
                        
                        modOsc.start(now);
                        modOsc.stop(now + buffer.duration);
                        
                        processedNode = ringMod;
                        break;
                        
                    case 'texture':
                        // Granular-style processing
                        source.loop = true;
                        source.loopStart = 0;
                        source.loopEnd = Math.min(0.5, buffer.duration * 0.5);
                        
                        // Slow random pitch modulation
                        const lfo = this.ctx.createOscillator();
                        lfo.frequency.value = 0.2;
                        const lfoGain = this.ctx.createGain();
                        lfoGain.gain.value = 0.1;
                        
                        lfo.connect(lfoGain);
                        lfoGain.connect(source.playbackRate);
                        source.playbackRate.value = 1;
                        
                        lfo.start(now);
                        lfo.stop(now + 60 / this.bpm * 4);
                        
                        // Comb filter for metallic texture
                        const comb = this.ctx.createDelay(0.1);
                        comb.delayTime.value = 1 / (100 + Math.random() * 200);
                        const combFeedback = this.ctx.createGain();
                        combFeedback.gain.value = 0.8;
                        
                        inputGain.connect(comb);
                        comb.connect(combFeedback);
                        combFeedback.connect(comb);
                        comb.connect(env);
                        
                        processedNode = inputGain; // Already connected through comb
                        break;
                }
                
                // Envelope
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(0.5, now + 0.01);
                
                if (!source.loop) {
                    const fadeTime = Math.min(0.1, buffer.duration * 0.1);
                    env.gain.setValueAtTime(0.5, now + buffer.duration - fadeTime);
                    env.gain.linearRampToValueAtTime(0, now + buffer.duration);
                }
                
                // Connect chain
                source.connect(inputGain);
                if (processedNode !== inputGain) {
                    processedNode.connect(env);
                }
                env.connect(this.fx.sidechain);
                
                // Add to spatial bus based on category
                this.spatializeSample(env, category);
                
                try {
                    source.start();
                    
                    if (!source.loop) {
                        source.stop(now + buffer.duration);
                    } else {
                        // Stop looping samples after 4 beats
                        const beatTime = 60 / this.bpm * 4;
                        source.stop(now + beatTime);
                    }
                } catch (err) {
                    console.error('Error playing sample:', err);
                }
            }
            
            createHarmonicCurve(amount) {
                const samples = 4096;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    // Add odd harmonics for warm bass
                    curve[i] = x + 
                              (Math.sin(x * Math.PI) * 0.3) +
                              (Math.sin(x * Math.PI * 3) * 0.1) +
                              (Math.sin(x * Math.PI * 5) * 0.05);
                }
                
                return curve;
            }
            
            spatializeSample(node, category) {
                const panner = this.ctx.createStereoPanner();
                
                // Different spatial positions for each category
                switch(category) {
                    case 'bass':
                        panner.pan.value = 0; // Center
                        break;
                    case 'mid':
                        panner.pan.value = (Math.random() - 0.5) * 0.6; // Moderate spread
                        break;
                    case 'high':
                        panner.pan.value = (Math.random() - 0.5) * 0.9; // Wide spread
                        break;
                    case 'texture':
                        // Autopan for movement
                        const autoPan = this.ctx.createOscillator();
                        autoPan.frequency.value = 0.3;
                        const panDepth = this.ctx.createGain();
                        panDepth.gain.value = 0.7;
                        
                        autoPan.connect(panDepth);
                        panDepth.connect(panner.pan);
                        
                        autoPan.start();
                        autoPan.stop(this.ctx.currentTime + 4);
                        break;
                }
                
                node.connect(panner);
                panner.connect(this.fx.sidechain);
            }
            
            quantizePitch() {
                // Quantize to harmonic series
                const harmonics = [0.5, 0.75, 1, 1.5, 2];
                return harmonics[Math.floor(Math.random() * harmonics.length)];
            }
            
            updateSampleIndicator() {
                const dots = this.ui.samples.querySelectorAll('.sample-dot');
                const index = this.captureCount % dots.length;
                dots[index].classList.add('active');
                setTimeout(() => dots[index].classList.remove('active'), 2000);
            }
            
            updateEnergy() {
                this.ui.energyFill.style.width = (this.energy * 100) + '%';
                
                // Automate filter based on energy
                const freq = 200 + (this.energy * 10000);
                this.fx.filter.frequency.exponentialRampToValueAtTime(
                    freq, 
                    this.ctx.currentTime + 0.1
                );
            }
            
            start() {
                // Start kick drum
                this.startKick();
                
                // Start visualization
                this.animate();
                
                // Energy decay
                setInterval(() => {
                    this.energy *= 0.98;
                    this.updateEnergy();
                }, 100);
                
                // Setup test button
                this.ui.testCapture.style.display = 'block';
                this.ui.help.style.display = 'block';
                this.ui.testCapture.addEventListener('click', () => {
                    this.testCapture();
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.testCapture();
                    } else if (e.key === 't' || e.key === 'T') {
                        e.preventDefault();
                        this.tapTempo();
                    }
                });
                
                // Initial status
                this.ui.status.textContent = 'LISTENING - Make sounds near mic';
                this.ui.debug.textContent = 'System ready - Press SPACE to test';
                
                // Start the AI DJ brain
                this.startDJBrain();
            }
            
            startDJBrain() {
                // AI decides when to replay samples and create the mix
                const think = () => {
                    // Update evolution phase based on samples collected
                    this.updateEvolutionPhase();
                    
                    // Decide if we should play existing samples
                    if (this.shouldTriggerSample()) {
                        this.triggerEvolutionSample();
                    }
                    
                    // Check for special moments
                    if (this.evolution.phase === 'peak' && Math.random() < 0.01) {
                        this.triggerDrop();
                    }
                    
                    // Automate effects based on phase
                    this.automateEffects();
                    
                    // Schedule next think
                    const thinkInterval = 250 + Math.random() * 250; // 250-500ms
                    setTimeout(think, thinkInterval);
                };
                
                // Start after a delay
                setTimeout(think, 2000);
            }
            
            triggerDrop() {
                const now = this.ctx.currentTime;
                
                // Quick filter sweep down
                this.fx.filter.frequency.cancelScheduledValues(now);
                this.fx.filter.frequency.setValueAtTime(this.fx.filter.frequency.value, now);
                this.fx.filter.frequency.exponentialRampToValueAtTime(200, now + 0.5);
                
                // Then explosion back up
                setTimeout(() => {
                    const dropTime = this.ctx.currentTime;
                    
                    // Filter sweep up
                    this.fx.filter.frequency.exponentialRampToValueAtTime(15000, dropTime + 0.1);
                    
                    // Play multiple samples at once
                    ['bass', 'mid', 'high'].forEach(category => {
                        if (this.samples[category].length > 0) {
                            const sample = this.samples[category][this.samples[category].length - 1];
                            this.playEvolutionSample(sample.buffer, category);
                        }
                    });
                    
                    // Visual feedback - flash all sample dots
                    const dots = this.ui.samples.querySelectorAll('.sample-dot');
                    dots.forEach(dot => {
                        dot.classList.add('active');
                        setTimeout(() => dot.classList.remove('active'), 500);
                    });
                    
                    // Energy burst
                    this.energy = 1;
                    this.updateEnergy();
                    
                    this.ui.status.textContent = 'DROP!';
                    setTimeout(() => {
                        this.ui.status.textContent = `${this.evolution.phase.toUpperCase()} - ${this.captureCount} samples`;
                    }, 1000);
                }, 500);
            }
            
            updateEvolutionPhase() {
                const totalSamples = Object.values(this.samples).reduce((sum, cat) => sum + cat.length, 0);
                
                // Remove all phase classes
                const energyDiv = this.ui.energyFill.parentElement;
                energyDiv.classList.remove('intro', 'buildup', 'peak', 'breakdown', 'outro');
                
                if (totalSamples < 5) {
                    this.evolution.phase = 'intro';
                    this.evolution.intensity = 0.2;
                } else if (totalSamples < 15) {
                    this.evolution.phase = 'buildup';
                    this.evolution.intensity = 0.4;
                } else if (totalSamples < 30) {
                    this.evolution.phase = 'peak';
                    this.evolution.intensity = 0.8;
                } else if (totalSamples < 40) {
                    this.evolution.phase = 'breakdown';
                    this.evolution.intensity = 0.5;
                } else {
                    this.evolution.phase = 'outro';
                    this.evolution.intensity = 0.3;
                }
                
                // Add current phase class
                energyDiv.classList.add(this.evolution.phase);
                
                // Update status
                if (this.captureCount > 0) {
                    this.ui.status.textContent = `${this.evolution.phase.toUpperCase()} - ${this.captureCount} samples`;
                }
            }
            
            shouldTriggerSample() {
                // Base probability on phase and current energy
                const baseProbability = {
                    intro: 0.1,
                    buildup: 0.2,
                    peak: 0.4,
                    breakdown: 0.3,
                    outro: 0.15
                }[this.evolution.phase];
                
                // Increase probability if energy is low
                const energyFactor = 1 - this.energy;
                const probability = baseProbability * (1 + energyFactor);
                
                // Don't play too many at once
                const activeSamples = this.evolution.samplePlayback.filter(s => 
                    s.startTime + s.duration > this.ctx.currentTime
                ).length;
                
                if (activeSamples > 3) return false;
                
                return Math.random() < probability;
            }
            
            triggerEvolutionSample() {
                // Choose category based on phase
                const categoryWeights = {
                    intro: { bass: 0.5, mid: 0.3, high: 0.1, texture: 0.1 },
                    buildup: { bass: 0.3, mid: 0.3, high: 0.2, texture: 0.2 },
                    peak: { bass: 0.2, mid: 0.3, high: 0.3, texture: 0.2 },
                    breakdown: { bass: 0.2, mid: 0.2, high: 0.2, texture: 0.4 },
                    outro: { bass: 0.3, mid: 0.2, high: 0.1, texture: 0.4 }
                }[this.evolution.phase];
                
                // Select category
                const rand = Math.random();
                let accumulator = 0;
                let selectedCategory = 'mid';
                
                for (const [category, weight] of Object.entries(categoryWeights)) {
                    accumulator += weight;
                    if (rand < accumulator) {
                        selectedCategory = category;
                        break;
                    }
                }
                
                // Get samples from category
                const categorySamples = this.samples[selectedCategory];
                if (categorySamples.length === 0) return;
                
                // Choose a sample (prefer newer ones)
                const recentBias = Math.random() < 0.7;
                const index = recentBias ? 
                    Math.floor(Math.random() * Math.min(3, categorySamples.length)) :
                    Math.floor(Math.random() * categorySamples.length);
                
                const sample = categorySamples[categorySamples.length - 1 - index];
                
                // Play with evolution-specific processing
                this.playEvolutionSample(sample.buffer, selectedCategory);
                
                // Track playback
                this.evolution.samplePlayback.push({
                    startTime: this.ctx.currentTime,
                    duration: sample.buffer.duration,
                    category: selectedCategory
                });
                
                // Clean old entries
                this.evolution.samplePlayback = this.evolution.samplePlayback.filter(s =>
                    s.startTime + s.duration > this.ctx.currentTime - 10
                );
                
                // Boost energy
                this.energy = Math.min(1, this.energy + 0.05);
                this.updateEnergy();
            }
            
            playEvolutionSample(buffer, category) {
                // Similar to playSample but with phase-specific variations
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                
                // Phase-specific playback rate
                const rateVariation = {
                    intro: 1,
                    buildup: 1 + Math.random() * 0.1,
                    peak: 1 + (Math.random() - 0.5) * 0.2,
                    breakdown: 0.9 + Math.random() * 0.1,
                    outro: 0.8 + Math.random() * 0.2
                }[this.evolution.phase];
                
                // Apply base rate from original
                const baseRates = {
                    bass: 0.5,
                    mid: this.quantizePitch(),
                    high: 2,
                    texture: 1
                };
                
                source.playbackRate.value = baseRates[category] * rateVariation;
                
                // Volume based on phase
                const phaseVolume = {
                    intro: 0.4,
                    buildup: 0.5,
                    peak: 0.6,
                    breakdown: 0.4,
                    outro: 0.3
                }[this.evolution.phase];
                
                const env = this.ctx.createGain();
                const now = this.ctx.currentTime;
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(phaseVolume, now + 0.05);
                
                // Longer fade for outro
                const fadeTime = this.evolution.phase === 'outro' ? 0.5 : 0.1;
                env.gain.setValueAtTime(phaseVolume, now + buffer.duration - fadeTime);
                env.gain.linearRampToValueAtTime(0, now + buffer.duration);
                
                source.connect(env);
                env.connect(this.fx.sidechain);
                
                source.start();
                source.stop(now + buffer.duration);
            }
            
            automateEffects() {
                const now = this.ctx.currentTime;
                
                // Filter automation based on phase
                const filterTargets = {
                    intro: 5000,
                    buildup: 8000 + Math.sin(now * 0.1) * 2000,
                    peak: 15000,
                    breakdown: 3000 + Math.sin(now * 0.05) * 1000,
                    outro: 2000
                };
                
                this.fx.filter.frequency.linearRampToValueAtTime(
                    filterTargets[this.evolution.phase],
                    now + 0.5
                );
                
                // Reverb amount
                const reverbLevels = {
                    intro: 0.2,
                    buildup: 0.3,
                    peak: 0.4,
                    breakdown: 0.6,
                    outro: 0.8
                };
                
                this.fx.reverbSend.gain.linearRampToValueAtTime(
                    reverbLevels[this.evolution.phase],
                    now + 1
                );
                
                // Delay feedback
                const delayFeedback = {
                    intro: 0.3,
                    buildup: 0.5,
                    peak: 0.6,
                    breakdown: 0.7,
                    outro: 0.4
                };
                
                this.fx.delayFeedback.gain.linearRampToValueAtTime(
                    delayFeedback[this.evolution.phase],
                    now + 0.5
                );
            }
            
            tapTempo() {
                const now = Date.now();
                
                // Reset if too much time has passed
                if (now - this.lastTap > 2000) {
                    this.tapTimes = [];
                }
                
                this.tapTimes.push(now);
                this.lastTap = now;
                
                // Need at least 2 taps
                if (this.tapTimes.length > 1) {
                    // Calculate average interval
                    let totalInterval = 0;
                    for (let i = 1; i < this.tapTimes.length; i++) {
                        totalInterval += this.tapTimes[i] - this.tapTimes[i-1];
                    }
                    const avgInterval = totalInterval / (this.tapTimes.length - 1);
                    
                    // Convert to BPM
                    const newBpm = Math.round(60000 / avgInterval);
                    
                    // Constrain to reasonable range
                    if (newBpm >= 60 && newBpm <= 200) {
                        this.bpm = newBpm;
                        this.ui.bpm.textContent = this.bpm;
                        
                        // Update delay time
                        this.fx.delay.delayTime.value = 60 / this.bpm / 4;
                    }
                }
                
                // Keep only last 8 taps
                if (this.tapTimes.length > 8) {
                    this.tapTimes.shift();
                }
            }
            
            testCapture() {
                // Force a capture for testing
                this.ui.debug.textContent = 'Test capture triggered';
                
                // Generate a test tone
                const duration = 0.5;
                const samples = Math.floor(this.ctx.sampleRate * duration);
                const buffer = this.ctx.createBuffer(1, samples, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Create a simple sine wave
                const frequency = 440; // A4
                for (let i = 0; i < samples; i++) {
                    data[i] = Math.sin(2 * Math.PI * frequency * i / this.ctx.sampleRate) * 0.5;
                }
                
                // Process as if it was captured
                this.spectralCentroid = frequency;
                this.processSample(buffer);
                
                // Update UI
                this.updateSampleIndicator();
                this.energy = Math.min(1, this.energy + 0.1);
                this.updateEnergy();
                
                this.captureCount++;
                this.ui.status.textContent = `CAPTURED: ${this.captureCount} (TEST)`;
            }
            
            startKick() {
                const scheduleKick = () => {
                    if (!this.kickPlaying) return;
                    
                    const now = this.ctx.currentTime;
                    const beatLength = 60 / this.bpm;
                    
                    if (now >= this.nextKick) {
                        this.playKick();
                        this.nextKick = now + beatLength;
                    }
                    
                    setTimeout(scheduleKick, 50);
                };
                
                this.kickPlaying = true;
                this.nextKick = this.ctx.currentTime;
                scheduleKick();
            }
            
            playKick() {
                const now = this.ctx.currentTime;
                
                // Visual feedback
                this.ui.kickFlash.style.display = 'block';
                this.ui.kickFlash.classList.remove('active');
                void this.ui.kickFlash.offsetWidth; // Force reflow
                this.ui.kickFlash.classList.add('active');
                
                // Oscillator
                const osc = this.ctx.createOscillator();
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
                
                // Envelope
                const env = this.ctx.createGain();
                env.gain.setValueAtTime(0.7, now);
                env.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                
                osc.connect(env);
                env.connect(this.limiter);
                
                osc.start(now);
                osc.stop(now + 0.5);
                
                // Sidechain
                this.triggerSidechain();
            }
            
            triggerSidechain() {
                const now = this.ctx.currentTime;
                this.fx.sidechain.gain.cancelScheduledValues(now);
                this.fx.sidechain.gain.setValueAtTime(this.fx.sidechain.gain.value, now);
                this.fx.sidechain.gain.linearRampToValueAtTime(0.2, now + 0.01);
                this.fx.sidechain.gain.exponentialRampToValueAtTime(1, now + 0.12);
            }
            
            animate() {
                const canvas = this.ui.waveform;
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    // Get waveform data
                    const timeData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.analyser.getByteTimeDomainData(timeData);
                    
                    // Clear with fade
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, width, height);
                    
                    // Check if we have signal
                    let maxDeviation = 0;
                    for (let i = 0; i < timeData.length; i++) {
                        maxDeviation = Math.max(maxDeviation, Math.abs(timeData[i] - 128));
                    }
                    
                    // Draw waveform
                    ctx.strokeStyle = maxDeviation > 5 ? 'rgba(255, 255, 255, 0.8)' : 'rgba(255, 255, 255, 0.2)';
                    ctx.lineWidth = 1 + (this.energy * 2);
                    ctx.beginPath();
                    
                    const sliceWidth = width / timeData.length;
                    let x = 0;
                    
                    for (let i = 0; i < timeData.length; i++) {
                        const v = timeData[i] / 128.0;
                        const y = v * height / 2;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    ctx.stroke();
                    
                    // Draw spectrum bars at bottom
                    const barWidth = width / 64;
                    for (let i = 0; i < 64; i++) {
                        const value = this.fftData[i] / 255;
                        const barHeight = value * height * 0.3;
                        
                        // Color based on frequency range
                        let color;
                        if (i < 8) {
                            color = `rgba(255, 0, 0, ${value * 0.8})`; // Bass - red
                        } else if (i < 32) {
                            color = `rgba(0, 255, 0, ${value * 0.8})`; // Mid - green
                        } else {
                            color = `rgba(0, 0, 255, ${value * 0.8})`; // High - blue
                        }
                        
                        ctx.fillStyle = color;
                        ctx.fillRect(i * barWidth, height - barHeight, barWidth - 1, barHeight);
                    }
                };
                
                draw();
            }
        }
        
        // Start
        const gump = new GumpDJ();
    </script>
</body>
</html>
