<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Hybrid Motion Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 45px;
      height: 45px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.2s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.6); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.grime {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
      box-shadow: 0 0 50px rgba(255,107,53,0.7);
    }
    
    .orb.trip {
      background: radial-gradient(circle, #6b73ff 0%, rgba(107,115,255,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(107,115,255,0.6);
      animation: tripFloat 4s ease-in-out infinite;
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #4a90e2 0%, rgba(74,144,226,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(74,144,226,0.7);
    }
    
    .orb.intense {
      background: radial-gradient(circle, #ff3535 0%, #ff6b35 40%, #ffaa35 70%, transparent 90%);
      box-shadow: 0 0 80px rgba(255,53,53,0.8);
      animation: intensePulse 0.3s ease-in-out infinite;
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(155,89,182,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    .orb.dimensional {
      background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, #ffff00 50%, #00ff00 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(0,255,255,1);
      filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
    }
    
    .orb.chill {
      background: radial-gradient(circle, #35b5ff 0%, rgba(53,181,255,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(53,181,255,0.4);
      animation: chillWave 5s ease-in-out infinite;
    }
    
    .orb.void {
      background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(147,112,219,0.4);
      filter: drop-shadow(0 0 20px rgba(147,112,219,0.2));
      animation: voidBreathe 3s ease-in-out infinite;
    }
    
    @keyframes tripFloat {
      0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
      50% { transform: translate(-50%, -50%) scale(1.1) rotate(2deg); }
    }
    
    @keyframes intensePulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.3); }
    }
    
    @keyframes chillWave {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.8; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.15); 
        opacity: 1; 
      }
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes voidBreathe {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.4);
      padding: 12px;
      border-radius: 8px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .ui-corner.bottom-right {
      bottom: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 4px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff6b35, #6b73ff);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 80px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 6px;
      background: linear-gradient(0deg, rgba(255,107,53,0.8), rgba(107,115,255,0.8));
      border-radius: 3px 3px 0 0;
      transition: height 0.15s ease;
    }

    .drop-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,107,53,0.2);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .drop-flash.active {
      opacity: 1;
      transition: opacity 0.2s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      ENTER THE FLOW
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO BUILD THE UNIVERSE</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">AMBIENT</div>
      <div class="metric">STYLE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION FLOW</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">GROOVE DEPTH</div>
      <div class="bar">
        <div class="bar-fill" id="grooveBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">85</span></div>
      <div class="metric">KEY: <span id="keyDisplay">A MIN</span></div>
      <div class="metric">LAYERS: <span id="layerCount">0</span></div>
    </div>
    
    <div class="ui-corner bottom-right">
      <div class="metric">PATTERN: <span id="patternDisplay">CALM</span></div>
      <div class="metric">PHRASE: <span id="phraseDisplay">A</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="theme-text" id="themeText"></div>
  <div class="drop-flash" id="dropFlash"></div>

  <script>
    class GUMPHybridEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure - Optimized
        this.bpm = 85;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D'];
        this.sectionLength = 16;
        this.buildupIntensity = 0;
        this.groove = 0;
        
        // Motion & Feel - Simplified
        this.motion = 0;
        this.intensity = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.lastMotionTime = Date.now();
        this.totalMotion = 0;
        this.firstMovement = false;
        
        // Evolution - Streamlined
        this.stage = 'AMBIENT';
        this.currentTechnique = 'waiting';
        this.currentTheme = 'ambient';
        this.voidPhase = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        
        // Audio Chain - Optimized
        this.masterGain = null;
        this.compressor = null;
        this.reverb = null;
        this.delay = null;
        
        // Layer management - Reduced complexity
        this.layerGains = {};
        this.layerFilters = {};
        this.voicePool = {
          kick: { max: 1, active: [] },
          snare: { max: 1, active: [] },
          hihat: { max: 2, active: [] },
          bass: { max: 2, active: [] },
          lead: { max: 3, active: [] },
          pad: { max: 4, active: [] },
          perc: { max: 2, active: [] },
          fx: { max: 2, active: [] },
          ostinato: { max: 3, active: [] },
          harmony: { max: 4, active: [] },
          atmosphere: { max: 2, active: [] },
          strings: { max: 4, active: [] },
          brass: { max: 3, active: [] },
          choir: { max: 4, active: [] }
        };
        
        this.layers = {
          kick: false, snare: false, hihat: false, bass: false,
          lead: false, pad: false, perc: false, fx: false,
          ostinato: false, harmony: false, atmosphere: false,
          strings: false, brass: false, choir: false
        };
        
        // Musical Elements - Simplified
        this.key = 'A';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
        this.mode = 'minor';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          pentatonic: [0, 2, 4, 7, 9]
        };
        this.scale = this.scales.minor;
        
        // Chord progressions
        this.chordProgression = [
          [0,3,7],    // Am
          [8,12,15],  // F
          [3,7,10],   // C
          [10,14,17]  // G
        ];
        this.currentChordIndex = 0;
        
        // Patterns
        this.bassline = [0, 3, 7, 5];
        this.melody = [0, 7, 12, 10, 5];
        this.ostinatoPattern = [0,3,7,3,0,3,7,3];
        this.currentBassIndex = 0;
        this.currentMelodyIndex = 0;
        this.ostinatoIndex = 0;
        
        // UI elements
        this.elements = {};
        this.spectrumBars = [];
        
        // Performance tracking
        this.lastUpdateTime = 0;
        this.updateThrottle = 100; // ms
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'grooveBar', 'bpmDisplay',
         'keyDisplay', 'layerCount', 'patternDisplay', 'phraseDisplay', 
         'voiceCount', 'themeText', 'spectrumViz', 'dropFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i < 32; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 3.125}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupInteractionListeners() {
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          this.triggerDrop();
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          this.triggerDrop();
        });

        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === 'Space') {
            e.preventDefault();
            this.triggerDrop();
          }
        });
      }

      triggerDrop() {
        console.log('🎵 DROP TRIGGERED!');
        this.stage = 'INTENSE';
        this.elements.orb.className = 'orb intense';
        this.currentTheme = 'intense';
        this.buildupIntensity = 1;
        
        // Activate drop layers
        this.layers.kick = true;
        this.layers.snare = true;
        this.layers.bass = true;
        this.layers.lead = true;
        this.layers.perc = true;
        
        this.flashDrop();
        
        // Return to previous state after drop
        setTimeout(() => {
          if (this.totalMotion > 300) {
            this.evolveToOrchestral();
          } else {
            this.stage = this.motionPattern === 'trip' ? 'TRIP' : 'GRIME';
            this.elements.orb.className = `orb ${this.stage.toLowerCase()}`;
          }
          this.buildupIntensity = 0.6;
        }, 4000);
      }

      flashDrop() {
        this.elements.dropFlash.classList.add('active');
        setTimeout(() => this.elements.dropFlash.classList.remove('active'), 200);
      }

      async start() {
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          
          this.setupAudioChain();
          
          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'MOVE OR CLICK TO BUILD THE FLOW';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.startSequencer();
          this.animate();
          
        } catch (e) {
          console.error('Failed to start engine:', e);
          alert('Failed to initialize audio. Error: ' + e.message);
        }
      }

      setupAudioChain() {
        // Simplified but effective audio chain
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 64;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        // Master compressor
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -12;
        this.compressor.knee.value = 6;
        this.compressor.ratio.value = 3;
        this.compressor.attack.value = 0.01;
        this.compressor.release.value = 0.2;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        
        // Simple reverb
        this.reverb = this.ctx.createConvolver();
        this.generateReverb();
        
        // Simple delay
        this.delay = this.ctx.createDelay(0.5);
        this.delayFeedback = this.ctx.createGain();
        this.delayGain = this.ctx.createGain();
        this.delayFeedback.gain.value = 0.2;
        this.delayGain.gain.value = 0.1;
        this.delay.delayTime.value = 60 / this.bpm / 4;
        this.delay.connect(this.delayFeedback);
        this.delayFeedback.connect(this.delay);
        
        // Layer setup - streamlined
        const layerNames = Object.keys(this.layers);
        const layerLevels = {
          kick: 0.9, snare: 0.6, hihat: 0.3, bass: 0.8, lead: 0.5, pad: 0.4, perc: 0.4, fx: 0.3,
          ostinato: 0.3, harmony: 0.25, atmosphere: 0.2, strings: 0.3, brass: 0.25, choir: 0.2
        };
        
        layerNames.forEach(name => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[name] || 0.5;
          
          this.layerFilters[name] = this.ctx.createBiquadFilter();
          this.layerFilters[name].type = 'lowpass';
          this.layerFilters[name].frequency.value = 20000;
          this.layerFilters[name].Q.value = 0.7;

          // Simple routing
          this.layerGains[name].connect(this.layerFilters[name]);
          this.layerFilters[name].connect(this.compressor);
          
          // Selective effects
          if (['strings', 'brass', 'choir', 'harmony', 'pad'].includes(name)) {
            this.layerGains[name].connect(this.reverb);
          }
          if (['ostinato', 'lead', 'snare'].includes(name)) {
            this.layerGains[name].connect(this.delay);
          }
        });
        
        // Chain connections
        this.compressor.connect(this.analyser);
        this.reverb.connect(this.analyser);
        this.delay.connect(this.delayGain);
        this.delayGain.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      generateReverb() {
        const length = this.ctx.sampleRate * 1.5;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        const left = impulse.getChannelData(0);
        const right = impulse.getChannelData(1);
        
        for (let i = 0; i < length; i++) {
          const decay = Math.pow(1 - i / length, 1.2);
          left[i] = (Math.random() * 2 - 1) * decay * 0.2;
          right[i] = (Math.random() * 2 - 1) * decay * 0.2;
        }
        this.reverb.buffer = impulse;
      }

      setupMotionDetection() {
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.isMotionSupported = false;

        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          this.isMotionSupported = true;
          
          const dx = Math.abs((acc.x || 0) - this.lastAccel.x);
          const dy = Math.abs((acc.y || 0) - this.lastAccel.y);
          const dz = Math.abs((acc.z || 0) - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.3;
          this.updateMotion(newMotion);
          
          this.velocity.x += (acc.x || 0) * 0.005;
          this.velocity.y += (acc.y || 0) * 0.005;
          this.updatePosition();
          
          this.lastAccel = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
        });

        // Mouse fallback - optimized
        let lastMouse = { x: 50, y: 50, time: Date.now() };
        let mouseActive = false;
        
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          mouseActive = true;
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 20;
          const velocityY = (newY - lastMouse.y) / dt * 20;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
          
          if (!this.isMotionSupported || dt > 100) {
            this.updateMotion(mouseMotion);
          }
          
          this.pos.x = newX;
          this.pos.y = newY;
          
          lastMouse = { x: newX, y: newY, time: now };
        });

        // Auto motion for demo
        setTimeout(() => {
          if (!mouseActive && !this.isMotionSupported) {
            this.startAutoMotion();
          }
        }, 3000);
      }

      startAutoMotion() {
        let time = 0;
        const simulate = () => {
          if (!this.active || this.isMotionSupported) return;
          
          time += 0.02;
          const autoMotion = Math.sin(time) * 1.5 + Math.cos(time * 0.7) * 1 + 1.5;
          this.updateMotion(autoMotion);
          
          this.pos.x = 50 + Math.sin(time * 0.3) * 15;
          this.pos.y = 50 + Math.cos(time * 0.2) * 10;
          
          requestAnimationFrame(simulate);
        };
        simulate();
      }

      updateMotion(newMotion) {
        if (isNaN(newMotion) || newMotion < 0) newMotion = 0;
        
        this.motion = this.motion * 0.8 + newMotion * 0.2;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 30) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        if (this.motion > 0.3) {
          this.lastMotionTime = Date.now();
          if (this.voidPhase) {
            this.exitVoidState();
          }
        }
        
        // Void state check
        if (Date.now() - this.lastMotionTime > 8000 && !this.voidPhase && this.totalMotion > 50) {
          this.enterVoidState();
        }
        
        // First movement
        if (!this.firstMovement && this.motion > 1.5) {
          this.firstMovement = true;
          this.evolveFromAmbient();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.length > 5 ? 
          this.motionHistory.slice(-5).reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / 5 : 0;
        
        // Pattern detection - simplified
        if (avgMotion > 3) this.motionPattern = 'chaotic';
        else if (avgMotion > 2.5) this.motionPattern = 'grime';
        else if (avgMotion > 1.5) this.motionPattern = 'trip';
        else if (avgMotion > 0.8) this.motionPattern = 'rhythmic';
        else this.motionPattern = 'calm';
        
        this.groove = Math.min(avgMotion / 3, 1);
        this.updateEvolution();
        this.currentTechnique = this.motionPattern;
      }

      enterVoidState() {
        console.log('🌌 ENTERING VOID STATE');
        this.voidPhase = true;
        this.stage = 'VOID';
        this.elements.orb.className = 'orb void';
        this.currentTheme = 'void';
        
        // Clear most layers
        Object.keys(this.layers).forEach(layer => {
          if (layer !== 'atmosphere') {
            this.layers[layer] = false;
          }
        });
        
        this.layers.atmosphere = true;
        this.showThemeText('Void Healing');
      }

      exitVoidState() {
        console.log('🌌 EXITING VOID STATE');
        this.voidPhase = false;
        this.layers.atmosphere = false;
        this.evolveFromAmbient();
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.8;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.8;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.95;
        this.velocity.y *= 0.95;
      }

      updateEvolution() {
        if (this.voidPhase) return;
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        // Layer activation - optimized
        this.layers.kick = this.motionPattern === 'rhythmic' || this.motionPattern === 'grime' || this.stage === 'INTENSE';
        this.layers.snare = this.motionPattern === 'grime' || this.intensity > 2;
        this.layers.hihat = this.stage !== 'AMBIENT' && avgMotion > 0.5;
        this.layers.bass = this.motionPattern !== 'calm' && avgMotion > 1;
        this.layers.lead = avgMotion > 1.5 || this.buildupIntensity > 0.3;
        this.layers.pad = this.motionPattern === 'trip' || this.releasePhase;
        this.layers.perc = avgMotion > 2;
        this.layers.fx = this.stage === 'INTENSE' || Math.random() < 0.02;
        
        // Cinematic layers
        this.layers.ostinato = this.stage !== 'AMBIENT' && avgMotion > 0.8;
        this.layers.harmony = this.totalMotion > 150 && avgMotion > 1.5;
        this.layers.atmosphere = avgMotion < 0.5;
        this.layers.strings = this.totalMotion > 100 && avgMotion > 1.2;
        this.layers.brass = this.buildPhase && this.intensity > 2;
        this.layers.choir = this.releasePhase && this.totalMotion > 300;
        
        // Stage evolution - simplified
        if (this.stage === 'AMBIENT' && this.totalMotion > 50) {
          this.evolveFromAmbient();
        } else if ((this.stage === 'GRIME' || this.stage === 'TRIP') && this.totalMotion > 200) {
          this.evolveToOrchestral();
        } else if (this.stage === 'ORCHESTRAL' && this.totalMotion > 500) {
          this.evolveToTranscendent();
        }
        
        // BPM adjustment
        let targetBPM = 85;
        if (this.motionPattern === 'chaotic') targetBPM = 110;
        else if (this.motionPattern === 'grime') targetBPM = 95;
        else if (this.motionPattern === 'trip') targetBPM = 80;
        else if (this.motionPattern === 'rhythmic') targetBPM = 100;
        
        this.bpm = this.bpm * 0.9 + targetBPM * 0.1;
        this.bpm = Math.max(60, Math.min(130, this.bpm));
        
        this.updateTheme(avgMotion);
      }

      updateTheme(avgMotion) {
        let newTheme = 'ambient';
        
        if (this.voidPhase) newTheme = 'void';
        else if (this.stage === 'INTENSE') newTheme = 'intense';
        else if (this.motionPattern === 'chaotic') newTheme = 'chaos';
        else if (this.motionPattern === 'grime') newTheme = 'grime';
        else if (this.motionPattern === 'trip') newTheme = 'trip';
        else if (avgMotion > 1.5) newTheme = 'adventure';
        else if (avgMotion < 0.8) newTheme = 'chill';
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.showThemeText(newTheme);
        }
      }

      showThemeText(theme) {
        const themes = {
          ambient: 'Ambient Space',
          chill: 'Chill Vibes',
          trip: 'Trip-Hop Flow',
          grime: 'Grime Energy',
          intense: 'Maximum Drop',
          adventure: 'Into Motion',
          chaos: 'Chaos Storm',
          void: 'Void Healing'
        };
        
        this.elements.themeText.textContent = themes[theme] || theme;
        this.elements.themeText.classList.add('visible');
        setTimeout(() => this.elements.themeText.classList.remove('visible'), 3000);
      }

      evolveFromAmbient() {
        if (this.motionPattern === 'trip' || this.groove < 0.3) {
          this.stage = 'TRIP';
          this.elements.orb.className = 'orb trip';
          console.log('🌊 TRIP-HOP EVOLUTION');
        } else {
          this.stage = 'GRIME';
          this.elements.orb.className = 'orb grime';
          console.log('🔥 GRIME EVOLUTION');
        }
      }

      evolveToOrchestral() {
        this.stage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        console.log('🎼 ORCHESTRAL EVOLUTION');
      }

      evolveToTranscendent() {
        this.stage = 'TRANSCENDENT';
        this.elements.orb.className = 'orb transcendent';
        console.log('✨ TRANSCENDENT EVOLUTION');
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.currentBassIndex = (this.currentBassIndex + 1) % this.bassline.length;
            this.currentMelodyIndex = (this.currentMelodyIndex + 1) % this.melody.length;
          }
          
          const interval = (60 / this.bpm) * 250; // 16th notes
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep() {
        if (this.voidPhase) {
          // Only atmosphere in void
          if (this.step % 16 === 0) this.playAtmosphere();
          return;
        }
        
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
        }
        
        // Core rhythm patterns
        const kickPattern = this.step % 4 === 0;
        const snarePattern = this.step % 8 === 4;
        const hihatPattern = this.step % 2 === 1;
        
        // Play layers
        if (this.layers.kick && kickPattern) this.playKick();
        if (this.layers.snare && snarePattern) this.playSnare();
        if (this.layers.hihat && hihatPattern) this.playHihat();
        if (this.layers.bass && kickPattern) this.playBass();
        if (this.layers.lead && this.step % 4 === 2) this.playLead();
        if (this.layers.pad && this.step % 32 === 0) this.playPad();
        if (this.layers.perc && Math.random() < 0.1) this.playPerc();
        if (this.layers.fx && Math.random() < 0.03) this.playFX();
        
        // Cinematic elements
        if (this.layers.ostinato && this.step % 1 === 0) this.playOstinato();
        if (this.layers.harmony && this.step % 16 === 0) this.playHarmony();
        if (this.layers.atmosphere && Math.random() < 0.02) this.playAtmosphere();
        if (this.layers.strings && this.step % 8 === 0) this.playStrings();
        if (this.layers.brass && this.step % 16 === 0) this.playBrass();
        if (this.layers.choir && this.step % 32 === 0) this.playChoir();
      }

      // Optimized sound generators
      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();

        if (!this.allocateVoice('kick', osc, gain, 0.6)) return;

        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(35, this.ctx.currentTime + 0.1);

        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);

        gain.gain.value = 0.9;

        osc.connect(env).connect(gain).connect(this.layerGains.kick);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.6);
      }

      playSnare() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('snare', noise, gain, 0.2)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 1.5);
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 3000;
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        gain.gain.value = 0.6;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.snare);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.2);
      }

      playHihat() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('hihat', noise, gain, 0.1)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 8000;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        gain.gain.value = 0.3;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.hihat);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.1);
      }

      playBass() {
        const noteIndex = this.bassline[this.currentBassIndex % this.bassline.length];
        const freq = this.noteToFreq(noteIndex, 2);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('bass', osc, gain, 0.5)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 150 + this.groove * 100;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.01);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        gain.gain.value = 0.8;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.bass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      playLead() {
        const noteIndex = this.melody[this.currentMelodyIndex % this.melody.length];
        const freq = this.noteToFreq(noteIndex, 4);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('lead', osc, gain, 0.4)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 800 + this.intensity * 200;
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 0.05);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        
        gain.gain.value = 0.5;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.lead);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
      }

      playPad() {
        this.scale.slice(0, 3).forEach((note, i) => {
          const freq = this.noteToFreq(note, 3);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('pad', osc, gain, 3)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 400;
          filter.Q.value = 1;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 1);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
          
          gain.gain.value = 0.4;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.pad);
          osc.start();
          osc.stop(this.ctx.currentTime + 3);
        });
      }

      playPerc() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('perc', osc, gain, 0.15)) return;
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400 + Math.random() * 600, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 0.1);
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
        
        gain.gain.value = 0.4;
        
        osc.connect(env).connect(gain).connect(this.layerGains.perc);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
      }

      playFX() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('fx', osc, gain, 0.3)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100 + Math.random() * 300, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 0.2);
        
        filter.type = 'bandpass';
        filter.frequency.value = 500 + Math.random() * 1000;
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.1);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        gain.gain.value = 0.3;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.fx);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
      }

      // Cinematic Elements - Simplified
      playOstinato() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(noteIndex, 4);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('ostinato', osc, gain, 0.2)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        gain.gain.value = 0.3;
        
        osc.connect(env).connect(gain).connect(this.layerGains.ostinato);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
        
        this.ostinatoIndex++;
      }

      playHarmony() {
        const chord = this.chordProgression[this.currentChordIndex];
        
        chord.forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 3);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('harmony', osc, gain, 3)) return;
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          env.gain.setValueAtTime(0.1, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.5);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
          
          gain.gain.value = 0.15;
          
          osc.connect(env).connect(gain).connect(this.layerGains.harmony);
          osc.start();
          osc.stop(this.ctx.currentTime + 3);
        });
      }

      playAtmosphere() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 5);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('atmosphere', osc, gain, 15)) return;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 200;
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 3);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 15);
        
        gain.gain.value = 0.2;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.atmosphere);
        osc.start();
        osc.stop(this.ctx.currentTime + 15);
      }

      playStrings() {
        const noteIndex = this.scale[Math.floor(Math.random() * this.scale.length)];
        const freq = this.noteToFreq(noteIndex, 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('strings', osc, gain, 2)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(0.1, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 0.8);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        gain.gain.value = 0.3;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.strings);
        osc.start();
        osc.stop(this.ctx.currentTime + 2);
      }

      playBrass() {
        const freq = this.noteToFreq(this.scale[2], 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('brass', osc, gain, 2)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(0.1, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 1);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        gain.gain.value = 0.25;
        
        osc.connect(env).connect(gain).connect(this.layerGains.brass);
        osc.start();
        osc.stop(this.ctx.currentTime + 2);
      }

      playChoir() {
        this.chordProgression[this.currentChordIndex].forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 4);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('choir', osc, gain, 8)) return;
          
          osc.type = 'triangle';
          osc.frequency.value = freq;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 3);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
          
          gain.gain.value = 0.2;
          
          osc.connect(env).connect(gain).connect(this.layerGains.choir);
          osc.start();
          osc.stop(this.ctx.currentTime + 8);
        });
      }

      allocateVoice(layer, source, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) return false;
        
        const now = this.ctx.currentTime;
        
        // Clean up expired voices
        pool.active = pool.active.filter(voice => {
          if (now > voice.startTime + voice.duration + 0.1) {
            try {
              if (voice.source && voice.source.stop) voice.source.stop();
            } catch(e) {}
            return false;
          }
          return true;
        });
        
        // Check if we can add a new voice
        if (pool.active.length >= pool.max) {
          const oldest = pool.active.shift();
          if (oldest && oldest.source && oldest.source.stop) {
            try {
              oldest.source.stop();
            } catch(e) {}
          }
        }
        
        const voice = { source, gain: gainNode, startTime: now, duration };
        pool.active.push(voice);
        
        return true;
      }

      noteToFreq(note, octave = 4) {
        const semitones = this.keyOffsets[this.key] + note;
        return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
      }

      updateUI() {
        const now = Date.now();
        if (now - this.lastUpdateTime < this.updateThrottle) return;
        this.lastUpdateTime = now;
        
        this.elements.stageName.textContent = this.voidPhase ? 'VOID STATE' : this.stage;
        this.elements.technique.textContent = this.currentTechnique.toUpperCase();
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = `${this.key} ${this.mode.toUpperCase()}`;
        this.elements.patternDisplay.textContent = this.motionPattern.toUpperCase();
        this.elements.phraseDisplay.textContent = this.phrase;
        
        const motionPercent = Math.min(this.motion * 15, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        const groovePercent = this.groove * 100;
        this.elements.grooveBar.style.width = groovePercent + '%';
        
        const totalLayers = Object.values(this.layers).filter(Boolean).length;
        this.elements.layerCount.textContent = totalLayers;
        
        const totalVoices = Object.values(this.voicePool).reduce((sum, pool) => sum + pool.active.length, 0);
        this.elements.voiceCount.textContent = totalVoices;
        
        // Update spectrum - throttled
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.dataArray);
          this.spectrumBars.forEach((bar, i) => {
            const height = (this.dataArray[i] / 255) * 60;
            bar.style.height = height + 'px';
            
            let color = 'rgba(255,255,255,0.6)';
            if (this.voidPhase) color = 'rgba(147,112,219,0.4)';
            else if (this.stage === 'GRIME') color = 'rgba(255,107,53,0.8)';
            else if (this.stage === 'TRIP') color = 'rgba(107,115,255,0.8)';
            else if (this.stage === 'ORCHESTRAL') color = 'rgba(74,144,226,0.8)';
            else if (this.stage === 'TRANSCENDENT') color = 'rgba(155,89,182,0.8)';
            else if (this.stage === 'INTENSE') color = 'rgba(255,53,53,0.8)';
            
            bar.style.background = `linear-gradient(0deg, ${color}, rgba(255,255,255,0.2))`;
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          // Throttled UI updates
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          // Optimized background updates
          const intensityNorm = Math.min(this.intensity / 3, 1);
          const motionNorm = Math.min(this.motion / 4, 1);
          
          let bg;
          if (this.voidPhase) {
            const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
            bg = `radial-gradient(circle at 50% 50%, rgba(147, 112, 219, ${0.1 + breathe * 0.1}) 5%, rgba(75, 0, 130, ${0.05 + breathe * 0.05}) 20%, #000000 60%)`;
          } else if (this.stage === 'INTENSE') {
            const pulse = Math.sin(Date.now() / 200) * 0.3 + 0.7;
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,53,53,${pulse}) ${5 + motionNorm * 15}%, rgba(255,107,53,${pulse * 0.6}) ${25}%, #1a0000 70%)`;
          } else if (this.stage === 'TRANSCENDENT') {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(155,89,182,${0.7 + intensityNorm * 0.3}) ${8 + motionNorm * 12}%, rgba(231,76,60,${0.4 + intensityNorm * 0.2}) ${25}%, #0a0a0a ${70}%)`;
          } else if (this.stage === 'ORCHESTRAL') {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(74,144,226,${0.6 + intensityNorm * 0.3}) ${10 + motionNorm * 10}%, rgba(52,73,94,${0.3}) ${35}%, #050510 75%)`;
          } else if (this.stage === 'GRIME') {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,107,53,${0.6 + intensityNorm * 0.4}) ${10 + motionNorm * 8}%, rgba(139,69,19,0.4) ${30}%, #0f0a05 75%)`;
          } else if (this.stage === 'TRIP') {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(107,115,255,${0.5 + motionNorm * 0.3}) ${8 + motionNorm * 7}%, rgba(75,0,130,0.3) ${35}%, #050510 80%)`;
          } else {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,255,255,${0.1 + motionNorm * 0.1}) ${3}%, rgba(50,50,50,0.1) ${50}%, #0a0a0a 90%)`;
          }
          
          document.body.style.background = bg;
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    new GUMPHybridEngine();
  </script>
</body>
</html>
