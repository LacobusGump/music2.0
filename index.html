<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP 2.0</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a0a;overflow:hidden;touch-action:none;height:100vh;font-family:system-ui,-apple-system,sans-serif}
        canvas{position:fixed;inset:0}

        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100;cursor:pointer;background:#0a0a0a}
        #enter.off{display:none}
        #enter div{width:140px;height:140px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px}
        #enter .title{font-size:11px;letter-spacing:6px;color:rgba(255,255,255,0.4)}
        #enter .sub{font-size:8px;letter-spacing:2px;color:rgba(255,255,255,0.2)}

        /* WHEEL DIALS - coin edge style */
        #dials{position:fixed;bottom:0;left:0;right:0;z-index:50;padding:10px 0 20px;background:linear-gradient(transparent,rgba(0,0,0,0.95));touch-action:pan-x}

        .wheel{margin-bottom:15px;position:relative}
        .wheel-label{font-size:8px;letter-spacing:3px;color:rgba(255,255,255,0.25);text-transform:uppercase;text-align:center;margin-bottom:8px}

        .wheel-container{position:relative;height:44px;overflow:hidden}
        .wheel-track{display:flex;position:absolute;left:50%;transform:translateX(-50%);transition:transform 0.3s cubic-bezier(0.2,0.9,0.3,1)}

        .wheel-notch{width:70px;height:44px;display:flex;align-items:center;justify-content:center;font-size:11px;color:rgba(255,255,255,0.25);cursor:pointer;position:relative;flex-shrink:0;transition:all 0.3s;-webkit-tap-highlight-color:transparent}
        .wheel-notch::before{content:'';position:absolute;left:0;top:50%;transform:translateY(-50%);width:1px;height:20px;background:rgba(255,255,255,0.1)}
        .wheel-notch:first-child::before{display:none}
        .wheel-notch.active{color:#fff;font-size:13px;text-shadow:0 0 20px rgba(255,255,255,0.5)}

        /* Center indicator */
        .wheel-indicator{position:absolute;left:50%;top:0;bottom:0;width:80px;transform:translateX(-50%);border-left:1px solid rgba(255,255,255,0.2);border-right:1px solid rgba(255,255,255,0.2);pointer-events:none;background:linear-gradient(90deg,transparent,rgba(255,255,255,0.03),transparent)}

        /* Gear teeth on top and bottom */
        .wheel-teeth{position:absolute;left:0;right:0;height:3px;display:flex;justify-content:center;gap:8px;pointer-events:none}
        .wheel-teeth.top{top:0}
        .wheel-teeth.bottom{bottom:0}
        .wheel-tooth{width:2px;height:3px;background:rgba(255,255,255,0.15)}
    </style>
</head>
<body>
<div id="enter">
    <div>
        <span class="title">GUMP</span>
        <span class="sub">tap to begin</span>
    </div>
</div>

<div id="dials" style="display:none">
    <div class="wheel" id="beats-wheel" data-dial="beats">
        <div class="wheel-label">beats</div>
        <div class="wheel-container">
            <div class="wheel-indicator"></div>
            <div class="wheel-teeth top"></div>
            <div class="wheel-teeth bottom"></div>
            <div class="wheel-track">
                <div class="wheel-notch" data-value="none">off</div>
                <div class="wheel-notch active" data-value="lofi">lo-fi</div>
                <div class="wheel-notch" data-value="trap">trap</div>
                <div class="wheel-notch" data-value="jazz">jazz</div>
                <div class="wheel-notch" data-value="rock">rock</div>
            </div>
        </div>
    </div>
    <div class="wheel" id="bass-wheel" data-dial="bass">
        <div class="wheel-label">bass</div>
        <div class="wheel-container">
            <div class="wheel-indicator"></div>
            <div class="wheel-teeth top"></div>
            <div class="wheel-teeth bottom"></div>
            <div class="wheel-track">
                <div class="wheel-notch" data-value="none">off</div>
                <div class="wheel-notch active" data-value="sub">sub</div>
                <div class="wheel-notch" data-value="funk">funk</div>
                <div class="wheel-notch" data-value="synth">synth</div>
            </div>
        </div>
    </div>
    <div class="wheel" id="vibe-wheel" data-dial="vibe">
        <div class="wheel-label">vibe</div>
        <div class="wheel-container">
            <div class="wheel-indicator"></div>
            <div class="wheel-teeth top"></div>
            <div class="wheel-teeth bottom"></div>
            <div class="wheel-track">
                <div class="wheel-notch" data-value="raw">raw</div>
                <div class="wheel-notch active" data-value="lofi">lo-fi</div>
                <div class="wheel-notch" data-value="polished">polished</div>
                <div class="wheel-notch" data-value="crushed">crushed</div>
            </div>
        </div>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// GUMP 2.0 - Wheel UI + Better Sound

const TAU = Math.PI * 2;
let ctx, master, filter, reverb, reverbGain, canvas, vc;
let running = false;

// State
let dials = { beats: 'lofi', bass: 'sub', vibe: 'lofi' };
let field = { x: 0.5, y: 0.5, energy: 0, time: 0 };

// ============ SOUND CONFIGS ============

const BEATS = {
    none: null,
    lofi: {
        bpm: 72,
        swing: 0.08,
        kick: [0, 2],
        snare: [1, 3],
        hat: [0.5, 1.5, 2.5, 3.5],
        // Lo-fi character
        kickTune: 0.9,
        snareTight: true,
        hatLow: true
    },
    trap: {
        bpm: 140,
        swing: 0,
        kick: [0, 1.5, 2.25],
        snare: [1, 3],
        hat: [0,0.25,0.5,0.75,1,1.25,1.5,1.75,2,2.25,2.5,2.75,3,3.25,3.5,3.75],
        // Trap character
        kickHard: true,
        snareClap: true,
        hatRoll: true
    },
    jazz: {
        bpm: 90,
        swing: 0.2,
        kick: [0, 2.5],
        snare: [1.5, 3.5],
        ride: [0, 0.66, 1.33, 2, 2.66, 3.33],
        // Jazz character
        kickSoft: true,
        brushes: true
    },
    rock: {
        bpm: 115,
        swing: 0,
        kick: [0, 0.5, 2, 2.5],
        snare: [1, 3],
        hat: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5],
        // Rock character
        kickPunch: true,
        snareRing: true
    }
};

const VIBES = {
    raw: { cutoff: 20000, res: 0, verb: 0.1 },
    lofi: { cutoff: 2800, res: 2, verb: 0.3 },
    polished: { cutoff: 16000, res: 0.5, verb: 0.25 },
    crushed: { cutoff: 1800, res: 4, verb: 0.15 }
};

// ============ DRUM SOUNDS ============

function kick(cfg = {}) {
    const now = ctx.currentTime;
    const o = ctx.createOscillator();
    const g = ctx.createGain();

    // Pitch
    const startFreq = cfg.kickHard ? 180 : cfg.kickSoft ? 100 : 150;
    const endFreq = cfg.kickHard ? 35 : cfg.kickSoft ? 50 : 42;
    const tune = cfg.kickTune || 1;

    o.frequency.setValueAtTime(startFreq * tune, now);
    o.frequency.exponentialRampToValueAtTime(endFreq * tune, now + 0.08);

    // Envelope
    const vol = cfg.kickSoft ? 0.4 : cfg.kickHard ? 0.8 : 0.6;
    const decay = cfg.kickPunch ? 0.2 : cfg.kickSoft ? 0.35 : 0.28;
    g.gain.setValueAtTime(vol, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + decay);

    o.connect(g).connect(master);
    o.start(now);
    o.stop(now + decay + 0.01);

    // Click layer for punch
    if (cfg.kickHard || cfg.kickPunch) {
        const click = ctx.createOscillator();
        const clickG = ctx.createGain();
        click.frequency.value = 1000;
        clickG.gain.setValueAtTime(0.15, now);
        clickG.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
        click.connect(clickG).connect(master);
        click.start(now);
        click.stop(now + 0.02);
    }
}

function snare(cfg = {}) {
    const now = ctx.currentTime;

    // Tone body
    const o = ctx.createOscillator();
    const og = ctx.createGain();
    o.type = 'triangle';
    o.frequency.value = cfg.snareRing ? 220 : 180;
    og.gain.setValueAtTime(cfg.brushes ? 0.08 : 0.2, now);
    og.gain.exponentialRampToValueAtTime(0.001, now + (cfg.snareTight ? 0.08 : 0.12));
    o.connect(og).connect(master);
    o.start(now);
    o.stop(now + 0.15);

    // Noise
    const len = cfg.brushes ? 0.15 : cfg.snareTight ? 0.06 : 0.1;
    const buf = ctx.createBuffer(1, ctx.sampleRate * len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const n = ctx.createBufferSource();
    n.buffer = buf;

    const nf = ctx.createBiquadFilter();
    nf.type = cfg.brushes ? 'bandpass' : 'highpass';
    nf.frequency.value = cfg.brushes ? 3000 : cfg.snareTight ? 2500 : 1800;
    nf.Q.value = cfg.brushes ? 2 : 1;

    const ng = ctx.createGain();
    ng.gain.setValueAtTime(cfg.brushes ? 0.15 : cfg.snareClap ? 0.35 : 0.25, now);
    ng.gain.exponentialRampToValueAtTime(0.001, now + len);

    n.connect(nf).connect(ng).connect(master);
    n.start(now);

    // Clap layer for trap
    if (cfg.snareClap) {
        for (let i = 0; i < 3; i++) {
            const clap = ctx.createBufferSource();
            const clapBuf = ctx.createBuffer(1, ctx.sampleRate * 0.02, ctx.sampleRate);
            const cd = clapBuf.getChannelData(0);
            for (let j = 0; j < cd.length; j++) cd[j] = Math.random() * 2 - 1;
            clap.buffer = clapBuf;
            const cg = ctx.createGain();
            const cf = ctx.createBiquadFilter();
            cf.type = 'bandpass';
            cf.frequency.value = 1500;
            cg.gain.setValueAtTime(0.1, now + i * 0.012);
            cg.gain.exponentialRampToValueAtTime(0.001, now + i * 0.012 + 0.03);
            clap.connect(cf).connect(cg).connect(master);
            clap.start(now + i * 0.012);
        }
    }
}

function hat(cfg = {}) {
    const now = ctx.currentTime;
    const len = cfg.hatRoll ? 0.02 : cfg.hatLow ? 0.04 : 0.03;

    const buf = ctx.createBuffer(1, ctx.sampleRate * len, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;

    const n = ctx.createBufferSource();
    n.buffer = buf;

    const f = ctx.createBiquadFilter();
    f.type = 'highpass';
    f.frequency.value = cfg.hatLow ? 6000 : 8000;

    const f2 = ctx.createBiquadFilter();
    f2.type = 'lowpass';
    f2.frequency.value = cfg.hatLow ? 10000 : 16000;

    const g = ctx.createGain();
    g.gain.setValueAtTime(cfg.hatLow ? 0.08 : 0.12, now);
    g.gain.exponentialRampToValueAtTime(0.001, now + len);

    n.connect(f).connect(f2).connect(g).connect(master);
    n.start(now);
}

function ride(cfg = {}) {
    const now = ctx.currentTime;

    // Bell tones
    const freqs = [340, 520, 720];
    freqs.forEach((freq, i) => {
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.03 / (i + 1), now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);
        o.connect(g).connect(master);
        o.start(now);
        o.stop(now + 0.5);
    });

    // Shimmer
    const buf = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
    const d = buf.getChannelData(0);
    for (let i = 0; i < d.length; i++) d[i] = Math.random() * 2 - 1;
    const n = ctx.createBufferSource();
    n.buffer = buf;
    const nf = ctx.createBiquadFilter();
    nf.type = 'bandpass';
    nf.frequency.value = 5000;
    nf.Q.value = 3;
    const ng = ctx.createGain();
    ng.gain.setValueAtTime(0.04, now);
    ng.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
    n.connect(nf).connect(ng).connect(master);
    n.start(now);
}

// Beat sequencer
let beatStep = 0;
let lastBeatTime = 0;

function updateBeats() {
    const cfg = BEATS[dials.beats];
    if (!cfg) return;

    const swingAmount = cfg.swing || 0;
    const beatDuration = 60 / cfg.bpm / 4;
    const now = ctx.currentTime;

    if (now - lastBeatTime >= beatDuration) {
        lastBeatTime = now;
        const step = beatStep % 16;
        let beat = step / 4;

        // Apply swing to off-beats
        const isOffBeat = step % 2 === 1;
        if (isOffBeat && swingAmount > 0) {
            // Delay checking slightly
        }

        if (cfg.kick && cfg.kick.some(b => Math.abs(b - beat) < 0.1)) kick(cfg);
        if (cfg.snare && cfg.snare.some(b => Math.abs(b - beat) < 0.1)) snare(cfg);
        if (cfg.hat && cfg.hat.some(b => Math.abs(b - beat) < 0.1)) hat(cfg);
        if (cfg.ride && cfg.ride.some(b => Math.abs(b - beat) < 0.15)) ride(cfg);

        beatStep++;
    }
}

// ============ BASS ============

let bassOsc, bassGain, bassFilter;

function initBass() {
    bassOsc = ctx.createOscillator();
    bassFilter = ctx.createBiquadFilter();
    bassGain = ctx.createGain();

    bassOsc.type = 'sine';
    bassOsc.frequency.value = 55;

    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 500;

    bassGain.gain.value = 0;

    bassOsc.connect(bassFilter).connect(bassGain).connect(master);
    bassOsc.start();
}

function updateBass() {
    if (dials.bass === 'none') {
        bassGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
        return;
    }

    const configs = {
        sub: { type: 'sine', base: 35, range: 1.2, filter: 300, vol: 0.25 },
        funk: { type: 'sawtooth', base: 55, range: 1.5, filter: 900, vol: 0.18 },
        synth: { type: 'square', base: 50, range: 1.5, filter: 1200, vol: 0.15 }
    };

    const cfg = configs[dials.bass];
    const freq = cfg.base * Math.pow(2, (1 - field.y) * cfg.range);

    bassOsc.type = cfg.type;
    bassOsc.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.05);
    bassFilter.frequency.linearRampToValueAtTime(cfg.filter + field.energy * 300, ctx.currentTime + 0.05);
    bassGain.gain.linearRampToValueAtTime(cfg.vol, ctx.currentTime + 0.1);
}

// ============ LAYERS ============

let layers = [];

function createLayer() {
    if (layers.length >= 5) {
        const old = layers.shift();
        old.osc.stop();
    }

    const freq = 220 * Math.pow(2, (1 - field.y) * 2);
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const f = ctx.createBiquadFilter();

    o.type = layers.length % 2 === 0 ? 'sine' : 'triangle';
    o.frequency.value = freq;

    f.type = 'lowpass';
    f.frequency.value = 1500;

    const vol = 0.06 * Math.pow(0.7, layers.length);
    g.gain.value = vol;

    o.connect(f).connect(g).connect(master);
    o.start();

    layers.push({ osc: o, gain: g, filter: f, freq, vol, phase: 0, len: 1.5 + Math.random() });
}

function updateLayers(dt) {
    for (const L of layers) {
        L.phase += dt / L.len;
        if (L.phase >= 1) L.phase -= 1;
        const env = 0.5 + 0.5 * Math.cos(L.phase * TAU);
        L.gain.gain.value = L.vol * env;
    }
}

// Orb
let orb = { active: false, x: 0.5, y: 0.5 };

function updateOrb(dt) {
    if (!orb.active && field.energy > 0.04) {
        orb.active = true;
        orb.x = field.x;
        orb.y = field.y;
    }

    if (orb.active) {
        const dx = 0.5 - orb.x;
        const dy = 0.5 - orb.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist > 0.03) {
            orb.x += (dx / dist) * 0.5 * dt;
            orb.y += (dy / dist) * 0.5 * dt;
        } else {
            createLayer();
            orb.active = false;
        }

        if (field.energy < 0.01) orb.active = false;
    }
}

// ============ REVERB ============

function createReverb() {
    const convolver = ctx.createConvolver();
    const len = ctx.sampleRate * 1.5;
    const buf = ctx.createBuffer(2, len, ctx.sampleRate);

    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
            d[i] = (Math.random() * 2 - 1) * Math.exp(-i / (len * 0.2));
        }
    }
    convolver.buffer = buf;
    return convolver;
}

// Vibe
function updateVibe() {
    const cfg = VIBES[dials.vibe];
    filter.frequency.linearRampToValueAtTime(cfg.cutoff, ctx.currentTime + 0.1);
    filter.Q.value = cfg.res;
    reverbGain.gain.linearRampToValueAtTime(cfg.verb, ctx.currentTime + 0.1);
}

// ============ INPUT ============

let dialsElement;

function onMove(nx, ny) {
    const dx = nx - field.x;
    const dy = ny - field.y;
    field.x += dx * 0.2;
    field.y += dy * 0.2;
    field.energy = field.energy * 0.9 + Math.sqrt(dx*dx + dy*dy) * 2;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;
    field.x = Math.max(0, Math.min(1, field.x + ax * 0.05));
    field.y = Math.max(0, Math.min(1, field.y - ay * 0.05));
    field.energy = field.energy * 0.9 + Math.sqrt(ax*ax + ay*ay) * 0.5;
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 45;
    const gy = (e.beta || 0) / 45 - 0.5;
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ WHEEL UI ============

function initWheels() {
    document.querySelectorAll('.wheel').forEach(wheel => {
        const track = wheel.querySelector('.wheel-track');
        const notches = wheel.querySelectorAll('.wheel-notch');
        const dialName = wheel.dataset.dial;
        let currentIndex = Array.from(notches).findIndex(n => n.classList.contains('active'));

        function updateWheel(index) {
            index = Math.max(0, Math.min(notches.length - 1, index));
            currentIndex = index;

            notches.forEach((n, i) => {
                n.classList.toggle('active', i === index);
            });

            // Center the active notch
            const offset = -index * 70; // 70px per notch
            track.style.transform = `translateX(calc(-50% + ${offset}px))`;

            // Update dial value
            dials[dialName] = notches[index].dataset.value;

            if (dialName === 'beats') {
                beatStep = 0;
                lastBeatTime = ctx ? ctx.currentTime : 0;
            }
            if (dialName === 'vibe' && ctx) {
                updateVibe();
            }
        }

        // Click to select
        notches.forEach((notch, i) => {
            notch.addEventListener('click', (e) => {
                e.stopPropagation();
                updateWheel(i);
            });
            notch.addEventListener('touchend', (e) => {
                e.stopPropagation();
            });
        });

        // Swipe to scroll
        let startX = 0;
        let startIndex = 0;

        wheel.addEventListener('touchstart', (e) => {
            e.stopPropagation();
            startX = e.touches[0].clientX;
            startIndex = currentIndex;
        }, { passive: true });

        wheel.addEventListener('touchmove', (e) => {
            e.stopPropagation();
        }, { passive: true });

        wheel.addEventListener('touchend', (e) => {
            e.stopPropagation();
            const endX = e.changedTouches[0].clientX;
            const diff = startX - endX;
            if (Math.abs(diff) > 30) {
                updateWheel(startIndex + (diff > 0 ? 1 : -1));
            }
        });

        // Mouse drag
        wheel.addEventListener('mousedown', (e) => {
            e.stopPropagation();
            startX = e.clientX;
            startIndex = currentIndex;
        });

        wheel.addEventListener('click', (e) => {
            e.stopPropagation();
        });

        // Initialize position
        updateWheel(currentIndex);

        // Add gear teeth
        const teethTop = wheel.querySelector('.wheel-teeth.top');
        const teethBottom = wheel.querySelector('.wheel-teeth.bottom');
        for (let i = 0; i < 20; i++) {
            teethTop.innerHTML += '<div class="wheel-tooth"></div>';
            teethBottom.innerHTML += '<div class="wheel-tooth"></div>';
        }
    });
}

// ============ VISUALS ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    vc.fillStyle = 'rgba(10,10,10,0.15)';
    vc.fillRect(0, 0, w, h);

    // Center
    vc.strokeStyle = 'rgba(255,255,255,0.08)';
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w/2, h/2, 25, 0, TAU);
    vc.stroke();

    // Layers
    layers.forEach((L, i) => {
        const r = 35 + i * 25;
        const a = 0.1 + (0.5 + 0.5 * Math.cos(L.phase * TAU)) * 0.15;
        vc.strokeStyle = `rgba(130,160,220,${a})`;
        vc.beginPath();
        vc.arc(w/2, h/2, r, 0, TAU);
        vc.stroke();
    });

    // Orb
    if (orb.active) {
        const ox = orb.x * w, oy = orb.y * h;
        vc.fillStyle = 'rgba(255,255,255,0.6)';
        vc.beginPath();
        vc.arc(ox, oy, 6, 0, TAU);
        vc.fill();

        vc.strokeStyle = 'rgba(255,255,255,0.1)';
        vc.beginPath();
        vc.moveTo(ox, oy);
        vc.lineTo(w/2, h/2);
        vc.stroke();
    }

    // Cursor
    const cx = field.x * w, cy = field.y * h;
    vc.fillStyle = `rgba(255,255,255,${0.15 + field.energy * 0.5})`;
    vc.beginPath();
    vc.arc(cx, cy, 4 + field.energy * 12, 0, TAU);
    vc.fill();
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    const dt = 1/60;
    field.time += dt;
    field.energy *= 0.97;

    updateBeats();
    updateBass();
    updateOrb(dt);
    updateLayers(dt);

    draw();
    requestAnimationFrame(tick);
}

// ============ INIT ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 2800;

    reverb = createReverb();
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.3;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -8;
    comp.ratio.value = 4;
    comp.attack.value = 0.005;
    comp.release.value = 0.1;

    master = ctx.createGain();
    master.gain.value = 0.8;

    // Dry path
    master.connect(filter).connect(comp).connect(ctx.destination);

    // Wet path (reverb)
    master.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(comp);

    initBass();
    initWheels();

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    addEventListener('resize', resize);

    updateVibe();
}

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('dials').style.display = 'block';

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    addEventListener('devicemotion', onMotion);
    addEventListener('deviceorientation', onOrientation);

    // Only respond to motion on canvas, not dials
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
