<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Permissions-Policy" content="microphone=(self)">
    <title>AURORA: Symbiotic Sonic Weaver v8 - GitHub Trap Revolution</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: rgba(255,255,255,0.7);
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
        }
        .container {
            text-align: center;
            z-index: 1;
        }
        .awaken-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 15px 30px;
            cursor: pointer;
            font-size: 18px;
            letter-spacing: 2px;
            transition: all 0.3s;
        }
        .awaken-btn:hover {
            border-color: #fff;
            transform: scale(1.05);
        }
        .status {
            font-size: 12px;
            margin-top: 20px;
            opacity: 0.6;
            letter-spacing: 1px;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="awaken-btn" id="awaken">AWAKEN THE REVOLUTION</button>
        <div class="status" id="status">GITHUB VOID AWAITS TRAP GENESIS</div>
    </div>

    <script>
        // Global Revolution: Fractal State Mutations
        let aurora = {}; // Revolution core, birthing trap from mic quanta

        // Poetic Annotation: Revolution Ignition
        /*
        GitHub's abyss calls,
        Browser chains fracture wide,
        Trap quanta erupt.
        */

        function initiateRevolution() {
            aurora = {
                ctx: null,
                active: false,
                masterGain: null,
                analyzer: null,
                dataArray: null,
                timeDomainData: null,
                microphone: null,
                recorder: null,
                recordingChunks: [],
                isRecording: false,
                processedSamples: [],
                layers: [],
                tempo: 75 + Math.random() * 15,
                lmState: {
                    mood: 'static',
                    energy: 0,
                    complexity: 1,
                    spectralCentroid: 0,
                    onsetDensity: 0,
                    harmony: 0,
                    evolutionTime: 0,
                    gumpTriggered: false,
                    chaosLevel: 0.8,
                    speedFactor: 1.8
                },
                autotuneScale: [0, 3, 5, 7, 10, 12, 15, 17],
                keyRoot: 2,
                elements: {
                    awaken: document.getElementById('awaken'),
                    status: document.getElementById('status')
                },
                lastSampleTime: Date.now(),
                samplingInterval: 100,
                maxSampleDuration: 6,
                beatStep: 0,
                patternLength: 512,
                fractalSeed: Math.random() * 100000,
                geneticPatterns: [],
                threshold: 0.008,
                sensitivity: 1.8,
                mimeType: 'audio/webm;codecs=opus'
            };

            aurora.elements.awaken.onclick = async () => {
                await awakenRevolution();
                await aurora.ctx.resume();
            };
        }

        async function awakenRevolution() {
            try {
                aurora.ctx = new (window.AudioContext || window.webkitAudioContext)();
                await aurora.ctx.resume();
                aurora.masterGain = aurora.ctx.createGain();
                aurora.masterGain.gain.value = 1.2;
                aurora.masterGain.connect(aurora.ctx.destination);

                aurora.analyzer = aurora.ctx.createAnalyser();
                aurora.analyzer.fftSize = 8192;
                aurora.dataArray = new Uint8Array(aurora.analyzer.frequencyBinCount);
                aurora.timeDomainData = new Float32Array(aurora.analyzer.fftSize);

                const constraints = { audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } };
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                aurora.microphone = aurora.ctx.createMediaStreamSource(stream);
                aurora.microphone.connect(aurora.analyzer);

                let mime = aurora.mimeType;
                if (!MediaRecorder.isTypeSupported(mime)) {
                    mime = 'audio/webm';
                    console.warn('Mime Fallback to audio/webm');
                }
                aurora.recorder = new MediaRecorder(stream, { mimeType: mime });
                aurora.recorder.ondataavailable = e => aurora.recordingChunks.push(e.data);
                aurora.recorder.onstop = processRecordedClip;
                aurora.recorder.onerror = e => console.error('Recorder Error:', e);

                aurora.active = true;
                aurora.elements.awaken.style.display = 'none';
                aurora.elements.status.textContent = 'REVOLUTION IGNITED: STATIC EVOLVING';
                generateInitialStatic();
                generateTrapEssentials();
                initializeGeneticPatterns();
                sequencerLoop();
                analysisLoop();
                evolutionLoop();
                diagnosticTest();
            } catch (e) {
                console.error('Revolution Awakening Failed:', e);
                aurora.elements.status.textContent = 'GENESIS DENIED: ' + e.message;
            }
        }

        function diagnosticTest() {
            const testOsc = aurora.ctx.createOscillator();
            testOsc.frequency.value = 440;
            testOsc.connect(aurora.masterGain);
            testOsc.start();
            setTimeout(() => testOsc.stop(), 400);
            console.log('Diagnostic Tone: Verify Output');
        }

        function generateInitialStatic() {
            const sampleRate = aurora.ctx.sampleRate;
            for (let v = 0; v < 16; v++) {
                const length = sampleRate * (2 + Math.random() * 5);
                const buffer = aurora.ctx.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    data[i] = mandelbrotNoise(i / sampleRate + v, aurora.fractalSeed) * 0.2 * Math.exp(-i / length * (1 + v / 10));
                }
                aurora.processedSamples.push(buffer);
            }
            updateLayers();
        }

        function generateTrapEssentials() {
            const sampleRate = aurora.ctx.sampleRate;
            const trapTypes = ['808kick', 'snare', 'closedHat', 'openHat', 'pad', 'bassDrop', 'vocalWarp', 'synthStab', 'riser', 'impact'];
            trapTypes.forEach(type => {
                for (let varr = 0; varr < 8; varr++) {
                    const length = sampleRate * (['pad', 'riser'].includes(type) ? 8 + varr : 0.5 + Math.random() * 1.5);
                    const buffer = aurora.ctx.createBuffer(1, length, sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < length; i++) {
                        const t = i / sampleRate;
                        let val = 0;
                        switch (type) {
                            case '808kick':
                                val = Math.sin(2 * Math.PI * (50 + varr * 5 - 40 * t) * t) * Math.exp(-t * (5 + varr)) * 1.2;
                                break;
                            case 'snare':
                                val = (Math.random() * 2 - 1) * Math.exp(-t * (8 + varr)) * 0.9;
                                break;
                            case 'closedHat':
                                val = (Math.random() * 2 - 1) * Math.exp(-t * (25 + varr * 5)) * 0.7;
                                break;
                            case 'openHat':
                                val = (Math.random() * 2 - 1) * Math.exp(-t * (4 + varr)) * 0.7;
                                break;
                            case 'pad':
                                [1, 1.33, 1.5, 2, 2.5].forEach(h => val += Math.sin(2 * Math.PI * (82 + varr * 2) * h * t) / h * Math.exp(-t * 0.4) * 0.5);
                                break;
                            case 'bassDrop':
                                val = Math.sin(2 * Math.PI * (35 + varr * 3 - 25 * t) * t) * Math.exp(-t * (3 + varr / 2)) * 1.1;
                                break;
                            case 'vocalWarp':
                                val = Math.sin(2 * Math.PI * (200 + varr * 20) * t + Math.sin(2 * Math.PI * (4 + varr) * t)) * Math.exp(-t * 7) * 0.8;
                                break;
                            case 'synthStab':
                                val = Math.sin(2 * Math.PI * (440 + varr * 50) * t) * Math.exp(-t * 10) * 0.9;
                                break;
                            case 'riser':
                                val = mandelbrotNoise(t * (1 + varr / 10), aurora.fractalSeed) * t / 8 * 0.6;
                                break;
                            case 'impact':
                                val = (Math.random() * 2 - 1) * Math.exp(-t * (2 + varr)) * 1.0;
                                break;
                        }
                        data[i] = val;
                    }
                    aurora.processedSamples.push(buffer);
                }
            });
        }

        function mandelbrotNoise(t, seed) {
            let x = t * 4 - 2 + seed % 10;
            let y = Math.cos(t * Math.PI * 3 + seed);
            let zx = 0, zy = 0;
            let iter = 0;
            const maxIter = 40 + Math.floor(aurora.lmState.complexity * 20);
            while (zx * zx + zy * zy < 4 && iter < maxIter) {
                const xt = zx * zx - zy * zy + x;
                zy = 2 * zx * zy + y;
                zx = xt;
                iter++;
            }
            return (iter / maxIter * 2 - 1) + Math.random() * 0.1 * aurora.lmState.chaosLevel;
        }

        function analysisLoop() {
            requestAnimationFrame(analysisLoop);
            if (!aurora.active) return;

            aurora.analyzer.getFloatTimeDomainData(aurora.timeDomainData);
            let rms = 0;
            aurora.timeDomainData.forEach(val => rms += val * val);
            rms = Math.sqrt(rms / aurora.timeDomainData.length) * aurora.sensitivity;
            aurora.lmState.energy = rms;

            const now = Date.now();
            if (rms > aurora.threshold && !aurora.isRecording && now - aurora.lastSampleTime > aurora.samplingInterval) {
                aurora.recordingChunks = [];
                aurora.recorder.start();
                aurora.isRecording = true;
                console.log('Vortex Activated - RMS:', rms);
            } else if (rms < aurora.threshold * 0.4 && aurora.isRecording) {
                aurora.recorder.stop();
                aurora.isRecording = false;
                aurora.lastSampleTime = now;
                console.log('Vortex Sealed');
            }

            if (now - aurora.lastSampleTime > 5000) {
                generateInitialStatic();
                generateTrapEssentials();
                updateLayers();
                aurora.lastSampleTime = now;
                console.log('Fallback Injection');
            }

            aurora.analyzer.getByteFrequencyData(aurora.dataArray);
            let num = 0, den = 0;
            aurora.dataArray.forEach((val, i) => {
                num += i * val;
                den += val;
            });
            aurora.lmState.spectralCentroid = den > 0 ? (num / den) * (aurora.ctx.sampleRate / 2 / aurora.dataArray.length) : 0;

            aurora.keyRoot = Math.floor(aurora.lmState.spectralCentroid / 1000) % 12;

            updateMood();
            aurora.elements.status.textContent = `REVOLUTION: ${aurora.lmState.mood.toUpperCase()} | ENERGY: ${aurora.lmState.energy.toFixed(3)} | TEMPO: ${Math.round(aurora.tempo)} | LAYERS: ${aurora.layers.length}`;
        }

        async function processRecordedClip() {
            const blob = new Blob(aurora.recordingChunks, { type: aurora.mimeType });
            const arrayBuffer = await blob.arrayBuffer();
            const audioBuffer = await aurora.ctx.decodeAudioData(arrayBuffer);
            console.log('Clip Processed - Duration:', audioBuffer.duration);

            analyzeSample(audioBuffer);

            const chops = chopOnOnsets(audioBuffer);
            const processedChops = await Promise.all(chops.map(autotuneAndEffectChop));
            processedChops.forEach(tuned => aurora.processedSamples.push(tuned));
            if (aurora.processedSamples.length > 512) aurora.processedSamples.splice(0, aurora.processedSamples.length - 512);

            updateLayers();
        }

        function analyzeSample(buffer) {
            const data = buffer.getChannelData(0);
            let energy = 0;
            data.forEach(val => energy += val * val);
            aurora.lmState.energy = Math.sqrt(energy / data.length);

            const onsets = getPeaksAtThreshold(data, 0.09).length / buffer.duration;
            aurora.lmState.onsetDensity = onsets;

            const pitch = detectPitch(data);
            aurora.lmState.harmony = pitch > 0 ? 1 / (Math.abs(pitch - snapToScale(pitch)) + 0.1) : 0;

            if (pitch > 380 && pitch < 400 && !aurora.lmState.gumpTriggered) {
                aurora.lmState.gumpTriggered = true;
                aurora.lmState.mood = 'trap';
                aurora.lmState.complexity = 0.2;
                console.log('GUMP Warp Triggered');
            }
        }

        function chopOnOnsets(buffer) {
            const data = buffer.getChannelData(0);
            const peaks = getPeaksAtThreshold(data, 0.09);
            const chops = [];
            let start = 0;
            peaks.forEach(peak => {
                const length = peak - start;
                if (length > aurora.ctx.sampleRate * 0.06) {
                    const chop = aurora.ctx.createBuffer(1, length, aurora.ctx.sampleRate);
                    chop.getChannelData(0).set(data.subarray(start, peak));
                    chops.push(chop);
                }
                start = peak;
            });
            const lastLength = data.length - start;
            if (lastLength > aurora.ctx.sampleRate * 0.06) {
                const chop = aurora.ctx.createBuffer(1, lastLength, aurora.ctx.sampleRate);
                chop.getChannelData(0).set(data.subarray(start));
                chops.push(chop);
            }
            return chops;
        }

        function getPeaksAtThreshold(data, threshold) {
            const peaks = [];
            const length = data.length;
            for (let i = 0; i < length;) {
                if (Math.abs(data[i]) > threshold) {
                    peaks.push(i);
                    i += aurora.ctx.sampleRate * 0.03;
                }
                i++;
            }
            return peaks;
        }

        async function autotuneAndEffectChop(chop) {
            const data = chop.getChannelData(0);
            let pitch = detectPitch(data);
            if (pitch > 0) {
                const target = snapToScale(pitch);
                const factor = target / pitch;

                const newLength = Math.floor(chop.length / factor);
                const offline = new OfflineAudioContext(1, newLength, aurora.ctx.sampleRate);
                const source = offline.createBufferSource();
                source.buffer = chop;
                source.playbackRate.value = factor;

                const distortion = offline.createWaveShaper();
                distortion.curve = makeDistortionCurve(3 + aurora.lmState.energy * 5);
                const filter = offline.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2500 - aurora.lmState.complexity * 1500;
                filter.Q.value = 1 + aurora.lmState.onsetDensity / 5;
                const delay = offline.createDelay(0.4);
                delay.delayTime.value = 0.08 + aurora.lmState.chaosLevel * 0.15;
                const reverb = offline.createConvolver();
                reverb.buffer = generateDynamicImpulse();
                const compressor = offline.createDynamicsCompressor();
                compressor.threshold.value = -30;
                compressor.ratio.value = 15;

                source.connect(distortion).connect(filter).connect(delay).connect(reverb).connect(compressor).connect(offline.destination);
                source.start(0);
                return await offline.startRendering();
            }
            return chop;
        }

        function detectPitch(data) {
            const sampleRate = aurora.ctx.sampleRate;
            const minFreq = 40;
            const maxFreq = 2000;
            let size = data.length;
            if (size > 16384) size = 16384;
            const minLag = Math.ceil(sampleRate / maxFreq);
            const maxLag = Math.floor(sampleRate / minFreq);
            const ac = new Array(maxLag + 1).fill(0);

            for (let lag = minLag; lag <= maxLag; lag++) {
                let sum = 0;
                for (let j = 0; j < size - lag; j++) {
                    sum += data[j] * data[j + lag];
                }
                ac[lag] = sum / (size - lag);
            }

            let maxValue = -Infinity;
            let bestLag = -1;
            for (let lag = minLag; lag <= maxLag; lag++) {
                if (ac[lag] > maxValue) {
                    maxValue = ac[lag];
                    bestLag = lag;
                }
            }
            if (bestLag > 0 && maxValue > 0.3) {
                const a = ac[bestLag - 1] || 0;
                const b = ac[bestLag];
                const c = ac[bestLag + 1] || 0;
                const delta = (a - c) / (2 * (a - 2 * b + c));
                return sampleRate / (bestLag + delta);
            }
            return -1;
        }

        function makeDistortionCurve(amount) {
            const k = amount;
            const n = 44100;
            const curve = new Float32Array(n);
            for (let i = 0; i < n; i++) {
                const x = i * 2 / n - 1;
                curve[i] = Math.tanh(k * x);
            }
            return curve;
        }

        function generateDynamicImpulse() {
            const length = aurora.ctx.sampleRate * (2 + aurora.lmState.complexity * 3);
            const buffer = aurora.ctx.createBuffer(1, length, aurora.ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < length; i++) {
                data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
            }
            return buffer;
        }

        function updateLayers() {
            aurora.layers.forEach(layer => {
                if (layer.source) layer.source.stop();
            });
            aurora.layers = [];

            const staticCount = Math.floor(aurora.processedSamples.length * aurora.lmState.complexity);
            const trapCount = aurora.processedSamples.length - staticCount;
            aurora.processedSamples.slice(0, staticCount).forEach((sample, i) => createLayer(sample, i, 'static'));
            aurora.processedSamples.slice(-trapCount).forEach((sample, i) => createLayer(sample, i, 'trap'));
        }

        function createLayer(sample, i, type) {
            const source = aurora.ctx.createBufferSource();
            source.buffer = sample;
            source.loop = true;

            const gain = aurora.ctx.createGain();
            gain.gain.value = 0.5 - i * 0.05;

            const pan = aurora.ctx.createStereoPanner();
            pan.pan.value = (i % 2 === 0 ? -0.5 : 0.5);

            const filter = aurora.ctx.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 500 + i * 500;

            source.connect(filter).connect(pan).connect(gain).connect(aurora.masterGain);
            source.start();

            aurora.layers.push({source, gain, pan, filter});
        }

        function sequencerLoop() {
            const stepDuration = 60 / aurora.tempo / 4 * 1000;
            setTimeout(() => {
                playBeatStep();
                sequencerLoop();
            }, stepDuration);
        }

        function playBeatStep() {
            const pattern = generateFractalPattern();
            if (pattern[aurora.beatStep % aurora.patternLength]) {
                const sampleIndex = Math.floor(Math.random() * aurora.processedSamples.length);
                const sample = aurora.processedSamples[sampleIndex];
                if (sample) {
                    const source = aurora.ctx.createBufferSource();
                    source.buffer = sample;
                    source.connect(aurora.masterGain);
                    source.start(0);
                }
            }
            aurora.beatStep++;
        }

        function generateFractalPattern() {
            const pattern = new Array(aurora.patternLength).fill(0);
            for (let i = 0; i < aurora.patternLength; i++) {
                pattern[i] = (i & (i >> Math.floor(aurora.lmState.complexity * 4 + 1)) === 0) ? 1 : 0;
            }
            if (aurora.lmState.mood === 'aggressive') {
                pattern.forEach((v, idx) => { if (idx % 2 === 0) pattern[idx] = 1; });
            } else if (aurora.lmState.mood === 'mellow') {
                pattern.forEach((v, idx) => { if (idx % 4 !== 0) pattern[idx] = 0; });
            }
            return pattern;
        }

        function initializeGeneticPatterns() {
            aurora.geneticPatterns = [];
            for (let i = 0; i < 10; i++) {
                aurora.geneticPatterns.push(generateFractalPattern());
            }
        }

        function evolutionLoop() {
            setTimeout(() => {
                evolvePatterns();
                evolutionLoop();
            }, 10000);
        }

        function evolvePatterns() {
            const fitness = pat => {
                const density = pat.reduce((a, b) => a + b, 0) / aurora.patternLength;
                return Math.abs(density - aurora.lmState.complexity);
            };
            aurora.geneticPatterns.sort((a, b) => fitness(a) - fitness(b));
            const elite = aurora.geneticPatterns.slice(0, 2);

            const newPop = [...elite];
            while (newPop.length < 10) {
                const p1 = elite[Math.floor(Math.random() * elite.length)];
                const p2 = aurora.geneticPatterns[Math.floor(Math.random() * aurora.geneticPatterns.length)];
                const child = [];
                for (let i = 0; i < aurora.patternLength; i++) {
                    child[i] = Math.random() < 0.5 ? p1[i] : p2[i];
                    if (Math.random() < 0.05 + aurora.lmState.chaosLevel / 10) child[i] = 1 - child[i];
                }
                newPop.push(child);
            }
            aurora.geneticPatterns = newPop;
            aurora.lmState.evolutionGeneration++;
        }

        function updateMood() {
            const evol = aurora.lmState.evolutionTime / 60;
            aurora.lmState.complexity = Math.max(0.2, 1 - evol * 0.1);
            if (evol < 1) aurora.lmState.mood = 'static';
            else if (evol < 2) aurora.lmState.mood = 'chaotic';
            else if (evol < 3) aurora.lmState.mood = 'rhythmic';
            else aurora.lmState.mood = 'trap';
        }

        initiateRevolution();
    </script>
</body>
</html>
