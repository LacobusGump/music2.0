<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI DJ - Real-time Autonomous Beat System</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
        }

        /* Animated background */
        .bg-pulse {
            position: fixed;
            inset: 0;
            background: radial-gradient(circle at center, rgba(138, 43, 226, 0.1) 0%, transparent 70%);
            animation: pulse 4s ease-in-out infinite;
            pointer-events: none;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.1); opacity: 1; }
        }

        /* Main container */
        .container {
            width: 90%;
            max-width: 1200px;
            z-index: 10;
        }

        /* Title */
        h1 {
            text-align: center;
            font-size: 3rem;
            font-weight: 100;
            letter-spacing: 0.2em;
            margin-bottom: 2rem;
            background: linear-gradient(45deg, #00ffff, #ff00ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: glow 2s ease-in-out infinite;
        }

        @keyframes glow {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        /* Control panel */
        .controls {
            display: flex;
            gap: 1rem;
            justify-content: center;
            margin-bottom: 2rem;
        }

        button {
            padding: 1rem 2rem;
            font-size: 1rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            border-radius: 50px;
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Status display */
        .status {
            text-align: center;
            margin-bottom: 2rem;
            font-size: 1.2rem;
            color: #00ffff;
            height: 30px;
        }

        /* Visualizer */
        .visualizer {
            width: 100%;
            height: 200px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 10px;
            position: relative;
            overflow: hidden;
            margin-bottom: 2rem;
        }

        #waveform {
            width: 100%;
            height: 100%;
        }

        /* Beat grid */
        .beat-grid {
            display: grid;
            grid-template-columns: repeat(16, 1fr);
            gap: 0.5rem;
            margin-bottom: 2rem;
        }

        .beat {
            aspect-ratio: 1;
            background: rgba(138, 43, 226, 0.1);
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 5px;
            transition: all 0.2s;
        }

        .beat.active {
            background: linear-gradient(135deg, #00ffff, #ff00ff);
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.8);
            transform: scale(1.1);
        }

        .beat.playing {
            background: white;
            box-shadow: 0 0 30px white;
        }

        /* Info panel */
        .info-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            padding: 1rem;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 10px;
            border: 1px solid rgba(138, 43, 226, 0.3);
        }

        .info-item {
            text-align: center;
        }

        .info-label {
            font-size: 0.8rem;
            color: #888;
            text-transform: uppercase;
            letter-spacing: 0.1em;
        }

        .info-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #00ffff;
            margin-top: 0.2rem;
        }

        /* Layer indicators */
        .layers {
            display: flex;
            gap: 0.5rem;
            justify-content: center;
            margin-top: 1rem;
        }

        .layer-indicator {
            width: 50px;
            height: 5px;
            background: rgba(138, 43, 226, 0.2);
            border-radius: 3px;
            transition: all 0.3s;
        }

        .layer-indicator.active {
            background: linear-gradient(90deg, #00ffff, #ff00ff);
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.8);
        }
    </style>
</head>
<body>
    <div class="bg-pulse"></div>
    
    <div class="container">
        <h1>AI DJ</h1>
        
        <div class="controls">
            <button id="startBtn">Start AI DJ</button>
            <button id="stopBtn" disabled>Stop</button>
            <button id="clearBtn">Clear Mix</button>
        </div>
        
        <div class="status" id="status">Click Start to begin...</div>
        
        <div class="visualizer">
            <canvas id="waveform"></canvas>
        </div>
        
        <div class="beat-grid" id="beatGrid">
            <!-- 16 beat cells will be created here -->
        </div>
        
        <div class="info-panel">
            <div class="info-item">
                <div class="info-label">BPM</div>
                <div class="info-value" id="bpm">--</div>
            </div>
            <div class="info-item">
                <div class="info-label">Layers</div>
                <div class="info-value" id="layerCount">0</div>
            </div>
            <div class="info-item">
                <div class="info-label">Energy</div>
                <div class="info-value" id="energy">0%</div>
            </div>
            <div class="info-item">
                <div class="info-label">Mode</div>
                <div class="info-value" id="mode">--</div>
            </div>
        </div>
        
        <div class="layers" id="layers">
            <!-- Layer indicators will be created here -->
        </div>
    </div>

    <script>
        class AIDJ {
            constructor() {
                this.audioContext = null;
                this.analyser = null;
                this.microphone = null;
                this.isRunning = false;
                this.layers = [];
                this.currentBPM = 120;
                this.currentStep = 0;
                this.schedulerTimer = null;
                this.nextNoteTime = 0;
                this.lookahead = 25.0; // ms
                this.scheduleAheadTime = 0.1; // s
                this.captureBuffer = [];
                this.maxBufferLength = 10; // seconds of audio
                this.beatPattern = new Array(16).fill(false);
                this.sampleBank = [];
                this.masterGain = null;
                this.compressor = null;
                
                this.initializeUI();
            }
            
            initializeUI() {
                // Create beat grid
                const beatGrid = document.getElementById('beatGrid');
                for (let i = 0; i < 16; i++) {
                    const beat = document.createElement('div');
                    beat.className = 'beat';
                    beat.dataset.index = i;
                    beatGrid.appendChild(beat);
                }
                
                // Create layer indicators
                for (let i = 0; i < 4; i++) {
                    const indicator = document.createElement('div');
                    indicator.className = 'layer-indicator';
                    indicator.dataset.layer = i;
                    document.getElementById('layers').appendChild(indicator);
                }
                
                // Bind controls
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearMix());
            }
            
            async start() {
                try {
                    // Initialize audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Setup audio chain
                    this.setupAudioChain();
                    
                    // Get microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        } 
                    });
                    
                    this.microphone = this.audioContext.createMediaStreamSource(stream);
                    this.microphone.connect(this.analyser);
                    
                    // Start continuous capture
                    this.startCapture();
                    
                    // Start beat scheduler
                    this.startScheduler();
                    
                    // Start visualizer
                    this.startVisualizer();
                    
                    // Start AI processing loop
                    this.startAILoop();
                    
                    this.isRunning = true;
                    document.getElementById('startBtn').disabled = true;
                    document.getElementById('stopBtn').disabled = false;
                    document.getElementById('status').textContent = 'AI DJ is listening...';
                    document.getElementById('mode').textContent = 'LIVE';
                    
                } catch (error) {
                    console.error('Failed to start:', error);
                    document.getElementById('status').textContent = 'Error: ' + error.message;
                }
            }
            
            setupAudioChain() {
                // Create analyser
                this.analyser = this.audioContext.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
                
                // Create master gain
                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.value = 0.8;
                
                // Create compressor
                this.compressor = this.audioContext.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 30;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                
                // Connect chain
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.audioContext.destination);
            }
            
            startCapture() {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const capture = () => {
                    if (!this.isRunning) return;
                    
                    this.analyser.getByteTimeDomainData(dataArray);
                    
                    // Convert to float and store
                    const floatData = new Float32Array(bufferLength);
                    for (let i = 0; i < bufferLength; i++) {
                        floatData[i] = (dataArray[i] - 128) / 128;
                    }
                    
                    this.captureBuffer.push({
                        data: floatData,
                        timestamp: this.audioContext.currentTime
                    });
                    
                    // Keep buffer size limited
                    const cutoffTime = this.audioContext.currentTime - this.maxBufferLength;
                    this.captureBuffer = this.captureBuffer.filter(chunk => chunk.timestamp > cutoffTime);
                    
                    // Calculate energy
                    let energy = 0;
                    for (let i = 0; i < bufferLength; i++) {
                        energy += Math.abs(floatData[i]);
                    }
                    energy = Math.min(100, Math.round((energy / bufferLength) * 500));
                    document.getElementById('energy').textContent = energy + '%';
                    
                    requestAnimationFrame(capture);
                };
                
                capture();
            }
            
            startScheduler() {
                this.nextNoteTime = this.audioContext.currentTime;
                
                const schedule = () => {
                    if (!this.isRunning) return;
                    
                    // Schedule notes
                    while (this.nextNoteTime < this.audioContext.currentTime + this.scheduleAheadTime) {
                        this.scheduleNote(this.currentStep, this.nextNoteTime);
                        this.nextNote();
                    }
                    
                    this.schedulerTimer = setTimeout(schedule, this.lookahead);
                };
                
                schedule();
            }
            
            scheduleNote(beatNumber, time) {
                // Visual feedback
                const beats = document.querySelectorAll('.beat');
                const currentBeat = beats[beatNumber];
                
                setTimeout(() => {
                    // Clear previous playing
                    beats.forEach(b => b.classList.remove('playing'));
                    
                    // Highlight current
                    if (this.beatPattern[beatNumber]) {
                        currentBeat.classList.add('playing');
                        setTimeout(() => currentBeat.classList.remove('playing'), 100);
                    }
                }, (time - this.audioContext.currentTime) * 1000);
                
                // Play sounds for this beat
                this.layers.forEach(layer => {
                    if (layer.pattern[beatNumber] && layer.active) {
                        this.playLayerSound(layer, beatNumber, time);
                    }
                });
            }
            
            playLayerSound(layer, beatNumber, time) {
                if (!layer.buffer) return;
                
                const source = this.audioContext.createBufferSource();
                source.buffer = layer.buffer;
                
                const gain = this.audioContext.createGain();
                gain.gain.value = layer.volume * (layer.pattern[beatNumber] || 0);
                
                // Add some effects
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 2000 + (Math.random() * 3000);
                filter.Q.value = 1 + Math.random() * 5;
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                
                source.start(time);
                
                // Random variations
                source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.02;
            }
            
            nextNote() {
                const secondsPerBeat = 60.0 / this.currentBPM / 4; // 16th notes
                this.nextNoteTime += secondsPerBeat;
                this.currentStep = (this.currentStep + 1) % 16;
            }
            
            startVisualizer() {
                const canvas = document.getElementById('waveform');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
                
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                const draw = () => {
                    if (!this.isRunning) return;
                    
                    this.analyser.getByteFrequencyData(dataArray);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    const barWidth = (canvas.width / bufferLength) * 2.5;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const barHeight = (dataArray[i] / 255) * canvas.height;
                        
                        const r = barHeight + 25 * (i / bufferLength);
                        const g = 250 * (i / bufferLength);
                        const b = 250;
                        
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                        
                        x += barWidth + 1;
                    }
                    
                    requestAnimationFrame(draw);
                };
                
                draw();
            }
            
            startAILoop() {
                const processLoop = () => {
                    if (!this.isRunning) return;
                    
                    // Analyze captured audio
                    if (this.captureBuffer.length > 50) {
                        this.analyzeAndCreate();
                    }
                    
                    // Evolve the mix
                    if (this.layers.length > 0 && Math.random() < 0.1) {
                        this.evolveMix();
                    }
                    
                    // Next AI cycle
                    setTimeout(processLoop, 2000 + Math.random() * 3000);
                };
                
                setTimeout(processLoop, 3000);
            }
            
            analyzeAndCreate() {
                // Get recent audio
                const recentChunks = this.captureBuffer.slice(-100);
                if (recentChunks.length === 0) return;
                
                // Detect tempo
                const tempo = this.detectTempo(recentChunks);
                if (tempo && Math.abs(tempo - this.currentBPM) > 5) {
                    this.currentBPM = tempo;
                    document.getElementById('bpm').textContent = Math.round(tempo);
                }
                
                // Extract interesting patterns
                const pattern = this.extractPattern(recentChunks);
                
                // Create audio buffer from pattern
                const buffer = this.createBufferFromPattern(recentChunks);
                
                // Add as new layer if we have room
                if (this.layers.length < 4) {
                    this.addLayer(buffer, pattern);
                    document.getElementById('status').textContent = `Created layer ${this.layers.length}`;
                }
            }
            
            detectTempo(chunks) {
                // Simple onset detection
                const onsets = [];
                let previousEnergy = 0;
                
                chunks.forEach((chunk, i) => {
                    let energy = 0;
                    for (let j = 0; j < chunk.data.length; j++) {
                        energy += Math.abs(chunk.data[j]);
                    }
                    energy /= chunk.data.length;
                    
                    if (energy > previousEnergy * 1.5 && energy > 0.1) {
                        onsets.push(chunk.timestamp);
                    }
                    previousEnergy = energy;
                });
                
                if (onsets.length < 2) return this.currentBPM;
                
                // Calculate intervals
                const intervals = [];
                for (let i = 1; i < onsets.length; i++) {
                    intervals.push(onsets[i] - onsets[i - 1]);
                }
                
                // Find most common interval
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const bpm = 60 / avgInterval;
                
                // Quantize to reasonable BPM
                const quantized = Math.round(bpm / 5) * 5;
                return Math.max(60, Math.min(200, quantized));
            }
            
            extractPattern(chunks) {
                const pattern = new Array(16).fill(0);
                
                // Create a random but musical pattern
                const styles = [
                    [1, 0, 0, 0, 0.5, 0, 0, 0, 1, 0, 0, 0, 0.5, 0, 0, 0], // Basic 4/4
                    [1, 0, 0.5, 0, 0, 0, 0.5, 0, 1, 0, 0.5, 0, 0, 0, 0.5, 0], // Syncopated
                    [1, 0, 0, 0.5, 0, 0.5, 0, 0, 1, 0, 0, 0.5, 0, 0.5, 0, 0], // Off-beat
                    [1, 0.3, 0.3, 0.3, 0.5, 0.3, 0.3, 0.3, 1, 0.3, 0.3, 0.3, 0.5, 0.3, 0.3, 0.3] // Busy
                ];
                
                const style = styles[Math.floor(Math.random() * styles.length)];
                
                // Add some randomness
                for (let i = 0; i < 16; i++) {
                    pattern[i] = style[i] * (0.5 + Math.random() * 0.5);
                    if (Math.random() < 0.1) pattern[i] = 0; // Random rests
                }
                
                return pattern;
            }
            
            createBufferFromPattern(chunks) {
                if (chunks.length === 0) return null;
                
                // Combine chunks into one buffer
                const totalLength = chunks.reduce((sum, chunk) => sum + chunk.data.length, 0);
                const combinedData = new Float32Array(totalLength);
                
                let offset = 0;
                chunks.forEach(chunk => {
                    combinedData.set(chunk.data, offset);
                    offset += chunk.data.length;
                });
                
                // Apply effects
                this.applyEffects(combinedData);
                
                // Create audio buffer
                const buffer = this.audioContext.createBuffer(1, combinedData.length, this.audioContext.sampleRate);
                buffer.getChannelData(0).set(combinedData);
                
                return buffer;
            }
            
            applyEffects(data) {
                // Normalize
                let max = 0;
                for (let i = 0; i < data.length; i++) {
                    max = Math.max(max, Math.abs(data[i]));
                }
                if (max > 0) {
                    const scale = 0.8 / max;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= scale;
                    }
                }
                
                // Random effect
                const effect = Math.floor(Math.random() * 4);
                
                switch (effect) {
                    case 0: // Reverse
                        data.reverse();
                        break;
                    case 1: // Bit crush
                        const bits = 8;
                        const levels = Math.pow(2, bits);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = Math.round(data[i] * levels) / levels;
                        }
                        break;
                    case 2: // Distortion
                        for (let i = 0; i < data.length; i++) {
                            data[i] = Math.tanh(data[i] * 3);
                        }
                        break;
                    case 3: // Gate
                        const gateLength = Math.floor(data.length / 16);
                        for (let i = 0; i < data.length; i++) {
                            if ((i % gateLength) > gateLength / 2) {
                                data[i] *= 0.1;
                            }
                        }
                        break;
                }
            }
            
            addLayer(buffer, pattern) {
                const layer = {
                    id: Date.now(),
                    buffer: buffer,
                    pattern: pattern,
                    volume: 0.5 + Math.random() * 0.3,
                    active: true
                };
                
                this.layers.push(layer);
                
                // Update UI
                document.getElementById('layerCount').textContent = this.layers.length;
                const indicators = document.querySelectorAll('.layer-indicator');
                if (indicators[this.layers.length - 1]) {
                    indicators[this.layers.length - 1].classList.add('active');
                }
                
                // Update beat grid
                this.updateBeatGrid();
            }
            
            updateBeatGrid() {
                // Combine all active patterns
                this.beatPattern.fill(false);
                
                this.layers.forEach(layer => {
                    if (layer.active) {
                        layer.pattern.forEach((value, i) => {
                            if (value > 0.5) {
                                this.beatPattern[i] = true;
                            }
                        });
                    }
                });
                
                // Update visuals
                const beats = document.querySelectorAll('.beat');
                beats.forEach((beat, i) => {
                    if (this.beatPattern[i]) {
                        beat.classList.add('active');
                    } else {
                        beat.classList.remove('active');
                    }
                });
            }
            
            evolveMix() {
                if (this.layers.length === 0) return;
                
                const evolution = Math.random();
                
                if (evolution < 0.3) {
                    // Toggle layer
                    const layer = this.layers[Math.floor(Math.random() * this.layers.length)];
                    layer.active = !layer.active;
                    document.getElementById('status').textContent = `Toggled layer ${this.layers.indexOf(layer) + 1}`;
                } else if (evolution < 0.6) {
                    // Modify pattern
                    const layer = this.layers[Math.floor(Math.random() * this.layers.length)];
                    layer.pattern = this.extractPattern(this.captureBuffer.slice(-50));
                    document.getElementById('status').textContent = 'Pattern evolved';
                } else if (evolution < 0.8) {
                    // Adjust volume
                    const layer = this.layers[Math.floor(Math.random() * this.layers.length)];
                    layer.volume = 0.3 + Math.random() * 0.5;
                    document.getElementById('status').textContent = 'Mix adjusted';
                } else {
                    // Change tempo slightly
                    this.currentBPM = Math.max(60, Math.min(200, this.currentBPM + (Math.random() - 0.5) * 10));
                    document.getElementById('bpm').textContent = Math.round(this.currentBPM);
                    document.getElementById('status').textContent = 'Tempo shifted';
                }
                
                this.updateBeatGrid();
            }
            
            clearMix() {
                this.layers = [];
                this.beatPattern.fill(false);
                document.getElementById('layerCount').textContent = '0';
                document.getElementById('status').textContent = 'Mix cleared';
                
                // Clear visuals
                document.querySelectorAll('.beat').forEach(beat => {
                    beat.classList.remove('active', 'playing');
                });
                document.querySelectorAll('.layer-indicator').forEach(indicator => {
                    indicator.classList.remove('active');
                });
            }
            
            stop() {
                this.isRunning = false;
                
                if (this.schedulerTimer) {
                    clearTimeout(this.schedulerTimer);
                }
                
                if (this.microphone) {
                    this.microphone.disconnect();
                }
                
                if (this.audioContext) {
                    this.audioContext.close();
                }
                
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('status').textContent = 'Stopped';
                document.getElementById('mode').textContent = '--';
            }
        }
        
        // Initialize
        const dj = new AIDJ();
    </script>
</body>
</html>
