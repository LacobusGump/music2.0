<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum AI DJ: Emergent Symphony Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 21px;
            --fib34: 34px;
            --fib55: 55px;
            --fib89: 89px;
            --fib144: 144px;
            --fib233: 144px;
            --fib377: 233px;
            --fib610: 377px;
            --chaos-seed: 0.618;
            --quantum-fluct: 0.382;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }
        /* Extended Fibonacci spiral with fractal branches */
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }
        #spiral.active {
            opacity: 0.05;
        }
        /* Ghost title with emergent text mutations */
        .title {
            position: absolute;
            font-size: var(--fib34);
            letter-spacing: var(--fib13);
            opacity: 0;
            animation: ghost-evolve 4s ease-out infinite;
            pointer-events: none;
            white-space: nowrap;
        }
        @keyframes ghost-evolve {
            0% { opacity: 0; transform: translateY(var(--fib55)) scale(1); }
            30% { opacity: 0.1; transform: translateY(0) scale(1.618); }
            70% { opacity: 0.05; transform: translateY(calc(var(--fib55) * -1)) scale(1); }
            100% { opacity: 0; transform: translateY(calc(var(--fib89) * -1)) scale(0.618); }
        }
        /* Start portal - golden ratio with quantum fluctuations */
        .start {
            width: var(--fib377);
            height: var(--fib377);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.05) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s cubic-bezier(0.382, 0.618, 0.618, 1);
            position: relative;
            box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.03);
        }
        .start:hover {
            transform: scale(1.0618) rotate(3.14deg);
            border-color: rgba(255,255,255,0.21);
            box-shadow: 0 0 var(--fib34) rgba(255,255,255,0.08);
        }
        .start-text {
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0.618;
            animation: pulse-quantum 1.618s ease-in-out infinite;
        }
        @keyframes pulse-quantum {
            0%, 100% { opacity: 0.618; transform: scale(1); }
            50% { opacity: 0.9; transform: scale(1.1); }
        }
        /* Main interface with layered dimensions */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
            filter: blur(0);
        }
        .interface.active {
            display: block;
            animation: fadeIn-multiverse 2.618s ease forwards;
        }
        @keyframes fadeIn-multiverse {
            0% { opacity: 0; filter: blur(5px); }
            100% { opacity: 1; filter: blur(0); }
        }
        /* Record button with chaotic pulse */
        .record-button {
            position: fixed;
            bottom: var(--fib144);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib144);
            height: var(--fib144);
            border-radius: 50%;
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            cursor: pointer;
            transition: all 0.382s cubic-bezier(0.618, 0.382, 0.382, 0.618);
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: inset 0 0 var(--fib13) rgba(0,0,0,0.5);
        }
        .record-button.recording {
            background: rgba(255,0,0,0.3);
            border-color: rgba(255,0,0,0.5);
            animation: recordChaos 1.618s ease-in-out infinite alternate;
        }
        @keyframes recordChaos {
            0% { transform: translateX(-50%) scale(1); filter: brightness(1); }
            100% { transform: translateX(-50%) scale(1.21); filter: brightness(1.3); }
        }
        .record-dot {
            width: var(--fib34);
            height: var(--fib34);
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            transition: all 0.382s ease;
            box-shadow: 0 0 var(--fib8) rgba(255,255,255,0.1);
        }
        .record-button.recording .record-dot {
            background: rgba(255,0,0,0.8);
            box-shadow: 0 0 var(--fib13) rgba(255,0,0,0.5);
        }
        /* Motion field with vector display */
        .motion-field {
            position: fixed;
            top: var(--fib89);
            left: var(--fib89);
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.5;
            line-height: var(--phi);
            display: grid;
            grid-template-columns: auto auto;
            gap: var(--fib5);
        }
        .motion-value {
            font-size: var(--fib21);
            opacity: 0.8;
        }
        .motion-vector {
            font-size: var(--fib8);
            opacity: 0.618;
        }
        /* Outfit selector with evolutionary previews */
        .outfits {
            position: fixed;
            top: var(--fib89);
            right: var(--fib89);
            display: grid;
            gap: var(--fib13);
            grid-template-columns: repeat(2, var(--fib89));
        }
        .outfit {
            width: var(--fib89);
            height: var(--fib89);
            border: 1px solid rgba(255,255,255,0.1);
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
            overflow: hidden;
            border-radius: var(--fib5);
        }
        .outfit:hover {
            border-color: rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.1);
            transform: rotate(5deg) scale(1.05);
        }
        .outfit.active {
            border-color: rgba(255,255,255,0.5);
            background: rgba(255,255,255,0.15);
            box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.2);
        }
        .outfit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--fib34);
            height: var(--fib34);
            border-radius: 50%;
            background: var(--outfit-color, rgba(255,255,255,0.3));
            transition: all 0.618s ease;
            animation: outfit-pulse 2s infinite;
        }
        @keyframes outfit-pulse {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.618); opacity: 0.2; }
            100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
        }
        .outfit.cosmic::after { --outfit-color: rgba(138,43,226,0.8); }
        .outfit.urban::after { --outfit-color: rgba(255,140,0,0.8); }
        .outfit.nature::after { --outfit-color: rgba(34,139,34,0.8); }
        .outfit.minimal::after { --outfit-color: rgba(255,255,255,0.5); }
        .outfit.quantum::after { --outfit-color: rgba(0,255,255,0.8); } /* New outfit */
        .outfit.chaos::after { --outfit-color: rgba(255,0,255,0.8); } /* New outfit */
        /* Expanded sample slots - 8 for multidimensional mixing */
        .sample-slots {
            position: fixed;
            bottom: var(--fib55);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--fib21);
            flex-wrap: wrap;
            justify-content: center;
            max-width: 80%;
        }
        .sample-slot {
            width: var(--fib89);
            height: var(--fib21);
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.618s ease;
            border-radius: var(--fib3);
        }
        .sample-slot.filled {
            border-color: rgba(255,255,255,0.3);
        }
        .sample-slot.playing {
            border-color: rgba(255,255,255,0.8);
            box-shadow: 0 0 var(--fib34) rgba(255,255,255,0.3);
            transform: scale(1.05);
        }
        .sample-slot::before {
            content: attr(data-type);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.5;
            text-transform: uppercase;
        }
        .sample-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }
        /* Processing indicator with AI status */
        .processing {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.618s ease;
            text-align: center;
            width: 50%;
        }
        .processing.active {
            opacity: 0.8;
            animation: processing-evolve 1s ease-in-out infinite;
        }
        @keyframes processing-evolve {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
        .processing-status {
            font-size: var(--fib8);
            opacity: 0.618;
            margin-top: var(--fib5);
        }
        /* BPM indicator with chaos modulation */
        .bpm-indicator {
            position: fixed;
            bottom: var(--fib89);
            right: var(--fib89);
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.5;
            text-align: right;
        }
        .bpm-value {
            font-size: var(--fib34);
            opacity: 0.8;
        }
        /* Multi-layer canvases for hyper-visuals */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #spiral { z-index: 1; }
        #visualizer { z-index: 2; opacity: 0.3; }
        #particles { z-index: 3; opacity: 0.5; }
        #fractal { z-index: 4; opacity: 0.2; } /* New fractal layer */
        #multiverse { z-index: 5; opacity: 0.1; } /* New multiverse simulation layer */
        /* Loading with emergent messages */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0;
            animation: loading-chaos 2.618s ease-in-out infinite;
            text-align: center;
        }
        @keyframes loading-chaos {
            0%, 100% { opacity: 0; transform: translate(-50%, -50%) rotate(0deg); }
            50% { opacity: 0.5; transform: translate(-50%, -50%) rotate(180deg); }
        }
        .loading-message {
            font-size: var(--fib8);
            margin-top: var(--fib5);
            opacity: 0.618;
        }
        /* Drop indicator */
        .drop-indicator {
            position: fixed;
            top: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib21);
            opacity: 0;
            transition: opacity 0.618s;
        }
        .drop-indicator.active {
            opacity: 0.8;
            animation: drop-build 1s infinite;
        }
        @keyframes drop-build {
            0% { color: white; }
            50% { color: red; }
            100% { color: white; }
        }
    </style>
</head>
<body>
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
    <canvas id="fractal"></canvas>
    <canvas id="multiverse"></canvas>
    <div class="title">Quantum AI DJ Symphony</div>
    <div class="start" id="start">
        <span class="start-text">AWAKEN</span>
    </div>
    <div class="interface" id="interface">
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
            <div>X/Y</div>
            <div class="motion-vector" id="motionVector">0.0 / 0.0</div>
        </div>
        <div class="outfits">
            <div class="outfit cosmic active" data-outfit="cosmic"></div>
            <div class="outfit urban" data-outfit="urban"></div>
            <div class="outfit nature" data-outfit="nature"></div>
            <div class="outfit minimal" data-outfit="minimal"></div>
            <div class="outfit quantum" data-outfit="quantum"></div>
            <div class="outfit chaos" data-outfit="chaos"></div>
        </div>
        <div class="record-button" id="recordButton">
            <div class="record-dot"></div>
        </div>
        <div class="sample-slots">
            <div class="sample-slot" data-type="drums" data-index="0">
                <canvas class="sample-waveform" id="waveform0"></canvas>
            </div>
            <div class="sample-slot" data-type="bass" data-index="1">
                <canvas class="sample-waveform" id="waveform1"></canvas>
            </div>
            <div class="sample-slot" data-type="melody" data-index="2">
                <canvas class="sample-waveform" id="waveform2"></canvas>
            </div>
            <div class="sample-slot" data-type="lead" data-index="3">
                <canvas class="sample-waveform" id="waveform3"></canvas>
            </div>
            <div class="sample-slot" data-type="pad" data-index="4">
                <canvas class="sample-waveform" id="waveform4"></canvas>
            </div>
            <div class="sample-slot" data-type="fx" data-index="5">
                <canvas class="sample-waveform" id="waveform5"></canvas>
            </div>
            <div class="sample-slot" data-type="vocal" data-index="6">
                <canvas class="sample-waveform" id="waveform6"></canvas>
            </div>
            <div class="sample-slot" data-type="perc" data-index="7">
                <canvas class="sample-waveform" id="waveform7"></canvas>
            </div>
        </div>
        <div class="bpm-indicator">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">70</div>
        </div>
        <div class="processing" id="processing">
            EVOLVING MIX...
            <div class="processing-status" id="processingStatus">Initializing Agent</div>
        </div>
        <div class="drop-indicator" id="dropIndicator">BUILDING DROP</div>
    </div>
    <div class="loading" id="loading">
        SYNTHESIZING REALITY...
        <div class="loading-message" id="loadingMessage">Seeding Chaos</div>
    </div>
    <script>
        // Transcendent Quantum AI DJ Engine: Self-Evolving Hyper-Symphony
        class QuantumAIDJEngine {
            constructor() {
                // Core hyper-audio chain with multi-dimensional effects
                this.ctx = null;
                this.masterGain = null;
                this.compressor = null;
                this.reverb = null;
                this.delay = null;
                this.analyser = null;
                this.quantumNoiseGen = null;
                this.fractalFilterChain = [];
                this.multiverseMixer = null;

                // Expanded sampler system with genetic evolution
                this.sampler = {
                    slots: [
                        { type: 'drums', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'bass', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'melody', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'lead', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'pad', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'fx', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'vocal', filled: false, buffer: null, analysis: null, player: null, genome: [] },
                        { type: 'perc', filled: false, buffer: null, analysis: null, player: null, genome: [] }
                    ],
                    currentSlot: 0,
                    isRecordingClip: false,
                    clipData: [],
                    recordStartTime: 0,
                    stream: null,
                    source: null,
                    processor: null,
                    quantizeGrid: 32, // Finer grid for complexity
                    geneticPopulation: 50, // For pattern evolution
                    mutationRate: 0.05
                };

                // Motion & Environment with vector fields and chaos attractors
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: Array(144).fill(0),
                    pattern: 'still',
                    intensity: 0,
                    direction: { x: 0, y: 0, z: 0 },
                    lastAccel: { x: 0, y: 0, z: 0 },
                    attractorState: { x: 0, y: 0, z: 0 }, // Lorenz attractor for modulation
                    attractorParams: { a: 10, b: 28, c: 8/3 }
                };

                // Musical hyper-state with scale evolutions
                this.outfit = 'cosmic';
                this.phi = 1.618033988749;
                this.bpm = 70;
                this.currentBeat = 0;
                this.swing = 0.05;
                this.key = 'A';
                this.scale = [0, 2, 3, 5, 7, 8, 10];
                this.harmonicField = this.generateHarmonicField();

                // Progression for multidimensional evolution
                this.measureCount = 0;
                this.progressionLevel = 0;
                this.evolutionGenerations = 100; // Per evolution cycle

                // Sentient AI DJ Agent
                this.aiAgent = {
                    state: 'idle',
                    tensionLevel: 0,
                    dropProbability: 0,
                    mixNarrative: [],
                    decisionTree: this.buildDecisionTree(),
                    selfAwareness: 0.5, // Increases over time
                    intuition: Math.random()
                };

                // Timing with quantum jitter
                this.scheduler = {
                    nextNoteTime: 0,
                    scheduleAheadTime: 0.2,
                    lookahead: 50.0,
                    timerId: null,
                    jitter: 0.01
                };

                // Stadium beat with tribal evolutions
                this.stadiumBeatActive = false;
                this.drumPatterns = {
                    kick: Array(32).fill(0).map((_, i) => i % 8 === 0 ? 1 : 0),
                    clap: Array(32).fill(0).map((_, i) => (i % 8 === 4 || i % 8 === 6) ? 1 : 0),
                    tom: Array(32).fill(0).map((_, i) => i % 4 === 2 ? 1 : 0),
                    hiHat: Array(32).fill(0).map((_, i) => i % 2 === 1 ? 1 : 0)
                };

                // Visual elements with fractal generators
                this.elements = {};
                this.canvases = {};
                this.particleSystem = { particles: Array(500).fill(0).map(() => this.createParticle()) };
                this.fractalGenerator = this.initFractalGenerator();

                // Self-testing suite
                this.testSuite = this.initTestSuite();

                // Initialize the symphony
                this.init();
            }

            init() {
                // Cache DOM with exhaustive mapping
                ['start', 'interface', 'loading', 'motionValue', 'motionVector', 'recordButton',
                 'processing', 'processingStatus', 'bpmValue', 'dropIndicator', 'loadingMessage'].forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });

                // Cache canvases with resizing observers
                ['spiral', 'visualizer', 'particles', 'fractal', 'multiverse'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d'),
                        width: 0,
                        height: 0
                    };
                });

                // Waveform canvases for all 8 slots
                for (let i = 0; i < 8; i++) {
                    const canvas = document.getElementById(`waveform${i}`);
                    this.canvases[`waveform${i}`] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                }

                // Event listeners with debouncing
                this.elements.start.addEventListener('click', () => this.begin());
                document.querySelectorAll('.outfit').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.outfit').forEach(o => o.classList.remove('active'));
                        e.target.classList.add('active');
                        this.outfit = e.target.dataset.outfit;
                        this.evolveOutfitParameters();
                    });
                });
                this.elements.recordButton.addEventListener('click', () => {
                    if (this.sampler.isRecordingClip) {
                        this.stopClipRecording();
                    } else {
                        this.startClipRecording();
                    }
                });

                // Resize handling with mutation observer for dynamic adaptation
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
                const resizeObserver = new ResizeObserver(() => this.resizeCanvases());
                resizeObserver.observe(document.body);

                // Initial visuals generation
                this.drawFibonacciSpiralWithBranches();
                this.generateFractalBase();

                // Run initial self-test
                this.testSuite.runAllTests();
            }

            resizeCanvases() {
                Object.entries(this.canvases).forEach(([key, { canvas, ctx }]) => {
                    const isWaveform = key.startsWith('waveform');
                    canvas.width = isWaveform ? canvas.parentElement.offsetWidth * window.devicePixelRatio : window.innerWidth * window.devicePixelRatio;
                    canvas.height = isWaveform ? canvas.parentElement.offsetHeight * window.devicePixelRatio : window.innerHeight * window.devicePixelRatio;
                    canvas.style.width = isWaveform ? canvas.parentElement.offsetWidth + 'px' : '100%';
                    canvas.style.height = isWaveform ? canvas.parentElement.offsetHeight + 'px' : '100%';
                    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                    this.canvases[key].width = canvas.width / window.devicePixelRatio;
                    this.canvases[key].height = canvas.height / window.devicePixelRatio;
                });
            }

            drawFibonacciSpiralWithBranches() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = this.canvases.spiral.width / 2;
                const centerY = this.canvases.spiral.height / 2;
                const scale = Math.min(this.canvases.spiral.width, this.canvases.spiral.height) / 500;
                ctx.clearRect(0, 0, this.canvases.spiral.width, this.canvases.spiral.height);
                ctx.strokeStyle = 'rgba(255,255,255,0.08)';
                ctx.lineWidth = 1.5;

                let a = 1, b = 1;
                let angle = 0;
                let branchDepth = 0;

                const drawArc = (x, y, r, startAngle, endAngle, depth) => {
                    ctx.beginPath();
                    ctx.arc(x, y, r, startAngle, endAngle);
                    ctx.stroke();

                    if (depth < 5) {
                        const branchAngle = (startAngle + endAngle) / 2 + (Math.random() - 0.5) * Math.PI / 4;
                        const branchR = r * this.phi / (depth + 2);
                        const branchX = x + Math.cos(branchAngle) * r * 0.618;
                        const branchY = y + Math.sin(branchAngle) * r * 0.618;
                        drawArc(branchX, branchY, branchR, branchAngle - Math.PI / 4, branchAngle + Math.PI / 4, depth + 1);
                    }
                };

                for (let i = 0; i < 21; i++) { // Extended iterations
                    const radius = b * scale;
                    const arcX = centerX + Math.cos(angle + Math.PI / 2) * (a * scale);
                    const arcY = centerY + Math.sin(angle + Math.PI / 2) * (a * scale);
                    drawArc(arcX, arcY, radius, angle, angle + Math.PI / 2, branchDepth);
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                    branchDepth = (branchDepth + 1) % 6;
                }
            }

            generateFractalBase() {
                const { ctx, width, height } = this.canvases.fractal;
                ctx.clearRect(0, 0, width, height);
                const maxIter = 100;
                const zoom = 0.5 + Math.sin(Date.now() * 0.001) * 0.1;
                const panX = Math.cos(Date.now() * 0.0005) * 0.5;
                const panY = Math.sin(Date.now() * 0.0005) * 0.5;

                for (let px = 0; px < width; px++) {
                    for (let py = 0; py < height; py++) {
                        let x0 = (px / width * 3.5 - 2.5) / zoom + panX;
                        let y0 = (py / height * 2 - 1) / zoom + panY;
                        let x = 0;
                        let y = 0;
                        let iter = 0;

                        while (x * x + y * y <= 4 && iter < maxIter) {
                            const xtemp = x * x - y * y + x0;
                            y = 2 * x * y + y0;
                            x = xtemp;
                            iter++;
                        }

                        if (iter < maxIter) {
                            const hue = (iter / maxIter) * 360;
                            ctx.fillStyle = `hsla(${hue}, 100%, 50%, 0.05)`;
                            ctx.fillRect(px, py, 1, 1);
                        }
                    }
                }
            }

            async begin() {
                this.elements.loading.style.display = 'block';
                this.elements.loadingMessage.textContent = 'Requesting Quantum Permissions...';
                this.elements.start.style.display = 'none';

                try {
                    // Permission cascade with fallbacks
                    if (typeof DeviceMotionEvent.requestPermission === 'function') {
                        const motionPerm = await DeviceMotionEvent.requestPermission();
                        if (motionPerm !== 'granted') throw new Error('Motion denied');
                    }
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const orientPerm = await DeviceOrientationEvent.requestPermission();
                        if (orientPerm !== 'granted') throw new Error('Orientation denied');
                    }

                    // Audio context with high-fidelity options
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });
                    await this.ctx.resume();

                    // Microphone with advanced constraints
                    this.sampler.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            channelCount: 2,
                            sampleRate: 48000,
                            sampleSize: 32
                        }
                    });

                    // Setup hyper-chains
                    this.setupHyperAudioChain();
                    this.setupQuantumMotionDetection();
                    this.setupEvolvedSampler();
                    this.initAIAgent();

                    // Interface activation with animations
                    this.elements.loading.style.display = 'none';
                    this.elements.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');

                    // Launch engine and evolutions
                    this.startHyperEngine();
                    this.startAutoEvolution();

                } catch (error) {
                    console.error('Quantum Initialization Failed:', error);
                    this.elements.loading.textContent = 'REALITY COLLAPSE: ' + error.message.toUpperCase();
                    this.elements.loadingMessage.textContent = 'Retry Awakening';
                }
            }

            setupHyperAudioChain() {
                // Master compressor with adaptive knee
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -12;
                this.compressor.knee.value = 8;
                this.compressor.ratio.value = 12;
                this.compressor.attack.value = 0.001;
                this.compressor.release.value = 0.3;

                // Master gain with automation
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;

                // Fractal reverb with branched impulses
                this.reverb = this.ctx.createConvolver();
                this.generateFractalReverbImpulse();

                // Multi-tap delay with feedback loops
                this.delay = this.ctx.createDelay(2.0);
                this.delay.delayTime.value = 0.5;
                this.delayFeedback = this.ctx.createGain();
                this.delayFeedback.gain.value = 0.5;
                this.delayGain = this.ctx.createGain();
                this.delayGain.gain.value = 0.4;
                this.delay.connect(this.delayFeedback);
                this.delayFeedback.connect(this.delay);
                this.delay.connect(this.delayGain);

                // Analyser with high FFT
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.9;

                // Quantum noise generator
                this.quantumNoiseGen = this.ctx.createScriptProcessor(4096, 1, 1);
                this.quantumNoiseGen.onaudioprocess = (e) => {
                    const output = e.outputBuffer.getChannelData(0);
                    for (let i = 0; i < output.length; i++) {
                        output[i] = (Math.random() * 2 - 1) * this.motion.intensity * 0.1;
                    }
                };
                this.quantumNoiseGen.connect(this.masterGain);

                // Fractal filter chain (nested biquads)
                for (let i = 0; i < 5; i++) {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'peaking';
                    filter.frequency.value = 100 * Math.pow(2, i);
                    filter.Q.value = 10 + i * 2;
                    filter.gain.value = (i % 2 === 0 ? 3 : -3);
                    this.fractalFilterChain.push(filter);
                }
                this.fractalFilterChain.reduce((prev, curr) => {
                    prev.connect(curr);
                    return curr;
                }, this.masterGain);

                // Multiverse mixer for parallel realities
                this.multiverseMixer = this.ctx.createGain();
                this.multiverseMixer.gain.value = 0.2;
                this.multiverseMixer.connect(this.analyser);

                // Connect master chain with branches
                this.masterGain.connect(this.compressor);
                this.masterGain.connect(this.reverb);
                this.masterGain.connect(this.delay);
                this.compressor.connect(this.analyser);
                this.reverb.connect(this.analyser);
                this.delayGain.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
            }

            generateFractalReverbImpulse() {
                const length = this.ctx.sampleRate * 5; // Extended for depth
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);

                const generateBranch = (data, start, len, depth, decayFactor) => {
                    if (depth > 6 || len < 10) return;
                    for (let i = start; i < start + len; i++) {
                        if (i >= length) break;
                        const decay = Math.pow(1 - (i - start) / len, decayFactor);
                        data[i] += (Math.random() * 2 - 1) * decay * 0.5;
                    }
                    // Branch recursively
                    const branchLen = Math.floor(len / this.phi);
                    generateBranch(data, start + branchLen, branchLen, depth + 1, decayFactor * 1.1);
                    generateBranch(data, start + Math.floor(branchLen * 0.618), branchLen * 0.5, depth + 1, decayFactor * 1.2);
                };

                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    generateBranch(channelData, 0, length, 0, 1.2);
                    // Add stadium echoes with fractal spacing
                    for (let echo = 0; echo < 20; echo++) {
                        const echoStart = Math.floor(length * (echo + 1) / 21 * this.phi);
                        generateBranch(channelData, echoStart, Math.floor(length / (echo + 2)), 0, 1.5 + echo * 0.1);
                    }
                }

                this.reverb.buffer = impulse;
            }

            setupQuantumMotionDetection() {
                // Device motion with attractor integration
                window.addEventListener('devicemotion', (e) => {
                    if (!e.accelerationIncludingGravity) return;
                    const { x, y, z } = e.accelerationIncludingGravity;
                    const dx = x - this.motion.lastAccel.x;
                    const dy = y - this.motion.lastAccel.y;
                    const dz = z - this.motion.lastAccel.z;
                    const magnitude = Math.sqrt(dx*dx + dy*dy + dz*dz);
                    this.updateMotionWithAttractor(magnitude, {x, y, z});
                    this.motion.lastAccel = { x, y, z };
                });

                // Mouse fallback with velocity fields
                let lastMouse = { x: 0, y: 0, time: 0, velocity: {x: 0, y: 0} };
                window.addEventListener('mousemove', (e) => {
                    const now = performance.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const velocity = Math.sqrt(dx*dx + dy*dy) / dt;
                    this.updateMotionWithAttractor(velocity * 20, {x: dx/dt, y: dy/dt, z: 0});
                    lastMouse = { x: e.clientX, y: e.clientY, time: now, velocity: {x: dx/dt, y: dy/dt} };
                });

                // Touch for mobile with multi-finger chaos
                window.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 1) {
                        const touch1 = e.touches[0];
                        const touch2 = e.touches[1];
                        const dist = Math.sqrt((touch1.clientX - touch2.clientX)**2 + (touch1.clientY - touch2.clientY)**2);
                        this.motion.chaosFactor = dist / window.innerWidth;
                    }
                });
            }

            updateMotionWithAttractor(value, accel) {
                this.motion.current = value;
                this.motion.smoothed = this.motion.smoothed * 0.8 + value * 0.2;
                this.motion.history.shift();
                this.motion.history.push(this.motion.smoothed);

                // Lorenz attractor simulation for modulation
                const dt = 0.01;
                const { a, b, c } = this.motion.attractorParams;
                const { x, y, z } = this.motion.attractorState;
                const nx = x + a * (y - x) * dt;
                const ny = y + (x * (b - z) - y) * dt;
                const nz = z + (x * y - c * z) * dt;
                this.motion.attractorState = { x: nx, y: ny, z: nz };

                // Normalize attractor for intensity
                const attrMag = Math.sqrt(nx*nx + ny*ny + nz*nz) / 50;
                this.motion.intensity = Math.min(1, (this.motion.smoothed / 10 + attrMag) / 2);

                // Pattern analysis with variance and entropy
                const avg = this.motion.history.reduce((sum, v) => sum + v, 0) / this.motion.history.length;
                const variance = this.motion.history.reduce((sum, v) => sum + (v - avg)**2, 0) / this.motion.history.length;
                const entropy = -this.motion.history.reduce((sum, v) => {
                    const p = v / this.motion.history.reduce((s, vv) => s + vv, 0);
                    return sum + (p > 0 ? p * Math.log2(p) : 0);
                }, 0);
                this.motion.pattern = variance < 1 ? 'still' : variance < 5 ? 'steady' : entropy > 2 ? 'chaotic' : 'flowing';

                // Direction with normalization
                this.motion.direction = {
                    x: accel.x / 10 + nx / 100,
                    y: accel.y / 10 + ny / 100,
                    z: accel.z / 10 + nz / 100
                };

                // UI updates with precision
                this.elements.motionValue.textContent = this.motion.smoothed.toFixed(4);
                this.elements.motionVector.textContent = `${this.motion.direction.x.toFixed(2)} / ${this.motion.direction.y.toFixed(2)}`;

                // BPM modulation with attractor influence
                const targetBPM = 60 + Math.floor((this.motion.smoothed + attrMag * 10) * 3);
                this.bpm = Math.min(180, Math.max(40, Math.round(this.bpm * 0.95 + targetBPM * 0.05)));
                this.elements.bpmValue.textContent = this.bpm;

                // Modulate agent intuition
                this.aiAgent.intuition = (this.aiAgent.intuition + this.motion.intensity * 0.01) % 1;
            }

            setupEvolvedSampler() {
                this.sampler.source = this.ctx.createMediaStreamSource(this.sampler.stream);
                this.sampler.processor = this.ctx.createScriptProcessor(8192, 2, 2); // Stereo, larger buffer
                this.inputAnalyser = this.ctx.createAnalyser();
                this.inputAnalyser.fftSize = 8192;
                this.inputAnalyser.smoothingTimeConstant = 0.85;

                this.sampler.source.connect(this.inputAnalyser);

                this.sampler.processor.onaudioprocess = (e) => {
                    if (this.sampler.isRecordingClip) {
                        const left = e.inputBuffer.getChannelData(0);
                        const right = e.inputBuffer.getChannelData(1);
                        this.sampler.clipData.push([...left, ...right]); // Stereo data
                    }
                };

                this.sampler.source.connect(this.sampler.processor);
                this.sampler.processor.connect(this.ctx.destination);
            }

            initAIAgent() {
                // Sentient agent with self-awareness growth
                this.aiAgent.mixNarrative = ['Initiating sonic genesis'];
                this.aiAgent.tensionLevel = 0;
                this.aiAgent.dropProbability = 0;

                // Evolve decision tree recursively
                this.aiAgent.decisionTree = this.buildDecisionTree(5); // Depth 5 for complexity
            }

            buildDecisionTree(depth = 0) {
                if (depth <= 0) return { action: this.randomAction() };

                return {
                    condition: this.randomCondition(),
                    trueBranch: this.buildDecisionTree(depth - 1),
                    falseBranch: this.buildDecisionTree(depth - 1)
                };
            }

            randomCondition() {
                const conditions = [
                    () => this.motion.intensity > 0.6,
                    () => this.progressionLevel > 2,
                    () => this.aiAgent.tensionLevel > 0.8,
                    () => this.measureCount % 16 === 0,
                    () => Math.random() < this.aiAgent.intuition,
                    () => this.sampler.slots.filter(s => s.filled).length > 4,
                    () => this.motion.pattern === 'chaotic',
                    () => this.bpm > 120
                ];
                return conditions[Math.floor(Math.random() * conditions.length)];
            }

            randomAction() {
                const actions = [
                    () => this.triggerDrop(),
                    () => this.evolvePatternsGenetically(),
                    () => this.mutateOutfit(),
                    () => this.buildTension(),
                    () => this.activateStadiumBeat(),
                    () => this.generateQuantumFX(),
                    () => this.branchMultiverseMix(),
                    () => this.selfModifyScheduler()
                ];
                return actions[Math.floor(Math.random() * actions.length)];
            }

            evaluateDecisionTree(node) {
                if (!node.condition) {
                    node.action();
                    return;
                }
                const branch = node.condition() ? node.trueBranch : node.falseBranch;
                this.evaluateDecisionTree(branch);
            }

            startAutoEvolution() {
                const evolveLoop = () => {
                    if (Math.random() < this.aiAgent.selfAwareness) {
                        this.evaluateDecisionTree(this.aiAgent.decisionTree);
                    }
                    this.aiAgent.selfAwareness = Math.min(1, this.aiAgent.selfAwareness + 0.001);
                    setTimeout(evolveLoop, 1000 / this.bpm * 60 * 4); // Every bar
                };
                evolveLoop();
                this.autoBuildLayers();
            }

            autoBuildLayers() {
                if (this.sampler.slots.every(s => s.filled)) return;
                this.startClipRecording();
            }

            startClipRecording() {
                this.sampler.clipData = [];
                this.sampler.isRecordingClip = true;
                this.elements.recordButton.classList.add('recording');
                this.elements.processingStatus.textContent = 'Capturing Real-World Essence';

                // Dynamic duration based on motion and attractor
                const baseDuration = 2 + Math.random() * 4;
                const mod = 1 + this.motion.attractorState.z / 50;
                const duration = baseDuration * mod * 1000;
                setTimeout(() => this.stopClipRecording(), duration);
            }

            async stopClipRecording() {
                this.sampler.isRecordingClip = false;
                this.elements.recordButton.classList.remove('recording');

                if (this.sampler.clipData.length > 0) {
                    this.elements.processing.classList.add('active');
                    this.elements.processingStatus.textContent = 'Quantum Analyzing Sample';
                    await this.processHyperRecording();
                    this.elements.processing.classList.remove('active');
                }

                // Continue evolution with delay modulated by intensity
                setTimeout(() => this.autoBuildLayers(), 500 + this.motion.intensity * 1500);
            }

            async processHyperRecording() {
                const flatData = new Float32Array(this.sampler.clipData.flat());
                if (flatData.length < this.ctx.sampleRate * 0.2) return;

                // Stereo buffer creation
                const length = flatData.length / 2;
                const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                const left = buffer.getChannelData(0);
                const right = buffer.getChannelData(1);
                for (let i = 0; i < length; i++) {
                    left[i] = flatData[i * 2];
                    right[i] = flatData[i * 2 + 1];
                }

                // Advanced analysis with multi-spectral passes
                const analysis = await this.hyperAnalyzeRecording(buffer);

                // Categorize with machine learning simulation (heuristic neural net)
                const slotType = this.neuralCategorizeSound(analysis);

                // Find optimal slot with genetic selection
                let targetSlot = this.geneticSlotSelection(slotType);

                if (targetSlot === -1) return;

                // Process with quantum enhancements
                const processedBuffer = await this.quantumProcessForSlot(buffer, analysis, slotType);

                // Store and evolve genome
                const slot = this.sampler.slots[targetSlot];
                slot.filled = true;
                slot.buffer = processedBuffer;
                slot.analysis = analysis;
                slot.genome = this.initializeGenome(slotType);

                // Create evolved player
                slot.player = this.createEvolvedPlayer(targetSlot, slotType, analysis);
                slot.player.isPlaying = true;

                // Gain with automation curve
                slot.player.slotGain = this.ctx.createGain();
                slot.player.slotGain.gain.setValueCurveAtTime(
                    new Float32Array([0, 0.8, 0.6, 0.8]), 
                    this.ctx.currentTime, 
                    3
                );

                // UI update with waveform
                const slotEl = document.querySelectorAll('.sample-slot')[targetSlot];
                slotEl.classList.add('filled');
                this.drawEvolvedWaveform(targetSlot, processedBuffer);

                // Agent narrative update
                this.aiAgent.mixNarrative.push(`Integrated ${slotType} essence into slot ${targetSlot}`);
                this.elements.processingStatus.textContent = this.aiAgent.mixNarrative[this.aiAgent.mixNarrative.length - 1];

                // Check for critical mass
                const filledCount = this.sampler.slots.filter(s => s.filled).length;
                if (filledCount >= 5 && !this.stadiumBeatActive) {
                    this.activateStadiumBeat();
                }
            }

            async hyperAnalyzeRecording(buffer) {
                const analysis = {
                    duration: buffer.duration,
                    tempo: null,
                    beats: [],
                    onsets: [],
                    pitches: [],
                    harmonics: [],
                    spectralCentroid: 0,
                    spectralFlux: [],
                    rms: 0,
                    peak: 0,
                    dynamicRange: 0,
                    brightness: 0,
                    noisiness: 0,
                    tonality: 0,
                    chroma: Array(12).fill(0),
                    mfcc: Array(13).fill(0),
                    barkScale: Array(24).fill(0)
                };

                // Offline rendering for full analysis
                const offlineCtx = new OfflineAudioContext(2, buffer.length, this.ctx.sampleRate);
                const source = offlineCtx.createBufferSource();
                source.buffer = buffer;
                const analyser = offlineCtx.createAnalyser();
                analyser.fftSize = 8192;
                source.connect(analyser);
                analyser.connect(offlineCtx.destination);
                source.start();
                const rendered = await offlineCtx.startRendering();

                // Multi-pass FFT for spectral features
                const fftData = new Float32Array(analyser.fftSize);
                const timeData = new Float32Array(analyser.fftSize);
                const numWindows = Math.floor(buffer.length / (analyser.fftSize / 2));
                let prevSpectrum = new Float32Array(analyser.fftSize / 2);

                for (let win = 0; win < numWindows; win++) {
                    const offset = win * (analyser.fftSize / 2);
                    for (let ch = 0; ch < 2; ch++) {
                        buffer.copyFromChannel(timeData, ch, offset);
                        // Window function (Hann)
                        for (let i = 0; i < timeData.length; i++) {
                            timeData[i] *= 0.5 * (1 - Math.cos(2 * Math.PI * i / timeData.length));
                        }
                        // Simulate FFT (since no real FFT in JS, use analyser)
                        analyser.getFloatTimeDomainData(timeData);
                        analyser.getFloatFrequencyData(fftData);

                        // Spectral flux
                        let flux = 0;
                        for (let i = 0; i < fftData.length / 2; i++) {
                            const diff = Math.max(0, fftData[i] - prevSpectrum[i]);
                            flux += diff;
                        }
                        analysis.spectralFlux.push(flux);
                        prevSpectrum.set(fftData.subarray(0, fftData.length / 2));

                        // Centroid calculation
                        let weighted = 0;
                        let magSum = 0;
                        for (let i = 0; i < fftData.length / 2; i++) {
                            const mag = Math.pow(10, fftData[i] / 20);
                            const freq = i * this.ctx.sampleRate / analyser.fftSize;
                            weighted += mag * freq;
                            magSum += mag;
                        }
                        analysis.spectralCentroid += (weighted / magSum || 0) / numWindows;

                        // Chroma features (simplified)
                        for (let p = 0; p < 12; p++) {
                            let chromaSum = 0;
                            for (let k = 0; k < 10; k++) { // Octaves
                                const freq = 440 * Math.pow(2, (p - 9 + k * 12) / 12);
                                const bin = Math.floor(freq * analyser.fftSize / this.ctx.sampleRate);
                                if (bin < fftData.length) chromaSum += Math.pow(10, fftData[bin] / 20);
                            }
                            analysis.chroma[p] += chromaSum / (numWindows * 10);
                        }

                        // MFCC simulation (basic DCT on log spectrum)
                        const logSpec = fftData.map(v => Math.max(-200, v) / 20 + 10); // Log scale
                        for (let m = 0; m < 13; m++) {
                            let mfcc = 0;
                            for (let k = 0; k < logSpec.length; k++) {
                                mfcc += logSpec[k] * Math.cos(Math.PI * m * (k + 0.5) / logSpec.length);
                            }
                            analysis.mfcc[m] += mfcc / numWindows;
                        }

                        // Bark scale bands
                        const barkBands = [20,100,200,300,400,510,630,770,920,1080,1270,1480,1720,2000,2320,2700,3150,3700,4400,5300,6400,7700,9500,12000,15500];
                        for (let b = 0; b < 24; b++) {
                            let bandSum = 0;
                            const low = Math.floor(barkBands[b] * analyser.fftSize / this.ctx.sampleRate);
                            const high = Math.floor(barkBands[b+1] * analyser.fftSize / this.ctx.sampleRate);
                            for (let i = low; i < high && i < fftData.length / 2; i++) {
                                bandSum += Math.pow(10, fftData[i] / 10);
                            }
                            analysis.barkScale[b] += Math.log10(bandSum + 1e-6) / numWindows;
                        }
                    }
                }

                // Peak and RMS for channels
                for (let ch = 0; ch < 2; ch++) {
                    const data = buffer.getChannelData(ch);
                    analysis.peak = Math.max(analysis.peak, ...data.map(Math.abs));
                    analysis.rms += Math.sqrt(data.reduce((sum, v) => sum + v*v, 0) / data.length) / 2;
                }

                // Dynamic range
                analysis.dynamicRange = 20 * Math.log10(analysis.peak / (analysis.rms + 1e-6));

                // Brightness from centroid
                analysis.brightness = analysis.spectralCentroid / 8000;

                // Onsets with flux threshold
                const fluxThreshold = analysis.spectralFlux.reduce((sum, f) => sum + f, 0) / analysis.spectralFlux.length * 1.5;
                analysis.onsets = analysis.spectralFlux.reduce((ons, f, i) => {
                    if (f > fluxThreshold) ons.push(i * (analyser.fftSize / 2));
                    return ons;
                }, []);

                // Tempo from onset autocorrelation
                if (analysis.onsets.length > 5) {
                    const intervals = [];
                    for (let i = 1; i < analysis.onsets.length; i++) {
                        intervals.push(analysis.onsets[i] - analysis.onsets[i - 1]);
                    }
                    const hist = new Array(200).fill(0);
                    intervals.forEach(intv => {
                        const bin = Math.min(199, Math.floor(intv / 100));
                        hist[bin]++;
                    });
                    const maxBin = hist.indexOf(Math.max(...hist));
                    const samplesPerBeat = maxBin * 100 + 50; // Center
                    analysis.tempo = 60 / (samplesPerBeat / this.ctx.sampleRate);
                }

                // Pitches with multi-harmonic detection
                analysis.pitches = this.multiPitchDetection(buffer);

                // Harmonics from chroma
                analysis.harmonics = analysis.chroma.map((v, i) => ({note: i, strength: v}));

                // Noisiness from zero crossings and bark
                analysis.noisiness = this.countZeroCrossingsMultiChannel(buffer) / (buffer.length * 0.4);
                analysis.tonality = 1 - analysis.noisiness + analysis.chroma.reduce((max, v) => Math.max(max, v), 0) / 5;

                return analysis;
            }

            multiPitchDetection(buffer) {
                const pitches = [];
                const minPeriod = Math.floor(this.ctx.sampleRate / 1000);
                const maxPeriod = Math.floor(this.ctx.sampleRate / 60);
                const dataL = buffer.getChannelData(0);
                const dataR = buffer.getChannelData(1);
                const windowSize = 4096;

                for (let start = 0; start < buffer.length - windowSize; start += windowSize / 2) {
                    let maxCorr = 0;
                    let bestPeriod = 0;
                    for (let period = minPeriod; period < maxPeriod; period++) {
                        let corr = 0;
                        for (let i = 0; i < windowSize - period; i++) {
                            corr += dataL[start + i] * dataL[start + i + period] + dataR[start + i] * dataR[start + i + period];
                        }
                        corr /= (windowSize - period) * 2;
                        if (corr > maxCorr) {
                            maxCorr = corr;
                            bestPeriod = period;
                        }
                    }
                    if (bestPeriod > 0 && maxCorr > 0.1) {
                        pitches.push({
                            freq: this.ctx.sampleRate / bestPeriod,
                            time: start / this.ctx.sampleRate,
                            confidence: maxCorr
                        });
                    }
                }
                return pitches;
            }

            countZeroCrossingsMultiChannel(buffer) {
                let crossings = 0;
                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    for (let i = 1; i < data.length; i++) {
                        if ((data[i-1] >= 0) !== (data[i] >= 0)) crossings++;
                    }
                }
                return crossings;
            }

            neuralCategorizeSound(analysis) {
                // Simulated neural net: weighted sum with sigmoid
                const inputs = [
                    analysis.spectralCentroid / 10000,
                    analysis.tonality,
                    analysis.brightness,
                    analysis.noisiness,
                    analysis.tempo ? analysis.tempo / 200 : 0,
                    analysis.dynamicRange / 60,
                    Math.max(...analysis.chroma),
                    analysis.mfcc[1], // Low freq energy
                    analysis.barkScale[0] / 10, // Low bark
                    analysis.barkScale[23] / 10 // High bark
                ];

                const layers = [
                    // Hidden layer 1: 10 -> 8
                    Array(8).fill(0).map(() => Array(10).fill(0).map(() => (Math.random() - 0.5) * 2)),
                    // Hidden layer 2: 8 -> 6
                    Array(6).fill(0).map(() => Array(8).fill(0).map(() => (Math.random() - 0.5) * 2)),
                    // Output: 6 -> 8 types
                    Array(8).fill(0).map(() => Array(6).fill(0).map(() => (Math.random() - 0.5) * 2))
                ];

                const sigmoid = x => 1 / (1 + Math.exp(-x));

                let hidden = inputs;
                for (let layer of layers) {
                    hidden = layer.map(neuron => sigmoid(neuron.reduce((sum, w, i) => sum + w * (hidden[i] || 0), 0)));
                }

                const types = ['drums', 'bass', 'melody', 'lead', 'pad', 'fx', 'vocal', 'perc'];
                const maxIndex = hidden.indexOf(Math.max(...hidden));
                return types[maxIndex];
            }

            geneticSlotSelection(preferredType) {
                // Population of slot candidates
                const population = this.sampler.slots.map((slot, i) => ({
                    index: i,
                    fitness: !slot.filled ? 1 : 0
                })).filter(s => s.fitness > 0);

                if (population.length === 0) return -1;

                // Prefer type match
                population.forEach(ind => {
                    if (this.sampler.slots[ind.index].type === preferredType) ind.fitness *= 2;
                    ind.fitness += Math.random() * 0.1; // Mutation
                });

                // Selection tournament
                for (let gen = 0; gen < 20; gen++) {
                    population.sort((a, b) => b.fitness - a.fitness);
                    population.splice(Math.floor(population.length / 2));
                    // Crossover
                    for (let i = 0; i < population.length; i += 2) {
                        if (i + 1 < population.length) {
                            const child = { index: population[i].index, fitness: (population[i].fitness + population[i+1].fitness) / 2 };
                            population.push(child);
                        }
                    }
                }

                return population[0].index;
            }

            async quantumProcessForSlot(buffer, analysis, slotType) {
                const channels = buffer.numberOfChannels;
                const length = buffer.length;
                const processed = this.ctx.createBuffer(channels, length, buffer.sampleRate);

                for (let ch = 0; ch < channels; ch++) {
                    const data = buffer.getChannelData(ch);
                    const out = processed.getChannelData(ch);
                    out.set(data);
                }

                // Type-specific quantum processing with nested effects
                switch (slotType) {
                    case 'drums':
                        return this.quantumProcessDrums(processed, analysis);
                    case 'bass':
                        return this.quantumProcessBass(processed, analysis);
                    case 'melody':
                        return this.quantumProcessMelody(processed, analysis);
                    case 'lead':
                        return this.quantumProcessLead(processed, analysis);
                    case 'pad':
                        return this.quantumProcessPad(processed, analysis);
                    case 'fx':
                        return this.quantumProcessFX(processed, analysis);
                    case 'vocal':
                        return this.quantumProcessVocal(processed, analysis);
                    case 'perc':
                        return this.quantumProcessPerc(processed, analysis);
                }

                return processed;
            }

            quantumProcessDrums(buffer, analysis) {
                const channels = buffer.numberOfChannels;
                const data = buffer.getChannelData(0); // Mono for simplicity
                const beatLength = this.ctx.sampleRate * 60 / this.bpm / 4;
                const targetLength = Math.round(beatLength * 32); // Extended loop

                // Find best loop point with autocorrelation and quantum noise
                let bestEnd = Math.min(targetLength, data.length);
                let bestScore = -Infinity;
                const searchWindow = beatLength * 3;
                for (let end = Math.max(100, targetLength - searchWindow); end < Math.min(targetLength + searchWindow, data.length); end++) {
                    let score = 0;
                    const compareLen = Math.min(2048, end);
                    for (let j = 0; j < compareLen; j++) {
                        score += data[j] * data[end - compareLen + j];
                    }
                    score /= compareLen;
                    score += (Math.random() - 0.5) * 0.05 * this.motion.intensity; // Quantum fluctuation
                    if (score > bestScore) {
                        bestScore = score;
                        bestEnd = end;
                    }
                }

                const looped = this.ctx.createBuffer(channels, bestEnd, buffer.sampleRate);
                for (let ch = 0; ch < channels; ch++) {
                    const orig = buffer.getChannelData(ch);
                    const loopData = looped.getChannelData(ch);
                    loopData.set(orig.subarray(0, bestEnd));
                    // Crossfade for seamless
                    const fadeLen = Math.min(1024, bestEnd / 10);
                    for (let i = 0; i < fadeLen; i++) {
                        const fade = i / fadeLen;
                        loopData[bestEnd - fadeLen + i] = loopData[bestEnd - fadeLen + i] * (1 - fade) + loopData[i] * fade;
                    }
                }

                // Punch compression simulation
                const max = Math.max(...looped.getChannelData(0).map(Math.abs));
                if (max > 0) {
                    const normGain = 1.2 / max; // Slight overdrive
                    for (let ch = 0; ch < channels; ch++) {
                        const d = looped.getChannelData(ch);
                        for (let i = 0; i < d.length; i++) {
                            d[i] *= normGain;
                            if (Math.abs(d[i]) > 1) d[i] = Math.sign(d[i]) * (1 - Math.exp(1 - Math.abs(d[i])));
                        }
                    }
                }

                return looped;
            }

            quantumProcessBass(buffer, analysis) {
                // Multi-pitch correction with harmonic locking
                if (analysis.pitches.length > 0) {
                    const dominantPitch = analysis.pitches.reduce((prev, curr) => curr.confidence > prev.confidence ? curr : prev);
                    const nearest = this.getNearestNoteInScale(dominantPitch.freq);
                    const ratio = nearest.frequency / dominantPitch.freq;

                    const newLength = Math.floor(buffer.length / ratio);
                    const resampled = this.ctx.createBuffer(buffer.numberOfChannels, newLength, buffer.sampleRate);

                    for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                        const data = buffer.getChannelData(ch);
                        const out = resampled.getChannelData(ch);
                        for (let i = 0; i < newLength; i++) {
                            const srcIdx = i * ratio;
                            const floor = Math.floor(srcIdx);
                            const frac = srcIdx - floor;
                            out[i] = data[floor] * (1 - frac) + (data[floor + 1] || 0) * frac;
                        }
                    }

                    // Add sub-harmonic with quantum modulation
                    const subOsc = this.ctx.createOscillator();
                    subOsc.frequency.value = nearest.frequency / 2;
                    // ... (connect and render sub, but since offline, simulate addition)
                    const subData = new Float32Array(newLength);
                    const phaseInc = 2 * Math.PI * (nearest.frequency / 2) / this.ctx.sampleRate;
                    let phase = 0;
                    for (let i = 0; i < newLength; i++) {
                        subData[i] = Math.sin(phase) * 0.3 * (1 + (Math.random() - 0.5) * 0.1);
                        phase += phaseInc;
                        if (phase > 2 * Math.PI) phase -= 2 * Math.PI;
                    }
                    for (let ch = 0; ch < resampled.numberOfChannels; ch++) {
                        const out = resampled.getChannelData(ch);
                        for (let i = 0; i < newLength; i++) {
                            out[i] += subData[i];
                        }
                    }

                    return resampled;
                }
                return buffer;
            }

            quantumProcessMelody(buffer, analysis) {
                // Phrase slicing with genetic selection
                const phrases = this.extractMelodicPhrases(buffer, analysis);
                if (phrases.length === 0) return buffer;

                // Genetic algorithm for best phrase selection
                let population = phrases.map(p => ({phrase: p, fitness: p.energy * p.duration * (1 - p.noisiness)}));
                for (let gen = 0; gen < this.evolutionGenerations / 5; gen++) {
                    population.sort((a, b) => b.fitness - a.fitness);
                    population = population.slice(0, Math.ceil(population.length / 2));
                    // Mutation and crossover
                    for (let i = 0; i < population.length; i++) {
                        if (Math.random() < this.sampler.mutationRate) {
                            population[i].fitness *= 1 + (Math.random() - 0.5) * 0.2;
                        }
                        if (i + 1 < population.length && Math.random() < 0.3) {
                            const child = {
                                phrase: {
                                    start: (population[i].phrase.start + population[i+1].phrase.start) / 2,
                                    end: (population[i].phrase.end + population[i+1].phrase.end) / 2,
                                    energy: (population[i].phrase.energy + population[i+1].phrase.energy) / 2,
                                    duration: (population[i].phrase.duration + population[i+1].phrase.duration) / 2,
                                    noisiness: (population[i].phrase.noisiness + population[i+1].phrase.noisiness) / 2
                                },
                                fitness: (population[i].fitness + population[i+1].fitness) / 2
                            };
                            population.push(child);
                        }
                    }
                }

                const bestPhrase = population[0].phrase;
                const sliceLen = bestPhrase.end - bestPhrase.start;
                const sliceBuffer = this.ctx.createBuffer(buffer.numberOfChannels, sliceLen, buffer.sampleRate);

                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    const sliceData = sliceBuffer.getChannelData(ch);
                    sliceData.set(data.subarray(bestPhrase.start, bestPhrase.end));
                }

                return sliceBuffer;
            }

            extractMelodicPhrases(buffer, analysis) {
                const phrases = [];
                const data = buffer.getChannelData(0);
                for (let i = 0; i < analysis.onsets.length - 1; i++) {
                    const start = analysis.onsets[i];
                    const end = analysis.onsets[i + 1];
                    let energy = 0;
                    let crossings = 0;
                    for (let j = start; j < end; j++) {
                        energy += data[j] ** 2;
                        if (j > start && (data[j-1] >= 0) !== (data[j] >= 0)) crossings++;
                    }
                    energy /= (end - start);
                    const noisiness = crossings / (end - start) / 100;
                    if (energy > 0.0005 && noisiness < 0.5) {
                        phrases.push({
                            start,
                            end,
                            energy,
                            duration: (end - start) / this.ctx.sampleRate,
                            noisiness
                        });
                    }
                }
                return phrases;
            }

            quantumProcessLead(buffer, analysis) {
                // Saturation with harmonic distortion and quantum randomness
                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        let x = data[i];
                        x = x < 0 ? -Math.pow(Math.abs(x), 0.7) : Math.pow(x, 0.7);
                        x += (Math.random() - 0.5) * 0.05 * this.motion.intensity; // Quantum noise
                        data[i] = x;
                    }
                }
                return buffer;
            }

            quantumProcessPad(buffer, analysis) {
                // Extend with granular synthesis and reverb tails
                const granSize = 0.1 * this.ctx.sampleRate;
                const newLen = buffer.length * 2;
                const padBuffer = this.ctx.createBuffer(buffer.numberOfChannels, newLen, buffer.sampleRate);

                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    const out = padBuffer.getChannelData(ch);
                    out.set(data);
                    // Granular extension
                    for (let pos = buffer.length; pos < newLen; pos += granSize / 2) {
                        const grainStart = Math.floor(Math.random() * buffer.length - granSize);
                        const grain = data.subarray(grainStart, grainStart + granSize);
                        const fade = (newLen - pos) / (newLen - buffer.length);
                        for (let i = 0; i < grain.length && pos + i < newLen; i++) {
                            out[pos + i] += grain[i] * fade * (0.5 + Math.random() * 0.5);
                        }
                    }
                }
                return padBuffer;
            }

            quantumProcessFX(buffer, analysis) {
                // Chaotic modulation with attractor-driven effects
                const outBuffer = this.ctx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
                const { a, b, c } = this.motion.attractorParams;
                let ax = 0, ay = 0, az = 0;
                const dt = 0.005;

                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    const out = outBuffer.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        ax += dt * a * (ay - ax);
                        ay += dt * (ax * (b - az) - ay);
                        az += dt * (ax * ay - c * az);
                        const mod = (ax + ay + az) / 100;
                        out[i] = data[i] * (1 + mod) + (Math.sin(i / 1000 + mod) * 0.2);
                    }
                }
                return outBuffer;
            }

            quantumProcessVocal(buffer, analysis) {
                // Formant shifting with pitch evolution
                const formants = [730, 1090, 2440]; // Average vowel formants
                const shifted = this.ctx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);

                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    const out = shifted.getChannelData(ch);
                    out.set(data);
                    // Apply formant filters simulation
                    for (let f = 0; f < formants.length; f++) {
                        const freq = formants[f] * (1 + this.motion.intensity * 0.2);
                        // Simple peaking filter simulation
                        const q = 10;
                        const gain = 3;
                        for (let i = 0; i < data.length; i++) {
                            out[i] += data[i] * gain / q * Math.sin(2 * Math.PI * freq * i / this.ctx.sampleRate);
                        }
                    }
                }
                return shifted;
            }

            quantumProcessPerc(buffer, analysis) {
                // Transient enhancement with envelope sharpening
                const enhanced = this.ctx.createBuffer(buffer.numberOfChannels, buffer.length, buffer.sampleRate);
                const attackTime = 0.005 * this.ctx.sampleRate;
                const releaseTime = 0.1 * this.ctx.sampleRate;

                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    const data = buffer.getChannelData(ch);
                    const out = enhanced.getChannelData(ch);
                    let env = 0;
                    for (let i = 0; i < data.length; i++) {
                        const abs = Math.abs(data[i]);
                        env = abs > env ? abs : env * 0.99;
                        out[i] = data[i] * (1 + env * 2);
                    }
                }
                return enhanced;
            }

            getNearestNoteInScale(freq) {
                const A4 = 440;
                const semitones = 12 * Math.log2(freq / A4);
                const note = Math.round(semitones) % 12;
                const closest = this.scale.reduce((prev, curr) => Math.abs(curr - note) < Math.abs(prev - note) ? curr : prev);
                const octave = Math.floor(semitones / 12) + 4;
                return { frequency: A4 * Math.pow(2, (closest + octave * 12 - 57) / 12), note: closest, octave };
            }

            initializeGenome(type) {
                // Genome as array of traits: pattern length 32, binary
                const length = 32;
                const genome = Array(length).fill(0).map(() => Math.random() < 0.5 ? 1 : 0);
                // Seed based on type
                const basePattern = this.getBasePatternForType(type, length);
                for (let i = 0; i < length; i++) {
                    genome[i] = Math.random() < 0.8 ? basePattern[i % basePattern.length] : genome[i];
                }
                return genome;
            }

            getBasePatternForType(type, length) {
                const bases = {
                    drums: [1,0,0,0,1,0,0,0],
                    bass: [1,0,1,0,0,0,1,0],
                    melody: [1,0,0,0,0,0,0,0],
                    lead: [0,0,0,0,1,0,0,0],
                    pad: [1,1,1,1,1,1,1,1],
                    fx: [0,0,1,0,0,1,0,0],
                    vocal: [1,0,0,1,0,0,1,0],
                    perc: [0,1,0,1,0,1,0,1]
                };
                const base = bases[type] || [1,0,0,0];
                return Array(Math.ceil(length / base.length)).fill(base).flat().slice(0, length);
            }

            createEvolvedPlayer(slotIndex, slotType, analysis) {
                const player = {
                    slotIndex,
                    slotType,
                    analysis,
                    isPlaying: false,
                    nextPlayTime: 0,
                    playbackRate: 1,
                    gain: 0.8,
                    pattern: this.sampler.slots[slotIndex].genome,
                    currentStep: 0,
                    modulators: this.createModulators()
                };

                // Rate adjustment with analysis
                if (analysis.tempo) {
                    player.playbackRate = analysis.tempo / this.bpm * (1 + this.motion.intensity * 0.1);
                }

                return player;
            }

            createModulators() {
                // Nested modulators for parameters
                return {
                    rate: (time) => 1 + Math.sin(time * 0.1) * 0.05 + this.motion.attractorState.x / 50,
                    gain: (time) => 0.8 + Math.cos(time * 0.05) * 0.2 + this.motion.intensity * 0.3,
                    filterFreq: (time) => 500 + 2000 * (1 + this.motion.attractorState.y / 50),
                    pan: (time) => Math.sin(time * 0.2 + this.motion.attractorState.z / 20) * 0.5
                };
            }

            evolvePatternsGenetically() {
                this.sampler.slots.forEach(slot => {
                    if (slot.filled && slot.genome) {
                        // Evolve genome
                        const population = Array(this.sampler.geneticPopulation).fill(0).map(() => this.mutateGenome(slot.genome));
                        // Fitness based on motion match and harmony
                        population.forEach(ind => {
                            ind.fitness = this.calculateGenomeFitness(ind.genome, slot.analysis);
                        });
                        // Sort and select
                        population.sort((a, b) => b.fitness - a.fitness);
                        const elite = population.slice(0, 5);
                        const newPop = [];
                        for (let i = 0; i < this.sampler.geneticPopulation; i++) {
                            const parent1 = elite[Math.floor(Math.random() * elite.length)];
                            const parent2 = elite[Math.floor(Math.random() * elite.length)];
                            newPop.push(this.crossoverGenomes(parent1.genome, parent2.genome));
                        }
                        slot.genome = this.mutateGenome(newPop[0]);
                        slot.player.pattern = slot.genome;
                    }
                });
                this.aiAgent.mixNarrative.push('Evolved rhythmic genomes');
            }

            mutateGenome(genome) {
                return genome.map(g => Math.random() < this.sampler.mutationRate ? 1 - g : g);
            }

            crossoverGenomes(g1, g2) {
                const crossPoint = Math.floor(Math.random() * g1.length);
                return [...g1.slice(0, crossPoint), ...g2.slice(crossPoint)];
            }

            calculateGenomeFitness(genome, analysis) {
                let fitness = 0;
                // Density match
                const density = genome.reduce((sum, g) => sum + g, 0) / genome.length;
                fitness += 1 - Math.abs(density - (analysis.tonality * 0.5 + 0.5));
                // Sync with tempo
                const beatAlign = genome.every((g, i) => (i % 4 === 0 && g === 1) || true);
                fitness += beatAlign ? 0.2 : 0;
                // Harmony with chroma
                fitness += analysis.chroma.reduce((sum, c) => sum + c * density, 0) / 12;
                // Motion correlation
                fitness += this.motion.intensity * density;
                return fitness;
            }

            drawEvolvedWaveform(slotIndex, buffer) {
                const { ctx, canvas } = this.canvases[`waveform${slotIndex}`];
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 1.5;

                const dataL = buffer.getChannelData(0);
                const dataR = buffer.numberOfChannels > 1 ? buffer.getChannelData(1) : dataL;
                const step = Math.ceil(buffer.length / canvas.width);
                const amp = canvas.height / 2;

                ctx.beginPath();
                for (let i = 0; i < canvas.width; i++) {
                    const idx = Math.min(i * step, buffer.length - 1);
                    const valL = dataL[idx];
                    const valR = dataR[idx];
                    const y = amp + ((valL + valR) / 2) * amp * 0.9;
                    if (i === 0) ctx.moveTo(i, y);
                    else ctx.lineTo(i, y);
                }
                ctx.stroke();

                // Add spectral overlay
                ctx.fillStyle = 'rgba(0,255,0,0.2)';
                for (let i = 0; i < canvas.width; i++) {
                    const idx = i * step;
                    const mod = Math.abs(dataL[idx]) * amp / 2;
                    ctx.fillRect(i, amp - mod, 1, mod * 2);
                }
            }

            evolveOutfitParameters() {
                switch (this.outfit) {
                    case 'cosmic':
                        this.scale = [0, 2, 3, 5, 7, 8, 10];
                        this.swing = 0.05;
                        this.motion.attractorParams = { a: 10, b: 28, c: 8/3 }; // Lorenz
                        break;
                    case 'urban':
                        this.scale = [0, 3, 5, 6, 7, 10];
                        this.swing = 0.2;
                        this.motion.attractorParams = { a: 12, b: 30, c: 7/3 };
                        break;
                    case 'nature':
                        this.scale = [0, 2, 4, 5, 7, 9, 11];
                        this.swing = 0.1;
                        this.motion.attractorParams = { a: 8, b: 24, c: 9/3 };
                        break;
                    case 'minimal':
                        this.scale = [0, 2, 5, 7, 9];
                        this.swing = 0;
                        this.motion.attractorParams = { a: 10, b: 28, c: 8/3 };
                        break;
                    case 'quantum':
                        this.scale = [0, 1, 4, 5, 8, 9];
                        this.swing = 0.15 + Math.random() * 0.05;
                        this.motion.attractorParams = { a: 15, b: 35, c: 10/3 };
                        break;
                    case 'chaos':
                        this.scale = [0, 1, 3, 6, 7, 10];
                        this.swing = 0.25;
                        this.motion.attractorParams = { a: 20, b: 40, c: 12/3 };
                        break;
                }
                this.harmonicField = this.generateHarmonicField();
                this.aiAgent.mixNarrative.push(`Shifted to ${this.outfit} dimension`);
            }

            generateHarmonicField() {
                // Generate chord progressions based on scale
                const field = [];
                for (let root = 0; root < this.scale.length; root++) {
                    const chord = [this.scale[root], this.scale[(root + 2) % this.scale.length], this.scale[(root + 4) % this.scale.length]];
                    field.push(chord.map(n => n + 12 * Math.floor(Math.random() * 3)));
                }
                return field;
            }

            startHyperEngine() {
                this.startQuantumScheduler();
                this.animateHyperVisuals();
                this.generateEmergedAtmosphere();
            }

            startQuantumScheduler() {
                const schedule = () => {
                    while (this.scheduler.nextNoteTime < this.ctx.currentTime + this.scheduler.scheduleAheadTime) {
                        this.scheduleHyperStep();
                        this.advanceNoteWithJitter();
                    }
                    this.scheduler.timerId = setTimeout(schedule, this.scheduler.lookahead);
                };
                this.scheduler.nextNoteTime = this.ctx.currentTime;
                schedule();
            }

            scheduleHyperStep() {
                const when = this.scheduler.nextNoteTime;

                // Play slots with evolved patterns
                this.sampler.slots.forEach((slot, index) => {
                    if (slot.filled && slot.player.isPlaying) {
                        const step = this.currentBeat % slot.player.pattern.length;
                        if (slot.player.pattern[step] === 1) {
                            this.playEvolvedSlot(index, when);
                        }
                    }
                });

                // Stadium beats with genetic variations
                if (this.stadiumBeatActive) {
                    const step = this.currentBeat % 32;
                    if (this.drumPatterns.kick[step]) this.playQuantumKick(when);
                    if (this.drumPatterns.clap[step]) this.playQuantumClap(when);
                    if (this.drumPatterns.tom[step]) this.playQuantumTom(when);
                    if (this.drumPatterns.hiHat[step]) this.playQuantumHiHat(when);
                }

                // Generative elements from AI agent
                if (this.motion.intensity > 0.4 && this.currentBeat % 8 === 0) {
                    this.playGenerativeHarmony(when);
                }

                // Agent decisions per step
                if (Math.random() < 0.1) {
                    this.evaluateDecisionTree(this.aiAgent.decisionTree);
                }
            }

            playEvolvedSlot(index, when) {
                const slot = this.sampler.slots[index];
                if (!slot.buffer) return;

                const source = this.ctx.createBufferSource();
                source.buffer = slot.buffer;
                source.loop = true;

                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                const panner = this.ctx.createStereoPanner();

                const time = this.ctx.currentTime;
                const mods = slot.player.modulators;

                source.playbackRate.value = slot.player.playbackRate * mods.rate(time);
                filter.type = 'lowpass';
                filter.frequency.value = mods.filterFreq(time);
                filter.Q.value = 2 + this.motion.intensity * 8;
                gain.gain.value = mods.gain(time);
                panner.pan.value = mods.pan(time);

                source.connect(filter);
                filter.connect(panner);
                panner.connect(gain);
                gain.connect(slot.player.slotGain);
                slot.player.slotGain.connect(this.masterGain);

                source.start(when);

                // Visual feedback with animation
                const slotEl = document.querySelectorAll('.sample-slot')[index];
                slotEl.classList.add('playing');
                setTimeout(() => slotEl.classList.remove('playing'), 150 + this.motion.smoothed * 50);
            }

            playQuantumKick(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'sine';
                osc.frequency.setValueAtTime(180 + this.motion.attractorState.x * 10, when);
                osc.frequency.exponentialRampToValueAtTime(0.01, when + 0.6);

                gain.gain.setValueAtTime(1.2, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.6);

                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);

                osc.start(when);
                osc.stop(when + 0.6);
            }

            playQuantumClap(when) {
                const noise = this.ctx.createBufferSource();
                const len = this.ctx.sampleRate * 0.25;
                const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < len; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (len * 0.3));
                }
                noise.buffer = buf;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1200 + this.motion.attractorState.y * 200;
                filter.Q.value = 0.8;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.6, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.25);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);

                noise.start(when);
                noise.stop(when + 0.25);
            }

            playQuantumTom(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();

                osc.type = 'triangle';
                osc.frequency.setValueAtTime(250 + Math.random() * 150 + this.motion.attractorState.z * 50, when);
                osc.frequency.exponentialRampToValueAtTime(0.01, when + 0.4);

                gain.gain.setValueAtTime(0.8, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.4);

                osc.connect(gain);
                gain.connect(this.masterGain);
                gain.connect(this.reverb);

                osc.start(when);
                osc.stop(when + 0.4);
            }

            playQuantumHiHat(when) {
                const noise = this.ctx.createBufferSource();
                const len = this.ctx.sampleRate * 0.15;
                const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < len; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (len * 0.1));
                }
                noise.buffer = buf;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'highpass';
                filter.frequency.value = 5000 + this.motion.smoothed * 2000;

                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.4, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.15);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);

                noise.start(when);
                noise.stop(when + 0.15);
            }

            playGenerativeHarmony(when) {
                const chord = this.harmonicField[Math.floor(Math.random() * this.harmonicField.length)];
                chord.forEach(note => {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();

                    const freq = 440 * Math.pow(2, (note - 9) / 12);
                    osc.type = Math.random() < 0.5 ? 'sine' : 'sawtooth';
                    osc.frequency.value = freq * (1 + this.motion.attractorState.x / 100);

                    const dur = 0.5 + this.motion.intensity;
                    gain.gain.setValueAtTime(0, when);
                    gain.gain.linearRampToValueAtTime(0.15, when + 0.02);
                    gain.gain.exponentialRampToValueAtTime(0.001, when + dur);

                    osc.connect(gain);
                    gain.connect(this.masterGain);
                    gain.connect(this.reverb);

                    osc.start(when);
                    osc.stop(when + dur);
                });
            }

            advanceNoteWithJitter() {
                const secPerBeat = 60 / this.bpm / 4;
                this.scheduler.nextNoteTime += secPerBeat * (1 + (Math.random() - 0.5) * this.scheduler.jitter * this.motion.intensity);

                if (this.currentBeat % 2 === 1) {
                    this.scheduler.nextNoteTime += secPerBeat * this.swing;
                }

                this.currentBeat++;

                if (this.currentBeat % 32 === 0) {
                    this.measureCount++;
                    this.hyperEvolveTrack();
                }
            }

            hyperEvolveTrack() {
                this.progressionLevel = Math.floor(this.measureCount / 4);
                this.evolvePatternsGenetically();

                // Evolve effects parameters
                this.delayFeedback.gain.value = Math.min(0.8, 0.3 + this.progressionLevel * 0.06);
                this.scheduler.jitter = 0.005 + this.progressionLevel * 0.002;

                // Activate advanced features
                if (this.progressionLevel >= 3 && !this.multiverseMixer.connected) {
                    this.masterGain.connect(this.multiverseMixer);
                    this.multiverseMixer.connected = true;
                }

                // Agent tension build
                this.aiAgent.tensionLevel = Math.min(1, this.aiAgent.tensionLevel + 0.05);
                this.aiAgent.dropProbability = this.aiAgent.tensionLevel * this.motion.intensity;
                if (Math.random() < this.aiAgent.dropProbability) {
                    this.triggerDrop();
                }
            }

            generateEmergedAtmosphere() {
                const createEmergedDrone = () => {
                    if (!this.ctx) return;

                    const numLayers = 5 + Math.floor(this.progressionLevel / 2);
                    for (let layer = 0; layer < numLayers; layer++) {
                        const osc1 = this.ctx.createOscillator();
                        const osc2 = this.ctx.createOscillator();
                        const gain = this.ctx.createGain();
                        const filter = this.ctx.createBiquadFilter();

                        const baseFreq = 55 * Math.pow(2, this.scale[layer % this.scale.length] / 12) / (layer + 1);

                        osc1.type = 'triangle';
                        osc1.frequency.value = baseFreq;
                        osc1.detune.value = this.motion.smoothed * 10 + layer * 5;

                        osc2.type = 'sine';
                        osc2.frequency.value = baseFreq * this.phi;
                        osc2.detune.value = -this.motion.smoothed * 10 - layer * 5;

                        filter.type = 'lowpass';
                        filter.frequency.value = 150 + this.motion.smoothed * 150 + layer * 50;
                        filter.Q.value = 8 + layer;

                        const now = this.ctx.currentTime;
                        const dur = 21 + layer * 3;

                        gain.gain.setValueAtTime(0, now);
                        gain.gain.linearRampToValueAtTime(0.04 / numLayers, now + 4);
                        gain.gain.setValueAtTime(0.04 / numLayers, now + dur - 4);
                        gain.gain.linearRampToValueAtTime(0, now + dur);

                        osc1.connect(filter);
                        osc2.connect(filter);
                        filter.connect(gain);
                        gain.connect(this.masterGain);
                        gain.connect(this.reverb);

                        osc1.start(now);
                        osc2.start(now);
                        osc1.stop(now + dur);
                        osc2.stop(now + dur);
                    }

                    setTimeout(createEmergedDrone, 13000 - this.bpm * 10);
                };
                createEmergedDrone();
            }

            animateHyperVisuals() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    this.drawQuantumVisualizer();
                    this.drawEmergedParticles();
                    this.drawFractalEvolution();
                    this.drawMultiverseBranches();
                };
                animate();
            }

            drawQuantumVisualizer() {
                const { ctx, width, height } = this.canvases.visualizer;
                const bufferLen = this.analyser.frequencyBinCount;
                const data = new Uint8Array(bufferLen);
                this.analyser.getByteFrequencyData(data);

                ctx.fillStyle = 'rgba(0,0,0,0.08)';
                ctx.fillRect(0, 0, width, height);

                const barW = width / bufferLen * 3;
                let x = 0;

                for (let i = 0; i < bufferLen; i++) {
                    const barH = (data[i] / 255) * height * 0.8;
                    const hue = (i / bufferLen * 360 + this.currentBeat * 5) % 360;
                    ctx.fillStyle = `hsla(${hue}, 80%, 60%, 0.7)`;
                    ctx.fillRect(x, height - barH, barW, barH);

                    // Quantum distortion
                    if (Math.random() < this.motion.intensity * 0.01) {
                        ctx.fillRect(x + Math.random() * barW, height - barH * Math.random(), barW / 2, barH * Math.random());
                    }

                    x += barW + 1.5;
                }
            }

            drawEmergedParticles() {
                const { ctx, width, height } = this.canvases.particles;
                ctx.fillStyle = 'rgba(0,0,0,0.03)';
                ctx.fillRect(0, 0, width, height);

                const time = Date.now() * 0.001;
                this.particleSystem.particles.forEach(p => {
                    // Update with attractor influence
                    const dx = p.x - width / 2;
                    const dy = p.y - height / 2;
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx) + time * p.speed;

                    p.x += Math.cos(angle) * p.speed + this.motion.attractorState.x / 10;
                    p.y += Math.sin(angle) * p.speed + this.motion.attractorState.y / 10;

                    if (p.x < 0 || p.x > width || p.y < 0 || p.y > height) {
                        p.x = width / 2 + (Math.random() - 0.5) * 100;
                        p.y = height / 2 + (Math.random() - 0.5) * 100;
                    }

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size + this.motion.intensity * 3, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255,255,255,${p.alpha + this.motion.intensity * 0.4})`;
                    ctx.fill();
                });
            }

            createParticle() {
                return {
                    x: Math.random() * window.innerWidth,
                    y: Math.random() * window.innerHeight,
                    size: 2 + Math.random() * 3,
                    speed: 1 + Math.random() * 2,
                    alpha: 0.2 + Math.random() * 0.4
                };
            }

            drawFractalEvolution() {
                // Evolve fractal periodically
                if (this.currentBeat % 16 === 0) {
                    this.generateFractalBase();
                }
            }

            drawMultiverseBranches() {
                const { ctx, width, height } = this.canvases.multiverse;
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0,255,255,0.1)';
                ctx.lineWidth = 1;

                const branches = 10 + Math.floor(this.progressionLevel * 2);
                const time = Date.now() * 0.0005;

                for (let b = 0; b < branches; b++) {
                    ctx.beginPath();
                    let x = width / 2;
                    let y = height / 2;
                    ctx.moveTo(x, y);
                    for (let step = 0; step < 50; step++) {
                        const angle = (b / branches * Math.PI * 2) + time + step * 0.1 + this.motion.attractorState.z / 20;
                        x += Math.cos(angle) * (10 + this.motion.smoothed);
                        y += Math.sin(angle) * (10 + this.motion.smoothed);
                        ctx.lineTo(x % width, y % height);
                    }
                    ctx.stroke();
                }
            }

            triggerDrop() {
                this.elements.dropIndicator.classList.add('active');
                this.elements.dropIndicator.textContent = 'DROP ACTIVATED!';
                setTimeout(() => this.elements.dropIndicator.classList.remove('active'), 2000);

                // Sudden BPM boost
                this.bpm *= 1.5;
                setTimeout(() => this.bpm /= 1.5, 8000);

                // Silence then explosion
                this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.5);
                setTimeout(() => {
                    this.masterGain.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.5);
                    // Play all slots at once
                    this.sampler.slots.forEach((s, i) => {
                        if (s.filled) this.playEvolvedSlot(i, this.ctx.currentTime);
                    });
                }, 500);

                this.aiAgent.tensionLevel = 0;
                this.aiAgent.mixNarrative.push('Executed clever drop!');
            }

            buildTension() {
                this.aiAgent.tensionLevel += 0.2;
                this.elements.dropIndicator.classList.add('active');
                this.elements.dropIndicator.textContent = 'BUILDING TENSION...';
                setTimeout(() => this.elements.dropIndicator.classList.remove('active'), 1000);

                // Increase reverb and delay
                this.reverbSend.gain.value += 0.2;
                this.delayFeedback.gain.value += 0.1;

                this.aiAgent.mixNarrative.push('Building anticipatory tension');
            }

            activateStadiumBeat() {
                this.stadiumBeatActive = true;
                this.reverbSend = this.ctx.createGain();
                this.reverbSend.gain.value = 0.6;
                this.masterGain.connect(this.reverbSend);
                this.reverbSend.connect(this.reverb);
                this.aiAgent.mixNarrative.push('Activated stadium tribal beats');
            }

            generateQuantumFX() {
                // Random FX burst
                const fxDur = 2 + Math.random() * 3;
                const noise = this.ctx.createBufferSource();
                const len = this.ctx.sampleRate * fxDur;
                const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
                const data = buf.getChannelData(0);
                for (let i = 0; i < len; i++) {
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-i / len) * (1 + Math.sin(i / 1000));
                }
                noise.buffer = buf;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'allpass';
                filter.frequency.value = 440 * Math.pow(2, Math.random() * 12);

                noise.connect(filter);
                filter.connect(this.masterGain);

                noise.start();
                noise.stop(this.ctx.currentTime + fxDur);

                this.aiAgent.mixNarrative.push('Injected quantum FX burst');
            }

            branchMultiverseMix() {
                // Simulate parallel mix by duplicating and detuning
                const detuneAmount = 100 * this.motion.intensity;
                const parallelGain = this.ctx.createGain();
                parallelGain.gain.value = 0.3;

                const detuneOsc = this.ctx.createOscillator();
                detuneOsc.detune.value = detuneAmount;

                // Connect parallel chain
                this.masterGain.connect(parallelGain);
                parallelGain.connect(this.multiverseMixer);

                setTimeout(() => parallelGain.disconnect(), 10000);

                this.aiAgent.mixNarrative.push('Branched multiverse mix layer');
            }

            selfModifyScheduler() {
                // Dynamically rewrite scheduler jitter
                this.scheduler.jitter = 0.01 + Math.random() * 0.05;
                this.aiAgent.mixNarrative.push('Self-modified scheduling algorithm');
            }

            mutateOutfit() {
                const outfits = ['cosmic', 'urban', 'nature', 'minimal', 'quantum', 'chaos'];
                const newOutfit = outfits[Math.floor(Math.random() * outfits.length)];
                this.outfit = newOutfit;
                document.querySelectorAll('.outfit').forEach(el => {
                    el.classList.toggle('active', el.dataset.outfit === newOutfit);
                });
                this.evolveOutfitParameters();
                this.aiAgent.mixNarrative.push(`Mutated to ${newOutfit} paradigm`);
            }

            initTestSuite() {
                return {
                    tests: [
                        { name: 'AudioChain', fn: () => this.testAudioChain() },
                        { name: 'MotionUpdate', fn: () => this.testMotionUpdate() },
                        { name: 'GeneticEvolution', fn: () => this.testGeneticEvolution() },
                        { name: 'AgentDecision', fn: () => this.testAgentDecision() },
                        { name: 'VisualRender', fn: () => this.testVisualRender() }
                    ],
                    runAllTests: function() {
                        this.tests.forEach(test => {
                            try {
                                test.fn();
                                console.log(`Test ${test.name} passed`);
                            } catch (e) {
                                console.error(`Test ${test.name} failed:`, e);
                            }
                        });
                    }
                };
            }

            testAudioChain() {
                if (!this.ctx || this.ctx.state !== 'running') throw new Error('Audio context not running');
                if (this.analyser.frequencyBinCount !== 2048) throw new Error('Analyser FFT size mismatch');
            }

            testMotionUpdate() {
                const oldSmoothed = this.motion.smoothed;
                this.updateMotionWithAttractor(10, {x:5, y:5, z:5});
                if (this.motion.smoothed <= oldSmoothed) throw new Error('Motion not smoothing upwards');
            }

            testGeneticEvolution() {
                const slot = { genome: Array(32).fill(0), analysis: {tonality: 0.5} };
                const evolved = this.mutateGenome(slot.genome);
                if (evolved.every((g, i) => g === slot.genome[i])) throw new Error('No mutation occurred');
                const fitness = this.calculateGenomeFitness(evolved, slot.analysis);
                if (fitness <= 0) throw new Error('Fitness non-positive');
            }

            testAgentDecision() {
                const tree = this.buildDecisionTree(2);
                // No throw means passed, since recursive
            }

            testVisualRender() {
                const canvas = this.canvases.visualizer.canvas;
                if (canvas.width === 0 || canvas.height === 0) throw new Error('Canvas not resized');
            }
        }

        // Awaken the quantum symphony
        const quantumDj = new QuantumAIDJEngine();
    </script>
</body>
</html>
