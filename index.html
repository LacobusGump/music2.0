<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh;height:100dvh}
        canvas{position:fixed;top:0;left:0;width:100%;height:100%}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 1.5s}
        #enter div{width:100px;height:100px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:3px;color:rgba(255,255,255,0.3);transition:0.3s}
        #enter:hover div{border-color:rgba(255,255,255,0.4);color:rgba(255,255,255,0.6)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// Position is harmony. Stillness blooms. Movement is melody.

const TAU = Math.PI * 2;

// ============ STATE ============

let ctx, master, verb, dly;
let canvas, vc;
let running = false;

const field = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    energy: 0,
    stillness: 0,
    groove: 0,
    time: 0,

    // Current harmony
    root: 0,
    color: 0.5,
    lastRoot: 0
};

// Living notes - spawn from stillness, fade with movement
const notes = [];
const MAX_NOTES = 16;

// Melody state
const melody = {
    voice: null,
    currentNote: null,
    targetNote: null,
    lastTrigger: 0
};

// ============ MUSIC THEORY ============

const BASE = 110; // A2

// Scale degrees (major scale intervals in semitones)
const SCALE = [0, 2, 4, 5, 7, 9, 11]; // Major scale

// Chord tones relative to root (in semitones)
const CHORDS = {
    major: [0, 4, 7, 11],      // maj7
    minor: [0, 3, 7, 10],      // min7
    dom: [0, 4, 7, 10],        // dom7
    dim: [0, 3, 6, 9],         // dim7
    sus: [0, 5, 7, 10]         // sus4
};

// Get chord type based on Y position (color)
function getChordType(y) {
    if (y < 0.2) return 'minor';
    if (y < 0.4) return 'dom';
    if (y < 0.6) return 'major';
    if (y < 0.8) return 'sus';
    return 'major';
}

// Get root note from X position (moves through scale)
function getRootFromX(x) {
    const degree = Math.floor(x * 7) % 7;
    return SCALE[degree];
}

// Get a random chord tone
function getChordTone(root, chordType, octaveOffset = 0) {
    const chord = CHORDS[chordType];
    const interval = chord[Math.floor(Math.random() * chord.length)];
    return BASE * Math.pow(2, (root + interval) / 12 + octaveOffset);
}

// Get scale tone for melody
function getScaleTone(root, y) {
    // Y position determines register (octave) and tendency
    const octave = Math.floor(y * 2) + 1;
    const degree = SCALE[Math.floor(Math.random() * SCALE.length)];
    return BASE * Math.pow(2, (root + degree) / 12 + octave);
}

// ============ RHYTHM ============

const rhythm = {
    bpm: 72,
    position: 0,
    accumulator: 0,

    // Purdie shuffle - 48 steps (12 per beat Ã— 4 beats)
    kick: [
        0.9,0,0,0,0,0, 0,0,0,0,0,0,
        0,0,0,0,0,0, 0.5,0,0,0,0,0,
        0.7,0,0,0,0,0, 0,0,0,0,0,0,
        0,0,0,0,0,0, 0.4,0,0,0,0,0
    ],
    snare: [
        0,0,0.12,0,0.15,0, 0,0,0.1,0,0.18,0,
        0.95,0,0.15,0,0.1,0, 0.08,0,0.2,0,0.12,0,
        0,0,0.1,0,0.18,0, 0,0,0.12,0,0.22,0,
        1.0,0,0.12,0,0.15,0, 0.1,0,0.18,0,0.15,0
    ],
    hat: [
        0.5,0,0,0.3,0,0, 0.4,0,0,0.25,0,0,
        0.5,0,0,0.3,0,0, 0.4,0,0,0.25,0,0,
        0.5,0,0,0.3,0,0, 0.4,0,0,0.25,0,0,
        0.5,0,0,0.3,0,0, 0.45,0,0,0.3,0,0
    ],

    kickPulse: 0,
    snarePulse: 0,
    hatPulse: 0,

    get subdivisionLength() { return (60 / this.bpm) / 12; }
};

// ============ AUDIO ============

function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master = ctx.createGain();
    master.gain.value = 0.6;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.ratio.value = 4;
    comp.attack.value = 0.003;
    comp.release.value = 0.15;

    verb = createVerb();
    dly = createDelay();

    master.connect(comp);
    comp.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    initDrums();
    initMelody();
}

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.3;

    [0.029, 0.067, 0.113, 0.179, 0.233, 0.307, 0.419, 0.541].forEach((t, i) => {
        const d = ctx.createDelay(1);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = 0.3 * Math.pow(0.8, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 2500 - i * 250;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
    });

    return { input, output };
}

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.2;

    const d = ctx.createDelay(2);
    d.delayTime.value = (60 / rhythm.bpm) * 0.75;
    const fb = ctx.createGain();
    fb.gain.value = 0.3;
    const f = ctx.createBiquadFilter();
    f.type = 'lowpass';
    f.frequency.value = 1800;

    input.connect(d);
    d.connect(f);
    f.connect(fb);
    fb.connect(d);
    f.connect(output);

    return { input, output, delay: d, feedback: fb };
}

// ============ DRUMS ============

let drums = {};

function initDrums() {
    drums.master = ctx.createGain();
    drums.master.gain.value = 0;
    drums.master.connect(master);
    drums.master.connect(verb.input);
}

function triggerKick(vel) {
    const v = vel * field.groove;
    if (v < 0.05) return;

    const now = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);

    gain.gain.setValueAtTime(v * 0.7, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

    osc.connect(gain);
    gain.connect(drums.master);
    osc.start(now);
    osc.stop(now + 0.35);

    rhythm.kickPulse = v;
}

function triggerSnare(vel) {
    const v = vel * field.groove;
    if (v < 0.02) return;

    const now = ctx.currentTime;
    const isGhost = vel < 0.4;

    const bufSize = ctx.sampleRate * (isGhost ? 0.06 : 0.12);
    const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.12));
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buf;

    const filt = ctx.createBiquadFilter();
    filt.type = 'bandpass';
    filt.frequency.value = isGhost ? 4000 : 2500;
    filt.Q.value = isGhost ? 2 : 1;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(v * (isGhost ? 0.2 : 0.4), now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + (isGhost ? 0.05 : 0.1));

    noise.connect(filt);
    filt.connect(gain);
    gain.connect(drums.master);
    noise.start(now);

    if (!isGhost) {
        const osc = ctx.createOscillator();
        const oscGain = ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(180, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.03);
        oscGain.gain.setValueAtTime(v * 0.3, now);
        oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.06);
        osc.connect(oscGain);
        oscGain.connect(drums.master);
        osc.start(now);
        osc.stop(now + 0.1);
    }

    rhythm.snarePulse = Math.max(rhythm.snarePulse, v);
}

function triggerHat(vel) {
    const v = vel * field.groove;
    if (v < 0.05) return;

    const now = ctx.currentTime;
    const bufSize = ctx.sampleRate * 0.03;
    const buf = ctx.createBuffer(1, bufSize, ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i = 0; i < bufSize; i++) {
        data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufSize * 0.2));
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buf;

    const filt = ctx.createBiquadFilter();
    filt.type = 'highpass';
    filt.frequency.value = 8000;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(v * 0.15, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.03);

    noise.connect(filt);
    filt.connect(gain);
    gain.connect(drums.master);
    noise.start(now);

    rhythm.hatPulse = Math.max(rhythm.hatPulse, v);
}

// ============ MELODY ============

function initMelody() {
    melody.voice = {
        osc: ctx.createOscillator(),
        gain: ctx.createGain(),
        filter: ctx.createBiquadFilter()
    };

    melody.voice.osc.type = 'sawtooth';
    melody.voice.osc.frequency.value = 220;
    melody.voice.filter.type = 'lowpass';
    melody.voice.filter.frequency.value = 800;
    melody.voice.filter.Q.value = 2;
    melody.voice.gain.gain.value = 0;

    melody.voice.osc.connect(melody.voice.filter);
    melody.voice.filter.connect(melody.voice.gain);
    melody.voice.gain.connect(master);
    melody.voice.gain.connect(dly.input);
    melody.voice.gain.connect(verb.input);

    melody.voice.osc.start();
}

function updateMelody(dt) {
    const now = ctx.currentTime;

    // Melody follows movement - more movement = more melody
    const melodyIntensity = Math.min(1, field.energy * 3);

    // Target frequency based on position
    const root = getRootFromX(field.x);
    const chordType = getChordType(field.y);
    const octave = 1 + field.y;
    const targetFreq = BASE * Math.pow(2, (root + SCALE[Math.floor(field.y * 7) % 7]) / 12 + octave);

    // Glide to target
    melody.voice.osc.frequency.linearRampToValueAtTime(targetFreq, now + 0.1);

    // Volume follows energy
    const vol = melodyIntensity * 0.12 * (1 - field.groove * 0.5);
    melody.voice.gain.gain.linearRampToValueAtTime(vol, now + 0.05);

    // Filter opens with Y and energy
    const filterFreq = 400 + field.y * 2000 + field.energy * 1500;
    melody.voice.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.08);
}

// ============ BLOOMING NOTES ============
// When still, notes spawn to complete the harmony

function spawnNote() {
    if (notes.length >= MAX_NOTES) return;
    if (field.stillness < 0.3) return;
    if (Math.random() > field.stillness * 0.15) return;

    const root = getRootFromX(field.x);
    const chordType = getChordType(field.y);
    const octave = Math.random() < 0.5 ? 0 : 1;
    const freq = getChordTone(root, chordType, octave);

    const note = {
        freq,
        life: 1,
        x: field.x + (Math.random() - 0.5) * 0.2,
        y: field.y + (Math.random() - 0.5) * 0.2,
        osc: ctx.createOscillator(),
        osc2: ctx.createOscillator(),
        gain: ctx.createGain(),
        filter: ctx.createBiquadFilter(),
        pan: ctx.createStereoPanner()
    };

    // Setup audio
    note.osc.type = 'sine';
    note.osc.frequency.value = freq;
    note.osc2.type = 'sine';
    note.osc2.frequency.value = freq * 1.002;

    note.filter.type = 'lowpass';
    note.filter.frequency.value = 300 + field.y * 1500;
    note.filter.Q.value = 0.5;

    note.gain.gain.value = 0;
    note.pan.pan.value = (note.x - 0.5) * 1.5;

    // Connect
    note.osc.connect(note.filter);
    note.osc2.connect(note.filter);
    note.filter.connect(note.gain);
    note.gain.connect(note.pan);
    note.pan.connect(master);
    note.pan.connect(verb.input);

    note.osc.start();
    note.osc2.start();

    // Fade in
    const now = ctx.currentTime;
    note.gain.gain.linearRampToValueAtTime(0.08 * field.stillness, now + 0.3);

    notes.push(note);
}

function updateNotes(dt) {
    const now = ctx.currentTime;

    // Movement kills notes
    const decayRate = 0.02 + field.energy * 0.5;

    for (let i = notes.length - 1; i >= 0; i--) {
        const note = notes[i];
        note.life -= dt * decayRate;

        if (note.life <= 0) {
            // Fade out and remove
            note.gain.gain.linearRampToValueAtTime(0, now + 0.3);
            setTimeout(() => {
                note.osc.stop();
                note.osc2.stop();
            }, 400);
            notes.splice(i, 1);
        } else {
            // Update volume based on life and stillness
            const vol = note.life * field.stillness * 0.08;
            note.gain.gain.linearRampToValueAtTime(vol, now + 0.1);

            // Filter follows field
            note.filter.frequency.linearRampToValueAtTime(200 + field.y * 1500 + note.life * 500, now + 0.1);
        }
    }
}

// ============ FIELD SHAPING ============

function shapeField(dt) {
    const now = ctx.currentTime;

    const speed = Math.sqrt(field.vx * field.vx + field.vy * field.vy);
    field.energy = field.energy * 0.9 + speed * 1.0;

    if (speed < 0.008) {
        field.stillness = Math.min(1, field.stillness + dt * 0.3);
    } else {
        field.stillness *= 0.88;
    }

    // Groove from stillness
    const targetGroove = field.stillness * (1 - field.energy * 0.5);
    field.groove += (targetGroove - field.groove) * dt * 1.0;
    field.groove = Math.max(0, Math.min(1, field.groove));

    // Track harmony changes
    const newRoot = getRootFromX(field.x);
    if (newRoot !== field.root) {
        field.lastRoot = field.root;
        field.root = newRoot;
        // Kill some notes on chord change
        for (const note of notes) {
            note.life *= 0.5;
        }
    }
    field.color = field.y;

    // Drums
    drums.master.gain.linearRampToValueAtTime(field.groove * 0.8, now + 0.1);

    // Reverb
    verb.output.gain.linearRampToValueAtTime(0.2 + field.stillness * 0.3, now + 0.2);

    // Delay
    dly.feedback.gain.linearRampToValueAtTime(0.15 + field.energy * 0.3, now + 0.1);
}

// ============ RHYTHM ENGINE ============

function tickRhythm(dt) {
    rhythm.accumulator += dt;
    rhythm.kickPulse *= 0.85;
    rhythm.snarePulse *= 0.88;
    rhythm.hatPulse *= 0.9;

    while (rhythm.accumulator >= rhythm.subdivisionLength) {
        rhythm.accumulator -= rhythm.subdivisionLength;

        const k = rhythm.kick[rhythm.position];
        const s = rhythm.snare[rhythm.position];
        const h = rhythm.hat[rhythm.position];

        if (k > 0) triggerKick(k);
        if (s > 0) triggerSnare(s);
        if (h > 0) triggerHat(h);

        // Spawn notes on some beats when still
        if (rhythm.position % 12 === 0) {
            spawnNote();
        }

        rhythm.position = (rhythm.position + 1) % 48;
    }
}

// ============ INPUT ============

function onMove(nx, ny) {
    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = nx;
    field.y = ny;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    field.vx = field.vx * 0.7 + (a.x || 0) / 12 * 0.3;
    field.vy = field.vy * 0.7 + (a.y || 0) / 12 * 0.3;
    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.08));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.08));
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 50;
    const gy = (e.beta || 0) / 50 - 0.8;
    onMove(Math.max(0, Math.min(1, (gx + 1) / 2)), Math.max(0, Math.min(1, 1 - (gy + 1) / 2)));
}

// ============ VISUALS ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = window.innerWidth * dpr;
    canvas.height = window.innerHeight * dpr;
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    const fadeAlpha = 0.07 + (1 - field.energy) * 0.03 + field.groove * 0.03;
    vc.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
    vc.fillRect(0, 0, w, h);

    const cx = field.x * w;
    const cy = (1 - field.y) * h;

    // Harmonic region indicator
    const root = field.root;
    const regionHue = (root * 30 + 180) % 360;
    vc.fillStyle = `hsla(${regionHue}, 40%, 20%, ${0.1 + field.stillness * 0.1})`;
    vc.fillRect(0, 0, w, h);

    // Rhythm rings
    if (field.groove > 0.1) {
        if (rhythm.kickPulse > 0.1) {
            vc.beginPath();
            vc.arc(cx, cy, 70 + rhythm.kickPulse * 50, 0, TAU);
            vc.strokeStyle = `rgba(255, 150, 100, ${rhythm.kickPulse * field.groove * 0.4})`;
            vc.lineWidth = 3 + rhythm.kickPulse * 3;
            vc.stroke();
        }
        if (rhythm.snarePulse > 0.05) {
            vc.beginPath();
            vc.arc(cx, cy, 35 + rhythm.snarePulse * 25, 0, TAU);
            vc.strokeStyle = `rgba(255, 255, 255, ${rhythm.snarePulse * field.groove * 0.5})`;
            vc.lineWidth = 1 + rhythm.snarePulse * 2;
            vc.stroke();
        }
    }

    // Blooming notes
    for (const note of notes) {
        const nx = note.x * w;
        const ny = (1 - note.y) * h;
        const nr = 8 + note.life * 25;
        const noteHue = (Math.log2(note.freq / BASE) * 60 + 200) % 360;

        vc.beginPath();
        vc.arc(nx, ny, nr, 0, TAU);
        const grad = vc.createRadialGradient(nx, ny, 0, nx, ny, nr);
        grad.addColorStop(0, `hsla(${noteHue}, 70%, 60%, ${note.life * 0.6})`);
        grad.addColorStop(1, 'transparent');
        vc.fillStyle = grad;
        vc.fill();

        // Connection to cursor
        if (note.life > 0.3) {
            vc.beginPath();
            vc.moveTo(cx, cy);
            vc.lineTo(nx, ny);
            vc.strokeStyle = `rgba(255, 255, 255, ${note.life * 0.15})`;
            vc.lineWidth = 1;
            vc.stroke();
        }
    }

    // Melody indicator
    const melodySize = 15 + field.energy * 30;
    vc.beginPath();
    vc.arc(cx, cy, melodySize, 0, TAU);
    const melodyGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, melodySize);
    melodyGrad.addColorStop(0, `rgba(255, 255, 255, ${0.5 + field.energy * 0.4})`);
    melodyGrad.addColorStop(0.5, `rgba(200, 220, 255, ${0.15 + field.energy * 0.2})`);
    melodyGrad.addColorStop(1, 'transparent');
    vc.fillStyle = melodyGrad;
    vc.fill();

    // Movement trail
    if (field.energy > 0.03) {
        const trailLen = field.energy * 80;
        vc.beginPath();
        vc.moveTo(cx, cy);
        vc.lineTo(cx - field.vx * trailLen * 8, cy + field.vy * trailLen * 8);
        vc.strokeStyle = `rgba(255, 255, 255, ${field.energy * 0.5})`;
        vc.lineWidth = 2 + field.energy * 2;
        vc.lineCap = 'round';
        vc.stroke();
    }
}

// ============ LOOP ============

let lastTime = 0;

function tick(timestamp) {
    if (!running) return;

    const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
    lastTime = timestamp;
    field.time += dt;

    tickRhythm(dt);
    shapeField(dt);
    updateMelody(dt);
    updateNotes(dt);
    spawnNote();
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);

    initAudio();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, 1 - e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    lastTime = performance.now();
    tick(lastTime);
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
