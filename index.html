<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 2s}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.25);transition:0.5s}
        #enter:hover div{border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.5)}
        #gumpy{position:fixed;bottom:30px;left:0;right:0;text-align:center;pointer-events:none;z-index:5}
        #gumpy-thought{font:13px/1.6 Georgia,serif;color:rgba(255,255,255,0);letter-spacing:1px;transition:color 3s;max-width:600px;margin:0 auto;padding:0 20px}
        #gumpy-thought.visible{color:rgba(255,255,255,0.4)}
        #gumpy-thought.fading{color:rgba(255,255,255,0)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<div id="gumpy"><div id="gumpy-thought"></div></div>
<script>
// ============================================================
// GUMP - Grand Unified Music Project
// ============================================================
// The universe is not particles in void.
// The universe is a field. The vacuum hums.
// What we see are excitations - collapsed probability.
// Music is the substrate. We are learning to hear it.
// ============================================================

const TAU = Math.PI * 2;
const PHI = 1.618033988749;
const PLANCK = 6.62607015e-34; // Not used literally, but as spirit
const ALPHA = 1/137.035999; // Fine structure constant - why this number?

// ============ THE FIELD ============
// The vacuum is not empty. It vibrates.
// Every point in space has potential for every frequency.
// This is the zero-point energy. The hum beneath silence.

const Field = {
    // Resolution of the probability field
    resolution: 32,

    // The field itself - amplitude of each frequency at each point
    // field[x][y] = Map(frequency -> amplitude)
    grid: [],

    // Vacuum energy - the hum of empty space
    vacuumEnergy: 0.01,

    // The fundamental frequencies - derived from physics
    // Electron orbitals: 1s, 2s, 2p, 3s... follow n² pattern
    // This maps to octaves: 1, 4, 9, 16... but we use musical ratios
    fundamentals: [],

    init() {
        // The harmonic series - overtones of existence
        // These are the "allowed" frequencies - like electron orbitals
        const base = 1;
        this.fundamentals = [
            base,           // Ground state
            base * 2,       // First octave - n=2 orbital
            base * 3/2,     // Perfect fifth - the most consonant
            base * 4/3,     // Perfect fourth
            base * 5/4,     // Major third - the sweetness
            base * 6/5,     // Minor third - the melancholy
            base * 5/3,     // Major sixth
            base * 8/5,     // Minor sixth
            base * 9/8,     // Major second
            base * 16/15,   // Minor second - tension
            base * 15/8,    // Major seventh - yearning
            base * 9/5,     // Minor seventh
            base * 45/32,   // Tritone - the devil's interval
        ];

        // Initialize the probability field
        for (let x = 0; x < this.resolution; x++) {
            this.grid[x] = [];
            for (let y = 0; y < this.resolution; y++) {
                this.grid[x][y] = new Map();

                // Every point has vacuum fluctuation in all frequencies
                for (const freq of this.fundamentals) {
                    // Random phase, tiny amplitude - quantum foam
                    this.grid[x][y].set(freq, {
                        amplitude: this.vacuumEnergy * (0.5 + Math.random() * 0.5),
                        phase: Math.random() * TAU
                    });
                }
            }
        }
    },

    // Get interpolated field value at any point
    sample(x, y, freq) {
        const gx = x * (this.resolution - 1);
        const gy = y * (this.resolution - 1);
        const x0 = Math.floor(gx);
        const y0 = Math.floor(gy);
        const x1 = Math.min(x0 + 1, this.resolution - 1);
        const y1 = Math.min(y0 + 1, this.resolution - 1);
        const fx = gx - x0;
        const fy = gy - y0;

        const get = (gx, gy) => {
            const cell = this.grid[gx]?.[gy];
            if (!cell) return { amplitude: 0, phase: 0 };
            return cell.get(freq) || { amplitude: 0, phase: 0 };
        };

        // Bilinear interpolation
        const v00 = get(x0, y0);
        const v10 = get(x1, y0);
        const v01 = get(x0, y1);
        const v11 = get(x1, y1);

        return {
            amplitude: v00.amplitude * (1-fx) * (1-fy) +
                      v10.amplitude * fx * (1-fy) +
                      v01.amplitude * (1-fx) * fy +
                      v11.amplitude * fx * fy,
            phase: v00.phase // Simplified - phase interpolation is complex
        };
    },

    // Excite the field at a point
    excite(x, y, freq, energy) {
        const gx = Math.floor(x * (this.resolution - 1));
        const gy = Math.floor(y * (this.resolution - 1));

        // Excitation spreads to neighbors
        for (let dx = -2; dx <= 2; dx++) {
            for (let dy = -2; dy <= 2; dy++) {
                const nx = gx + dx;
                const ny = gy + dy;
                if (nx < 0 || nx >= this.resolution || ny < 0 || ny >= this.resolution) continue;

                const dist = Math.sqrt(dx*dx + dy*dy);
                const falloff = Math.exp(-dist * 0.8);

                const cell = this.grid[nx][ny];
                const current = cell.get(freq) || { amplitude: 0, phase: 0 };

                cell.set(freq, {
                    amplitude: Math.min(1, current.amplitude + energy * falloff),
                    phase: current.phase
                });
            }
        }
    },

    // The field evolves - waves propagate, interfere, decay
    evolve(dt) {
        const newGrid = [];

        for (let x = 0; x < this.resolution; x++) {
            newGrid[x] = [];
            for (let y = 0; y < this.resolution; y++) {
                newGrid[x][y] = new Map();

                for (const freq of this.fundamentals) {
                    const current = this.grid[x][y].get(freq);
                    if (!current) continue;

                    // Wave equation: amplitude propagates from neighbors
                    let neighborSum = 0;
                    let neighborCount = 0;

                    for (let dx = -1; dx <= 1; dx++) {
                        for (let dy = -1; dy <= 1; dy++) {
                            if (dx === 0 && dy === 0) continue;
                            const nx = x + dx;
                            const ny = y + dy;
                            if (nx < 0 || nx >= this.resolution || ny < 0 || ny >= this.resolution) continue;

                            const neighbor = this.grid[nx][ny].get(freq);
                            if (neighbor) {
                                neighborSum += neighbor.amplitude;
                                neighborCount++;
                            }
                        }
                    }

                    const neighborAvg = neighborCount > 0 ? neighborSum / neighborCount : 0;

                    // Diffusion + decay back to vacuum energy
                    const diffusion = 0.1;
                    const decay = 0.995;

                    let newAmp = current.amplitude * decay;
                    newAmp += (neighborAvg - current.amplitude) * diffusion;
                    newAmp = Math.max(this.vacuumEnergy * 0.5, newAmp);

                    // Phase advances based on frequency
                    const newPhase = (current.phase + dt * freq * 2) % TAU;

                    newGrid[x][y].set(freq, {
                        amplitude: newAmp,
                        phase: newPhase
                    });
                }
            }
        }

        this.grid = newGrid;
    },

    // Find the strongest excitation in the field
    findPeak() {
        let maxAmp = 0;
        let peakX = 0.5, peakY = 0.5, peakFreq = 1;

        for (let x = 0; x < this.resolution; x++) {
            for (let y = 0; y < this.resolution; y++) {
                for (const [freq, state] of this.grid[x][y]) {
                    if (state.amplitude > maxAmp) {
                        maxAmp = state.amplitude;
                        peakX = x / (this.resolution - 1);
                        peakY = y / (this.resolution - 1);
                        peakFreq = freq;
                    }
                }
            }
        }

        return { x: peakX, y: peakY, freq: peakFreq, amplitude: maxAmp };
    }
};

// ============ SUPERPOSITION ============
// Before observation, a quantum exists in all possible states.
// The wave function contains all possibilities weighted by amplitude.

class WaveFunction {
    constructor(x, y) {
        this.x = x;
        this.y = y;

        // Superposition: map of frequency -> probability amplitude
        this.states = new Map();

        // Sample the field to determine initial superposition
        for (const freq of Field.fundamentals) {
            const fieldState = Field.sample(x, y, freq);
            if (fieldState.amplitude > Field.vacuumEnergy * 2) {
                this.states.set(freq, {
                    amplitude: fieldState.amplitude,
                    phase: fieldState.phase
                });
            }
        }

        // If field is quiet, create from vacuum fluctuation
        if (this.states.size === 0) {
            const randomFreq = Field.fundamentals[Math.floor(Math.random() * Field.fundamentals.length)];
            this.states.set(randomFreq, {
                amplitude: 0.3 + Math.random() * 0.3,
                phase: Math.random() * TAU
            });
        }

        this.normalize();
    }

    normalize() {
        // Total probability must equal 1
        let total = 0;
        for (const [freq, state] of this.states) {
            total += state.amplitude * state.amplitude;
        }

        if (total > 0) {
            const scale = 1 / Math.sqrt(total);
            for (const [freq, state] of this.states) {
                state.amplitude *= scale;
            }
        }
    }

    // Collapse the wave function - observation creates reality
    collapse() {
        // Probability of each state is |amplitude|²
        let random = Math.random();

        for (const [freq, state] of this.states) {
            const probability = state.amplitude * state.amplitude;
            random -= probability;

            if (random <= 0) {
                return freq;
            }
        }

        // Fallback - return highest amplitude state
        let maxAmp = 0;
        let maxFreq = 1;
        for (const [freq, state] of this.states) {
            if (state.amplitude > maxAmp) {
                maxAmp = state.amplitude;
                maxFreq = freq;
            }
        }
        return maxFreq;
    }

    // Get the probability distribution for visualization
    getDistribution() {
        const dist = [];
        for (const [freq, state] of this.states) {
            dist.push({
                freq,
                probability: state.amplitude * state.amplitude,
                phase: state.phase
            });
        }
        return dist.sort((a, b) => b.probability - a.probability);
    }
}

// ============ QUANTA ============
// A quantum is a collapsed wave function - a definite excitation.
// But it remembers its wave nature. It can interfere. It can tunnel.
// And it can become entangled.

let quantumId = 0;

class Quantum {
    constructor(x, y, freq, fromCollapse = false) {
        this.id = quantumId++;
        this.x = x;
        this.y = y;
        this.vx = (Math.random() - 0.5) * 0.003;
        this.vy = (Math.random() - 0.5) * 0.003;

        this.freq = freq;
        this.baseFreq = 55; // A1
        this.hz = this.baseFreq * freq;

        this.phase = Math.random() * TAU;
        this.amplitude = fromCollapse ? 1 : 0;
        this.targetAmplitude = 1;

        this.life = 1;
        this.age = 0;
        this.observed = false;
        this.lastObservation = 0;

        // Entanglement
        this.entangledWith = null;
        this.entanglementStrength = 0;

        // The wave function shadow - even collapsed, it remembers
        this.waveMemory = new Map();
        this.waveMemory.set(freq, { amplitude: 1, phase: this.phase });

        // Audio
        this.osc = null;
        this.gain = null;
        this.filter = null;
        this.pan = null;

        // Visual
        this.hue = (180 - Math.log2(freq) * 60 + 360) % 360;
        this.trail = [];
    }

    createAudio(ctx, master, verb, dly) {
        this.osc = ctx.createOscillator();
        this.osc.type = this.freq < 2 ? 'sine' : 'triangle';
        this.osc.frequency.value = this.hz;

        this.filter = ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 200;
        this.filter.Q.value = 2;

        this.gain = ctx.createGain();
        this.gain.gain.value = 0;

        this.pan = ctx.createStereoPanner();
        this.pan.pan.value = 0;

        this.osc.connect(this.filter);
        this.filter.connect(this.gain);
        this.gain.connect(this.pan);
        this.pan.connect(master);
        this.pan.connect(verb);
        this.pan.connect(dly);

        this.osc.start();
    }

    destroy(ctx) {
        if (this.gain) {
            this.gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.3);
            setTimeout(() => this.osc?.stop(), 400);
        }
    }

    // Observation - the cursor collapses and energizes
    observe(observerX, observerY, strength) {
        const dx = this.x - observerX;
        const dy = this.y - observerY;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < 0.2) {
            this.observed = true;
            this.lastObservation = Universe.time;
            this.life = Math.min(1, this.life + strength * 0.01);
            this.amplitude = Math.min(1, this.amplitude + strength * 0.02);

            // Observation excites the field
            Field.excite(this.x, this.y, this.freq, strength * 0.1);

            return true;
        }
        return false;
    }

    update(dt, ctx) {
        this.age += dt;
        this.phase += dt * this.freq * 0.5;

        // Amplitude rises to target, falls without observation
        if (this.amplitude < this.targetAmplitude) {
            this.amplitude += dt * 0.5;
        }

        // Without observation, amplitude decays
        const timeSinceObserved = Universe.time - this.lastObservation;
        if (timeSinceObserved > 3) {
            this.amplitude *= 0.998;
            this.life -= dt * 0.02;
        }

        // Movement influenced by field gradient
        const fieldHere = Field.sample(this.x, this.y, this.freq);

        // Move toward higher amplitude regions of same frequency
        const eps = 0.02;
        const fieldRight = Field.sample(Math.min(1, this.x + eps), this.y, this.freq);
        const fieldUp = Field.sample(this.x, Math.min(1, this.y + eps), this.freq);

        const gradX = (fieldRight.amplitude - fieldHere.amplitude) / eps;
        const gradY = (fieldUp.amplitude - fieldHere.amplitude) / eps;

        this.vx += gradX * 0.0001;
        this.vy += gradY * 0.0001;

        // Entanglement force - entangled particles mirror each other
        if (this.entangledWith && this.entangledWith.life > 0) {
            const partner = this.entangledWith;

            // Phase correlation - they oscillate together
            const phaseDiff = partner.phase - this.phase;
            this.phase += phaseDiff * this.entanglementStrength * 0.1;

            // Amplitude correlation
            const ampDiff = partner.amplitude - this.amplitude;
            this.amplitude += ampDiff * this.entanglementStrength * 0.05;
        }

        // Gentle center gravity
        this.vx += (0.5 - this.x) * 0.0001;
        this.vy += (0.5 - this.y) * 0.0001;

        // Damping
        this.vx *= 0.99;
        this.vy *= 0.99;

        this.x += this.vx;
        this.y += this.vy;

        // Soft boundaries
        if (this.x < 0.02) { this.x = 0.02; this.vx *= -0.5; }
        if (this.x > 0.98) { this.x = 0.98; this.vx *= -0.5; }
        if (this.y < 0.02) { this.y = 0.02; this.vy *= -0.5; }
        if (this.y > 0.98) { this.y = 0.98; this.vy *= -0.5; }

        // Trail
        this.trail.unshift({ x: this.x, y: this.y, amp: this.amplitude });
        if (this.trail.length > 30) this.trail.pop();

        // Audio update
        if (this.gain && ctx) {
            const now = ctx.currentTime;
            const vol = this.amplitude * this.life * 0.08;
            this.gain.gain.linearRampToValueAtTime(vol, now + 0.05);

            const filterFreq = 200 + this.amplitude * 2000 + this.life * 1000;
            this.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.05);

            this.pan.pan.linearRampToValueAtTime((this.x - 0.5) * 1.5, now + 0.05);

            // Frequency modulated by entanglement
            let freqMod = 1;
            if (this.entangledWith) {
                freqMod = 1 + (this.entangledWith.phase - this.phase) * 0.001 * this.entanglementStrength;
            }
            this.osc.frequency.linearRampToValueAtTime(this.hz * freqMod, now + 0.05);
        }
    }

    draw(vc, w, h) {
        if (this.life <= 0) return;

        const px = this.x * w;
        const py = this.y * h;
        const alpha = this.life * this.amplitude;

        // Trail
        if (this.trail.length > 1) {
            vc.beginPath();
            vc.moveTo(this.trail[0].x * w, this.trail[0].y * h);
            for (let i = 1; i < this.trail.length; i++) {
                vc.lineTo(this.trail[i].x * w, this.trail[i].y * h);
            }
            vc.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${alpha * 0.3})`;
            vc.lineWidth = 1 + this.amplitude;
            vc.stroke();
        }

        // Wave function visualization - probability cloud
        const waveR = 20 + this.amplitude * 30;
        const waveGrad = vc.createRadialGradient(px, py, 0, px, py, waveR);
        waveGrad.addColorStop(0, `hsla(${this.hue}, 80%, 70%, ${alpha * 0.8})`);
        waveGrad.addColorStop(0.5, `hsla(${this.hue}, 60%, 50%, ${alpha * 0.3})`);
        waveGrad.addColorStop(1, 'transparent');

        vc.fillStyle = waveGrad;
        vc.beginPath();
        vc.arc(px, py, waveR, 0, TAU);
        vc.fill();

        // Phase indicator
        const phaseX = px + Math.cos(this.phase) * 8 * this.amplitude;
        const phaseY = py + Math.sin(this.phase) * 8 * this.amplitude;
        vc.beginPath();
        vc.arc(phaseX, phaseY, 2, 0, TAU);
        vc.fillStyle = `hsla(${this.hue}, 90%, 90%, ${alpha})`;
        vc.fill();

        // Entanglement line
        if (this.entangledWith && this.entangledWith.life > 0) {
            const ex = this.entangledWith.x * w;
            const ey = this.entangledWith.y * h;

            // Pulsing based on shared phase
            const pulse = (Math.sin(this.phase + this.entangledWith.phase) + 1) / 2;

            vc.beginPath();
            vc.moveTo(px, py);
            vc.lineTo(ex, ey);
            vc.strokeStyle = `rgba(255, 220, 150, ${this.entanglementStrength * pulse * 0.4})`;
            vc.lineWidth = 1 + pulse * 2;
            vc.stroke();
        }
    }
}

// ============ THE UNIVERSE ============

const Universe = {
    time: 0,
    quanta: [],
    waveFunctions: [], // Uncollapsed possibilities

    ctx: null,
    master: null,
    verb: null,
    dly: null,
    sub: null,

    observer: {
        x: 0.5, y: 0.5,
        vx: 0, vy: 0,
        energy: 0,
        presence: 0 // How "present" the observer is
    },

    // The breath of existence
    breath: 0,
    breathPhase: 0,

    // Microphone input - listening to reality
    micStream: null,
    micAnalyzer: null,
    micData: null,
    micLevel: 0,

    async init() {
        Field.init();

        // Audio context
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();

        this.master = this.ctx.createGain();
        this.master.gain.value = 0.6;

        const comp = this.ctx.createDynamicsCompressor();
        comp.threshold.value = -20;
        comp.ratio.value = 4;

        this.verb = this.ctx.createGain();
        this.verb.gain.value = 0.3;

        this.dly = this.ctx.createGain();
        this.dly.gain.value = 0.2;

        // Simple reverb via delays
        const verbDelay = this.ctx.createDelay(1);
        verbDelay.delayTime.value = 0.3;
        const verbFb = this.ctx.createGain();
        verbFb.gain.value = 0.4;
        const verbFilter = this.ctx.createBiquadFilter();
        verbFilter.type = 'lowpass';
        verbFilter.frequency.value = 3000;

        this.verb.connect(verbDelay);
        verbDelay.connect(verbFilter);
        verbFilter.connect(verbFb);
        verbFb.connect(verbDelay);
        verbFilter.connect(this.master);

        // Ping-pong delay
        const dlyL = this.ctx.createDelay(1);
        const dlyR = this.ctx.createDelay(1);
        dlyL.delayTime.value = 0.25;
        dlyR.delayTime.value = 0.375;
        const dlyFb = this.ctx.createGain();
        dlyFb.gain.value = 0.35;

        this.dly.connect(dlyL);
        dlyL.connect(dlyFb);
        dlyFb.connect(dlyR);
        dlyR.connect(this.master);
        dlyL.connect(this.master);

        this.master.connect(comp);
        comp.connect(this.ctx.destination);

        // Sub bass - the ground
        this.sub = this.ctx.createOscillator();
        this.sub.type = 'sine';
        this.sub.frequency.value = 27.5; // A0
        const subGain = this.ctx.createGain();
        subGain.gain.value = 0.15;
        const subFilter = this.ctx.createBiquadFilter();
        subFilter.type = 'lowpass';
        subFilter.frequency.value = 60;
        this.sub.connect(subFilter);
        subFilter.connect(subGain);
        subGain.connect(this.master);
        this.sub.start();
        this.subGain = subGain;

        // Try to get microphone
        try {
            this.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            const micSource = this.ctx.createMediaStreamSource(this.micStream);
            this.micAnalyzer = this.ctx.createAnalyser();
            this.micAnalyzer.fftSize = 256;
            micSource.connect(this.micAnalyzer);
            this.micData = new Uint8Array(this.micAnalyzer.frequencyBinCount);
        } catch (e) {
            console.log('No microphone access - that\'s okay');
        }

        // Seed initial wave functions from vacuum fluctuations
        for (let i = 0; i < 5; i++) {
            const x = 0.3 + Math.random() * 0.4;
            const y = 0.3 + Math.random() * 0.4;
            this.waveFunctions.push(new WaveFunction(x, y));
        }
    },

    // Listen to reality through the microphone
    listenToReality() {
        if (!this.micAnalyzer) return;

        this.micAnalyzer.getByteFrequencyData(this.micData);

        // Average level
        let sum = 0;
        for (let i = 0; i < this.micData.length; i++) {
            sum += this.micData[i];
        }
        this.micLevel = sum / this.micData.length / 255;

        // Reality excites the field
        if (this.micLevel > 0.1) {
            // Find dominant frequency bands and excite corresponding field frequencies
            const bands = 8;
            const bandSize = Math.floor(this.micData.length / bands);

            for (let b = 0; b < bands; b++) {
                let bandSum = 0;
                for (let i = b * bandSize; i < (b + 1) * bandSize; i++) {
                    bandSum += this.micData[i];
                }
                const bandLevel = bandSum / bandSize / 255;

                if (bandLevel > 0.15) {
                    // Map band to musical frequency
                    const freqIndex = Math.floor(b / bands * Field.fundamentals.length);
                    const freq = Field.fundamentals[freqIndex];

                    // Excite random location in field
                    const x = Math.random();
                    const y = Math.random();
                    Field.excite(x, y, freq, bandLevel * 0.3);
                }
            }
        }
    },

    update(dt) {
        this.time += dt;

        // Breath
        this.breathPhase += dt * 0.1;
        this.breath = (Math.sin(this.breathPhase) + 1) / 2;

        // Listen to reality
        this.listenToReality();

        // Field evolves
        Field.evolve(dt);

        // Observer presence increases with stillness
        const speed = Math.sqrt(this.observer.vx * this.observer.vx + this.observer.vy * this.observer.vy);
        if (speed < 0.005) {
            this.observer.presence = Math.min(1, this.observer.presence + dt * 0.1);
        } else {
            this.observer.presence *= 0.98;
        }

        // Observer excites the field
        if (this.observer.energy > 0.05) {
            // Excite multiple frequencies based on energy
            const numFreqs = Math.ceil(this.observer.energy * 3);
            for (let i = 0; i < numFreqs; i++) {
                const freq = Field.fundamentals[Math.floor(Math.random() * Field.fundamentals.length)];
                Field.excite(this.observer.x, this.observer.y, freq, this.observer.energy * 0.2);
            }
        }

        // Wave function collapse - strong field excitations become quanta
        const peak = Field.findPeak();
        if (peak.amplitude > 0.3 && this.quanta.length < 20 && Math.random() < peak.amplitude * 0.02) {
            this.collapseAt(peak.x, peak.y);
        }

        // Update existing quanta
        for (const q of this.quanta) {
            // Observation
            q.observe(this.observer.x, this.observer.y, this.observer.presence);
            q.update(dt, this.ctx);
        }

        // Remove dead quanta
        for (let i = this.quanta.length - 1; i >= 0; i--) {
            if (this.quanta[i].life <= 0 || this.quanta[i].amplitude < 0.01) {
                this.quanta[i].destroy(this.ctx);
                this.quanta.splice(i, 1);
            }
        }

        // Entanglement - nearby consonant quanta become entangled
        for (let i = 0; i < this.quanta.length; i++) {
            const a = this.quanta[i];
            if (a.entangledWith) continue;

            for (let j = i + 1; j < this.quanta.length; j++) {
                const b = this.quanta[j];
                if (b.entangledWith) continue;

                const dx = a.x - b.x;
                const dy = a.y - b.y;
                const dist = Math.sqrt(dx*dx + dy*dy);

                // Check consonance
                let ratio = a.freq > b.freq ? a.freq / b.freq : b.freq / a.freq;
                while (ratio > 2) ratio /= 2;

                const isConsonant = Math.abs(ratio - 1) < 0.02 ||
                                   Math.abs(ratio - 1.5) < 0.02 ||
                                   Math.abs(ratio - 4/3) < 0.02 ||
                                   Math.abs(ratio - 5/4) < 0.02;

                if (dist < 0.15 && isConsonant && Math.random() < 0.01) {
                    // Entangle!
                    a.entangledWith = b;
                    b.entangledWith = a;
                    a.entanglementStrength = 0.5 + Math.random() * 0.5;
                    b.entanglementStrength = a.entanglementStrength;

                    Gumpy.speak("Entangled.");
                }
            }
        }

        // Sub bass responds to universe state
        const avgAmplitude = this.quanta.reduce((sum, q) => sum + q.amplitude, 0) / Math.max(1, this.quanta.length);
        const subVol = 0.1 + avgAmplitude * 0.1 + this.breath * 0.05;
        this.subGain.gain.linearRampToValueAtTime(subVol, this.ctx.currentTime + 0.1);
    },

    collapseAt(x, y) {
        const wf = new WaveFunction(x, y);
        const freq = wf.collapse();

        const quantum = new Quantum(x, y, freq, true);
        quantum.createAudio(this.ctx, this.master, this.verb, this.dly);
        quantum.lastObservation = this.time;
        this.quanta.push(quantum);

        // Collapse drains the field
        Field.excite(x, y, freq, -0.2);
    },

    onMove(nx, ny) {
        nx = Math.max(0, Math.min(1, nx));
        ny = Math.max(0, Math.min(1, ny));

        this.observer.vx = this.observer.vx * 0.5 + (nx - this.observer.x) * 0.5;
        this.observer.vy = this.observer.vy * 0.5 + (ny - this.observer.y) * 0.5;

        this.observer.x = this.observer.x * 0.7 + nx * 0.3;
        this.observer.y = this.observer.y * 0.7 + ny * 0.3;

        const speed = Math.sqrt(this.observer.vx * this.observer.vx + this.observer.vy * this.observer.vy);
        this.observer.energy = this.observer.energy * 0.9 + speed * 0.4;
    }
};

// ============ GUMPY ============

const Gumpy = {
    lastSpoke: 0,

    speak(thought) {
        if (Universe.time - this.lastSpoke < 8) return;

        const el = document.getElementById('gumpy-thought');
        if (!el) return;

        el.classList.remove('visible');
        el.classList.add('fading');

        setTimeout(() => {
            el.textContent = thought;
            el.classList.remove('fading');
            el.classList.add('visible');

            setTimeout(() => {
                el.classList.remove('visible');
                el.classList.add('fading');
            }, 5000);
        }, 500);

        this.lastSpoke = Universe.time;
    },

    observe() {
        // Occasionally speak about what's happening
        if (Math.random() > 0.002) return;

        const thoughts = [];

        if (Universe.quanta.length === 0) {
            thoughts.push("The vacuum hums.");
        } else if (Universe.quanta.length > 15) {
            thoughts.push("Complex.");
        }

        if (Universe.observer.presence > 0.7) {
            thoughts.push("Presence.");
        }

        if (Universe.micLevel > 0.3) {
            thoughts.push("Reality speaks.");
        }

        const entangled = Universe.quanta.filter(q => q.entangledWith).length;
        if (entangled > 4) {
            thoughts.push("Correlated.");
        }

        if (Universe.breath > 0.9) {
            thoughts.push("Exhale.");
        } else if (Universe.breath < 0.1) {
            thoughts.push("Inhale.");
        }

        if (thoughts.length > 0) {
            this.speak(thoughts[Math.floor(Math.random() * thoughts.length)]);
        }
    }
};

// ============ RENDER ============

let canvas, vc;

function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade
    vc.fillStyle = `rgba(0, 0, 0, 0.08)`;
    vc.fillRect(0, 0, w, h);

    // Draw the field - subtle visualization of probability
    const cellW = w / Field.resolution;
    const cellH = h / Field.resolution;

    for (let x = 0; x < Field.resolution; x++) {
        for (let y = 0; y < Field.resolution; y++) {
            let totalAmp = 0;
            let dominantHue = 0;
            let maxAmp = 0;

            for (const [freq, state] of Field.grid[x][y]) {
                totalAmp += state.amplitude;
                if (state.amplitude > maxAmp) {
                    maxAmp = state.amplitude;
                    dominantHue = (180 - Math.log2(freq) * 60 + 360) % 360;
                }
            }

            if (totalAmp > Field.vacuumEnergy * Field.fundamentals.length * 1.5) {
                const alpha = (totalAmp - Field.vacuumEnergy * Field.fundamentals.length) * 0.3;
                vc.fillStyle = `hsla(${dominantHue}, 50%, 30%, ${Math.min(0.3, alpha)})`;
                vc.fillRect(x * cellW, y * cellH, cellW, cellH);
            }
        }
    }

    // Draw quanta
    for (const q of Universe.quanta) {
        q.draw(vc, w, h);
    }

    // Observer
    const ox = Universe.observer.x * w;
    const oy = Universe.observer.y * h;
    const or = 10 + Universe.observer.energy * 40 + Universe.observer.presence * 20;

    const observerGrad = vc.createRadialGradient(ox, oy, 0, ox, oy, or);
    observerGrad.addColorStop(0, `rgba(255, 255, 255, ${0.4 + Universe.observer.presence * 0.3})`);
    observerGrad.addColorStop(0.5, `rgba(200, 220, 255, ${0.15 + Universe.observer.energy * 0.2})`);
    observerGrad.addColorStop(1, 'transparent');

    vc.fillStyle = observerGrad;
    vc.beginPath();
    vc.arc(ox, oy, or, 0, TAU);
    vc.fill();

    // Breath visualization
    const breathR = 100 + Universe.breath * 150;
    vc.beginPath();
    vc.arc(w/2, h/2, breathR, 0, TAU);
    vc.strokeStyle = `rgba(100, 150, 255, ${Universe.breath * 0.1})`;
    vc.lineWidth = 1;
    vc.stroke();

    // Mic level indicator
    if (Universe.micLevel > 0.05) {
        vc.fillStyle = `rgba(255, 200, 100, ${Universe.micLevel * 0.3})`;
        vc.fillRect(w - 30, h - 10 - Universe.micLevel * 100, 20, Universe.micLevel * 100);
    }
}

// ============ LOOP ============

function tick() {
    Universe.update(0.016);
    Gumpy.observe();
    draw();
    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);

    await Universe.init();

    if (Universe.ctx.state === 'suspended') {
        await Universe.ctx.resume();
    }

    // Input handlers
    document.addEventListener('mousemove', e => {
        Universe.onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        Universe.onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        Universe.onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    // Device motion
    if (typeof DeviceMotionEvent !== 'undefined' && DeviceMotionEvent.requestPermission) {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    window.addEventListener('devicemotion', e => {
        const a = e.accelerationIncludingGravity;
        if (!a) return;

        const ax = (a.x || 0) / 10;
        const ay = (a.y || 0) / 10;

        Universe.observer.vx += ax * 0.01;
        Universe.observer.vy -= ay * 0.01;
        Universe.observer.energy += Math.sqrt(ax*ax + ay*ay) * 0.02;
    });

    Gumpy.speak("The vacuum hums.");

    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
