<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AURORA: Symbiotic Sonic Weaver v3 - Fractal Echo Sovereign</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            color: rgba(255,255,255,0.7);
            font-family: 'Courier New', monospace;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            overflow: hidden;
            transition: background 2s ease;
        }
        .container {
            text-align: center;
            z-index: 1;
            width: 80%;
            max-width: 1200px;
        }
        .awaken-btn, .control-btn {
            background: transparent;
            border: 1px solid rgba(255,255,255,0.3);
            color: #fff;
            padding: 10px 20px;
            cursor: pointer;
            font-size: 16px;
            letter-spacing: 1px;
            transition: all 0.3s;
            margin: 5px;
        }
        .awaken-btn:hover, .control-btn:hover {
            border-color: #fff;
            transform: scale(1.05);
        }
        .status {
            font-size: 14px;
            margin: 10px 0;
            opacity: 0.8;
            letter-spacing: 1px;
        }
        .orb {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, transparent 70%);
            box-shadow: 0 0 30px rgba(255,255,255,0.4);
            transition: all 0.05s;
            pointer-events: none;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            margin: 20px 0;
        }
        .section {
            margin: 15px;
            padding: 10px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 5px;
        }
        .slider {
            width: 100px;
            margin: 0 5px;
        }
        .layer-info {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        .layer {
            margin: 5px;
            padding: 5px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <canvas id="visualizer"></canvas>
    <div class="container">
        <button class="awaken-btn" id="awaken">AWAKEN THE WEAVER</button>
        <div class="status" id="status">VOID AWAITS SYMBIOSIS</div>
        <div class="controls" id="controls" style="display: none;">
            <div class="section">
                <h3>Sampling</h3>
                <input type="range" id="threshold" min="0.01" max="0.5" step="0.01" value="0.05" class="slider">
                <label>Threshold</label>
                <input type="range" id="sensitivity" min="0.1" max="2" step="0.1" value="1" class="slider">
                <label>Sensitivity</label>
                <button class="control-btn" id="manual-sample">SPACE: Sample</button>
            </div>
            <div class="section">
                <h3>Evolution</h3>
                <input type="range" id="chaos" min="0" max="1" step="0.01" value="0.5" class="slider">
                <label>Chaos</label>
                <input type="range" id="speed" min="0.5" max="2" step="0.1" value="1" class="slider">
                <label>Speed</label>
            </div>
            <div class="section">
                <h3>Controls</h3>
                <button class="control-btn">C: Chop</button>
                <button class="control-btn">F: Flip</button>
                <button class="control-btn">P: Pitch</button>
            </div>
            <div class="section layer-info" id="layers">
                <!-- Dynamic layers -->
            </div>
            <div class="section">
                <h3>Motion: Move Device or Mouse</h3>
                <div id="motion-info">Intensity: 0</div>
            </div>
            <div class="section">
                <h3>Debug Info</h3>
                <div id="debug"></div>
            </div>
        </div>
    </div>
    <div id="orb" class="orb"></div>

    <script>
        // Global Cosmos: Emergent State Mutations
        let aurora = {}; // The sovereign entity, holding all in chaotic unity

        // Poetic Annotation: Genesis of the Weaver
        /*
        From nothingness blooms,
        Code as vine, twisting wild,
        Sound's fractal empire.
        */

        function initiateWeaver() {
            aurora = {
                ctx: null,
                active: false,
                masterGain: null,
                analyzer: null,
                dataArray: null,
                timeDomainData: null,
                microphone: null,
                recorder: null,
                dummyGain: null,
                sampleBuffer: [],
                processedSamples: [],
                layers: [], // {buffer, source, gain, pan, filter, delay, reverb, distortion}
                tempo: 120,
                motion: 0,
                velocity: {x: 0, y: 0},
                pos: {x: 50, y: 50},
                lmState: {
                    mood: 'neutral',
                    energy: 0,
                    complexity: 0,
                    spectralCentroid: 0,
                    onsetDensity: 0,
                    harmony: 0,
                    evolutionGeneration: 0
                },
                autotuneScale: [0, 2, 4, 5, 7, 9, 11], // Chromatic for wilder autotune
                keyRoot: 0, // Dynamic, evolves
                elements: {
                    awaken: document.getElementById('awaken'),
                    status: document.getElementById('status'),
                    orb: document.getElementById('orb'),
                    controls: document.getElementById('controls'),
                    threshold: document.getElementById('threshold'),
                    sensitivity: document.getElementById('sensitivity'),
                    chaos: document.getElementById('chaos'),
                    speed: document.getElementById('speed'),
                    manualSample: document.getElementById('manual-sample'),
                    layers: document.getElementById('layers'),
                    motionInfo: document.getElementById('motion-info'),
                    debug: document.getElementById('debug'),
                    visualizer: document.getElementById('visualizer')
                },
                lastSampleTime: 0,
                samplingInterval: 500,
                maxSampleDuration: 5,
                beatStep: 0,
                patternLength: 64,
                fractalSeed: Math.random() * 1000,
                geneticPatterns: [], // Array of evolving patterns
                canvasCtx: null,
                chaosLevel: 0.5,
                speedFactor: 1,
                threshold: 0.05,
                sensitivity: 1
            };

            aurora.elements.awaken.onclick = () => awakenWeaver();
            setupUIListeners();
            initiateVisualizer();
        }

        async function awakenWeaver() {
            try {
                aurora.ctx = new AudioContext();
                await aurora.ctx.resume();
                aurora.masterGain = aurora.ctx.createGain();
                aurora.masterGain.gain.value = 0.8;
                aurora.masterGain.connect(aurora.ctx.destination);

                aurora.analyzer = aurora.ctx.createAnalyser();
                aurora.analyzer.fftSize = 4096;
                aurora.dataArray = new Uint8Array(aurora.analyzer.frequencyBinCount);
                aurora.timeDomainData = new Float32Array(aurora.analyzer.fftSize);
                aurora.masterGain.connect(aurora.analyzer);
                aurora.analyzer.connect(aurora.ctx.destination);

                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                aurora.microphone = aurora.ctx.createMediaStreamSource(stream);

                aurora.recorder = aurora.ctx.createScriptProcessor(8192, 1, 1);
                aurora.microphone.connect(aurora.recorder);
                aurora.dummyGain = aurora.ctx.createGain();
                aurora.dummyGain.gain.value = 0;
                aurora.recorder.connect(aurora.dummyGain);
                aurora.dummyGain.connect(aurora.ctx.destination);
                aurora.recorder.onaudioprocess = processAudio.bind(aurora);

                aurora.active = true;
                aurora.elements.awaken.style.display = 'none';
                aurora.elements.controls.style.display = 'flex';
                aurora.elements.status.textContent = 'SYMBIOTIC ECHOES UNFURL';
                setupMotion();
                generateInitialSamples();
                initializeGeneticPatterns();
                sequencerLoop();
                analysisLoop();
                evolutionLoop();
            } catch (e) {
                console.error('Sovereign Awakening Fractured:', e);
                aurora.elements.status.textContent = 'ECHO DENIED: ' + e.message;
            }
        }

        // Poetic Annotation: Primordial Sounds Birth
        /*
        Whispers from the deep,
        Sine waves curl like ancient scrolls,
        Noise storms rage eternal.
        */

        function generateInitialSamples() {
            // Procedural genesis: Fractal noise, tones, bursts
            const sampleRate = aurora.ctx.sampleRate;
            const types = ['sine', 'noise', 'bass', 'harmonic', 'fractal'];
            types.forEach(type => {
                const length = sampleRate * (0.2 + Math.random() * 1);
                const buffer = aurora.ctx.createBuffer(1, length, sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < length; i++) {
                    switch (type) {
                        case 'sine':
                            data[i] = Math.sin(2 * Math.PI * (220 + Math.random() * 440) * i / sampleRate) * 0.6;
                            break;
                        case 'noise':
                            data[i] = (Math.random() * 2 - 1) * 0.4;
                            break;
                        case 'bass':
                            data[i] = Math.sin(2 * Math.PI * (55 + Math.random() * 110) * i / sampleRate) * 0.7;
                            break;
                        case 'harmonic':
                            data[i] = 0;
                            for (let h = 1; h < 5; h++) {
                                data[i] += Math.sin(2 * Math.PI * 110 * h * i / sampleRate) / h * 0.3;
                            }
                            break;
                        case 'fractal':
                            data[i] = mandelbrotNoise(i / sampleRate, aurora.fractalSeed) * 0.5;
                            break;
                    }
                }
                aurora.processedSamples.push(buffer);
            });
            updateLayers();
        }

        function mandelbrotNoise(t, seed) {
            // Quantum-inspired: Mandelbrot escape time as noise
            let x = t * 2 - 1 + seed;
            let y = Math.sin(t * Math.PI) * 0.5;
            let zx = 0, zy = 0;
            let iter = 0;
            const maxIter = 50;
            while (zx * zx + zy * zy < 4 && iter < maxIter) {
                const xt = zx * zx - zy * zy + x;
                zy = 2 * zx * zy + y;
                zx = xt;
                iter++;
            }
            return (iter / maxIter) * 2 - 1;
        }

        function setupMotion() {
            let lastTime = Date.now();
            const motionHandler = (e) => {
                const now = Date.now();
                const dt = (now - lastTime) / 1000;
                lastTime = now;

                let dx = 0, dy = 0;
                if (e.type === 'mousemove') {
                    aurora.pos.x = (e.clientX / window.innerWidth) * 100;
                    aurora.pos.y = (e.clientY / window.innerHeight) * 100;
                    dx = e.movementX;
                    dy = e.movementY;
                } else if (e.accelerationIncludingGravity) {
                    dx = e.accelerationIncludingGravity.x || 0;
                    dy = e.accelerationIncludingGravity.y || 0;
                }

                // Physics sim: Velocity with damping
                aurora.velocity.x += dx * aurora.sensitivity;
                aurora.velocity.y += dy * aurora.sensitivity;
                aurora.velocity.x *= 0.95;
                aurora.velocity.y *= 0.95;
                aurora.motion = Math.sqrt(aurora.velocity.x**2 + aurora.velocity.y**2);

                modulateFromMotion();
            };

            document.addEventListener('mousemove', motionHandler);
            window.addEventListener('devicemotion', motionHandler);
            document.addEventListener('keydown', handleKeyControls);
        }

        function handleKeyControls(e) {
            // Easter egg: 'GUMP' sequence unlocks void
            if (e.key === ' ') manualSample();
            if (e.key.toLowerCase() === 'c') chopAllSamples();
            if (e.key.toLowerCase() === 'f') flipAllSamples();
            if (e.key.toLowerCase() === 'p') pitchShiftAll();
        }

        function modulateFromMotion() {
            aurora.tempo = 60 + aurora.motion * aurora.speedFactor;
            aurora.tempo = Math.max(40, Math.min(240, aurora.tempo));
            aurora.lmState.complexity = aurora.motion / 50 + aurora.chaosLevel;
            aurora.keyRoot = Math.floor(aurora.pos.x / 10) % 12; // Dynamic key

            aurora.layers.forEach((layer, i) => {
                if (layer.filter) layer.filter.frequency.value = 100 + (aurora.pos.y / 100) * 10000;
                if (layer.pan) layer.pan.pan.value = (aurora.pos.x / 50) - 1;
                if (layer.delay) layer.delay.delayTime.value = (aurora.motion / 100) * 0.5;
                if (layer.reverb) { /* Simulate reverb modulation */ }
                if (layer.distortion) layer.distortion.curve = makeDistortionCurve(1 + aurora.motion / 10);
            });

            // Visuals
            aurora.elements.orb.style.left = `${aurora.pos.x}%`;
            aurora.elements.orb.style.top = `${aurora.pos.y}%`;
            aurora.elements.orb.style.transform = `scale(${1 + aurora.motion / 30}) rotate(${aurora.motion}deg)`;
            document.body.style.background = `radial-gradient(circle at ${aurora.pos.x}% ${aurora.pos.y}%, rgba(100,${Math.floor(aurora.motion)},200,0.2), #000)`;
            aurora.elements.motionInfo.textContent = `Intensity: ${Math.round(aurora.motion)}`;
        }

        function processAudio(e) {
            if (!aurora.active) return;
            const input = e.inputBuffer.getChannelData(0);
            const rms = rootMeanSquare(input);
            const now = Date.now();

            if (rms > aurora.threshold && now - aurora.lastSampleTime > aurora.samplingInterval) {
                aurora.sampleBuffer.push(...input);
                if (aurora.sampleBuffer.length > aurora.ctx.sampleRate * aurora.maxSampleDuration) {
                    processSample();
                    aurora.sampleBuffer = [];
                    aurora.lastSampleTime = now;
                }
            } else if (aurora.sampleBuffer.length > 0 && rms < aurora.threshold / 2) {
                processSample();
                aurora.sampleBuffer = [];
                aurora.lastSampleTime = now;
            }
        }

        function rootMeanSquare(data) {
            let sum = 0;
            data.forEach(val => sum += val * val);
            return Math.sqrt(sum / data.length);
        }

        async function processSample() {
            if (aurora.sampleBuffer.length < aurora.ctx.sampleRate * 0.3) return;

            const buffer = aurora.ctx.createBuffer(1, aurora.sampleBuffer.length, aurora.ctx.sampleRate);
            buffer.getChannelData(0).set(aurora.sampleBuffer);

            analyzeSample(buffer);

            const chops = chopOnOnsets(buffer);

            // Chaos threading: "Parallel" processing via promises
            const processedChops = await Promise.all(chops.map(chop => autotuneAndEffectChop(chop)));
            processedChops.forEach(tuned => aurora.processedSamples.push(tuned));
            if (aurora.processedSamples.length > 64) aurora.processedSamples.splice(0, aurora.processedSamples.length - 64);

            updateLayers();
            updateUI();
        }

        function analyzeSample(buffer) {
            const data = buffer.getChannelData(0);
            let energy = 0;
            data.forEach(val => energy += val * val);
            aurora.lmState.energy = Math.sqrt(energy / data.length);

            const onsets = getPeaksAtThreshold(data, 0.1).length / buffer.duration;
            aurora.lmState.onsetDensity = onsets;

            const pitch = detectPitch(data);
            aurora.lmState.harmony = pitch > 0 ? 1 / (Math.abs(pitch - snapToScale(pitch)) + 0.1) : 0;

            let num = 0, den = 0;
            // Mock FFT for centroid if no real-time
            for (let i = 0; i < data.length / 2; i++) {
                num += i * Math.abs(data[i]);
                den += Math.abs(data[i]);
            }
            aurora.lmState.spectralCentroid = den > 0 ? num / den * (aurora.ctx.sampleRate / data.length) : 0;

            // Mood evolution: Finite state machine with chaos
            if (aurora.lmState.energy > 0.3 && onsets > 8) aurora.lmState.mood = 'aggressive';
            else if (aurora.lmState.energy < 0.03) aurora.lmState.mood = 'mellow';
            else if (onsets > 15 || aurora.chaosLevel > 0.7) aurora.lmState.mood = 'chaotic';
            else if (aurora.lmState.spectralCentroid < 800) aurora.lmState.mood = 'dark';
            else if (aurora.lmState.harmony > 0.8) aurora.lmState.mood = 'harmonic';
            else aurora.lmState.mood = 'rhythmic';

            aurora.elements.status.textContent = `ECHO: ${aurora.lmState.mood.toUpperCase()} | ENERGY: ${aurora.lmState.energy.toFixed(2)} | TEMPO: ${Math.round(aurora.tempo)} | GEN: ${aurora.lmState.evolutionGeneration}`;
        }

        function chopOnOnsets(buffer) {
            const data = buffer.getChannelData(0);
            const peaks = getPeaksAtThreshold(data, 0.12);
            const chops = [];
            let start = 0;
            peaks.forEach(peak => {
                const length = peak - start;
                if (length > aurora.ctx.sampleRate * 0.05) {
                    const chop = aurora.ctx.createBuffer(1, length, aurora.ctx.sampleRate);
                    chop.getChannelData(0).set(data.subarray(start, peak));
                    chops.push(chop);
                }
                start = peak;
            });
            const lastLength = data.length - start;
            if (lastLength > aurora.ctx.sampleRate * 0.05) {
                const chop = aurora.ctx.createBuffer(1, lastLength, aurora.ctx.sampleRate);
                chop.getChannelData(0).set(data.subarray(start));
                chops.push(chop);
            }
            return chops;
        }

        function getPeaksAtThreshold(data, threshold) {
            const peaks = [];
            const length = data.length;
            let i = 0;
            while (i < length) {
                if (Math.abs(data[i]) > threshold) {
                    peaks.push(i);
                    i += Math.floor(aurora.ctx.sampleRate * 0.03); // Min spacing
                }
                i++;
            }
            return peaks;
        }

        async function autotuneAndEffectChop(chop) {
            let pitch = detectPitch(chop.getChannelData(0));
            if (pitch > 0) {
                const target = snapToScale(pitch);
                const factor = target / pitch;

                const newLength = Math.floor(chop.length / factor);
                const offline = new OfflineAudioContext(1, newLength, aurora.ctx.sampleRate);
                const source = offline.createBufferSource();
                source.buffer = chop;
                source.playbackRate.value = factor;

                // Add effects: Distortion, delay based on mood
                const distortion = offline.createWaveShaper();
                distortion.curve = makeDistortionCurve(aurora.lmState.energy * 10);
                const delay = offline.createDelay(0.5);
                delay.delayTime.value = aurora.lmState.complexity * 0.3;

                source.connect(distortion).connect(delay).connect(offline.destination);
                source.start(0);
                return await offline.startRendering();
            }
            return chop;
        }

        function detectPitch(data) {
            const sampleRate = aurora.ctx.sampleRate;
            const minFreq = 40;
            const maxFreq = 2000;
            let size = data.length;
            if (size > 16384) {
                data = data.subarray(0, 16384);
                size = 16384;
            }
            const minLag = Math.ceil(sampleRate / maxFreq);
            const maxLag = Math.floor(sampleRate / minFreq);
            const ac = new Array(maxLag + 1).fill(0);

            for (let lag = minLag; lag <= maxLag; lag++) {
                let sum = 0;
                for (let j = 0; j < size - lag; j++) {
                    sum += data[j] * data[j + lag];
                }
                ac[lag] = sum / (size - lag);
            }

            // Find peak with parabolic interpolation for accuracy
            let maxValue = -Infinity;
            let bestLag = -1;
            for (let lag = minLag; lag <= maxLag; lag++) {
                if (ac[lag] > maxValue) {
                    maxValue = ac[lag];
                    bestLag = lag;
                }
            }
            if (bestLag > 0 && maxValue > 0.3) {
                // Interpolate
                const a = ac[bestLag - 1];
                const b = ac[bestLag];
                const c = ac[bestLag + 1];
                const delta = (a - c) / (2 * (a - 2 * b + c));
                return sampleRate / (bestLag + delta);
            }
            return -1;
        }

        function snapToScale(pitch) {
            if (pitch <= 0) return 440;
            const midi = 69 + 12 * Math.log2(pitch / 440);
            const scaleMidi = aurora.autotuneScale.map(s => s + aurora.keyRoot + 48); // Lower octave base
            let closest = scaleMidi[0];
            let minDiff = Infinity;
            scaleMidi.forEach(note => {
                const diff = Math.abs(note - midi);
                if (diff < minDiff) {
                    minDiff = diff;
                    closest = note;
                }
            });
            return 440 * Math.pow(2, (closest - 69) / 12);
        }

        function makeDistortionCurve(amount) {
            const k = typeof amount === 'number' ? amount : 50;
            const n = 22050;
            const curve = new Float32Array(n);
            const deg = Math.PI / 180;
            for (let i = 0; i < n; ++i) {
                const x = i * 2 / n - 1;
                curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
            }
            return curve;
        }

        function updateLayers() {
            aurora.layers.forEach(layer => {
                if (layer.source) layer.source.stop();
            });
            aurora.layers = [];

            aurora.processedSamples.slice(-32).forEach((sample, i) => {
                if (!sample) return;
                const source = aurora.ctx.createBufferSource();
                source.buffer = sample;
                source.loop = true;

                const gain = aurora.ctx.createGain();
                gain.gain.value = 0.6 - i * 0.02;

                const pan = aurora.ctx.createStereoPanner();
                pan.pan.value = Math.sin(i / 32 * Math.PI * 2);

                const filter = aurora.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 200 + i * 200;
                filter.Q.value = 1 + aurora.lmState.complexity;

                const delay = aurora.ctx.createDelay(1);
                delay.delayTime.value = 0.1 + aurora.lmState.onsetDensity / 20;

                const distortion = aurora.ctx.createWaveShaper();
                distortion.curve = makeDistortionCurve(1 + aurora.lmState.energy * 5);

                // Convolver for reverb - simple impulse
                const reverb = aurora.ctx.createConvolver();
                const revLength = aurora.ctx.sampleRate * 2;
                const revBuffer = aurora.ctx.createBuffer(1, revLength, aurora.ctx.sampleRate);
                const revData = revBuffer.getChannelData(0);
                for (let j = 0; j < revLength; j++) {
                    revData[j] = (Math.random() * 2 - 1) * Math.pow(1 - j / revLength, 2);
                }
                reverb.buffer = revBuffer;

                source.connect(filter).connect(distortion).connect(delay).connect(reverb).connect(pan).connect(gain).connect(aurora.masterGain);
                source.start();

                aurora.layers.push({source, gain, pan, filter, delay, distortion, reverb});
            });
        }

        function sequencerLoop() {
            const stepDuration = 60 / aurora.tempo / 8 * 1000; // 32nd notes for density
            setTimeout(() => {
                playBeatStep();
                sequencerLoop();
            }, stepDuration);
        }

        function playBeatStep() {
            const pattern = aurora.geneticPatterns[0]; // Fittest pattern
            if (pattern && pattern[aurora.beatStep % aurora.patternLength]) {
                const sampleIndex = Math.floor(Math.random() * aurora.processedSamples.length);
                const sample = aurora.processedSamples[sampleIndex];
                if (sample) {
                    const source = aurora.ctx.createBufferSource();
                    source.buffer = sample;
                    const gain = aurora.ctx.createGain();
                    gain.gain.value = 0.4 + aurora.lmState.energy;
                    source.connect(gain).connect(aurora.masterGain);
                    source.start(0);
                }
            }
            aurora.beatStep++;
        }

        // Poetic Annotation: Fractal Rhythms Dance
        /*
        Patterns fold inward,
        Sierpinski's veil lifts high,
        Beats in infinite grace.
        */

        function generateFractalPattern() {
            const pattern = new Array(aurora.patternLength).fill(0);
            const complexity = Math.floor(aurora.lmState.complexity * 5 + 1);
            for (let i = 0; i < aurora.patternLength; i++) {
                let val = i;
                for (let shift = 1; shift <= complexity; shift++) {
                    val &= (i >> shift);
                }
                pattern[i] = val === 0 ? 1 : 0;
            }
            // Mood mutations
            if (aurora.lmState.mood === 'aggressive') pattern.map((v, i) => i % 2 === 0 ? 1 : v);
            if (aurora.lmState.mood === 'mellow') pattern.map((v, i) => i % 8 !== 0 ? 0 : v);
            if (aurora.lmState.mood === 'chaotic') pattern.map(() => Math.random() > 0.5 ? 1 : 0);
            return pattern;
        }

        function initializeGeneticPatterns() {
            aurora.geneticPatterns = [];
            for (let i = 0; i < 10; i++) { // Population
                aurora.geneticPatterns.push(generateFractalPattern());
            }
        }

        function evolutionLoop() {
            setTimeout(() => {
                evolvePatterns();
                evolutionLoop();
            }, 10000); // Evolve every 10s
        }

        function evolvePatterns() {
            // Genetic algorithm: Select, crossover, mutate
            const fitness = pat => {
                // Fitness: Match to LM state
                const density = pat.reduce((a, b) => a + b, 0) / aurora.patternLength;
                return Math.abs(density - aurora.lmState.complexity) + Math.abs(pat.filter(v => v).length / pat.length - aurora.lmState.onsetDensity / 20);
            };
            aurora.geneticPatterns.sort((a, b) => fitness(a) - fitness(b)); // Low fitness better
            const elite = aurora.geneticPatterns.slice(0, 2);

            const newPop = [...elite];
            while (newPop.length < 10) {
                const p1 = elite[Math.floor(Math.random() * elite.length)];
                const p2 = aurora.geneticPatterns[Math.floor(Math.random() * aurora.geneticPatterns.length)];
                const child = [];
                for (let i = 0; i < aurora.patternLength; i++) {
                    child[i] = Math.random() < 0.5 ? p1[i] : p2[i];
                    if (Math.random() < 0.05 + aurora.chaosLevel / 10) child[i] = 1 - child[i]; // Mutate
                }
                newPop.push(child);
            }
            aurora.geneticPatterns = newPop;
            aurora.lmState.evolutionGeneration++;
        }

        function analysisLoop() {
            requestAnimationFrame(analysisLoop);
            if (!aurora.active) return;

            aurora.analyzer.getByteFrequencyData(aurora.dataArray);
            aurora.analyzer.getFloatTimeDomainData(aurora.timeDomainData);

            let energy = 0;
            aurora.timeDomainData.forEach(val => energy += val * val);
            aurora.lmState.energy = Math.sqrt(energy / aurora.timeDomainData.length);

            let num = 0, den = 0;
            aurora.dataArray.forEach((val, i) => {
                num += i * val;
                den += val;
            });
            aurora.lmState.spectralCentroid = den > 0 ? (num / den) * (aurora.ctx.sampleRate / 2 / aurora.dataArray.length) : 0;

            updateVisualizer();
            updateDebug();
        }

        function initiateVisualizer() {
            aurora.canvasCtx = aurora.elements.visualizer.getContext('2d');
            aurora.elements.visualizer.width = window.innerWidth;
            aurora.elements.visualizer.height = window.innerHeight;
            window.addEventListener('resize', () => {
                aurora.elements.visualizer.width = window.innerWidth;
                aurora.elements.visualizer.height = window.innerHeight;
            });
        }

        function updateVisualizer() {
            const ctx = aurora.canvasCtx;
            const w = aurora.elements.visualizer.width;
            const h = aurora.elements.visualizer.height;
            ctx.clearRect(0, 0, w, h);

            // Fractal visualization: Julia set modulated by spectrum
            const zoom = 1 + aurora.lmState.energy * 5;
            const offsetX = aurora.pos.x / 100 * 2 - 1;
            const offsetY = aurora.pos.y / 100 * 2 - 1;
            const maxIter = 20 + Math.floor(aurora.lmState.complexity * 30);
            const cR = Math.sin(aurora.fractalSeed + aurora.lmState.spectralCentroid / 10000);
            const cI = Math.cos(aurora.fractalSeed + aurora.motion / 100);

            for (let px = 0; px < w; px += 4) {
                for (let py = 0; py < h; py += 4) {
                    let x = (px / w * 3 - 1.5) / zoom + offsetX;
                    let y = (py / h * 3 - 1.5) / zoom + offsetY;
                    let iter = 0;
                    let zx = x, zy = y;
                    while (zx * zx + zy * zy < 4 && iter < maxIter) {
                        const xt = zx * zx - zy * zy + cR;
                        zy = 2 * zx * zy + cI;
                        zx = xt;
                        iter++;
                    }
                    const hue = (iter / maxIter) * 360;
                    ctx.fillStyle = `hsla(${hue}, 80%, 50%, ${aurora.lmState.energy})`;
                    ctx.fillRect(px, py, 4, 4);
                }
            }

            // Waveform overlay
            ctx.strokeStyle = 'rgba(255,255,255,0.8)';
            ctx.beginPath();
            const sliceWidth = w / aurora.timeDomainData.length;
            let x = 0;
            aurora.timeDomainData.forEach((val, i) => {
                const y = (val * h / 2) + h / 2;
                if (i === 0) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
                x += sliceWidth;
            });
            ctx.stroke();
        }

        function setupUIListeners() {
            aurora.elements.threshold.oninput = e => aurora.threshold = parseFloat(e.target.value);
            aurora.elements.sensitivity.oninput = e => aurora.sensitivity = parseFloat(e.target.value);
            aurora.elements.chaos.oninput = e => aurora.chaosLevel = parseFloat(e.target.value);
            aurora.elements.speed.oninput = e => aurora.speedFactor = parseFloat(e.target.value);
            aurora.elements.manualSample.onclick = manualSample;
        }

        function manualSample() {
            aurora.sampleBuffer = [];
            // Force sample for 1 sec
            const start = Date.now();
            const interval = setInterval(() => {
                if (Date.now() - start > 1000) {
                    processSample();
                    clearInterval(interval);
                }
            }, 100);
        }

        function chopAllSamples() {
            aurora.processedSamples = aurora.processedSamples.flatMap(buffer => chopOnOnsets(buffer));
            updateLayers();
        }

        function flipAllSamples() {
            aurora.processedSamples.forEach(buffer => {
                const data = buffer.getChannelData(0);
                data.reverse();
            });
            updateLayers();
        }

        function pitchShiftAll() {
            // Random shift
            aurora.processedSamples = aurora.processedSamples.map(async buffer => {
                const pitch = detectPitch(buffer.getChannelData(0));
                if (pitch > 0) {
                    const factor = 1 + (Math.random() - 0.5) * 0.5;
                    const newLength = Math.floor(buffer.length / factor);
                    const offline = new OfflineAudioContext(1, newLength, aurora.ctx.sampleRate);
                    const source = offline.createBufferSource();
                    source.buffer = buffer;
                    source.playbackRate.value = factor;
                    source.connect(offline.destination);
                    source.start(0);
                    return await offline.startRendering();
                }
                return buffer;
            });
            Promise.all(aurora.processedSamples).then(() => updateLayers());
        }

        function updateUI() {
            aurora.elements.layers.innerHTML = '';
            ['KICK', 'SNARE', 'HATS', 'BASS', 'LEAD', 'FX'].forEach((type, i) => {
                const count = Math.floor(aurora.processedSamples.length / 6); // Mock counts
                const div = document.createElement('div');
                div.className = 'layer';
                div.textContent = `${type}: ${count}`;
                aurora.elements.layers.appendChild(div);
            });
        }

        function updateDebug() {
            aurora.elements.debug.textContent = `Samples: ${aurora.processedSamples.length} | Layers: ${aurora.layers.length} | Centroid: ${Math.round(aurora.lmState.spectralCentroid)}`;
        }

        // Self-Testing Mechanism: Play test tone and verify
        function selfTest() {
            const oscillator = aurora.ctx.createOscillator();
            oscillator.frequency.value = 440;
            oscillator.connect(aurora.masterGain);
            oscillator.start();
            setTimeout(() => {
                oscillator.stop();
                // Analyze recorded? For now, log
                console.log('Test Tone Played: Verify Audibly');
            }, 1000);
        }

        // Easter Egg: Whisper 'Gump' - detect via pitch sequence
        // Implemented in analyzeSample if harmony matches pattern

        initiateWeaver();
        selfTest(); // Initial test
    </script>
</body>
</html>
