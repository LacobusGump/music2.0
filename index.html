<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP 307: Quantum Void Symphony</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    :root {
      --void-primary: #0a0a0a;
      --void-secondary: #1a1a1a;
      --quantum-glow: #9b59b6;
      --tribal-fire: #ff6b35;
      --orchestral-wave: #4a90e2;
      --transcendent-gold: #f39c12;
    }
    
    body {
      background: var(--void-primary);
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    /* Portal Entry */
    .portal-container {
      text-align: center;
      z-index: 1000;
      transition: all 2s ease;
    }
    
    .portal-btn {
      width: 240px;
      height: 240px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, 
        rgba(155,89,182,0.1) 0%, 
        transparent 50%,
        rgba(155,89,182,0.05) 100%);
      border: 1px solid rgba(155,89,182,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 18px;
      font-weight: 100;
      letter-spacing: 4px;
      backdrop-filter: blur(20px);
      transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      animation: portal-breathe 8s ease-in-out infinite;
      position: relative;
      overflow: hidden;
    }
    
    .portal-btn::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      background: conic-gradient(from 0deg at 50% 50%, 
        transparent 0deg,
        rgba(155,89,182,0.4) 90deg,
        transparent 180deg,
        rgba(74,144,226,0.4) 270deg,
        transparent 360deg);
      animation: portal-spin 20s linear infinite;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .portal-btn:hover::before {
      opacity: 1;
    }
    
    .portal-btn:hover {
      transform: scale(1.1);
      border-color: rgba(155,89,182,0.6);
      box-shadow: 
        0 0 60px rgba(155,89,182,0.4),
        inset 0 0 60px rgba(155,89,182,0.1);
    }
    
    @keyframes portal-breathe {
      0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 0 40px rgba(155,89,182,0.2);
      }
      50% { 
        transform: scale(1.05); 
        box-shadow: 0 0 80px rgba(155,89,182,0.4);
      }
    }
    
    @keyframes portal-spin {
      to { transform: rotate(360deg); }
    }
    
    /* Symphony Space */
    .symphony-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
      pointer-events: none;
    }
    
    .symphony-space.active {
      opacity: 1;
      pointer-events: all;
    }
    
    /* Core Orb */
    .core-orb {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, 
        rgba(255,255,255,0.9) 0%, 
        rgba(255,255,255,0.3) 40%, 
        transparent 70%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 
        0 0 60px rgba(255,255,255,0.6),
        0 0 120px rgba(255,255,255,0.3),
        inset 0 0 20px rgba(255,255,255,0.5);
      backdrop-filter: blur(10px);
      mix-blend-mode: screen;
    }
    
    .core-orb.pulse {
      animation: quantum-pulse 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    }
    
    @keyframes quantum-pulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.5); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .core-orb.tribal {
      background: radial-gradient(circle at 30% 30%, 
        var(--tribal-fire) 0%, 
        rgba(255,107,53,0.4) 40%, 
        transparent 70%);
      box-shadow: 
        0 0 80px rgba(255,107,53,0.8),
        0 0 160px rgba(255,107,53,0.4);
    }
    
    .core-orb.orchestral {
      background: radial-gradient(circle at 30% 30%, 
        var(--orchestral-wave) 0%, 
        rgba(74,144,226,0.4) 40%, 
        transparent 70%);
      box-shadow: 
        0 0 100px rgba(74,144,226,0.8),
        0 0 200px rgba(74,144,226,0.4);
    }
    
    .core-orb.transcendent {
      background: radial-gradient(circle at 30% 30%, 
        var(--quantum-glow) 0%,
        var(--tribal-fire) 30%,
        var(--orchestral-wave) 60%, 
transparent 80%);
      box-shadow: 
        0 0 150px rgba(155,89,182,0.9),
        0 0 300px rgba(155,89,182,0.5);
      animation: transcendent-morph 4s ease-in-out;
    }
    
    @keyframes transcendent-morph {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1) rotate(0deg); 
        filter: hue-rotate(0deg);
      }
      25% { 
        transform: translate(-50%, -50%) scale(1.3) rotate(90deg); 
        filter: hue-rotate(60deg);
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1) rotate(180deg); 
        filter: hue-rotate(-60deg);
      }
      75% { 
        transform: translate(-50%, -50% scale(1.4) rotate(270deg); 
        filter: hue-rotate(90deg);
      }
    }
    
    /* Quantum UI */
    .quantum-hud {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      font-weight: 300;
      letter-spacing: 2px;
      background: rgba(0,0,0,0.4);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .quantum-hud.top-left {
      top: 30px;
      left: 30px;
    }
    
    .quantum-hud.bottom-left {
      bottom: 30px;
      left: 30px;
    }
    
    .quantum-hud.top-right {
      top: 30px;
      right: 30px;
      text-align: right;
    }
    
    .hud-title {
      font-size: 14px;
      color: rgba(255,255,255,0.95);
      margin-bottom: 10px;
      font-weight: 600;
      text-transform: uppercase;
    }
    
    .hud-metric {
      margin: 5px 0;
      font-size: 10px;
      opacity: 0.8;
    }
    
    .quantum-bar {
      width: 120px;
      height: rgba(255,255,255,0.1);
      margin: 5px 0;
      background: rgba(255,255,255,0.1);
      margin: 5px 0;
      border-radius: 2px;
      overflow: hidden;
      position: relative;
    }
    
    .quantum-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, 
        var(--orchestral-wave), 
        var(--quantum-glow),
        var(--tribal-fire));
      width: 0%;
      transition: width 0.3s cubic-bezier(0.25, 0.46,0.45, 0.94);
      border-radius: 2px;
      box-shadow: 0 0 10px currentColor;
    }
    
    /* Motion Trail */
    .motion-trail {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: rgba(255,255,255,0.6);
      pointer-events: none;
      animation: trail-fade 2s ease-out forwards;
    }
    
    @keyframes trail-fade {
      0% { 
        opacity: 0.8;
        transform: scale(1);
      }
      100% { 
        opacity: 0;
        transform: scale(3);
      }
    }
    
    /* Quantum Particles */
    .quantum-field {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .quantum-particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: rgba(255,255,255,0.8);
      border-radius: 50%;
      filter: blur(0.5px);
    }
    
    /* Harmonic Visualizer */
    .harmonic-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 150px;
      pointer-events: none;
      z-index: 10;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 2px;
      padding: 0 20px;
      opacity: 0.8;
    }
    
    .harmonic-bar {
      flex: 1;
      max-width: 12px;
      background: linear-gradient(0deg, 
        rgba(255,255,255,0.9), 
        rgba(255,255,255,0.3));
      border-radius: 2px 2px 0 0;
      transition: height 0.05s ease-out;
      transform-origin: bottom;
    }
    
    /* Cinematic Elements */
    .void-veil {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, 
        transparent 20%, 
        rgba(0,0,0,0.4) 50%,
        rgba(0,0,0,0.8) 100%);
      opacity: 0;
      transition: opacity 4s ease;
      z-index: 2;
    }
    
    .void-veil.active { opacity: 1; }
    
    .evolution-text {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 24px;
      font-weight: 100;
      letter-spacing: 8px;
      text-transform: uppercase;
      opacity: 0;
      transition: all 3s ease;
      text-align: center;
      pointer-events: none;
      z-index: 100;
      filter: blur(0.5px);
      text-shadow: 0 0 40px currentColor;
    }
    
    .evolution-text.show {
      opacity: 1;
      letter-spacing: 12px;
      filter: blur(0px);
    }
    
    /* Resonance Rings */
    .resonance-ring {
      position: absolute;
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      pointer-events: none;
      animation: resonance-expand 3s ease-out forwards;
    }
    
    @keyframes resonance-expand {
      0% {
        width: 60px;
        height: 60px;
        opacity: 0.8;
        transform: translate(-50%, -50%) scale(1);
      }
      100% {
        width: 600px;
        height: 600px;
        opacity: 0;
        transform: translate(-50%, -50%) scale(1);
      }
    }
    
    /* Hidden initially */
    .hidden { display: none !important; }
    
    /* Biometric Indicator */
    .biometric-pulse {
      position: fixed;
      bottom: 30px;
      right: 30px;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.2);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 10px;
      backdrop-filter: blur(10px);
    }
    
    .biometric-pulse::before {
      content: '';
      position: absolute;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      border: 1px solid rgba(255,255,255,0.4);
      animation: biometric-beat 1s ease-out infinite;
    }
    
    @keyframes biometric-beat {
      0% { transform: scale(1); opacity: 0.8; }
      100% { transform: scale(1.3); opacity: 0; }
    }
  </style>
</head>
<body>
  <!-- Portal Entry -->
  <div class="portal-container" id="portal">
    <div class="portal-btn" id="portalBtn">
      ENTER VOID
    </div>
  </div>
  
  <!-- Symphony Space -->
  <div class="symphony-space" id="symphonySpace">
    <div class="core-orb" id="coreOrb"></div>
    
    <!-- Quantum HUD -->
    <div class="quantum-hud top-left">
      <div class="hud-title" id="evolutionStage">VOID SILENCE</div>
      <div class="hud-metric">TECHNIQUE: <span id="techniqueDisplay">AWAITING</span></div>
      <div class="hud-metric">PATTERN: <span id="patternDisplay">NONE</span></div>
    </div>
    
    <div class="quantum-hud bottom-left">
      <div class="hud-metric">MOTION RESONANCE</div>
      <div class="quantum-bar">
        <div class="quantum-bar-fill" id="motionBar"></div>
      </div>
      <div class="hud-metric">QUANTUM TENSION</div>
      <div class="quantum-bar">
        <div class="quantum-bar-fill" id="quantumBar"></div>
      </div>
      <div class="hud-metric">HARMONIC FIELD</div>
      <div class="quantum-bar">
        <div class="quantum-bar-fill" id="harmonicBar"></div>
      </div>
    </div>
    
    <div class="quantum-hud top-right">
      <div class="hud-metric">BPM: <span id="bpmDisplay">0</span></div>
      <div class="hud-metric">KEY: <span id="keyDisplay">?</span></div>
      <div class="hud-metric">VOICES: <span id="voiceDisplay">0</span></div>
      <div class="hud-metric">DIMENSION: <span id="dimensionDisplay">1D</span></div>
    </div>
    
    <!-- Harmonic Visualizer -->
    <div class="harmonic-viz" id="harmonicViz"></div>
    
    <!-- Biometric Pulse -->
    <div class="biometric-pulse" id="biometricPulse">
      <span id="heartRate">--</span>
    </div>
  </div>
  
  <!-- Cinematic Elements -->
  <div class="void-veil" id="voidVeil"></div>
  <div class="evolution-text" id="evolutionText"></div>
  <div class="quantum-field" id="quantumField"></div>

  <script>
    // GUMP 307: Quantum Void Symphony Engine
    class QuantumVoidEngine {
      constructor() {
        this.version = 307;
        this.ctx = null;
        this.active = false;
        this.startTime = 0;
        
        // Core Audio Architecture
        this.nodes = {
          master: null,
          analyser: null,
          limiter: null,
          compressor: null,
          convolver: null,
          delays: [],
          filters: {},
          panners: {},
          gains: {}
        };
        
        // Quantum State
        this.quantum = {
          superposition: 0,
          entanglement: 0,
          coherence: 1,
          dimension: 1,
          resonanceField: new Float32Array(128),
          harmonicMatrix: []
        };
        
        // Motion & Gesture System
        this.motion = {
          instant: 0,
          average: 0,
          variance: 0,
          history: new Float32Array(256),
          historyIndex: 0,
          acceleration: { x: 0, y: 0, z: 0 },
          orientation: { alpha: 0, beta: 0, gamma: 0 },
          gesture: null,
          pattern: 'void'
        };
        
        // Position & Physics
        this.physics = {
          position: { x: 50, y: 50 },
          velocity: { x: 0, y: 0 },
          momentum: { x: 0, y: 0 },
          trail: []
        };
        
        // Musical Evolution System
        this.evolution = {
          stage: 'VOID_SILENCE',
          progress: 0,
          threshold: {
            tribal: 100,
            orchestral: 500,
            transcendent: 1000,
            quantum: 2000
          }
        };
        
        // Musical Parameters
        this.music = {
          bpm: 60,
          key: 'C',
          mode: 'aeolian',
          scale: [],
          currentChord: [0, 3, 7],
          phrase: 0,
          step: 0,
          beatDivision: 16
        };
        
        // Voice Architecture
        this.voices = {
          active: new Map(),
          pools: {
            foundation: { max: 4, type: 'sine', range: [20, 80] },
            rhythm: { max: 8, type: 'noise', range: [200, 8000] },
            harmonic: { max: 12, type: 'triangle', range: [100, 400] },
            melodic: { max: 6, type: 'sawtooth', range: [200, 800] },
            atmospheric: { max: 16, type: 'sine', range: [400, 2000] },
            quantum: { max: 24, type: 'custom', range: [50, 20000] }
          }
        };
        
        // Cinematic Themes
        this.themes = {
          current: 'awakening',
          library: {
            awakening: { 
              colors: ['#0a0a0a', '#1a1a1a'], 
              mood: 'mysterious',
              text: 'THE VOID STIRS'
            },
            tribal: { 
              colors: ['#ff6b35', '#8b2500'], 
              mood: 'primal',
              text: 'ANCIENT RHYTHMS AWAKEN'
            },
            orchestral: { 
              colors: ['#4a90e2', '#1e3a8a'], 
              mood: 'majestic',
              text: 'SYMPHONIC CONVERGENCE'
            },
            transcendent: { 
              colors: ['#9b59b6', '#f39c12', '#e74c3c'], 
              mood: 'ethereal',
              text: 'CONSCIOUSNESS EXPANDING'
            },
            quantum: { 
              colors: ['#ffffff', '#000000'], 
              mood: 'infinite',
              text: 'QUANTUM ENTANGLEMENT'
            }
          }
        };
        
        // Biometric Integration
        this.biometric = {
          heartRate: 70,
          variability: 0,
          breathing: { phase: 0, rate: 0.1 }
        };
        
        // Environment Context
        this.environment = {
          location: null,
          weather: null,
          timeOfDay: new Date().getHours(),
          season: this.getSeason()
        };
        
        // Performance Optimization
        this.performance = {
          frameCount: 0,
          lastFrame: 0,
          fps: 60,
          audioLatency: 0
        };
        
        // Cached DOM for visualization
        this.dom = {};
        this.harmonicBars = [];
        
        // Initialize
        this.init();
      }
      
      init() {
        this.setupDOM();
        this.setupEventListeners();
        this.setupVisualization();
        console.log(`🌌 GUMP ${this.version} initialized. Awaiting consciousness...`);
      }
      
      setupDOM() {
        // Cache all DOM elements
        this.dom.portal = document.getElementById('portal');
        this.dom.portalBtn = document.getElementById('portalBtn');
        this.dom.symphonySpace = document.getElementById('symphonySpace');
        this.dom.coreOrb = document.getElementById('coreOrb');
        this.dom.evolutionStage = document.getElementById('evolutionStage');
        this.dom.techniqueDisplay = document.getElementById('techniqueDisplay');
        this.dom.patternDisplay = document.getElementById('patternDisplay');
        this.dom.motionBar = document.getElementById('motionBar');
        this.dom.quantumBar = document.getElementById('quantumBar');
        this.dom.harmonicBar = document.getElementById('harmonicBar');
        this.dom.bpmDisplay = document.getElementById('bpmDisplay');
        this.dom.keyDisplay = document.getElementById('keyDisplay');
        this.dom.voiceDisplay = document.getElementById('voiceDisplay');
        this.dom.dimensionDisplay = document.getElementById('dimensionDisplay');
        this.dom.harmonicViz = document.getElementById('harmonicViz');
        this.dom.biometricPulse = document.getElementById('biometricPulse');
        this.dom.heartRate = document.getElementById('heartRate');
        this.dom.voidVeil = document.getElementById('voidVeil');
        this.dom.evolutionText = document.getElementById('evolutionText');
        this.dom.quantumField = document.getElementById('quantumField');
      }
      
      setupEventListeners() {
        this.dom.portalBtn.addEventListener('click', () => this.enterVoid());
        
        // Motion detection
        window.addEventListener('devicemotion', (e) => this.processMotion(e));
        window.addEventListener('deviceorientation', e => this.processOrientation(e));
        
        // Mouse fallback
        window.addEventListener('mousemove', e => this.processMouseMotion(e));
        window.addEventListener('wheel', e => this.processWheel(e));
        
        // Touch
        window.addEventListener('touchstart', e => this.processTouchStart(e), { passive: false });
        window.addEventListener('touchmove', e => this.processTouchMove(e), { passive: false });
        
        // Keyboard (for testing/accessibility)
        window.addEventListener('keydown', e => this.processKey(e));
      }
      
      setupVisualization() {
        // Create harmonic visualizer bars
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'harmonic-bar';
          bar.style.height = '0px';
          this.dom.harmonicViz.appendChild(bar);
        }
        this.harmonicBars = [...this.dom.harmonicViz.querySelectorAll('.harmonic-bar')];
        
        // Create quantum particle field
        this.createQuantumField();
      }
      
      createQuantumField() {
        const particleCount = 30; // Reduced for performance
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.className = 'quantum-particle';
          particle.style.left = `${Math.random() * 100}%`;
          particle.style.top = `${Math.random() * 100}%`;
          
          // Quantum motion
          const duration = 10 + Math.random() * 20;
          const delay = Math.random() * duration;
          
          particle.animate([
            { transform: `translate(0, 0) scale(1)`, opacity: 0 },
            { transform: `translate(${(Math.random() - 0.5) * 200}px, ${(Math.random() - 0.5) * 200}px) scale(${0.5 + Math.random()})`, opacity: 0.8 },
            { transform: `translate(${(Math.random() - 0.5) * 400}px, ${(Math.random() - 0.5) * 400}px) scale(0)`, opacity: 0 }
          ], {
            duration: duration * 1000,
            delay: delay * 1000,
            iterations: Infinity,
            easing: 'cubic-bezier(0.25, 0.46, 0.45, 0.94)'
          });
          
          this.dom.quantumField.appendChild(particle);
        }
      }
      
      async enterVoid() {
        try {
          // Request permissions
          if (typeof DeviceMotionEvent.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') {
              console.warn('Motion permission denied');
            }
          }
          
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            const permission = await DeviceOrientationEvent.requestPermission();
            if (permission !== 'granted') {
              console.warn('Orientation permission denied');
            }
          }
          
          // Initialize audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          
          // Build audio graph
          this.buildAudioGraph();
          
          // Transition UI
          this.dom.portal.style.opacity = '0';
          setTimeout(() => {
            this.dom.portal.classList.add('hidden');
            this.dom.symphonySpace.classList.add('active');
          }, 2000);
          
          // Start engine
          this.active = true;
          this.startTime = Date.now();
          
          // Begin quantum symphony
          this.startQuantumEngine();
          this.animate();
          
          // Show awakening message
          this.showEvolutionText('CONSCIOUSNESS AWAKENING');
          
          // Fetch environment data
          this.fetchEnvironmentData();
          
          console.log('🎭 Entering the Void...');
          
        } catch (error) {
          console.error('Failed to enter void:', error);
          alert('Failed to initialize quantum engine. Please check console for errors and ensure browser supports Web Audio and motion sensors.');
        }
      }
      
      buildAudioGraph() {
        // Master chain
        this.nodes.limiter = this.ctx.createDynamicsCompressor();
        this.nodes.limiter.threshold.value = -3;
        this.nodes.limiter.knee.value = 0;
        this.nodes.limiter.ratio.value = 20;
        this.nodes.limiter.attack.value = 0.001;
        this.nodes.limiter.release.value = 0.01;
        
        this.nodes.master = this.ctx.createGain();
        this.nodes.master.gain.value = 0.7;
        
        this.nodes.analyser = this.ctx.createAnalyser();
        this.nodes.analyser.fftSize = 256;
        this.nodes.analyser.smoothingTimeConstant = 0.85;
        
        // Global effects
        this.nodes.compressor = this.ctx.createDynamicsCompressor();
        this.nodes.compressor.threshold.value = -24;
        this.nodes.compressor.knee.value = 30;
        this.nodes.compressor.ratio.value = 12;
        this.nodes.compressor.attack.value = 0.003;
        this.nodes.compressor.release.value = 0.25;
        
        // Convolution reverb
        this.nodes.convolver = this.ctx.createConvolver();
        this.nodes.convolver.buffer = this.createReverbImpulse(4, 2, false);
        
        // Create delay network
        this.createDelayNetwork();
        
        // Create filter bank
        this.createFilterBank();
        
        // Connect master chain
        this.nodes.compressor.connect(this.nodes.limiter);
        this.nodes.convolver.connect(this.nodes.limiter);
        this.nodes.limiter.connect(this.nodes.analyser);
        this.nodes.analyser.connect(this.nodes.master);
        this.nodes.master.connect(this.ctx.destination);
        
        // Setup 3D audio
        this.setup3DAudio();
      }
      
      createDelayNetwork() {
        const delayTimes = [0.087, 0.131, 0.217, 0.347];
        const feedbacks = [0.3, 0.25, 0.2, 0.15];
        
        delayTimes.forEach((time, i) => {
          const delay = this.ctx.createDelay(1);
          delay.delayTime.value = time;
          
          const feedback = this.ctx.createGain();
          feedback.gain.value = feedbacks[i];
          
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'highshelf';
          filter.frequency.value = 8000;
          filter.gain.value = -3;
          
          // Create feedback loop
          delay.connect(feedback);
          feedback.connect(filter);
          filter.connect(delay);
          
          // Store reference
          this.nodes.delays.push({
            delay,
            feedback,
            filter,
            mix: this.ctx.createGain()
          });
          
          // Connect to output
          delay.connect(this.nodes.delays[i].mix);
          this.nodes.delays[i].mix.gain.value = 0.15;
          this.nodes.delays[i].mix.connect(this.nodes.limiter);
        });
      }
      
      createFilterBank() {
        const filterTypes = ['lowshelf', 'peaking', 'peaking', 'highshelf'];
        const frequencies = [80, 320, 2500, 8000];
        
        filterTypes.forEach((type, i) => {
          const filter = this.ctx.createBiquadFilter();
          filter.type = type;
          filter.frequency.value = frequencies[i];
          filter.Q.value = 0.7;
          filter.gain.value = 0;
          
          this.nodes.filters[`band${i}`] = filter;
        });
      }
      
      setup3DAudio() {
        // Configure listener
        if (this.ctx.listener.forwardX) {
          this.ctx.listener.forwardX.value = 0;
          this.ctx.listener.forwardY.value = 0;
          this.ctx.listener.forwardZ.value = 0;
          this.ctx.listener.forwardZ.value = -1;
          this.ctx.listener.upX.value = 0;
          this.ctx.listener.upY.value = 1;
          this.ctx.listener.upZ.value = 0;
        }
        
        // Create spatial panners for each voice pool
        Object.keys(this.voices.pools).forEach(poolName => {
          const panner = this.ctx.createPanner();
          panner.panningModel = 'HRTF';
          panner.distanceModel = 'inverse';
          panner.refDistance = 1;
          panner.maxDistance = 10000;
          panner.rolloffFactor = 1;
          panner.coneInnerAngle = 360;
          panner.coneOuterAngle = 0;
          panner.coneOuterGain = 0;
          
          this.nodes.panners[poolName] = panner;
          
          // Create gain node for this voice pool
          this.nodes.gains[poolName] = this.ctx.createGain();
          this.nodes.gains[poolName].gain.value = 0.5;
          
          // Connect panner to gains
          panner.connect(this.nodes.gains[poolName]);
          this.nodes.gains[poolName].connect(this.nodes.compressor);
          
          // Route some pools through reverb
          if (['atmospheric', 'harmonic', 'quantum'].includes(poolName)) {
            this.nodes.gains[poolName].connect(this.nodes.convolver);
          }
          
          // Route some through delays
          if (['melodic', 'quantum'].includes(poolName)) {
            this.nodes.gains[poolName].connect(this.nodes.delays[0].delay);
          }
        });
        
        // Set initial positions
        this.updateSpatialPositions();
      }
      
      updateSpatialPositions() {
        const positions = {
          foundation: [0, -2, -3],
          rhythm: [0, 0, -1],
          harmonic: [-3, 0, -5],
          melodic: [3, 0, -5],
          atmospheric: [0, 3, -8],
          quantum: [0, 0, -10]
        };
        
        Object.entries(positions).forEach(([pool, pos]) => {
          if (this.nodes.panners[pool]) {
            this.nodes.panners[pool].positionX.value = pos[0];
            this.nodes.panners[pool].positionY.value = pos[1];
            this.nodes.panners[pool].positionZ.value = pos[2];
          }
        });
      }
      
      createReverbImpulse(duration, decay, reverse = false) {
        const length = this.ctx.sampleRate * duration;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const channelData = impulse.getChannelData(channel);
          
          for (let i = 0; i < length; i++) {
            const n = reverse ? length - i : i;
            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - n / length, decay);
          }
        }
        
        return impulse;
      }
      
      startQuantumEngine() {
        // Initialize musical scales
        this.updateScale();
        
        // Start the quantum sequencer
        this.quantumSequencer();
        
        // Start gesture recognition
        this.startGestureRecognition();
        
        // Start biometric simulation
        this.startBiometricEngine();
      }
      
      updateScale() {
        const scales = {
          ionian: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10]
        };
        
        this.music.scale = scales[this.music.mode] || scales.aeolian;
      }
      
      quantumSequencer() {
        const sequence = () => {
          if (!this.active) return;
          
          // Process current step
          this.processQuantumStep();
          
          // Advance sequencer
          this.music.step = (this.music.step + 1) % this.music.beatDivision;
          
          // Check for phrase change
          if (this.music.step === 0) {
            this.music.phrase++;
            this.updateHarmonicProgression();
          }
          
          // Calculate next step timing with quantum fluctuation
          const baseInterval = (60 / this.music.bpm) * 1000 / 4;
          const quantumFlux = (Math.random() - 0.5) * 2 * this.quantum.coherence;
          const interval = baseInterval + quantumFlux;
          
          setTimeout(sequence, interval);
        };
        
        sequence();
      }
      
      processQuantumStep() {
        const beat = this.music.step % 4;
        const measure = Math.floor(this.music.step / 16);
        
        // Pulse on downbeats
        if (beat === 0) {
          this.dom.coreOrb.classList.add('pulse');
          setTimeout(() => this.dom.coreOrb.classList.remove('pulse'), 300);
          this.createResonanceRing();
        }
        
        // Layer activation based on evolution and motion
        this.activateVoiceLayers(beat, measure);
        
        // Update quantum state
        this.updateQuantumState();
      }
      
      activateVoiceLayers(beat, measure) {
        const motion = this.motion.average;
        const variance = this.motion.variance;
        const evolution = this.evolution.progress;
        
        // Foundation layer - deep bass presence
        if (beat === 0 && (motion > 0.5 || evolution > 50)) {
          this.playFoundation();
        }
        
        // Rhythm layer - percussive elements
        if (motion > 1 && (beat === 2 || (variance > 2 && beat % 2 === 1))) {
          this.playRhythm(beat);
        }
        
        // Harmonic layer - chord progressions
        if (beat === 0 && evolution > 100 && motion > 0.8) {
          this.playHarmonic();
        }
        
        // Melodic layer - lead lines
        if ((beat % 2 === 0) && evolution > 200) {
          this.playMelodic();
        }
        
        // Atmospheric layer - ambient textures
        if (Math.random() < 0.1 * this.quantum.coherence && evolution > 300) {
          this.playAtmospheric();
        }
        
        // Quantum layer - transcendent sounds
        if (this.quantum.superposition > 0.5 && evolution > 500) {
          this.playQuantum();
        }
      }
      
      checkPoolLimit(pool) {
        const activeInPool = Array.from(this.voices.active.values()).filter(v => v.pool === pool);
        if (activeInPool.length >= this.voices.pools[pool].max) {
          const oldest = activeInPool[0].node;
          oldest.stop();
          this.voices.active.delete(oldest);
        }
      }
      
      playFoundation() {
        this.checkPoolLimit('foundation');
        
        const note = this.music.currentChord[0];
        const freq = this.noteToFrequency(note, 1);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.5, this.ctx.currentTime + 0.5);
        
        filter.type = 'lowpass';
        filter.frequency.value = 100 + this.motion.average * 50;
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.panners.foundation);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1);
        
        this.registerVoice('foundation', osc);
      }
      
      playRhythm(beat) {
        this.checkPoolLimit('rhythm');
        
        const types = ['white', 'pink', 'brown'];
        const noiseType = types[beat % 3];
        
        const bufferSize = 0.1 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        
        // Generate noise based on type
        let b0 = 0, b1 = 0, b2 = 0, b3 = 0, b4 = 0, b5 = 0, b6 = 0; // For pink/brown optimization
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          if (noiseType === 'white') {
            data[i] = white;
          } else if (noiseType === 'pink') {
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            data[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            data[i] *= 0.11;
            b6 = white * 0.115926;
          } else {
            b0 = 0.995 * b0 + white * 0.01;
            data[i] = b0;
          }
        }
        
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        source.buffer = buffer;
        
        filter.type = beat === 0 ? 'lowpass' : 'highpass';
        filter.frequency.value = beat === 0 ? 200 : 8000;
        filter.Q.value = 10;
        
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        source.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.panners.rhythm);
        
        source.start();
        
        this.registerVoice('rhythm', source);
      }
      
      playHarmonic() {
        this.checkPoolLimit('harmonic');
        
        const chord = this.music.currentChord;
        const inversions = [0, 1, 2];
        const inversion = inversions[Math.floor(Math.random() * inversions.length)];
        
        chord.forEach((note, i) => {
          const octaveShift = (i + inversion) % 3;
          const freq = this.noteToFrequency(note, 3 + octaveShift);
          
          const osc = this.ctx.createOscillator();
          osc.type = 'triangle';
          osc.frequency.value = freq;
          osc.detune.value = Math.random() * 10 - 5;
          
          const gain = this.ctx.createGain();
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
          
          const filter = this.ctx.createBiquadFilter();
          filter.type = 'bandpass';
          filter.frequency.value = freq;
          filter.Q.value = 5;
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.nodes.panners.harmonic);
          
          osc.start();
          osc.stop(this.ctx.currentTime + 3);
          
          this.registerVoice('harmonic', osc);
        });
      }
      
      playMelodic() {
        this.checkPoolLimit('melodic');
        
        const scaleNote = Math.floor(Math.random() * this.music.scale.length);
        const octave = 4 + Math.floor(this.quantum.superposition * 2);
        const freq = this.noteToFrequency(this.music.scale[scaleNote], octave);
        
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 2, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(freq * 8, this.ctx.currentTime + 0.2);
        filter.frequency.exponentialRampToValueAtTime(freq * 2, this.ctx.currentTime + 0.8);
        filter.Q.value = 3 + this.quantum.coherence * 5;
        
        const vibrato = this.ctx.createOscillator();
        vibrato.type = 'sine';
        vibrato.frequency.value = 4 + this.motion.variance * 2;
        const vibratoGain = this.ctx.createGain();
        vibratoGain.gain.value = 5 + this.quantum.entanglement * 10;
        
        vibrato.connect(vibratoGain);
        vibratoGain.connect(osc.frequency);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.nodes.panners.melodic);
        
        vibrato.start();
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
        vibrato.stop(this.ctx.currentTime + 1.5);
        
        this.registerVoice('melodic', osc);
      }
      
      playAtmospheric() {
        this.checkPoolLimit('atmospheric');
        
        const freq = this.noteToFrequency(
          this.music.scale[Math.floor(Math.random() * this.music.scale.length)],
          5 + Math.random() * 2
        );
        
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.linearRampToValueAtTime(freq * 1.05, this.ctx.currentTime + 5);
        osc.frequency.linearRampToValueAtTime(freq * 0.95, this.ctx.currentTime + 10);
        
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 3);
        gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 7);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = freq;
        filter.Q.value = 50;
        
        const panner = this.ctx.createPanner();
        const angle = Math.random() * Math.PI * 2;
        const distance = 5 + Math.random() * 10;
        panner.positionX.value = Math.cos(angle) * distance;
        panner.positionY.value = Math.random() * 5;
        panner.positionZ.value = Math.sin(angle) * distance;
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(panner);
        panner.connect(this.nodes.panners.atmospheric);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 10);
        
        this.registerVoice('atmospheric', osc);
      }
      
      playQuantum() {
        this.checkPoolLimit('quantum');
        
        const fundamentalFreq = this.noteToFrequency(this.music.currentChord[0], 2);
        const harmonics = [1, 1.5, 2, 2.5, 3, 4, 5, 6, 8];
        
        harmonics.forEach((harmonic, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          // Custom waveform
          const real = new Float32Array(harmonics.length + 1);
          real[i + 1] = 1;
          const imag = new Float32Array(real.length);
          const wave = this.ctx.createPeriodicWave(real, imag);
          osc.setPeriodicWave(wave);
          
          osc.frequency.value = fundamentalFreq * harmonic;
          
          filter.type = 'peaking';
          filter.frequency.value = fundamentalFreq * harmonic;
          filter.Q.value = 20;
          filter.gain.value = 10;
          
          // Quantum amplitude envelope
          const amplitude = Math.sin((i / harmonics.length) * Math.PI) * this.quantum.superposition;
          gain.gain.setValueAtTime(amplitude * 0.05, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 5);
          
          osc.connect(filter);
          filter.connect(gain);
          gain.connect(this.nodes.panners.quantum);
          
          osc.start();
          osc.stop(this.ctx.currentTime + 5);
          
          this.registerVoice('quantum', osc);
        });
      }
      
      registerVoice(pool, node) {
        const voice = {
          pool,
          node,
          startTime: this.ctx.currentTime
        };
        
        this.voices.active.set(node, voice);
        
        // Auto cleanup
        node.onended = () => {
          this.voices.active.delete(node);
        };
      }
      
      noteToFrequency(note, octave) {
        const keyOffset = {
          'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
          'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11
        };
        
        const semitones = (keyOffset[this.music.key] || 0) + note;
        return 261.63 * Math.pow(2, (semitones / 12) + (octave - 4));
      }
      
      updateHarmonicProgression() {
        const progressions = [
          [[0, 3, 7], [5, 8, 0], [3, 7, 10], [0, 3, 7]],  // i - VI - v - i
          [[0, 3, 7], [7, 10, 2], [3, 7, 10], [8, 0, 3]], // i - VII - v - VI
          [[0, 3, 7], [2, 5, 9], [7, 10, 2], [0, 3, 7]],  // i - ii° - VII - i
          [[0, 3, 7], [5, 8, 0], [2, 5, 9], [7, 10, 2]]   // i - VI - ii° - VII
        ];
        
        const progression = progressions[Math.floor(this.music.phrase / 4) % progressions.length];
        this.music.currentChord = progression[this.music.phrase % 4];
      }
      
      updateQuantumState() {
        // Update quantum coherence based on motion stability
        const motionStability = 1 - (this.motion.variance / 10);
        this.quantum.coherence = this.quantum.coherence * 0.95 + motionStability * 0.05;
        
        // Update superposition based on gesture complexity
        const gestureComplexity = this.motion.pattern === 'spiral' ? 0.8 : 
                                 this.motion.pattern === 'wave' ? 0.6 : 
                                 this.motion.pattern === 'shake' ? 0.9 : 0.3;
        this.quantum.superposition = this.quantum.superposition * 0.9 + gestureComplexity * 0.1;
        
        // Update entanglement based on biometric sync
        const biometricSync = Math.abs(Math.sin(this.biometric.breathing.phase) * 
                                      Math.cos(this.biometric.heartRate / 60));
        this.quantum.entanglement = this.quantum.entanglement * 0.8 + biometricSync * 0.2;
        
        // Calculate dimension
        this.quantum.dimension = 1 + Math.floor(
          this.quantum.coherence + 
          this.quantum.superposition + 
          this.quantum.entanglement
        );
      }
      
      processMotion(event) {
        if (!this.active || !event.accelerationIncludingGravity) return;
        
        const acc = event.accelerationIncludingGravity;
        const rotationRate = event.rotationRate || { alpha: 0, beta: 0, gamma: 0 };
        
        // Calculate motion magnitude
        const dx = acc.x - this.motion.acceleration.x;
        const dy = acc.y - this.motion.acceleration.y;
        const dz = acc.z - this.motion.acceleration.z;
        
        const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
        
        // Update motion state
        this.motion.acceleration = { x: acc.x, y: acc.y, z: acc.z };
        this.motion.instant = magnitude;
        
        // Update history
        this.motion.history[this.motion.historyIndex] = magnitude;
        this.motion.historyIndex = (this.motion.historyIndex + 1) % this.motion.history.length;
        
        // Calculate statistics
        this.updateMotionStatistics();
        
        // Update physics
        this.physics.velocity.x += acc.x * 0.01;
        this.physics.velocity.y += acc.y * 0.01;
        
        // Detect gestures
        this.detectGestures(rotationRate);
        
        // Update evolution
        this.updateEvolution();
      }
      
      processOrientation(event) {
        if (!this.active) return;
        
        this.motion.orientation = {
          alpha: event.alpha || 0,
          beta: event.beta || 0,
          gamma: event.gamma || 0
        };
        
        // Update 3D listener orientation
        this.update3DListenerOrientation();
      }
      
      processMouseMotion(event) {
        if (!this.active) return;
        
        const x = (event.clientX / window.innerWidth) * 100;
        const y = (event.clientY / window.innerHeight) * 100;
        
        const dx = x - this.physics.position.x;
        const dy = y - this.physics.position.y;
        
        const magnitude = Math.sqrt(dx * dx + dy * dy) * 0.5;
        
        this.motion.instant = magnitude;
        this.physics.position = { x, y };
        
        // Update motion history
        this.motion.history[this.motion.historyIndex] = magnitude;
        this.motion.historyIndex = (this.motion.historyIndex + 1) % this.motion.history.length;
        
        this.updateMotionStatistics();
        this.updateEvolution();
      }
      
      processWheel(event) {
        if (!this.active) return;
        
        // Use wheel as a "depth" control
        this.quantum.coherence += event.deltaY * 0.001;
        this.quantum.coherence = Math.max(0, Math.min(1, this.quantum.coherence));
      }
      
      processTouchStart(event) {
        event.preventDefault();
        this.touchStart = {
          x: event.touches[0].clientX,
          y: event.touches[0].clientY,
          time: Date.now()
        };
      }
      
      processTouchMove(event) {
        event.preventDefault();
        if (!this.touchStart) return;
        
        const touch = event.touches[0];
        const dx = touch.clientX - this.touchStart.x;
        const dy = touch.clientY - this.touchStart.y;
        const dt = Date.now() - this.touchStart.time;
        
        const velocity = Math.sqrt(dx * dx + dy * dy) / dt * 100;
        
        this.motion.instant = velocity;
        this.processMouseMotion({
          clientX: touch.clientX,
          clientY: touch.clientY
        });
        
        this.touchStart = {
          x: touch.clientX,
          y: touch.clientY,
          time: Date.now()
        };
      }
      
      processKey(event) {
        if (!this.active) return;
        
        const keyMap = {
          'ArrowUp': () => this.physics.velocity.y -= 5,
          'ArrowDown': () => this.physics.velocity.y += 5,
          'ArrowLeft': () => this.physics.velocity.x -= 5,
          'ArrowRight': () => this.physics.velocity.x += 5,
          ' ': () => this.playQuantum(),
          'Enter': () => this.evolveStage()
        };
        
        if (keyMap[event.key]) {
          keyMap[event.key]();
        }
      }
      
      updateMotionStatistics() {
        let sum = 0;
        let count = 0;
        
        for (let i = 0; i < this.motion.history.length; i++) {
          const value = this.motion.history[i];
          if (value > 0) {
            sum += value;
            count++;
          }
        }
        
        this.motion.average = count > 0 ? sum / count : 0;
        
        let varianceSum = 0;
        for (let i = 0; i < this.motion.history.length; i++) {
          const value = this.motion.history[i];
          if (value > 0) {
            varianceSum += Math.pow(value - this.motion.average, 2);
          }
        }
        
        this.motion.variance = count > 0 ? Math.sqrt(varianceSum / count) : 0;
        
        // Detect motion patterns
        this.detectMotionPattern();
      }
      
      detectMotionPattern() {
        const recent = this.motion.history.slice(-30);
        
        if (this.motion.variance > 3 && this.motion.average > 2) {
          this.motion.pattern = 'chaos';
        } else if (this.motion.variance < 0.5 && this.motion.average < 0.5) {
          this.motion.pattern = 'stillness';
        } else if (this.detectRhythmicPattern(recent)) {
          this.motion.pattern = 'rhythmic';
        } else if (this.detectSpiralPattern()) {
          this.motion.pattern = 'spiral';
        } else if (this.motion.average > 1.5) {
          this.motion.pattern = 'flowing';
        } else {
          this.motion.pattern = 'ambient';
        }
      }
      
      detectRhythmicPattern(data) {
        const peaks = [];
        for (let i = 1; i < data.length - 1; i++) {
          if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > this.motion.average * 1.5) {
            peaks.push(i);
          }
        }
        
        if (peaks.length < 3) return false;
        
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
          intervals.push(peaks[i] - peaks[i-1]);
        }
        
        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const variance = intervals.reduce((sum, int) => sum + Math.pow(int - avgInterval, 2), 0) / intervals.length;
        
        return variance < avgInterval * 0.3;
      }
      
      detectSpiralPattern() {
        const alphaChange = Math.abs(this.motion.orientation.alpha - (this.lastOrientation?.alpha || 0));
        const betaStable = Math.abs(this.motion.orientation.beta - (this.lastOrientation?.beta || 0)) < 10;
        
        this.lastOrientation = { ...this.motion.orientation };
        
        return alphaChange > 30 && betaStable && this.motion.average > 1;
      }
      
      detectGestures(rotationRate) {
        const rateSum = Math.abs(rotationRate.alpha) + Math.abs(rotationRate.beta) + Math.abs(rotationRate.gamma);
        if (rateSum > 500) {
          this.motion.gesture = 'shake';
          this.onGesture('shake');
        } else if (Math.abs(rotationRate.beta) > 100 && Math.abs(rotationRate.alpha) < 50) {
          this.motion.gesture = 'wave';
          this.onGesture('wave');
        } else if (this.motion.instant > 10 && this.motion.average < 2) {
          this.motion.gesture = 'tap';
          this.onGesture('tap');
        }
      }
      
      onGesture(gesture) {
        console.log(`🎭 Gesture detected: ${gesture}`);
        
        switch (gesture) {
          case 'shake':
            this.quantum.coherence = Math.random();
            this.createQuantumBurst();
            break;
          case 'wave':
            this.music.bpm = Math.min(180, this.music.bpm + 10);
            break;
          case 'tap':
            this.playQuantum();
            break;
        }
      }
      
      update3DListenerOrientation() {
        if (!this.ctx.listener.forwardX) return;
        
        const alpha = this.motion.orientation.alpha * Math.PI / 180;
        const beta = this.motion.orientation.beta * Math.PI / 180;
        const gamma = this.motion.orientation.gamma * Math.PI / 180;
        
        const forwardX = Math.cos(alpha) * Math.cos(beta);
        const forwardY = Math.sin(alpha) * Math.cos(beta);
        const forwardZ = -Math.sin(beta);
        
        const upX = Math.cos(alpha) * Math.sin(gamma) - Math.sin(alpha) * Math.sin(beta) * Math.cos(gamma);
        const upY = Math.sin(alpha) * Math.sin(gamma) + Math.cos(alpha) * Math.sin(beta) * Math.cos(gamma);
        const upZ = Math.cos(beta) * Math.cos(gamma);
        
        this.ctx.listener.forwardX.value = forwardX;
        this.ctx.listener.forwardY.value = forwardY;
        this.ctx.listener.forwardZ.value = forwardZ;
        this.ctx.listener.upX.value = upX;
        this.ctx.listener.upY.value = upY;
        this.ctx.listener.upZ.value = upZ;
      }
      
      updateEvolution() {
        this.evolution.progress += this.motion.average * 0.1;
        
        if (this.evolution.stage === 'VOID_SILENCE' && this.evolution.progress > this.evolution.threshold.tribal) {
          this.evolveStage('TRIBAL_AWAKENING');
        } else if (this.evolution.stage === 'TRIBAL_AWAKENING' && this.evolution.progress > this.evolution.threshold.orchestral) {
          this.evolveStage('ORCHESTRAL_RISING');
        } else if (this.evolution.stage === 'ORCHESTRAL_RISING' && this.evolution.progress > this.evolution.threshold.transcendent) {
          this.evolveStage('TRANSCENDENT_UNITY');
        } else if (this.evolution.stage === 'TRANSCENDENT_UNITY' && this.evolution.progress > this.evolution.threshold.quantum) {
          this.evolveStage('QUANTUM_INFINITY');
        }
        
        this.updateMusicalEvolution();
      }
      
      evolveStage(newStage) {
        this.evolution.stage = newStage;
        
        console.log(`✨ Evolution: ${newStage}`);
        
        this.dom.evolutionStage.textContent = newStage.replace('_', ' ');
        
        const messages = {
          'TRIBAL_AWAKENING': 'ANCIENT RHYTHMS AWAKEN',
          'ORCHESTRAL_RISING': 'SYMPHONIC FORCES GATHER',
          'TRANSCENDENT_UNITY': 'CONSCIOUSNESS EXPANDS',
          'QUANTUM_INFINITY': 'INFINITE DIMENSIONS UNFOLD'
        };
        
        this.showEvolutionText(messages[newStage] || newStage);
        
        const classes = {
          'TRIBAL_AWAKENING': 'tribal',
          'ORCHESTRAL_RISING': 'orchestral',
          'TRANSCENDENT_UNITY': 'transcendent',
          'QUANTUM_INFINITY': 'transcendent'
        };
        
        this.dom.coreOrb.className = 'core-orb ' + (classes[newStage] || '');
        
        this.createEvolutionParticles(newStage);
        
        this.updateTheme(newStage);
      }
      
      updateMusicalEvolution() {
        let targetBPM = 60 + (this.evolution.progress * 0.05) + (this.motion.average * 10);
        
        const stageMultipliers = {
          'VOID_SILENCE': 0.8,
          'TRIBAL_AWAKENING': 1.2,
          'ORCHESTRAL_RISING': 1.1,
          'TRANSCENDENT_UNITY': 1.3,
          'QUANTUM_INFINITY': 1.5
        };
        
        targetBPM *= stageMultipliers[this.evolution.stage] || 1;
        
        targetBPM += (this.biometric.heartRate - 70) * 0.3;
        
        this.music.bpm = this.music.bpm * 0.95 + targetBPM * 0.05;
        this.music.bpm = Math.max(40, Math.min(180, this.music.bpm));
        
        if (this.evolution.progress > 200 && this.evolution.progress % 200 < 10) {
          this.modulateKey();
        }
      }
      
      modulateKey() {
        const keys = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'G#', 'D#', 'A#', 'F'];
        const currentIndex = keys.indexOf(this.music.key);
        const direction = this.quantum.superposition > 0.5 ? 1 : -1;
        const newIndex = (currentIndex + direction + keys.length) % keys.length;
        
        this.music.key = keys[newIndex];
        console.log(`🎵 Key modulation: ${this.music.key}`);
      }
      
      startGestureRecognition() {
        setInterval(() => {
          if (!this.active) return;
          
          const patterns = this.analyzeComplexGestures();
          
          if (patterns.infinity) {
            this.onGesture('infinity');
            this.quantum.entanglement = 1;
          }
          
          if (patterns.spiral) {
            this.onGesture('spiral');
            this.createSpiralEffect();
          }
          
          if (patterns.stillness && this.evolution.progress > 100) {
            this.onGesture('meditation');
            this.enterMeditativeState();
          }
        }, 500);
      }
      
      analyzeComplexGestures() {
        const recent = this.motion.history.slice(-60);
        
        return {
          infinity: this.detectInfinityPattern(recent),
          spiral: this.motion.pattern === 'spiral',
          stillness: recent.every(m => m < 0.1)
        };
      }
      
      detectInfinityPattern(data) {
        const midpoint = data.length / 2;
        const firstHalf = data.slice(0, midpoint);
        const secondHalf = data.slice(midpoint);
        
        const firstPeak = Math.max(...firstHalf);
        const secondPeak = Math.max(...secondHalf);
        
        return firstPeak > 3 && secondPeak > 3 && Math.abs(firstPeak - secondPeak) < 1;
      }
      
      createSpiralEffect() {
        const spiralCount = 8;
        const centerX = this.physics.position.x;
        const centerY = this.physics.position.y;
        
        for (let i = 0; i < spiralCount; i++) {
          const angle = (i / spiralCount) * Math.PI * 2;
          const radius = 50 + i * 10;
          
          const particle = document.createElement('div');
          particle.className = 'motion-trail';
          particle.style.left = `${centerX + Math.cos(angle) * radius}%`;
          particle.style.top = `${centerY + Math.sin(angle) * radius}%`;
          particle.style.background = `hsl(${i * 45}, 70%, 60%)`;
          
          this.dom.symphonySpace.appendChild(particle);
          
          setTimeout(() => particle.remove(), 2000);
        }
      }
      
      enterMeditativeState() {
        this.dom.voidVeil.classList.add('active');
        
        this.music.bpm *= 0.5;
        
        this.nodes.gains.atmospheric.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 2);
        
        setTimeout(() => {
          this.dom.voidVeil.classList.remove('active');
          this.nodes.gains.atmospheric.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 2);
          this.music.bpm *= 2;
        }, 10000);
      }
      
      startBiometricEngine() {
        setInterval(() => {
          if (!this.active) return;
          
          const targetHR = 70 + this.motion.average * 10 + Math.random() * 5;
          this.biometric.heartRate = this.biometric.heartRate * 0.9 + targetHR * 0.1;
          
          this.biometric.breathing.phase += this.biometric.breathing.rate;
          if (this.biometric.breathing.phase > Math.PI * 2) {
            this.biometric.breathing.phase -= Math.PI * 2;
          }
          
          this.biometric.variability = Math.abs(Math.sin(Date.now() * 0.001)) * 10;
          
          this.dom.heartRate.textContent = Math.round(this.biometric.heartRate);
          
          this.applyBiometricInfluence();
        }, 100);
      }
      
      applyBiometricInfluence() {
        const breathIntensity = Math.sin(this.biometric.breathing.phase) * 0.5 + 0.5;
        
        Object.values(this.nodes.filters).forEach(filter => {
          const baseFreq = filter.frequency.value;
          filter.frequency.linearRampToValueAtTime(
            baseFreq * (0.8 + breathIntensity * 0.4),
            this.ctx.currentTime + 0.1
          );
        });
        
        const hrNormalized = (this.biometric.heartRate - 60) / 60;
        this.nodes.delays.forEach(delay => {
          delay.feedback.gain.value = 0.2 + hrNormalized * 0.2;
        });
      }
      
      async fetchEnvironmentData() {
        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
          });
          
          this.environment.location = {
            lat: position.coords.latitude,
            lon: position.coords.longitude
          };
          
          const weatherResponse = await fetch(
            `https://api.open-meteo.com/v1/forecast?latitude=${this.environment.location.lat}&longitude=${this.environment.location.lon}&current_weather=true`
          );
          
          if (!weatherResponse.ok) throw new Error('Weather API failed');
          
          const weatherData = await weatherResponse.json();
          this.environment.weather = weatherData.current_weather;
          
          this.applyEnvironmentalInfluences();
          
        } catch (error) {
          console.warn('Environmental data unavailable:', error);
          // Fallback to default influences
          this.environment.weather = { temperature: 20, windspeed: 5, weathercode: 0 };
          this.applyEnvironmentalInfluences();
        }
      }
      
      getSeason() {
        const month = new Date().getMonth();
        if (month >= 2 && month <= 4) return 'spring';
        if (month >= 5 && month <= 7) return 'summer';
        if (month >= 8 && month <= 10) return 'autumn';
        return 'winter';
      }
      
      applyEnvironmentalInfluences() {
        const temp = this.environment.weather.temperature;
        const windSpeed = this.environment.weather.windspeed;
        const weatherCode = this.environment.weather.weathercode;
        
        const reverbTime = 2 + (temp / 10);
        this.nodes.convolver.buffer = this.createReverbImpulse(reverbTime, 2, false);
        
        this.windModulation = windSpeed / 20;
        
        if (weatherCode >= 61 && weatherCode <= 67) {
          this.music.mode = 'aeolian';
          this.themes.current = 'orchestral';
        } else if (weatherCode >= 71 && weatherCode <= 77) {
          this.music.mode = 'lydian';
          this.themes.current = 'transcendent';
        } else if (weatherCode <= 3) {
          this.music.mode = 'ionian';
          this.themes.current = 'awakening';
        }
        
        if (this.environment.timeOfDay >= 22 || this.environment.timeOfDay <= 6) {
          this.nodes.gains.atmospheric.gain.value *= 1.5;
        }
        
        this.updateScale();
        console.log(`🌍 Environmental adaptation: ${temp}°C, ${this.music.mode} mode`);
      }
      
      createQuantumBurst() {
        const burstCount = 10; // Reduced for performance
        for (let i = 0; i < burstCount; i++) {
          setTimeout(() => {
            const freq = 100 + Math.random() * 2000;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const panner = this.ctx.createPanner();
            
            osc.frequency.value = freq;
            osc.type = 'sine';
            
            const angle = (i / burstCount) * Math.PI * 2;
            const distance = 5 + Math.random() * 10;
            panner.positionX.value = Math.cos(angle) * distance;
            panner.positionY.value = Math.random() * 10 - 5;
            panner.positionZ.value = Math.sin(angle) * distance;
            
            gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
            
            osc.connect(gain);
            gain.connect(panner);
            panner.connect(this.nodes.master);
            
            osc.start();
            osc.stop(this.ctx.currentTime + 0.5);
          }, i * 50);
        }
      }
      
      createResonanceRing() {
        const ring = document.createElement('div');
        ring.className = 'resonance-ring';
        ring.style.left = `${this.physics.position.x}%`;
        ring.style.top = `${this.physics.position.y}%`;
        
        this.dom.symphonySpace.appendChild(ring);
        
        setTimeout(() => ring.remove(), 3000);
      }
      
      showEvolutionText(text) {
        this.dom.evolutionText.textContent = text;
        this.dom.evolutionText.classList.add('show');
        
        setTimeout(() => this.dom.evolutionText.classList.remove('show'), 4000);
      }
      
      createEvolutionParticles(stage) {
        const configs = {
          'TRIBAL_AWAKENING': { count: 30, color: '#ff6b35', speed: 2 }, // Reduced count
          'ORCHESTRAL_RISING': { count: 40, color: '#4a90e2', speed: 1.5 },
          'TRANSCENDENT_UNITY': { count: 60, color: '#9b59b6', speed: 1 },
          'QUANTUM_INFINITY': { count: 100, color: '#ffffff', speed: 0.5 }
        };
        
        const config = configs[stage] || { count: 30, color: '#ffffff', speed: 1 };
        
        for (let i = 0; i < config.count; i++) {
          const particle = document.createElement('div');
          particle.className = 'motion-trail';
          particle.style.left = `${this.physics.position.x + (Math.random() - 0.5) * 50}%`;
          particle.style.top = `${this.physics.position.y + (Math.random() - 0.5) * 50}%`;
          particle.style.background = config.color;
          particle.style.animationDuration = `${2 / config.speed}s`;
          
          this.dom.symphonySpace.appendChild(particle);
          
          setTimeout(() => particle.remove(), 2000);
        }
      }
      
      updateTheme(stage) {
        const themeMap = {
          'VOID_SILENCE': 'awakening',
          'TRIBAL_AWAKENING': 'tribal',
          'ORCHESTRAL_RISING': 'orchestral',
          'TRANSCENDENT_UNITY': 'transcendent',
          'QUANTUM_INFINITY': 'quantum'
        };
        
        const themeName = themeMap[stage] || 'awakening';
        const theme = this.themes.library[themeName];
        
        if (theme) {
          this.themes.current = themeName;
          
          const gradient = `radial-gradient(circle at ${this.physics.position.x}% ${this.physics.position.y}%, ${theme.colors[0]} 0%, ${theme.colors[1] || '#000000'} 100%)`;
          document.body.style.background = gradient;
        }
      }
      
      animate() {
        const frame = () => {
          if (!this.active) return;
          
          this.updatePhysics();
          
          this.updateUI();
          
          this.updateVisualization();
          
          if (this.motion.instant > 2 && this.performance.frameCount % 3 === 0) {
            this.createMotionTrail();
          }
          
          this.performance.frameCount++;
          const now = performance.now();
          if (now - this.performance.lastFrame > 1000) {
            this.performance.fps = this.performance.frameCount;
            this.performance.frameCount = 0;
            this.performance.lastFrame = now;
          }
          
          requestAnimationFrame(frame);
        };
        
        requestAnimationFrame(frame);
      }
      
      updatePhysics() {
        this.physics.position.x += this.physics.velocity.x;
        this.physics.position.y += this.physics.velocity.y;
        
        if (this.physics.position.x < 0 || this.physics.position.x > 100) {
          this.physics.velocity.x *= -0.8;
          this.createQuantumBurst();
        }
        if (this.physics.position.y < 0 || this.physics.position.y > 100) {
          this.physics.velocity.y *= -0.8;
          this.createQuantumBurst();
        }
        
        this.physics.position.x = Math.max(0, Math.min(100, this.physics.position.x));
        this.physics.position.y = Math.max(0, Math.min(100, this.physics.position.y));
        
        this.physics.velocity.x *= 0.98;
        this.physics.velocity.y *= 0.98;
        
        this.dom.coreOrb.style.left = `${this.physics.position.x}%`;
        this.dom.coreOrb.style.top = `${this.physics.position.y}%`;
      }
      
      updateUI() {
        this.dom.evolutionStage.textContent = this.evolution.stage.replace(/_/g, ' ');
        this.dom.techniqueDisplay.textContent = this.getCurrentTechnique();
        this.dom.patternDisplay.textContent = this.motion.pattern.toUpperCase();
        this.dom.bpmDisplay.textContent = Math.round(this.music.bpm);
        this.dom.keyDisplay.textContent = `${this.music.key} ${this.music.mode.toUpperCase()}`;
        this.dom.voiceDisplay.textContent = this.voices.active.size;
        this.dom.dimensionDisplay.textContent = this.quantum.dimension + 'D';
        
        this.dom.motionBar.style.width = `${Math.min(this.motion.average * 20, 100)}%`;
        this.dom.quantumBar.style.width = `${this.quantum.coherence * 100}%`;
        this.dom.harmonicBar.style.width = `${this.quantum.entanglement * 100}%`;
      }
      
      getCurrentTechnique() {
        if (this.quantum.superposition > 0.8) return 'QUANTUM INTERFERENCE';
        if (this.motion.pattern === 'spiral') return 'SPIRAL SYNTHESIS';
        if (this.motion.pattern === 'rhythmic') return 'RHYTHMIC RESONANCE';
        if (this.motion.variance > 3) return 'CHAOTIC BLOOM';
        if (this.motion.average < 0.5) return 'STILLNESS MEDITATION';
        return 'FLOWING EXPRESSION';
      }
      
      updateVisualization() {
        if (!this.nodes.analyser) return;
        
        const bufferLength = this.nodes.analyser.frequencyBinCount;
        const dataArray = new Uint8Array(bufferLength);
        this.nodes.analyser.getByteFrequencyData(dataArray);
        
        const barCount = this.harmonicBars.length;
        
        for (let i = 0; i < barCount; i++) {
          const index = Math.floor(i * bufferLength / barCount);
          const value = dataArray[index] || 0;
          const height = (value / 255) * 120;
          
          this.harmonicBars[i].style.height = `${height}px`;
          this.harmonicBars[i].style.opacity = 0.5 + (value / 255) * 0.5;
          
          const hue = (i / barCount) * 60 + 200;
          this.harmonicBars[i].style.background = `linear-gradient(0deg, hsl(${hue}, 70%, 60%), hsl(${hue}, 70%, 80%))`;
        }
      }
      
      createMotionTrail() {
        const trail = document.createElement('div');
        trail.className = 'motion-trail';
        trail.style.left = `${this.physics.position.x}%`;
        trail.style.top = `${this.physics.position.y}%`;
        
        const hue = this.quantum.superposition * 360;
        trail.style.background = `hsl(${hue}, 70%, 60%)`;
        
        this.dom.symphonySpace.appendChild(trail);
        
        this.physics.trail.push({
          x: this.physics.position.x,
          y: this.physics.position.y,
          time: Date.now()
        });
        
        if (this.physics.trail.length > 50) {
          this.physics.trail.shift();
        }
        
        setTimeout(() => trail.remove(), 2000);
      }
    }
    
    // Initialize the engine
    const engine = new QuantumVoidEngine();
  </script>
</body>
</html>
