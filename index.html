<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>Gump</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; width:100%; background:#000; overflow:hidden; touch-action:none; }
canvas { position:fixed; inset:0; }
#tap { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; color:#0ff; font-family:system-ui; font-size:24px; text-align:center; background:rgba(0,0,0,0.8); z-index:10; transition:opacity 1s; }
#tap.hidden { opacity:0; pointer-events:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="tap">Gump<br><br>Tap once.<br>Grant mic & motion.<br>Then breathe, hum, speak, move.<br>The world becomes the song.</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let mic, meter;
let zones = [];
let pos = {x: canvas.width/2, y: canvas.height/2};
let vel = {x:0, y:0};
let accel = {x:0, y:0};
let calib = {x:0, y:0};
let started = false;

const master = new Tone.Gain(0.8).toDestination();
const reverb = new Tone.Reverb({decay:7, wet:0.5}).connect(master);
reverb.generate();

class Zone {
  constructor(x,y,r,color,effectChain) {
    this.x = x; this.y = y; this.r = r; this.color = color;
    this.gain = new Tone.Gain(0);
    this.panner = new Tone.Panner(0).connect(reverb);
    this.chain = effectChain.connect(this.gain).connect(this.panner);
  }
  update(prox, pan, input) {
    this.panner.pan.rampTo(pan, 0.2);
    this.gain.gain.rampTo(prox * (0.4 + input*0.8), 0.2);
  }
  draw() {
    let prox = Math.max(0, 1 - dist(pos.x,pos.y,this.x,this.y)/this.r);
    let pulse = prox > 0 ? 1 + Math.sin(Date.now()*0.01)*0.1*prox : 1;
    ctx.strokeStyle = this.color;
    ctx.lineWidth = 3 + prox*10;
    ctx.globalAlpha = 0.4 + prox*0.6;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r * pulse, 0, Math.PI*2);
    ctx.stroke();
    if (prox > 0.3) {
      ctx.globalAlpha = prox*0.3;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.r*1.5 * pulse, 0, Math.PI*2);
      ctx.stroke();
    }
  }
}

function dist(x1,y1,x2,y2) { return Math.hypot(x1-x2, y1-y2); }

async function start() {
  if (started) return;
  await Tone.start();
  
  if (typeof DeviceMotionEvent?.requestPermission === 'function') {
    await DeviceMotionEvent.requestPermission();
  }
  if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
    await DeviceOrientationEvent.requestPermission();
  }
  
  mic = new Tone.UserMedia();
  await mic.open();
  meter = new Tone.Meter();
  mic.connect(meter);

  zones = [
    new Zone(canvas.width*0.25, canvas.height*0.35, 120, '#0ff', new Tone.PitchShift(-12).connect(new Tone.Filter(300,'lowpass'))),
    new Zone(canvas.width*0.75, canvas.height*0.35, 110, '#f0f', new Tone.PitchShift(7).connect(new Tone.Chorus(6,0.7,0.6))),
    new Zone(canvas.width*0.5, canvas.height*0.65, 140, '#0f8', new Tone.BitCrusher(6).connect(new Tone.Tremolo(10,0.7).start())),
    new Zone(canvas.width*0.3, canvas.height*0.7, 100, '#ff8', new Tone.FeedbackDelay(0.35,0.7).connect(new Tone.Phaser(0.4))),
    new Zone(canvas.width*0.7, canvas.height*0.75, 120, '#f80', new Tone.AutoFilter({frequency:0.2, depth:0.9}).start())
  ];

  mic.fan(...zones.map(z => z.chain));

  window.addEventListener('devicemotion', e => {
    if (e.accelerationIncludingGravity) {
      accel.x = e.accelerationIncludingGravity.x || 0;
      accel.y = e.accelerationIncludingGravity.y || 0;
    }
  });

  calib = {x: accel.x, y: accel.y};

  started = true;
  document.getElementById('tap').classList.add('hidden');
  loop();
}

function loop() {
  ctx.fillStyle = 'rgba(0,0,0,0.07)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const ax = (accel.x - calib.x) * 10;
  const ay = (accel.y - calib.y) * 10;
  vel.x += ax; vel.y += ay;
  vel.x *= 0.94; vel.y *= 0.94;
  pos.x += vel.x; pos.y += vel.y;

  pos.x = Math.max(50, Math.min(canvas.width-50, pos.x));
  pos.y = Math.max(50, Math.min(canvas.height-50, pos.y));

  const input = Math.max(0, meter.getValue() + 40)/40;

  zones.forEach(z => {
    const d = dist(pos.x,pos.y,z.x,z.y);
    const prox = Math.max(0, 1 - d/z.r);
    const pan = (pos.x - z.x)/canvas.width * 2;
    z.update(prox, pan, input);
    z.draw();
  });

  ctx.fillStyle = '#f0f';
  ctx.globalAlpha = 0.8 + input*0.2;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, 20 + input*30, 0, Math.PI*2);
  ctx.fill();

  requestAnimationFrame(loop);
}

document.addEventListener('touchstart', start);
document.addEventListener('click', start);
</script>
</body>
</html>
