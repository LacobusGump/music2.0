<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump - AI DJ</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
            --fib233: 144px;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }

        /* Fibonacci spiral visualization */
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }

        #spiral.active {
            opacity: 0.03;
        }

        /* Ghost title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }

        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }

        /* Start circle - golden ratio proportions */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%, 
                rgba(255,255,255,0.03) 0%, 
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }

        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }

        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }

        /* Main interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }

        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* AI DJ State indicator */
        .ai-state {
            position: fixed;
            top: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib5);
            opacity: 0.618;
            text-align: center;
            transition: all 0.618s ease;
        }

        .ai-state.building {
            color: #ff8c00;
            text-shadow: 0 0 var(--fib13) rgba(255, 140, 0, 0.5);
        }

        .ai-state.dropping {
            color: #ff0000;
            text-shadow: 0 0 var(--fib21) rgba(255, 0, 0, 0.8);
            animation: dropPulse 0.25s ease-in-out infinite;
        }

        .ai-state.void {
            color: #8a2be2;
            text-shadow: 0 0 var(--fib34) rgba(138, 43, 226, 0.8);
        }

        @keyframes dropPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }

        /* Motion indicator */
        .motion-field {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            line-height: var(--phi);
        }

        .motion-value {
            font-size: var(--fib13);
            opacity: 0.618;
        }

        /* Layer counter */
        .layer-counter {
            position: fixed;
            top: var(--fib55);
            right: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.618;
            text-align: right;
        }

        .layer-count {
            font-size: var(--fib21);
            opacity: 0.8;
        }

        /* Ambient recorder indicator */
        .ambient-recorder {
            position: fixed;
            bottom: var(--fib144);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib5);
            letter-spacing: var(--fib3);
            opacity: 0;
            transition: opacity 0.382s ease;
        }

        .ambient-recorder.active {
            opacity: 0.618;
            animation: recordPulse 2s ease-in-out infinite;
        }

        /* Sample slots - 8 slots now for more layers */
        .sample-slots {
            position: fixed;
            bottom: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(8, var(--fib34));
            gap: var(--fib8);
        }

        .sample-slot {
            width: var(--fib34);
            height: var(--fib13);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
            transition: all 0.382s ease;
        }

        .sample-slot.filled {
            border-color: rgba(255,255,255,0.21);
        }

        .sample-slot.playing {
            border-color: rgba(255,255,255,0.55);
            box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.21);
        }

        .sample-slot.ambient {
            background: rgba(138,43,226,0.1);
        }

        /* BPM indicator */
        .bpm-indicator {
            position: fixed;
            bottom: var(--fib55);
            right: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            text-align: right;
        }

        .bpm-value {
            font-size: var(--fib21);
            opacity: 0.618;
        }

        /* Canvas layers */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #spiral { z-index: 1; }
        #visualizer { z-index: 2; opacity: 0.21; }
        #particles { z-index: 3; opacity: 0.34; }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            animation: loading 1.618s ease-in-out infinite;
        }

        @keyframes loading {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.382; }
        }

        /* Build meter */
        .build-meter {
            position: fixed;
            left: var(--fib21);
            top: 50%;
            transform: translateY(-50%);
            width: var(--fib5);
            height: var(--fib233);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            opacity: 0;
            transition: opacity 0.618s ease;
        }

        .build-meter.active {
            opacity: 0.618;
        }

        .build-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000, #ff8c00);
            transition: height 0.382s ease;
        }
    </style>
</head>
<body>
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
    
    <div class="title">Gump by James McCandless</div>
    
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
    
    <div class="interface" id="interface">
        <div class="ai-state" id="aiState">AWAKENING</div>
        
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
        </div>
        
        <div class="layer-counter">
            <div>LAYERS</div>
            <div class="layer-count" id="layerCount">0</div>
        </div>
        
        <div class="ambient-recorder" id="ambientRecorder">LISTENING...</div>
        
        <div class="sample-slots" id="sampleSlots">
            <!-- 8 slots will be created dynamically -->
        </div>
        
        <div class="bpm-indicator">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">128</div>
        </div>
        
        <div class="build-meter" id="buildMeter">
            <div class="build-fill" id="buildFill"></div>
        </div>
    </div>
    
    <div class="loading" id="loading">AWAKENING...</div>

    <script>
        // Gump AI DJ System
        class GumpAIDJ {
            constructor() {
                // Core audio
                this.ctx = null;
                this.masterGain = null;
                this.compressor = null;
                this.limiter = null;
                this.reverb = null;
                this.delay = null;
                this.analyser = null;
                
                // AI DJ State Machine
                this.djState = {
                    phase: 'init', // init, ambient, building, dropping, void
                    layerCount: 0,
                    buildProgress: 0,
                    dropEnergy: 0,
                    voidDepth: 0,
                    transitionTime: 0
                };
                
                // Advanced sampler with 8 slots
                this.sampler = {
                    slots: Array(8).fill(null).map((_, i) => ({
                        id: i,
                        filled: false,
                        buffer: null,
                        analysis: null,
                        player: null,
                        type: null,
                        source: null // 'manual' or 'ambient'
                    })),
                    ambientRecorder: null,
                    isRecording: false,
                    recordBuffer: [],
                    stream: null
                };
                
                // Ambient recording system
                this.ambient = {
                    isListening: false,
                    silenceThreshold: 0.01,
                    recordDuration: { min: 1000, max: 4000 }, // 1-4 seconds
                    cooldown: 3000, // 3 seconds between recordings
                    lastRecordTime: 0,
                    noiseGate: null,
                    captureNode: null
                };
                
                // Musical parameters
                this.bpm = 128; // EDM standard
                this.currentBeat = 0;
                this.barCount = 0;
                this.key = 'F'; // Good for dubstep
                this.scale = [0, 1, 3, 5, 7, 8, 10]; // F minor
                
                // Motion tracking
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: [],
                    intensity: 0,
                    pattern: 'still'
                };
                
                // EDM-specific elements
                this.edm = {
                    sidechain: null,
                    subBass: null,
                    riseFx: null,
                    buildSynth: null,
                    dropBass: null,
                    kickPattern: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
                    buildStartBar: 0,
                    isBuilding: false,
                    hasDropped: false
                };
                
                // Timing
                this.scheduler = {
                    nextNoteTime: 0,
                    scheduleAheadTime: 0.1,
                    lookahead: 25.0,
                    timerId: null
                };
                
                // Visual elements
                this.elements = {};
                this.canvases = {};
                
                this.init();
            }
            
            init() {
                // Cache DOM elements
                ['start', 'interface', 'loading', 'motionValue', 'aiState',
                 'layerCount', 'ambientRecorder', 'bpmValue', 'buildMeter',
                 'buildFill', 'sampleSlots'].forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });
                
                // Create sample slots
                this.createSampleSlots();
                
                // Cache canvases
                ['spiral', 'visualizer', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                });
                
                // Event listeners
                this.elements.start.addEventListener('click', () => this.begin());
                
                // Resize handling
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
                
                // Draw initial spiral
                this.drawFibonacciSpiral();
            }
            
            createSampleSlots() {
                this.elements.sampleSlots.innerHTML = '';
                for (let i = 0; i < 8; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'sample-slot';
                    slot.dataset.index = i;
                    this.elements.sampleSlots.appendChild(slot);
                }
            }
            
            resizeCanvases() {
                Object.values(this.canvases).forEach(({ canvas }) => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
            }
            
            drawFibonacciSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 400;
                
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                
                let a = 0, b = 1;
                let angle = 0;
                
                for (let i = 0; i < 13; i++) {
                    const radius = b * scale;
                    
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(angle) * a * scale,
                        centerY + Math.sin(angle) * a * scale,
                        radius,
                        angle,
                        angle + Math.PI / 2
                    );
                    ctx.stroke();
                    
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                }
            }
            
            async begin() {
                this.elements.loading.style.display = 'block';
                this.elements.start.style.display = 'none';
                
                try {
                    // Request permissions
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                    
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 48000,
                        latencyHint: 'interactive'
                    });
                    await this.ctx.resume();
                    
                    // Get microphone access
                    this.sampler.stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    // Setup everything
                    this.setupAudioChain();
                    this.setupMotionDetection();
                    this.setupAmbientRecording();
                    this.setupEDMElements();
                    
                    // Start interface
                    this.elements.loading.style.display = 'none';
                    this.elements.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');
                    
                    // Initialize AI DJ
                    this.initializeAIDJ();
                    
                    // Start the engine
                    this.startEngine();
                    
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.elements.loading.textContent = 'PERMISSION NEEDED';
                }
            }
            
            setupAudioChain() {
                // Master limiter
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -1;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.05;
                
                // Master compression
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -12;
                this.compressor.knee.value = 2;
                this.compressor.ratio.value = 4;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;
                
                // Master gain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;
                
                // Create reverb
                this.reverb = this.ctx.createConvolver();
                this.createReverbImpulse();
                this.reverbSend = this.ctx.createGain();
                this.reverbSend.gain.value = 0.2;
                
                // Create delay
                this.delay = this.ctx.createDelay(1.0);
                this.delay.delayTime.value = 60 / this.bpm / 8; // 1/8 note delay
                this.delayFeedback = this.ctx.createGain();
                this.delayFeedback.gain.value = 0.4;
                this.delaySend = this.ctx.createGain();
                this.delaySend.gain.value = 0.15;
                
                // High-pass filter for master (clean up low end)
                this.masterHighpass = this.ctx.createBiquadFilter();
                this.masterHighpass.type = 'highpass';
                this.masterHighpass.frequency.value = 20;
                this.masterHighpass.Q.value = 0.7;
                
                // Analyser
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.85;
                
                // Connect delay
                this.delay.connect(this.delayFeedback);
                this.delayFeedback.connect(this.delay);
                this.delay.connect(this.delaySend);
                
                // Master chain
                this.masterGain.connect(this.masterHighpass);
                this.masterHighpass.connect(this.compressor);
                this.compressor.connect(this.limiter);
                this.limiter.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Effect sends
                this.masterGain.connect(this.reverbSend);
                this.reverbSend.connect(this.reverb);
                this.reverb.connect(this.limiter);
                
                this.masterGain.connect(this.delaySend);
                this.delaySend.connect(this.delay);
                this.delaySend.connect(this.limiter);
            }
            
            createReverbImpulse() {
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.3;
                    }
                }
                
                this.reverb.buffer = impulse;
            }
            
            setupMotionDetection() {
                // Device motion
                window.addEventListener('devicemotion', (e) => {
                    if (!e.accelerationIncludingGravity) return;
                    
                    const { x, y, z } = e.accelerationIncludingGravity;
                    const magnitude = Math.sqrt(x * x + y * y + z * z) / 10;
                    this.updateMotion(magnitude);
                });
                
                // Mouse movement fallback
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', (e) => {
                    const now = performance.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                    
                    this.updateMotion(velocity * 10);
                    
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                });
            }
            
            updateMotion(value) {
                this.motion.current = value;
                this.motion.smoothed = this.motion.smoothed * 0.9 + value * 0.1;
                
                this.motion.history.push(this.motion.smoothed);
                if (this.motion.history.length > 60) {
                    this.motion.history.shift();
                }
                
                // Calculate intensity
                const avg = this.motion.history.reduce((a, b) => a + b, 0) / this.motion.history.length;
                this.motion.intensity = Math.min(1, avg / 5);
                
                // Update UI
                this.elements.motionValue.textContent = this.motion.smoothed.toFixed(3);
                
                // AI DJ responds to motion
                this.aiDJRespond();
            }
            
            setupAmbientRecording() {
                // Create input source
                const source = this.ctx.createMediaStreamSource(this.sampler.stream);
                
                // Create noise gate
                this.ambient.noiseGate = this.ctx.createDynamicsCompressor();
                this.ambient.noiseGate.threshold.value = -50;
                this.ambient.noiseGate.knee.value = 0;
                this.ambient.noiseGate.ratio.value = 10;
                this.ambient.noiseGate.attack.value = 0.001;
                this.ambient.noiseGate.release.value = 0.1;
                
                // Create capture node
                this.ambient.captureNode = this.ctx.createScriptProcessor(4096, 1, 1);
                
                // Connect chain
                source.connect(this.ambient.noiseGate);
                this.ambient.noiseGate.connect(this.ambient.captureNode);
                // Don't connect to destination - just capture
                
                // Initialize ambient recorder
                this.sampler.ambientRecorder = {
                    buffer: [],
                    isRecording: false,
                    startTime: 0,
                    targetDuration: 0,
                    silenceTime: 0
                };
                
                // Setup processing
                this.ambient.captureNode.onaudioprocess = (e) => {
                    if (!this.ambient.isListening) return;
                    
                    const inputData = e.inputBuffer.getChannelData(0);
                    this.processAmbientAudio(inputData);
                };
            }
            
            processAmbientAudio(inputData) {
                const recorder = this.sampler.ambientRecorder;
                
                // Calculate RMS
                const rms = Math.sqrt(inputData.reduce((sum, x) => sum + x * x, 0) / inputData.length);
                
                if (!recorder.isRecording) {
                    // Check if we should start recording
                    const now = Date.now();
                    if (rms > this.ambient.silenceThreshold && 
                        now - this.ambient.lastRecordTime > this.ambient.cooldown &&
                        this.djState.layerCount < 8) {
                        
                        // Start recording
                        recorder.isRecording = true;
                        recorder.buffer = [];
                        recorder.startTime = now;
                        recorder.targetDuration = this.ambient.recordDuration.min + 
                            Math.random() * (this.ambient.recordDuration.max - this.ambient.recordDuration.min);
                        recorder.silenceTime = 0;
                        
                        this.elements.ambientRecorder.classList.add('active');
                    }
                } else {
                    // We're recording
                    recorder.buffer.push(...inputData);
                    
                    // Check for silence
                    if (rms < this.ambient.silenceThreshold) {
                        recorder.silenceTime += 4096 / this.ctx.sampleRate * 1000;
                    } else {
                        recorder.silenceTime = 0;
                    }
                    
                    const elapsed = Date.now() - recorder.startTime;
                    
                    // Stop if we've recorded enough or too much silence
                    if (elapsed >= recorder.targetDuration || recorder.silenceTime > 500) {
                        this.stopAmbientRecording();
                    }
                }
            }
            
            async stopAmbientRecording() {
                const recorder = this.sampler.ambientRecorder;
                recorder.isRecording = false;
                this.ambient.lastRecordTime = Date.now();
                this.elements.ambientRecorder.classList.remove('active');
                
                // Process the recorded audio
                if (recorder.buffer.length > this.ctx.sampleRate * 0.1) {
                    await this.processAmbientSample(new Float32Array(recorder.buffer));
                }
            }
            
            async processAmbientSample(audioData) {
                // Create buffer
                const buffer = this.ctx.createBuffer(1, audioData.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(audioData);
                
                // Analyze
                const analysis = await this.analyzeAudio(audioData, buffer);
                
                // Find empty slot
                let targetSlot = -1;
                for (let i = 0; i < 8; i++) {
                    if (!this.sampler.slots[i].filled) {
                        targetSlot = i;
                        break;
                    }
                }
                
                if (targetSlot === -1) return; // No empty slots
                
                // Process for musical use
                const processedBuffer = await this.processForMusicalUse(buffer, analysis);
                
                // Store in slot
                const slot = this.sampler.slots[targetSlot];
                slot.filled = true;
                slot.buffer = processedBuffer;
                slot.analysis = analysis;
                slot.source = 'ambient';
                slot.type = this.categorizeAmbientSound(analysis);
                
                // Create player
                slot.player = this.createPlayer(targetSlot, slot.type, analysis);
                
                // Update UI
                const slotElement = document.querySelectorAll('.sample-slot')[targetSlot];
                slotElement.classList.add('filled', 'ambient');
                
                // Update layer count
                this.djState.layerCount++;
                this.elements.layerCount.textContent = this.djState.layerCount;
                
                // AI DJ evolves the arrangement
                this.evolveArrangement();
            }
            
            async analyzeAudio(data, buffer) {
                const analysis = {
                    duration: buffer.duration,
                    rms: 0,
                    peak: 0,
                    spectralCentroid: 0,
                    zeroCrossings: 0,
                    tempo: null,
                    pitch: null,
                    brightness: 0,
                    roughness: 0
                };
                
                // Basic analysis
                analysis.peak = Math.max(...data.map(Math.abs));
                analysis.rms = Math.sqrt(data.reduce((sum, x) => sum + x * x, 0) / data.length);
                
                // Zero crossings
                for (let i = 1; i < data.length; i++) {
                    if ((data[i-1] >= 0) !== (data[i] >= 0)) {
                        analysis.zeroCrossings++;
                    }
                }
                
                // Spectral analysis using offline context
                try {
                    const offlineCtx = new OfflineAudioContext(1, buffer.length, this.ctx.sampleRate);
                    const source = offlineCtx.createBufferSource();
                    source.buffer = buffer;
                    
                    const analyser = offlineCtx.createAnalyser();
                    analyser.fftSize = 2048;
                    
                    source.connect(analyser);
                    analyser.connect(offlineCtx.destination);
                    source.start();
                    
                    await offlineCtx.startRendering();
                    
                    const freqData = new Float32Array(analyser.frequencyBinCount);
                    analyser.getFloatFrequencyData(freqData);
                    
                    // Spectral centroid
                    let weightedSum = 0;
                    let magnitudeSum = 0;
                    for (let i = 0; i < freqData.length; i++) {
                        const magnitude = Math.pow(10, freqData[i] / 20);
                        const frequency = (i * this.ctx.sampleRate) / (analyser.fftSize);
                        weightedSum += magnitude * frequency;
                        magnitudeSum += magnitude;
                    }
                    analysis.spectralCentroid = weightedSum / (magnitudeSum || 1);
                    analysis.brightness = Math.min(1, analysis.spectralCentroid / 4000);
                    
                } catch (e) {
                    console.warn('Spectral analysis failed:', e);
                }
                
                // Roughness estimation
                analysis.roughness = Math.min(1, analysis.zeroCrossings / (data.length * 0.5));
                
                return analysis;
            }
            
            categorizeAmbientSound(analysis) {
                // Smart categorization for ambient sounds
                if (analysis.roughness > 0.7) return 'texture';
                if (analysis.spectralCentroid < 300) return 'sub';
                if (analysis.spectralCentroid > 3000) return 'hi';
                if (analysis.duration < 0.5) return 'hit';
                if (analysis.duration > 2) return 'pad';
                return 'mid';
            }
            
            async processForMusicalUse(buffer, analysis) {
                // Clone buffer
                const processed = this.ctx.createBuffer(
                    buffer.numberOfChannels,
                    buffer.length,
                    buffer.sampleRate
                );
                
                for (let ch = 0; ch < buffer.numberOfChannels; ch++) {
                    processed.copyToChannel(buffer.getChannelData(ch), ch);
                }
                
                // Apply fade in/out
                const data = processed.getChannelData(0);
                const fadeLength = Math.min(1000, data.length * 0.1);
                
                for (let i = 0; i < fadeLength; i++) {
                    data[i] *= i / fadeLength;
                    data[data.length - 1 - i] *= i / fadeLength;
                }
                
                // Normalize
                const maxVal = Math.max(...data.map(Math.abs));
                if (maxVal > 0) {
                    const scale = 0.8 / maxVal;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= scale;
                    }
                }
                
                return processed;
            }
            
            createPlayer(slotIndex, type, analysis) {
                return {
                    slotIndex,
                    type,
                    analysis,
                    isPlaying: false,
                    pattern: this.generatePattern(type),
                    gain: 0.7,
                    filter: { freq: 1000, q: 1 },
                    pan: (slotIndex - 3.5) * 0.2 // Stereo spread
                };
            }
            
            generatePattern(type) {
                // Generate rhythmic patterns based on type
                const patterns = {
                    texture: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                    sub:     [1,0,0,0, 0,0,1,0, 0,0,0,0, 1,0,0,0],
                    hi:      [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                    hit:     [1,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],
                    pad:     [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
                    mid:     [0,0,0,1, 0,0,1,0, 0,1,0,0, 1,0,0,0]
                };
                
                return patterns[type] || patterns.mid;
            }
            
            setupEDMElements() {
                // Sidechain compressor
                this.edm.sidechain = this.ctx.createDynamicsCompressor();
                this.edm.sidechain.threshold.value = -20;
                this.edm.sidechain.knee.value = 0;
                this.edm.sidechain.ratio.value = 8;
                this.edm.sidechain.attack.value = 0.001;
                this.edm.sidechain.release.value = 0.1;
                
                // Connect sidechain to master
                this.edm.sidechain.connect(this.masterGain);
            }
            
            initializeAIDJ() {
                this.djState.phase = 'ambient';
                this.elements.aiState.textContent = 'LISTENING';
                
                // Start ambient recording
                this.ambient.isListening = true;
            }
            
            aiDJRespond() {
                // AI DJ responds to motion and adjusts the mix
                if (this.djState.phase === 'dropping' || this.djState.phase === 'void') {
                    // Modulate effects based on motion during intense phases
                    const intensity = this.motion.intensity;
                    
                    if (this.edm.dropBass) {
                        this.edm.dropBass.filterFreq = 100 + intensity * 400;
                    }
                    
                    // Adjust reverb send
                    this.reverbSend.gain.value = 0.2 + intensity * 0.3;
                }
            }
            
            evolveArrangement() {
                // AI DJ evolves based on layer count
                const layers = this.djState.layerCount;
                
                if (layers >= 2 && this.djState.phase === 'ambient') {
                    // Start building
                    this.startBuild();
                } else if (layers >= 4 && this.djState.phase === 'building') {
                    // Check if ready to drop
                    if (this.barCount - this.edm.buildStartBar >= 8) {
                        this.executeDrop();
                    }
                } else if (layers >= 6 && this.djState.phase === 'dropping') {
                    // Transition to void
                    if (this.barCount % 16 === 0) {
                        this.enterVoid();
                    }
                }
            }
            
            startBuild() {
                this.djState.phase = 'building';
                this.edm.isBuilding = true;
                this.edm.buildStartBar = this.barCount;
                
                this.elements.aiState.textContent = 'BUILDING ENERGY';
                this.elements.aiState.className = 'ai-state building';
                this.elements.buildMeter.classList.add('active');
                
                // Create build synth
                this.createBuildElements();
                
                // Gradually increase tempo
                this.targetBPM = 140;
            }
            
            createBuildElements() {
                // Rising sweep synth
                const startTime = this.ctx.currentTime;
                const buildDuration = 8 * (60 / this.bpm); // 8 bars
                
                // White noise riser
                const noise = this.ctx.createBufferSource();
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = Math.random() * 2 - 1;
                }
                noise.buffer = noiseBuffer;
                noise.loop = true;
                
                const noiseFilter = this.ctx.createBiquadFilter();
                noiseFilter.type = 'highpass';
                noiseFilter.frequency.setValueAtTime(100, startTime);
                noiseFilter.frequency.exponentialRampToValueAtTime(8000, startTime + buildDuration);
                
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.setValueAtTime(0, startTime);
                noiseGain.gain.linearRampToValueAtTime(0.3, startTime + buildDuration);
                
                noise.connect(noiseFilter);
                noiseFilter.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                
                noise.start(startTime);
                noise.stop(startTime + buildDuration);
                
                // Sub bass build
                const subOsc = this.ctx.createOscillator();
                subOsc.type = 'sine';
                subOsc.frequency.value = 55; // Low A
                
                const subGain = this.ctx.createGain();
                subGain.gain.setValueAtTime(0, startTime);
                subGain.gain.linearRampToValueAtTime(0.5, startTime + buildDuration);
                
                subOsc.connect(subGain);
                subGain.connect(this.masterGain);
                
                subOsc.start(startTime);
                subOsc.stop(startTime + buildDuration);
                
                // Store reference
                this.edm.buildSynth = { noise, subOsc, endTime: startTime + buildDuration };
            }
            
            executeDrop() {
                this.djState.phase = 'dropping';
                this.edm.hasDropped = true;
                
                this.elements.aiState.textContent = 'DROP IT!';
                this.elements.aiState.className = 'ai-state dropping';
                this.elements.buildMeter.classList.remove('active');
                
                // Create massive dubstep bass
                this.createDubstepBass();
                
                // Add impact
                this.createDropImpact();
                
                // Change all patterns to be more aggressive
                this.sampler.slots.forEach(slot => {
                    if (slot.filled && slot.player) {
                        // Make patterns more dense
                        slot.player.pattern = slot.player.pattern.map((step, i) => 
                            i % 2 === 0 ? 1 : Math.random() > 0.5 ? 1 : 0
                        );
                    }
                });
            }
            
            createDubstepBass() {
                // Wobble bass engine
                this.edm.dropBass = {
                    osc1: null,
                    osc2: null,
                    filter: null,
                    gain: null,
                    lfo: null,
                    filterFreq: 200,
                    wobbleRate: 4, // Start with quarter notes
                    isPlaying: false
                };
                
                // This will be triggered on the beat
            }
            
            playDubstepBass(when) {
                const bass = this.edm.dropBass;
                if (bass.isPlaying) return;
                
                // Two detuned oscillators
                bass.osc1 = this.ctx.createOscillator();
                bass.osc2 = this.ctx.createOscillator();
                bass.osc1.type = 'sawtooth';
                bass.osc2.type = 'sawtooth';
                bass.osc1.frequency.value = 55; // Low A
                bass.osc2.frequency.value = 55.5; // Slight detune
                
                // Filter with LFO modulation
                bass.filter = this.ctx.createBiquadFilter();
                bass.filter.type = 'lowpass';
                bass.filter.Q.value = 10;
                
                // LFO for wobble
                bass.lfo = this.ctx.createOscillator();
                bass.lfo.frequency.value = bass.wobbleRate;
                
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = bass.filterFreq;
                
                bass.lfo.connect(lfoGain);
                lfoGain.connect(bass.filter.frequency);
                
                // Gain with sidechain ducking
                bass.gain = this.ctx.createGain();
                bass.gain.gain.value = 0.6;
                
                // Connect
                bass.osc1.connect(bass.filter);
                bass.osc2.connect(bass.filter);
                bass.filter.connect(bass.gain);
                bass.gain.connect(this.edm.sidechain);
                
                // Start
                const now = when || this.ctx.currentTime;
                bass.osc1.start(now);
                bass.osc2.start(now);
                bass.lfo.start(now);
                
                bass.isPlaying = true;
                
                // Modulate wobble rate over time
                setTimeout(() => {
                    if (bass.lfo) bass.lfo.frequency.value = 8; // 8th notes
                }, 4000);
                
                setTimeout(() => {
                    if (bass.lfo) bass.lfo.frequency.value = 16; // 16th notes
                }, 8000);
            }
            
            createDropImpact() {
                const now = this.ctx.currentTime;
                
                // Sub drop
                const sub = this.ctx.createOscillator();
                sub.type = 'sine';
                sub.frequency.setValueAtTime(80, now);
                sub.frequency.exponentialRampToValueAtTime(30, now + 1);
                
                const subGain = this.ctx.createGain();
                subGain.gain.setValueAtTime(1, now);
                subGain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                
                sub.connect(subGain);
                subGain.connect(this.masterGain);
                
                sub.start(now);
                sub.stop(now + 1);
                
                // White noise hit
                const noise = this.ctx.createBufferSource();
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * (1 - i / noiseData.length);
                }
                noise.buffer = noiseBuffer;
                
                const noiseGain = this.ctx.createGain();
                noiseGain.gain.value = 0.5;
                
                noise.connect(noiseGain);
                noiseGain.connect(this.masterGain);
                
                noise.start(now);
            }
            
            enterVoid() {
                this.djState.phase = 'void';
                
                this.elements.aiState.textContent = 'ENTERING THE VOID';
                this.elements.aiState.className = 'ai-state void';
                
                // Stop dubstep bass
                if (this.edm.dropBass && this.edm.dropBass.isPlaying) {
                    const now = this.ctx.currentTime;
                    this.edm.dropBass.gain.gain.exponentialRampToValueAtTime(0.01, now + 2);
                    setTimeout(() => {
                        if (this.edm.dropBass.osc1) this.edm.dropBass.osc1.stop();
                        if (this.edm.dropBass.osc2) this.edm.dropBass.osc2.stop();
                        if (this.edm.dropBass.lfo) this.edm.dropBass.lfo.stop();
                        this.edm.dropBass.isPlaying = false;
                    }, 2000);
                }
                
                // Make everything dark and creepy
                this.reverbSend.gain.value = 0.6;
                this.delaySend.gain.value = 0.4;
                this.masterHighpass.frequency.value = 80;
                
                // Slow down patterns
                this.sampler.slots.forEach(slot => {
                    if (slot.filled && slot.player) {
                        // Sparse, creepy patterns
                        slot.player.pattern = Array(16).fill(0).map((_, i) => 
                            Math.random() > 0.8 ? 1 : 0
                        );
                        
                        // Lower pitch
                        slot.player.pitchShift = -12; // Octave down
                    }
                });
                
                // Add void ambience
                this.createVoidAmbience();
            }
            
            createVoidAmbience() {
                // Dark drone
                const drone = this.ctx.createOscillator();
                drone.type = 'triangle';
                drone.frequency.value = 27.5; // Low A
                
                const droneFilter = this.ctx.createBiquadFilter();
                droneFilter.type = 'lowpass';
                droneFilter.frequency.value = 200;
                droneFilter.Q.value = 5;
                
                const droneGain = this.ctx.createGain();
                droneGain.gain.value = 0.2;
                
                // Add slow modulation
                const lfo = this.ctx.createOscillator();
                lfo.type = 'sine';
                lfo.frequency.value = 0.1; // Very slow
                
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 50;
                
                lfo.connect(lfoGain);
                lfoGain.connect(droneFilter.frequency);
                
                drone.connect(droneFilter);
                droneFilter.connect(droneGain);
                droneGain.connect(this.reverb);
                droneGain.connect(this.masterGain);
                
                const now = this.ctx.currentTime;
                drone.start(now);
                lfo.start(now);
            }
            
            startEngine() {
                // Start scheduler
                this.startScheduler();
                
                // Start visualizations
                this.animate();
            }
            
            startScheduler() {
                const scheduleNotes = () => {
                    while (this.scheduler.nextNoteTime < this.ctx.currentTime + this.scheduler.scheduleAheadTime) {
                        this.scheduleStep();
                        this.nextStep();
                    }
                    this.scheduler.timerId = setTimeout(scheduleNotes, this.scheduler.lookahead);
                };
                
                this.scheduler.nextNoteTime = this.ctx.currentTime;
                scheduleNotes();
            }
            
            scheduleStep() {
                const stepTime = this.scheduler.nextNoteTime;
                const currentStep = this.currentBeat % 16;
                
                // Kick on the beat during drop
                if (this.djState.phase === 'dropping' && currentStep % 4 === 0) {
                    this.playKick(stepTime);
                    this.sidechainDuck(stepTime);
                }
                
                // Play dubstep bass
                if (this.djState.phase === 'dropping' && this.edm.dropBass && !this.edm.dropBass.isPlaying) {
                    this.playDubstepBass(stepTime);
                }
                
                // Play samples
                this.sampler.slots.forEach((slot, index) => {
                    if (slot.filled && slot.player && slot.player.pattern[currentStep]) {
                        this.playSlot(index, stepTime);
                    }
                });
                
                // Update build progress
                if (this.djState.phase === 'building') {
                    const progress = Math.min(1, (this.barCount - this.edm.buildStartBar) / 8);
                    this.djState.buildProgress = progress;
                    this.elements.buildFill.style.height = `${progress * 100}%`;
                }
            }
            
            playKick(when) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                
                osc.type = 'sine';
                osc.frequency.setValueAtTime(60, when);
                osc.frequency.exponentialRampToValueAtTime(30, when + 0.1);
                
                gain.gain.setValueAtTime(1, when);
                gain.gain.exponentialRampToValueAtTime(0.01, when + 0.2);
                
                osc.connect(gain);
                gain.connect(this.masterGain);
                
                osc.start(when);
                osc.stop(when + 0.2);
            }
            
            sidechainDuck(when) {
                // Duck the sidechain compressor
                const reduction = this.ctx.createGain();
                reduction.gain.setValueAtTime(1, when);
                reduction.gain.linearRampToValueAtTime(0.2, when + 0.01);
                reduction.gain.linearRampToValueAtTime(1, when + 0.1);
                
                // This would connect to sidechain control
            }
            
            playSlot(index, when) {
                const slot = this.sampler.slots[index];
                if (!slot.buffer) return;
                
                const source = this.ctx.createBufferSource();
                source.buffer = slot.buffer;
                
                // Pitch shift for void
                if (slot.player.pitchShift) {
                    source.playbackRate.value = Math.pow(2, slot.player.pitchShift / 12);
                }
                
                const gain = this.ctx.createGain();
                gain.gain.value = slot.player.gain * (1 - this.djState.voidDepth * 0.5);
                
                // Panning
                const panner = this.ctx.createStereoPanner();
                panner.pan.value = slot.player.pan;
                
                // Filter
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = slot.player.filter.freq;
                filter.Q.value = slot.player.filter.q;
                
                // Connect
                source.connect(filter);
                filter.connect(panner);
                panner.connect(gain);
                
                // Route based on phase
                if (this.djState.phase === 'dropping') {
                    gain.connect(this.edm.sidechain);
                } else {
                    gain.connect(this.masterGain);
                }
                
                source.start(when);
                
                // Visual feedback
                const slotElement = document.querySelectorAll('.sample-slot')[index];
                slotElement.classList.add('playing');
                setTimeout(() => slotElement.classList.remove('playing'), 100);
            }
            
            nextStep() {
                const secondsPerBeat = 60.0 / this.bpm / 4; // 16th notes
                this.scheduler.nextNoteTime += secondsPerBeat;
                
                this.currentBeat++;
                if (this.currentBeat % 16 === 0) {
                    this.barCount++;
                }
            }
            
            animate() {
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    this.drawVisualizer();
                    this.drawParticles();
                };
                
                draw();
            }
            
            drawVisualizer() {
                const { ctx, canvas } = this.canvases.visualizer;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                
                this.analyser.getByteFrequencyData(dataArray);
                
                // Different visual styles for different phases
                const fadeAlpha = this.djState.phase === 'void' ? 0.02 : 0.1;
                ctx.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / bufferLength * 2.5;
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const barHeight = (dataArray[i] / 255) * canvas.height * 0.7;
                    
                    let hue, saturation, lightness;
                    
                    switch (this.djState.phase) {
                        case 'ambient':
                            hue = 200 + (i / bufferLength) * 60;
                            saturation = 50;
                            lightness = 50;
                            break;
                        case 'building':
                            hue = 30 + (i / bufferLength) * 30;
                            saturation = 70 + this.djState.buildProgress * 30;
                            lightness = 50;
                            break;
                        case 'dropping':
                            hue = (i / bufferLength) * 360 + this.currentBeat * 10;
                            saturation = 100;
                            lightness = 50;
                            break;
                        case 'void':
                            hue = 270 + (i / bufferLength) * 30;
                            saturation = 80;
                            lightness = 20 + (dataArray[i] / 255) * 30;
                            break;
                        default:
                            hue = 0;
                            saturation = 0;
                            lightness = 50;
                    }
                    
                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
                    ctx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    
                    x += barWidth + 1;
                }
            }
            
            drawParticles() {
                const { ctx, canvas } = this.canvases.particles;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const time = Date.now() * 0.001;
                let particleCount, particleSize, speed;
                
                switch (this.djState.phase) {
                    case 'ambient':
                        particleCount = 5;
                        particleSize = 1;
                        speed = 0.05;
                        break;
                    case 'building':
                        particleCount = 8 + Math.floor(this.djState.buildProgress * 13);
                        particleSize = 1 + this.djState.buildProgress * 2;
                        speed = 0.1 + this.djState.buildProgress * 0.2;
                        break;
                    case 'dropping':
                        particleCount = 34;
                        particleSize = 3;
                        speed = 0.5;
                        break;
                    case 'void':
                        particleCount = 13;
                        particleSize = 2;
                        speed = 0.02;
                        break;
                    default:
                        particleCount = 8;
                        particleSize = 1;
                        speed = 0.1;
                }
                
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2 + time * speed;
                    const radius = 100 + Math.sin(time + i) * 50 + this.motion.smoothed * 100;
                    
                    const x = canvas.width / 2 + Math.cos(angle) * radius;
                    const y = canvas.height / 2 + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, particleSize, 0, Math.PI * 2);
                    
                    const alpha = 0.3 + this.motion.intensity * 0.5;
                    
                    if (this.djState.phase === 'void') {
                        ctx.fillStyle = `rgba(138, 43, 226, ${alpha})`;
                    } else {
                        ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
                    }
                    
                    ctx.fill();
                }
            }
        }
        
        // Initialize
        const gumpDJ = new GumpAIDJ();
    </script>
</body>
</html>
