<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Spatial AI Music</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 40% 60%, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
    }
    
    .app { width: 100%; max-width: 400px; padding: 20px; text-align: center; }
    
    .logo {
      font-size: clamp(3rem, 12vw, 6rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      animation: pulse 3s ease-in-out infinite;
    }
    
    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }
    
    .tagline { font-size: 1.2rem; opacity: 0.8; margin-bottom: 3rem; font-weight: 300; }
    
    .btn {
      padding: 20px 40px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 30px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(0,255,170,0.3);
      margin: 10px;
    }
    
    .btn:hover { transform: translateY(-3px); box-shadow: 0 15px 40px rgba(0,255,170,0.5); }
    
    .viz {
      width: 100%;
      height: 250px;
      border: 2px solid rgba(0,255,170,0.2);
      border-radius: 20px;
      position: relative;
      background: rgba(0,255,170,0.03);
      margin: 20px 0;
      overflow: hidden;
    }
    
    .orb {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffaa, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
      box-shadow: 0 0 30px rgba(0,255,170,0.5);
    }
    
    .instrument {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1), transparent);
      border: 2px solid rgba(255,255,255,0.2);
      opacity: 0;
      transition: all 0.8s ease;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.2rem;
      color: rgba(255,255,255,0.8);
    }
    
    .instrument.active {
      opacity: 0.9;
      transform: scale(1.2);
      box-shadow: 0 0 20px rgba(255,255,255,0.4);
    }
    
    .instrument.drums { top: 20%; left: 20%; background: radial-gradient(circle, rgba(255,0,0,0.3), transparent); }
    .instrument.bass { top: 20%; right: 20%; background: radial-gradient(circle, rgba(0,255,0,0.3), transparent); }
    .instrument.lead { bottom: 20%; left: 20%; background: radial-gradient(circle, rgba(0,0,255,0.3), transparent); }
    .instrument.pad { bottom: 20%; right: 20%; background: radial-gradient(circle, rgba(255,255,0,0.3), transparent); }
    .instrument.melody { top: 50%; left: 10%; background: radial-gradient(circle, rgba(255,0,255,0.3), transparent); }
    .instrument.fx { top: 50%; right: 10%; background: radial-gradient(circle, rgba(0,255,255,0.3), transparent); }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin: 20px 0;
    }
    
    .stat {
      background: rgba(0,255,170,0.1);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(0,255,170,0.2);
    }
    
    .stat-value { font-size: 1.3rem; font-weight: 700; color: #00ffaa; }
    .stat-label { font-size: 0.7rem; opacity: 0.7; margin-top: 3px; }
    
    .hidden { display: none !important; }
    
    .void {
      background: radial-gradient(circle at 60% 40%, #0a0014 0%, #1a0f2e 40%, #2e1a3e 100%);
      color: #ff88cc;
    }
    
    .void .logo {
      background: linear-gradient(45deg, #ff88cc, #88aaff, #ccaa88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .energy {
      animation: energyPulse 0.5s ease-in-out infinite;
    }
    
    @keyframes energyPulse { 0%, 100% { filter: brightness(1); } 50% { filter: brightness(1.3); } }
  </style>
</head>
<body>
  <div class="app">
    <div class="logo">GUMP</div>
    <div class="tagline">Spatial AI Music</div>
    
    <button class="btn" id="start">üéµ Start Journey</button>
    <button class="btn hidden" id="stop">‚èπ Stop</button>
    
    <div class="viz hidden" id="viz">
      <div class="orb" id="orb"></div>
      <div class="instrument drums" id="drums">ü•Å</div>
      <div class="instrument bass" id="bass">üé∏</div>
      <div class="instrument lead" id="lead">üéπ</div>
      <div class="instrument pad" id="pad">üéª</div>
      <div class="instrument melody" id="melody">üé∫</div>
      <div class="instrument fx" id="fx">‚ú®</div>
    </div>
    
    <div class="stats hidden" id="stats">
      <div class="stat">
        <div class="stat-value" id="motion">0</div>
        <div class="stat-label">Motion</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="layers">0</div>
        <div class="stat-label">Layers</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="harmony">0</div>
        <div class="stat-label">Harmony</div>
      </div>
    </div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.motion = 0;
        this.pos = { x: 50, y: 50 };
        this.lastMove = Date.now();
        this.motionHistory = [];
        this.totalMotion = 0;
        this.activeLayers = 0;
        this.harmony = 0;
        
        this.instruments = {
          drums: { 
            active: false, 
            threshold: 10, 
            osc: null, 
            gain: null, 
            type: 'kick',
            prompt: 'minimal techno kick drum pattern, deep bass, steady rhythm'
          },
          bass: { 
            active: false, 
            threshold: 25, 
            osc: null, 
            gain: null, 
            type: 'bass',
            prompt: 'deep bass line, sub frequencies, electronic groove'
          },
          lead: { 
            active: false, 
            threshold: 40, 
            osc: null, 
            gain: null, 
            type: 'lead',
            prompt: 'synthesizer lead melody, bright arpeggios, cutting through mix'
          },
          pad: { 
            active: false, 
            threshold: 55, 
            osc: null, 
            gain: null, 
            type: 'pad',
            prompt: 'ambient pad chords, atmospheric, warm sustained tones'
          },
          melody: { 
            active: false, 
            threshold: 70, 
            osc: null, 
            gain: null, 
            type: 'melody',
            prompt: 'melodic sequence, catchy hook, emotional progression'
          },
          fx: { 
            active: false, 
            threshold: 85, 
            osc: null, 
            gain: null, 
            type: 'fx',
            prompt: 'ambient textures, reverb swells, spatial effects'
          }
        };
        
        this.audioElements = {};
        this.generatedAudio = {};
        this.apiKeys = {
          suno: 'your-suno-api-key',
          musiclm: 'your-google-api-key'
        };
        
        this.init();
      }
      
      init() {
        document.getElementById('start').onclick = () => this.start();
        document.getElementById('stop').onclick = () => this.stop();
      }
      
      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') throw new Error('Permission denied');
          }
          
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          
          this.active = true;
          this.show(['viz', 'stats', 'stop']);
          this.hide(['start']);
          
          this.startSensors();
          this.startEngine();
          this.animate();
          
        } catch (e) {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.active = true;
          this.show(['viz', 'stats', 'stop']);
          this.hide(['start']);
          this.startDesktopMode();
          this.startEngine();
          this.animate();
        }
      }
      
      startDesktopMode() {
        const viz = document.getElementById('viz');
        viz.addEventListener('mousemove', e => {
          if (!this.active) return;
          const rect = viz.getBoundingClientRect();
          this.pos.x = ((e.clientX - rect.left) / rect.width) * 100;
          this.pos.y = ((e.clientY - rect.top) / rect.height) * 100;
          this.motion = Math.random() * 50 + 20;
          this.lastMove = Date.now();
          this.updateMotionHistory();
        });
      }
      
      stop() {
        this.active = false;
        this.show(['start']);
        this.hide(['viz', 'stats', 'stop']);
        
        Object.values(this.audioElements).forEach(audio => {
          if (audio) {
            audio.pause();
            audio.currentTime = 0;
          }
        });
        
        this.resetInstruments();
        document.body.className = '';
      }
      
      resetInstruments() {
        Object.keys(this.instruments).forEach(key => {
          this.instruments[key].active = false;
          document.getElementById(key).classList.remove('active');
        });
        this.activeLayers = 0;
      }
      
      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          
          const motion = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
          this.motion = Math.min(100, motion * 8);
          
          if (this.motion > 3) this.lastMove = Date.now();
          
          this.pos.x = Math.max(5, Math.min(95, 50 + acc.x * 4));
          this.pos.y = Math.max(5, Math.min(95, 50 + acc.y * 4));
          
          this.updateMotionHistory();
        });
      }
      
      updateMotionHistory() {
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 50) this.motionHistory.shift();
        
        this.totalMotion = this.motionHistory.reduce((a, b) => a + b, 0);
        this.harmony = Math.min(100, this.totalMotion / 10);
      }
      
      startEngine() {
        const update = () => {
          if (!this.active) return;
          
          this.updateInstruments();
          this.updateState();
          
          setTimeout(update, 200);
        };
        update();
      }
      
      async updateInstruments() {
        let newActiveLayers = 0;
        
        for (const [key, instrument] of Object.entries(this.instruments)) {
          const shouldActivate = this.totalMotion > instrument.threshold;
          
          if (shouldActivate && !instrument.active) {
            instrument.active = true;
            document.getElementById(key).classList.add('active');
            await this.activateInstrument(key);
            newActiveLayers++;
          } else if (!shouldActivate && instrument.active) {
            instrument.active = false;
            document.getElementById(key).classList.remove('active');
            this.deactivateInstrument(key);
          } else if (instrument.active) {
            newActiveLayers++;
          }
        }
        
        this.activeLayers = newActiveLayers;
      }
      
      async activateInstrument(instrumentKey) {
        const instrument = this.instruments[instrumentKey];
        
        if (!this.generatedAudio[instrumentKey]) {
          try {
            const audioUrl = await this.generateAIAudio(instrument.prompt);
            if (audioUrl) {
              this.generatedAudio[instrumentKey] = audioUrl;
              this.playInstrument(instrumentKey, audioUrl);
            } else {
              this.playFallbackInstrument(instrumentKey);
            }
          } catch (e) {
            this.playFallbackInstrument(instrumentKey);
          }
        } else {
          this.playInstrument(instrumentKey, this.generatedAudio[instrumentKey]);
        }
      }
      
      async generateAIAudio(prompt) {
        const services = [
          () => this.callSunoAPI(prompt),
          () => this.callMusicLMAPI(prompt),
          () => this.callMuBertAPI(prompt)
        ];
        
        for (const service of services) {
          try {
            const result = await service();
            if (result) return result;
          } catch (e) {
            console.warn('AI service failed:', e.message);
          }
        }
        
        return null;
      }
      
      async callSunoAPI(prompt) {
        const response = await fetch('https://api.suno.ai/v1/generate', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKeys.suno}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            prompt: prompt,
            duration: 8,
            format: 'mp3',
            loop: true
          })
        });
        
        if (!response.ok) throw new Error('Suno API failed');
        const data = await response.json();
        return data.audio_url;
      }
      
      async callMusicLMAPI(prompt) {
        const response = await fetch('https://api.google.com/musiclm/v1/generate', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.apiKeys.musiclm}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            text: prompt,
            length: 8,
            continuation: true
          })
        });
        
        if (!response.ok) throw new Error('MusicLM API failed');
        const data = await response.json();
        return data.audio_url;
      }
      
      async callMuBertAPI(prompt) {
        const response = await fetch('https://api.mubert.com/v2/generate', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            method: 'generate',
            params: {
              prompt: prompt,
              duration: 8,
              format: 'mp3',
              loop: true
            }
          })
        });
        
        if (!response.ok) throw new Error('Mubert API failed');
        const data = await response.json();
        return data.result.audio_url;
      }
      
      playInstrument(instrumentKey, audioUrl) {
        if (!this.audioElements[instrumentKey]) {
          this.audioElements[instrumentKey] = new Audio();
          this.audioElements[instrumentKey].loop = true;
          this.audioElements[instrumentKey].volume = 0.6;
        }
        
        const audio = this.audioElements[instrumentKey];
        audio.src = audioUrl;
        audio.play().catch(e => {
          console.warn('Audio play failed:', e);
          this.playFallbackInstrument(instrumentKey);
        });
      }
      
      playFallbackInstrument(instrumentKey) {
        const instrument = this.instruments[instrumentKey];
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        const freqs = {
          drums: 60,
          bass: 80,
          lead: 440,
          pad: 220,
          melody: 330,
          fx: 880
        };
        
        osc.frequency.value = freqs[instrumentKey] || 440;
        osc.type = instrumentKey === 'drums' ? 'square' : 
                   instrumentKey === 'bass' ? 'sawtooth' : 
                   instrumentKey === 'fx' ? 'sine' : 'triangle';
        
        gain.gain.value = 0.1;
        
        osc.connect(gain).connect(this.ctx.destination);
        osc.start();
        
        instrument.osc = osc;
        instrument.gain = gain;
        
        setTimeout(() => {
          if (instrument.osc) {
            instrument.osc.stop();
            instrument.osc = null;
          }
        }, 8000);
      }
      
      deactivateInstrument(instrumentKey) {
        const audio = this.audioElements[instrumentKey];
        if (audio) {
          audio.pause();
        }
        
        const instrument = this.instruments[instrumentKey];
        if (instrument.osc) {
          instrument.osc.stop();
          instrument.osc = null;
        }
      }
      
      updateState() {
        const stillTime = Date.now() - this.lastMove;
        const isVoid = stillTime > 5000;
        const hasEnergy = this.motion > 60;
        
        document.body.classList.toggle('void', isVoid);
        document.body.classList.toggle('energy', hasEnergy);
        
        document.getElementById('motion').textContent = Math.round(this.motion);
        document.getElementById('layers').textContent = this.activeLayers;
        document.getElementById('harmony').textContent = Math.round(this.harmony);
      }
      
      animate() {
        const update = () => {
          if (!this.active) return;
          
          const orb = document.getElementById('orb');
          orb.style.left = this.pos.x + '%';
          orb.style.top = this.pos.y + '%';
          
          const scale = 1 + (this.motion / 200);
          orb.style.transform = `translate(-50%, -50%) scale(${scale})`;
          
          requestAnimationFrame(update);
        };
        update();
      }
      
      show(ids) { ids.forEach(id => document.getElementById(id).classList.remove('hidden')); }
      hide(ids) { ids.forEach(id => document.getElementById(id).classList.add('hidden')); }
    }
    
    new GUMP();
  </script>
</body>
</html>
