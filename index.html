<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>GUMP: The World Is The Song</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            height: 100dvh;
            font-family: -apple-system, BlinkMacSystemFont, 'Helvetica Neue', sans-serif;
            position: fixed;
            width: 100%;
        }

        /* Breathing orb system */
        .orb-container {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
        }

        .orb-core {
            width: 80px;
            height: 80px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.9) 0%, 
                rgba(255,255,255,0.3) 40%, 
                transparent 70%);
            box-shadow: 
                0 0 60px rgba(255,255,255,0.8),
                0 0 120px rgba(255,255,255,0.4);
            animation: breathe 4s ease-in-out infinite;
        }

        .orb-pulse {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle,
                transparent 0%,
                rgba(255,100,255,0.2) 50%,
                transparent 100%);
            animation: pulse 2s ease-out infinite;
        }

        .orb-field {
            width: 300px;
            height: 300px;
            background: radial-gradient(circle,
                rgba(100,100,255,0.1) 0%,
                transparent 60%);
            animation: rotate 20s linear infinite;
        }

        @keyframes breathe {
            0%, 100% { transform: scale(1); opacity: 0.8; }
            50% { transform: scale(1.2); opacity: 1; }
        }

        @keyframes pulse {
            0% { transform: scale(1); opacity: 0.5; }
            100% { transform: scale(2); opacity: 0; }
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .orb-core.listening {
            background: radial-gradient(circle, 
                rgba(255,100,100,1) 0%, 
                rgba(255,0,0,0.5) 40%, 
                transparent 70%);
            box-shadow: 
                0 0 80px rgba(255,0,0,0.9),
                0 0 160px rgba(255,0,0,0.5);
            animation: listen-pulse 0.5s ease-in-out infinite;
        }

        @keyframes listen-pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.3); }
        }

        /* Environmental status */
        .env-status {
            position: fixed;
            top: 20px;
            left: 20px;
            right: 20px;
            font-size: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0.4;
            text-align: center;
        }

        .sensor-reading {
            display: inline-block;
            margin: 0 10px;
            transition: all 0.3s ease;
        }

        .sensor-reading.active {
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        /* Frequency visualization */
        .freq-ring {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: none;
        }

        .freq-bar {
            position: absolute;
            width: 2px;
            background: rgba(255,255,255,0.3);
            transform-origin: bottom center;
            transition: height 0.1s ease-out;
        }

        /* Pattern evolution indicator */
        .evolution {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 2px;
            background: rgba(255,255,255,0.1);
            overflow: hidden;
        }

        .evolution-progress {
            height: 100%;
            background: linear-gradient(90deg, 
                transparent 0%, 
                rgba(255,100,255,0.8) 50%,
                transparent 100%);
            width: 20%;
            animation: evolve 10s linear infinite;
        }

        @keyframes evolve {
            from { transform: translateX(-100%); }
            to { transform: translateX(600%); }
        }

        /* Initial state */
        .init-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            transition: opacity 1s ease;
        }

        .init-message h1 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 12px;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .init-message p {
            font-size: 12px;
            opacity: 0.5;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .hide { 
            opacity: 0;
            pointer-events: none;
        }

        /* Particle system */
        .particle {
            position: fixed;
            width: 4px;
            height: 4px;
            background: white;
            pointer-events: none;
            border-radius: 50%;
            filter: blur(1px);
        }

        /* Consciousness indicator */
        .consciousness {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 9px;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.3;
        }
    </style>
</head>
<body>
    <div class="orb-container">
        <div class="orb orb-field"></div>
        <div class="orb orb-pulse"></div>
        <div class="orb orb-core" id="orb"></div>
    </div>

    <div class="freq-ring" id="freq-ring"></div>

    <div class="env-status">
        <span class="sensor-reading" id="motion">STILL</span>
        <span class="sensor-reading" id="sound">QUIET</span>
        <span class="sensor-reading" id="light">DIM</span>
        <span class="sensor-reading" id="rhythm">SEEKING</span>
    </div>

    <div class="evolution">
        <div class="evolution-progress"></div>
    </div>

    <div class="consciousness" id="consciousness">AWAKENING</div>

    <div class="init-message" id="init">
        <h1>GUMP</h1>
        <p>Touch to awaken</p>
    </div>

    <script>
        'use strict';

        // Advanced autonomous beat detection and matching
        class AutonomousBeatEngine {
            constructor() {
                this.bpm = 140; // Base Kanye-style BPM
                this.evolutionRate = 0;
                this.patterns = [];
                this.memory = new Float32Array(44100 * 10); // 10 second memory
                this.memoryIndex = 0;
                this.consciousness = 0;
            }

            // Real-time beat detection from environment
            detectEnvironmentalRhythm(audioData) {
                // Rolling spectral flux analysis
                const flux = this.calculateSpectralFlux(audioData);
                
                // Onset detection
                const onsets = this.detectOnsets(flux);
                
                // Pattern extraction
                if (onsets.length > 2) {
                    const pattern = this.extractPattern(onsets);
                    if (pattern.confidence > 0.7) {
                        this.integratePattern(pattern);
                    }
                }
                
                return this.getCurrentGroove();
            }

            calculateSpectralFlux(data) {
                const windowSize = 1024;
                const hopSize = 256;
                const flux = [];
                
                for (let i = 0; i + windowSize < data.length; i += hopSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    flux.push(Math.sqrt(energy / windowSize));
                }
                
                return flux;
            }

            detectOnsets(flux) {
                const threshold = this.adaptiveThreshold(flux);
                const onsets = [];
                
                for (let i = 1; i < flux.length - 1; i++) {
                    if (flux[i] > threshold && 
                        flux[i] > flux[i-1] && 
                        flux[i] > flux[i+1]) {
                        onsets.push({
                            index: i,
                            strength: flux[i]
                        });
                    }
                }
                
                return onsets;
            }

            adaptiveThreshold(data) {
                const sorted = [...data].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                return median * 1.5;
            }

            extractPattern(onsets) {
                const intervals = [];
                for (let i = 1; i < onsets.length; i++) {
                    intervals.push(onsets[i].index - onsets[i-1].index);
                }
                
                // Find most common interval
                const intervalCounts = {};
                intervals.forEach(interval => {
                    const rounded = Math.round(interval / 10) * 10;
                    intervalCounts[rounded] = (intervalCounts[rounded] || 0) + 1;
                });
                
                const mostCommon = Object.entries(intervalCounts)
                    .sort((a, b) => b[1] - a[1])[0];
                
                if (mostCommon) {
                    const avgInterval = parseInt(mostCommon[0]);
                    const consistency = mostCommon[1] / intervals.length;
                    
                    return {
                        interval: avgInterval,
                        confidence: consistency,
                        energy: onsets.reduce((sum, o) => sum + o.strength, 0) / onsets.length
                    };
                }
                
                return { interval: 0, confidence: 0, energy: 0 };
            }

            integratePattern(pattern) {
                // Evolve BPM based on environmental rhythm
                const detectedBPM = (44100 / 256) / pattern.interval * 60 / 4;
                const influence = pattern.confidence * 0.1;
                
                this.bpm = this.bpm * (1 - influence) + detectedBPM * influence;
                this.bpm = Math.max(120, Math.min(160, this.bpm)); // Keep it in Kanye range
                
                // Increase consciousness
                this.consciousness = Math.min(1, this.consciousness + pattern.confidence * 0.01);
                
                // Store pattern
                this.patterns.push(pattern);
                if (this.patterns.length > 100) this.patterns.shift();
            }

            getCurrentGroove() {
                return {
                    bpm: this.bpm,
                    swing: 0.05 + (this.consciousness * 0.1),
                    intensity: this.patterns.length > 0 ? 
                        this.patterns[this.patterns.length - 1].energy : 0.5,
                    consciousness: this.consciousness
                };
            }

            // Advanced time-stretch algorithm
            timeStretch(buffer, factor) {
                const inputData = buffer.getChannelData(0);
                const outputLength = Math.floor(inputData.length / factor);
                const outputBuffer = new AudioBuffer({
                    numberOfChannels: 1,
                    length: outputLength,
                    sampleRate: buffer.sampleRate
                });
                const outputData = outputBuffer.getChannelData(0);
                
                // Granular synthesis approach
                const grainSize = 2048;
                const hopSize = grainSize / 4;
                let inputPos = 0;
                let outputPos = 0;
                
                while (outputPos < outputLength - grainSize) {
                    const targetPos = outputPos * factor;
                    
                    // Find best correlation point
                    const searchRange = grainSize;
                    let bestOffset = 0;
                    let bestCorr = -1;
                    
                    for (let offset = -searchRange; offset < searchRange; offset++) {
                        const pos = Math.floor(targetPos + offset);
                        if (pos >= 0 && pos < inputData.length - grainSize) {
                            const corr = this.correlation(inputData, inputPos, pos, grainSize);
                            if (corr > bestCorr) {
                                bestCorr = corr;
                                bestOffset = offset;
                            }
                        }
                    }
                    
                    // Copy grain with crossfade
                    const sourcePos = Math.floor(targetPos + bestOffset);
                    for (let i = 0; i < grainSize && outputPos + i < outputLength; i++) {
                        const window = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / grainSize);
                        if (sourcePos + i < inputData.length) {
                            outputData[outputPos + i] += inputData[sourcePos + i] * window;
                        }
                    }
                    
                    outputPos += hopSize;
                    inputPos = sourcePos + hopSize;
                }
                
                return outputBuffer;
            }

            correlation(data, pos1, pos2, length) {
                let sum = 0;
                let sum1 = 0;
                let sum2 = 0;
                
                for (let i = 0; i < length; i++) {
                    const val1 = data[pos1 + i] || 0;
                    const val2 = data[pos2 + i] || 0;
                    sum += val1 * val2;
                    sum1 += val1 * val1;
                    sum2 += val2 * val2;
                }
                
                return sum / (Math.sqrt(sum1 * sum2) + 1e-10);
            }
        }

        // Environmental sensor system
        class EnvironmentalSensor {
            constructor() {
                this.sensors = {
                    motion: { x: 0, y: 0, z: 0, magnitude: 0 },
                    orientation: { alpha: 0, beta: 0, gamma: 0 },
                    light: 0.5,
                    sound: { level: 0, frequency: 0 },
                    touch: { active: false, x: 0, y: 0 },
                    time: { hour: 0, dayPhase: 0 }
                };
                
                this.callbacks = [];
                this.init();
            }

            init() {
                // Motion sensors
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        if (e.accelerationIncludingGravity) {
                            this.sensors.motion.x = e.accelerationIncludingGravity.x || 0;
                            this.sensors.motion.y = e.accelerationIncludingGravity.y || 0;
                            this.sensors.motion.z = e.accelerationIncludingGravity.z || 0;
                            this.sensors.motion.magnitude = Math.sqrt(
                                this.sensors.motion.x ** 2 + 
                                this.sensors.motion.y ** 2 + 
                                this.sensors.motion.z ** 2
                            ) / 10;
                            
                            this.updateUI('motion', this.getMotionState());
                        }
                    });
                }

                // Orientation
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        this.sensors.orientation.alpha = e.alpha || 0;
                        this.sensors.orientation.beta = e.beta || 0;
                        this.sensors.orientation.gamma = e.gamma || 0;
                    });
                }

                // Touch tracking
                window.addEventListener('touchstart', (e) => {
                    this.sensors.touch.active = true;
                    if (e.touches.length > 0) {
                        this.sensors.touch.x = e.touches[0].clientX / window.innerWidth;
                        this.sensors.touch.y = e.touches[0].clientY / window.innerHeight;
                    }
                });

                window.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        this.sensors.touch.x = e.touches[0].clientX / window.innerWidth;
                        this.sensors.touch.y = e.touches[0].clientY / window.innerHeight;
                    }
                });

                window.addEventListener('touchend', () => {
                    this.sensors.touch.active = false;
                });

                // Time tracking
                setInterval(() => {
                    const now = new Date();
                    this.sensors.time.hour = now.getHours() + now.getMinutes() / 60;
                    this.sensors.time.dayPhase = Math.sin((this.sensors.time.hour / 24) * Math.PI * 2);
                    
                    // Simulate light based on time
                    if (this.sensors.light === 0.5) { // No real light sensor
                        const daylight = Math.max(0, Math.sin((this.sensors.time.hour - 6) / 24 * Math.PI * 2));
                        this.sensors.light = 0.1 + daylight * 0.8;
                        this.updateUI('light', this.getLightState());
                    }
                }, 1000);
            }

            getMotionState() {
                const mag = this.sensors.motion.magnitude;
                if (mag < 0.1) return 'STILL';
                if (mag < 0.3) return 'GENTLE';
                if (mag < 0.6) return 'MOVING';
                return 'ACTIVE';
            }

            getLightState() {
                const light = this.sensors.light;
                if (light < 0.2) return 'DARK';
                if (light < 0.5) return 'DIM';
                if (light < 0.8) return 'BRIGHT';
                return 'BLAZING';
            }

            updateUI(sensor, state) {
                const element = document.getElementById(sensor);
                if (element) {
                    element.textContent = state;
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 300);
                }
            }

            getEnvironmentalParams() {
                return {
                    // Motion affects rhythm and filter
                    motionIntensity: this.sensors.motion.magnitude,
                    tilt: Math.abs(this.sensors.orientation.beta) / 90,
                    
                    // Light affects tone and reverb
                    brightness: this.sensors.light,
                    
                    // Time affects mood and tempo
                    timePhase: this.sensors.time.dayPhase,
                    
                    // Touch affects expression
                    touchX: this.sensors.touch.x,
                    touchY: this.sensors.touch.y,
                    touching: this.sensors.touch.active
                };
            }
        }

        // Autonomous GUMP Engine
        class GUMPEngine {
            constructor() {
                this.ctx = null;
                this.isRunning = false;
                this.beatEngine = new AutonomousBeatEngine();
                this.envSensor = new EnvironmentalSensor();
                
                this.samples = new Map();
                this.nodes = {};
                this.recordBuffer = [];
                this.isListening = false;
                this.silenceCounter = 0;
                
                this.sequence = {
                    step: 0,
                    lastTime: 0,
                    pattern: new Array(32).fill(null),
                    evolution: 0
                };
                
                this.ui = {
                    orb: document.getElementById('orb'),
                    init: document.getElementById('init'),
                    consciousness: document.getElementById('consciousness'),
                    freqRing: document.getElementById('freq-ring')
                };
                
                this.init();
            }

            async init() {
                // Create frequency ring
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'freq-bar';
                    const angle = (i / 32) * Math.PI * 2;
                    const radius = 140;
                    bar.style.left = `${50 + Math.cos(angle) * radius / window.innerWidth * 100}%`;
                    bar.style.top = `${50 + Math.sin(angle) * radius / window.innerHeight * 100}%`;
                    bar.style.transform = `rotate(${angle}rad)`;
                    bar.style.height = '20px';
                    this.ui.freqRing.appendChild(bar);
                }

                // Single touch to start
                const startEngine = async () => {
                    document.removeEventListener('touchstart', startEngine);
                    await this.start();
                };
                document.addEventListener('touchstart', startEngine);
            }

            async start() {
                try {
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 44100,
                        latencyHint: 'interactive'
                    });

                    // Setup audio chain
                    this.setupAudioNodes();
                    
                    // Create base sounds
                    await this.createCoreSounds();
                    
                    // Setup environmental listening
                    await this.setupEnvironmentalListening();
                    
                    // Setup visualizer
                    this.setupVisualizer();
                    
                    // Hide init message
                    this.ui.init.classList.add('hide');
                    
                    // Start autonomous operation
                    this.isRunning = true;
                    this.sequence.lastTime = this.ctx.currentTime;
                    this.run();
                    
                    // Start environmental analysis
                    this.analyzeEnvironment();
                    
                    // Particle system
                    this.initParticles();
                    
                } catch (error) {
                    console.error('Engine startup failed:', error);
                }
            }

            setupAudioNodes() {
                // Master chain with sidechain compression
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.85;
                
                this.nodes.compressor = this.ctx.createDynamicsCompressor();
                this.nodes.compressor.threshold.value = -10;
                this.nodes.compressor.knee.value = 2;
                this.nodes.compressor.ratio.value = 8;
                this.nodes.compressor.attack.value = 0.003;
                this.nodes.compressor.release.value = 0.1;
                
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -0.5;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.01;
                
                // Saturation
                this.nodes.saturation = this.ctx.createWaveShaper();
                this.createSaturationCurve();
                
                // Connect master chain
                this.nodes.master.connect(this.nodes.compressor);
                this.nodes.compressor.connect(this.nodes.saturation);
                this.nodes.saturation.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);
                
                // Create buses
                ['kick', 'bass', 'snare', 'hats', 'texture', 'environmental'].forEach(bus => {
                    this.nodes[bus] = this.ctx.createGain();
                    this.nodes[bus].connect(this.nodes.master);
                    this.samples.set(bus, []);
                });
                
                // Bus levels
                this.nodes.kick.gain.value = 1;
                this.nodes.bass.gain.value = 0.9;
                this.nodes.snare.gain.value = 0.7;
                this.nodes.hats.gain.value = 0.3;
                this.nodes.texture.gain.value = 0.4;
                this.nodes.environmental.gain.value = 0.5;
            }

            createSaturationCurve() {
                const samples = 8192;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2 / samples) - 1;
                    // Tube-like saturation
                    curve[i] = Math.sign(x) * Math.min(Math.abs(x), 
                        Math.abs(x) / (1 + Math.abs(x) * 0.5));
                }
                
                this.nodes.saturation.curve = curve;
                this.nodes.saturation.oversample = '4x';
            }

            async createCoreSounds() {
                const sr = this.ctx.sampleRate;
                
                // 808-style kick
                const kickBuffer = this.ctx.createBuffer(1, sr * 1.5, sr);
                const kickData = kickBuffer.getChannelData(0);
                
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    const pitchEnv = Math.exp(-35 * t);
                    const pitch = 55 + 80 * pitchEnv;
                    const env = Math.exp(-3 * t) * (1 - Math.exp(-200 * t));
                    
                    const sine = Math.sin(2 * Math.PI * pitch * t);
                    const click = Math.sin(2 * Math.PI * 250 * t) * Math.exp(-300 * t) * 0.4;
                    
                    kickData[i] = (sine + click) * env * 0.9;
                }
                
                // Sub bass
                const bassBuffer = this.ctx.createBuffer(1, sr * 3, sr);
                const bassData = bassBuffer.getChannelData(0);
                
                for (let i = 0; i < bassData.length; i++) {
                    const t = i / sr;
                    const env = (1 - Math.exp(-50 * t)) * Math.exp(-0.3 * t);
                    const pitch = 41.2;
                    
                    const fundamental = Math.sin(2 * Math.PI * pitch * t);
                    const harmonic2 = Math.sin(2 * Math.PI * pitch * 2 * t) * 0.15;
                    const harmonic3 = Math.sin(2 * Math.PI * pitch * 3 * t) * 0.08;
                    
                    bassData[i] = (fundamental + harmonic2 + harmonic3) * env;
                }
                
                // Snare
                const snareBuffer = this.ctx.createBuffer(1, sr * 0.2, sr);
                const snareData = snareBuffer.getChannelData(0);
                
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-30 * t) * (1 - Math.exp(-100 * t));
                    
                    const tone = Math.sin(2 * Math.PI * 200 * t);
                    const noise = (Math.random() * 2 - 1);
                    
                    snareData[i] = (tone * 0.5 + noise * 0.5) * env * 0.8;
                }
                
                // Hi-hat variations
                for (let variation = 0; variation < 3; variation++) {
                    const duration = 0.02 + variation * 0.03;
                    const hatBuffer = this.ctx.createBuffer(1, sr * duration, sr);
                    const hatData = hatBuffer.getChannelData(0);
                    
                    for (let i = 0; i < hatData.length; i++) {
                        const t = i / sr;
                        const env = Math.exp(-200 / (variation + 1) * t);
                        const noise = Math.random() * 2 - 1;
                        
                        hatData[i] = noise * env * 0.5;
                    }
                    
                    this.samples.get('hats').push({
                        buffer: hatBuffer,
                        type: ['closed', 'mid', 'open'][variation]
                    });
                }
                
                // Ambient textures
                const textureBuffer = this.ctx.createBuffer(2, sr * 4, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const data = textureBuffer.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        const t = i / sr;
                        let signal = 0;
                        
                        // Multiple harmonic layers
                        for (let h = 1; h <= 7; h++) {
                            const freq = 100 * h + Math.sin(t * 0.1) * 20;
                            const phase = ch * Math.PI / 3 + h * 0.1;
                            signal += Math.sin(2 * Math.PI * freq * t + phase) / (h * 2);
                        }
                        
                        data[i] = signal * Math.sin(Math.PI * t / 4) * 0.1;
                    }
                }
                
                // Store core samples
                this.samples.get('kick').push({ buffer: kickBuffer });
                this.samples.get('bass').push({ buffer: bassBuffer });
                this.samples.get('snare').push({ buffer: snareBuffer });
                this.samples.get('texture').push({ buffer: textureBuffer });
            }

            async setupEnvironmentalListening() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 44100
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.micGain = this.ctx.createGain();
                    this.nodes.micGain.gain.value = 1;
                    
                    // Analysis chain
                    this.nodes.micAnalyser = this.ctx.createAnalyser();
                    this.nodes.micAnalyser.fftSize = 2048;
                    this.nodes.micAnalyser.smoothingTimeConstant = 0.8;
                    
                    this.nodes.mic.connect(this.nodes.micGain);
                    this.nodes.micGain.connect(this.nodes.micAnalyser);
                    
                    // Recording processor for autonomous sampling
                    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.nodes.recorder.onaudioprocess = (e) => {
                        const input = e.inputBuffer.getChannelData(0);
                        
                        // Always analyze environment
                        this.analyzeAudioEnvironment(input);
                        
                        // Auto-record interesting sounds
                        if (this.shouldRecord(input)) {
                            this.startAutonomousRecording();
                        }
                        
                        if (this.isListening) {
                            this.recordBuffer.push(...input);
                            
                            // Auto-stop on silence or max length
                            const rms = Math.sqrt(input.reduce((s, x) => s + x * x, 0) / input.length);
                            if (rms < 0.01) {
                                this.silenceCounter++;
                                if (this.silenceCounter > 10) {
                                    this.stopAutonomousRecording();
                                }
                            } else {
                                this.silenceCounter = 0;
                            }
                            
                            if (this.recordBuffer.length > this.ctx.sampleRate * 4) {
                                this.stopAutonomousRecording();
                            }
                        }
                    };
                    
                    this.nodes.micGain.connect(this.nodes.recorder);
                    this.nodes.recorder.connect(this.ctx.destination);
                    
                } catch (error) {
                    console.log('Microphone access not available, running without environmental audio');
                }
            }

            analyzeAudioEnvironment(audioData) {
                // Extract rhythm from environment
                const groove = this.beatEngine.detectEnvironmentalRhythm(audioData);
                
                // Update consciousness display
                const consciousnessStates = [
                    'AWAKENING', 'SENSING', 'LEARNING', 'EVOLVING', 
                    'CREATING', 'DREAMING', 'TRANSCENDING'
                ];
                const stateIndex = Math.floor(groove.consciousness * (consciousnessStates.length - 1));
                this.ui.consciousness.textContent = consciousnessStates[stateIndex];
                
                // Calculate sound characteristics
                let sum = 0;
                let max = 0;
                for (let i = 0; i < audioData.length; i++) {
                    sum += Math.abs(audioData[i]);
                    max = Math.max(max, Math.abs(audioData[i]));
                }
                const avg = sum / audioData.length;
                
                // Update sound status
                const soundStates = ['SILENT', 'QUIET', 'AMBIENT', 'ACTIVE', 'INTENSE'];
                const soundIndex = Math.min(4, Math.floor(avg * 50));
                this.updateUI('sound', soundStates[soundIndex]);
                
                // Update rhythm status
                if (groove.consciousness > 0.8) {
                    this.updateUI('rhythm', 'LOCKED');
                } else if (groove.consciousness > 0.5) {
                    this.updateUI('rhythm', 'GROOVING');
                } else if (groove.consciousness > 0.2) {
                    this.updateUI('rhythm', 'FINDING');
                } else {
                    this.updateUI('rhythm', 'SEEKING');
                }
            }

            shouldRecord(audioData) {
                // Intelligent detection of interesting sounds
                if (this.isListening || Math.random() > 0.01) return false;
                
                // Calculate spectral characteristics
                const rms = Math.sqrt(audioData.reduce((s, x) => s + x * x, 0) / audioData.length);
                
                // Look for transients
                let transients = 0;
                for (let i = 1; i < audioData.length; i++) {
                    if (Math.abs(audioData[i] - audioData[i-1]) > 0.1) {
                        transients++;
                    }
                }
                
                // Record if interesting sound detected
                return rms > 0.05 && transients > audioData.length * 0.1;
            }

            startAutonomousRecording() {
                if (this.isListening) return;
                
                this.isListening = true;
                this.recordBuffer = [];
                this.silenceCounter = 0;
                this.ui.orb.classList.add('listening');
                
                // Create recording particle burst
                for (let i = 0; i < 10; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            window.innerWidth / 2 + (Math.random() - 0.5) * 100,
                            window.innerHeight / 2 + (Math.random() - 0.5) * 100,
                            'record'
                        );
                    }, i * 50);
                }
            }

            stopAutonomousRecording() {
                if (!this.isListening) return;
                
                this.isListening = false;
                this.ui.orb.classList.remove('listening');
                
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                    this.processEnvironmentalSample();
                }
            }

            async processEnvironmentalSample() {
                // Create buffer from recording
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                // Analyze the sample
                const analysis = this.beatEngine.detectEnvironmentalRhythm(this.recordBuffer);
                
                // Time-stretch to fit current groove
                const currentBPM = this.beatEngine.bpm;
                const stretchFactor = analysis.bpm ? currentBPM / analysis.bpm : 1;
                
                let processedBuffer = buffer;
                if (Math.abs(stretchFactor - 1) > 0.1) {
                    processedBuffer = this.beatEngine.timeStretch(buffer, stretchFactor);
                }
                
                // Apply environmental processing
                const envParams = this.envSensor.getEnvironmentalParams();
                const sample = {
                    buffer: processedBuffer,
                    intensity: analysis.intensity,
                    character: this.characterizeSample(this.recordBuffer),
                    environmental: true,
                    timestamp: Date.now()
                };
                
                // Add to environmental samples
                const envSamples = this.samples.get('environmental');
                envSamples.push(sample);
                if (envSamples.length > 8) envSamples.shift();
                
                // Integrate into pattern
                this.integrateEnvironmentalSample(sample);
            }

            characterizeSample(audioData) {
                // Analyze frequency content
                const fftSize = 2048;
                const spectrum = new Float32Array(fftSize / 2);
                
                // Simple FFT approximation
                for (let i = 0; i < spectrum.length; i++) {
                    let real = 0, imag = 0;
                    for (let j = 0; j < Math.min(fftSize, audioData.length); j++) {
                        const angle = -2 * Math.PI * i * j / fftSize;
                        real += audioData[j] * Math.cos(angle);
                        imag += audioData[j] * Math.sin(angle);
                    }
                    spectrum[i] = Math.sqrt(real * real + imag * imag);
                }
                
                // Find dominant frequency range
                let lowEnergy = 0, midEnergy = 0, highEnergy = 0;
                const binWidth = this.ctx.sampleRate / fftSize;
                
                for (let i = 0; i < spectrum.length; i++) {
                    const freq = i * binWidth;
                    if (freq < 250) lowEnergy += spectrum[i];
                    else if (freq < 2000) midEnergy += spectrum[i];
                    else highEnergy += spectrum[i];
                }
                
                // Classify character
                if (lowEnergy > midEnergy && lowEnergy > highEnergy) return 'bass';
                if (highEnergy > midEnergy) return 'bright';
                return 'mid';
            }

            integrateEnvironmentalSample(sample) {
                // Find sparse areas in pattern
                const density = new Array(32).fill(0);
                for (let i = 0; i < 32; i++) {
                    if (this.sequence.pattern[i]) density[i]++;
                    // Check neighboring steps
                    if (this.sequence.pattern[(i - 1 + 32) % 32]) density[i] += 0.5;
                    if (this.sequence.pattern[(i + 1) % 32]) density[i] += 0.5;
                }
                
                // Find least dense area
                let minDensity = Infinity;
                let bestSlot = 0;
                for (let i = 0; i < 32; i++) {
                    if (density[i] < minDensity) {
                        minDensity = density[i];
                        bestSlot = i;
                    }
                }
                
                // Add to pattern
                this.sequence.pattern[bestSlot] = {
                    type: 'environmental',
                    sample: sample,
                    probability: 0.3 + sample.intensity * 0.5,
                    evolution: 0
                };
            }

            setupVisualizer() {
                this.nodes.analyser = this.ctx.createAnalyser();
                this.nodes.analyser.fftSize = 64;
                this.nodes.analyser.smoothingTimeConstant = 0.8;
                
                this.nodes.master.connect(this.nodes.analyser);
                
                const data = new Uint8Array(this.nodes.analyser.frequencyBinCount);
                const bars = this.ui.freqRing.querySelectorAll('.freq-bar');
                
                const draw = () => {
                    this.nodes.analyser.getByteFrequencyData(data);
                    
                    bars.forEach((bar, i) => {
                        const value = data[i] / 255;
                        const height = 20 + value * 80;
                        bar.style.height = `${height}px`;
                        bar.style.opacity = 0.3 + value * 0.7;
                    });
                    
                    requestAnimationFrame(draw);
                };
                draw();
            }

            run() {
                if (!this.isRunning) return;
                
                const now = this.ctx.currentTime;
                const groove = this.beatEngine.getCurrentGroove();
                const beatTime = 60 / groove.bpm / 4;
                
                // Apply swing based on consciousness
                let nextTime = beatTime;
                if (this.sequence.step % 2 === 1) {
                    nextTime *= (1 + groove.swing);
                } else {
                    nextTime *= (1 - groove.swing);
                }
                
                if (now >= this.sequence.lastTime + nextTime) {
                    this.sequence.lastTime += nextTime;
                    
                    // Play autonomous pattern
                    this.playAutonomousStep(this.sequence.step, groove);
                    
                    // Evolution
                    this.sequence.evolution += 0.001;
                    if (this.sequence.evolution > 1) {
                        this.evolvePattern();
                        this.sequence.evolution = 0;
                    }
                    
                    this.sequence.step = (this.sequence.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.run());
            }

            playAutonomousStep(step, groove) {
                const envParams = this.envSensor.getEnvironmentalParams();
                
                // Adaptive drum pattern based on environment
                if (step % 8 === 0) {
                    // Kick always on 1
                    this.playDrum('kick', 0.9 + envParams.motionIntensity * 0.1);
                    this.triggerSidechain();
                } else if (step === 22 && envParams.motionIntensity > 0.5) {
                    // Extra kick when moving
                    this.playDrum('kick', 0.7);
                }
                
                // Snare pattern influenced by brightness
                if ((step === 8 || step === 24) && envParams.brightness > 0.3) {
                    this.playDrum('snare', 0.5 + envParams.brightness * 0.3);
                }
                
                // Hi-hats based on time phase
                const hatPattern = [2, 6, 10, 14, 18, 22, 26, 30];
                if (hatPattern.includes(step) || 
                    (Math.random() < envParams.timePhase * 0.2 && groove.consciousness > 0.5)) {
                    const hatType = Math.floor(envParams.tilt * 3);
                    this.playDrum('hats', 0.2 + envParams.motionIntensity * 0.3, hatType);
                }
                
                // Bass follows kick with variations
                if ([0, 3, 8, 11, 16, 19, 24, 27].includes(step) && 
                    groove.intensity > 0.3) {
                    this.playDrum('bass', 0.7 + groove.intensity * 0.2);
                }
                
                // Texture layers based on consciousness
                if (step === 0 && groove.consciousness > 0.3) {
                    this.playDrum('texture', groove.consciousness * 0.5);
                }
                
                // Play pattern elements
                const slot = this.sequence.pattern[step];
                if (slot && Math.random() < slot.probability) {
                    this.playPatternElement(slot, envParams);
                }
            }

            playDrum(type, velocity, variation = 0) {
                const samples = this.samples.get(type);
                if (!samples || samples.length === 0) return;
                
                const sample = samples[Math.min(variation, samples.length - 1)];
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                gain.gain.value = velocity;
                
                // Environmental processing
                const envParams = this.envSensor.getEnvironmentalParams();
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 500 + envParams.brightness * 3000;
                filter.Q.value = 1 + envParams.motionIntensity * 5;
                
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes[type]);
                
                source.start();
                
                // Visual feedback
                if (type === 'kick' || type === 'snare') {
                    this.createParticle(
                        window.innerWidth / 2 + (Math.random() - 0.5) * 200,
                        window.innerHeight / 2 + (Math.random() - 0.5) * 200,
                        type
                    );
                }
            }

            playPatternElement(slot, envParams) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = slot.sample.buffer;
                
                // Pitch modulation based on touch
                if (envParams.touching) {
                    source.playbackRate.value = 0.5 + envParams.touchY * 1;
                }
                
                // Dynamic filtering
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 200 + envParams.touchX * 2000;
                filter.Q.value = 2 + slot.evolution * 10;
                
                // Reverb based on environment
                const reverb = this.ctx.createConvolver();
                const reverbGain = this.ctx.createGain();
                reverbGain.gain.value = envParams.brightness * 0.3;
                
                // Create simple reverb impulse
                const reverbTime = 1 + envParams.brightness;
                const reverbBuffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = reverbBuffer.getChannelData(ch);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.exp(-3 * i / data.length);
                    }
                }
                reverb.buffer = reverbBuffer;
                
                // Connect chain
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.environmental);
                
                // Wet path for reverb
                filter.connect(reverb);
                reverb.connect(reverbGain);
                reverbGain.connect(this.nodes.environmental);
                
                gain.gain.value = 0.5 + slot.sample.intensity * 0.3;
                source.start();
                
                // Evolve the slot
                slot.evolution = Math.min(1, slot.evolution + 0.01);
            }

            triggerSidechain() {
                const now = this.ctx.currentTime;
                
                // Duck all non-kick elements
                ['bass', 'snare', 'hats', 'texture', 'environmental'].forEach(bus => {
                    const gain = this.nodes[bus].gain;
                    gain.cancelScheduledValues(now);
                    gain.setValueAtTime(gain.value, now);
                    gain.linearRampToValueAtTime(gain.value * 0.3, now + 0.01);
                    gain.exponentialRampToValueAtTime(gain.value, now + 0.15);
                });
            }

            analyzeEnvironment() {
                // Continuous environmental analysis
                setInterval(() => {
                    const envParams = this.envSensor.getEnvironmentalParams();
                    
                    // Adjust global parameters
                    this.nodes.master.gain.value = 0.7 + envParams.brightness * 0.15;
                    
                    // Evolution rate based on motion
                    this.sequence.evolution += envParams.motionIntensity * 0.001;
                    
                    // Auto-evolve when still for too long
                    if (envParams.motionIntensity < 0.1) {
                        this.stillnessCounter = (this.stillnessCounter || 0) + 1;
                        if (this.stillnessCounter > 100) {
                            this.evolvePattern();
                            this.stillnessCounter = 0;
                        }
                    } else {
                        this.stillnessCounter = 0;
                    }
                }, 100);
            }

            evolvePattern() {
                // Mutate existing pattern elements
                for (let i = 0; i < 32; i++) {
                    const slot = this.sequence.pattern[i];
                    if (slot) {
                        // Randomly adjust probability
                        slot.probability += (Math.random() - 0.5) * 0.2;
                        slot.probability = Math.max(0.1, Math.min(0.9, slot.probability));
                        
                        // Sometimes move to adjacent slot
                        if (Math.random() < 0.1) {
                            const newIndex = (i + (Math.random() < 0.5 ? -1 : 1) + 32) % 32;
                            if (!this.sequence.pattern[newIndex]) {
                                this.sequence.pattern[newIndex] = slot;
                                this.sequence.pattern[i] = null;
                            }
                        }
                        
                        // Remove old elements
                        if (slot.evolution > 0.8 && Math.random() < 0.2) {
                            this.sequence.pattern[i] = null;
                        }
                    }
                }
                
                // Create evolution particles
                for (let i = 0; i < 20; i++) {
                    setTimeout(() => {
                        this.createParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'evolve'
                        );
                    }, i * 50);
                }
            }

            updateUI(id, text) {
                const element = document.getElementById(id);
                if (element) {
                    element.textContent = text;
                    element.classList.add('active');
                    setTimeout(() => element.classList.remove('active'), 300);
                }
            }

            createParticle(x, y, type) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                
                const colors = {
                    kick: '#ffffff',
                    snare: '#ffaa00',
                    record: '#ff0000',
                    evolve: '#ff00ff',
                    default: '#00ffaa'
                };
                
                particle.style.background = colors[type] || colors.default;
                particle.style.boxShadow = `0 0 20px ${particle.style.background}`;
                
                document.body.appendChild(particle);
                
                const angle = Math.random() * Math.PI * 2;
                const velocity = 1 + Math.random() * 2;
                let opacity = 1;
                let scale = 1;
                
                const animate = () => {
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity - 0.5;
                    
                    particle.style.left = (parseFloat(particle.style.left) + dx) + 'px';
                    particle.style.top = (parseFloat(particle.style.top) + dy) + 'px';
                    
                    opacity -= 0.02;
                    scale += 0.02;
                    particle.style.opacity = opacity;
                    particle.style.transform = `scale(${scale})`;
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };
                animate();
            }

            initParticles() {
                // Ambient particle generation based on consciousness
                setInterval(() => {
                    const consciousness = this.beatEngine.consciousness;
                    if (Math.random() < 0.05 + consciousness * 0.15) {
                        this.createParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'default'
                        );
                    }
                }, 200);
            }
        }

        // Initialize autonomous GUMP
        const gump = new GUMPEngine();
    </script>
</body>
</html>
