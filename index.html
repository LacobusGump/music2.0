<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Revolutionary Reality Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, system-ui, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s cubic-bezier(0.25, 0.1, 0.25, 1);
    }
    
    .loading-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(circle, #1a1a2e 0%, #000 100%);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 2s ease, transform 2s ease;
    }
    
    .loading-screen.hidden {
      opacity: 0;
      transform: scale(1.1);
      pointer-events: none;
    }
    
    .revolution-title {
      font-size: clamp(48px, 8vw, 96px);
      font-weight: 100;
      letter-spacing: 12px;
      margin-bottom: 20px;
      background: linear-gradient(45deg, #fff 0%, #4ecdc4 50%, #ff6b35 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: titlePulse 6s ease-in-out infinite;
      text-align: center;
    }
    
    .revolution-subtitle {
      font-size: clamp(14px, 2vw, 20px);
      font-weight: 200;
      letter-spacing: 6px;
      opacity: 0.8;
      margin-bottom: 60px;
      text-transform: uppercase;
      text-align: center;
    }
    
    .tagline {
      font-size: clamp(12px, 1.5vw, 16px);
      font-weight: 300;
      letter-spacing: 2px;
      opacity: 0.6;
      margin-bottom: 40px;
      text-align: center;
      max-width: 600px;
    }
    
    @keyframes titlePulse {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.02); }
    }
    
    .enter-reality-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(78,205,196,0.1) 0%, rgba(255,107,53,0.05) 50%, transparent 80%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 300;
      letter-spacing: 3px;
      backdrop-filter: blur(20px);
      transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
      animation: orbPulse 8s ease-in-out infinite;
      position: relative;
      overflow: hidden;
    }
    
    .enter-reality-btn::before {
      content: '';
      position: absolute;
      top: -50%;
      left: -50%;
      width: 200%;
      height: 200%;
      background: conic-gradient(transparent, rgba(78,205,196,0.2), transparent);
      animation: rotate 12s linear infinite;
    }
    
    .enter-reality-btn:hover {
      border-color: rgba(78,205,196,0.8);
      background: radial-gradient(circle, rgba(78,205,196,0.2) 0%, rgba(255,107,53,0.1) 50%, transparent 80%);
      transform: scale(1.05);
      box-shadow: 0 0 100px rgba(78,205,196,0.5);
    }
    
    .btn-text {
      font-size: 14px;
      margin-bottom: 8px;
    }
    
    .btn-subtext {
      font-size: 10px;
      opacity: 0.7;
      letter-spacing: 1px;
    }
    
    @keyframes orbPulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 60px rgba(78,205,196,0.3); }
      50% { transform: scale(1.08); box-shadow: 0 0 150px rgba(78,205,196,0.6); }
    }
    
    @keyframes rotate {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    .reality-canvas {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
    }
    
    .reality-canvas.active { opacity: 1; }
    
    .consciousness-orb {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.4) 40%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s cubic-bezier(0.25, 0.1, 0.25, 1);
      box-shadow: 0 0 80px rgba(255,255,255,0.6), inset 0 0 30px rgba(255,255,255,0.3);
      backdrop-filter: blur(15px);
      border: 2px solid rgba(255,255,255,0.3);
      z-index: 10;
    }
    
    .consciousness-orb::before {
      content: '';
      position: absolute;
      top: 20%;
      left: 20%;
      width: 60%;
      height: 60%;
      background: radial-gradient(circle, rgba(255,255,255,0.8), transparent);
      border-radius: 50%;
      animation: innerGlow 4s ease-in-out infinite;
    }
    
    @keyframes innerGlow {
      0%, 100% { opacity: 0.3; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.2); }
    }
    
    .consciousness-orb.heartbeat {
      animation: dramaticHeartbeat 1s ease-out;
    }
    
    @keyframes dramaticHeartbeat {
      0% { transform: translate(-50%, -50%) scale(1); }
      20% { transform: translate(-50%, -50%) scale(1.6); }
      40% { transform: translate(-50%, -50%) scale(1.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .consciousness-orb.urban {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 40%, transparent 80%);
      box-shadow: 0 0 120px rgba(255,107,53,0.8);
    }
    
    .consciousness-orb.nature {
      background: radial-gradient(circle, #4ecdc4 0%, rgba(78,205,196,0.4) 40%, transparent 80%);
      box-shadow: 0 0 140px rgba(78,205,196,0.8);
    }
    
    .consciousness-orb.transcendent {
      background: radial-gradient(circle, #e74c3c 0%, #9b59b6 30%, #f39c12 60%, transparent 90%);
      box-shadow: 0 0 200px rgba(155,89,182,0.9);
      animation: transcendentPulse 3s ease-in-out infinite;
    }
    
    @keyframes transcendentPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    .ui-glass {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      font-weight: 300;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.2);
      padding: 20px;
      border-radius: 16px;
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255,255,255,0.1);
      transition: all 0.3s ease;
    }
    
    .ui-glass:hover {
      background: rgba(0,0,0,0.3);
      border-color: rgba(255,255,255,0.2);
      transform: translateY(-2px);
    }
    
    .ui-glass.top-left { top: 30px; left: 30px; }
    .ui-glass.bottom-left { bottom: 30px; left: 30px; }
    .ui-glass.top-right { top: 30px; right: 30px; }
    .ui-glass.bottom-right { bottom: 30px; right: 30px; }
    
    .scene-title {
      font-size: 18px;
      color: #fff;
      margin-bottom: 12px;
      font-weight: 400;
      letter-spacing: 2px;
      background: linear-gradient(45deg, #4ecdc4, #ff6b35);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }
    
    .scene-description {
      font-size: 10px;
      color: rgba(255,255,255,0.7);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 1px;
      line-height: 1.4;
    }
    
    .data-point {
      margin: 8px 0;
      font-size: 11px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .data-label {
      opacity: 0.8;
    }
    
    .data-value {
      font-weight: 500;
      color: #4ecdc4;
    }
    
    .energy-bar {
      width: 120px;
      height: 3px;
      background: rgba(255,255,255,0.1);
      margin: 6px 0;
      border-radius: 3px;
      overflow: hidden;
      position: relative;
    }
    
    .energy-fill {
      height: 100%;
      background: linear-gradient(90deg, #4ecdc4 0%, #44a08d 50%, #ff6b35 100%);
      width: 0%;
      transition: width 0.6s cubic-bezier(0.25, 0.1, 0.25, 1);
      border-radius: 3px;
      box-shadow: 0 0 10px rgba(78,205,196,0.5);
    }
    
    .hidden { display: none !important; }
    
    .particle-field {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .reality-particle {
      position: absolute;
      border-radius: 50%;
      background: rgba(78,205,196,0.6);
      animation: particleFlow 20s linear infinite;
      box-shadow: 0 0 20px rgba(78,205,196,0.4);
    }
    
    @keyframes particleFlow {
      0% { 
        transform: translateY(110vh) translateX(0) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      5% { opacity: 1; }
      95% { opacity: 1; }
      100% { 
        transform: translateY(-10vh) translateX(200px) scale(2) rotate(720deg); 
        opacity: 0; 
      }
    }
    
    .discovery-hint {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      color: rgba(255,255,255,0.9);
      text-align: center;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 3s ease;
      margin-top: 140px;
      font-weight: 300;
      max-width: 80%;
      background: rgba(0,0,0,0.2);
      padding: 16px 32px;
      border-radius: 24px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .discovery-hint.show { opacity: 1; }

    .cinematic-vignette {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(ellipse at center, transparent 20%, rgba(0,0,0,0.4) 70%, rgba(0,0,0,0.8) 100%);
      opacity: 0;
      transition: opacity 4s ease;
      z-index: 2;
    }
    
    .cinematic-vignette.active { opacity: 1; }
    
    .narrative-text {
      position: fixed;
      bottom: 50px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 16px;
      color: rgba(255,255,255,0.95);
      text-transform: uppercase;
      letter-spacing: 5px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: 200;
      text-align: center;
      background: rgba(0,0,0,0.3);
      padding: 16px 40px;
      border-radius: 30px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.2);
      max-width: 90%;
    }
    
    .narrative-text.visible { opacity: 1; }

    .spectrum-display {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 140px;
      pointer-events: none;
      z-index: 3;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 1px;
      padding: 0 40px;
    }
    
    .spectrum-bar {
      width: 3px;
      background: linear-gradient(0deg, 
        rgba(78,205,196,0.9) 0%, 
        rgba(68,160,141,0.7) 50%, 
        rgba(255,107,53,0.5) 100%);
      border-radius: 2px;
      transition: height 0.15s ease;
      min-height: 2px;
      box-shadow: 0 0 10px rgba(78,205,196,0.3);
    }

    .environment-fx {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }

    .rain-fx {
      position: absolute;
      width: 1px;
      height: 25px;
      background: linear-gradient(to bottom, transparent, rgba(174,194,224,0.8));
      animation: rainfall 0.8s linear infinite;
    }

    @keyframes rainfall {
      0% { transform: translateY(-30px); opacity: 0; }
      10% { opacity: 1; }
      100% { transform: translateY(100vh); opacity: 0; }
    }

    .snow-fx {
      position: absolute;
      width: 8px;
      height: 8px;
      background: rgba(255,255,255,0.9);
      border-radius: 50%;
      animation: snowfall 12s linear infinite;
      box-shadow: 0 0 10px rgba(255,255,255,0.5);
    }

    @keyframes snowfall {
      0% { transform: translateY(-20px) translateX(0); opacity: 0; }
      10% { opacity: 1; }
      100% { transform: translateY(100vh) translateX(150px); opacity: 0; }
    }

    .scene-transition {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(circle, rgba(78,205,196,0.2) 0%, rgba(0,0,0,0.9) 100%);
      opacity: 0;
      pointer-events: none;
      z-index: 50;
      transition: opacity 1.5s ease;
    }

    .scene-transition.active { opacity: 1; }

    .discovery-notification {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,0.9);
      color: #fff;
      padding: 30px 50px;
      border-radius: 20px;
      font-size: 18px;
      letter-spacing: 3px;
      backdrop-filter: blur(30px);
      border: 2px solid rgba(78,205,196,0.5);
      opacity: 0;
      z-index: 200;
      transition: opacity 0.8s ease;
      text-align: center;
      box-shadow: 0 20px 60px rgba(0,0,0,0.8);
    }

    .discovery-notification.show { 
      opacity: 1; 
      animation: discoveryPulse 0.6s ease-out;
    }

    @keyframes discoveryPulse {
      0% { transform: translate(-50%, -50%) scale(0.8); }
      50% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }

    .permission-modal {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      background: rgba(0,0,0,0.95);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 999;
      opacity: 1;
      transition: opacity 1s ease;
    }

    .permission-modal.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .permission-content {
      background: rgba(255,255,255,0.05);
      backdrop-filter: blur(30px);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 24px;
      padding: 40px;
      text-align: center;
      max-width: 500px;
      margin: 20px;
    }

    .permission-title {
      font-size: 24px;
      font-weight: 300;
      margin-bottom: 20px;
      color: #4ecdc4;
    }

    .permission-text {
      font-size: 14px;
      line-height: 1.6;
      margin-bottom: 30px;
      opacity: 0.8;
    }

    .permission-btn {
      background: linear-gradient(45deg, #4ecdc4, #44a08d);
      border: none;
      border-radius: 12px;
      color: white;
      padding: 16px 32px;
      font-size: 16px;
      letter-spacing: 2px;
      cursor: pointer;
      transition: all 0.3s ease;
      font-family: inherit;
    }

    .permission-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 10px 30px rgba(78,205,196,0.4);
    }

    @media (max-width: 768px) {
      .revolution-title { font-size: 48px; letter-spacing: 8px; }
      .revolution-subtitle { font-size: 14px; letter-spacing: 4px; }
      .enter-reality-btn { width: 160px; height: 160px; }
      .consciousness-orb { width: 60px; height: 60px; }
      .ui-glass { padding: 16px; margin: 20px; }
      .ui-glass.top-left, .ui-glass.top-right { top: 20px; }
      .ui-glass.bottom-left, .ui-glass.bottom-right { bottom: 20px; }
      .ui-glass.top-left, .ui-glass.bottom-left { left: 20px; }
      .ui-glass.top-right, .ui-glass.bottom-right { right: 20px; }
    }
  </style>
</head>
<body>
  <div class="permission-modal" id="permissionModal">
    <div class="permission-content">
      <h2 class="permission-title">ðŸŒŸ Revolutionary Experience Awaits</h2>
      <p class="permission-text">
        GUMP creates a living soundtrack that responds to your movement, location, and gestures. 
        Grant permissions to unlock the full revolutionary experience.
      </p>
      <button class="permission-btn" id="grantPermissions">GRANT PERMISSIONS & ENTER</button>
    </div>
  </div>

  <div class="loading-screen" id="loadingScreen">
    <div class="revolution-title">GUMP</div>
    <div class="revolution-subtitle">Revolutionary Reality Engine</div>
    <div class="tagline">Where Human Experience Becomes Music</div>
    <div class="enter-reality-btn" id="enterBtn">
      <div class="btn-text">ENTER REALITY</div>
      <div class="btn-subtext">Experience Revolution</div>
    </div>
  </div>
  
  <div class="reality-canvas" id="realityCanvas">
    <div class="consciousness-orb" id="consciousnessOrb"></div>
    
    <div class="discovery-hint" id="discoveryHint">MOVE TO DISCOVER â€¢ EXPLORE TO EVOLVE</div>
    
    <div class="ui-glass top-left">
      <div class="scene-title" id="sceneTitle">AWAKENING</div>
      <div class="scene-description" id="sceneDescription">Reality is loading...</div>
      <div class="data-point">
        <span class="data-label">Status</span>
        <span class="data-value" id="statusText">Initializing</span>
      </div>
    </div>
    
    <div class="ui-glass bottom-left">
      <div class="data-point">
        <span class="data-label">Motion Energy</span>
      </div>
      <div class="energy-bar">
        <div class="energy-fill" id="motionEnergy"></div>
      </div>
      <div class="data-point">
        <span class="data-label">Cinematic Intensity</span>
      </div>
      <div class="energy-bar">
        <div class="energy-fill" id="cinematicIntensity"></div>
      </div>
    </div>
    
    <div class="ui-glass top-right">
      <div class="data-point">
        <span class="data-label">BPM</span>
        <span class="data-value" id="bpmDisplay">72</span>
      </div>
      <div class="data-point">
        <span class="data-label">Key</span>
        <span class="data-value" id="keyDisplay">C MAJ</span>
      </div>
      <div class="data-point">
        <span class="data-label">Scene</span>
        <span class="data-value" id="sceneType">NEUTRAL</span>
      </div>
    </div>

    <div class="ui-glass bottom-right">
      <div class="data-point">
        <span class="data-label">Location</span>
        <span class="data-value" id="locationName">Unknown</span>
      </div>
      <div class="data-point">
        <span class="data-label">Weather</span>
        <span class="data-value" id="weatherDisplay">Clear</span>
      </div>
      <div class="data-point">
        <span class="data-label">Voices</span>
        <span class="data-value" id="voiceCount">0</span>
      </div>
    </div>
    
    <div class="spectrum-display" id="spectrumDisplay"></div>
  </div>

  <div class="cinematic-vignette" id="cinematicVignette"></div>
  <div class="narrative-text" id="narrativeText"></div>
  <div class="environment-fx" id="environmentFx"></div>
  <div class="scene-transition" id="sceneTransition"></div>
  <div class="discovery-notification" id="discoveryNotification"></div>

  <script>
    class RevolutionaryRealityEngine {
      constructor() {
        this.isActive = false;
        this.audioContext = null;
        this.analyser = null;
        this.audioData = null;
        this.permissionsGranted = false;
        
        // Revolutionary Core Systems
        this.consciousness = {
          bpm: 72,
          step: 0,
          intensity: 0,
          emotion: 'neutral',
          narrative: 0,
          climax: false
        };
        
        // Location & Environmental Intelligence  
        this.environment = {
          currentLocation: { lat: null, lng: null },
          placeType: 'unknown',
          weather: null,
          timeOfDay: this.getTimeOfDay(),
          movementDistance: 0,
          contextualAudio: new Map()
        };
        
        // Advanced Motion Analysis
        this.motion = {
          intensity: 0,
          pattern: 'still',
          gesture: 'none',
          position: { x: 50, y: 50 },
          velocity: { x: 0, y: 0 },
          history: []
        };
        
        // Cinematic Orchestration
        this.orchestra = {
          strings: { active: [], max: 20 },
          brass: { active: [], max: 12 },
          percussion: { active: [], max: 8 },
          ambient: { active: [], max: 15 },
          contextual: { active: [], max: 10 }
        };
        
        // Revolutionary Features
        this.discoveries = {
          found: new Set(),
          secrets: [
            { name: 'HIDDEN HARMONY', trigger: 'stillness_in_nature', unlocked: false },
            { name: 'URBAN SYMPHONY', trigger: 'rhythmic_city_walk', unlocked: false },
            { name: 'SCHOOL MEMORIES', trigger: 'playground_dance', unlocked: false },
            { name: 'STORM REVELATION', trigger: 'rain_intensity', unlocked: false },
            { name: 'MIDNIGHT TRANSCENDENCE', trigger: 'night_meditation', unlocked: false }
          ]
        };
        
        // Professional Audio Architecture
        this.audio = {
          master: null,
          buses: new Map(),
          effects: new Map(),
          samples: new Map()
        };
        
        this.ui = new Map();
        this.spectrumBars = [];
        this.particleSystem = [];
        
        this.init();
      }

      init() {
        // Cache UI elements
        [
          'permissionModal', 'grantPermissions', 'loadingScreen', 'enterBtn', 
          'realityCanvas', 'consciousnessOrb', 'discoveryHint', 'sceneTitle', 
          'sceneDescription', 'statusText', 'motionEnergy', 'cinematicIntensity',
          'bpmDisplay', 'keyDisplay', 'sceneType', 'locationName', 'weatherDisplay',
          'voiceCount', 'spectrumDisplay', 'cinematicVignette', 'narrativeText',
          'environmentFx', 'sceneTransition', 'discoveryNotification'
        ].forEach(id => this.ui.set(id, document.getElementById(id)));
        
        this.ui.get('grantPermissions').onclick = () => this.requestPermissions();
        this.ui.get('enterBtn').onclick = () => this.enterReality();
        
        this.setupSpectrumVisualizer();
        this.startEnvironmentalSensing();
      }

      setupSpectrumVisualizer() {
        const display = this.ui.get('spectrumDisplay');
        for (let i = 0; i < 128; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.height = '2px';
          display.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      async requestPermissions() {
        try {
          // Request device motion permission
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              throw new Error('Motion permission is required for the revolutionary experience');
            }
          }

          // Request device orientation permission  
          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              throw new Error('Orientation permission enhances spatial audio');
            }
          }

          this.permissionsGranted = true;
          this.ui.get('permissionModal').classList.add('hidden');
          
          // Show revolutionary features are unlocked
          this.showDiscovery('ðŸŽµ REVOLUTIONARY FEATURES UNLOCKED');
          
        } catch (error) {
          console.error('Permission request failed:', error);
          alert('Some features may be limited without permissions. You can still experience the revolution!');
          this.ui.get('permissionModal').classList.add('hidden');
        }
      }

      async enterReality() {
        try {
          // Initialize revolutionary audio context
          this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
          await this.audioContext.resume();
          
          // Setup professional audio architecture
          this.setupRevolutionaryAudio();
          
          // Start motion detection systems
          this.initializeMotionSystems();
          
          // Begin location intelligence
          this.startLocationIntelligence();
          
          // Transition to reality
          this.ui.get('loadingScreen').classList.add('hidden');
          this.ui.get('realityCanvas').classList.add('active');
          
          // Show discovery hint
          setTimeout(() => {
            this.ui.get('discoveryHint').classList.add('show');
            setTimeout(() => this.ui.get('discoveryHint').classList.remove('show'), 6000);
          }, 2000);

          this.isActive = true;
          this.startRevolutionaryEngine();
          this.animate();
          
          console.log('ðŸš€ Revolutionary Reality Engine: ACTIVATED');
          
        } catch (error) {
          console.error('Reality initialization failed:', error);
          alert('Unable to enter reality. Please refresh and try again.');
        }
      }

      setupRevolutionaryAudio() {
        // Master analytics
        this.analyser = this.audioContext.createAnalyser();
        this.analyser.fftSize = 256;
        this.audioData = new Uint8Array(this.analyser.frequencyBinCount);
        
        // Professional mastering chain
        const masterCompressor = this.audioContext.createDynamicsCompressor();
        masterCompressor.threshold.value = -12;
        masterCompressor.knee.value = 6;
        masterCompressor.ratio.value = 4;
        masterCompressor.attack.value = 0.003;
        masterCompressor.release.value = 0.2;
        
        // Cinematic EQ
        const lowBoost = this.audioContext.createBiquadFilter();
        lowBoost.type = 'lowshelf';
        lowBoost.frequency.value = 150;
        lowBoost.gain.value = 3;
        
        const highShine = this.audioContext.createBiquadFilter();
        highShine.type = 'highshelf';
        highShine.frequency.value = 10000;
        highShine.gain.value = 2;
        
        // Revolutionary reverb
        const convolver = this.audioContext.createConvolver();
        convolver.buffer = this.createCinematicSpace();
        
        // Master output
        this.audio.master = this.audioContext.createGain();
        this.audio.master.gain.value = 0.8;
        
        // Create instrument buses with spatial positioning
        ['strings', 'brass', 'percussion', 'ambient', 'contextual'].forEach(instrument => {
          const bus = this.audioContext.createGain();
          bus.gain.value = 0.7;
          
          const panner = this.audioContext.createPanner();
          panner.panningModel = 'HRTF';
          panner.distanceModel = 'inverse';
          panner.refDistance = 1;
          panner.maxDistance = 10000;
          
          bus.connect(panner);
          panner.connect(masterCompressor);
          
          this.audio.buses.set(instrument, bus);
          this.audio.effects.set(instrument, panner);
        });
        
        // Connect mastering chain
        masterCompressor.connect(lowBoost);
        lowBoost.connect(highShine);
        highShine.connect(convolver);
        convolver.connect(this.analyser);
        this.analyser.connect(this.audio.master);
        this.audio.master.connect(this.audioContext.destination);
        
        // Create revolutionary samples
        this.createRevolutionarySamples();
      }

      createCinematicSpace() {
        const length = this.audioContext.sampleRate * 3;
        const buffer = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const channelData = buffer.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, 1.5);
            channelData[i] = (Math.random() * 2 - 1) * decay * 0.3;
          }
        }
        return buffer;
      }

      createRevolutionarySamples() {
        // Create contextual audio samples
        this.audio.samples.set('schoolBell', this.synthesizeSchoolBell());
        this.audio.samples.set('cityAmbient', this.synthesizeCityAmbient());
        this.audio.samples.set('natureAmbient', this.synthesizeNatureAmbient());
        this.audio.samples.set('rainTexture', this.synthesizeRain());
        this.audio.samples.set('windTexture', this.synthesizeWind());
      }

      synthesizeSchoolBell() {
        const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 2, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          const t = i / this.audioContext.sampleRate;
          const decay = Math.exp(-t * 3);
          const bell = Math.sin(2 * Math.PI * 800 * t) + Math.sin(2 * Math.PI * 1600 * t) * 0.5;
          data[i] = bell * decay * 0.4;
        }
        return buffer;
      }

      synthesizeCityAmbient() {
        const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 30, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          const t = i / this.audioContext.sampleRate;
          let sample = Math.random() * 2 - 1;
          sample *= 0.05 * (0.8 + 0.2 * Math.sin(t * 0.1)); // Traffic rumble
          data[i] = sample;
        }
        return buffer;
      }

      synthesizeNatureAmbient() {
        const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 20, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          const t = i / this.audioContext.sampleRate;
          let sample = 0;
          
          // Multiple bird frequencies
          for (let bird = 0; bird < 4; bird++) {
            const freq = 1500 + bird * 600 + 300 * Math.sin(t * 0.3);
            const chirp = Math.sin(2 * Math.PI * freq * t);
            const envelope = Math.max(0, Math.sin(t * 1.5 + bird) * 0.2);
            sample += chirp * envelope;
          }
          data[i] = sample * 0.1;
        }
        return buffer;
      }

      synthesizeRain() {
        const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 10, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.06;
        }
        return buffer;
      }

      synthesizeWind() {
        const buffer = this.audioContext.createBuffer(1, this.audioContext.sampleRate * 15, this.audioContext.sampleRate);
        const data = buffer.getChannelData(0);
        
        for (let i = 0; i < data.length; i++) {
          const t = i / this.audioContext.sampleRate;
          let wind = Math.random() * 2 - 1;
          wind *= 0.1 * (0.6 + 0.4 * Math.sin(t * 0.2));
          data[i] = wind;
        }
        return buffer;
      }

      initializeMotionSystems() {
        let accelerationBuffer = [];
        let lastAcceleration = { x: 0, y: 0, z: 0 };

        // Advanced device motion analysis
        window.addEventListener('devicemotion', (event) => {
          if (!this.isActive) return;
          
          const acc = event.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          // Calculate motion vectors
          const deltaX = Math.abs(acc.x - lastAcceleration.x);
          const deltaY = Math.abs(acc.y - lastAcceleration.y);
          const deltaZ = Math.abs(acc.z - lastAcceleration.z);
          
          const motionMagnitude = Math.sqrt(deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ) * 0.4;
          
          accelerationBuffer.push(motionMagnitude);
          if (accelerationBuffer.length > 90) accelerationBuffer.shift(); // 1.5 seconds at 60fps
          
          this.analyzeMotionIntelligence(accelerationBuffer);
          this.updatePosition(acc);
          
          lastAcceleration = { x: acc.x, y: acc.y, z: acc.z };
        });

        // Mouse/touch motion for desktop experience
        let lastPointer = { x: 0, y: 0, time: 0 };
        const handlePointerMovement = (e) => {
          if (!this.isActive) return;
          
          const now = Date.now();
          const deltaTime = Math.max(1, now - lastPointer.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastPointer.x) / deltaTime * 40;
          const velocityY = (newY - lastPointer.y) / deltaTime * 40;
          
          const pointerMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
          accelerationBuffer.push(pointerMotion);
          if (accelerationBuffer.length > 90) accelerationBuffer.shift();
          
          this.analyzeMotionIntelligence(accelerationBuffer);
          
          this.motion.position.x = newX;
          this.motion.position.y = newY;
          
          lastPointer = { x: newX, y: newY, time: now };
        };

        window.addEventListener('mousemove', handlePointerMovement);
        window.addEventListener('touchmove', (e) => {
          if (e.touches.length > 0) {
            handlePointerMovement(e.touches[0]);
          }
        });
      }

      analyzeMotionIntelligence(buffer) {
        if (buffer.length < 20) return;
        
        const average = buffer.reduce((a, b) => a + b, 0) / buffer.length;
        const variance = buffer.reduce((sum, val) => sum + Math.pow(val - average, 2), 0) / buffer.length;
        const standardDev = Math.sqrt(variance);
        
        // Update motion metrics
        this.motion.intensity = average;
        this.motion.history.push(average);
        if (this.motion.history.length > 300) this.motion.history.shift();
        
        // Classify motion patterns with revolutionary intelligence
        this.motion.pattern = this.classifyRevolutionaryMotion(buffer, average, standardDev);
        
        // Update cinematic intensity
        this.consciousness.intensity = this.consciousness.intensity * 0.9 + (average + standardDev) * 0.1;
        
        // Detect revolutionary gestures
        this.detectRevolutionaryGestures(buffer);
      }

      classifyRevolutionaryMotion(buffer, avg, stdDev) {
        const recent = buffer.slice(-30);
        const peaks = recent.filter(v => v > avg + stdDev).length;
        const rhythmicScore = this.calculateRhythmicScore(recent);
        
        if (avg < 0.3) return 'meditation';
        if (rhythmicScore > 0.8 && peaks > 15) return 'dancing';
        if (avg > 4 && stdDev < 1) return 'running';
        if (stdDev > 4) return 'expression';
        if (avg > 2) return 'exploration';
        if (avg > 1) return 'wandering';
        return 'contemplation';
      }

      calculateRhythmicScore(buffer) {
        const intervals = [];
        let lastPeak = -1;
        
        for (let i = 1; i < buffer.length - 1; i++) {
          if (buffer[i] > buffer[i-1] && buffer[i] > buffer[i+1] && buffer[i] > 2) {
            if (lastPeak >= 0) {
              intervals.push(i - lastPeak);
            }
            lastPeak = i;
          }
        }
        
        if (intervals.length < 3) return 0;
        
        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const variance = intervals.reduce((sum, val) => sum + Math.pow(val - avgInterval, 2), 0) / intervals.length;
        
        return Math.max(0, 1 - (Math.sqrt(variance) / avgInterval));
      }

      detectRevolutionaryGestures(buffer) {
        const recent = buffer.slice(-40);
        if (recent.length < 40) return;
        
        // Detect spiral gestures
        if (this.detectSpiral(recent)) {
          this.motion.gesture = 'spiral';
          this.triggerDiscovery('SPIRAL_GESTURE');
        }
        // Detect wave gestures  
        else if (this.detectWave(recent)) {
          this.motion.gesture = 'wave';
          this.triggerDiscovery('WAVE_GESTURE');
        }
        // Detect pulse gestures
        else if (this.detectPulse(recent)) {
          this.motion.gesture = 'pulse';
          this.triggerDiscovery('PULSE_GESTURE');
        }
        else {
          this.motion.gesture = 'none';
        }
      }

      detectSpiral(data) {
        // Look for increasing then decreasing intensity pattern
        let ascent = 0, descent = 0;
        for (let i = 1; i < data.length / 2; i++) {
          if (data[i] > data[i-1]) ascent++;
        }
        for (let i = data.length / 2; i < data.length - 1; i++) {
          if (data[i] < data[i+1]) descent++;
        }
        return ascent > 8 && descent > 8;
      }

      detectWave(data) {
        // Look for oscillating pattern
        let direction = 0;
        let changes = 0;
        for (let i = 1; i < data.length; i++) {
          const newDirection = data[i] > data[i-1] ? 1 : -1;
          if (newDirection !== direction) changes++;
          direction = newDirection;
        }
        return changes > 10 && changes < 25;
      }

      detectPulse(data) {
        // Look for rhythmic spikes
        const spikes = data.filter(v => v > 3).length;
        const avg = data.reduce((a, b) => a + b, 0) / data.length;
        return spikes > 5 && spikes < 15 && avg > 1.5;
      }

      updatePosition(acceleration) {
        this.motion.velocity.x += acceleration.x * 0.008;
        this.motion.velocity.y += acceleration.y * 0.008;
        
        this.motion.position.x += this.motion.velocity.x;
        this.motion.position.y += this.motion.velocity.y;
        
        // Boundary physics with damping
        if (this.motion.position.x < 2 || this.motion.position.x > 98) {
          this.motion.velocity.x *= -0.7;
        }
        if (this.motion.position.y < 2 || this.motion.position.y > 98) {
          this.motion.velocity.y *= -0.7;
        }
        
        this.motion.position.x = Math.max(2, Math.min(98, this.motion.position.x));
        this.motion.position.y = Math.max(2, Math.min(98, this.motion.position.y));
        
        // Apply natural friction
        this.motion.velocity.x *= 0.94;
        this.motion.velocity.y *= 0.94;
      }

      startLocationIntelligence() {
        if (!navigator.geolocation) {
          console.warn('Geolocation not available - using simulated locations');
          this.simulateLocationChanges();
          return;
        }

        const options = {
          enableHighAccuracy: true,
          timeout: 15000,
          maximumAge: 60000
        };

        navigator.geolocation.watchPosition(
          (position) => this.processLocationUpdate(position),
          (error) => {
            console.error('Location error:', error);
            this.simulateLocationChanges();
          },
          options
        );

        // Environmental sensing
        this.startEnvironmentalSensing();
      }

      async processLocationUpdate(position) {
        const { latitude, longitude, accuracy } = position.coords;
        
        // Calculate movement distance
        if (this.environment.currentLocation.lat !== null) {
          const distance = this.calculateDistance(
            this.environment.currentLocation.lat, this.environment.currentLocation.lng,
            latitude, longitude
          );
          this.environment.movementDistance += distance;
        }
        
        this.environment.currentLocation = { lat: latitude, lng: longitude, accuracy };
        
        // Analyze new location context
        await this.analyzeLocationContext();
        this.updateLocationBasedMusic();
        this.checkLocationDiscoveries();
      }

      calculateDistance(lat1, lon1, lat2, lon2) {
        const R = 6371000; // Earth radius in meters
        const dLat = (lat2 - lat1) * Math.PI / 180;
        const dLon = (lon2 - lon1) * Math.PI / 180;
        const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
          Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
          Math.sin(dLon/2) * Math.sin(dLon/2);
        return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)) * R;
      }

      simulateLocationChanges() {
        // Simulate different location types based on time and motion
        setInterval(() => {
          if (!this.isActive) return;
          
          const hour = new Date().getHours();
          const motionLevel = this.motion.intensity;
          
          let newPlaceType = 'neutral';
          if (hour >= 8 && hour <= 15 && motionLevel < 1) {
            newPlaceType = 'school';
          } else if (motionLevel > 2 && hour > 6 && hour < 22) {
            newPlaceType = 'urban';
          } else if (motionLevel < 1 && this.motion.pattern === 'meditation') {
            newPlaceType = 'nature';
          } else if (hour >= 22 || hour <= 6) {
            newPlaceType = 'night';
          } else if (motionLevel > 1 && motionLevel < 3) {
            newPlaceType = 'park';
          }
          
          if (newPlaceType !== this.environment.placeType) {
            this.environment.placeType = newPlaceType;
            this.updateLocationBasedMusic();
          }
        }, 15000);
      }

      async analyzeLocationContext() {
        // Simulate advanced location analysis
        const timeOfDay = this.getTimeOfDay();
        const motionPattern = this.motion.pattern;
        
        // Determine place type based on context
        if (timeOfDay === 'morning' && motionPattern === 'contemplation') {
          this.environment.placeType = 'nature';
        } else if (this.motion.intensity > 2) {
          this.environment.placeType = 'urban';
        } else if (timeOfDay === 'night') {
          this.environment.placeType = 'night';
        } else if (motionPattern === 'dancing') {
          this.environment.placeType = 'park';
        } else {
          this.environment.placeType = 'neutral';
        }
        
        await this.updateWeatherIntelligence();
      }

      async updateWeatherIntelligence() {
        // Simulate weather conditions
        const conditions = ['clear', 'cloudy', 'rain', 'storm', 'snow'];
        const randomCondition = conditions[Math.floor(Math.random() * conditions.length)];
        
        this.environment.weather = {
          condition: randomCondition,
          temperature: 20 + Math.random() * 10,
          intensity: Math.random()
        };
        
        this.createWeatherEffects();
        this.ui.get('weatherDisplay').textContent = 
          `${this.environment.weather.condition} ${Math.round(this.environment.weather.temperature)}Â°C`;
      }

      createWeatherEffects() {
        const fx = this.ui.get('environmentFx');
        fx.innerHTML = '';
        
        switch (this.environment.weather.condition) {
          case 'rain':
            this.createRainEffect(fx);
            this.playContextualAudio('rainTexture', 0.2);
            break;
          case 'snow':
            this.createSnowEffect(fx);
            break;
          case 'storm':
            this.createRainEffect(fx);
            this.playContextualAudio('windTexture', 0.3);
            break;
        }
      }

      createRainEffect(container) {
        for (let i = 0; i < 80; i++) {
          const drop = document.createElement('div');
          drop.className = 'rain-fx';
          drop.style.left = Math.random() * 100 + '%';
          drop.style.animationDelay = Math.random() * 2 + 's';
          drop.style.animationDuration = (0.4 + Math.random() * 0.4) + 's';
          container.appendChild(drop);
        }
      }

      createSnowEffect(container) {
        for (let i = 0; i < 40; i++) {
          const flake = document.createElement('div');
          flake.className = 'snow-fx';
          flake.style.left = Math.random() * 100 + '%';
          flake.style.animationDelay = Math.random() * 10 + 's';
          flake.style.animationDuration = (6 + Math.random() * 6) + 's';
          container.appendChild(flake);
        }
      }

      updateLocationBasedMusic() {
        const placeThemes = {
          school: { key: 'F', mode: 'major', bpm: 85, mood: 'playful' },
          urban: { key: 'Dm', mode: 'minor', bpm: 100, mood: 'energetic' },
          nature: { key: 'G', mode: 'major', bpm: 65, mood: 'peaceful' },
          park: { key: 'A', mode: 'major', bpm: 78, mood: 'joyful' },
          night: { key: 'Am', mode: 'minor', bpm: 55, mood: 'contemplative' },
          neutral: { key: 'C', mode: 'major', bpm: 72, mood: 'balanced' }
        };
        
        const theme = placeThemes[this.environment.placeType] || placeThemes.neutral;
        
        // Smooth BPM transition
        this.consciousness.targetBPM = theme.bpm + (this.motion.intensity * 15);
        
        // Update UI
        this.ui.get('sceneType').textContent = this.environment.placeType.toUpperCase();
        this.ui.get('keyDisplay').textContent = `${theme.key} ${theme.mode.toUpperCase()}`;
        this.ui.get('locationName').textContent = this.getLocationDisplayName();
        
        // Visual theme update
        this.updateVisualTheme(theme);
        
        // Play contextual audio
        this.playLocationAudio();
        
        // Show scene transition
        this.showSceneTransition(theme);
      }

      getLocationDisplayName() {
        const displayNames = {
          school: 'Learning Sanctuary',
          urban: 'Concrete Symphony',
          nature: 'Natural Cathedral',  
          park: 'Community Garden',
          night: 'Midnight Realm',
          neutral: 'Open Space'
        };
        return displayNames[this.environment.placeType] || 'Unknown Territory';
      }

      updateVisualTheme(theme) {
        const orb = this.ui.get('consciousnessOrb');
        orb.className = 'consciousness-orb';
        
        switch (theme.mood) {
          case 'energetic':
            orb.classList.add('urban');
            break;
          case 'peaceful':
          case 'joyful':
            orb.classList.add('nature');
            break;
          case 'contemplative':
            orb.classList.add('transcendent');
            break;
        }
        
        this.updateCinematicBackground(theme);
      }

      updateCinematicBackground(theme) {
        const moodColors = {
          playful: ['#f39c12', '#e74c3c', '#9b59b6'],
          energetic: ['#ff6b35', '#e67e22', '#d35400'],
          peaceful: ['#4ecdc4', '#52c2aa', '#45a293'],
          joyful: ['#2ecc71', '#27ae60', '#16a085'],
          contemplative: ['#34495e', '#2c3e50', '#1a252f'],
          balanced: ['#3498db', '#2980b9', '#21618c']
        };
        
        const colors = moodColors[theme.mood] || moodColors.balanced;
        const x = this.motion.position.x;
        const y = this.motion.position.y;
        const intensity = Math.min(this.consciousness.intensity * 30, 70);
        
        const gradient = `radial-gradient(ellipse at ${x}% ${y}%, ${colors[0]} 0%, ${colors[1]} ${25 + intensity}%, ${colors[2]} ${60 + intensity}%, #000 100%)`;
        document.body.style.background = gradient;
      }

      showSceneTransition(theme) {
        const transition = this.ui.get('sceneTransition');
        transition.classList.add('active');
        
        setTimeout(() => {
          transition.classList.remove('active');
        }, 1500);
        
        // Show narrative text
        const narrativeTexts = {
          playful: 'Echoes of Childhood',
          energetic: 'Urban Heartbeat', 
          peaceful: 'Natural Harmony',
          joyful: 'Community Spirit',
          contemplative: 'Midnight Reflection',
          balanced: 'Open Possibilities'
        };
        
        const narrative = this.ui.get('narrativeText');
        narrative.textContent = narrativeTexts[theme.mood] || 'Story Unfolds';
        narrative.classList.add('visible');
        
        setTimeout(() => {
          narrative.classList.remove('visible');
        }, 4000);
      }

      playLocationAudio() {
        switch (this.environment.placeType) {
          case 'school':
            if (Math.random() < 0.4) {
              this.playContextualAudio('schoolBell', 0.3);
            }
            break;
          case 'urban':
            this.playContextualAudio('cityAmbient', 0.1);
            break;
          case 'nature':
          case 'park':
            this.playContextualAudio('natureAmbient', 0.2);
            break;
        }
      }

      playContextualAudio(sampleName, volume) {
        const sample = this.audio.samples.get(sampleName);
        if (!sample) return;
        
        const source = this.audioContext.createBufferSource();
        const gain = this.audioContext.createGain();
        
        source.buffer = sample;
        gain.gain.value = volume * (0.7 + Math.random() * 0.6);
        
        source.connect(gain);
        gain.connect(this.audio.buses.get('contextual'));
        
        source.start();
      }

      checkLocationDiscoveries() {
        this.discoveries.secrets.forEach(secret => {
          if (secret.unlocked) return;
          
          if (this.checkDiscoveryCondition(secret.trigger)) {
            this.triggerDiscovery(secret.name);
            secret.unlocked = true;
          }
        });
      }

      checkDiscoveryCondition(trigger) {
        switch (trigger) {
          case 'stillness_in_nature':
            return this.environment.placeType === 'nature' && 
                   this.motion.pattern === 'meditation' && 
                   this.motion.intensity < 0.2;
          
          case 'rhythmic_city_walk':
            return this.environment.placeType === 'urban' && 
                   this.motion.pattern === 'exploration';
          
          case 'playground_dance': 
            return (this.environment.placeType === 'school' || this.environment.placeType === 'park') && 
                   this.motion.pattern === 'dancing';
          
          case 'rain_intensity':
            return this.environment.weather?.condition === 'rain' && 
                   this.consciousness.intensity > 0.8;
          
          case 'night_meditation':
            return this.environment.placeType === 'night' && 
                   this.motion.pattern === 'meditation';
          
          default:
            return false;
        }
      }

      triggerDiscovery(discoveryName) {
        if (this.discoveries.found.has(discoveryName)) return;
        
        this.discoveries.found.add(discoveryName);
        this.showDiscovery(`ðŸŽµ DISCOVERED: ${discoveryName}`);
        this.playDiscoveryAudio(discoveryName);
        
        console.log(`ðŸŽ¬ Revolutionary Discovery: ${discoveryName}`);
      }

      showDiscovery(message) {
        const notification = this.ui.get('discoveryNotification');
        notification.textContent = message;
        notification.classList.add('show');
        
        setTimeout(() => {
          notification.classList.remove('show');
        }, 4000);
      }

      playDiscoveryAudio(discoveryName) {
        // Play special harmonic sequences for discoveries
        const discoveryMelodies = {
          'HIDDEN HARMONY': [60, 64, 67, 72, 76], // C major pentatonic
          'URBAN SYMPHONY': [62, 65, 69, 74, 77], // D minor pentatonic
          'SCHOOL MEMORIES': [65, 69, 72, 77, 81], // F major pentatonic
          'STORM REVELATION': [57, 60, 64, 67, 72], // A minor pentatonic
          'MIDNIGHT TRANSCENDENCE': [69, 72, 76, 81, 84] // A major pentatonic
        };
        
        const melody = discoveryMelodies[discoveryName] || discoveryMelodies['HIDDEN HARMONY'];
        
        melody.forEach((note, i) => {
          setTimeout(() => {
            this.playNote(note, 'ambient', 1.0, 2.0);
          }, i * 600);
        });
      }

      startRevolutionaryEngine() {
        let lastBeat = Date.now();
        
        const revolutionaryTick = () => {
          if (!this.isActive) return;
          
          const now = Date.now();
          const beatInterval = (60 / this.consciousness.bpm) * 1000;
          
          if (now - lastBeat >= beatInterval) {
            this.playRevolutionaryBeat();
            this.consciousness.step++;
            lastBeat = now;
          }
          
          // Smooth BPM transitions
          if (this.consciousness.targetBPM) {
            const bpmDiff = this.consciousness.targetBPM - this.consciousness.bpm;
            this.consciousness.bpm += bpmDiff * 0.02;
            if (Math.abs(bpmDiff) < 0.5) this.consciousness.targetBPM = null;
          }
          
          setTimeout(revolutionaryTick, 20); // High precision timing
        };
        
        revolutionaryTick();
      }

      playRevolutionaryBeat() {
        // Revolutionary beat indicator
        if (this.consciousness.step % 4 === 0) {
          this.ui.get('consciousnessOrb').classList.add('heartbeat');
          setTimeout(() => {
            this.ui.get('consciousnessOrb').classList.remove('heartbeat');
          }, 600);
        }
        
        // Dynamic orchestration based on consciousness state
        this.orchestrateRevolutionaryMusic();
      }

      orchestrateRevolutionaryMusic() {
        const intensity = this.consciousness.intensity;
        const motionPattern = this.motion.pattern;
        const step = this.consciousness.step;
        
        // Foundation rhythm (adaptive to motion)
        if (step % 4 === 0 || (intensity > 0.5 && step % 2 === 0)) {
          this.playFoundationBeat(intensity);
        }
        
        // Melodic elements (respond to gesture and location)
        if (step % 8 === 0 || (motionPattern === 'dancing' && step % 4 === 0)) {
          this.playMelodicPhrase(intensity);
        }
        
        // Harmonic layers (build with intensity)
        if (step % 16 === 0 && intensity > 0.3) {
          this.playHarmonicLayer(intensity);
        }
        
        // Atmospheric textures (location-dependent)
        if (Math.random() < 0.1 * intensity) {
          this.playAtmosphericTexture();
        }
        
        // Contextual elements (special patterns)
        if (this.motion.gesture !== 'none') {
          this.playGestureResponse();
        }
      }

      playFoundationBeat(intensity) {
        // Adaptive bass foundation
        const rootNote = this.getCurrentRootNote();
        const velocity = 0.7 + intensity * 0.3;
        
        this.playNote(rootNote - 12, 'strings', velocity, 0.8);
        
        // Add percussion for higher intensities
        if (intensity > 0.4) {
          this.playPercussiveElement('kick', velocity);
        }
      }

      playMelodicPhrase(intensity) {
        const scale = this.getCurrentScale();
        const noteIndex = (this.consciousness.step / 8) % scale.length;
        const note = scale[noteIndex];
        const octaveShift = Math.floor(intensity * 2);
        
        this.playNote(note + (octaveShift * 12), 'brass', 0.6 + intensity * 0.4, 1.5);
      }

      playHarmonicLayer(intensity) {
        const chord = this.getCurrentChord();
        const baseOctave = 4;
        
        chord.forEach((note, i) => {
          setTimeout(() => {
            this.playNote(note + (baseOctave * 12), 'strings', 0.3 + intensity * 0.2, 4.0);
          }, i * 150);
        });
      }

      playAtmosphericTexture() {
        const scale = this.getCurrentScale();
        const randomNote = scale[Math.floor(Math.random() * scale.length)];
        const highOctave = 5 + Math.random() * 2;
        
        this.playNote(randomNote + (highOctave * 12), 'ambient', 0.2 + Math.random() * 0.3, 8.0 + Math.random() * 12);
      }

      playGestureResponse() {
        switch (this.motion.gesture) {
          case 'spiral':
            // Ascending spiral melody
            for (let i = 0; i < 5; i++) {
              setTimeout(() => {
                const note = 60 + (i * 7); // Perfect fifths
                this.playNote(note, 'ambient', 0.5, 1.0);
              }, i * 200);
            }
            break;
          
          case 'wave':
            // Oscillating wave pattern
            [0, 4, 2, 5, 1, 6, 3, 7].forEach((interval, i) => {
              setTimeout(() => {
                const note = 60 + interval;
                this.playNote(note, 'ambient', 0.4, 0.8);
              }, i * 100);
            });
            break;
          
          case 'pulse':
            // Rhythmic pulse bursts
            for (let i = 0; i < 3; i++) {
              setTimeout(() => {
                this.playPercussiveElement('pulse', 0.8);
              }, i * 300);
            }
            break;
        }
      }

      playNote(midiNote, instrument, velocity, duration) {
        const frequency = 440 * Math.pow(2, (midiNote - 69) / 12);
        
        if (!this.allocateVoice(instrument)) return;
        
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const envelope = this.audioContext.createGain();
        
        // Instrument-specific waveforms
        const waveforms = {
          strings: 'sawtooth',
          brass: 'square',
          percussion: 'triangle',
          ambient: 'sine',
          contextual: 'sine'
        };
        
        oscillator.type = waveforms[instrument] || 'sine';
        oscillator.frequency.value = frequency;
        
        // Advanced ADSR envelope
        const attack = 0.05;
        const decay = 0.2;
        const sustain = velocity * 0.6;
        const release = Math.max(0.1, duration * 0.3);
        
        envelope.gain.setValueAtTime(0, this.audioContext.currentTime);
        envelope.gain.linearRampToValueAtTime(velocity, this.audioContext.currentTime + attack);
        envelope.gain.linearRampToValueAtTime(sustain, this.audioContext.currentTime + attack + decay);
        envelope.gain.setValueAtTime(sustain, this.audioContext.currentTime + duration - release);
        envelope.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + duration);
        
        gainNode.gain.value = 1.0;
        
        oscillator.connect(envelope);
        envelope.connect(gainNode);
        gainNode.connect(this.audio.buses.get(instrument) || this.audio.buses.get('ambient'));
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + duration);
        
        // Clean up voice tracking
        setTimeout(() => {
          this.releaseVoice(instrument);
        }, duration * 1000 + 100);
      }

      playPercussiveElement(type, velocity) {
        const oscillator = this.audioContext.createOscillator();
        const gainNode = this.audioContext.createGain();
        const envelope = this.audioContext.createGain();
        
        if (type === 'kick') {
          oscillator.type = 'sine';
          oscillator.frequency.setValueAtTime(60, this.audioContext.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(20, this.audioContext.currentTime + 0.1);
          
          envelope.gain.setValueAtTime(velocity, this.audioContext.currentTime);
          envelope.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.3);
          
        } else if (type === 'pulse') {
          oscillator.type = 'square';
          oscillator.frequency.value = 1000 + Math.random() * 2000;
          
          envelope.gain.setValueAtTime(velocity * 0.5, this.audioContext.currentTime);
          envelope.gain.exponentialRampToValueAtTime(0.001, this.audioContext.currentTime + 0.1);
        }
        
        gainNode.gain.value = 0.8;
        
        oscillator.connect(envelope);
        envelope.connect(gainNode);
        gainNode.connect(this.audio.buses.get('percussion'));
        
        oscillator.start();
        oscillator.stop(this.audioContext.currentTime + 0.3);
      }

      allocateVoice(instrument) {
        const orchestraSection = this.orchestra[instrument];
        if (!orchestraSection) return false;
        
        // Clean up expired voices
        const currentTime = this.audioContext.currentTime;
        orchestraSection.active = orchestraSection.active.filter(voice => 
          voice.endTime > currentTime
        );
        
        // Check capacity
        if (orchestraSection.active.length >= orchestraSection.max) {
          // Remove oldest voice
          orchestraSection.active.shift();
        }
        
        // Add new voice
        const voice = { 
          startTime: currentTime, 
          endTime: currentTime + 15 // Max voice duration
        };
        orchestraSection.active.push(voice);
        
        return true;
      }

      releaseVoice(instrument) {
        const orchestraSection = this.orchestra[instrument];
        if (!orchestraSection || orchestraSection.active.length === 0) return;
        
        orchestraSection.active.shift();
      }

      getCurrentRootNote() {
        // Map location types to root notes
        const locationRoots = {
          school: 65, // F
          urban: 62,  // D
          nature: 67, // G
          park: 69,   // A
          night: 57,  // A (lower octave)
          neutral: 60 // C
        };
        return locationRoots[this.environment.placeType] || 60;
      }

      getCurrentScale() {
        const rootNote = this.getCurrentRootNote();
        const scalePattern = [0, 2, 4, 5, 7, 9, 11]; // Major scale
        return scalePattern.map(interval => rootNote + interval);
      }

      getCurrentChord() {
        const rootNote = this.getCurrentRootNote();
        return [rootNote, rootNote + 4, rootNote + 7]; // Major triad
      }

      getTimeOfDay() {
        const hour = new Date().getHours();
        if (hour >= 6 && hour < 12) return 'morning';
        if (hour >= 12 && hour < 18) return 'afternoon';
        if (hour >= 18 && hour < 22) return 'evening';
        return 'night';
      }

      startEnvironmentalSensing() {
        // Continuous environmental monitoring
        setInterval(() => {
          if (!this.isActive) return;
          
          // Check for significant movement changes
          if (this.environment.movementDistance > 200) { // 200 meters
            this.environment.movementDistance = 0;
            this.triggerDiscovery('JOURNEY_MILESTONE');
          }
          
          // Time-based transitions
          const newTimeOfDay = this.getTimeOfDay();
          if (newTimeOfDay !== this.environment.timeOfDay) {
            this.environment.timeOfDay = newTimeOfDay;
            this.handleTimeTransition(newTimeOfDay);
          }
          
          // Update weather effects
          this.updateWeatherIntelligence();
          
        }, 30000); // Check every 30 seconds
      }

      handleTimeTransition(newTime) {
        const timeTransitions = {
          morning: 'nature',
          afternoon: 'urban',
          evening: 'park',
          night: 'night'
        };
        
        const suggestedPlace = timeTransitions[newTime];
        if (suggestedPlace && suggestedPlace !== this.environment.placeType) {
          // Gentle transition suggestion through music
          this.consciousness.targetBPM = this.consciousness.bpm + (newTime === 'night' ? -15 : 10);
        }
      }

      updateUI() {
        // Update energy bars
        const motionPercent = Math.min(this.motion.intensity * 25, 100);
        this.ui.get('motionEnergy').style.width = motionPercent + '%';
        
        const intensityPercent = Math.min(this.consciousness.intensity * 40, 100);
        this.ui.get('cinematicIntensity').style.width = intensityPercent + '%';
        
        // Update display values
        this.ui.get('bpmDisplay').textContent = Math.round(this.consciousness.bpm);
        
        // Update voice count
        const totalVoices = Object.values(this.orchestra).reduce(
          (sum, section) => sum + section.active.length, 0
        );
        this.ui.get('voiceCount').textContent = totalVoices;
        
        // Update status based on motion pattern
        const statusTexts = {
          meditation: 'Deep Focus',
          contemplation: 'Reflecting', 
          wandering: 'Exploring',
          exploration: 'Adventuring',
          dancing: 'Expressing',
          running: 'Energizing',
          expression: 'Creating'
        };
        this.ui.get('statusText').textContent = statusTexts[this.motion.pattern] || 'Experiencing';
        
        // Update scene descriptions
        const sceneDescriptions = {
          school: 'Echoes of learning and growth',
          urban: 'Rhythms of city life pulsing',
          nature: 'Harmony with natural world',
          park: 'Community and connection',
          night: 'Introspection under stars',
          neutral: 'Open to all possibilities'
        };
        this.ui.get('sceneDescription').textContent = sceneDescriptions[this.environment.placeType] || 'Reality unfolding...';
        
        // Revolutionary scene titles
        const sceneTitles = {
          school: 'ACADEMIC SYMPHONY',
          urban: 'CONCRETE RHAPSODY',
          nature: 'ORGANIC HARMONY',
          park: 'COMMUNITY CHORUS', 
          night: 'NOCTURNAL MEDITATION',
          neutral: 'INFINITE CANVAS'
        };
        this.ui.get('sceneTitle').textContent = sceneTitles[this.environment.placeType] || 'REVOLUTIONARY REALITY';
        
        // Update spectrum visualization
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.audioData);
          this.spectrumBars.forEach((bar, i) => {
            const height = (this.audioData[i] / 255) * 120;
            bar.style.height = height + 'px';
            
            // Dynamic coloring based on frequency and intensity
            const hue = (i / this.spectrumBars.length) * 180 + 140; // Blue-green spectrum
            const saturation = 70 + (this.consciousness.intensity * 30);
            bar.style.background = `linear-gradient(0deg, hsl(${hue}, ${saturation}%, 60%), hsl(${hue}, ${saturation}%, 30%))`;
          });
        }
      }

      animate() {
        const revolutionaryLoop = () => {
          if (!this.isActive) return;
          
          // Update consciousness orb position
          this.ui.get('consciousnessOrb').style.left = this.motion.position.x + '%';
          this.ui.get('consciousnessOrb').style.top = this.motion.position.y + '%';
          
          // Update UI periodically
          if (this.consciousness.step % 8 === 0) {
            this.updateUI();
          }
          
          // Update cinematic effects
          this.updateCinematicEffects();
          
          // Create atmospheric particles
          if (Math.random() < 0.03) {
            this.createRevolutionaryParticle();
          }
          
          requestAnimationFrame(revolutionaryLoop);
        };
        requestAnimationFrame(revolutionaryLoop);
      }

      updateCinematicEffects() {
        // Cinematic vignette for dramatic moments
        const shouldShowVignette = this.consciousness.intensity > 0.7 || this.motion.pattern === 'expression';
        this.ui.get('cinematicVignette').classList.toggle('active', shouldShowVignette);
        
        // Dynamic contrast and saturation
        if (this.consciousness.intensity > 0.6) {
          const contrast = 100 + (this.consciousness.intensity * 25);
          const saturate = 100 + (this.consciousness.intensity * 40);
          document.body.style.filter = `contrast(${contrast}%) saturate(${saturate}%)`;
        } else {
          document.body.style.filter = 'none';
        }
      }

      createRevolutionaryParticle() {
        if (!document.querySelector('.particle-field')) {
          const container = document.createElement('div');
          container.className = 'particle-field';
          document.body.appendChild(container);
        }
        
        const particle = document.createElement('div');
        particle.className = 'reality-particle';
        
        // Size based on consciousness intensity
        const size = 2 + Math.random() * (6 + this.consciousness.intensity * 8);
        particle.style.width = size + 'px';
        particle.style.height = size + 'px';
        particle.style.left = Math.random() * 100 + '%';
        
        // Color based on current environment
        const environmentColors = {
          school: 'rgba(243,156,18,0.6)',
          urban: 'rgba(255,107,53,0.6)',
          nature: 'rgba(78,205,196,0.6)',
          park: 'rgba(46,204,113,0.6)',
          night: 'rgba(155,89,182,0.6)',
          neutral: 'rgba(78,205,196,0.6)'
        };
        particle.style.background = environmentColors[this.environment.placeType] || environmentColors.neutral;
        
        // Animation duration based on motion
        const duration = 10 + Math.random() * 15 - (this.motion.intensity * 3);
        particle.style.animationDuration = duration + 's';
        particle.style.animationDelay = Math.random() * 3 + 's';
        
        document.querySelector('.particle-field').appendChild(particle);
        
        // Clean up after animation
        setTimeout(() => {
          if (particle.parentNode) {
            particle.parentNode.removeChild(particle);
          }
        }, (duration + 3) * 1000);
      }
    }

    // Initialize the Revolutionary Reality Engine
    console.log('ðŸŒŸ Initializing Revolutionary Reality Engine...');
    new RevolutionaryRealityEngine();
  </script>
</body>
</html>
