<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - God Grid Music</title>
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont,sans-serif; background: radial-gradient(circle at 40% 60%, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa; overflow: hidden; min-height: 100vh; margin: 0; display: flex; align-items: center; justify-content: center;
      transition: background 1.5s cubic-bezier(.6,0,.6,1);}
    body.heaven { background: radial-gradient(circle at 60% 40%, #180042 0%, #381466 50%, #ffe4fa 100%); color: #ff88cc;}
    .app { width: 100%; max-width: 470px; padding: 24px; text-align: center; }
    .logo { font-size: 3rem; font-weight: 900; background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4); -webkit-background-clip: text;
      -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: .5rem; transition: all 1.2s;}
    .logo.heaven { background: linear-gradient(45deg, #ff88cc, #ffeee3, #aaccff, #bbaaff); -webkit-background-clip: text;
      -webkit-text-fill-color: transparent; background-clip: text; filter: drop-shadow(0 0 30px #ff88cc80);}
    .tagline { font-size: 1.15rem; opacity: .82; margin-bottom: 2.1rem; font-weight: 300;}
    .tagline.heaven { color: #ffb3ed; opacity: 1; }
    .start-btn { padding: 20px 40px; background: linear-gradient(45deg,#00ffaa,#4ecdc4); color:#000; border:none; border-radius:30px; font-size:1.1rem;
      font-weight:700; cursor:pointer; transition:all .25s; margin-bottom:2rem; }
    .start-btn:hover { box-shadow: 0 8px 28px #00ffaa55; }
    .viz { width: 100%; height: 190px; border: 2px solid #00ffaa33; border-radius: 20px; background: rgba(0,255,170,0.035); margin: 18px 0; position: relative;}
    .viz.heaven { border-color: #ff88cc80; background: rgba(255,170,255,0.08);}
    .orb { position: absolute; width: 60px; height: 60px; border-radius: 50%; background: radial-gradient(circle, #00ffaa 0%, transparent 95%);
      top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 30px #00ffaa55; transition: all .2s;}
    .orb.heaven { background: radial-gradient(circle, #ff88cc 0%, #ffeee3 60%, transparent 100%);
      box-shadow: 0 0 60px #ff88cc99, 0 0 120px #ffe4fa55;}
    .stats { display: grid; grid-template-columns: repeat(3,1fr); gap: 14px; margin-bottom: 2rem; }
    .stat { background: rgba(0,255,170,0.12); padding: 12px; border-radius: 12px; border: 1px solid #00ffaa33;}
    .stat.heaven { background: rgba(255,136,204,0.15); border-color: #ff88cc44;}
    .stat-value { font-size: 1.2rem; font-weight: 700; color: #00ffaa;}
    .stat-value.heaven { color: #ffb3ed;}
    .stat-label { font-size: 0.7rem; opacity: 0.7; margin-top: 3px; }
    .status { font-size: 1rem; color: #4ecdc4; opacity: .93; margin-bottom: 1.2rem;}
    .status.heaven { color: #ffb3ed;}
    .hidden { display: none !important; }
    .error { background: #220 1px solid #c33; border-radius: 15px; padding: 18px; color: #ff6b6b; margin-top: 16px;}
  </style>
</head>
<body>
  <div class="app">
    <div class="logo" id="logo">GUMP</div>
    <div class="tagline" id="tagline">God Grid: 120bpm. You are the rhythm.</div>
    <button class="start-btn" id="start">ðŸŽµ Start Your Soundtrack</button>
    <div class="viz hidden" id="viz"><div class="orb" id="orb"></div></div>
    <div class="stats hidden" id="stats">
      <div class="stat" id="motionStat"><div class="stat-value" id="motion">0</div><div class="stat-label">Motion</div></div>
      <div class="stat" id="bpmStat"><div class="stat-value" id="bpm">120</div><div class="stat-label">BPM</div></div>
      <div class="stat" id="grooveStat"><div class="stat-value" id="groove">CHILL</div><div class="stat-label">State</div></div>
    </div>
    <div class="status hidden" id="status">ðŸŽµ 120BPM is your universe.</div>
    <div class="error hidden" id="error"></div>
  </div>
  <script>
    // --------- ENGINE ---------
    class GUMP {
      constructor() {
        // Core
        this.ctx = null;
        this.motion = 0;        // Raw motion value
        this.lastMotion = 0;
        this.pos = { x: 50, y: 50 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.heaven = false;
        this.motionWindow = [];
        this.windowSize = 5;
        this.lastMotionTime = Date.now();
        // Music
        this.tickCount = 0;  // Counts 8th notes at 120bpm
        this.subdiv = 1;     // Subdivision based on user motion (1 = 8th, 2 = 16th, 3 = triplets, 4 = 32nds)
        this.chordStep = 0;
        // Song structure
        this.scale = [261.63, 293.66, 329.63, 392, 440, 523.25]; // C D E G A C5
        this.progression = [[0,2,4],[1,3,5],[0,3,4],[2,4,5]]; // Chord degrees
        this.currentChord = 0;
        // Drums
        this.kickPat = [1,0,0,0,1,0,1,0];
        this.snarePat = [0,0,1,0,0,0,1,0];
        this.hatPat = [1,1,1,1,1,1,1,1];
        this.lastTick = null;
        this.init();
      }

      init() {
        document.getElementById('start').onclick = () => this.start();
      }

      createReverb() {
        this.reverb = this.ctx.createConvolver();
        const b = this.ctx.createBuffer(2, this.ctx.sampleRate * 2, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          let d = b.getChannelData(c);
          for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/d.length, 2.5);
        }
        this.reverb.buffer = b;
        this.reverb.connect(this.ctx.destination);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') throw new Error('Permission denied');
          }
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();
          document.getElementById('start').classList.add('hidden');
          ['viz','stats','status'].forEach(id=>document.getElementById(id).classList.remove('hidden'));
          this.active = true;
          this.startSensors();
          this.godGridLoop();
          this.animate();
        } catch (e) {
          this.showError('Motion sensors unavailable. Please use a mobile device.');
        }
      }

      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          const dx = acc.x - this.last.x, dy = acc.y - this.last.y, dz = acc.z - this.last.z;
          let power = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.last = { x: acc.x, y: acc.y, z: acc.z };
          // Smooth
          this.motionWindow.push(power); if (this.motionWindow.length > this.windowSize) this.motionWindow.shift();
          this.motion = this.motionWindow.reduce((a,b)=>a+b,0)/this.motionWindow.length;
          if (this.motion > 0.7) this.lastMotionTime = Date.now();
          this.pos.x = Math.max(10, Math.min(90, 50 + acc.x*4));
          this.pos.y = Math.max(10, Math.min(90, 50 + acc.y*4));
        });
      }

      animate() {
        const update = () => {
          if (!this.active) return;
          document.getElementById('motion').textContent = Math.round(this.motion*10);
          document.getElementById('bpm').textContent = 120;
          document.getElementById('groove').textContent = this.heaven ? 'HEAVEN' : (
            this.subdiv===4 ? 'POLY/FAST' : this.subdiv===3 ? 'TRIPLET' : this.subdiv===2 ? 'GROOVE' : 'CHILL');
          // orb follows motion
          let orb = document.getElementById('orb');
          orb.style.left = this.pos.x + '%';
          orb.style.top = this.pos.y + '%';
          orb.className = 'orb' + (this.heaven ? ' heaven' : '');
          // heaven mode visuals
          document.getElementById('logo').className = 'logo' + (this.heaven ? ' heaven' : '');
          document.getElementById('tagline').className = 'tagline' + (this.heaven ? ' heaven' : '');
          document.getElementById('viz').className = 'viz' + (this.heaven ? ' heaven' : '');
          ['motionStat','bpmStat','grooveStat'].forEach(id=>{
            let e=document.getElementById(id);
            if (e) e.className = 'stat' + (this.heaven ? ' heaven' : '');
          });
          document.body.className = this.heaven ? 'heaven' : '';
          document.getElementById('status').className = 'status' + (this.heaven ? ' heaven' : '');
          requestAnimationFrame(update);
        };
        update();
      }

      godGridLoop() {
        // Underlying 120bpm 8th note gridâ€”engine tick never changes.
        // All musical structure, drums, everything locks to this.
        setInterval(() => {
          if (!this.active) return;
          // Determine motion subdivision each 8th note
          // (e.g. more motion means denser events, but all on the grid)
          let m = Math.min(this.motion*12,20);
          this.subdiv = m > 16 ? 4 : m > 8 ? 3 : m > 3.5 ? 2 : 1;
          // Heaven world if no movement >1.3s
          if (Date.now() - this.lastMotionTime > 1300) {
            if (!this.heaven) { this.heaven = true; this.playHeavenPad(); }
            this.heavenEngine();
          } else {
            if (this.heaven) this.heaven = false;
            this.grooveEngine();
          }
          this.tickCount = (this.tickCount+1) % (8*16); // song structure cycles every 8 bars
          // Chord progression advances every 8 bars
          if (this.tickCount % (16*8) === 0) {
            this.currentChord = (this.currentChord+1)%this.progression.length;
          }
        }, 250); // 120bpm, 8th note = 500ms, so 250ms is 16th, but we treat it as 8th grid
      }

      grooveEngine() {
        // Subdivisions: 1 = 8th, 2 = 16th, 3 = triplet, 4 = 32nds/polyrhythm
        let sub = this.subdiv;
        let posInBar = this.tickCount % 16;
        let chord = this.progression[this.currentChord];
        // KICK always on 1, 5, 9, 13. Snare on 5, 13
        if (this.kickPat[posInBar%8] && this.tickCount % Math.max(1, 8/sub) === 0) this.kick();
        if (this.snarePat[posInBar%8] && this.tickCount % Math.max(2, 16/sub) === 0) this.snare();
        if (this.hatPat[posInBar%8] && this.tickCount % Math.max(1, 4/sub) === 0) this.hat();
        // Poly: movement triggers metric mod synth
        if (sub>1 && this.tickCount%sub===0) this.polySynth(sub,chord);
        // Bass on 1, 9
        if (posInBar===0||posInBar===8) this.bass(chord[0]);
        // Chord pad on bar downbeat
        if (posInBar===0 && this.tickCount%16===0) this.pad(chord);
      }

      heavenEngine() {
        // Dreamscape: slow pad, occasional bells, always locked to grid.
        if (this.tickCount%8===0) this.playHeavenPad();
        if (this.tickCount%20===0 && Math.random()>.45) this.playHeavenBell();
      }

      // --------- INSTRUMENTS ---------
      kick() {
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(82,this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(31,this.ctx.currentTime+0.13);
        g.gain.setValueAtTime(0.8,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.21);
        o.connect(g).connect(this.reverb); o.start(); o.stop(this.ctx.currentTime+0.22);
      }
      snare() {
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.13,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.17,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.12);
        n.connect(g).connect(this.reverb); n.start(); n.stop(this.ctx.currentTime+0.13);
      }
      hat() {
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.04,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=3200;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.13,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.06);
        n.connect(f).connect(g).connect(this.reverb); n.start(); n.stop(this.ctx.currentTime+0.05);
      }
      bass(degree) {
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='triangle'; o.frequency.value = this.scale[degree]*0.5;
        g.gain.setValueAtTime(0.15,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.31);
        o.connect(g).connect(this.reverb); o.start(); o.stop(this.ctx.currentTime+0.33);
      }
      pad(chord) {
        let now = this.ctx.currentTime;
        chord.forEach((deg,i)=>{
          let freq=this.scale[deg];
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='triangle'; o.frequency.value=freq;
          g.gain.setValueAtTime(0.09, now);
          g.gain.linearRampToValueAtTime(0.08, now+0.6+0.18*i);
          g.gain.linearRampToValueAtTime(0.001, now+2.0+0.2*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.05*i); o.stop(now+2.1+0.2*i);
        });
      }
      polySynth(sub,chord) {
        // Metric mod synthâ€”poly against the base grid
        let root=this.scale[chord[1]], freq=root*([1,1.25,1.33,1.5][sub-1]);
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='sawtooth'; o.frequency.value=freq;
        g.gain.setValueAtTime(0.07,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.22+0.12*sub);
        o.connect(g).connect(this.reverb);
        o.start(); o.stop(this.ctx.currentTime+0.24+0.12*sub);
      }
      playHeavenPad() {
        let now = this.ctx.currentTime, c=this.progression[this.currentChord];
        c.forEach((deg,i)=>{
          let freq=this.scale[deg];
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='triangle'; o.frequency.value=freq;
          g.gain.setValueAtTime(0.09, now);
          g.gain.linearRampToValueAtTime(0.07, now+0.6+0.15*i);
          g.gain.linearRampToValueAtTime(0.001, now+2.2+0.1*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.03*i); o.stop(now+2.2+0.2*i);
        });
      }
      playHeavenBell() {
        let now = this.ctx.currentTime, d = Math.floor(Math.random()*this.scale.length);
        let freq = this.scale[d]*([1,2][Math.floor(Math.random()*2)]);
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type = 'sine';
        o.frequency.value = freq;
        g.gain.setValueAtTime(0.11, now);
        g.gain.exponentialRampToValueAtTime(0.001, now+2.3);
        o.connect(g).connect(this.reverb);
        o.start(now+0.12); o.stop(now+2.3);
      }
      showError(msg) {
        let e = document.getElementById('error');
        e.textContent = msg;
        e.classList.remove('hidden');
      }
    }
    new GUMP();
  </script>
</body>
</html>
