<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Kanye-Style Sampling Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
        }

        .orb {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.1s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 20px rgba(255,255,255,0.4);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.3px);
        }

        .orb.pulse {
            animation: pulse 0.4s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.3px); }
            50% { transform: translate(-50%, -50%) scale(3.5); box-shadow: 0 0 40px rgba(255,255,255,0.7); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.3px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,1) 0%, rgba(255,0,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 25px rgba(255,0,0,0.6);
            animation: rec 0.8s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
        }

        .orb.motion {
            background: radial-gradient(circle, rgba(100,255,100,1) 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 25px rgba(0,255,0,0.6);
            animation: motionGlow 0.5s ease-in-out infinite alternate;
        }

        @keyframes motionGlow {
            0% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        #controls {
            position: fixed;
            bottom: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            z-index: 5;
            color: #fff;
        }

        #status {
            margin-bottom: 10px;
            font-size: 14px;
        }

        button {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            border: 1px solid #fff;
            color: #fff;
            cursor: pointer;
            margin: 5px;
            border-radius: 5px;
        }

        button:hover {
            background: rgba(255,255,255,0.4);
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>
    <div id="controls">
        <div id="status">Click to start</div>
        <button id="micButton">Request Microphone Access</button>
        <button id="recordButton" disabled>Toggle Recording</button>
    </div>

    <script>
        'use strict';

        class BeatMatcher {
            constructor(bpm = 75) {
                this.bpm = bpm;
                this.barLength = 4;
            }

            findPeaks(buffer) {
                const data = buffer.getChannelData(0);
                const peaks = [];
                const windowSize = 1024;
                const hop = 512;
                let prevEnergy = 0;

                for (let i = 0; i < data.length - windowSize; i += hop) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] ** 2;
                    }
                    energy = Math.sqrt(energy / windowSize);

                    if (energy > prevEnergy * 1.4 && energy > 0.06) {
                        peaks.push({ time: i / buffer.sampleRate, energy, index: i });
                    }
                    prevEnergy = energy;
                }

                return peaks.filter((p, idx) => idx === 0 || p.time - peaks[idx - 1].time > 0.08);
            }

            matchToGrid(peaks) {
                if (peaks.length < 2) return 1;

                const intervals = peaks.slice(1).map((p, i) => p.time - peaks[i].time);
                const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                const beatDuration = 60 / this.bpm;
                const divisions = [4, 2, 1, 0.5, 0.25];
                let bestDiv = 1;
                let minDiff = Infinity;

                for (const div of divisions) {
                    const target = beatDuration * div;
                    const diff = Math.abs(avgInterval - target);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestDiv = div;
                    }
                }

                const targetDuration = beatDuration * this.barLength;
                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                return (targetDuration / actualDuration) * bestDiv;
            }

            chopSample(buffer, peaks) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration / 2; // 8th notes

                for (let i = 0; i < peaks.length - 1; i++) {
                    const start = peaks[i].index;
                    const end = Math.min(start + buffer.sampleRate * chopLength, buffer.length);
                    const chopBuffer = this.ctx.createBuffer(1, end - start, buffer.sampleRate);
                    chopBuffer.getChannelData(0).set(buffer.getChannelData(0).subarray(start, end));
                    chops.push(chopBuffer);
                }
                return chops;
            }
        }

        class ProfessionalBass {
            constructor(ctx, bpm) {
                this.ctx = ctx;
                this.bpm = bpm;
                this.activeVoices = new Map();
                this.notes = [36, 36, 43, 41, 38, 38, 34, 36];
                this.pattern = [1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0];
            }

            midiToFreq(midi) {
                return 440 * Math.pow(2, (midi - 69) / 12);
            }

            play(step, output) {
                if (!this.pattern[step % 16]) return;

                const noteIndex = Math.floor(step / 2) % this.notes.length;
                const midi = this.notes[noteIndex];
                const freq = this.midiToFreq(midi);

                if (this.activeVoices.has(midi)) {
                    this.activeVoices.get(midi).stop(this.ctx.currentTime);
                    this.activeVoices.delete(midi);
                }

                const voice = this.createVoice(freq, output);
                this.activeVoices.set(midi, voice);
            }

            createVoice(freq, output) {
                const now = this.ctx.currentTime;
                const duration = 60 / this.bpm / 4 * 2;

                const sub = this.ctx.createOscillator();
                const mid = this.ctx.createOscillator();
                const top = this.ctx.createOscillator();

                sub.type = 'sine';
                sub.frequency.value = freq * 0.5;
                mid.type = 'sine';
                mid.frequency.value = freq;
                top.type = 'triangle';
                top.frequency.value = freq * 2;

                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 120;
                filter.Q.value = 6;

                const envelope = this.ctx.createGain();
                envelope.gain.setValueAtTime(0, now);
                envelope.gain.linearRampToValueAtTime(0.8, now + 0.005);
                envelope.gain.exponentialRampToValueAtTime(0.4, now + 0.1);
                envelope.gain.exponentialRampToValueAtTime(0.01, now + duration * 0.8);

                filter.frequency.setValueAtTime(80, now);
                filter.frequency.exponentialRampToValueAtTime(250, now + 0.02);
                filter.frequency.exponentialRampToValueAtTime(120, now + duration * 0.3);
                filter.frequency.exponentialRampToValueAtTime(60, now + duration);

                const pitchBend = -18;
                sub.frequency.exponentialRampToValueAtTime(freq * 0.5 * Math.pow(2, pitchBend/12), now + duration * 0.8);
                mid.frequency.exponentialRampToValueAtTime(freq * Math.pow(2, pitchBend/12), now + duration * 0.8);

                sub.connect(filter);
                mid.connect(filter);
                top.connect(filter);
                filter.connect(envelope);
                envelope.connect(output);

                [sub, mid, top].forEach(osc => {
                    osc.start(now);
                    osc.stop(now + duration);
                });

                return { stop: (when) => [sub, mid, top].forEach(osc => osc.stop(when)) };
            }
        }

        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = { drums: {}, chops: [] };
                this.beatMatcher = new BeatMatcher();
                this.professionalBass = null;
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.15, last: 0 };
                this.orb = document.getElementById('orb');
                this.bassActive = false;
                this.warmupBeats = 0;
                this.pitchShifts = [1.0, 1.5, 2.0, 0.5, 0.75]; // Less extreme for professional sound
                this.motionThreshold = 1.5;
                this.status = document.getElementById('status');
                this.micButton = document.getElementById('micButton');
                this.recordButton = document.getElementById('recordButton');

                document.addEventListener('mousemove', (e) => {
                    this.orb.style.left = `${e.clientX}px`;
                    this.orb.style.top = `${e.clientY}px`;
                });

                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', this.handleMotion.bind(this));
                }

                this.micButton.addEventListener('click', () => this.requestMicAccess());
                this.recordButton.addEventListener('click', () => this.toggleRecording());

                document.addEventListener('keydown', (e) => {
                    if (e.key === ' ') this.toggleRecording();
                });

                document.addEventListener('click', () => this.start());
            }

            async requestMicAccess() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                    });
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);

                    this.nodes.recorder.onaudioprocess = (e) => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            if (this.buffer.length > this.ctx.sampleRate * 8) this.stopRecording();
                        }
                    };

                    this.status.textContent = 'Microphone access granted!';
                    this.micButton.disabled = true;
                    this.recordButton.disabled = false;
                    this.autoSampleLoop();
                } catch (e) {
                    this.status.textContent = 'Microphone access denied.';
                }
            }

            async start() {
                if (this.ctx) return this.toggleRecording();

                this.ctx = new AudioContext({ sampleRate: 44100 });
                this.professionalBass = new ProfessionalBass(this.ctx, this.beatMatcher.bpm);

                // Master chain for professional sound
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.7;

                this.nodes.comp = this.ctx.createDynamicsCompressor();
                this.nodes.comp.threshold.value = -24;
                this.nodes.comp.knee.value = 30;
                this.nodes.comp.ratio.value = 12;
                this.nodes.comp.attack.value = 0.003;
                this.nodes.comp.release.value = 0.25;

                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -0.1;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0;
                this.nodes.limiter.release.value = 0.1;

                this.nodes.master.connect(this.nodes.comp);
                this.nodes.comp.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);

                // Layers with reduced gains
                const layers = {
                    kick: 0.6,
                    snare: 0.5,
                    hats: 0.2,
                    sample: 0.4,
                    bass: 0.6
                };
                Object.entries(layers).forEach(([name, vol]) => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = vol;
                    this.nodes[name].connect(this.nodes.master);
                });

                await this.generateDrums();

                this.seq.last = this.ctx.currentTime;
                requestAnimationFrame(this.tick.bind(this));
            }

            async generateDrums() {
                const sr = this.ctx.sampleRate;

                // Kick with controlled amplitude
                const kick = this.ctx.createBuffer(1, sr * 0.4, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const subEnv = Math.exp(-8 * t);
                    const subFreq = 45 * Math.exp(-25 * t);
                    const sub = Math.sin(2 * Math.PI * subFreq * t) * subEnv * 0.7;
                    const midEnv = Math.exp(-15 * t);
                    const midFreq = 80 * Math.exp(-30 * t);
                    const mid = Math.sin(2 * Math.PI * midFreq * t) * midEnv * 0.5;
                    const clickEnv = Math.exp(-100 * t);
                    const click = Math.sin(2 * Math.PI * 2000 * t) * clickEnv * 0.2;
                    kd[i] = sub + mid + click;
                }

                // Snare
                const snare = this.ctx.createBuffer(1, sr * 0.2, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-20 * t);
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.3;
                    const body = Math.sin(2 * Math.PI * 80 * t) * Math.exp(-40 * t) * 0.2;
                    const noise = (Math.random() * 2 - 1) * 0.6;
                    sd[i] = (tone + body + noise) * env;
                }

                // Hats
                const hat = this.ctx.createBuffer(1, sr * 0.08, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-60 * t);
                    let s = (Math.random() * 2 - 1) * env * 0.4;
                    if (i > 2) s = s * 0.3 + hd[i-1] * 0.4 + hd[i-2] * 0.3;
                    hd[i] = s;
                }

                this.samples.drums = { kick, snare, hat };
            }

            toggleRecording() {
                if (!this.nodes.mic) return;

                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.recorder);
                    this.nodes.recorder.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                    this.status.textContent = 'Recording...';
                }
            }

            stopRecording() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.recorder);
                this.nodes.recorder.disconnect();
                this.orb.classList.remove('recording');
                this.status.textContent = 'Processing sample...';

                if (this.buffer.length < this.ctx.sampleRate * 0.5) return;

                const audioBuffer = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                const data = audioBuffer.getChannelData(0);
                data.set(this.buffer);

                // Normalize
                let max = 0;
                for (let i = 0; i < data.length; i++) {
                    max = Math.max(max, Math.abs(data[i]));
                }
                if (max > 0) {
                    for (let i = 0; i < data.length; i++) {
                        data[i] /= max;
                        data[i] *= 0.8;
                    }
                }

                const peaks = this.beatMatcher.findPeaks(audioBuffer);
                const stretch = this.beatMatcher.matchToGrid(peaks);
                const pitch = this.pitchShifts[Math.floor(Math.random() * this.pitchShifts.length)];
                const chops = this.beatMatcher.chopSample(audioBuffer, peaks);

                this.samples.chops = chops.map(chop => {
                    // Pitch shift chop
                    const pitched = this.ctx.createBuffer(1, chop.length / pitch, this.ctx.sampleRate);
                    const pitchedData = pitched.getChannelData(0);
                    for (let i = 0; i < pitched.length; i++) {
                        const origIndex = Math.floor(i * pitch);
                        if (origIndex < chop.length) pitchedData[i] = chop.getChannelData(0)[origIndex];
                    }
                    return pitched;
                });

                this.status.textContent = 'Sample chopped and ready!';
            }

            autoSampleLoop() {
                if (!this.nodes.mic) return;

                const analyser = this.ctx.createAnalyser();
                analyser.fftSize = 2048;
                this.nodes.mic.connect(analyser);

                const data = new Float32Array(analyser.frequencyBinCount);
                let cooldown = 0;

                const check = () => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        requestAnimationFrame(check);
                        return;
                    }

                    analyser.getFloatFrequencyData(data);

                    let score = 0;
                    for (let i = 20; i < 200; i++) {
                        if (data[i] > -60) score += data[i] + 60;
                    }
                    score /= 180;

                    if (score > 20) {
                        this.toggleRecording();
                        cooldown = 300;
                    }

                    requestAnimationFrame(check);
                };
                check();
            }

            handleMotion(e) {
                const acc = e.accelerationIncludingGravity;
                const g = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2) / 9.81;

                if (g > this.motionThreshold) {
                    this.orb.classList.add('motion');
                    setTimeout(() => this.orb.classList.remove('motion'), 500);
                }
            }

            tick() {
                const now = this.ctx.currentTime;
                const beatDuration = 60 / this.beatMatcher.bpm / 4;
                const swingFactor = this.seq.step % 2 === 1 ? 1 + this.seq.swing : 1 - this.seq.swing;
                const stepDuration = beatDuration * swingFactor;

                if (now >= this.seq.last + stepDuration) {
                    this.seq.last = now;
                    this.warmupBeats++;

                    if (this.seq.step % 4 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 300);
                    }

                    // Drums
                    if (this.seq.step % 4 === 0) this.playDrum('kick');
                    if (this.seq.step % 8 === 4) this.playDrum('snare');
                    if (this.seq.step % 2 === 0) this.playDrum('hats');

                    // Bass
                    if (this.bassActive) {
                        this.professionalBass.play(this.seq.step, this.nodes.bass);
                    } else if (this.warmupBeats > 16) {
                        this.bassActive = true;
                    }

                    // Chops
                    if (this.samples.chops.length > 0 && this.seq.step % 2 === 1) {
                        const chop = this.samples.chops[Math.floor(Math.random() * this.samples.chops.length)];
                        const src = this.ctx.createBufferSource();
                        src.buffer = chop;
                        src.connect(this.nodes.sample);
                        src.start();
                    }

                    this.seq.step = (this.seq.step + 1) % 32;
                }

                requestAnimationFrame(this.tick.bind(this));
            }

            playDrum(type) {
                const src = this.ctx.createBufferSource();
                src.buffer = this.samples.drums[type];
                src.connect(this.nodes[type]);
                src.start();
            }
        }

        new Engine();
    </script>
</body>
</html>
