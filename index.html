<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>GUMP MOBILE</title>
    <style>
        :root {
            --hue-shift: 0deg;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            height: 100svh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            position: relative;
        }

        #orb {
            position: fixed;
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,1), rgba(255,255,255,0.2));
            box-shadow: 0 0 120px rgba(255,255,255,0.8), 
                        0 0 60px rgba(255,255,255,0.6),
                        inset -10px -10px 20px rgba(0,0,0,0.3);
            transition: all 0.15s ease-out;
            z-index: 1000;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            filter: hue-rotate(var(--hue-shift));
        }

        #orb.recording {
            background: radial-gradient(circle at 30% 30%, #ff0000, #660000);
            box-shadow: 0 0 150px #ff0000, 
                        0 0 80px #ff0000,
                        inset -10px -10px 20px rgba(0,0,0,0.5);
            transform: translate(-50%, -50%) scale(1.2);
        }

        #orb.beat {
            transform: translate(-50%, -50%) scale(1.3);
            box-shadow: 0 0 200px rgba(255,255,255,1), 
                        0 0 100px rgba(255,255,255,0.8);
        }

        #orb.god-mode {
            background: radial-gradient(circle at 30% 30%, #ff00ff, #00ffff);
            animation: godPulse 2s ease-in-out infinite;
        }

        @keyframes godPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); filter: hue-rotate(var(--hue-shift)); }
            50% { transform: translate(-50%, -50%) scale(1.5) rotate(180deg); filter: hue-rotate(calc(var(--hue-shift) + 180deg)); }
        }

        .status {
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
            text-transform: uppercase;
            text-align: center;
            padding: 0 20px;
        }

        .status.visible {
            opacity: 0.7;
        }

        .hint {
            position: fixed;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 2s;
            text-transform: uppercase;
            text-align: center;
            padding: 0 20px;
        }

        .hint.visible {
            opacity: 0.5;
        }

        .producer-status {
            position: fixed;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
            text-transform: uppercase;
            color: #ff00ff;
            text-align: center;
            padding: 0 20px;
        }

        .producer-status.visible {
            opacity: 0.6;
        }

        .visualizer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s;
        }

        .visualizer.active {
            opacity: 1;
        }

        .ai-personality {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 16px;
            letter-spacing: 4px;
            opacity: 0;
            transition: all 0.5s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .ai-personality.visible {
            opacity: 0.8;
        }

        .waveform {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            height: 100px;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .waveform.visible {
            opacity: 0.3;
        }

        .sample-counter {
            position: fixed;
            bottom: 30px;
            right: 30px;
            font-size: 24px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .sample-counter.visible {
            opacity: 0.6;
        }

        .tempo-display {
            position: fixed;
            bottom: 30px;
            left: 30px;
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .tempo-display.visible {
            opacity: 0.4;
        }

        .evolution-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: rgba(255,255,255,0.1);
            overflow: hidden;
        }

        .evolution-progress {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #ff00ff, #00ffff);
            transition: width 1s ease-out;
        }
    </style>
</head>
<body>
    <canvas id="visualizer" class="visualizer"></canvas>
    <canvas id="waveform" class="waveform"></canvas>
    <div id="orb"></div>
    <div id="status" class="status"></div>
    <div id="producer-status" class="producer-status"></div>
    <div id="ai-personality" class="ai-personality"></div>
    <div id="hint" class="hint">TAP TO START</div>
    <div id="sample-counter" class="sample-counter">0</div>
    <div id="tempo-display" class="tempo-display">72 BPM</div>
    <div class="evolution-bar">
        <div id="evolution-progress" class="evolution-progress"></div>
    </div>

    <script>
        'use strict';

        // GUMP MOBILE - Auto-evolving beat experience with expanded spatial audio and proper motion permissions
        class GUMP {
            constructor() {
                this.ctx = null;
                this.isInitialized = false;
                this.isRecording = false;
                this.recordBuffer = [];
                this.samples = new Map();
                this.loops = [];
                
                // Tempo and timing
                this.bpm = 72;
                this.swing = 0.15;
                this.currentStep = 0;
                this.barCount = 0;
                this.sessionStartTime = null;
                
                // Visual elements
                this.orb = document.getElementById('orb');
                this.status = document.getElementById('status');
                this.producerStatus = document.getElementById('producer-status');
                this.aiPersonality = document.getElementById('ai-personality');
                this.hint = document.getElementById('hint');
                this.sampleCounter = document.getElementById('sample-counter');
                this.tempoDisplay = document.getElementById('tempo-display');
                this.evolutionProgress = document.getElementById('evolution-progress');
                
                // Producer AI state
                this.producer = {
                    energy: 0.3,
                    complexity: 0,
                    evolution: 0,
                    mood: 'building',
                    godMode: false,
                    personality: 'kanye',
                    currentPersonalityIndex: 0,
                    decisions: [],
                    memory: [],
                    structurePosition: 0,
                    intensity: 0.5,
                    autoEvolve: true
                };
                
                // Effects state
                this.stutterActive = false;
                this.reverseMode = false;
                
                // Performance features
                this.sidechain = {
                    active: false,
                    amount: 0
                };
                
                // Motion controls (expanded with permissions and spatial awareness)
                this.motion = {
                    alpha: 0,    // rotation around z-axis
                    beta: 0,     // front-to-back tilt
                    gamma: 0,    // left-to-right tilt
                    acceleration: { x: 0, y: 0, z: 0 },
                    rotationRate: { alpha: 0, beta: 0, gamma: 0 },
                    shakeIntensity: 0,
                    lastShakeTime: 0,
                    smoothAlpha: 0,
                    smoothBeta: 0,
                    smoothGamma: 0,
                    calibration: { alpha: 0, beta: 0, gamma: 0 },
                    enabled: false,
                    permissionGranted: false  // New flag for permission status
                };
                
                // Musical context
                this.musicalContext = {
                    energy: 0,
                    harmony: 0,
                    rhythm: 0,
                    space: 0
                };
                
                // Personalization
                this.personal = {
                    sessionId: Date.now().toString(36) + Math.random().toString(36).substr(2),
                    timeOfDay: this.getTimeOfDay(),
                    movementPattern: 'neutral',
                    interactionStyle: 'explorer',
                    colorSeed: Math.random() * 360,
                    personalityBlend: 0,
                    motionHistory: [],
                    touchPatterns: []
                };
                
                // Touch interactions
                this.setupTouchControls();
                
                // Show hint
                setTimeout(() => this.hint.classList.add('visible'), 500);
                
                // Auto-evolution timers
                this.evolutionTimers = {
                    personalitySwitch: null,
                    godModeActivation: null,
                    effectCycles: null
                };
            }

            getTimeOfDay() {
                const hour = new Date().getHours();
                if (hour < 6) return 'night';
                if (hour < 12) return 'morning';
                if (hour < 17) return 'afternoon';
                if (hour < 21) return 'evening';
                return 'night';
            }

            setupTouchControls() {
                // Single tap to init or toggle recording
                this.orb.addEventListener('click', (e) => {
                    e.preventDefault();
                    if (!this.isInitialized) {
                        this.init();
                    } else {
                        this.toggleRecording();
                    }
                });
                
                // Track touch patterns
                let touchStartTime = 0;
                let touchStartPos = { x: 0, y: 0 };
                
                this.orb.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchStartTime = Date.now();
                    touchStartPos = {
                        x: e.touches[0].clientX,
                        y: e.touches[0].clientY
                    };
                });
                
                // Long press to clear samples
                let longPressTimer;
                this.orb.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    longPressTimer = setTimeout(() => {
                        if (this.isInitialized) {
                            this.clearSamples();
                            // Haptic feedback if available
                            if ('vibrate' in navigator) {
                                navigator.vibrate(200);
                            }
                        }
                    }, 1000);
                });
                
                this.orb.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    clearTimeout(longPressTimer);
                    
                    // Track touch patterns for personalization
                    if (this.isInitialized) {
                        const touchDuration = Date.now() - touchStartTime;
                        const touchEndPos = {
                            x: e.changedTouches[0].clientX,
                            y: e.changedTouches[0].clientY
                        };
                        const distance = Math.sqrt(
                            Math.pow(touchEndPos.x - touchStartPos.x, 2) +
                            Math.pow(touchEndPos.y - touchStartPos.y, 2)
                        );
                        
                        this.personal.touchPatterns.push({
                            duration: touchDuration,
                            distance: distance,
                            time: Date.now()
                        });
                        
                        // Keep only last 20 touches
                        if (this.personal.touchPatterns.length > 20) {
                            this.personal.touchPatterns.shift();
                        }
                        
                        // Update interaction style based on patterns
                        this.updateInteractionStyle();
                    }
                });
                
                this.orb.addEventListener('touchcancel', (e) => {
                    e.preventDefault();
                    clearTimeout(longPressTimer);
                });
                
                // Prevent default touch behaviors
                document.addEventListener('touchmove', (e) => e.preventDefault(), { passive: false });
            }

            async requestMotionPermissions() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        const orientationPermission = await DeviceOrientationEvent.requestPermission();
                        if (orientationPermission !== 'granted') {
                            this.status.textContent = 'ORIENTATION PERMISSION DENIED';
                            this.status.classList.add('visible');
                            setTimeout(() => this.status.classList.remove('visible'), 3000);
                            return false;
                        }
                        
                        const motionPermission = await DeviceMotionEvent.requestPermission();
                        if (motionPermission !== 'granted') {
                            this.status.textContent = 'MOTION PERMISSION DENIED';
                            this.status.classList.add('visible');
                            setTimeout(() => this.status.classList.remove('visible'), 3000);
                            return false;
                        }
                        
                        return true;
                    } catch (err) {
                        console.error('Permission request failed:', err);
                        return false;
                    }
                }
                return true; // No permission needed on this platform
            }

            initMotionListeners() {
                // Simple motion setup without permission blocking
                window.addEventListener('deviceorientation', (e) => {
                    if (e.alpha !== null && e.beta !== null && e.gamma !== null) {
                        this.motion.enabled = true;
                        
                        // Store raw values
                        this.motion.alpha = e.alpha;
                        this.motion.beta = e.beta;
                        this.motion.gamma = e.gamma;
                        
                        // Smooth the values
                        const smoothing = 0.9;
                        this.motion.smoothAlpha = this.motion.smoothAlpha * smoothing + e.alpha * (1 - smoothing);
                        this.motion.smoothBeta = this.motion.smoothBeta * smoothing + e.beta * (1 - smoothing);
                        this.motion.smoothGamma = this.motion.smoothGamma * smoothing + e.gamma * (1 - smoothing);
                        
                        // First reading becomes calibration
                        if (this.motion.calibration.alpha === 0) {
                            this.motion.calibration = {
                                alpha: e.alpha,
                                beta: e.beta,
                                gamma: e.gamma
                            };
                        }
                        
                        // Apply motion effects
                        this.applyMotionEffects();
                    }
                });
                
                // Device motion for shake detection
                window.addEventListener('devicemotion', (e) => {
                    if (e.acceleration) {
                        this.motion.acceleration = {
                            x: e.acceleration.x || 0,
                            y: e.acceleration.y || 0,
                            z: e.acceleration.z || 0
                        };
                        
                        // Detect shake
                        const totalAcceleration = Math.sqrt(
                            Math.pow(this.motion.acceleration.x, 2) +
                            Math.pow(this.motion.acceleration.y, 2) +
                            Math.pow(this.motion.acceleration.z, 2)
                        );
                        
                        if (totalAcceleration > 15) {
                            const now = Date.now();
                            if (now - this.motion.lastShakeTime > 500) {
                                this.onShake(totalAcceleration);
                                this.motion.lastShakeTime = now;
                            }
                        }
                        
                        this.motion.shakeIntensity = Math.min(totalAcceleration / 30, 1);
                    }
                });
            }

            updateMovementPattern() {
                // Simplified movement detection
                if (!this.motion.enabled) {
                    this.personal.movementPattern = 'still';
                }
            }

            updateInteractionStyle() {
                // Simple interaction classification
                const patterns = this.personal.touchPatterns.slice(-10);
                if (patterns.length < 5) return;
                
                const avgDuration = patterns.reduce((sum, p) => sum + p.duration, 0) / patterns.length;
                
                if (avgDuration < 200) {
                    this.personal.interactionStyle = 'precise';
                } else if (avgDuration > 500) {
                    this.personal.interactionStyle = 'contemplative';
                } else {
                    this.personal.interactionStyle = 'explorer';
                }
            }

            applyMotionEffects() {
                if (!this.motion.enabled || !this.isInitialized) return;
                
                // Make sure we have calibration
                if (!this.motion.calibration.beta) {
                    this.motion.calibration = {
                        alpha: this.motion.smoothAlpha || 0,
                        beta: this.motion.smoothBeta || 0,
                        gamma: this.motion.smoothGamma || 0
                    };
                }
                
                // Simple, intuitive motion mapping
                const tilt = (this.motion.smoothBeta - this.motion.calibration.beta) / 45; // -1 to 1
                const rotation = (this.motion.smoothGamma - this.motion.calibration.gamma) / 45; // -1 to 1
                
                // Tilt forward/back = energy
                const motionEnergy = Math.max(0, Math.min(1, 0.5 + tilt));
                
                // Subtle master volume response
                this.master.gain.linearRampToValueAtTime(
                    0.95 * (0.8 + motionEnergy * 0.2),
                    this.ctx.currentTime + 0.1
                );
                
                // Filter all samples together
                const filterFreq = 1000 + (1 + tilt) * 7000; // 1k-15k range
                this.sampleFilter.frequency.linearRampToValueAtTime(filterFreq, this.ctx.currentTime + 0.1);
                
                // Rotation adds space
                const reverbAmount = Math.max(0, Math.min(1, 0.3 + Math.abs(rotation) * 0.4));
                this.reverbSend.gain.linearRampToValueAtTime(reverbAmount, this.ctx.currentTime + 0.1);
                
                // Expanded spatial audio effects
                if (this.samplePanner) {
                    // Position samples in 3D space based on motion
                    const posX = rotation * 5; // Left-right
                    const posY = tilt * 5;     // Up-down
                    const posZ = -Math.abs(tilt) * 3 - 1; // Forward-back based on tilt intensity
                    
                    this.samplePanner.positionX.linearRampToValueAtTime(posX, this.ctx.currentTime + 0.1);
                    this.samplePanner.positionY.linearRampToValueAtTime(posY, this.ctx.currentTime + 0.1);
                    this.samplePanner.positionZ.linearRampToValueAtTime(posZ, this.ctx.currentTime + 0.1);
                }
                
                // Update movement pattern occasionally
                if (Math.random() < 0.1) {
                    if (Math.abs(tilt) < 0.2 && Math.abs(rotation) < 0.2) {
                        this.personal.movementPattern = 'still';
                    } else if (Math.abs(tilt) > 0.6 || Math.abs(rotation) > 0.6) {
                        this.personal.movementPattern = 'energetic';
                    } else {
                        this.personal.movementPattern = 'gentle';
                    }
                }
            }

            onShake(intensity) {
                if (!this.isInitialized) return;
                
                // Simple shake = trigger effect
                if (this.loops.length > 0) {
                    // Quick stutter
                    this.stutterActive = true;
                    setTimeout(() => this.stutterActive = false, 200);
                    
                    // Visual feedback
                    this.orb.classList.add('god-mode');
                    setTimeout(() => this.orb.classList.remove('god-mode'), 200);
                }
                
                // Haptic
                if ('vibrate' in navigator) {
                    navigator.vibrate(50);
                }
            }

            async init() {
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });

                    // iOS audio unlock
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }

                    // Build the complete signal chain
                    this.buildMasterChain();
                    
                    // Create expanded drum kit
                    this.createDrumKit();
                    
                    // Setup microphone
                    await this.setupMicrophone();
                    
                    // Initialize visualizers
                    this.initVisualizer();
                    this.initWaveform();
                    
                    // Personalize based on context
                    this.personalizeExperience();
                    
                    // Create the intro sequence
                    this.scheduleIntro();
                    
                    // Start the producer AI
                    this.startProducerAI();
                    
                    // Start auto-evolution
                    this.startAutoEvolution();
                    
                    // Mark session start time
                    this.sessionStartTime = this.ctx.currentTime;
                    
                    this.isInitialized = true;
                    this.hint.textContent = 'TAP TO SAMPLE';
                    
                    // Setup motion immediately after user gesture (no timeout)
                    this.trySetupMotion();
                    
                    // Haptic feedback
                    if ('vibrate' in navigator) {
                        navigator.vibrate(50);
                    }

                    console.log('GUMP MOBILE initialized - Session:', this.personal.sessionId);

                } catch (err) {
                    console.error('Failed to initialize:', err);
                    this.status.textContent = 'Failed to initialize';
                    this.status.classList.add('visible');
                }
            }

            async trySetupMotion() {
                // Only setup motion if available, don't block
                if (window.DeviceOrientationEvent || window.DeviceMotionEvent) {
                    const granted = await this.requestMotionPermissions();
                    if (granted) {
                        this.motion.permissionGranted = true;
                        this.initMotionListeners();
                    } else {
                        console.log('Motion permissions not granted');
                    }
                }
            }

            personalizeExperience() {
                // Set initial personality based on time of day
                const timePersonalities = {
                    'night': 'arca',      // Weird late night vibes
                    'morning': 'dilla',   // Smooth morning grooves
                    'afternoon': 'kanye', // Bold afternoon energy
                    'evening': 'flylo',   // Psychedelic evening journey
                };
                
                this.producer.personality = timePersonalities[this.personal.timeOfDay] || 'kanye';
                this.producer.currentPersonalityIndex = ['kanye', 'dilla', 'flylo', 'arca', 'sophie']
                    .indexOf(this.producer.personality);
                
                // Adjust tempo based on time
                const tempoAdjustments = {
                    'night': 0.8,
                    'morning': 1.1,
                    'afternoon': 1.0,
                    'evening': 0.9
                };
                
                this.bpm *= tempoAdjustments[this.personal.timeOfDay] || 1;
                
                // Color scheme based on personal seed
                document.documentElement.style.setProperty('--hue-shift', this.personal.colorSeed + 'deg');
                
                // Welcome message
                const greetings = {
                    'night': 'LATE NIGHT SESSION',
                    'morning': 'MORNING VIBES',
                    'afternoon': 'AFTERNOON BEATS',
                    'evening': 'EVENING JOURNEY'
                };
                
                this.status.textContent = greetings[this.personal.timeOfDay];
                this.status.classList.add('visible');
                setTimeout(() => {
                    this.status.classList.remove('visible');
                    // Show personality after greeting
                    setTimeout(() => {
                        this.status.textContent = `${this.producer.personality.toUpperCase()} MODE`;
                        this.status.classList.add('visible');
                        setTimeout(() => this.status.classList.remove('visible'), 2000);
                    }, 1000);
                }, 3000);
            }

            buildMasterChain() {
                // Master gain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.95;

                // Multi-band compressor simulation
                this.lowComp = this.ctx.createDynamicsCompressor();
                this.lowComp.threshold.value = -10;
                this.lowComp.ratio.value = 4;
                
                this.midComp = this.ctx.createDynamicsCompressor();
                this.midComp.threshold.value = -12;
                this.midComp.ratio.value = 3;
                
                this.highComp = this.ctx.createDynamicsCompressor();
                this.highComp.threshold.value = -15;
                this.highComp.ratio.value = 2;

                // Bus compressor for glue
                this.busComp = this.ctx.createDynamicsCompressor();
                this.busComp.threshold.value = -8;
                this.busComp.knee.value = 3;
                this.busComp.ratio.value = 4;
                this.busComp.attack.value = 0.01;
                this.busComp.release.value = 0.1;

                // EQ section
                this.lowShelf = this.ctx.createBiquadFilter();
                this.lowShelf.type = 'lowshelf';
                this.lowShelf.frequency.value = 150;
                this.lowShelf.gain.value = 4;

                this.midEQ = this.ctx.createBiquadFilter();
                this.midEQ.type = 'peaking';
                this.midEQ.frequency.value = 2000;
                this.midEQ.Q.value = 0.7;
                this.midEQ.gain.value = 2;

                this.highShelf = this.ctx.createBiquadFilter();
                this.highShelf.type = 'highshelf';
                this.highShelf.frequency.value = 8000;
                this.highShelf.gain.value = 3;

                // Soft clipper
                this.clipper = this.ctx.createWaveShaper();
                this.clipper.curve = this.makeSoftClipCurve();
                this.clipper.oversample = '4x';

                // Final limiter
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -0.5;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                // Connect master chain
                this.master.connect(this.busComp);
                this.busComp.connect(this.lowShelf);
                this.lowShelf.connect(this.midEQ);
                this.midEQ.connect(this.highShelf);
                this.highShelf.connect(this.clipper);
                this.clipper.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);

                // Create buses
                this.createDrumBus();
                this.createSampleBus();
                this.createSendEffects();

                // Analyzers
                this.analyzer = this.ctx.createAnalyser();
                this.analyzer.fftSize = 2048;
                this.analyzer.smoothingTimeConstant = 0.85;
                this.limiter.connect(this.analyzer);

                this.waveformAnalyzer = this.ctx.createAnalyser();
                this.waveformAnalyzer.fftSize = 1024;
                this.master.connect(this.waveformAnalyzer);

                // Expanded: Set up audio listener for spatial audio
                this.ctx.listener.positionX.value = 0;
                this.ctx.listener.positionY.value = 0;
                this.ctx.listener.positionZ.value = 0;
                this.ctx.listener.forwardX.value = 0;
                this.ctx.listener.forwardY.value = 0;
                this.ctx.listener.forwardZ.value = -1;
                this.ctx.listener.upX.value = 0;
                this.ctx.listener.upY.value = 1;
                this.ctx.listener.upZ.value = 0;
            }

            createDrumBus() {
                this.drumBus = this.ctx.createGain();
                this.drumBus.gain.value = 1;
                
                // Drum compression
                this.drumComp = this.ctx.createDynamicsCompressor();
                this.drumComp.threshold.value = -6;
                this.drumComp.ratio.value = 6;
                this.drumComp.attack.value = 0.003;
                this.drumComp.release.value = 0.1;
                
                // Drum saturation
                this.drumSaturator = this.ctx.createWaveShaper();
                this.drumSaturator.curve = this.makeDistortionCurve(20);
                
                // Drum filter
                this.drumFilter = this.ctx.createBiquadFilter();
                this.drumFilter.frequency.value = 20000;
                
                // Sidechain compression simulation
                this.sidechainGain = this.ctx.createGain();
                this.sidechainGain.gain.value = 1;
                
                // Connect drum chain
                this.drumBus.connect(this.drumComp);
                this.drumComp.connect(this.drumSaturator);
                this.drumSaturator.connect(this.drumFilter);
                this.drumFilter.connect(this.sidechainGain);
                this.sidechainGain.connect(this.master);
            }

            createSampleBus() {
                this.sampleBus = this.ctx.createGain();
                this.sampleBus.gain.value = 0.8;
                
                // Sample processing chain
                this.sampleFilter = this.ctx.createBiquadFilter();
                this.sampleFilter.frequency.value = 5000;
                this.sampleFilter.Q.value = 1;
                
                // Bit crusher simulation
                this.bitCrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                this.bitDepth = 16;
                this.sampleRateReduction = 1;
                
                this.bitCrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    const bits = this.bitDepth;
                    const max = Math.pow(2, bits) - 1;
                    
                    for (let i = 0; i < input.length; i += this.sampleRateReduction) {
                        let sample = input[i];
                        sample = Math.round(sample * max) / max;
                        
                        for (let j = 0; j < this.sampleRateReduction && i + j < output.length; j++) {
                            output[i + j] = sample;
                        }
                    }
                };
                
                // Granular processor
                this.granularGain = this.ctx.createGain();
                this.granularGain.gain.value = 0;

                // Expanded: Add spatial panner for samples
                this.samplePanner = this.ctx.createPanner();
                this.samplePanner.panningModel = 'HRTF'; // High-quality binaural spatialization
                this.samplePanner.distanceModel = 'inverse';
                this.samplePanner.refDistance = 1;
                this.samplePanner.maxDistance = 10000;
                this.samplePanner.rolloffFactor = 1;
                this.samplePanner.coneInnerAngle = 360;
                this.samplePanner.coneOuterAngle = 0;
                this.samplePanner.coneOuterGain = 0;
                
                // Connect sample chain with panner
                this.sampleBus.connect(this.sampleFilter);
                this.sampleFilter.connect(this.bitCrusher);
                this.bitCrusher.connect(this.samplePanner);
                this.samplePanner.connect(this.sidechainGain);
                this.bitCrusher.connect(this.granularGain);
                this.granularGain.connect(this.master);
            }

            createSendEffects() {
                // Send 1: Lush Reverb
                this.reverbSend = this.ctx.createGain();
                this.reverbSend.gain.value = 0.3;
                this.lushReverb = this.createAdvancedReverb(2, 0.8);
                this.reverbSend.connect(this.lushReverb.input);
                this.lushReverb.output.connect(this.master);
                
                // Send 2: Ping-pong Delay
                this.delaySend = this.ctx.createGain();
                this.delaySend.gain.value = 0.2;
                this.pingPongDelay = this.createPingPongDelay(0.375, 0.6);
                this.delaySend.connect(this.pingPongDelay.input);
                this.pingPongDelay.output.connect(this.master);
                
                // Send 3: Chorus/Flanger
                this.chorusSend = this.ctx.createGain();
                this.chorusSend.gain.value = 0;
                this.chorus = this.createChorus();
                this.chorusSend.connect(this.chorus.input);
                this.chorus.output.connect(this.master);
                
                // Send 4: Distortion
                this.distortionSend = this.ctx.createGain();
                this.distortionSend.gain.value = 0;
                this.heavyDistortion = this.ctx.createWaveShaper();
                this.heavyDistortion.curve = this.makeDistortionCurve(100);
                this.distortionSend.connect(this.heavyDistortion);
                this.heavyDistortion.connect(this.master);
            }

            createAdvancedReverb(seconds, decay) {
                const length = this.ctx.sampleRate * seconds;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * 
                                       Math.pow(1 - i / length, decay) *
                                       (1 + Math.sin(i * 0.0001) * 0.2);
                    }
                }
                
                const convolver = this.ctx.createConvolver();
                convolver.buffer = impulse;
                
                const input = this.ctx.createGain();
                const wet = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                const preDelay = this.ctx.createDelay(0.1);
                preDelay.delayTime.value = 0.03;
                
                const reverbHighCut = this.ctx.createBiquadFilter();
                reverbHighCut.type = 'lowpass';
                reverbHighCut.frequency.value = 8000;
                
                wet.gain.value = 0.7;
                
                input.connect(preDelay);
                preDelay.connect(convolver);
                convolver.connect(reverbHighCut);
                reverbHighCut.connect(wet);
                wet.connect(output);
                
                return { input, output };
            }

            createPingPongDelay(time, feedback) {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                const merger = this.ctx.createChannelMerger(2);
                const splitter = this.ctx.createChannelSplitter(2);
                
                const delayL = this.ctx.createDelay(2);
                const delayR = this.ctx.createDelay(2);
                delayL.delayTime.value = time;
                delayR.delayTime.value = time * 1.5;
                
                const feedbackL = this.ctx.createGain();
                const feedbackR = this.ctx.createGain();
                feedbackL.gain.value = feedback;
                feedbackR.gain.value = feedback;
                
                const filterL = this.ctx.createBiquadFilter();
                const filterR = this.ctx.createBiquadFilter();
                filterL.frequency.value = 3000;
                filterR.frequency.value = 3000;
                
                input.connect(splitter);
                splitter.connect(delayL, 0);
                splitter.connect(delayR, 1);
                
                delayL.connect(filterL);
                filterL.connect(feedbackL);
                feedbackL.connect(delayR);
                
                delayR.connect(filterR);
                filterR.connect(feedbackR);
                feedbackR.connect(delayL);
                
                delayL.connect(merger, 0, 0);
                delayR.connect(merger, 0, 1);
                merger.connect(output);
                
                return { input, output };
            }

            createChorus() {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                const delays = [];
                const lfos = [];
                const depths = [0.002, 0.003, 0.004];
                const rates = [0.5, 0.7, 0.9];
                
                for (let i = 0; i < 3; i++) {
                    const delay = this.ctx.createDelay(0.1);
                    delay.delayTime.value = 0.02;
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = rates[i];
                    
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = depths[i];
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(delay.delayTime);
                    lfo.start();
                    
                    input.connect(delay);
                    delay.connect(output);
                    
                    delays.push(delay);
                    lfos.push(lfo);
                }
                
                input.connect(output);
                
                return { input, output };
            }

            makeSoftClipCurve() {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    curve[i] = Math.sign(x) * Math.tanh(Math.abs(x) * 2) * 0.95;
                }
                
                return curve;
            }

            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }

            createDrumKit() {
                this.drums = {
                    kick: this.synthesizeKick(),
                    kick808: this.synthesize808(),
                    snare: this.synthesizeSnare(),
                    rimshot: this.synthesizeRimshot(),
                    hihat: this.synthesizeHihat(),
                    openhat: this.synthesizeOpenHat(),
                    clap: this.synthesizeClap(),
                    perc: this.synthesizePerc(),
                    conga: this.synthesizeConga(),
                    cowbell: this.synthesizeCowbell(),
                    crash: this.synthesizeCrash(),
                    ride: this.synthesizeRide()
                };
            }

            synthesizeKick() {
                const duration = 0.8;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const pitch = 120 * Math.exp(-35 * t) + 45;
                    const amp = Math.exp(-3 * t) * (1 - 0.5 * t);
                    
                    let sample = Math.sin(2 * Math.PI * pitch * t) * amp;
                    
                    if (t < 0.005) {
                        sample += Math.sin(2 * Math.PI * 4000 * t) * (1 - t * 200) * 0.3;
                    }
                    
                    sample += Math.sin(4 * Math.PI * pitch * t) * amp * 0.15;
                    sample += Math.sin(8 * Math.PI * pitch * t) * amp * 0.05;
                    
                    data[i] = Math.tanh(sample * 1.5) * 0.9;
                }
                
                return buffer;
            }

            synthesize808() {
                const duration = 2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const pitch = 55 * Math.exp(-8 * t) + 35;
                    const amp = Math.exp(-0.5 * t);
                    
                    let sample = Math.sin(2 * Math.PI * pitch * t) * amp;
                    sample = Math.tanh(sample * 2) * 0.8;
                    
                    data[i] = sample;
                }
                
                return buffer;
            }

            synthesizeSnare() {
                const duration = 0.25;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                const toneFreq1 = 200;
                const toneFreq2 = 340;
                let previousNoise = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    const toneEnv = Math.exp(-20 * t) * (1 - t * 2);
                    const noiseEnv = Math.exp(-30 * t);
                    const clickEnv = t < 0.003 ? (1 - t * 333) : 0;
                    
                    const tone1 = Math.sin(2 * Math.PI * toneFreq1 * t);
                    const tone2 = Math.sin(2 * Math.PI * toneFreq2 * t);
                    const toneComponent = (tone1 + tone2 * 0.8) * toneEnv * 0.4;
                    
                    const whiteNoise = Math.random() * 2 - 1;
                    const highpassedNoise = whiteNoise - previousNoise * 0.95;
                    previousNoise = whiteNoise;
                    const noiseComponent = highpassedNoise * noiseEnv * 0.6;
                    
                    const click = Math.sin(2 * Math.PI * 3500 * t + Math.sin(8000 * t)) * clickEnv * 0.5;
                    
                    let sample = toneComponent + noiseComponent + click;
                    sample *= (1 + 0.3 * Math.sin(2 * Math.PI * 1700 * t));
                    
                    data[i] = Math.tanh(sample * 1.2) * 0.85;
                }
                
                return buffer;
            }

            synthesizeRimshot() {
                const duration = 0.1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-100 * t);
                    
                    let sample = Math.sin(2 * Math.PI * 800 * t) * 0.5;
                    sample += Math.sin(2 * Math.PI * 1200 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * 1600 * t) * 0.2;
                    
                    if (t < 0.002) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 500);
                    }
                    
                    data[i] = sample * env * 0.7;
                }
                
                return buffer;
            }

            synthesizeHihat() {
                const duration = 0.05;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                let previousSample = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-200 * t);
                    
                    let sample = (Math.random() * 2 - 1);
                    sample += Math.sin(2 * Math.PI * 8000 * t) * 0.1;
                    sample += Math.sin(2 * Math.PI * 12000 * t) * 0.05;
                    
                    const filtered = sample - previousSample * 0.95;
                    previousSample = sample;
                    
                    data[i] = filtered * env * 0.8;
                }
                
                return buffer;
            }

            synthesizeOpenHat() {
                const duration = 0.3;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                let previousSample = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-6 * t);
                    
                    let sample = (Math.random() * 2 - 1);
                    sample += Math.sin(2 * Math.PI * 5000 * t) * 0.15;
                    sample += Math.sin(2 * Math.PI * 7500 * t) * 0.1;
                    sample += Math.sin(2 * Math.PI * 10000 * t) * 0.05;
                    
                    const filtered = sample - previousSample * 0.9;
                    previousSample = sample;
                    
                    data[i] = filtered * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeClap() {
                const duration = 0.15;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                const clapTimes = [0, 0.01, 0.025, 0.03];
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    let sample = 0;
                    
                    for (const clapTime of clapTimes) {
                        if (t >= clapTime && t < clapTime + 0.02) {
                            const localT = t - clapTime;
                            const env = Math.exp(-100 * localT);
                            sample += (Math.random() * 2 - 1) * env * (0.7 + Math.random() * 0.3);
                        }
                    }
                    
                    data[i] = sample * 0.7;
                }
                
                return buffer;
            }

            synthesizePerc() {
                const duration = 0.1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-50 * t);
                    
                    const vibrato = Math.sin(2 * Math.PI * 20 * t) * 200;
                    const freq = 800 + vibrato;
                    let sample = Math.sin(2 * Math.PI * freq * t);
                    
                    sample += Math.sin(2 * Math.PI * freq * 2 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * freq * 3 * t) * 0.1;
                    
                    if (t < 0.002) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 500);
                    }
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeConga() {
                const duration = 0.2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-15 * t);
                    
                    let sample = Math.sin(2 * Math.PI * 220 * t) * 0.6;
                    sample += Math.sin(2 * Math.PI * 330 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * 440 * t) * 0.1;
                    
                    if (t < 0.005) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 200) * 0.5;
                    }
                    
                    data[i] = sample * env * 0.8;
                }
                
                return buffer;
            }

            synthesizeCowbell() {
                const duration = 0.3;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-10 * t);
                    
                    let sample = Math.sin(2 * Math.PI * 560 * t) * 0.5;
                    sample += Math.sin(2 * Math.PI * 845 * t) * 0.5;
                    sample *= (1 + 0.5 * Math.sin(2 * Math.PI * 40 * t));
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeCrash() {
                const duration = 2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-1.5 * t);
                    
                    let sample = 0;
                    const freqs = [523, 787, 1046, 1319, 1568, 1976, 2349, 2794];
                    freqs.forEach((freq, index) => {
                        sample += Math.sin(2 * Math.PI * freq * t) * (1 / (index + 1));
                    });
                    
                    sample += (Math.random() * 2 - 1) * 0.3;
                    sample *= (1 + 0.5 * Math.sin(2 * Math.PI * 70 * t));
                    
                    data[i] = sample * env * 0.5;
                }
                
                return buffer;
            }

            synthesizeRide() {
                const duration = 1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-3 * t);
                    
                    let sample = Math.sin(2 * Math.PI * 2000 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * 3000 * t) * 0.2;
                    sample += Math.sin(2 * Math.PI * 4500 * t) * 0.1;
                    sample += (Math.random() * 2 - 1) * 0.1;
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            async setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.micSource = this.ctx.createMediaStreamSource(stream);
                    
                    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.recorder.onaudioprocess = (e) => {
                        if (this.isRecording) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            this.recordBuffer.push(...inputData);
                            
                            // Auto-stop after 8 seconds
                            if (this.recordBuffer.length > this.ctx.sampleRate * 8) {
                                this.stopRecording();
                            }
                        }
                    };
                    
                } catch (err) {
                    console.log('Microphone not available');
                    // Still allow the experience without mic
                }
            }

            initVisualizer() {
                const canvas = document.getElementById('visualizer');
                const ctx = canvas.getContext('2d');
                
                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resize();
                window.addEventListener('resize', resize);
                
                this.visualizerCtx = ctx;
                this.visualizerCanvas = canvas;
                
                // Initialize particle system
                this.particles = [];
                for (let i = 0; i < 50; i++) {
                    this.particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3 + 1,
                        hue: Math.random() * 360
                    });
                }
            }

            initWaveform() {
                const canvas = document.getElementById('waveform');
                const ctx = canvas.getContext('2d');
                
                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = 100;
                };
                resize();
                window.addEventListener('resize', resize);
                
                this.waveformCtx = ctx;
                this.waveformCanvas = canvas;
            }

            animateVisualizer() {
                if (!this.analyzer || this.producer.energy < 0.2) return;
                
                const canvas = this.visualizerCanvas;
                const ctx = this.visualizerCtx;
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const particles = this.particles;
                
                const draw = () => {
                    if (this.producer.energy < 0.2) {
                        canvas.classList.remove('active');
                        return;
                    }
                    
                    canvas.classList.add('active');
                    requestAnimationFrame(draw);
                    
                    this.analyzer.getByteFrequencyData(dataArray);
                    
                    // Choose visualization based on personality
                    switch (this.producer.personality) {
                        case 'kanye':
                            this.drawKanyeViz(ctx, dataArray);
                            break;
                        case 'dilla':
                            this.drawDillaViz(ctx, dataArray);
                            break;
                        case 'flylo':
                            this.drawFlyLoViz(ctx, dataArray);
                            break;
                        case 'arca':
                            this.drawArcaViz(ctx, dataArray);
                            break;
                        case 'sophie':
                            this.drawSophieViz(ctx, dataArray);
                            break;
                    }
                    
                    // Update particles with motion influence
                    const bass = dataArray[0] / 255;
                    particles.forEach(p => {
                        // Base movement
                        p.x += p.vx + bass * 5 * (Math.random() - 0.5);
                        p.y += p.vy + bass * 5 * (Math.random() - 0.5);
                        
                        // Motion influence
                        if (this.motion.enabled) {
                            // Tilt affects particle drift
                            p.x += (this.motion.smoothGamma - this.motion.calibration.gamma) / 30;
                            p.y += (this.motion.smoothBeta - this.motion.calibration.beta) / 30;
                            
                            // Shake scatters particles
                            if (this.motion.shakeIntensity > 0.3) {
                                p.vx += (Math.random() - 0.5) * this.motion.shakeIntensity * 5;
                                p.vy += (Math.random() - 0.5) * this.motion.shakeIntensity * 5;
                            }
                        }
                        
                        // Boundaries
                        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                        
                        // Clamp velocities
                        p.vx = Math.max(-5, Math.min(5, p.vx));
                        p.vy = Math.max(-5, Math.min(5, p.vy));
                        
                        // Color evolution with personal touch
                        p.hue += this.producer.evolution * 5 + this.personal.colorSeed / 100;
                        
                        // Draw particle
                        ctx.beginPath();
                        ctx.arc(p.x, p.y, p.size * (1 + bass), 0, Math.PI * 2);
                        ctx.fillStyle = `hsla(${p.hue % 360}, 100%, 50%, 0.6)`;
                        ctx.fill();
                    });
                };
                
                draw();
            }

            drawKanyeViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const bass = dataArray[0] / 255;
                const mid = dataArray[Math.floor(dataArray.length / 2)] / 255;
                
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                
                // Rotate based on device rotation
                const rotation = this.motion.enabled ? 
                    this.ctx.currentTime * 0.1 + (this.motion.smoothAlpha / 360) : 
                    this.ctx.currentTime * 0.1;
                ctx.rotate(rotation);
                
                // Color based on personal seed and motion
                const hue = this.personal.colorSeed + this.ctx.currentTime * 50 + 
                    (this.motion.enabled ? this.motion.smoothGamma : 0);
                ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                ctx.lineWidth = 5 + bass * 20;
                
                // Shape morphs with tilt
                const tiltMorph = this.motion.enabled ? 
                    1 + (this.motion.smoothBeta - this.motion.calibration.beta) / 90 : 1;
                
                ctx.beginPath();
                ctx.moveTo(0, (-100 - bass * 200) * tiltMorph);
                ctx.lineTo((100 + mid * 200) * tiltMorph, 0);
                ctx.lineTo(0, (100 + bass * 200) * tiltMorph);
                ctx.lineTo((-100 - mid * 200) * tiltMorph, 0);
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            }

            drawDillaViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Wobble based on motion
                const wobbleX = this.motion.enabled ? 
                    Math.sin(this.ctx.currentTime * 2) * this.motion.smoothGamma / 10 : 0;
                const wobbleY = this.motion.enabled ? 
                    Math.cos(this.ctx.currentTime * 1.5) * this.motion.smoothBeta / 10 : 0;
                
                for (let i = 0; i < dataArray.length; i += 20) {
                    const value = dataArray[i] / 255;
                    const x = (i / dataArray.length) * canvas.width + wobbleX;
                    const y = canvas.height / 2 + Math.sin(this.ctx.currentTime + i) * 100 + wobbleY;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, value * 50 * (1 + this.motion.shakeIntensity), 0, Math.PI * 2);
                    
                    // Color varies with personal interaction style
                    const hueOffset = this.personal.interactionStyle === 'contemplative' ? 0 : 30;
                    ctx.fillStyle = `hsla(${30 + value * 30 + hueOffset}, 70%, 50%, ${value * 0.5})`;
                    ctx.fill();
                }
            }

            drawFlyLoViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Multiple waves based on motion
                const numWaves = this.personal.movementPattern === 'energetic' ? 3 : 1;
                
                for (let wave = 0; wave < numWaves; wave++) {
                    ctx.beginPath();
                    for (let i = 0; i < dataArray.length; i++) {
                        const value = dataArray[i] / 255;
                        const x = (i / dataArray.length) * canvas.width;
                        
                        // Wave amplitude affected by tilt
                        const tiltAmplitude = this.motion.enabled ? 
                            1 + Math.abs(this.motion.smoothBeta - this.motion.calibration.beta) / 45 : 1;
                        
                        const y = canvas.height / 2 + 
                            value * 200 * tiltAmplitude * 
                            Math.sin(this.ctx.currentTime * 2 + i * 0.1 + wave * Math.PI / numWaves);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    const hue = this.personal.colorSeed + 
                        this.ctx.currentTime * 100 + wave * 120 +
                        (this.motion.enabled ? this.motion.smoothAlpha / 3 : 0);
                    ctx.strokeStyle = `hsla(${hue}, 100%, 50%, ${0.8 - wave * 0.2})`;
                    ctx.lineWidth = 2 + wave;
                    ctx.stroke();
                }
            }

            drawArcaViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                
                // Glitch intensity based on shake
                const glitchFactor = 10 + this.motion.shakeIntensity * 20;
                
                for (let i = 0; i < glitchFactor; i++) {
                    const index = Math.floor(Math.random() * dataArray.length);
                    const value = dataArray[index] / 255;
                    
                    if (value > 0.5 || this.personal.movementPattern === 'energetic') {
                        ctx.save();
                        
                        // Position affected by device orientation
                        const baseX = Math.random() * canvas.width;
                        const baseY = Math.random() * canvas.height;
                        const offsetX = this.motion.enabled ? 
                            (this.motion.smoothGamma - this.motion.calibration.gamma) * 2 : 0;
                        const offsetY = this.motion.enabled ? 
                            (this.motion.smoothBeta - this.motion.calibration.beta) * 2 : 0;
                        
                        ctx.translate(baseX + offsetX, baseY + offsetY);
                        ctx.scale(value * 5, value * 5);
                        ctx.rotate(Math.random() * Math.PI * 2 + this.motion.smoothAlpha / 100);
                        
                        ctx.fillStyle = `hsla(${Math.random() * 360 + this.personal.colorSeed}, 100%, 50%, ${value * 0.3})`;
                        ctx.fillRect(-50, -50, 100, 100);
                        
                        ctx.restore();
                    }
                }
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            drawSophieViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                // Crystal rotation based on device
                ctx.save();
                ctx.translate(centerX, centerY);
                if (this.motion.enabled) {
                    ctx.rotate((this.motion.smoothAlpha - this.motion.calibration.alpha) * Math.PI / 180);
                }
                
                // Number of segments based on interaction style
                const segments = this.personal.interactionStyle === 'precise' ? 16 : 12;
                
                for (let i = 0; i < dataArray.length; i += Math.floor(dataArray.length / segments)) {
                    const value = dataArray[i] / 255;
                    const angle = (i / dataArray.length) * Math.PI * 2;
                    
                    // Radius pulses with motion
                    const motionPulse = this.motion.enabled ? 
                        1 + Math.sin(this.ctx.currentTime * 3) * this.motion.shakeIntensity * 0.3 : 1;
                    const radius = (100 + value * 200) * motionPulse;
                    
                    const x = Math.cos(angle) * radius;
                    const y = Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(x, y);
                    
                    const nextAngle = ((i + Math.floor(dataArray.length / segments)) / dataArray.length) * Math.PI * 2;
                    const nextValue = dataArray[Math.min(i + Math.floor(dataArray.length / segments), dataArray.length - 1)] / 255;
                    const nextRadius = (100 + nextValue * 200) * motionPulse;
                    const nextX = Math.cos(nextAngle) * nextRadius;
                    const nextY = Math.sin(nextAngle) * nextRadius;
                    
                    ctx.lineTo(nextX, nextY);
                    ctx.closePath();
                    
                    const hue = 300 + value * 60 + this.personal.colorSeed / 6;
                    ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${value * 0.5})`;
                    ctx.fill();
                }
                
                ctx.restore();
            }

            animateWaveform() {
                if (!this.waveformAnalyzer || !this.loops.length) return;
                
                const canvas = this.waveformCanvas;
                const ctx = this.waveformCtx;
                const bufferLength = this.waveformAnalyzer.fftSize;
                const dataArray = new Float32Array(bufferLength);
                
                const draw = () => {
                    if (!this.loops.length) {
                        canvas.classList.remove('visible');
                        return;
                    }
                    
                    canvas.classList.add('visible');
                    requestAnimationFrame(draw);
                    
                    this.waveformAnalyzer.getFloatTimeDomainData(dataArray);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = `hsla(${this.producer.evolution * 360}, 100%, 50%, 0.8)`;
                    ctx.beginPath();
                    
                    const sliceWidth = canvas.width / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i];
                        const y = (v + 1) / 2 * canvas.height;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    ctx.stroke();
                };
                
                draw();
            }

            scheduleIntro() {
                const startTime = this.ctx.currentTime + 0.1;
                const beat = 60 / this.bpm;
                
                // Different intro based on personality
                const intros = {
                    kanye: this.createKanyeIntro(),
                    dilla: this.createDillaIntro(),
                    flylo: this.createFlyLoIntro(),
                    arca: this.createArcaIntro(),
                    sophie: this.createSophieIntro()
                };
                
                const intro = intros[this.producer.personality] || intros.kanye;
                
                intro.forEach(hit => {
                    this.scheduleSound(hit.sound, startTime + hit.time, hit.vel);
                });
                
                setTimeout(() => {
                    this.startMainLoop();
                }, beat * 16 * 1000);
            }

            createKanyeIntro() {
                const beat = 60 / this.bpm;
                return [
                    { time: 0, sound: 'kick', vel: 0.6 },
                    { time: beat * 2, sound: 'kick', vel: 0.4 },
                    { time: beat * 4, sound: 'kick', vel: 0.8 },
                    { time: beat * 5.5, sound: 'kick', vel: 0.3 },
                    { time: beat * 6, sound: 'kick', vel: 0.5 },
                    { time: beat * 8, sound: 'kick', vel: 0.9 },
                    { time: beat * 8.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 9, sound: 'hihat', vel: 0.4 },
                    { time: beat * 9.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 10, sound: 'kick', vel: 0.5 },
                    { time: beat * 10.5, sound: 'hihat', vel: 0.4 },
                    { time: beat * 12, sound: 'kick', vel: 1 },
                    { time: beat * 12.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 13, sound: 'snare', vel: 0.6 },
                    { time: beat * 13.5, sound: 'hihat', vel: 0.4 },
                    { time: beat * 14, sound: 'kick', vel: 0.7 },
                    { time: beat * 14.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 15, sound: 'snare', vel: 0.5 },
                    { time: beat * 15.5, sound: 'snare', vel: 0.4 }
                ];
            }

            createDillaIntro() {
                const beat = 60 / this.bpm;
                return [
                    { time: 0, sound: 'kick', vel: 0.7 },
                    { time: beat * 0.9, sound: 'hihat', vel: 0.3 },
                    { time: beat * 2.1, sound: 'kick', vel: 0.5 },
                    { time: beat * 2.4, sound: 'snare', vel: 0.4 },
                    { time: beat * 3.7, sound: 'hihat', vel: 0.4 },
                    { time: beat * 4.2, sound: 'kick', vel: 0.8 },
                    { time: beat * 5.9, sound: 'rimshot', vel: 0.5 },
                    { time: beat * 6.1, sound: 'kick', vel: 0.4 },
                    { time: beat * 7.8, sound: 'snare', vel: 0.6 },
                    { time: beat * 8.3, sound: 'kick', vel: 0.9 }
                ];
            }

            createFlyLoIntro() {
                const beat = 60 / this.bpm;
                return [
                    { time: 0, sound: 'crash', vel: 0.3 },
                    { time: beat * 2, sound: 'kick', vel: 0.4 },
                    { time: beat * 2.5, sound: 'hihat', vel: 0.2 },
                    { time: beat * 3, sound: 'hihat', vel: 0.2 },
                    { time: beat * 4, sound: 'kick', vel: 0.5 },
                    { time: beat * 4.5, sound: 'perc', vel: 0.3 },
                    { time: beat * 6, sound: 'snare', vel: 0.4 },
                    { time: beat * 7, sound: 'ride', vel: 0.3 },
                    { time: beat * 8, sound: 'kick', vel: 0.6 }
                ];
            }

            createArcaIntro() {
                const beat = 60 / this.bpm;
                return [
                    { time: 0, sound: 'kick', vel: 1 },
                    { time: beat * 0.25, sound: 'kick', vel: 0.5 },
                    { time: beat * 0.5, sound: 'snare', vel: 0.8 },
                    { time: beat * 1.75, sound: 'clap', vel: 0.6 },
                    { time: beat * 2, sound: 'kick', vel: 0.9 },
                    { time: beat * 3.5, sound: 'rimshot', vel: 0.7 },
                    { time: beat * 4, sound: 'kick808', vel: 0.8 },
                    { time: beat * 6.25, sound: 'cowbell', vel: 0.5 },
                    { time: beat * 7, sound: 'crash', vel: 0.4 }
                ];
            }

            createSophieIntro() {
                const beat = 60 / this.bpm;
                return [
                    { time: 0, sound: 'kick', vel: 1 },
                    { time: beat * 0.5, sound: 'hihat', vel: 0.9 },
                    { time: beat * 1, sound: 'hihat', vel: 0.9 },
                    { time: beat * 1.5, sound: 'hihat', vel: 0.9 },
                    { time: beat * 2, sound: 'snare', vel: 1 },
                    { time: beat * 3, sound: 'kick', vel: 1 },
                    { time: beat * 4, sound: 'kick', vel: 1 },
                    { time: beat * 4.5, sound: 'clap', vel: 0.8 },
                    { time: beat * 5, sound: 'clap', vel: 0.8 },
                    { time: beat * 6, sound: 'kick808', vel: 1 }
                ];
            }

            scheduleSound(sound, time, velocity = 1, bus = null) {
                const source = this.ctx.createBufferSource();
                const gainNode = this.ctx.createGain();
                const panNode = this.ctx.createStereoPanner();
                
                source.buffer = this.drums[sound];
                
                // Personalized velocity based on interaction style
                const personalVelocity = {
                    'precise': 0.9,
                    'contemplative': 0.7,
                    'expressive': 1.1,
                    'explorer': 1.0
                };
                
                const producerMultiplier = this.producer.godMode ? 
                    1 + Math.random() * 0.5 * this.producer.intensity : 1;
                
                const personalMultiplier = personalVelocity[this.personal.interactionStyle] || 1;
                
                gainNode.gain.value = velocity * producerMultiplier * personalMultiplier;
                
                // Pitch variation based on personality and motion
                const pitchVariation = {
                    kanye: 0.02,
                    dilla: 0.08,
                    flylo: 0.05,
                    arca: 0.15,
                    sophie: 0.01
                };
                
                let pitchShift = 1 + (Math.random() - 0.5) * (pitchVariation[this.producer.personality] || 0.02);
                
                // Add motion-based pitch shift
                if (this.motion.enabled) {
                    const motionPitch = 1 + (this.motion.smoothBeta - this.motion.calibration.beta) / 200;
                    pitchShift *= motionPitch;
                }
                
                source.playbackRate.value = pitchShift;
                
                // Pan based on motion
                if (this.motion.enabled) {
                    const motionPan = (this.motion.smoothGamma - this.motion.calibration.gamma) / 90;
                    panNode.pan.value = Math.max(-1, Math.min(1, motionPan));
                }
                
                let finalConnection = source;
                
                // Personal effects based on movement pattern
                if (this.personal.movementPattern === 'rhythmic' && Math.random() < 0.3) {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = 1000 + Math.random() * 3000;
                    filter.Q.value = 5 + Math.random() * 10;
                    
                    finalConnection.connect(filter);
                    finalConnection = filter;
                } else if (this.personal.movementPattern === 'energetic' && Math.random() < 0.4) {
                    const distortion = this.ctx.createWaveShaper();
                    distortion.curve = this.makeDistortionCurve(30 + Math.random() * 50);
                    
                    finalConnection.connect(distortion);
                    finalConnection = distortion;
                }
                
                if (this.producer.complexity > 0.7 && Math.random() < 0.3) {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = Math.random() > 0.5 ? 'highpass' : 'lowpass';
                    filter.frequency.value = 200 + Math.random() * 5000;
                    filter.Q.value = 1 + Math.random() * 10;
                    
                    finalConnection.connect(filter);
                    finalConnection = filter;
                }
                
                if (this.reverseMode && Math.random() < 0.3) {
                    source.playbackRate.value *= -1;
                }
                
                if (this.stutterActive) {
                    const stutterGain = this.ctx.createGain();
                    stutterGain.gain.setValueAtTime(0, time);
                    for (let i = 0; i < 8; i++) {
                        stutterGain.gain.setValueAtTime(1, time + i * 0.03);
                        stutterGain.gain.setValueAtTime(0, time + i * 0.03 + 0.015);
                    }
                    finalConnection.connect(stutterGain);
                    finalConnection = stutterGain;
                }
                
                finalConnection.connect(panNode);
                panNode.connect(gainNode);
                gainNode.connect(bus || this.drumBus);
                
                if (this.producer.godMode) {
                    const sendAmount = this.producer.complexity * 0.5;
                    gainNode.connect(this.reverbSend.gain.value = sendAmount, this.reverbSend);
                    gainNode.connect(this.delaySend.gain.value = sendAmount * 0.7, this.delaySend);
                    
                    if (this.producer.personality === 'flylo' || this.producer.personality === 'arca') {
                        gainNode.connect(this.chorusSend.gain.value = sendAmount * 0.3, this.chorusSend);
                    }
                }
                
                source.start(time);
                
                if (sound === 'kick' || sound === 'kick808') {
                    this.triggerSidechain(time);
                }
                
                const delay = (time - this.ctx.currentTime) * 1000;
                if (delay >= 0 && delay < 100) {
                    setTimeout(() => {
                        this.orb.classList.add('beat');
                        
                        // Orb size based on motion
                        if (this.motion.enabled) {
                            const scale = 1.3 + this.motion.shakeIntensity * 0.3;
                            this.orb.style.transform = `translate(-50%, -50%) scale(${scale})`;
                        }
                        
                        setTimeout(() => {
                            this.orb.classList.remove('beat');
                            if (this.motion.enabled) {
                                this.orb.style.transform = 'translate(-50%, -50%) scale(1)';
                            }
                        }, 50);
                    }, delay);
                }
            }

            triggerSidechain(time) {
                if (!this.sidechain.active) return;
                
                const attack = 0.01;
                const hold = 0.05;
                const release = 0.15;
                
                this.sidechainGain.gain.cancelScheduledValues(time);
                this.sidechainGain.gain.setValueAtTime(this.sidechainGain.gain.value, time);
                this.sidechainGain.gain.linearRampToValueAtTime(1 - this.sidechain.amount, time + attack);
                this.sidechainGain.gain.setValueAtTime(1 - this.sidechain.amount, time + attack + hold);
                this.sidechainGain.gain.linearRampToValueAtTime(1, time + attack + hold + release);
            }

            startMainLoop() {
                const beat = 60 / this.bpm;
                const sixteenth = beat / 4;
                let nextTime = this.ctx.currentTime;
                
                const patterns = {
                    kanye: {
                        kick: [0, 10, 20, 22],
                        snare: [8, 24],
                        hihat: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
                        openhat: [14, 30],
                        clap: [8, 24],
                        perc: [5, 13, 21, 29]
                    },
                    dilla: {
                        kick: [0, 7, 16, 22, 26],
                        snare: [9, 25],
                        hihat: [0, 3, 6, 8, 11, 14, 16, 19, 22, 24, 27, 30],
                        rimshot: [5, 21],
                        perc: [13, 29]
                    },
                    flylo: {
                        kick: [0, 11, 22],
                        snare: [8, 19, 24],
                        hihat: [2, 6, 10, 14, 18, 22, 26, 30],
                        ride: [0, 16],
                        perc: [5, 13, 21, 27],
                        crash: []
                    },
                    arca: {
                        kick: [0, 3, 10, 11, 20, 23, 27],
                        kick808: [16],
                        snare: [7, 15, 23, 31],
                        rimshot: [4, 12, 28],
                        clap: [8, 24],
                        conga: [5, 13, 21],
                        cowbell: [2, 18]
                    },
                    sophie: {
                        kick: [0, 4, 8, 12, 16, 20, 24, 28],
                        kick808: [0, 16],
                        snare: [8, 24],
                        hihat: [2, 6, 10, 14, 18, 22, 26, 30],
                        clap: [8, 12, 24, 28],
                        perc: []
                    }
                };
                
                const loop = () => {
                    const currentTime = this.ctx.currentTime;
                    
                    while (nextTime < currentTime + 0.1) {
                        const step = this.currentStep % 32;
                        
                        if (step === 0) {
                            this.barCount++;
                            this.updateProducerState();
                        }
                        
                        let swingOffset = 0;
                        if (step % 2 === 1) {
                            swingOffset = sixteenth * this.swing * 
                                (this.producer.personality === 'dilla' ? 1.5 : 1);
                        }
                        
                        const pattern = patterns[this.producer.personality] || patterns.kanye;
                        const producerPattern = this.producer.godMode ? 
                            this.producerDecidePattern(pattern, step) : pattern;
                        
                        Object.entries(producerPattern).forEach(([sound, steps]) => {
                            if (steps.includes(step)) {
                                let velocity = 0.8;
                                
                                if (this.producer.personality === 'dilla') {
                                    velocity = 0.4 + Math.random() * 0.4;
                                } else if (sound === 'hihat') {
                                    velocity = step % 4 === 0 ? 0.6 : 0.4;
                                } else if (sound === 'kick' && step === 0) {
                                    velocity = 1;
                                }
                                
                                if (this.producer.godMode) {
                                    velocity *= 0.5 + this.producer.energy * 0.5;
                                }
                                
                                this.scheduleSound(sound, nextTime + swingOffset, velocity);
                            }
                        });
                        
                        if (step === 0 && this.loops.length > 0) {
                            this.triggerSampleLoop(nextTime);
                        }
                        
                        this.currentStep++;
                        nextTime += sixteenth;
                    }
                    
                    requestAnimationFrame(loop);
                };
                
                loop();
            }

            startProducerAI() {
                // Smarter AI that weaves everything together
                setInterval(() => {
                    if (!this.isInitialized) return;
                    
                    const sampleCount = this.loops.length;
                    const timeElapsed = this.barCount * 4 * 60 / this.bpm;
                    
                    // Analyze the musical journey
                    this.analyzeMusicalContext();
                    
                    // Make intelligent production decisions
                    this.makeIntelligentDecisions(timeElapsed, sampleCount);
                    
                    // Update effects to support the journey
                    this.updateEffectsIntelligently();
                    
                }, 2000);
                
                // Micro-decisions every beat
                setInterval(() => {
                    if (this.producer.godMode && this.loops.length > 0) {
                        this.makeMicroAdjustments();
                    }
                }, (60 / this.bpm) * 1000);
            }

            analyzeMusicalContext() {
                // Build understanding of current musical state
                const context = {
                    energy: 0,
                    harmony: 0,
                    rhythm: 0,
                    space: 0
                };
                
                // Analyze energy from recent samples
                if (this.producer.memory.length > 0) {
                    const recentMemories = this.producer.memory.slice(-5);
                    context.energy = recentMemories.reduce((sum, m) => sum + m.energy, 0) / recentMemories.length;
                }
                
                // Detect rhythm consistency
                context.rhythm = this.loops.length > 2 ? 0.8 : 0.3;
                
                // Calculate space (inverse of complexity)
                context.space = 1 - this.producer.complexity;
                
                // Store context for decisions
                this.musicalContext = context;
            }

            makeIntelligentDecisions(timeElapsed, sampleCount) {
                const decisions = [];
                
                // Journey phases with smoother transitions
                const phase = Math.floor(timeElapsed / 45) % 5;
                const phases = ['introduction', 'building', 'peak', 'breakdown', 'resolution'];
                const currentPhase = phases[phase];
                
                // Make decisions based on phase and context
                switch (currentPhase) {
                    case 'introduction':
                        if (sampleCount === 0) {
                            decisions.push('WAITING FOR YOUR VOICE');
                        } else {
                            // Gentle introduction of elements
                            this.producer.energy = 0.3 + sampleCount * 0.1;
                            this.drumBus.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 2);
                            decisions.push('SETTING THE SCENE');
                        }
                        break;
                        
                    case 'building':
                        // Gradually increase energy
                        this.producer.energy = Math.min(0.8, this.producer.energy + 0.05);
                        
                        // Add layers intelligently
                        if (sampleCount > 1 && Math.random() < 0.3) {
                            this.reverbSend.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 1);
                            this.delaySend.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 1);
                            decisions.push('ADDING DEPTH');
                        }
                        
                        // Increase complexity
                        this.producer.complexity = Math.min(1, sampleCount * 0.2);
                        break;
                        
                    case 'peak':
                        // Maximum energy but with control
                        this.producer.energy = 0.9 + Math.sin(timeElapsed * 0.1) * 0.1;
                        
                        // All elements working together
                        if (!this.producer.godMode && sampleCount > 2) {
                            this.toggleGodMode();
                            decisions.push('TAKING CONTROL');
                        }
                        
                        // Sidechain for punch
                        this.sidechain.active = true;
                        this.sidechain.amount = 0.6;
                        break;
                        
                    case 'breakdown':
                        // Strategic reduction
                        this.producer.energy = 0.4;
                        
                        // Focus on samples
                        this.drumBus.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 2);
                        this.sampleBus.gain.linearRampToValueAtTime(1.2, this.ctx.currentTime + 2);
                        decisions.push('BREATHING SPACE');
                        
                        // Add atmosphere
                        this.reverbSend.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 2);
                        break;
                        
                    case 'resolution':
                        // Bring it home
                        this.producer.energy = 0.7;
                        this.drumBus.gain.linearRampToValueAtTime(0.9, this.ctx.currentTime + 2);
                        this.sampleBus.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 2);
                        decisions.push('FINDING BALANCE');
                        break;
                }
                
                // Show meaningful status
                if (decisions.length > 0) {
                    this.producerStatus.textContent = decisions[0];
                    this.producerStatus.classList.add('visible');
                    setTimeout(() => {
                        this.producerStatus.classList.remove('visible');
                    }, 3000);
                }
                
                // Update personality based on the journey
                this.chooseNextPersonality(currentPhase);
            }

            chooseNextPersonality(phase) {
                // Intelligent personality selection based on musical needs
                const phasePersonalities = {
                    'introduction': ['dilla', 'flylo'],
                    'building': ['kanye', 'dilla'],
                    'peak': ['sophie', 'kanye'],
                    'breakdown': ['flylo', 'arca'],
                    'resolution': ['dilla', 'flylo']
                };
                
                // Also consider user interaction
                if (this.personal.movementPattern === 'energetic') {
                    // Favor more intense personalities
                    if (Math.random() < 0.6) {
                        this.setAIPersonality(['arca', 'sophie', 'kanye'][Math.floor(Math.random() * 3)]);
                        return;
                    }
                }
                
                const candidates = phasePersonalities[phase] || ['kanye'];
                const next = candidates[Math.floor(Math.random() * candidates.length)];
                
                if (next !== this.producer.personality) {
                    this.setAIPersonality(next);
                }
            }

            makeMicroAdjustments() {
                // Subtle real-time adjustments for cohesion
                
                // Adjust sample volumes based on their age and relevance
                this.loops.forEach((loop, index) => {
                    if (loop.playing && loop.effects) {
                        const age = this.ctx.currentTime - loop.timestamp;
                        let relevance = 1 - (age / 200); // Older samples fade
                        
                        // But keep interesting ones
                        if (this.musicalContext && this.musicalContext.energy > 0.7) {
                            // In high energy, keep all samples present
                            relevance = Math.max(0.5, relevance);
                        }
                        
                        // Smooth volume adjustment
                        const targetGain = (0.8 - index * 0.08) * relevance * this.producer.energy;
                        // Note: gain control happens through the effect chain
                    }
                });
                
                // Intelligent filter sweeps
                if (Math.random() < 0.1 && this.musicalContext) {
                    const sweepType = this.musicalContext.energy > 0.5 ? 'opening' : 'closing';
                    const startFreq = sweepType === 'opening' ? 500 : 15000;
                    const endFreq = sweepType === 'opening' ? 15000 : 500;
                    
                    this.drumFilter.frequency.linearRampToValueAtTime(startFreq, this.ctx.currentTime);
                    this.drumFilter.frequency.linearRampToValueAtTime(endFreq, this.ctx.currentTime + 4);
                }
                
                // Dynamic swing based on feel
                if (this.producer.personality === 'dilla') {
                    this.swing = 0.15 + Math.sin(this.ctx.currentTime * 0.1) * 0.1;
                }
            }

            updateEffectsIntelligently() {
                // Effects that support the musical journey
                
                // Reverb increases with evolution
                const reverbAmount = 0.2 + this.producer.evolution * 0.3;
                this.reverbSend.gain.linearRampToValueAtTime(reverbAmount, this.ctx.currentTime + 0.5);
                
                // Delay based on complexity
                const delayAmount = 0.1 + this.producer.complexity * 0.3;
                this.delaySend.gain.linearRampToValueAtTime(delayAmount, this.ctx.currentTime + 0.5);
                
                // Filter resonance for tension
                if (this.musicalContext) {
                    const tension = this.musicalContext.energy * this.producer.complexity;
                    this.drumFilter.Q.value = 1 + tension * 10;
                    this.sampleFilter.Q.value = 2 + tension * 8;
                }
                
                // Sidechain amount based on energy
                if (this.sidechain.active) {
                    this.sidechain.amount = 0.3 + this.producer.energy * 0.4;
                }
            }

            startAutoEvolution() {
                // Simple, musical evolution
                
                // AI takes control after first sample
                this.evolutionTimers.godModeActivation = setInterval(() => {
                    if (!this.producer.godMode && this.loops.length > 0) {
                        this.toggleGodMode();
                        clearInterval(this.evolutionTimers.godModeActivation);
                    }
                }, 5000);
                
                // Personality changes every 30 seconds for variety
                this.evolutionTimers.personalitySwitch = setInterval(() => {
                    if (this.loops.length > 0 && this.producer.godMode) {
                        const personalities = ['kanye', 'dilla', 'flylo', 'arca', 'sophie'];
                        const current = personalities.indexOf(this.producer.personality);
                        const next = (current + 1) % personalities.length;
                        this.setAIPersonality(personalities[next]);
                    }
                }, 30000);
                
                // Update displays
                setInterval(() => {
                    this.tempoDisplay.textContent = `${Math.round(this.bpm)} BPM`;
                    this.tempoDisplay.classList.add('visible');
                    
                    // Evolution progress
                    const progress = Math.min(100, (this.barCount / 64) * 100);
                    this.evolutionProgress.style.width = progress + '%';
                }, 1000);
            }

            updateProducerIntensity(timeElapsed, sampleCount) {
                const personalities = {
                    kanye: () => {
                        if (timeElapsed < 30) {
                            this.producer.energy = Math.min(1, timeElapsed / 30);
                            this.producer.intensity = 0.8;
                        } else if (timeElapsed > 120 && timeElapsed < 150) {
                            this.producer.energy = 0.3;
                            this.producer.intensity = 1;
                        } else {
                            this.producer.energy = 0.8 + Math.sin(timeElapsed * 0.05) * 0.2;
                            this.producer.intensity = 0.9;
                        }
                    },
                    dilla: () => {
                        this.producer.energy = 0.4 + Math.sin(timeElapsed * 0.03) * 0.3;
                        this.producer.intensity = 0.6;
                        this.swing = 0.2 + Math.sin(timeElapsed * 0.02) * 0.05;
                    },
                    flylo: () => {
                        this.producer.energy = 0.5 + Math.sin(timeElapsed * 0.02) * 0.5;
                        this.producer.intensity = Math.min(1, timeElapsed / 180);
                        this.producer.complexity = Math.min(1, sampleCount * 0.3 + timeElapsed / 200);
                    },
                    arca: () => {
                        this.producer.energy = Math.random() * 0.5 + 0.5;
                        this.producer.intensity = Math.random();
                        if (Math.random() < 0.1) {
                            this.bpm = 72 + (Math.random() - 0.5) * 20;
                        }
                    },
                    sophie: () => {
                        this.producer.energy = timeElapsed % 32 < 16 ? 1 : 0.6;
                        this.producer.intensity = 1;
                        this.producer.complexity = 0.8;
                        this.sidechain.active = true;
                        this.sidechain.amount = 0.7;
                    }
                };
                
                const updateFunc = personalities[this.producer.personality] || personalities.kanye;
                updateFunc();
                
                this.producer.complexity = Math.min(1, sampleCount * 0.25 + timeElapsed / 180);
                this.producer.evolution = Math.min(1, timeElapsed / 240);
                
                // Update evolution bar
                this.evolutionProgress.style.width = (this.producer.evolution * 100) + '%';
            }

            makeProductionDecisions(timeElapsed, sampleCount) {
                const decisions = [];
                
                const section = Math.floor(timeElapsed / 32) % 4;
                const sections = ['Intro', 'Verse', 'Chorus', 'Bridge'];
                this.producer.structurePosition = section;
                
                if (this.barCount % 8 === 0) {
                    const rand = Math.random();
                    
                    if (section === 0 && rand < 0.3) {
                        decisions.push('Building tension...');
                        this.drumFilter.frequency.linearRampToValueAtTime(20000, this.ctx.currentTime + 4);
                    } else if (section === 1 && rand < 0.4) {
                        decisions.push('Creating space');
                        this.drumBus.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 0.5);
                        this.sampleBus.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.5);
                    } else if (section === 2 && rand < 0.5) {
                        decisions.push('Drop the beat!');
                        this.drumBus.gain.linearRampToValueAtTime(1.2, this.ctx.currentTime + 0.1);
                        this.master.gain.linearRampToValueAtTime(1.1, this.ctx.currentTime + 0.1);
                    } else if (section === 3 && rand < 0.4) {
                        decisions.push('Getting weird...');
                        this.applyCreativeEffect();
                    }
                }
                
                return decisions;
            }

            applyCreativeEffect() {
                const effects = [
                    () => {
                        this.bitDepth = Math.floor(Math.random() * 8) + 4;
                        this.sampleRateReduction = Math.floor(Math.random() * 4) + 1;
                        setTimeout(() => {
                            this.bitDepth = 16;
                            this.sampleRateReduction = 1;
                        }, 4000);
                    },
                    () => {
                        const startFreq = 200;
                        const endFreq = 15000;
                        this.drumFilter.frequency.linearRampToValueAtTime(startFreq, this.ctx.currentTime);
                        this.drumFilter.frequency.linearRampToValueAtTime(endFreq, this.ctx.currentTime + 2);
                        this.drumFilter.Q.value = 10;
                    },
                    () => {
                        this.reverseMode = true;
                        setTimeout(() => {
                            this.reverseMode = false;
                        }, 2000);
                    },
                    () => {
                        this.distortionSend.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 0.1);
                        this.distortionSend.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2);
                    },
                    () => {
                        const originalBPM = this.bpm;
                        this.bpm *= 0.5;
                        setTimeout(() => {
                            this.bpm = originalBPM;
                        }, 1000);
                    }
                ];
                
                const effect = effects[Math.floor(Math.random() * effects.length)];
                effect();
            }

            updateProducerState() {
                if (!this.producer.godMode) return;
                
                this.aiPersonality.textContent = `AI: ${this.producer.personality.toUpperCase()}`;
                this.aiPersonality.classList.add('visible');
                
                if (this.barCount % 4 === 0) {
                    const rand = Math.random();
                    
                    if (rand < 0.2 && this.producer.energy > 0.5) {
                        this.drumBus.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.1);
                        this.drumBus.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.5);
                        this.producerStatus.textContent = 'Drum dropout';
                        this.producerStatus.classList.add('visible');
                    } else if (rand < 0.4 && this.loops.length > 1) {
                        this.sampleBus.gain.linearRampToValueAtTime(1.2, this.ctx.currentTime + 0.1);
                        this.sampleBus.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 2);
                        this.producerStatus.textContent = 'Sample focus';
                        this.producerStatus.classList.add('visible');
                    } else if (rand < 0.6) {
                        const startFreq = 200 + Math.random() * 1000;
                        const endFreq = 5000 + Math.random() * 10000;
                        this.drumFilter.frequency.linearRampToValueAtTime(startFreq, this.ctx.currentTime);
                        this.drumFilter.frequency.linearRampToValueAtTime(endFreq, this.ctx.currentTime + 2);
                        this.producerStatus.textContent = 'Filter sweep';
                        this.producerStatus.classList.add('visible');
                    }
                    
                    setTimeout(() => {
                        this.producerStatus.classList.remove('visible');
                    }, 2000);
                }
                
                if (this.producer.energy > 0.2 && !this.visualizerActive) {
                    this.visualizerActive = true;
                    this.animateVisualizer();
                }
                
                if (this.loops.length > 0 && !this.waveformActive) {
                    this.waveformActive = true;
                    this.animateWaveform();
                }
            }

            producerDecidePattern(originalPattern, step) {
                const pattern = JSON.parse(JSON.stringify(originalPattern));
                
                if (this.producer.personality === 'dilla') {
                    Object.keys(pattern).forEach(sound => {
                        if (Math.random() < 0.1) {
                            pattern[sound] = pattern[sound].map(s => 
                                s + (Math.random() < 0.3 ? Math.floor(Math.random() * 3) - 1 : 0)
                            ).filter(s => s >= 0 && s < 32);
                        }
                    });
                } else if (this.producer.personality === 'arca') {
                    if (Math.random() < 0.2) {
                        const sounds = Object.keys(pattern);
                        const randomSound = sounds[Math.floor(Math.random() * sounds.length)];
                        pattern[randomSound].push(step);
                    }
                } else if (this.producer.personality === 'sophie') {
                    if (step % 4 === 0 && this.producer.energy > 0.8) {
                        pattern.kick.push(step);
                        pattern.kick808 = [step];
                    }
                }
                
                if (this.producer.complexity > 0.5 && Math.random() < 0.2) {
                    if (!pattern.kick.includes(step) && step % 4 === 2) {
                        pattern.kick.push(step);
                    }
                }
                
                if (this.producer.energy < 0.5 && Math.random() < 0.3) {
                    pattern.hihat = pattern.hihat.filter(s => s % 4 === 0);
                }
                
                if (this.producer.evolution > 0.7 && Math.random() < 0.1) {
                    const percSounds = ['perc', 'conga', 'cowbell', 'rimshot'];
                    const randomPerc = percSounds[Math.floor(Math.random() * percSounds.length)];
                    if (pattern[randomPerc]) {
                        pattern[randomPerc].push(step);
                    }
                }
                
                return pattern;
            }



            toggleRecording() {
                if (!this.micSource) {
                    this.status.textContent = 'NO MIC ACCESS';
                    this.status.classList.add('visible');
                    setTimeout(() => this.status.classList.remove('visible'), 2000);
                    return;
                }
                
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }



            startRecording() {
                if (!this.micSource) return;
                
                this.isRecording = true;
                this.recordBuffer = [];
                this.orb.classList.add('recording');
                this.status.textContent = 'RECORDING...';
                this.status.classList.add('visible');
                
                this.micSource.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
                
                // Haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate([50, 50, 50]);
                }
            }

            stopRecording() {
                this.isRecording = false;
                this.orb.classList.remove('recording');
                this.status.classList.remove('visible');
                
                try {
                    this.micSource.disconnect(this.recorder);
                    this.recorder.disconnect();
                } catch (e) {}
                
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                    this.processSample();
                }
            }

            processSample() {
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                const barLength = this.ctx.sampleRate * 60 / this.bpm * 4;
                const loopLength = Math.min(buffer.length, barLength);
                
                const loopBuffer = this.ctx.createBuffer(1, Math.floor(loopLength), this.ctx.sampleRate);
                const sourceData = buffer.getChannelData(0);
                const loopData = loopBuffer.getChannelData(0);
                
                this.processAudioForPersonality(sourceData, loopData, loopLength);
                
                this.loops.push({
                    buffer: loopBuffer,
                    playing: null,
                    effects: {
                        filter: null,
                        delay: null,
                        reverb: null,
                        distortion: null,
                        granular: null
                    },
                    grains: [],
                    personality: this.producer.personality,
                    timestamp: this.ctx.currentTime,
                    // Personal metadata
                    movementPattern: this.personal.movementPattern,
                    interactionStyle: this.personal.interactionStyle,
                    motionSnapshot: {
                        beta: this.motion.smoothBeta,
                        gamma: this.motion.smoothGamma
                    }
                });
                
                if (this.loops.length > 8) {
                    const removed = this.loops.shift();
                    if (removed.playing) {
                        removed.playing.stop();
                    }
                }
                
                this.producer.memory.push({
                    energy: this.analyzeEnergy(loopBuffer),
                    spectralCentroid: this.analyzeSpectralCentroid(loopBuffer),
                    timestamp: this.ctx.currentTime
                });
                
                // Update sample counter
                this.sampleCounter.textContent = this.loops.length;
                this.sampleCounter.classList.add('visible');
                
                // Personalized feedback messages
                const messages = {
                    'still': ['CAPTURED', 'FROZEN IN TIME', 'PRESERVED'],
                    'gentle': ['SMOOTH', 'FLOWING', 'GENTLE TOUCH'],
                    'rhythmic': ['GROOVY', 'IN THE POCKET', 'LOCKED IN'],
                    'energetic': ['WILD', 'UNLEASHED', 'EXPLOSIVE']
                };
                
                const messageSet = messages[this.personal.movementPattern] || messages['gentle'];
                const message = messageSet[Math.floor(Math.random() * messageSet.length)];
                
                this.status.textContent = `${message} • SAMPLE ${this.loops.length}`;
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
                
                // Auto-enable god mode after 3 samples
                if (this.loops.length === 3 && !this.producer.godMode) {
                    this.toggleGodMode();
                }
                
                // Haptic feedback based on energy
                if ('vibrate' in navigator) {
                    const energy = this.analyzeEnergy(loopBuffer);
                    navigator.vibrate(50 + Math.floor(energy * 150));
                }
            }

            processAudioForPersonality(sourceData, loopData, loopLength) {
                const fadeLength = 100;
                
                // Add personal touch based on movement pattern
                const movementProcessing = {
                    'still': (sample, i) => sample, // Clean, unprocessed
                    'gentle': (sample, i) => sample * (0.9 + Math.sin(i * 0.0001) * 0.1), // Subtle modulation
                    'rhythmic': (sample, i) => sample * (0.8 + Math.sin(i * 0.001) * 0.2), // Rhythmic pulsing
                    'energetic': (sample, i) => Math.tanh(sample * 2) * 0.9 // Driven harder
                };
                
                const processMovement = movementProcessing[this.personal.movementPattern] || movementProcessing['gentle'];
                
                switch (this.producer.personality) {
                    case 'kanye':
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            sample = Math.sign(sample) * Math.min(Math.abs(sample) * 2, 1);
                            sample = Math.tanh(sample * 3) * 0.9;
                            
                            // Personal movement processing
                            sample = processMovement(sample, i);
                            
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            loopData[i] = sample;
                        }
                        break;
                        
                    case 'dilla':
                        let phase = 0;
                        // More wobble for contemplative users
                        const wobbleAmount = this.personal.interactionStyle === 'contemplative' ? 0.0002 : 0.0001;
                        
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            if (Math.random() < 0.001) {
                                sample += (Math.random() - 0.5) * 0.1;
                            }
                            sample = Math.tanh(sample * 1.5) * 0.8;
                            phase += wobbleAmount + Math.sin(i * 0.00001) * 0.00005;
                            const wobbleIndex = Math.floor(i + Math.sin(phase) * 10) % sourceData.length;
                            sample = sample * 0.7 + sourceData[wobbleIndex] * 0.3;
                            
                            sample = processMovement(sample, i);
                            
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            loopData[i] = sample;
                        }
                        break;
                        
                    case 'flylo':
                        let delayBuffer = new Float32Array(4000);
                        let delayIndex = 0;
                        // More delay for expressive users
                        const delayFeedback = this.personal.interactionStyle === 'expressive' ? 0.6 : 0.5;
                        
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            if (i > 1) {
                                const cutoff = 0.5 + Math.sin(i * 0.0001) * 0.4;
                                sample = sample * cutoff + loopData[i-1] * (1 - cutoff) * 0.9;
                            }
                            const delayed = delayBuffer[delayIndex];
                            delayBuffer[delayIndex] = sample + delayed * delayFeedback;
                            sample = sample + delayed * 0.3;
                            delayIndex = (delayIndex + 1) % delayBuffer.length;
                            
                            sample = processMovement(sample, i);
                            
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            loopData[i] = Math.tanh(sample) * 0.8;
                        }
                        break;
                        
                    case 'arca':
                        let glitchBuffer = [];
                        // More glitches for energetic movement
                        const glitchChance = this.personal.movementPattern === 'energetic' ? 0.08 : 0.05;
                        
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            if (Math.random() < glitchChance) {
                                const glitchLength = Math.floor(Math.random() * 1000) + 100;
                                for (let j = 0; j < glitchLength && i + j < loopLength; j++) {
                                    glitchBuffer.push(sourceData[i]);
                                }
                            }
                            if (glitchBuffer.length > 0) {
                                sample = glitchBuffer.shift();
                            }
                            sample = Math.sign(sample) * Math.pow(Math.abs(sample), 0.5);
                            
                            sample = processMovement(sample, i);
                            
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            loopData[i] = sample * 0.9;
                        }
                        break;
                        
                    case 'sophie':
                        // Precision varies with user style
                        const precision = this.personal.interactionStyle === 'precise' ? 0.99 : 0.98;
                        
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            if (i > 0) {
                                sample = sample - sourceData[i-1] * precision;
                            }
                            sample = Math.max(-0.95, Math.min(0.95, sample * 2));
                            
                            sample = processMovement(sample, i);
                            
                            const fadeCurve = x => x * x * (3 - 2 * x);
                            if (i < fadeLength) sample *= fadeCurve(i / fadeLength);
                            if (i > loopLength - fadeLength) sample *= fadeCurve((loopLength - i) / fadeLength);
                            loopData[i] = sample;
                        }
                        break;
                        
                    default:
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            sample = processMovement(sample, i);
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            loopData[i] = sample;
                        }
                }
                
                // Apply motion-based processing if device is tilted during recording
                if (this.motion.enabled && this.isRecording) {
                    const tiltProcessing = Math.abs(this.motion.smoothBeta - this.motion.calibration.beta) / 90;
                    if (tiltProcessing > 0.2) {
                        // Apply pitch shift to the recorded loop
                        for (let i = 0; i < loopLength; i++) {
                            const shiftAmount = Math.floor(tiltProcessing * 100);
                            const shiftedIndex = (i + shiftAmount) % loopLength;
                            loopData[i] = loopData[i] * 0.7 + loopData[shiftedIndex] * 0.3;
                        }
                    }
                }
            }

            analyzeEnergy(buffer) {
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i];
                }
                return Math.sqrt(sum / data.length);
            }

            analyzeSpectralCentroid(buffer) {
                const data = buffer.getChannelData(0);
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 0; i < data.length / 2; i++) {
                    const magnitude = Math.abs(data[i]);
                    weightedSum += magnitude * i;
                    magnitudeSum += magnitude;
                }
                
                return magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
            }

            triggerSampleLoop(time) {
                this.loops.forEach((loop, index) => {
                    if (loop.playing) {
                        loop.playing.stop(time);
                    }
                    
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();
                    const panNode = this.ctx.createStereoPanner();
                    
                    source.buffer = loop.buffer;
                    source.loop = true;
                    
                    const filter = this.ctx.createBiquadFilter();
                    const delay = this.createPingPongDelay(0.375 * ((index % 4) + 1), 0.3 + index * 0.05);
                    const reverb = this.createAdvancedReverb(1 + index * 0.3, 0.7 + index * 0.05);
                    const distortion = this.ctx.createWaveShaper();
                    
                    const ageMultiplier = 1 + (this.ctx.currentTime - loop.timestamp) / 100;
                    
                    filter.type = ['lowpass', 'bandpass', 'highpass'][index % 3];
                    filter.frequency.value = 1000 + index * 1000 * ageMultiplier;
                    filter.Q.value = 2 + this.producer.complexity * 10;
                    
                    // Personalize based on the loop's captured movement pattern
                    if (loop.movementPattern === 'energetic') {
                        filter.Q.value *= 1.5;
                        filter.frequency.value *= 1.2;
                    } else if (loop.movementPattern === 'gentle') {
                        filter.Q.value *= 0.7;
                    }
                    
                    const distAmount = 10 + index * 15 + this.producer.evolution * 40 * ageMultiplier;
                    distortion.curve = this.makeDistortionCurve(distAmount);
                    distortion.oversample = '4x';
                    
                    const baseGain = (0.8 - (index * 0.08)) * (0.5 + this.producer.energy * 0.5);
                    gainNode.gain.value = baseGain;
                    
                    // Pan based on the motion when recorded
                    let recordedTilt = 0;
                    if (loop.motionSnapshot && this.motion.calibration.gamma !== undefined) {
                        recordedTilt = (loop.motionSnapshot.gamma - this.motion.calibration.gamma) / 90;
                        panNode.pan.value = Math.max(-0.8, Math.min(0.8, recordedTilt));
                    }
                    
                    if (index > 3 && this.producer.evolution > 0.5) {
                        this.setupGranularProcessing(loop, source, time);
                    }
                    
                    // Apply current motion to pitch
                    if (this.motion.enabled) {
                        const currentTilt = (this.motion.smoothBeta - this.motion.calibration.beta) / 90;
                        source.playbackRate.value = 1 + currentTilt * 0.2;
                    }
                    
                    source.connect(filter);
                    filter.connect(distortion);
                    distortion.connect(panNode);
                    panNode.connect(gainNode);
                    gainNode.connect(this.sampleBus);
                    
                    const wetAmount = Math.min(0.8, 0.2 + index * 0.1);
                    gainNode.connect(delay.input);
                    delay.output.gain.value = wetAmount;
                    delay.output.connect(this.sampleBus);
                    
                    gainNode.connect(reverb.input);
                    reverb.output.gain.value = wetAmount * 0.7;
                    reverb.output.connect(this.sampleBus);
                    
                    if (index > 5) {
                        gainNode.connect(this.chorusSend);
                        gainNode.connect(this.distortionSend);
                    }
                    
                    source.start(time);
                    loop.playing = source;
                    loop.effects = { filter, delay, reverb, distortion };
                    
                    const animateEffects = () => {
                        if (loop.playing === source) {
                            const now = this.ctx.currentTime;
                            
                            const lfo1 = Math.sin(now * (0.1 + index * 0.05)) * 0.5 + 0.5;
                            const lfo2 = Math.sin(now * (0.2 + index * 0.03)) * 0.5 + 0.5;
                            const lfo3 = Math.sin(now * 0.05) * 0.5 + 0.5;
                            
                            // Add motion modulation
                            let motionMod = 1;
                            if (this.motion.enabled) {
                                const tiltDelta = Math.abs(this.motion.smoothBeta - loop.motionSnapshot.beta) / 90;
                                motionMod = 1 + tiltDelta * 0.5;
                            }
                            
                            const baseFreq = 500 + this.producer.evolution * 3000;
                            filter.frequency.value = baseFreq + lfo1 * (15000 - index * 1000) * motionMod;
                            filter.Q.value = 1 + this.producer.energy * 15 + lfo2 * 10;
                            
                            const targetGain = baseGain * (0.7 + lfo3 * 0.3);
                            gainNode.gain.linearRampToValueAtTime(targetGain, now + 0.1);
                            
                            // Pan automation based on motion difference
                            if (this.motion.enabled && loop.motionSnapshot && this.motion.calibration.gamma !== undefined) {
                                const panDrift = (this.motion.smoothGamma - loop.motionSnapshot.gamma) / 180;
                                panNode.pan.linearRampToValueAtTime(
                                    Math.max(-1, Math.min(1, recordedTilt + panDrift)),
                                    now + 0.1
                                );
                            }
                            
                            requestAnimationFrame(animateEffects);
                        }
                    };
                    
                    if (this.producer.godMode) {
                        animateEffects();
                    }
                });
            }

            setupGranularProcessing(loop, source, startTime) {
                const grainDuration = 0.05;
                const grainOverlap = 0.5;
                const grainInterval = grainDuration * (1 - grainOverlap);
                
                let grainTime = startTime;
                const createGrain = () => {
                    if (loop.playing !== source) return;
                    
                    const grain = this.ctx.createBufferSource();
                    const grainEnv = this.ctx.createGain();
                    const grainPan = this.ctx.createStereoPanner();
                    
                    grain.buffer = loop.buffer;
                    
                    const position = Math.random();
                    grain.start(grainTime, position * loop.buffer.duration, grainDuration);
                    
                    grain.playbackRate.value = 0.5 + Math.random() * 1;
                    
                    grainEnv.gain.setValueAtTime(0, grainTime);
                    grainEnv.gain.linearRampToValueAtTime(0.2, grainTime + grainDuration * 0.3);
                    grainEnv.gain.linearRampToValueAtTime(0, grainTime + grainDuration);
                    
                    grainPan.pan.value = (Math.random() - 0.5) * 2;
                    
                    grain.connect(grainEnv);
                    grainEnv.connect(grainPan);
                    grainPan.connect(this.granularGain);
                    
                    grainTime += grainInterval;
                    
                    if (grainTime < this.ctx.currentTime + 2) {
                        setTimeout(createGrain, grainInterval * 1000);
                    }
                };
                
                createGrain();
            }

            toggleGodMode() {
                this.producer.godMode = true; // Always on after activation
                
                this.orb.classList.add('god-mode');
                this.status.textContent = 'AI PRODUCER ACTIVE';
                this.status.classList.add('visible');
                
                this.master.gain.linearRampToValueAtTime(1.1, this.ctx.currentTime + 0.5);
                
                this.sidechain.active = true;
                this.sidechain.amount = 0.5;
                
                this.animateVisualizer();
                
                this.aiPersonality.textContent = `${this.producer.personality.toUpperCase()}`;
                this.aiPersonality.classList.add('visible');
                
                // Haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate([100, 50, 100]);
                }
                
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }

            setAIPersonality(personality) {
                const personalities = ['kanye', 'dilla', 'flylo', 'arca', 'sophie'];
                if (personalities.includes(personality)) {
                    this.producer.personality = personality;
                    
                    switch (personality) {
                        case 'kanye':
                            this.bpm = 72;
                            this.swing = 0.15;
                            break;
                        case 'dilla':
                            this.bpm = 85;
                            this.swing = 0.25;
                            break;
                        case 'flylo':
                            this.bpm = 75;
                            this.swing = 0.1;
                            break;
                        case 'arca':
                            this.bpm = 130;
                            this.swing = 0;
                            break;
                        case 'sophie':
                            this.bpm = 140;
                            this.swing = 0;
                            break;
                    }
                    
                    this.status.textContent = `${personality.toUpperCase()} MODE`;
                    this.status.classList.add('visible');
                    setTimeout(() => this.status.classList.remove('visible'), 2000);
                    
                    if (this.producer.godMode) {
                        this.aiPersonality.textContent = personality.toUpperCase();
                    }
                    
                    // Haptic feedback
                    if ('vibrate' in navigator) {
                        navigator.vibrate(50);
                    }
                }
            }

            clearSamples() {
                this.loops.forEach(loop => {
                    if (loop.playing) {
                        loop.playing.stop();
                    }
                });
                this.loops = [];
                this.producer.memory = [];
                
                this.sampleCounter.textContent = '0';
                
                this.status.textContent = 'SAMPLES CLEARED';
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
                
                this.producer.complexity = 0;
                this.producer.evolution = 0;
                
                // Haptic feedback
                if ('vibrate' in navigator) {
                    navigator.vibrate(200);
                }
            }
        }

        // Initialize GUMP MOBILE
        const gump = new GUMP();
    </script>
</body>
</html>
