<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music 2.0: Personal Soundtrack</title>
  <script src="https://unpkg.com/tone@14.7.77/build/Tone.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { margin: 0; min-height: 100vh; display: flex; flex-direction: column; justify-content: center; align-items: center; background: linear-gradient(to bottom, #1e3a8a, #7c3aed); color: white; }
    #status { font-size: 0.9rem; opacity: 0.8; }
    #controls { display: flex; flex-wrap: wrap; gap: 1rem; }
    canvas { margin-top: 1rem; width: 100%; max-width: 300px; height: 100px; }
  </style>
</head>
<body>
  <div class="text-center p-4 max-w-md">
    <h1 class="text-3xl font-bold mb-4">Music 2.0: Your Soundtrack</h1>
    <p class="mb-4">Walk to set the beat, tilt to shape the vibe. Allow location and motion. Pocket your phone!</p>
    <button id="startBtn" class="bg-purple-600 hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-lg transition">Start Music</button>
    <div id="status" class="mt-4">Waiting to start...</div>
    <div id="tempoStatus" class="mt-2 text-sm">Walking Tempo: 0 BPM</div>
    <canvas id="visualizer"></canvas>
    <div id="controls" class="mt-4">
      <label class="flex items-center"><input type="checkbox" id="padToggle" checked class="mr-2"> Ambient Pad</label>
      <label class="flex items-center"><input type="checkbox" id="arpToggle" checked class="mr-2"> Arpeggio</label>
      <label class="flex items-center"><input type="checkbox" id="drumToggle" checked class="mr-2"> Drums</label>
      <label class="flex items-center flex-col">
        Motion Sensitivity
        <input type="range" id="motionSensitivity" min="0.5" max="2" step="0.1" value="1" class="mt-2">
      </label>
    </div>
  </div>

  <script>
    const startBtn = document.getElementById('startBtn');
    const statusDiv = document.getElementById('status');
    const tempoStatus = document.getElementById('tempoStatus');
    const padToggle = document.getElementById('padToggle');
    const arpToggle = document.getElementById('arpToggle');
    const drumToggle = document.getElementById('drumToggle');
    const motionSensitivity = document.getElementById('motionSensitivity');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');
    let synth, arp, drums, hiHat, reverb, delay, sidechain, analyser, meter, isPlaying = false;
    let lastStepTime = 0, stepBpm = 120, lastShake = 0, chordIndex = 0;

    // Initialize audio components
    function initAudio() {
      synth = new Tone.PolySynth(Tone.Synth, { 
        oscillator: { type: 'fatsawtooth' }, 
        envelope: { attack: 0.5, decay: 1, sustain: 0.7, release: 2 } 
      }).toDestination();
      arp = new Tone.PolySynth(Tone.Synth, { 
        oscillator: { type: 'triangle' }, 
        envelope: { attack: 0.1, decay: 0.2, sustain: 0.3, release: 0.5 } 
      }).toDestination();
      drums = new Tone.MembraneSynth({ pitchDecay: 0.05, octaves: 10 }).toDestination();
      hiHat = new Tone.MetalSynth({ frequency: 200, envelope: { attack: 0.001, decay: 0.1 }, octaves: 2 }).toDestination();
      reverb = new Tone.Reverb({ decay: 5, wet: 0.5 }).toDestination();
      delay = new Tone.PingPongDelay({ delayTime: '8n', feedback: 0.3, wet: 0.2 }).toDestination();
      sidechain = new Tone.Compressor({ threshold: -30, ratio: 6, attack: 0.01, release: 0.1 }).toDestination();
      analyser = new Tone.Analyser('waveform', 128).toDestination();
      meter = new Tone.Meter().toDestination();
      synth.connect(sidechain).connect(reverb).connect(meter).connect(analyser);
      arp.connect(delay).connect(meter).connect(analyser);
      drums.connect(reverb).connect(meter).connect(analyser);
      hiHat.connect(reverb).connect(meter).connect(analyser);
    }

    // Visualizer
    function drawVisualizer() {
      if (!isPlaying) return;
      const values = analyser.getValue();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.beginPath();
      ctx.strokeStyle = '#ffffff';
      ctx.lineWidth = 2;
      for (let i = 0; i < values.length; i++) {
        const x = (i / values.length) * canvas.width;
        const y = (1 - values[i]) * canvas.height / 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      requestAnimationFrame(drawVisualizer);
    }

    // Get user location
    async function getLocation() {
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) reject('Geolocation not supported');
        navigator.geolocation.getCurrentPosition(
          pos => resolve({ lat: pos.coords.latitude, lon: pos.coords.longitude }),
          err => reject(err.message)
        );
      });
    }

    // Fetch weather from Open-Meteo
    async function getWeather(lat, lon) {
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}Â¤t=temperature_2m,wind_speed_10m,cloud_cover,weather_code`;
      try {
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather fetch failed');
        const data = await response.json();
        return {
          temp: data.current.temperature_2m,
          wind: data.current.wind_speed_10m,
          clouds: data.current.cloud_cover,
          condition: data.current.weather_code
        };
      } catch (err) {
        console.error('Weather fetch failed:', err);
        return { temp: 20, wind: 10, clouds: 0, condition: 0 };
      }
    }

    // Get time-based scale and vibe
    function getTimeParams() {
      const hour = new Date().getHours();
      if (hour < 6) return { 
        scale: ['C4', 'Eb4', 'G4', 'Bb4'], 
        vibe: 'dark', 
        chords: [['C4', 'Eb4', 'G4'], ['G3', 'Bb3', 'D4'], ['Ab3', 'C4', 'Eb4'], ['F3', 'Ab3', 'C4']] // i-v-bVI-iv
      };
      if (hour < 12) return { 
        scale: ['C4', 'E4', 'G4', 'B4'], 
        vibe: 'bright', 
        chords: [['D4', 'F#4', 'A4'], ['G3', 'B3', 'D4'], ['A3', 'C#4', 'E4'], ['D4', 'F#4', 'A4']] // ii-V-I-ii
      };
      if (hour < 18) return { 
        scale: ['G4', 'A4', 'B4', 'D5'], 
        vibe: 'upbeat', 
        chords: [['G4', 'B4', 'D5'], ['C4', 'E4', 'G4'], ['D4', 'F#4', 'A4'], ['G4', 'B4', 'D5']] // I-IV-V-I
      };
      return { 
        scale: ['A4', 'C5', 'E5', 'G5'], 
        vibe: 'mellow', 
        chords: [['A4', 'C5', 'E5'], ['G4', 'B4', 'D5'], ['F4', 'A4', 'C5'], ['A4', 'C5', 'E5']] // i-bVII-bVI-i
      };
    }

    // Apply Picardy third for rain/clouds
    function applyPicardyThird(chords, clouds, isRainy) {
      if (clouds > 50 || isRainy) {
        const lastChord = chords[chords.length - 1];
        if (lastChord[1].includes('b')) { // Minor chord
          lastChord[1] = lastChord[1].replace('b', ''); // Make major (e.g., Eb4 -> E4)
        }
      }
      return chords;
    }

    // Handle device motion for walking tempo and tilt
    function handleMotion(event) {
      if (!isPlaying) return;
      const gyro = event.rotationRate || {};
      const beta = (gyro.beta || 0) / 180 * Math.PI; // Y-axis rotation rate (rad/s)
      const accel = event.accelerationIncludingGravity || {};
      const x = Math.abs(accel.x || 0);
      const totalAccel = Math.sqrt((accel.x || 0) ** 2 + (accel.y || 0) ** 2 + (accel.z || 0) ** 2);
      const sensitivity = parseFloat(motionSensitivity.value);

      // Tilt controls filter and pad volume
      const filterFreq = Math.min(5000, 200 + x * 500 * sensitivity);
      const padVolume = Math.min(0, -15 + x * 2 * sensitivity);
      synth.set({ filter: { frequency: filterFreq } });
      synth.volume.value = padToggle.checked ? padVolume : -Infinity;
      arp.volume.value = arpToggle.checked ? -10 : -Infinity;
      drums.volume.value = drumToggle.checked ? -10 : -Infinity;
      hiHat.volume.value = drumToggle.checked ? -15 : -Infinity;

      // Balance mix using meter
      const level = meter.getValue();
      if (level > -3) {
        synth.volume.value -= 1;
        arp.volume.value -= 1;
        drums.volume.value -= 1;
        hiHat.volume.value -= 1;
      }

      // Detect step (leg lift) via gyro Y-axis
      if (beta > 0.8 * sensitivity && Date.now() - lastStepTime > 300) {
        const now = Date.now();
        if (lastStepTime > 0) {
          const stepInterval = (now - lastStepTime) / 1000;
          stepBpm = Math.round(60 / stepInterval); // Step = half beat
          stepBpm = Math.max(60, Math.min(180, stepBpm));
          tempoStatus.textContent = `Walking Tempo: ${stepBpm} BPM`;
        }
        lastStepTime = now;
        if (drumToggle.checked) {
          drums.triggerAttackRelease('C2', '8n'); // Kick on step
        }
      }

      // Detect shake for chord change or fill
      if (totalAccel > 15 * sensitivity && Date.now() - lastShake > 500) {
        lastShake = Date.now();
        chordIndex = (chordIndex + 1) % 4; // Advance chord
        if (drumToggle.checked) {
          drums.triggerAttackRelease('C3', '8n'); // Snare fill
          hiHat.triggerAttackRelease('C4', '16n'); // Hi-hat accent
        }
      }
    }

    // Generate music
    async function generateMusic() {
      if (!isPlaying) return;
      try {
        const { lat, lon } = await getLocation();
        const weather = await getWeather(lat, lon);
        const { scale, vibe, chords } = getTimeParams();
        const isRainy = [45, 48, 51, 53, 55, 56, 57, 61, 63, 65, 66, 67].includes(weather.condition);
        const finalChords = applyPicardyThird(chords, weather.clouds, isRainy);

        // Map weather to music
        const temp = weather.temp;
        const wind = weather.wind;
        const clouds = weather.clouds;
        const rootShift = Math.round((temp + 20) / 5); // Transpose by temp
        const shiftedChords = finalChords.map(chord => 
          chord.map(note => Tone.Frequency(note).transpose(rootShift).toNote())
        );
        reverb.wet.value = isRainy ? 0.9 : clouds / 200;
        delay.feedback.value = wind / 100;
        Tone.Transport.bpm.value = stepBpm + wind / 5;

        // Ambient pad
        if (padToggle.checked) {
          const chord = shiftedChords[chordIndex];
          synth.triggerAttackRelease(chord, '2m');
          sidechain.set({ threshold: drumToggle.checked ? -30 : -Infinity }); // Sidechain with drums
        }

        // Arpeggio
        if (arpToggle.checked) {
          const chord = shiftedChords[chordIndex];
          const pattern = vibe === 'upbeat' ? chord.concat(chord.slice().reverse()) : chord;
          const density = Math.max(0.2, clouds / 100);
          const arpSequence = new Tone.Sequence((time, note) => {
            if (Math.random() < density) {
              arp.triggerAttackRelease(note, vibe === 'upbeat' ? '16n' : '8n', time, 0.5 + Math.random() * 0.5);
              arp.set({ pan: Math.random() * 0.4 - 0.2 }); // Subtle panning
            }
          }, pattern).start(0);
        }

        // Drums
        if (drumToggle.checked) {
          const kickPattern = vibe === 'upbeat' ? ['C2', null, 'C2', null] : ['C2', null, null, null];
          const snarePattern = vibe === 'upbeat' ? [null, 'C3', null, 'C3'] : [null, null, 'C3', null];
          const hiHatPattern = isRainy ? ['C4', 'C4', 'C4', 'C4'] : [null, 'C4', null, 'C4'];
          const drumSequence = new Tone.Sequence((time, beat) => {
            if (kickPattern[beat]) drums.triggerAttackRelease(kickPattern[beat], '8n', time);
            if (snarePattern[beat]) drums.triggerAttackRelease(snarePattern[beat], '8n', time);
            if (hiHatPattern[beat]) hiHat.triggerAttackRelease(hiHatPattern[beat], '16n', time);
          }, [0, 1, 2, 3]).start(0);
        }

        statusDiv.textContent = `Temp: ${temp}Â°C, Wind: ${wind} km/h, Clouds: ${clouds}%, Vibe: ${vibe}`;
        chordIndex = (chordIndex + 1) % 4; // Advance chord every 4 seconds
      } catch (err) {
        console.error('Error:', err);
        statusDiv.textContent = `Error: ${err}. Using fallback data.`;
      }

      setTimeout(generateMusic, 4000);
    }

    // Start music
    startBtn.addEventListener('click', async () => {
      if (isPlaying) return;
      isPlaying = true;
      startBtn.textContent = 'Playing...';
      startBtn.classList.add('opacity-50', 'cursor-not-allowed');
      await Tone.start();
      initAudio();
      Tone.Transport.start();
      drawVisualizer();

      // Request motion permission
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceMotionEvent.requestPermission();
          if (permission === 'granted') {
            window.addEventListener('devicemotion', handleMotion);
          } else {
            statusDiv.textContent += ' Motion denied. Walk/tilt wonât affect sound.';
          }
        } catch (err) {
          statusDiv.textContent += ' Motion permission error.';
        }
      } else {
        window.addEventListener('devicemotion', handleMotion);
      }

      generateMusic();
    });
  </script>
</body>
</html>
