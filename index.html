<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        :root{--phi:1.618;--gold:61.8%}
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#050505;overflow:hidden;touch-action:none;height:100vh;font-family:system-ui,-apple-system,sans-serif}
        canvas{position:fixed;inset:0}

        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100;cursor:pointer;background:#050505}
        #enter.off{display:none}
        #enter i{width:89px;height:89px;border-radius:50%;border:1px solid rgba(255,255,255,0.08);display:flex;align-items:center;justify-content:center}
        #enter i::after{content:'';width:34px;height:34px;border-radius:50%;border:1px solid rgba(255,255,255,0.15)}

        #loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:99;background:#050505;color:rgba(255,255,255,0.2);font-size:8px;letter-spacing:3px}
        #loading.off{display:none}

        /* Minimal dial system - Fibonacci spacing */
        #dials{position:fixed;bottom:0;left:0;right:0;z-index:50;padding:13px 21px 34px;touch-action:pan-x}

        .dial{display:flex;align-items:center;justify-content:center;gap:21px;margin-bottom:13px}
        .dial-opt{font-size:11px;color:rgba(255,255,255,0.15);cursor:pointer;padding:8px 13px;transition:all 0.3s;letter-spacing:1px;-webkit-tap-highlight-color:transparent}
        .dial-opt.on{color:rgba(255,255,255,0.7)}
        .dial-opt:hover{color:rgba(255,255,255,0.4)}

        .dial-line{width:1px;height:13px;background:rgba(255,255,255,0.05)}
    </style>
</head>
<body>
<div id="enter"><i></i></div>
<div id="loading" class="off">...</div>

<div id="dials" style="display:none">
    <div class="dial" data-dial="pulse">
        <span class="dial-opt" data-v="0">—</span>
        <span class="dial-line"></span>
        <span class="dial-opt on" data-v="dust">dust</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="gold">gold</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="drive">drive</span>
    </div>
    <div class="dial" data-dial="depth">
        <span class="dial-opt" data-v="0">—</span>
        <span class="dial-line"></span>
        <span class="dial-opt on" data-v="sub">sub</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="thick">thick</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="warm">warm</span>
    </div>
    <div class="dial" data-dial="haze">
        <span class="dial-opt" data-v="clear">clear</span>
        <span class="dial-line"></span>
        <span class="dial-opt on" data-v="fog">fog</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="glass">glass</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="heat">heat</span>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// GUMP - Ghosts in the Machine
// Discovery. Adventure. Surprise.

const TAU = Math.PI * 2;
const PHI = 1.618033988749;

let ctx, master, canvas, vc;
let running = false;

// State
let dial = { pulse: 'dust', depth: 'sub', haze: 'fog' };
let field = { x: 0.5, y: 0.5, energy: 0, time: 0, peak: 0 };

// Musical awareness
let music = {
    intensity: 0.3,
    bar: 0,
    phrase: 0,
    tension: 0,
    lastGhost: 0,
    dropPending: false,
    silenceUntil: 0
};

// ============ SAMPLES ============

const URLS = {
    kick_a: 'https://cdn.freesound.org/previews/171/171104_2394245-lq.mp3',
    kick_b: 'https://cdn.freesound.org/previews/568/568573_12517458-lq.mp3',
    snare_a: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    snare_b: 'https://cdn.freesound.org/previews/398/398712_183766-lq.mp3',
    hat_a: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',
    hat_b: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',
};

let samples = {};

async function loadSamples() {
    for (const [k, url] of Object.entries(URLS)) {
        try {
            const r = await fetch(url);
            samples[k] = await ctx.decodeAudioData(await r.arrayBuffer());
        } catch(e) {
            samples[k] = makeFallback(k);
        }
    }
}

function makeFallback(k) {
    const sr = ctx.sampleRate, len = sr * 0.4;
    const buf = ctx.createBuffer(2, len, sr);
    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        if (k.includes('kick')) {
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                d[i] = Math.sin(TAU * (140 * Math.exp(-t * 25) + 45) * t) * Math.exp(-t * 10) * 0.8;
            }
        } else if (k.includes('snare')) {
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                d[i] = ((Math.random() * 2 - 1) * 0.7 + Math.sin(TAU * 180 * t) * 0.3) * Math.exp(-t * 15) * 0.6;
            }
        } else {
            for (let i = 0; i < len * 0.15; i++) {
                const t = i / sr;
                d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40) * 0.35;
            }
        }
    }
    return buf;
}

// ============ FX ============

let drumBus, bassBus, padBus, masterBus;
let lofiFilter, verb, verbWet, dly, dlyWet, sat, comp, lim;

function initFX() {
    drumBus = ctx.createGain(); drumBus.gain.value = 0.7;
    bassBus = ctx.createGain(); bassBus.gain.value = 0.6;
    padBus = ctx.createGain(); padBus.gain.value = 0.35;
    masterBus = ctx.createGain();

    sat = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) curve[i] = Math.tanh((i / 32768 - 1) * 1.4) * 0.95;
    sat.curve = curve;
    sat.oversample = '4x';

    lofiFilter = ctx.createBiquadFilter();
    lofiFilter.type = 'lowpass';
    lofiFilter.frequency.value = 18000;

    comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -14;
    comp.ratio.value = 4;
    comp.attack.value = 0.003;
    comp.release.value = 0.12;

    lim = ctx.createDynamicsCompressor();
    lim.threshold.value = -2;
    lim.ratio.value = 20;
    lim.attack.value = 0.001;

    // Reverb
    verb = ctx.createConvolver();
    const vLen = ctx.sampleRate * 2.5;
    const vBuf = ctx.createBuffer(2, vLen, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = vBuf.getChannelData(ch);
        for (let i = 0; i < vLen; i++) d[i] = (Math.random() * 2 - 1) * Math.exp(-i / ctx.sampleRate / 1.2) * 0.4;
    }
    verb.buffer = vBuf;
    verbWet = ctx.createGain();
    verbWet.gain.value = 0.2;

    // Delay
    dly = ctx.createDelay(1);
    dly.delayTime.value = 0.375;
    const dlyFb = ctx.createGain();
    dlyFb.gain.value = 0.3;
    const dlyFilt = ctx.createBiquadFilter();
    dlyFilt.type = 'lowpass';
    dlyFilt.frequency.value = 2200;
    dlyWet = ctx.createGain();
    dlyWet.gain.value = 0.15;
    dly.connect(dlyFilt).connect(dlyFb).connect(dly);
    dlyFilt.connect(dlyWet);

    master = ctx.createGain();
    master.gain.value = 0.85;

    // Routing
    [drumBus, bassBus, padBus].forEach(b => b.connect(masterBus));
    masterBus.connect(sat).connect(lofiFilter).connect(comp);
    masterBus.connect(verb); verb.connect(verbWet);
    masterBus.connect(dly);
    [comp, verbWet, dlyWet].forEach(n => n.connect(lim));
    lim.connect(master).connect(ctx.destination);
}

// ============ PATTERN ENGINE ============

function euclidean(steps, pulses, rot = 0) {
    const p = [];
    let b = 0;
    for (let i = 0; i < steps; i++) {
        b += pulses;
        p.push(b >= steps ? (b -= steps, 1) : 0);
    }
    for (let i = 0; i < rot; i++) p.push(p.shift());
    return p;
}

const GENES = {
    dust: { bpm: 72, kickP: 3, swing: 0.12, ghost: 0.25, kit: 'a' },
    gold: { bpm: 88, kickP: 5, swing: 0.15, ghost: 0.2, kit: 'b' },
    drive: { bpm: 122, kickP: 4, swing: 0, ghost: 0.1, kit: 'b' }
};

let pattern = null;
let step = 0;
let lastStep = 0;

function genPattern(gene, bar) {
    const g = GENES[gene];
    const evolution = Math.sin(bar * 0.4) * 0.5;
    const kicks = euclidean(16, Math.round(g.kickP + evolution), bar % 5);

    const snares = new Array(16).fill(0);
    snares[4] = 1; snares[12] = 1;
    if (bar % 4 === 3) snares[14] = 0.6; // Fill hint

    const hats = [];
    for (let i = 0; i < 16; i++) {
        hats.push(Math.random() < 0.45 ? 0.25 + Math.random() * 0.25 : 0);
    }

    // Ghost notes
    const ghosts = kicks.map((k, i) => !k && !snares[i] && Math.random() < g.ghost * music.intensity ? 0.12 : 0);

    return { kicks, snares, hats, ghosts, swing: g.swing, kit: g.kit, bpm: g.bpm };
}

function play(buf, opts = {}) {
    if (!buf) return;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    if (opts.pitch) src.playbackRate.value = Math.pow(2, opts.pitch / 12);

    const g = ctx.createGain();
    g.gain.value = opts.vol || 1;

    let node = src;
    if (opts.filter) {
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = opts.filter;
        src.connect(f);
        node = f;
    }

    if (opts.pan) {
        const p = ctx.createStereoPanner();
        p.pan.value = opts.pan;
        node.connect(p).connect(g);
    } else {
        node.connect(g);
    }

    g.connect(opts.bus || drumBus);
    src.start(ctx.currentTime + (opts.delay || 0) + (Math.random() - 0.5) * 0.006);
}

function updateBeats() {
    if (dial.pulse === '0' || field.time < music.silenceUntil) return;

    const gene = GENES[dial.pulse];
    if (!gene) return;

    const stepDur = 60 / gene.bpm / 4;
    const now = ctx.currentTime;

    if (now - lastStep >= stepDur) {
        lastStep = now;

        if (step % 16 === 0) {
            music.bar++;
            music.phrase = music.bar % 8;
            pattern = genPattern(dial.pulse, music.bar);
            music.intensity = music.intensity * 0.9 + field.peak * 0.1;
            music.intensity = Math.max(0.15, Math.min(1, music.intensity));

            // Tension builds
            music.tension += 0.05;
            if (music.tension > 1 && Math.random() < 0.3) {
                triggerDrop();
            }
        }

        if (!pattern) return;

        const s = step % 16;
        const sw = s % 2 === 1 ? stepDur * pattern.swing : 0;
        const k = pattern.kit;

        if (pattern.kicks[s]) {
            play(samples['kick_' + k], { vol: 0.85 + music.intensity * 0.15, delay: sw });
        }
        if (pattern.snares[s]) {
            play(samples['snare_' + k], { vol: pattern.snares[s] * 0.75, delay: sw, pan: (Math.random() - 0.5) * 0.1 });
        }
        if (pattern.hats[s]) {
            play(samples['hat_' + k], { vol: pattern.hats[s], delay: sw, pan: (Math.random() - 0.5) * 0.4, filter: dial.haze === 'fog' ? 5000 : 12000 });
        }
        if (pattern.ghosts[s]) {
            play(samples['kick_' + k], { vol: pattern.ghosts[s], delay: sw, filter: 600, pitch: -3 });
        }

        // GHOSTS IN THE MACHINE - rare surprises
        if (Math.random() < 0.008 && field.time - music.lastGhost > 8) {
            triggerGhost();
        }

        step++;
    }
}

// ============ GHOSTS & ADVENTURE ============

function triggerGhost() {
    music.lastGhost = field.time;
    const type = Math.floor(Math.random() * 5);

    if (type === 0) {
        // Reverse-ish hit
        play(samples['snare_a'], { vol: 0.3, pitch: -7, pan: Math.random() - 0.5 });
    } else if (type === 1) {
        // Whisper echo
        setTimeout(() => play(samples['hat_a'], { vol: 0.15, pitch: 12, filter: 3000 }), 200);
        setTimeout(() => play(samples['hat_a'], { vol: 0.1, pitch: 12, filter: 2000 }), 400);
    } else if (type === 2) {
        // Sub drop
        const o = ctx.createOscillator();
        const g = ctx.createGain();
        o.frequency.setValueAtTime(80, ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(25, ctx.currentTime + 0.5);
        g.gain.setValueAtTime(0.4, ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + 0.6);
        o.connect(g).connect(bassBus);
        o.start(); o.stop(ctx.currentTime + 0.6);
    } else if (type === 3) {
        // Silence gap
        music.silenceUntil = field.time + 0.3 + Math.random() * 0.4;
    } else {
        // Stutter
        for (let i = 0; i < 4; i++) {
            setTimeout(() => play(samples['kick_a'], { vol: 0.25 - i * 0.05 }), i * 60);
        }
    }
}

function triggerDrop() {
    music.tension = 0;
    // Moment of silence before drop
    music.silenceUntil = field.time + 0.15;
    // Reset intensity for impact
    setTimeout(() => {
        music.intensity = 0.9;
        play(samples['kick_' + (pattern?.kit || 'a')], { vol: 1.2 });
    }, 180);
}

// ============ BASS ============

let bassO1, bassO2, bassF, bassG, bassLFO, bassLFOG;

function initBass() {
    bassO1 = ctx.createOscillator();
    bassO2 = ctx.createOscillator();
    bassO1.type = bassO2.type = 'sine';
    bassO1.frequency.value = bassO2.frequency.value = 55;
    bassO2.detune.value = 8;

    bassF = ctx.createBiquadFilter();
    bassF.type = 'lowpass';
    bassF.frequency.value = 400;
    bassF.Q.value = 1.5;

    bassLFO = ctx.createOscillator();
    bassLFO.frequency.value = 0.4;
    bassLFOG = ctx.createGain();
    bassLFOG.gain.value = 0;
    bassLFO.connect(bassLFOG).connect(bassF.frequency);
    bassLFO.start();

    bassG = ctx.createGain();
    bassG.gain.value = 0;

    const mix = ctx.createGain();
    mix.gain.value = 0.5;
    bassO1.connect(mix);
    bassO2.connect(mix);
    mix.connect(bassF).connect(bassG).connect(bassBus);
    bassO1.start();
    bassO2.start();
}

let bassSeq = [0, 0, 5, 3];
let lastBassShift = 0;

function updateBass() {
    if (dial.depth === '0') {
        bassG.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
        return;
    }

    const cfg = {
        sub: { t1: 'sine', t2: 'sine', base: 32.7, filt: 180, lfo: 0, vol: 0.55 },
        thick: { t1: 'sawtooth', t2: 'sawtooth', base: 55, filt: 500, lfo: 120, vol: 0.35, det: 18 },
        warm: { t1: 'triangle', t2: 'sine', base: 55, filt: 700, lfo: 40, vol: 0.4, det: 6 }
    }[dial.depth];

    if (!cfg) return;

    // Evolve sequence
    if (field.time - lastBassShift > 3 && Math.random() < 0.08) {
        lastBassShift = field.time;
        bassSeq[Math.floor(Math.random() * 4)] = [0, 3, 5, 7, -5][Math.floor(Math.random() * 5)];
    }

    const note = bassSeq[music.bar % 4];
    const freq = cfg.base * Math.pow(2, note / 12) * Math.pow(2, (1 - field.y) * 0.4);

    bassO1.type = cfg.t1;
    bassO2.type = cfg.t2;
    bassO1.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.04);
    bassO2.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.04);
    bassO2.detune.value = cfg.det || 8;

    bassF.frequency.linearRampToValueAtTime(cfg.filt * (1 + field.energy), ctx.currentTime + 0.05);
    bassLFOG.gain.value = cfg.lfo * music.intensity;
    bassG.gain.linearRampToValueAtTime(cfg.vol, ctx.currentTime + 0.1);
}

// ============ PAD ============

let padOscs = [], padG, padF;

const CHORDS = {
    dust: [[0,3,7,10], [5,8,12,15], [3,7,10,14], [7,10,14,17]],
    gold: [[0,4,7,11], [5,9,12,16], [7,11,14,17], [0,4,7,11]],
    drive: [[0,3,7,12], [5,8,12,17], [7,10,14,19], [0,3,7,12]]
};

function initPad() {
    padG = ctx.createGain();
    padG.gain.value = 0;
    padF = ctx.createBiquadFilter();
    padF.type = 'lowpass';
    padF.frequency.value = 1800;

    for (let i = 0; i < 4; i++) {
        const o = ctx.createOscillator();
        o.type = 'sine';
        o.frequency.value = 220;
        const g = ctx.createGain();
        g.gain.value = 0.12 / (i + 1);
        o.connect(g).connect(padF);
        o.start();
        padOscs.push({ o, g });
    }
    padF.connect(padG).connect(padBus);
}

function updatePad() {
    const genre = dial.pulse === '0' ? 'dust' : dial.pulse;
    const chords = CHORDS[genre] || CHORDS.dust;
    const chord = chords[music.bar % 4];
    const base = 110 * Math.pow(2, (1 - field.y) * 0.4);

    padOscs.forEach((p, i) => {
        const freq = base * Math.pow(2, (chord[i] || 0) / 12);
        p.o.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.25);
    });

    // Pad swells in stillness
    const still = 1 - Math.min(1, field.energy * 4);
    padG.gain.linearRampToValueAtTime(still * 0.2 * music.intensity, ctx.currentTime + 0.15);
    padF.frequency.linearRampToValueAtTime(1200 + still * 1500, ctx.currentTime + 0.1);
}

// ============ TEXTURE ============

let textureSrc, textureG;

function initTexture() {
    const len = ctx.sampleRate * 5;
    const buf = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
            const crackle = Math.random() < 0.0008 ? (Math.random() - 0.5) * 0.4 : 0;
            d[i] = crackle + (Math.random() * 2 - 1) * 0.015;
        }
    }
    textureSrc = ctx.createBufferSource();
    textureSrc.buffer = buf;
    textureSrc.loop = true;

    const f = ctx.createBiquadFilter();
    f.type = 'bandpass';
    f.frequency.value = 2500;
    f.Q.value = 0.4;

    textureG = ctx.createGain();
    textureG.gain.value = 0;

    textureSrc.connect(f).connect(textureG).connect(masterBus);
    textureSrc.start();
}

// ============ MELODY LAYERS ============

let melodies = [];

function createMelody() {
    if (melodies.length >= 3) {
        const old = melodies.shift();
        old.o.stop();
    }

    const genre = dial.pulse === '0' ? 'dust' : dial.pulse;
    const chord = (CHORDS[genre] || CHORDS.dust)[music.bar % 4];
    const note = chord[Math.floor(Math.random() * chord.length)];
    const base = 220 * Math.pow(2, (1 - field.y) * 0.8);
    const freq = base * Math.pow(2, note / 12);

    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const f = ctx.createBiquadFilter();

    o.type = melodies.length % 2 ? 'triangle' : 'sine';
    o.frequency.value = freq;
    f.type = 'lowpass';
    f.frequency.value = 1400;
    const vol = 0.04 * Math.pow(0.65, melodies.length);
    g.gain.value = vol;

    o.connect(f).connect(g).connect(padBus);
    o.start();

    melodies.push({ o, g, f, freq, vol, phase: 0, len: 1.5 + Math.random() * 1.5 });
}

function updateMelodies(dt) {
    for (const m of melodies) {
        m.phase += dt / m.len;
        if (m.phase >= 1) m.phase -= 1;
        m.g.gain.value = m.vol * (0.5 + 0.5 * Math.cos(m.phase * TAU));
    }
}

let orb = { on: false, x: 0.5, y: 0.5 };

function updateOrb(dt) {
    if (!orb.on && field.energy > 0.04) {
        orb.on = true;
        orb.x = field.x;
        orb.y = field.y;
    }
    if (orb.on) {
        const dx = 0.5 - orb.x, dy = 0.5 - orb.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d > 0.03) {
            orb.x += (dx / d) * 0.5 * dt;
            orb.y += (dy / d) * 0.5 * dt;
        } else {
            createMelody();
            orb.on = false;
        }
        if (field.energy < 0.008) orb.on = false;
    }
}

// ============ HAZE ============

const HAZE = {
    clear: { filt: 20000, verb: 0.08, dly: 0.05, tex: 0 },
    fog: { filt: 3000, verb: 0.25, dly: 0.18, tex: 0.12 },
    glass: { filt: 14000, verb: 0.18, dly: 0.1, tex: 0.02 },
    heat: { filt: 8000, verb: 0.12, dly: 0.22, tex: 0.06 }
};

function updateHaze() {
    const h = HAZE[dial.haze] || HAZE.fog;
    lofiFilter.frequency.linearRampToValueAtTime(h.filt, ctx.currentTime + 0.15);
    verbWet.gain.linearRampToValueAtTime(h.verb, ctx.currentTime + 0.15);
    dlyWet.gain.linearRampToValueAtTime(h.dly, ctx.currentTime + 0.15);
    textureG.gain.linearRampToValueAtTime(h.tex, ctx.currentTime + 0.15);
}

// ============ INPUT ============

function onMove(nx, ny) {
    const dx = nx - field.x, dy = ny - field.y;
    field.x += dx * 0.18;
    field.y += dy * 0.18;
    field.energy = field.energy * 0.88 + Math.sqrt(dx * dx + dy * dy) * 2;
    field.peak = Math.max(field.peak * 0.985, field.energy);
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    const ax = (a.x || 0) / 10, ay = (a.y || 0) / 10;
    field.x = Math.max(0, Math.min(1, field.x + ax * 0.05));
    field.y = Math.max(0, Math.min(1, field.y - ay * 0.05));
    field.energy = field.energy * 0.88 + Math.sqrt(ax * ax + ay * ay) * 0.5;
    field.peak = Math.max(field.peak * 0.985, field.energy);
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 45, gy = (e.beta || 0) / 45 - 0.5;
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ DIALS ============

function initDials() {
    document.querySelectorAll('.dial').forEach(d => {
        const name = d.dataset.dial;
        d.querySelectorAll('.dial-opt').forEach(opt => {
            opt.addEventListener('click', e => {
                e.stopPropagation();
                d.querySelectorAll('.dial-opt').forEach(o => o.classList.remove('on'));
                opt.classList.add('on');
                dial[name] = opt.dataset.v;
                if (name === 'pulse') { step = 0; lastStep = ctx.currentTime; pattern = null; }
                if (name === 'haze') updateHaze();
            });
            opt.addEventListener('touchend', e => e.stopPropagation());
        });
    });
}

// ============ VISUALS ============

function resize() {
    const dpr = devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;
    vc.fillStyle = `rgba(5,5,5,${0.08 + music.intensity * 0.04})`;
    vc.fillRect(0, 0, w, h);

    // Golden spiral hint
    const r = 21 + music.intensity * 13;
    vc.strokeStyle = `rgba(255,255,255,${0.02 + music.tension * 0.03})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w / 2, h / 2, r, 0, TAU);
    vc.stroke();

    // Melody rings
    melodies.forEach((m, i) => {
        const mr = 34 + i * 21;
        const a = 0.04 + (0.5 + 0.5 * Math.cos(m.phase * TAU)) * 0.08;
        vc.strokeStyle = `rgba(140,160,200,${a})`;
        vc.beginPath();
        vc.arc(w / 2, h / 2, mr, 0, TAU);
        vc.stroke();
    });

    // Orb
    if (orb.on) {
        vc.fillStyle = 'rgba(255,255,255,0.4)';
        vc.beginPath();
        vc.arc(orb.x * w, orb.y * h, 4, 0, TAU);
        vc.fill();
    }

    // Cursor
    vc.fillStyle = `rgba(255,255,255,${0.08 + field.energy * 0.35})`;
    vc.beginPath();
    vc.arc(field.x * w, field.y * h, 3 + field.energy * 8, 0, TAU);
    vc.fill();
}

// ============ LOOP ============

function tick() {
    if (!running) return;
    const dt = 1 / 60;
    field.time += dt;
    field.energy *= 0.96;

    updateBeats();
    updateBass();
    updatePad();
    updateOrb(dt);
    updateMelodies(dt);

    draw();
    requestAnimationFrame(tick);
}

// ============ INIT ============

async function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    initFX();
    initBass();
    initPad();
    initTexture();
    initDials();

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    addEventListener('resize', resize);

    document.getElementById('loading').classList.remove('off');
    await loadSamples();
    document.getElementById('loading').classList.add('off');
    document.getElementById('dials').style.display = 'block';

    updateHaze();
}

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch (e) { }
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch (e) { }
    }

    await init();

    addEventListener('devicemotion', onMotion);
    addEventListener('deviceorientation', onOrientation);
    canvas.addEventListener('mousemove', e => onMove(e.clientX / innerWidth, e.clientY / innerHeight));
    canvas.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX / innerWidth, e.touches[0].clientY / innerHeight); }, { passive: false });
    canvas.addEventListener('touchstart', e => { e.preventDefault(); onMove(e.touches[0].clientX / innerWidth, e.touches[0].clientY / innerHeight); }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
