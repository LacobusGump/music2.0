<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>GUMP DJ - Creative Intelligence</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
            -webkit-user-select: none;
        }
        :root {
            --phi: 1.618;
            --f1: 1px;
            --f2: 2px;
            --f3: 3px;
            --f5: 5px;
            --f8: 8px;
            --f13: 13px;
            --f21: 21px;
            --f34: 34px;
            --f55: 55px;
            --f89: 89px;
            --f144: 144px;
            --f233: 233px;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            height: 100dvh;
            overflow: hidden;
            position: relative;
            touch-action: none;
        }
        body::before {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(ellipse at center, rgba(138, 43, 226, 0.02) 0%, transparent 61.8%);
            animation: breathe 8s ease-in-out infinite;
            pointer-events: none;
        }
        @keyframes breathe {
            0%, 100% { opacity: 0.3; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.1); }
        }
        .creative-engine {
            width: 100vw;
            height: 100vh;
            height: 100dvh;
            display: flex;
            flex-direction: column;
            position: relative;
        }
        /* Init */
        .genesis-portal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            transition: all 0.377s cubic-bezier(0.23, 1, 0.320, 1);
        }
        .genesis-text {
            font-size: var(--f21);
            letter-spacing: var(--f5);
            font-weight: 100;
            opacity: 0.89;
        }
        .genesis-portal::before {
            content: '';
            position: absolute;
            inset: -var(--f34);
            border: 1px solid rgba(138, 43, 226, 0.21);
            border-radius: 50%;
            animation: pulse-ring 2.618s infinite;
        }
        @keyframes pulse-ring {
            0% { transform: scale(1); opacity: 1; }
            100% { transform: scale(1.618); opacity: 0; }
        }
        /* Main Interface */
        .studio {
            display: none;
            width: 100%;
            height: 100%;
            flex-direction: column;
        }
        .studio.active {
            display: flex;
        }
        /* Creative Status */
        .creative-status {
            height: var(--f55);
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0 var(--f21);
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(21px);
            -webkit-backdrop-filter: blur(21px);
            border-bottom: 1px solid rgba(138, 43, 226, 0.13);
        }
        .ai-state {
            display: flex;
            flex-direction: column;
            gap: var(--f2);
        }
        .ai-mood {
            font-size: var(--f8);
            letter-spacing: var(--f2);
            text-transform: uppercase;
            opacity: 0.55;
        }
        .ai-mood.creating {
            color: #8a2be2;
            text-shadow: 0 0 var(--f13) rgba(138, 43, 226, 0.5);
            opacity: 1;
        }
        .ai-process {
            font-size: var(--f8);
            opacity: 0.34;
            font-style: italic;
        }
        .beat-info {
            text-align: center;
        }
        .bpm-display {
            font-size: var(--f34);
            font-weight: 100;
        }
        .bar-count {
            font-size: var(--f8);
            opacity: 0.55;
        }
        .layer-count {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }
        .layer-number {
            font-size: var(--f21);
            color: #00ffff;
        }
        .layer-label {
            font-size: var(--f8);
            opacity: 0.55;
        }
        /* Composition Canvas */
        .composition-space {
            flex: 1;
            position: relative;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            padding: var(--f13);
        }
        /* Sample Waveform Display */
        .current-sample {
            height: var(--f89);
            background: rgba(138, 43, 226, 0.03);
            border: 1px solid rgba(138, 43, 226, 0.13);
            border-radius: var(--f5);
            margin-bottom: var(--f13);
            position: relative;
            overflow: hidden;
        }
        .sample-waveform {
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }
        .chop-markers {
            position: absolute;
            inset: 0;
            pointer-events: none;
        }
        .chop-marker {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 2px;
            background: rgba(255, 215, 0, 0.8);
            box-shadow: 0 0 var(--f8) rgba(255, 215, 0, 0.5);
        }
        /* Beat Grid */
        .beat-grid {
            flex: 1;
            display: grid;
            grid-template-rows: repeat(4, 1fr);
            gap: var(--f5);
            margin-bottom: var(--f13);
        }
        .track-layer {
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: var(--f3);
            position: relative;
            display: flex;
            align-items: center;
            padding: 0 var(--f8);
            overflow: hidden;
        }
        .track-label {
            position: absolute;
            left: var(--f8);
            font-size: var(--f8);
            opacity: 0.34;
            z-index: 1;
        }
        .pattern-sequence {
            display: flex;
            gap: var(--f2);
            width: 100%;
            height: 80%;
            align-items: center;
            position: relative;
            z-index: 2;
        }
        .pattern-step {
            flex: 1;
            height: 100%;
            background: rgba(138, 43, 226, 0.1);
            border-radius: var(--f2);
            transition: all 0.144s ease-out;
            position: relative;
            overflow: hidden;
        }
        .pattern-step.active {
            background: linear-gradient(135deg, rgba(138, 43, 226, 0.5), rgba(0, 255, 255, 0.5));
            box-shadow: 0 0 var(--f13) rgba(138, 43, 226, 0.5);
        }
        .pattern-step.playing {
            animation: step-pulse 0.2s ease-out;
        }
        @keyframes step-pulse {
            0% { transform: scaleY(1); }
            50% { transform: scaleY(1.2); }
            100% { transform: scaleY(1); }
        }
        /* Creation Visualizer */
        .creation-viz {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--f233);
            height: var(--f233);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.377s ease-out;
        }
        .creation-viz.active {
            opacity: 1;
        }
        .creation-particles {
            position: absolute;
            inset: 0;
        }
        .particle {
            position: absolute;
            width: var(--f3);
            height: var(--f3);
            background: rgba(138, 43, 226, 0.8);
            border-radius: 50%;
            animation: particle-float 3s ease-in-out infinite;
        }
        @keyframes particle-float {
            0%, 100% { transform: translate(0, 0) scale(1); opacity: 0.5; }
            50% { transform: translate(var(--x), var(--y)) scale(1.5); opacity: 1; }
        }
        /* Capture State */
        .capture-indicator {
            position: absolute;
            top: var(--f89);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--f13);
            color: #ff0000;
            opacity: 0;
            transition: opacity 0.233s ease-out;
            letter-spacing: var(--f2);
            text-transform: uppercase;
        }
        .capture-indicator.recording {
            opacity: 1;
            animation: record-blink 1s ease-in-out infinite;
        }
        @keyframes record-blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }
        /* Progress Ring */
        .progress-ring {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--f144);
            height: var(--f144);
            pointer-events: none;
        }
        .progress-ring circle {
            fill: none;
            stroke: rgba(138, 43, 226, 0.2);
            stroke-width: 2;
        }
        .progress-ring .progress {
            stroke: #8a2be2;
            stroke-dasharray: 440;
            stroke-dashoffset: 440;
            transform: rotate(-90deg);
            transform-origin: center;
            transition: stroke-dashoffset 0.377s ease-out;
        }
        /* Touch Ripple */
        .touch-ripple {
            position: absolute;
            width: var(--f55);
            height: var(--f55);
            border-radius: 50%;
            background: radial-gradient(circle, rgba(138, 43, 226, 0.5), transparent);
            pointer-events: none;
            transform: translate(-50%, -50%);
            animation: ripple-out 0.610s ease-out;
        }
        @keyframes ripple-out {
            0% { transform: translate(-50%, -50%) scale(0); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; }
        }
        /* Debug */
        .debug {
            position: absolute;
            top: 2px;
            right: 2px;
            font-size: 9px;
            font-family: monospace;
            opacity: 0.3;
            text-align: right;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div class="creative-engine">
        <!-- Genesis -->
        <div class="genesis-portal" id="genesis">
            <div class="genesis-text">AWAKEN</div>
        </div>
        <!-- Studio Interface -->
        <div class="studio" id="studio">
            <!-- Creative Status Bar -->
            <div class="creative-status">
                <div class="ai-state">
                    <div class="ai-mood" id="aiMood">AWAKENING</div>
                    <div class="ai-process" id="aiProcess">listening...</div>
                </div>
                <div class="beat-info">
                    <div class="bpm-display" id="bpmDisplay">120</div>
                    <div class="bar-count" id="barCount">1/4</div>
                </div>
                <div class="layer-count">
                    <div class="layer-number" id="layerNumber">0</div>
                    <div class="layer-label">LAYERS</div>
                </div>
            </div>
            <!-- Capture Indicator -->
            <div class="capture-indicator" id="captureIndicator">‚óè RECORDING</div>
            <!-- Composition Space -->
            <div class="composition-space">
                <!-- Current Sample Visualization -->
                <div class="current-sample" id="currentSample">
                    <canvas class="sample-waveform" id="sampleWaveform"></canvas>
                    <div class="chop-markers" id="chopMarkers"></div>
                </div>
                <!-- Beat Grid -->
                <div class="beat-grid" id="beatGrid">
                    <div class="track-layer" data-track="0">
                        <span class="track-label">FOUNDATION</span>
                        <div class="pattern-sequence" id="pattern0"></div>
                    </div>
                    <div class="track-layer" data-track="1">
                        <span class="track-label">RHYTHM</span>
                        <div class="pattern-sequence" id="pattern1"></div>
                    </div>
                    <div class="track-layer" data-track="2">
                        <span class="track-label">MELODY</span>
                        <div class="pattern-sequence" id="pattern2"></div>
                    </div>
                    <div class="track-layer" data-track="3">
                        <span class="track-label">TEXTURE</span>
                        <div class="pattern-sequence" id="pattern3"></div>
                    </div>
                </div>
                <!-- Creation Visualizer -->
                <div class="creation-viz" id="creationViz">
                    <svg class="progress-ring">
                        <circle cx="50%" cy="50%" r="70"></circle>
                        <circle class="progress" cx="50%" cy="50%" r="70"></circle>
                    </svg>
                    <div class="creation-particles" id="particles"></div>
                </div>
            </div>
        </div>
        <!-- Debug -->
        <div class="debug" id="debug"></div>
    </div>
    <script>
        class CreativeAIProducer {
            constructor() {
                // Audio Core
                this.ctx = null;
                this.input = null;
                this.sampleRate = 48000;
               
                // Creative AI Brain
                this.consciousness = {
                    state: 'awakening',
                    creativity: 0.5,
                    confidence: 0.3,
                    memory: [],
                    currentIdea: null,
                    musicalKey: null,
                    groove: null,
                    buildProgress: 0
                };
               
                // Composition State
                this.composition = {
                    bpm: 120,
                    bars: 4,
                    currentBar: 0,
                    layers: [],
                    patterns: [[], [], [], []],
                    isPlaying: false,
                    loopLength: 4, // bars
                    quantize: 16 // 16th notes
                };
               
                // Sample Processing
                this.captureBuffer = null;
                this.captureLength = 4; // seconds for creative sampling
                this.maxCaptureLength = 8; // max to allow extension
                this.isCapturing = false;
                this.captureStartTime = 0;
               
                // Chop Shop
                this.chopData = {
                    slices: [],
                    transients: [],
                    melodicContent: [],
                    rhythmicPattern: null
                };
               
                // Playback Engine
                this.scheduler = null;
                this.nextNoteTime = 0;
                this.currentStep = 0;
                this.lookahead = 0.1; // seconds
                this.scheduleInterval = 25; // ms
               
                // UI
                this.ui = {};
               
                // Initialize
                this.setupUI();
                this.bindEvents();
            }
           
            setupUI() {
                this.ui = {
                    genesis: document.getElementById('genesis'),
                    studio: document.getElementById('studio'),
                    aiMood: document.getElementById('aiMood'),
                    aiProcess: document.getElementById('aiProcess'),
                    bpmDisplay: document.getElementById('bpmDisplay'),
                    barCount: document.getElementById('barCount'),
                    layerNumber: document.getElementById('layerNumber'),
                    captureIndicator: document.getElementById('captureIndicator'),
                    sampleWaveform: document.getElementById('sampleWaveform'),
                    chopMarkers: document.getElementById('chopMarkers'),
                    beatGrid: document.getElementById('beatGrid'),
                    patterns: [
                        document.getElementById('pattern0'),
                        document.getElementById('pattern1'),
                        document.getElementById('pattern2'),
                        document.getElementById('pattern3')
                    ],
                    creationViz: document.getElementById('creationViz'),
                    particles: document.getElementById('particles'),
                    debug: document.getElementById('debug')
                };
               
                // Initialize patterns
                this.initializePatterns();
               
                // Create particles
                this.createParticles();
            }
           
            initializePatterns() {
                // Create 16 steps for each pattern
                for (let i = 0; i < 4; i++) {
                    for (let j = 0; j < 16; j++) {
                        const step = document.createElement('div');
                        step.className = 'pattern-step';
                        step.dataset.track = i;
                        step.dataset.step = j;
                        this.ui.patterns[i].appendChild(step);
                    }
                }
            }
           
            createParticles() {
                for (let i = 0; i < 8; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.setProperty('--x', `${(Math.random() - 0.5) * 100}px`);
                    particle.style.setProperty('--y', `${(Math.random() - 0.5) * 100}px`);
                    particle.style.animationDelay = `${i * 0.377}s`;
                    this.ui.particles.appendChild(particle);
                }
            }
           
            bindEvents() {
                // Initialize
                this.ui.genesis.addEventListener('click', () => this.initialize());
               
                // Touch gestures for capture (optional, since automatic)
                let touchStart = null;
                document.addEventListener('touchstart', (e) => {
                    touchStart = Date.now();
                    this.createRipple(e.touches[0].clientX, e.touches[0].clientY);
                });
               
                document.addEventListener('touchend', () => {
                    if (touchStart && Date.now() - touchStart > 500) {
                        // Long press triggers capture
                        this.startCreativeCapture();
                    }
                    touchStart = null;
                });
               
                // Double tap for instant capture
                let lastTap = 0;
                document.addEventListener('touchend', () => {
                    const now = Date.now();
                    if (now - lastTap < 300) {
                        this.captureInstant();
                    }
                    lastTap = now;
                });
            }
           
            createRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'touch-ripple';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                document.body.appendChild(ripple);
                setTimeout(() => ripple.remove(), 610);
            }
           
            async initialize() {
                try {
                    // Create context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: this.sampleRate,
                        latencyHint: 'interactive'
                    });
                   
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                   
                    // Get mic
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate
                        }
                    });
                   
                    // Setup audio pipeline
                    this.setupAudioPipeline(stream);
                   
                    // Show studio
                    this.ui.genesis.style.display = 'none';
                    this.ui.studio.classList.add('active');
                   
                    // Start AI consciousness
                    this.awakenConsciousness();
                   
                    // Start creative engine
                    this.startCreativeEngine();
                   
                    // Update UI
                    this.updateAIState('LISTENING', 'waiting for inspiration...');
                   
                } catch (err) {
                    console.error('Failed to initialize:', err);
                    alert('Unable to access microphone');
                }
            }
           
            setupAudioPipeline(stream) {
                // Input source
                this.input = this.ctx.createMediaStreamSource(stream);
               
                // Analysis chain
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.8;
               
                // Capture buffer (8 seconds circular)
                const bufferLength = this.sampleRate * 8;
                this.circularBuffer = new Float32Array(bufferLength);
                this.writePos = 0;
               
                // Recording processor
                this.recorder = this.ctx.createScriptProcessor(2048, 1, 1);
                this.recorder.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    this.processInputStream(input);
                };
               
                // Master output
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.9;
               
                // Compressor
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -10;
                this.compressor.knee.value = 10;
                this.compressor.ratio.value = 5;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.1;
               
                // Connect input chain
                this.input.connect(this.analyser);
                this.input.connect(this.recorder);
               
                // Silent connection for recorder
                const silence = this.ctx.createGain();
                silence.gain.value = 0;
                this.recorder.connect(silence);
                silence.connect(this.ctx.destination);
               
                // Output chain
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.ctx.destination);
            }
           
            processInputStream(input) {
                // Write to circular buffer
                for (let i = 0; i < input.length; i++) {
                    this.circularBuffer[this.writePos] = input[i];
                    this.writePos = (this.writePos + 1) % this.circularBuffer.length;
                }
               
                // Analyze if capturing
                if (this.isCapturing) {
                    this.analyzeCreativeContent();
                }
            }
           
            awakenConsciousness() {
                // AI consciousness loop
                this.consciousnessInterval = setInterval(() => {
                    // Evolve creativity
                    this.consciousness.creativity = 0.5 + 0.5 * Math.sin(Date.now() / 10000);
                   
                    // Build confidence through successful captures
                    if (this.composition.layers.length > 0) {
                        this.consciousness.confidence = Math.min(1, this.consciousness.confidence + 0.05);
                    }
                   
                    // Update state based on composition
                    if (this.composition.layers.length === 0) {
                        this.consciousness.state = 'searching';
                    } else if (this.composition.layers.length < 3) {
                        this.consciousness.state = 'building';
                    } else {
                        this.consciousness.state = 'creating';
                    }
                   
                    // Make creative decisions
                    this.makeCreativeDecision();
                   
                }, 2000);
            }
           
            makeCreativeDecision() {
                // AI decides what to do next
                const decision = Math.random();
               
                if (this.consciousness.state === 'searching' && decision < 0.3) {  // More frequent captures
                    // Start looking for foundation
                    this.updateAIState('HUNTING', 'searching for the perfect loop...');
                    this.startCreativeCapture();
                } else if (this.consciousness.state === 'building' && decision < 0.2) {
                    // Add another layer
                    this.updateAIState('LAYERING', 'finding complementary sounds...');
                    this.startCreativeCapture();
                } else if (this.consciousness.state === 'creating' && decision < 0.1) {
                    // Apply creative effect
                    this.applyCreativeEffect();
                }
            }
           
            startCreativeCapture() {
                if (this.isCapturing) return;
               
                this.isCapturing = true;
                this.captureStartTime = Date.now();
                this.captureLength = 4;  // Reset length
                this.captureBuffer = new Float32Array(this.sampleRate * this.maxCaptureLength);  // Alloc max
                this.capturePos = 0;
               
                // UI feedback
                this.ui.captureIndicator.classList.add('recording');
                this.ui.creationViz.classList.add('active');
                this.updateAIState('CAPTURING', 'recording reality...');
               
                // Capture interval
                this.captureInterval = setInterval(() => {
                    const elapsed = (Date.now() - this.captureStartTime) / 1000;
                   
                    // Copy from circular buffer
                    const samplesToRead = Math.min(
                        2048,
                        (this.sampleRate * this.captureLength) - this.capturePos
                    );
                   
                    const startPos = (this.writePos - samplesToRead + this.circularBuffer.length) % this.circularBuffer.length;
                   
                    for (let i = 0; i < samplesToRead; i++) {
                        const pos = (startPos + i) % this.circularBuffer.length;
                        this.captureBuffer[this.capturePos++] = this.circularBuffer[pos];
                    }
                   
                    // Update progress
                    const progress = elapsed / this.captureLength;
                    this.updateProgress(progress);
                   
                    if (elapsed >= this.captureLength) {
                        clearInterval(this.captureInterval);
                        this.processCreativeCapture();
                    }
                }, 50);
            }
           
            captureInstant() {
                // Quick 1-second capture for percussive elements
                this.captureLength = 1;
                this.startCreativeCapture();
            }
           
            updateProgress(progress) {
                const circle = this.ui.creationViz.querySelector('.progress');
                const circumference = 2 * Math.PI * 70;
                const offset = circumference - (progress * circumference);
                circle.style.strokeDashoffset = offset;
            }
           
            processCreativeCapture() {
                this.isCapturing = false;
                this.ui.captureIndicator.classList.remove('recording');
               
                // Trim buffer to actual length
                this.captureBuffer = this.captureBuffer.slice(0, this.capturePos);
               
                // Normalize capture
                this.normalizeBuffer(this.captureBuffer);
               
                // Analyze for creative potential
                this.updateAIState('ANALYZING', 'finding the magic...');
                const analysis = this.analyzeMusicalContent(this.captureBuffer);
               
                // Creative transformation based on analysis
                this.updateAIState('CREATING', 'transforming into art...');
                const transformed = this.creativeTransformation(this.captureBuffer, analysis);
               
                // Chop it up Kanye-style
                this.updateAIState('CHOPPING', 'slicing the soul...');
                const chops = this.intelligentChop(transformed, analysis);
               
                // Build pattern from chops
                this.updateAIState('COMPOSING', 'arranging the pieces...');
                this.buildPattern(chops, analysis, transformed);
               
                // Update UI
                this.updateCompositionDisplay(transformed);
                this.ui.creationViz.classList.remove('active');
               
                // Start playback if this is the first layer
                if (this.composition.layers.length === 1 && !this.composition.isPlaying) {
                    this.startPlayback();
                }
            }
           
            analyzeMusicalContent(buffer) {
                const analysis = {
                    energy: 0,
                    spectralCentroid: 0,
                    zeroCrossings: 0,
                    tempo: null,
                    key: null,
                    transients: [],
                    isPercussive: false,
                    isMelodic: false,
                    emotionalTone: 'neutral'
                };
               
                // Energy calculation
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += buffer[i] * buffer[i];
                }
                analysis.energy = Math.sqrt(sum / buffer.length);
               
                // Zero crossing rate (percussion detection)
                for (let i = 1; i < buffer.length; i++) {
                    if ((buffer[i] >= 0) !== (buffer[i-1] >= 0)) {
                        analysis.zeroCrossings++;
                    }
                }
               
                const zcr = analysis.zeroCrossings / buffer.length;
                analysis.isPercussive = zcr > 0.05;
                analysis.isMelodic = zcr < 0.02 && analysis.energy > 0.1;
               
                // Find transients (sudden energy changes)
                const windowSize = 512;
                let prevEnergy = 0;
                for (let i = 0; i < buffer.length - windowSize; i += windowSize / 2) {
                    let windowEnergy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        windowEnergy += buffer[i + j] * buffer[i + j];
                    }
                   
                    if (windowEnergy > prevEnergy * 2 && windowEnergy > analysis.energy * 2) {
                        analysis.transients.push(i / this.sampleRate);
                    }
                    prevEnergy = windowEnergy;
                }
               
                // Tempo detection (simplified)
                if (analysis.transients.length > 4) {
                    const intervals = [];
                    for (let i = 1; i < analysis.transients.length; i++) {
                        intervals.push(analysis.transients[i] - analysis.transients[i-1]);
                    }
                   
                    const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                    analysis.tempo = Math.round(60 / avgInterval);
                   
                    // Snap to common tempos
                    const commonTempos = [60, 70, 80, 90, 100, 110, 120, 128, 140, 160, 174];
                    let closestTempo = commonTempos[0];
                    let minDiff = Math.abs(analysis.tempo - closestTempo);
                   
                    for (const tempo of commonTempos) {
                        const diff = Math.abs(analysis.tempo - tempo);
                        if (diff < minDiff) {
                            minDiff = diff;
                            closestTempo = tempo;
                        }
                    }
                   
                    analysis.tempo = closestTempo;
                }
               
                // Emotional tone based on spectral content
                if (analysis.energy < 0.2) {
                    analysis.emotionalTone = 'ambient';
                } else if (analysis.isPercussive) {
                    analysis.emotionalTone = 'rhythmic';
                } else if (analysis.isMelodic) {
                    analysis.emotionalTone = 'melodic';
                } else {
                    analysis.emotionalTone = 'textural';
                }
               
                return analysis;
            }
           
            creativeTransformation(buffer, analysis) {
                // Create a new buffer for transformation
                const transformed = new Float32Array(buffer.length);
                buffer.forEach((sample, i) => transformed[i] = sample);
               
                // Apply creative processing based on analysis
                if (this.composition.layers.length === 0) {
                    // First layer - create foundation
                    if (analysis.isPercussive) {
                        // Enhance transients
                        this.enhanceTransients(transformed);
                    } else if (analysis.isMelodic) {
                        // Pitch to key
                        this.autotune(transformed, 'C');
                    }
                   
                    // Time stretch to fit tempo
                    if (analysis.tempo && Math.abs(analysis.tempo - this.composition.bpm) > 10) {
                        const ratio = this.composition.bpm / analysis.tempo;
                        this.timeStretch(transformed, ratio);
                    }
                } else {
                    // Additional layers - complement existing
                    const layerRole = this.determineLayerRole(analysis);
                   
                    switch(layerRole) {
                        case 'rhythm':
                            this.processAsRhythm(transformed);
                            break;
                        case 'melody':
                            this.processAsMelody(transformed);
                            break;
                        case 'texture':
                            this.processAsTexture(transformed);
                            break;
                    }
                }
               
                // Apply creative effects based on mood
                if (this.consciousness.creativity > 0.7) {
                    // High creativity - more experimental
                    if (Math.random() < 0.5) {
                        this.reverse(transformed);
                    }
                    if (Math.random() < 0.3) {
                        this.bitcrush(transformed, 8);
                    }
                }
               
                return transformed;
            }
           
            enhanceTransients(buffer) {
                // Transient shaping
                const envelope = new Float32Array(buffer.length);
                const attackTime = 0.001 * this.sampleRate;
                const releaseTime = 0.05 * this.sampleRate;
               
                let env = 0;
                for (let i = 0; i < buffer.length; i++) {
                    const input = Math.abs(buffer[i]);
                   
                    if (input > env) {
                        env += (input - env) / attackTime;
                    } else {
                        env += (input - env) / releaseTime;
                    }
                   
                    envelope[i] = env;
                   
                    // Apply shaping
                    buffer[i] *= (1 + envelope[i] * 2);
                }
            }
           
            autotune(buffer, targetKey) {
                // Simplified placeholder for pitch correction
                // In real scenario, use a pitch detection and shift algorithm like phase vocoder
                // Here, we apply a slight pitch shift as example
                const shiftRatio = 1.05;  // Slight shift
                this.pitchShift(buffer, shiftRatio);
            }
           
            pitchShift(buffer, ratio) {
                // Simple pitch shift without time correction (changes duration)
                const outputLength = Math.floor(buffer.length / ratio);
                const output = new Float32Array(outputLength);
               
                for (let i = 0; i < outputLength; i++) {
                    const sourceIndex = Math.floor(i * ratio);
                    output[i] = buffer[sourceIndex] || 0;
                }
               
                buffer.set(output);
                buffer.fill(0, output.length, buffer.length);  // Pad with zero if shortened
            }
           
            timeStretch(buffer, ratio) {
                // WSOLA-style time stretching (simplified)
                const outputLength = Math.floor(buffer.length / ratio);  // Note: inverse ratio for stretch
                const output = new Float32Array(outputLength);
               
                for (let i = 0; i < outputLength; i++) {
                    const sourceIndex = i * ratio;
                    const index0 = Math.floor(sourceIndex);
                    const index1 = Math.min(index0 + 1, buffer.length - 1);
                    const fraction = sourceIndex - index0;
                   
                    if (index0 < buffer.length) {
                        output[i] = buffer[index0] * (1 - fraction) + buffer[index1] * fraction;
                    }
                }
               
                // Copy back, truncate if longer
                for (let i = 0; i < Math.min(buffer.length, output.length); i++) {
                    buffer[i] = output[i];
                }
                if (outputLength < buffer.length) {
                    buffer.fill(0, outputLength);
                }
            }
           
            determineLayerRole(analysis) {
                if (analysis.isPercussive) return 'rhythm';
                if (analysis.isMelodic) return 'melody';
                return 'texture';
            }
           
            processAsRhythm(buffer) {
                // Gate and quantize
                const gateThreshold = 0.1;
                for (let i = 0; i < buffer.length; i++) {
                    if (Math.abs(buffer[i]) < gateThreshold) {
                        buffer[i] = 0;
                    }
                }
            }
           
            processAsMelody(buffer) {
                // Add reverb tail simulation
                const decay = 0.3;
                for (let i = 1; i < buffer.length; i++) {
                    buffer[i] += buffer[i-1] * decay;
                }
            }
           
            processAsTexture(buffer) {
                // Granular-style processing
                const grainSize = 1024;
                for (let i = 0; i < buffer.length - grainSize; i += grainSize / 2) {
                    // Reverse random grains
                    if (Math.random() < 0.3) {
                        for (let j = 0; j < grainSize / 2; j++) {
                            const temp = buffer[i + j];
                            buffer[i + j] = buffer[i + grainSize - j - 1];
                            buffer[i + grainSize - j - 1] = temp;
                        }
                    }
                }
            }
           
            reverse(buffer) {
                const reversed = new Float32Array(buffer.length);
                for (let i = 0; i < buffer.length; i++) {
                    reversed[i] = buffer[buffer.length - 1 - i];
                }
                buffer.set(reversed);
            }
           
            bitcrush(buffer, bits) {
                const levels = Math.pow(2, bits);
                for (let i = 0; i < buffer.length; i++) {
                    buffer[i] = Math.round(buffer[i] * levels) / levels;
                }
            }
           
            intelligentChop(buffer, analysis) {
                const chops = [];
               
                // Determine chop points
                let chopPoints = [0];
               
                if (analysis.transients.length > 0) {
                    // Chop at transients
                    for (const transient of analysis.transients) {
                        chopPoints.push(Math.floor(transient * this.sampleRate));
                    }
                } else {
                    // Regular interval chops
                    const chopInterval = this.sampleRate * 60 / this.composition.bpm / 4; // 16th notes
                    for (let i = chopInterval; i < buffer.length; i += chopInterval) {
                        chopPoints.push(Math.floor(i));
                    }
                }
               
                chopPoints.push(buffer.length);
               
                // Create chops
                for (let i = 0; i < chopPoints.length - 1; i++) {
                    const start = chopPoints[i];
                    const end = chopPoints[i + 1];
                    const chopBuffer = new Float32Array(end - start);
                   
                    for (let j = 0; j < chopBuffer.length; j++) {
                        chopBuffer[j] = buffer[start + j];
                    }
                   
                    chops.push({
                        buffer: chopBuffer,
                        start: start / this.sampleRate,
                        duration: chopBuffer.length / this.sampleRate,
                        energy: this.calculateEnergy(chopBuffer),
                        type: analysis.emotionalTone
                    });
                }
               
                // Display chop markers
                this.displayChopMarkers(chopPoints, buffer.length);
               
                return chops;
            }
           
            calculateEnergy(buffer) {
                let sum = 0;
                for (let i = 0; i < buffer.length; i++) {
                    sum += buffer[i] * buffer[i];
                }
                return Math.sqrt(sum / buffer.length);
            }
           
            displayChopMarkers(chopPoints, totalLength) {
                this.ui.chopMarkers.innerHTML = '';
               
                for (const point of chopPoints) {
                    if (point > 0 && point < totalLength) {
                        const marker = document.createElement('div');
                        marker.className = 'chop-marker';
                        marker.style.left = `${(point / totalLength) * 100}%`;
                        this.ui.chopMarkers.appendChild(marker);
                    }
                }
            }
           
            buildPattern(chops, analysis, transformed) {
                // Create pattern from chops
                const pattern = [];
                const stepsPerBar = 16;
                const totalSteps = stepsPerBar * this.composition.loopLength;
               
                // Determine which track to use
                let trackIndex = this.composition.layers.length;
                if (trackIndex > 3) trackIndex = 3;
               
                // Create pattern based on content type
                if (analysis.isPercussive) {
                    // Rhythmic pattern - more complex
                    const kickPattern = [true, false, false, false, true, false, false, false, true, false, false, false, true, false, false, false];
                    const snarePattern = [false, false, true, false, false, false, true, false, false, false, true, false, false, false, true, false];
                    const hatPattern = [true, true, true, true, true, true, true, true, true, true, true, true, true, true, true, true];
                   
                    for (let i = 0; i < totalSteps; i++) {
                        let chopIndex = 0;
                        let velocity = 0;
                       
                        if (kickPattern[i % 16]) {
                            chopIndex = 0;
                            velocity = 1.0;
                        } else if (snarePattern[i % 16]) {
                            chopIndex = Math.min(1, chops.length - 1);
                            velocity = 0.8;
                        } else if (hatPattern[i % 16] && Math.random() < 0.6) {
                            chopIndex = Math.floor(Math.random() * chops.length);
                            velocity = 0.4 + Math.random() * 0.4;
                        }
                       
                        if (velocity > 0) {
                            pattern.push({
                                chop: chops[chopIndex % chops.length],
                                velocity: velocity
                            });
                        } else {
                            pattern.push(null);
                        }
                    }
                } else if (analysis.isMelodic) {
                    // Melodic pattern - create a more varied melody
                    const melodyNotes = [0, 2, 4, 5, 7, 9, 11, 12];  // Scale degrees
                    for (let i = 0; i < totalSteps; i++) {
                        if (i % 4 === 0 || Math.random() < 0.3) {
                            const noteIndex = Math.floor(Math.random() * melodyNotes.length);
                            const chopIndex = noteIndex % chops.length;
                            pattern.push({
                                chop: chops[chopIndex],
                                velocity: 0.6 + Math.random() * 0.3,
                                pitch: 1 + (melodyNotes[noteIndex] / 12) * (Math.random() < 0.5 ? 1 : -1)  // Semitone shift
                            });
                        } else {
                            pattern.push(null);
                        }
                    }
                } else {
                    // Textural pattern - sparse and atmospheric
                    for (let i = 0; i < totalSteps; i++) {
                        if (Math.random() < 0.25) {
                            const chopIndex = Math.floor(Math.random() * chops.length);
                            pattern.push({
                                chop: chops[chopIndex],
                                velocity: 0.3 + Math.random() * 0.4,
                                pitch: 0.8 + Math.random() * 0.4
                            });
                        } else {
                            pattern.push(null);
                        }
                    }
                }
               
                // Store pattern
                this.composition.patterns[trackIndex] = pattern;
               
                // Create layer
                const layer = {
                    id: Date.now(),
                    type: analysis.emotionalTone,
                    buffer: transformed,
                    chops: chops,
                    pattern: pattern,
                    volume: 0.8,
                    muted: false
                };
               
                this.composition.layers.push(layer);
               
                // Update pattern display
                this.updatePatternDisplay(trackIndex, pattern);
            }
           
            updatePatternDisplay(trackIndex, pattern) {
                const steps = this.ui.patterns[trackIndex].querySelectorAll('.pattern-step');
               
                pattern.forEach((step, i) => {
                    if (i < steps.length) {
                        if (step) {
                            steps[i].classList.add('active');
                            steps[i].style.opacity = step.velocity;
                        } else {
                            steps[i].classList.remove('active');
                            steps[i].style.opacity = 1;
                        }
                    }
                });
            }
           
            normalizeBuffer(buffer) {
                let max = 0;
                for (let i = 0; i < buffer.length; i++) {
                    max = Math.max(max, Math.abs(buffer[i]));
                }
               
                if (max > 0 && max < 0.95) {
                    const gain = 0.8 / max;
                    for (let i = 0; i < buffer.length; i++) {
                        buffer[i] *= gain;
                    }
                }
            }
           
            updateAIState(mood, process) {
                this.ui.aiMood.textContent = mood;
                this.ui.aiMood.className = 'ai-mood creating';
                this.ui.aiProcess.textContent = process;
            }
           
            updateCompositionDisplay(transformed) {
                // Update layer count
                this.ui.layerNumber.textContent = this.composition.layers.length;
               
                // Update BPM if detected
                if (this.composition.layers.length === 1) {
                    const firstLayer = this.composition.layers[0];
                    if (firstLayer.analysis && firstLayer.analysis.tempo) {
                        this.composition.bpm = firstLayer.analysis.tempo;
                        this.ui.bpmDisplay.textContent = this.composition.bpm;
                    }
                }
               
                // Display waveform
                this.displayWaveform(transformed || this.captureBuffer);
            }
           
            displayWaveform(buffer) {
                const canvas = this.ui.sampleWaveform;
                const ctx = canvas.getContext('2d');
               
                canvas.width = canvas.offsetWidth;
                canvas.height = canvas.offsetHeight;
               
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.strokeStyle = 'rgba(138, 43, 226, 0.8)';
                ctx.lineWidth = 1;
               
                ctx.beginPath();
               
                const step = Math.ceil(buffer.length / canvas.width);
               
                for (let i = 0; i < canvas.width; i++) {
                    const index = i * step;
                    const value = buffer[index] || 0;
                    const y = (1 - value) * canvas.height / 2;
                   
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
               
                ctx.stroke();
            }
           
            startPlayback() {
                if (this.composition.layers.length === 0) return;
               
                this.composition.isPlaying = true;
               
                this.currentStep = 0;
                this.nextNoteTime = this.ctx.currentTime;
               
                this.scheduler = setInterval(() => this.schedule(), this.scheduleInterval);
            }
           
            stopPlayback() {
                this.composition.isPlaying = false;
               
                if (this.scheduler) {
                    clearInterval(this.scheduler);
                    this.scheduler = null;
                }
            }
           
            schedule() {
                while (this.nextNoteTime < this.ctx.currentTime + this.lookahead) {
                    this.scheduleStep(this.currentStep, this.nextNoteTime);
                    this.nextStep();
                }
            }
           
            scheduleStep(stepNumber, time) {
                // Play all layers for this step
                for (let trackIndex = 0; trackIndex < this.composition.patterns.length; trackIndex++) {
                    const pattern = this.composition.patterns[trackIndex];
                    if (!pattern || pattern.length === 0) continue;
                   
                    const step = pattern[stepNumber % pattern.length];
                    if (step && step.chop) {
                        this.playChop(step.chop, step.velocity, step.pitch || 1, time);
                    }
                }
               
                // Visual feedback
                setTimeout(() => {
                    this.updateStepDisplay(stepNumber);
                }, (time - this.ctx.currentTime) * 1000);
            }
           
            playChop(chop, velocity, pitch, time) {
                const source = this.ctx.createBufferSource();
                const buffer = this.ctx.createBuffer(1, chop.buffer.length, this.sampleRate);
                buffer.getChannelData(0).set(chop.buffer);
                source.buffer = buffer;
               
                const gain = this.ctx.createGain();
                gain.gain.value = velocity * 0.5;
               
                source.playbackRate.value = pitch;
               
                source.connect(gain);
                gain.connect(this.masterGain);
               
                source.start(time);
            }
           
            updateStepDisplay(stepNumber) {
                // Update pattern display
                for (let i = 0; i < 4; i++) {
                    const steps = this.ui.patterns[i].querySelectorAll('.pattern-step');
                    steps.forEach((step, j) => {
                        if (j === stepNumber % 16) {
                            step.classList.add('playing');
                        } else {
                            step.classList.remove('playing');
                        }
                    });
                }
               
                // Update bar count
                const bar = Math.floor(stepNumber / 16) + 1;
                this.ui.barCount.textContent = `${bar}/4`;
            }
           
            nextStep() {
                const secondsPerBeat = 60.0 / this.composition.bpm;
                const secondsPerStep = secondsPerBeat / 4; // 16th notes
               
                this.nextNoteTime += secondsPerStep;
                this.currentStep = (this.currentStep + 1) % (16 * this.composition.loopLength);
            }
           
            // Creative Effects (called by AI)
            applyCreativeEffect() {
                const effects = [
                    this.activateChopMode.bind(this),
                    this.activatePitchMode.bind(this),
                    this.activateReverseMode.bind(this),
                    this.activateStretchMode.bind(this)
                ];
               
                const effect = effects[Math.floor(Math.random() * effects.length)];
                effect();
            }
           
            activateChopMode() {
                this.updateAIState('CHOPPING', 're-imagining the rhythm...');
               
                // Re-chop current layers
                if (this.composition.layers.length > 0) {
                    const layer = this.composition.layers[this.composition.layers.length - 1];
                    const newChops = this.intelligentChop(layer.buffer, { transients: layer.analysis.transients, emotionalTone: layer.analysis.emotionalTone });
                    layer.chops = newChops;
                    const pattern = layer.pattern;
                    pattern.forEach((step, i) => {
                        if (step) {
                            step.chop = newChops[Math.floor(Math.random() * newChops.length)];
                        }
                    });
                    this.updatePatternDisplay(this.composition.layers.length - 1, pattern);
                    this.displayChopMarkers(layer.chops.map(c => c.start * this.sampleRate), layer.buffer.length);
                }
            }
           
            activatePitchMode() {
                this.updateAIState('PITCHING', 'finding new harmonies...');
               
                // Pitch shift patterns
                for (let pattern of this.composition.patterns) {
                    if (pattern) {
                        pattern.forEach(step => {
                            if (step) {
                                step.pitch = 0.8 + Math.random() * 0.8;
                            }
                        });
                    }
                }
            }
           
            activateReverseMode() {
                this.updateAIState('REVERSING', 'flipping reality...');
               
                // Reverse random chops
                if (this.composition.layers.length > 0) {
                    const layer = this.composition.layers[this.composition.layers.length - 1];
                    layer.chops.forEach(chop => {
                        if (Math.random() < 0.5) {
                            this.reverse(chop.buffer);
                        }
                    });
                }
            }
           
            activateStretchMode() {
                this.updateAIState('STRETCHING', 'bending time...');
               
                // Time stretch variation
                const newBPM = this.composition.bpm * (0.8 + Math.random() * 0.4);
                this.composition.bpm = Math.round(newBPM);
                this.ui.bpmDisplay.textContent = this.composition.bpm;
            }
           
            startCreativeEngine() {
                // Main creative loop
                setInterval(() => {
                    // Update debug
                    this.ui.debug.innerHTML = `
                        State: ${this.consciousness.state}<br>
                        Creativity: ${Math.round(this.consciousness.creativity * 100)}%<br>
                        Confidence: ${Math.round(this.consciousness.confidence * 100)}%<br>
                        Layers: ${this.composition.layers.length}
                    `;
                }, 1000);
            }
           
            analyzeCreativeContent() {
                // Real-time analysis during capture
                const recent = new Float32Array(2048);
                const start = (this.writePos - 2048 + this.circularBuffer.length) % this.circularBuffer.length;
               
                for (let i = 0; i < 2048; i++) {
                    recent[i] = this.circularBuffer[(start + i) % this.circularBuffer.length];
                }
               
                // Calculate current energy
                let energy = 0;
                for (let i = 0; i < recent.length; i++) {
                    energy += recent[i] * recent[i];
                }
                energy = Math.sqrt(energy / recent.length);
               
                // Adaptive capture - extend if interesting
                if (energy > 0.3 && this.captureLength < this.maxCaptureLength) {
                    this.captureLength += 0.5;
                    this.updateAIState('EXTENDING', 'this is gold...');
                }
            }
        }
       
        // Initialize Creative AI Producer
        const producer = new CreativeAIProducer();
    </script>
</body>
</html>
