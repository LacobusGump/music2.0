<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
    }
    
    body.expansion {
      animation: pooooffffff 3s ease-out forwards;
    }
    @keyframes pooooffffff {
      0% { background: black; transform: scale(0.01); }
      30% { background: radial-gradient(circle, white 0%, #ff6b6b 30%, #00ffaa 60%, black 100%); transform: scale(2); }
      100% { background: black; transform: scale(1); }
    }
    
    .start-btn {
      padding: 20px 40px;
      background: radial-gradient(circle, white, transparent);
      color: transparent;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 20px white;
      animation: dotPulse 2s ease-in-out infinite;
    }
    
    @keyframes dotPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
    
    .orb {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, white, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.25s ease;
      box-shadow: 0 0 40px white;
      will-change: transform;
    }
    
    .orb.expand {
      background: radial-gradient(circle, #ff88cc, #00ffaa, transparent);
      box-shadow: 0 0 80px #ff88cc;
      animation: heavenPulse 2s ease-in-out infinite;
    }
    
    .orb.pulse {
      animation: beatPulse 0.4s ease-in-out;
    }
    
    @keyframes heavenPulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.15); } }
    @keyframes beatPulse { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.4); } 100% { transform: translate(-50%, -50%) scale(1); } }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: white;
      border-radius: 50%;
      animation: float 4s infinite ease-in-out;
    }
    
    @keyframes float {
      0% { transform: translateY(100vh) scale(0); opacity: 0; }
      50% { opacity: 1; }
      100% { transform: translateY(-10vh) scale(1); opacity: 0; }
    }
  </style>
</head>
<body>
  <button class="start-btn" id="start"></button>
  <div class="spatial-viz hidden" id="viz">
    <div class="orb" id="orb"></div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 120;
        this.swing = 0.1;
        this.pos = { x: 50, y: 50 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.state = 'EMERGING';
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.reverb = null;
        this.songSection = 'INTRO';
        this.layerProgress = 0;
        this.lastStrideTime = 0;
        this.strideInterval = 500;
        this.envDensity = 0.5;
        this.oscillators = new Set();
        this.lastUpdateTime = 0;
        this.frameCount = 0;
        this.moodFactor = 0.7;
        this.seed = 0;
        this.currentChord = 0;
        
        this.scales = {
          major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
          minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25],
          pentatonic: [261.63, 311.13, 349.23, 415.30, 466.16],
          dorian: [261.63, 293.66, 311.13, 349.23, 392.00, 440.00, 466.16, 523.25]
        };
        this.scale = this.scales.pentatonic;
        this.chords = [];
        this.patterns = { kick: [], snare: [], hihat: [], bass: [], perc: [] };
        
        this.elements = {};
        this.rolloutBuffer = [];
        this.lastReflectionTime = 0;
        this.reflectionInterval = 15000;
        this.gravity = { x: 0, y: 0 };
        
        this.init();
      }

      init() {
        const ids = ['start', 'viz', 'orb'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.start.onclick = () => this.start();
        this.generateSongSeed();
      }

      generateSongSeed() {
        const now = new Date();
        this.seed = now.getTime() + Math.random() * 1000;
        
        const hours = now.getHours();
        this.moodFactor = hours < 6 || hours > 20 ? 0.4 : hours < 12 ? 0.9 : 1.2;
        
        this.swing = 0.05 + Math.random() * 0.2 * this.moodFactor;
        
        const scaleChoice = Math.floor(this.seed + this.moodFactor * 15) % 4;
        this.scale = scaleChoice === 0 ? this.scales.major : 
                     scaleChoice === 1 ? this.scales.minor : 
                     scaleChoice === 2 ? this.scales.pentatonic : this.scales.dorian;
        
        this.chords = this.generateChords();
        this.patterns = this.generatePatterns();
        
        this.bpm = 90 + (this.moodFactor * 60) + (this.seed % 35);
      }

      generateChords() {
        const chords = [];
        const chordCount = 4 + Math.floor((this.seed + this.moodFactor * 15) % 6);
        for (let i = 0; i < chordCount; i++) {
          const root = Math.floor((this.seed + i * 23 + this.moodFactor * 7) % this.scale.length);
          const chord = [
            root,
            (root + 2) % this.scale.length,
            (root + 4) % this.scale.length,
            (root + 6) % this.scale.length
          ];
          chords.push(chord);
        }
        return chords;
      }

      generatePatterns() {
        const length = 16;
        const patterns = { kick: [], snare: [], hihat: [], bass: [], perc: [] };
        
        let kickDensity = this.moodFactor * 0.65 + this.envDensity * 0.45;
        let snareDensity = this.moodFactor * 0.55 + this.envDensity * 0.35;
        let hihatDensity = this.moodFactor * 0.75 + this.envDensity * 0.55;
        let bassDensity = this.moodFactor * 0.65 + this.envDensity * 0.45;
        let percDensity = this.moodFactor * 0.55 + this.envDensity * 0.35;
        
        for (let i = 0; i < length; i++) {
          const swingOffset = (i % 2 === 1) ? this.swing : 0;
          patterns.kick.push(Math.random() < kickDensity * (1 + swingOffset) ? 1 : 0);
          patterns.snare.push(Math.random() < snareDensity * (1 + swingOffset) ? 1 : 0);
          patterns.hihat.push(Math.random() < hihatDensity * (1 + swingOffset) ? 1 : 0);
          patterns.bass.push(Math.random() < bassDensity * (1 + swingOffset) ? 1 : 0);
          patterns.perc.push(Math.random() < percDensity * (1 + swingOffset) ? 1 : 0);
          
          if (i % 4 === 0) patterns.kick[i] = 1;
          if (i % 8 === 4) patterns.snare[i] = 1;
          if (i % 2 === 0) patterns.hihat[i] = Math.random() < hihatDensity * 1.4 ? 1 : 0;
        }
        
        return patterns;
      }

      async start() {
        try {
          // Request device motion permission for iOS
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') {
              alert('Motion permission required for this experience');
              return;
            }
          }

          // Create audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();

          // Start expansion animation
          document.body.classList.add('expansion');
          setTimeout(() => {
            document.body.classList.remove('expansion');
            this.elements.viz.classList.remove('hidden');
          }, 3000);

          this.elements.start.classList.add('hidden');
          
          this.active = true;
          this.lastMotionTime = Date.now();
          this.startSensors();
          this.startGroove();
          this.animate();
          this.monitorTranscendence();
        } catch (e) {
          console.error('Failed to start:', e);
          alert('Failed to start audio context. Try clicking again.');
        }
      }

      startSensors() {
        let lastSensorTime = 0;
        const sensorThrottle = 50;
        const motionSmoothing = 8;
        let motionBuffer = [];
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - lastSensorTime < sensorThrottle) return;
          lastSensorTime = now;

          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);

          const rawMotion = Math.min(100, Math.sqrt(dx * dx + dy * dy + dz * dz) * 10);
          motionBuffer.push(rawMotion);
          if (motionBuffer.length > motionSmoothing) motionBuffer.shift();
          this.motion = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length;

          this.last = { x: acc.x, y: acc.y, z: acc.z };

          if (this.motion > 3) {
            this.lastMotionTime = now;
          }

          if (this.motion > 3 && now - this.lastStrideTime > this.strideInterval) {
            this.lastStrideTime = now;
            this.updateSongProgress();
          }

          // Update orb position with gravity
          this.gravity.x += (acc.x * 0.02);
          this.gravity.y += (acc.y * 0.02);
          this.pos.x += this.gravity.x;
          this.pos.y += this.gravity.y;
          this.pos.x = Math.max(5, Math.min(95, this.pos.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y));
          this.gravity.x *= 0.95;
          this.gravity.y *= 0.95;

          this.updateState();
        }, { passive: true });

        // Fallback for desktop - use mouse movement
        let lastMouseTime = 0;
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - lastMouseTime < 100) return;
          lastMouseTime = now;
          
          this.motion = 5; // Simulate some motion
          this.lastMotionTime = now;
          
          this.pos.x = (e.clientX / window.innerWidth) * 100;
          this.pos.y = (e.clientY / window.innerHeight) * 100;
        });
      }

      monitorTranscendence() {
        const check = () => {
          if (!this.active) return;
          
          const now = Date.now();
          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 800;

          if (shouldTranscend && !this.transcendent) {
            this.enterTranscendence();
          } else if (!shouldTranscend && this.transcendent) {
            this.exitTranscendence();
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 800) / 1500);
            this.deepenVoid();
          }

          setTimeout(check, 100);
        };
        check();
      }

      enterTranscendence() {
        this.transcendent = true;
        this.state = 'VOID';
        
        this.elements.orb.classList.add('expand');
        this.createParticles();
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.state = 'EMERGING';
        
        this.elements.orb.classList.remove('expand');
        this.clearParticles();
        this.cleanupOscillators();
      }

      createParticles() {
        const container = document.getElementById('particles') || document.createElement('div');
        container.id = 'particles';
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 4 + 's';
          container.appendChild(particle);
        }
      }

      clearParticles() {
        const container = document.getElementById('particles');
        if (container) {
          container.remove();
        }
      }

      createReverb() {
        if (!this.ctx) return;
        this.reverb = this.ctx.createConvolver();
        const reverbTime = 3;
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
          }
        }
        
        this.reverb.buffer = buffer;
        this.reverb.connect(this.ctx.destination);
      }

      deepenVoid() {
        const intensity = this.transcendentIntensity;
        if (intensity > 0.2 && Math.random() < 0.02) this.voidBell();
        if (intensity > 0.3) this.transcendentPad();
      }

      voidBell() {
        if (this.oscillators.size >= 10) return;
        const freq = [174, 207, 261, 311, 349][Math.floor(Math.random() * 5)];
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1 * this.transcendentIntensity, this.ctx.currentTime + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 4);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 4000);
      }

      transcendentPad() {
        if (this.oscillators.size >= 10) return;
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        const noteIndex = this.chords[this.currentChord][Math.floor(Math.random() * 3)];
        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.value = this.scale[noteIndex] * 0.5;
        osc2.frequency.value = this.scale[noteIndex] * 0.5 * 1.01;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity, this.ctx.currentTime + 1);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 5);
        
        osc1.connect(gain);
        osc2.connect(gain);
        gain.connect(this.reverb);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 5);
        osc2.stop(this.ctx.currentTime + 5);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => {
          this.oscillators.delete(osc1);
          this.oscillators.delete(osc2);
        }, 5000);
      }

      updateSongProgress() {
        const progressIncrement = 0.2;
        this.layerProgress = Math.min(8, this.layerProgress + progressIncrement);
        
        if (this.songSection === 'INTRO' && this.layerProgress >= 1) this.songSection = 'BUILD';
        else if (this.songSection === 'BUILD' && this.layerProgress >= 3) this.songSection = 'CLIMAX';
        else if (this.songSection === 'CLIMAX' && this.layerProgress >= 5) this.songSection = 'RESOLUTION';
        
        this.elements.orb.classList.add('expand');
      }

      updateState() {
        if (this.transcendent) {
          this.state = 'HEAVEN';
          this.bpm = Math.round(60 + (this.transcendentIntensity * 30));
          return;
        }

        const targetBPM = 90 + this.motion * 2 + this.envDensity * 20;
        this.bpm = Math.round(this.bpm * 0.9 + targetBPM * 0.1);
        
        if (this.songSection === 'INTRO') this.state = 'PRIMAL';
        else if (this.songSection === 'BUILD') this.state = 'ORCHESTRAL';
        else if (this.songSection === 'CLIMAX') this.state = 'OFF';
        else this.state = 'SYNTH';
      }

      startGroove() {
        const tick = () => {
          if (!this.active) return;

          const swingFactor = (this.step % 2 === 1) ? 1 + this.swing : 1;
          const interval = Math.max(80, (60000 / this.bpm / 4) * swingFactor);

          if (this.transcendent) {
            if (this.step % 8 === 0) this.etherealKick();
          } else {
            if (this.patterns.kick[this.step % 16] && this.layerProgress >= 0.5) this.kick808();
            if (this.patterns.snare[this.step % 16] && this.layerProgress >= 1) this.snareLayered();
            if (this.patterns.hihat[this.step % 16] && this.layerProgress >= 1.5) this.hihatMetallic();
          }

          this.step = (this.step + 1) % 16;
          if (this.step === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
          }

          setTimeout(tick, interval);
        };
        tick();
      }

      kick808() {
        if (this.oscillators.size >= 10) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.3);
        
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        osc.connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 300);
      }

      snareLayered() {
        if (this.oscillators.size >= 10) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'triangle';
        osc.frequency.value = 200;
        filter.type = 'bandpass';
        filter.frequency.value = 400 + this.motion * 5;
        filter.Q.value = 3;
        
        gain.gain.setValueAtTime(0.6, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
        
        osc.connect(filter).connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.15);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 150);
      }

      hihatMetallic() {
        if (this.oscillators.size >= 10) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'square';
        osc.frequency.value = 8000 + Math.random() * 2000;
        filter.type = 'highpass';
        filter.frequency.value = 6000;
        
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        osc.connect(filter).connect(gain).connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 100);
      }

      etherealKick() {
        if (this.oscillators.size >= 10) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(40, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(15, this.ctx.currentTime + 0.5);
        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 500);
      }

      cleanupOscillators() {
        this.oscillators.forEach(osc => {
          try {
            osc.stop();
          } catch (e) {}
        });
        this.oscillators.clear();
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - this.lastUpdateTime < 50) {
            requestAnimationFrame(loop);
            return;
          }
          this.lastUpdateTime = now;
          this.frameCount++;

          this.elements.orb.style.left = `${this.pos.x}%`;
          this.elements.orb.style.top = `${this.pos.y}%`;
          
          if (this.frameCount % Math.floor(60000 / this.bpm / 4 / 50) === 0) {
            this.elements.orb.classList.add('pulse');
            setTimeout(() => this.elements.orb.classList.remove('pulse'), 400);
          }

          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    const gump = new GUMP();
  </script>
</body>
</html>
