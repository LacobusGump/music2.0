<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Massive Sonic Evolution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
      font-family: 'Courier New', monospace;
    }
    
    body.expansion {
      animation: cosmicBirth 5s ease-out forwards;
    }
    @keyframes cosmicBirth {
      0% { background: black; transform: scale(0.0001); filter: brightness(0); }
      15% { background: radial-gradient(circle, white 0%, #ff3838 10%, #ff6b6b 25%, #4ecdc4 45%, #45b7d1 65%, black 100%); transform: scale(0.05); filter: brightness(3); }
      35% { background: radial-gradient(circle, #fff 0%, #ff9f43 8%, #ee5a24 18%, #0984e3 28%, #6c5ce7 38%, #fd79a8 48%, black 100%); transform: scale(1.5); filter: brightness(2); }
      65% { background: radial-gradient(circle, #a29bfe 0%, #6c5ce7 15%, #fd79a8 30%, #fdcb6e 45%, black 100%); transform: scale(4); filter: brightness(1.5); }
      100% { background: black; transform: scale(1); filter: brightness(1); }
    }
    
    .start-btn {
      padding: 40px 80px;
      background: radial-gradient(circle, white 0%, rgba(255,255,255,0.4) 40%, rgba(108,92,231,0.3) 70%, transparent 100%);
      color: white;
      border: 3px solid rgba(255,255,255,0.6);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 40px white, 0 0 80px rgba(108,92,231,0.5), inset 0 0 30px rgba(255,255,255,0.3);
      animation: massivePulse 4s ease-in-out infinite;
      font-size: 16px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 3px;
      backdrop-filter: blur(10px);
    }
    
    @keyframes massivePulse { 
      0%, 100% { transform: scale(1); box-shadow: 0 0 40px white, 0 0 80px rgba(108,92,231,0.5); } 
      50% { transform: scale(1.4); box-shadow: 0 0 100px #ff6b6b, 0 0 200px #4ecdc4, 0 0 300px rgba(108,92,231,0.8); } 
    }
    
    .orb {
      position: absolute;
      width: 6px; height: 6px;
      border-radius: 50%;
      background: radial-gradient(circle, white, transparent);
      top: 50%; left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
      box-shadow: 0 0 15px white;
      will-change: transform;
    }
    
    .orb.tribal { 
      background: radial-gradient(circle, #ff6b6b 0%, #ff9f43 50%, transparent);
      box-shadow: 0 0 30px #ff6b6b, 0 0 60px rgba(255,107,107,0.5);
      width: 10px; height: 10px;
    }
    
    .orb.orchestral { 
      background: radial-gradient(circle, #4ecdc4 0%, #45b7d1 30%, #74b9ff 60%, transparent);
      box-shadow: 0 0 50px #4ecdc4, 0 0 100px rgba(78,205,196,0.6), 0 0 150px rgba(69,183,209,0.4);
      width: 14px; height: 14px;
    }
    
    .orb.heaven { 
      background: radial-gradient(circle, #6c5ce7 0%, #a29bfe 25%, #fd79a8 50%, #fdcb6e 75%, transparent);
      box-shadow: 0 0 80px #6c5ce7, 0 0 160px #fd79a8, 0 0 240px rgba(108,92,231,0.7), 0 0 320px rgba(253,121,168,0.5);
      width: 20px; height: 20px;
      animation: cosmicPulse 1.5s ease-in-out infinite;
    }
    
    .orb.pulse { animation: massiveBeatPulse 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94); }
    
    @keyframes cosmicPulse { 
      0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); } 
      50% { transform: translate(-50%, -50%) scale(1.6) rotate(180deg); } 
    }
    @keyframes massiveBeatPulse { 
      0% { transform: translate(-50%, -50%) scale(1); } 
      40% { transform: translate(-50%, -50%) scale(2.2); } 
      100% { transform: translate(-50%, -50%) scale(1); } 
    }
    
    .message {
      position: absolute;
      top: 25%; left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      opacity: 0;
      transition: all 1.5s ease;
      text-shadow: 0 0 20px rgba(255,255,255,0.9), 0 0 40px rgba(108,92,231,0.6);
      letter-spacing: 2px;
    }
    
    .message.show { opacity: 1; transform: translateX(-50%) scale(1.1); }
    .hidden { display: none !important; }
    
    .progress-indicator {
      position: absolute;
      bottom: 40px; left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.8);
      font-size: 14px;
      text-align: center;
      backdrop-filter: blur(5px);
      padding: 10px 20px;
      border-radius: 10px;
      background: rgba(0,0,0,0.3);
    }
    
    .evolution-stage {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 16px;
    }
    
    .layer-indicator {
      position: absolute;
      left: 20px; top: 50%;
      transform: translateY(-50%);
      color: rgba(255,255,255,0.7);
      font-size: 12px;
    }
    
    .layer {
      margin: 5px 0;
      padding: 3px 8px;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      opacity: 0.3;
      transition: all 0.3s ease;
    }
    
    .layer.active {
      opacity: 1;
      background: rgba(108,92,231,0.3);
      box-shadow: 0 0 10px rgba(108,92,231,0.5);
    }
  </style>
</head>
<body>
  <button class="start-btn" id="start">IGNITE<br/>SONIC<br/>EVOLUTION</button>
  
  <div class="spatial-viz hidden" id="viz">
    <div class="orb" id="orb"></div>
    <div class="message" id="message">NOW MOVE<br/>CREATE SOUND</div>
    
    <div class="progress-indicator" id="progress">
      <div class="evolution-stage" id="stage">PRIMORDIAL SILENCE</div>
      <div id="substage">Sensors calibrating...</div>
    </div>
    
    <div class="layer-indicator" id="layers">
      <div class="layer" id="layer808">808 Sub Bass</div>
      <div class="layer" id="layerKick">Massive Kick</div>
      <div class="layer" id="layerSines">Sine Harmonics</div>
      <div class="layer" id="layerFifths">Circle of 5ths</div>
      <div class="layer" id="layerSevenths">7th Extensions</div>
      <div class="layer" id="layerStrings">Orchestral Strings</div>
      <div class="layer" id="layerBrass">Epic Brass</div>
      <div class="layer" id="layerChoir">Cosmic Choir</div>
      <div class="layer" id="layerPads">Heaven Pads</div>
    </div>
  </div>

  <script>
    class MassiveGUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 45;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        
        // Audio chain
        this.masterGain = null;
        this.reverb = null;
        this.compressor = null;
        
        // Evolution
        this.evolutionStage = 'PRIMORDIAL';
        this.totalSteps = 0;
        this.firstMovement = false;
        
        // Musical theory
        this.circleOfFifths = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5];
        this.currentFifthPosition = 0;
        this.noteFreqs = {
          0: 65.41, 1: 69.30, 2: 73.42, 3: 77.78, 4: 82.41, 5: 87.31,
          6: 92.50, 7: 98.00, 8: 103.83, 9: 110.00, 10: 116.54, 11: 123.47
        };
        
        this.oscillators = new Set();
        this.layerGains = {};
        this.layerStates = {
          sub808: false, massiveKick: false, sineHarmonics: false,
          circleOfFifths: false, seventhExtensions: false, orchestralStrings: false,
          epicBrass: false, cosmicChoir: false, heavenPads: false
        };
        
        this.elements = {};
        this.motionHistory = [];
        this.init();
      }

      init() {
        ['start', 'viz', 'orb', 'message', 'progress', 'stage', 'substage', 'layers'].forEach(id => 
          this.elements[id] = document.getElementById(id));
        this.elements.start.onclick = () => this.start();
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') return alert('Motion permission required');
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudio();

          document.body.classList.add('expansion');
          
          setTimeout(() => {
            document.body.classList.remove('expansion');
            this.elements.start.classList.add('hidden');
            this.elements.viz.classList.remove('hidden');
            
            setTimeout(() => {
              this.elements.message.classList.add('show');
              setTimeout(() => this.elements.message.classList.remove('show'), 4000);
            }, 1000);
            
            this.active = true;
            this.lastMotionTime = Date.now();
            this.startSensors();
            this.startEngine();
            this.animate();
            this.monitorTranscendence();
          }, 5000);
          
        } catch (e) {
          console.error('Failed to start:', e);
          alert('Failed to start. Try again.');
        }
      }

      setupAudio() {
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8;
        this.masterGain.connect(this.ctx.destination);
        
        this.reverb = this.ctx.createConvolver();
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * 4, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 1.2);
          }
        }
        this.reverb.buffer = buffer;
        this.reverb.connect(this.masterGain);
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -20;
        this.compressor.ratio.value = 12;
        this.compressor.connect(this.masterGain);
        
        Object.keys(this.layerStates).forEach(layer => {
          this.layerGains[layer] = this.ctx.createGain();
          this.layerGains[layer].gain.value = 0;
          this.layerGains[layer].connect(this.compressor);
        });
      }

      startSensors() {
        let motionBuffer = [];
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);
          
          const rawMotion = Math.sqrt(dx * dx + dy * dy + dz * dz);
          motionBuffer.push(rawMotion);
          if (motionBuffer.length > 10) motionBuffer.shift();
          
          this.motion = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length;
          this.motionHistory.push(this.motion);
          if (this.motionHistory.length > 50) this.motionHistory.shift();

          if (!this.firstMovement && this.motion > 1.5) {
            this.firstMovement = true;
            this.evolveToTribal();
          }

          if (this.motion > 1.5) {
            this.lastMotionTime = Date.now();
            this.totalSteps++;
          }

          this.velocity.x += acc.x * 0.01;
          this.velocity.y += acc.y * 0.01;
          this.pos.x += this.velocity.x;
          this.pos.y += this.velocity.y;
          
          if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
          if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
          
          this.pos.x = Math.max(5, Math.min(95, this.pos.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y));
          
          this.velocity.x *= 0.95;
          this.velocity.y *= 0.95;

          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.updateEvolution();
        }, { passive: true });

        // Desktop fallback
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          this.motion = Math.abs(newX - this.pos.x) + Math.abs(newY - this.pos.y);
          this.pos.x = newX;
          this.pos.y = newY;
          
          if (!this.firstMovement && this.motion > 2) {
            this.firstMovement = true;
            this.evolveToTribal();
          }
          
          if (this.motion > 2) {
            this.lastMotionTime = Date.now();
            this.totalSteps++;
          }
          
          this.updateEvolution();
        });
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.length > 0 ? 
          this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length : 0;
        
        this.updateLayers();
        
        if (this.evolutionStage === 'TRIBAL' && this.totalSteps > 20 && avgMotion > 2) {
          this.evolveToOrchestral();
        } else if (this.evolutionStage === 'ORCHESTRAL' && this.totalSteps > 60 && avgMotion > 3) {
          this.evolveToHeaven();
        }
        
        let targetBPM = 45;
        switch(this.evolutionStage) {
          case 'TRIBAL': targetBPM = 80 + avgMotion * 10; break;
          case 'ORCHESTRAL': targetBPM = 110 + avgMotion * 8; break;
          case 'HEAVEN': targetBPM = 140 + avgMotion * 6; break;
        }
        
        this.bpm = this.bpm * 0.9 + targetBPM * 0.1;
        this.updateUI();
      }

      updateLayers() {
        this.layerStates.sub808 = this.motion > 1;
        this.layerStates.massiveKick = this.evolutionStage !== 'PRIMORDIAL' && this.motion > 1.5;
        this.layerStates.sineHarmonics = this.totalSteps > 10 && this.motion > 2;
        this.layerStates.circleOfFifths = this.evolutionStage === 'ORCHESTRAL' || this.evolutionStage === 'HEAVEN';
        this.layerStates.seventhExtensions = this.evolutionStage === 'HEAVEN' && this.motion > 3;
        this.layerStates.orchestralStrings = this.evolutionStage === 'ORCHESTRAL' && this.totalSteps > 30;
        this.layerStates.epicBrass = this.motion > 4 && (this.evolutionStage === 'ORCHESTRAL' || this.evolutionStage === 'HEAVEN');
        this.layerStates.cosmicChoir = this.evolutionStage === 'HEAVEN';
        this.layerStates.heavenPads = this.transcendent || (this.evolutionStage === 'HEAVEN' && this.motion < 2);
        
        const elementMap = {
          'sub808': 'layer808', 'massiveKick': 'layerKick', 'sineHarmonics': 'layerSines',
          'circleOfFifths': 'layerFifths', 'seventhExtensions': 'layerSevenths', 'orchestralStrings': 'layerStrings',
          'epicBrass': 'layerBrass', 'cosmicChoir': 'layerChoir', 'heavenPads': 'layerPads'
        };
        
        Object.keys(this.layerStates).forEach(layer => {
          const isActive = this.layerStates[layer];
          const element = document.getElementById(elementMap[layer]);
          
          if (element) {
            element.classList.toggle('active', isActive);
          }
          
          if (this.layerGains[layer]) {
            const targetGain = isActive ? 0.3 + (this.motion / 20) : 0;
            this.layerGains[layer].gain.linearRampToValueAtTime(targetGain, this.ctx.currentTime + 0.1);
          }
        });
      }

      evolveToTribal() {
        this.evolutionStage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.elements.stage.textContent = 'TRIBAL AWAKENING';
        this.elements.substage.textContent = 'Primal rhythms emerging...';
      }

      evolveToOrchestral() {
        this.evolutionStage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.elements.stage.textContent = 'ORCHESTRAL SYNTHESIS';
        this.elements.substage.textContent = 'Complex harmonies building...';
      }

      evolveToHeaven() {
        this.evolutionStage = 'HEAVEN';
        this.elements.orb.className = 'orb heaven';
        this.elements.stage.textContent = 'COSMIC TRANSCENDENCE';
        this.elements.substage.textContent = 'Massive synthesis achieved...';
      }

      startEngine() {
        const tick = () => {
          if (!this.active) return;

          const interval = 60000 / this.bpm / 4;
          this.playLayers();
          this.step = (this.step + 1) % 16;
          
          if (this.step % 4 === 0) {
            this.currentFifthPosition = (this.currentFifthPosition + 1) % this.circleOfFifths.length;
          }

          setTimeout(tick, interval);
        };
        tick();
      }

      playLayers() {
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 200);
        }

        if (this.layerStates.sub808) this.play808();
        if (this.layerStates.massiveKick && this.step % 4 === 0) this.playKick();
        if (this.layerStates.sineHarmonics) this.playHarmonics();
        if (this.layerStates.circleOfFifths && this.step % 2 === 0) this.playFifths();
        if (this.layerStates.seventhExtensions && this.step % 8 === 0) this.playSevenths();
        if (this.layerStates.orchestralStrings && this.step % 8 === 0) this.playStrings();
        if (this.layerStates.epicBrass && this.step % 6 === 0) this.playBrass();
        if (this.layerStates.cosmicChoir && this.step % 12 === 0) this.playChoir();
        if (this.layerStates.heavenPads) this.playPads();
      }

      play808() {
        if (this.oscillators.size > 30) return;
        
        const freq = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 0.5;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.7, this.ctx.currentTime + 0.6);
        
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        osc.connect(gain).connect(this.layerGains.sub808);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.8);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 800);
      }

      playKick() {
        if (this.oscillators.size > 30) return;
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc1.type = 'sine';
        osc2.type = 'triangle';
        osc1.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc2.frequency.setValueAtTime(80, this.ctx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.3);
        osc2.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.2);
        
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        
        osc1.connect(gain);
        osc2.connect(gain);
        gain.connect(this.layerGains.massiveKick);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 0.3);
        osc2.stop(this.ctx.currentTime + 0.2);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => {
          this.oscillators.delete(osc1);
          this.oscillators.delete(osc2);
        }, 400);
      }

      playHarmonics() {
        if (this.oscillators.size > 30) return;
        
        const fundamental = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 2;
        [1, 2, 3, 5].forEach(harmonic => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = fundamental * harmonic;
          
          gain.gain.setValueAtTime(0.2 / harmonic, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
          
          osc.connect(gain).connect(this.layerGains.sineHarmonics);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1500);
        });
      }

      playFifths() {
        if (this.oscillators.size > 30) return;
        
        const note1 = this.circleOfFifths[this.currentFifthPosition];
        const note2 = this.circleOfFifths[(this.currentFifthPosition + 1) % this.circleOfFifths.length];
        
        [note1, note2].forEach((note, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = this.noteFreqs[note] * (2 + i);
          
          filter.type = 'lowpass';
          filter.frequency.value = 800 + this.motion * 50;
          filter.Q.value = 3;
          
          gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.circleOfFifths);
          osc.start();
          osc.stop(this.ctx.currentTime + 1);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1000);
        });
      }

      playSevenths() {
        if (this.oscillators.size > 30) return;
        
        const root = this.circleOfFifths[this.currentFifthPosition];
        const seventh = (root + 10) % 12; // minor 7th
        
        [root, (root + 4) % 12, (root + 7) % 12, seventh].forEach(note => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'triangle';
          osc.frequency.value = this.noteFreqs[note] * 4;
          
          gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(gain).connect(this.layerGains.seventhExtensions);
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 2000);
        });
      }

      playStrings() {
        if (this.oscillators.size > 30) return;
        
        const root = this.circleOfFifths[this.currentFifthPosition];
        [root, (root + 4) % 12, (root + 7) % 12].forEach(note => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = this.noteFreqs[note] * 2;
          
          filter.type = 'lowpass';
          filter.frequency.value = 1000 + this.motion * 100;
          filter.Q.value = 2;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.2);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.orchestralStrings);
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 2000);
        });
      }

      playBrass() {
        if (this.oscillators.size > 30) return;
        
        const root = this.circleOfFifths[this.currentFifthPosition];
        [root, (root + 4) % 12, (root + 7) % 12, (root + 11) % 12].forEach(note => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'square';
          osc.frequency.value = this.noteFreqs[note] * 3;
          
          filter.type = 'bandpass';
          filter.frequency.value = 800 + this.motion * 150;
          filter.Q.value = 5;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.3);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.epicBrass);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1500);
        });
      }

      playChoir() {
        if (this.oscillators.size > 30) return;
        
        const root = this.circleOfFifths[this.currentFifthPosition];
        const voicings = [
          [root, (root + 4) % 12, (root + 7) % 12],
          [(root + 2) % 12, (root + 5) % 12, (root + 9) % 12],
          [(root + 7) % 12, (root + 11) % 12, (root + 2) % 12]
        ];
        
        voicings.forEach((voicing, voiceIndex) => {
          voicing.forEach(note => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            osc.type = 'sine';
            osc.frequency.value = this.noteFreqs[note] * (4 + voiceIndex * 0.5);
            
            filter.type = 'highpass';
            filter.frequency.value = 200 + this.transcendentIntensity * 300;
            filter.Q.value = 1;
            
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.5);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
            
            osc.connect(filter).connect(gain).connect(this.layerGains.cosmicChoir);
            osc.start();
            osc.stop(this.ctx.currentTime + 3);
            
            this.oscillators.add(osc);
            setTimeout(() => this.oscillators.delete(osc), 3000);
          });
        });
      }

      playPads() {
        if (this.oscillators.size > 30) return;
        
        const root = this.circleOfFifths[this.currentFifthPosition];
        [root, (root + 4) % 12, (root + 7) % 12, (root + 11) % 12].forEach(note => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sine';
          osc.frequency.value = this.noteFreqs[note] * 0.5;
          
          filter.type = 'lowpass';
          filter.frequency.value = 300 + this.transcendentIntensity * 200;
          filter.Q.value = 5;
          
          gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.heavenPads);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 4000);
        });
      }

      monitorTranscendence() {
        const check = () => {
          if (!this.active) return;
          
          const now = Date.now();
          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 1500;

          if (shouldTranscend && !this.transcendent) {
            this.enterTranscendence();
          } else if (!shouldTranscend && this.transcendent) {
            this.exitTranscendence();
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 1500) / 2000);
          }

          setTimeout(check, 100);
        };
        check();
      }

      enterTranscendence() {
        this.transcendent = true;
        this.elements.substage.textContent = 'Entering transcendent void...';
        document.body.style.background = 'radial-gradient(circle, #0a0a0a 0%, #000 100%)';
        this.bpm *= 0.7;
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        document.body.style.background = 'black';
        this.updateUI();
      }

      updateUI() {
        let stageText = this.evolutionStage;
        let substageText = '';
        
        switch(this.evolutionStage) {
          case 'PRIMORDIAL':
            substageText = 'Waiting for movement to spark creation...';
            break;
          case 'TRIBAL':
            substageText = `Motion: ${'●'.repeat(Math.min(Math.floor(this.motion), 5))} • BPM: ${Math.round(this.bpm)} • Steps: ${this.totalSteps}`;
            break;
          case 'ORCHESTRAL':
            substageText = `Harmonics Active • BPM: ${Math.round(this.bpm)} • Layers: ${Object.values(this.layerStates).filter(Boolean).length}/9`;
            break;
          case 'HEAVEN':
            substageText = `Cosmic Synthesis • ${Object.values(this.layerStates).filter(Boolean).length}/9 Layers Active`;
            break;
        }
        
        if (this.transcendent) {
          substageText += ` • VOID STATE (${Math.round(this.transcendentIntensity * 100)}%)`;
        }
        
        this.elements.stage.textContent = stageText;
        this.elements.substage.textContent = substageText;
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = `${this.pos.x}%`;
          this.elements.orb.style.top = `${this.pos.y}%`;
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }

      // Cleanup for performance
      cleanup() {
        this.oscillators.forEach(osc => {
          try { osc.stop(); } catch (e) {}
        });
        this.oscillators.clear();
      }
    }

    // Initialize the massive evolution
    const gump = new MassiveGUMP();
    
    // Global access for debugging
    window.gump = gump;
    
    // Performance monitoring
    setInterval(() => {
      if (gump.active && gump.oscillators.size > 40) {
        console.warn('High oscillator count:', gump.oscillators.size);
        gump.cleanup();
      }
    }, 3000);
    
    // Easter egg: Konami code for instant heaven mode
    let konamiCode = [];
    const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65];
    
    document.addEventListener('keydown', (e) => {
      konamiCode.push(e.keyCode);
      if (konamiCode.length > 10) konamiCode.shift();
      
      if (konamiCode.length === 10 && konamiCode.every((code, i) => code === konamiSequence[i])) {
        if (gump.active) {
          gump.evolveToHeaven();
          gump.totalSteps = 200;
          gump.motion = 10;
          console.log('🚀 KONAMI CODE ACTIVATED - INSTANT HEAVEN MODE!');
        }
      }
    });
  </script>
</body>
</html>
