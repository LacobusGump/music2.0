<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump - Active DJ Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
            --fib233: 144px;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
            cursor: none;
        }

        /* Custom cursor that shows sampling */
        .cursor {
            position: fixed;
            width: var(--fib34);
            height: var(--fib34);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
            transition: transform 0.1s ease;
            z-index: 9999;
        }

        .cursor.sampling {
            animation: cursorPulse 0.5s ease-out;
        }

        .cursor.mixing {
            border-color: rgba(255,140,0,0.8);
            box-shadow: 0 0 var(--fib21) rgba(255,140,0,0.4);
        }

        @keyframes cursorPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }

        /* Start */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%, 
                rgba(255,255,255,0.03) 0%, 
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }

        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }

        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }

        /* Title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }

        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }

        /* Interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }

        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* DJ Mixer Interface */
        .dj-mixer {
            position: fixed;
            bottom: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            height: 200px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--fib8);
            padding: var(--fib21);
            display: flex;
            gap: var(--fib21);
        }

        .channel {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: var(--fib8);
        }

        .eq-knob {
            width: var(--fib34);
            height: var(--fib34);
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, #333, #111);
            border: 1px solid rgba(255,255,255,0.2);
            position: relative;
        }

        .eq-knob::after {
            content: '';
            position: absolute;
            top: var(--fib5);
            left: 50%;
            transform: translateX(-50%);
            width: 2px;
            height: 40%;
            background: rgba(255,255,255,0.6);
        }

        .eq-knob.active {
            box-shadow: 0 0 var(--fib13) rgba(255,140,0,0.6);
        }

        .channel-meter {
            flex: 1;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
            opacity: 0.1;
            border-radius: var(--fib3);
            position: relative;
            overflow: hidden;
        }

        .channel-level {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: inherit;
            opacity: 0.8;
            height: 0%;
            transition: height 0.05s ease;
        }

        .crossfader {
            position: absolute;
            bottom: var(--fib13);
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: var(--fib8);
            background: rgba(255,255,255,0.1);
            border-radius: var(--fib5);
        }

        .crossfader-handle {
            position: absolute;
            top: -50%;
            width: var(--fib21);
            height: var(--fib21);
            background: radial-gradient(circle at 30% 30%, #666, #333);
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.3);
            cursor: grab;
            left: 50%;
            transform: translateX(-50%);
        }

        /* Tempo and phase display */
        .tempo-display {
            position: fixed;
            top: var(--fib34);
            right: var(--fib34);
            text-align: right;
        }

        .bpm-large {
            font-size: var(--fib55);
            font-weight: 100;
            opacity: 0.8;
            font-variant-numeric: tabular-nums;
        }

        .phase-name {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.5;
            margin-top: var(--fib8);
        }

        /* Build meter */
        .build-meter {
            position: fixed;
            top: 50%;
            right: var(--fib34);
            transform: translateY(-50%);
            width: var(--fib13);
            height: var(--fib233);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--fib8);
            overflow: hidden;
        }

        .build-sections {
            height: 100%;
            display: flex;
            flex-direction: column;
        }

        .build-section {
            flex: 1;
            border-bottom: 1px solid rgba(255,255,255,0.05);
            position: relative;
            overflow: hidden;
        }

        .build-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 0%;
            transition: height 0.3s ease;
        }

        .build-section:nth-child(1) .build-fill { background: #00ff00; }
        .build-section:nth-child(2) .build-fill { background: #ffff00; }
        .build-section:nth-child(3) .build-fill { background: #ff8c00; }
        .build-section:nth-child(4) .build-fill { background: #ff0000; }

        /* Sample slots */
        .sample-deck {
            position: fixed;
            top: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: var(--fib13);
        }

        .sample-slot {
            width: var(--fib89);
            height: var(--fib55);
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--fib5);
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        .sample-slot.loaded {
            border-color: rgba(255,140,0,0.3);
            background: rgba(255,140,0,0.05);
        }

        .sample-slot.playing {
            border-color: rgba(0,255,0,0.8);
            box-shadow: 0 0 var(--fib21) rgba(0,255,0,0.4);
        }

        .sample-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.6;
        }

        .sample-progress {
            position: absolute;
            top: 0;
            left: 0;
            width: 2px;
            height: 100%;
            background: rgba(255,255,255,0.8);
            transform: translateX(-100%);
        }

        /* FX Rack */
        .fx-rack {
            position: fixed;
            left: var(--fib34);
            top: 50%;
            transform: translateY(-50%);
            display: flex;
            flex-direction: column;
            gap: var(--fib13);
        }

        .fx-unit {
            width: var(--fib89);
            padding: var(--fib8);
            background: rgba(255,255,255,0.02);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: var(--fib5);
            text-align: center;
            font-size: var(--fib8);
            opacity: 0.5;
            transition: all 0.3s ease;
        }

        .fx-unit.active {
            opacity: 1;
            border-color: rgba(138,43,226,0.8);
            box-shadow: 0 0 var(--fib21) rgba(138,43,226,0.4);
        }

        /* Canvas */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #waveform { z-index: 1; opacity: 0.3; }
        #spectrum { z-index: 2; opacity: 0.5; }
        #particles { z-index: 3; opacity: 0.8; }

        /* Motion hints */
        .motion-hint {
            position: fixed;
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            transition: opacity 0.5s ease;
            pointer-events: none;
        }

        .motion-hint.show {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <div class="cursor" id="cursor"></div>
    
    <canvas id="waveform"></canvas>
    <canvas id="spectrum"></canvas>
    <canvas id="particles"></canvas>
    
    <div class="title">Gump by James McCandless</div>
    
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
    
    <div class="interface" id="interface">
        <!-- Tempo Display -->
        <div class="tempo-display">
            <div class="bpm-large" id="bpmDisplay">128.0</div>
            <div class="phase-name" id="phaseName">SEEKING</div>
        </div>
        
        <!-- Build Meter -->
        <div class="build-meter">
            <div class="build-sections">
                <div class="build-section"><div class="build-fill"></div></div>
                <div class="build-section"><div class="build-fill"></div></div>
                <div class="build-section"><div class="build-fill"></div></div>
                <div class="build-section"><div class="build-fill"></div></div>
            </div>
        </div>
        
        <!-- Sample Deck -->
        <div class="sample-deck" id="sampleDeck"></div>
        
        <!-- FX Rack -->
        <div class="fx-rack">
            <div class="fx-unit" id="fx-filter">FILTER</div>
            <div class="fx-unit" id="fx-delay">DELAY</div>
            <div class="fx-unit" id="fx-reverb">REVERB</div>
            <div class="fx-unit" id="fx-distortion">CRUSH</div>
        </div>
        
        <!-- DJ Mixer -->
        <div class="dj-mixer">
            <div class="channel">
                <div class="eq-knob" id="eq-high-a"></div>
                <div class="eq-knob" id="eq-mid-a"></div>
                <div class="eq-knob" id="eq-low-a"></div>
                <div class="channel-meter">
                    <div class="channel-level" id="level-a"></div>
                </div>
            </div>
            <div class="channel">
                <div class="eq-knob" id="eq-high-b"></div>
                <div class="eq-knob" id="eq-mid-b"></div>
                <div class="eq-knob" id="eq-low-b"></div>
                <div class="channel-meter">
                    <div class="channel-level" id="level-b"></div>
                </div>
            </div>
            <div class="crossfader">
                <div class="crossfader-handle" id="crossfader"></div>
            </div>
        </div>
        
        <!-- Motion hints -->
        <div class="motion-hint" id="hint">MOVE TO DISCOVER</div>
    </div>

    <script>
        // Professional DJ Engine with Natural Feel
        class GumpDJEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.masterBus = null;
                
                // DJ State
                this.dj = {
                    tempo: 128,
                    actualTempo: 128, // Fluctuates naturally
                    phase: 'seeking', // seeking, collecting, building, peak, breakdown, outro
                    energy: 0,
                    tension: 0,
                    groove: 0,
                    swing: 0.1, // Human timing variance
                    crossfadePosition: 0.5
                };
                
                // Dual deck system
                this.decks = {
                    a: this.createDeck('a'),
                    b: this.createDeck('b')
                };
                
                // Sample pool with intelligent categorization
                this.samplePool = {
                    kicks: [],
                    snares: [],
                    hats: [],
                    percussion: [],
                    bass: [],
                    leads: [],
                    pads: [],
                    fx: [],
                    vocals: [],
                    ambient: []
                };
                
                // Recording buffer (30 seconds circular)
                this.recordBuffer = {
                    data: null,
                    writePos: 0,
                    size: 0,
                    analyzer: null
                };
                
                // Motion tracking for performance
                this.motion = {
                    x: 0.5,
                    y: 0.5,
                    velocity: 0,
                    acceleration: 0,
                    pattern: [], // Motion history
                    gesture: null
                };
                
                // Mix memory - learns from gestures
                this.mixMemory = {
                    buildPatterns: [],
                    dropMoments: [],
                    favoriteTransitions: []
                };
                
                // Effects chain
                this.fx = {};
                
                // Visuals
                this.visuals = {
                    waveform: null,
                    spectrum: null,
                    particles: []
                };
                
                // UI
                this.ui = {};
                
                this.init();
            }
            
            createDeck(id) {
                return {
                    id,
                    source: null,
                    buffer: null,
                    gain: null,
                    
                    // 3-band EQ
                    eq: {
                        high: null,
                        mid: null,
                        low: null
                    },
                    
                    // DJ effects
                    filter: null,
                    filterLFO: null,
                    
                    // Playback state
                    playing: false,
                    loop: null,
                    beatGrid: [],
                    nextCuePoint: 0,
                    
                    // Mix parameters
                    volume: 0.7,
                    eqValues: { high: 0, mid: 0, low: 0 }
                };
            }
            
            init() {
                // Get UI elements
                this.ui = {
                    start: document.getElementById('start'),
                    interface: document.getElementById('interface'),
                    cursor: document.getElementById('cursor'),
                    bpmDisplay: document.getElementById('bpmDisplay'),
                    phaseName: document.getElementById('phaseName'),
                    hint: document.getElementById('hint'),
                    sampleDeck: document.getElementById('sampleDeck'),
                    crossfader: document.getElementById('crossfader')
                };
                
                // Create sample slots
                for (let i = 0; i < 8; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'sample-slot';
                    slot.dataset.index = i;
                    const canvas = document.createElement('canvas');
                    canvas.className = 'sample-waveform';
                    canvas.width = 89;
                    canvas.height = 55;
                    slot.appendChild(canvas);
                    const progress = document.createElement('div');
                    progress.className = 'sample-progress';
                    slot.appendChild(progress);
                    this.ui.sampleDeck.appendChild(slot);
                }
                
                // Canvas setup
                ['waveform', 'spectrum', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    this.visuals[id] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                });
                
                // Mouse tracking
                this.setupMotionTracking();
                
                // Start button
                this.ui.start.addEventListener('click', () => this.begin());
            }
            
            setupMotionTracking() {
                let lastTime = Date.now();
                let lastX = 0.5, lastY = 0.5;
                
                document.addEventListener('mousemove', (e) => {
                    const now = Date.now();
                    const dt = (now - lastTime) / 1000;
                    
                    // Update cursor
                    this.ui.cursor.style.left = e.clientX + 'px';
                    this.ui.cursor.style.top = e.clientY + 'px';
                    
                    // Calculate motion metrics
                    const x = e.clientX / window.innerWidth;
                    const y = e.clientY / window.innerHeight;
                    
                    const dx = x - lastX;
                    const dy = y - lastY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const newVelocity = distance / dt;
                    this.motion.acceleration = (newVelocity - this.motion.velocity) / dt;
                    this.motion.velocity = newVelocity;
                    
                    this.motion.x = x;
                    this.motion.y = y;
                    
                    // Track motion pattern
                    this.motion.pattern.push({ x, y, v: newVelocity, t: now });
                    if (this.motion.pattern.length > 50) {
                        this.motion.pattern.shift();
                    }
                    
                    // Detect gestures
                    this.detectGesture();
                    
                    lastX = x;
                    lastY = y;
                    lastTime = now;
                });
            }
            
            detectGesture() {
                if (this.motion.pattern.length < 10) return;
                
                // Analyze recent motion
                const recent = this.motion.pattern.slice(-10);
                
                // Circular motion = filter sweep
                let circular = 0;
                for (let i = 1; i < recent.length; i++) {
                    const angle = Math.atan2(
                        recent[i].y - recent[i-1].y,
                        recent[i].x - recent[i-1].x
                    );
                    circular += Math.abs(angle);
                }
                
                if (circular > Math.PI) {
                    this.motion.gesture = 'sweep';
                    this.ui.cursor.classList.add('mixing');
                }
                
                // Vertical motion = pitch/energy
                const verticalChange = Math.abs(recent[0].y - recent[9].y);
                if (verticalChange > 0.3) {
                    this.motion.gesture = recent[0].y > recent[9].y ? 'drop' : 'rise';
                }
                
                // Fast horizontal = scratch/stutter
                if (this.motion.velocity > 5 && Math.abs(recent[0].x - recent[9].x) > 0.2) {
                    this.motion.gesture = 'scratch';
                }
            }
            
            async begin() {
                this.ui.start.style.display = 'none';
                
                try {
                    // Create audio context with low latency
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });
                    
                    // Get mic input
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    await this.setupAudioEngine(stream);
                    
                    // Show interface
                    this.ui.interface.classList.add('active');
                    this.showHint('MOVE TO DISCOVER SOUNDS');
                    
                    // Start the performance
                    this.startPerformance();
                    
                } catch (err) {
                    console.error('Setup failed:', err);
                    alert('Microphone access required for the experience.');
                }
            }
            
            async setupAudioEngine(stream) {
                // Input processing
                const input = this.ctx.createMediaStreamSource(stream);
                
                // Analysis chain
                this.recordBuffer.analyzer = this.ctx.createAnalyser();
                this.recordBuffer.analyzer.fftSize = 2048;
                this.recordBuffer.analyzer.smoothingTimeConstant = 0.7;
                
                // Recording buffer (30 seconds)
                this.recordBuffer.size = this.ctx.sampleRate * 30;
                this.recordBuffer.data = new Float32Array(this.recordBuffer.size);
                
                // Processor for continuous recording
                const processor = this.ctx.createScriptProcessor(2048, 1, 1);
                processor.onaudioprocess = (e) => {
                    this.recordAudio(e.inputBuffer.getChannelData(0));
                };
                
                // Master bus with sidechain compression
                this.masterBus = this.ctx.createDynamicsCompressor();
                this.masterBus.threshold.value = -10;
                this.masterBus.knee.value = 5;
                this.masterBus.ratio.value = 8;
                this.masterBus.attack.value = 0.003;
                this.masterBus.release.value = 0.1;
                
                // Setup professional FX chain
                this.setupFXChain();
                
                // Setup each deck
                this.setupDeck(this.decks.a);
                this.setupDeck(this.decks.b);
                
                // Connect input
                input.connect(this.recordBuffer.analyzer);
                input.connect(processor);
                processor.connect(this.ctx.destination); // Required
                
                // Master output
                this.masterBus.connect(this.ctx.destination);
            }
            
            setupDeck(deck) {
                // Create gain node
                deck.gain = this.ctx.createGain();
                deck.gain.gain.value = deck.volume;
                
                // 3-band EQ
                deck.eq.low = this.ctx.createBiquadFilter();
                deck.eq.low.type = 'lowshelf';
                deck.eq.low.frequency.value = 320;
                
                deck.eq.mid = this.ctx.createBiquadFilter();
                deck.eq.mid.type = 'peaking';
                deck.eq.mid.frequency.value = 1000;
                deck.eq.mid.Q.value = 0.5;
                
                deck.eq.high = this.ctx.createBiquadFilter();
                deck.eq.high.type = 'highshelf';
                deck.eq.high.frequency.value = 3200;
                
                // DJ Filter with resonance
                deck.filter = this.ctx.createBiquadFilter();
                deck.filter.type = 'lowpass';
                deck.filter.frequency.value = 20000;
                deck.filter.Q.value = 1;
                
                // Filter LFO for wobbles
                deck.filterLFO = this.ctx.createOscillator();
                deck.filterLFO.frequency.value = 0.5;
                const lfoGain = this.ctx.createGain();
                lfoGain.gain.value = 0;
                deck.filterLFO.connect(lfoGain);
                lfoGain.connect(deck.filter.frequency);
                deck.filterLFO.start();
                
                // Chain: source -> EQ -> filter -> gain -> master
                deck.eq.low.connect(deck.eq.mid);
                deck.eq.mid.connect(deck.eq.high);
                deck.eq.high.connect(deck.filter);
                deck.filter.connect(deck.gain);
                deck.gain.connect(this.masterBus);
            }
            
            setupFXChain() {
                // Professional reverb
                this.fx.reverb = this.ctx.createConvolver();
                this.fx.reverbSend = this.ctx.createGain();
                this.fx.reverbSend.gain.value = 0.15;
                
                // Create impulse
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                this.fx.reverb.buffer = impulse;
                
                // Ping-pong delay
                this.fx.delayL = this.ctx.createDelay(1);
                this.fx.delayR = this.ctx.createDelay(1);
                this.fx.delayL.delayTime.value = 0.375; // Dotted 8th
                this.fx.delayR.delayTime.value = 0.375;
                
                this.fx.delayFeedback = this.ctx.createGain();
                this.fx.delayFeedback.gain.value = 0.4;
                
                this.fx.delaySend = this.ctx.createGain();
                this.fx.delaySend.gain.value = 0;
                
                // Distortion/bitcrusher
                this.fx.distortion = this.ctx.createWaveShaper();
                this.fx.distortion.curve = this.makeDistortionCurve(50);
                this.fx.distortionSend = this.ctx.createGain();
                this.fx.distortionSend.gain.value = 0;
                
                // Connect FX sends
                this.masterBus.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb);
                this.fx.reverb.connect(this.ctx.destination);
                
                this.masterBus.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delayL);
                this.fx.delayL.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delayR);
                this.fx.delayR.connect(this.ctx.destination);
                
                this.masterBus.connect(this.fx.distortionSend);
                this.fx.distortionSend.connect(this.fx.distortion);
                this.fx.distortion.connect(this.ctx.destination);
            }
            
            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }
            
            recordAudio(input) {
                // Write to circular buffer
                for (let i = 0; i < input.length; i++) {
                    this.recordBuffer.data[this.recordBuffer.writePos] = input[i];
                    this.recordBuffer.writePos = (this.recordBuffer.writePos + 1) % this.recordBuffer.size;
                }
                
                // Analyze for beat detection
                this.analyzeBeat(input);
            }
            
            analyzeBeat(input) {
                // Energy-based beat detection with adaptive threshold
                let energy = 0;
                for (let i = 0; i < input.length; i++) {
                    energy += input[i] * input[i];
                }
                energy = Math.sqrt(energy / input.length);
                
                // Update groove feel
                this.dj.groove = this.dj.groove * 0.95 + energy * 0.05;
            }
            
            startPerformance() {
                // Start the musical brain
                this.runDJBrain();
                
                // Start visual engine
                this.animate();
                
                // Start gesture tracking
                this.trackGestures();
                
                // Natural tempo drift
                this.runTempoEngine();
            }
            
            runDJBrain() {
                const think = () => {
                    // Analyze current state
                    const hasEnoughSamples = Object.values(this.samplePool).flat().length;
                    const currentEnergy = this.dj.energy;
                    
                    // Phase transitions
                    switch (this.dj.phase) {
                        case 'seeking':
                            if (hasEnoughSamples >= 3) {
                                this.transitionPhase('collecting');
                                this.showHint('BUILDING YOUR RHYTHM');
                            }
                            break;
                            
                        case 'collecting':
                            if (hasEnoughSamples >= 6) {
                                this.transitionPhase('building');
                                this.startBuildUp();
                            }
                            break;
                            
                        case 'building':
                            // Natural build progression
                            this.dj.tension += 0.01;
                            this.updateBuildMeter();
                            
                            if (this.dj.tension > 0.9) {
                                this.transitionPhase('peak');
                                this.executeDrop();
                            }
                            break;
                            
                        case 'peak':
                            // Maintain energy
                            if (this.dj.energy < 0.5) {
                                this.transitionPhase('breakdown');
                            }
                            break;
                            
                        case 'breakdown':
                            // Cool down period
                            this.dj.tension *= 0.98;
                            if (this.dj.tension < 0.2) {
                                this.transitionPhase('collecting');
                            }
                            break;
                    }
                    
                    // Check for sample opportunities
                    if (this.motion.velocity > 0.5 && Math.random() < 0.1) {
                        this.captureLiveElement();
                    }
                    
                    setTimeout(think, 100);
                };
                
                think();
            }
            
            runTempoEngine() {
                // Natural tempo fluctuation like a real DJ
                const fluctuate = () => {
                    const drift = (Math.random() - 0.5) * 0.2;
                    this.dj.actualTempo = this.dj.tempo + drift;
                    
                    // Smooth display update
                    const display = this.dj.actualTempo.toFixed(1);
                    this.ui.bpmDisplay.textContent = display;
                    
                    // Apply to delays
                    const beatTime = 60 / this.dj.actualTempo;
                    this.fx.delayL.delayTime.value = beatTime * 0.375;
                    this.fx.delayR.delayTime.value = beatTime * 0.375;
                    
                    setTimeout(fluctuate, 1000 + Math.random() * 2000);
                };
                
                fluctuate();
            }
            
            trackGestures() {
                const track = () => {
                    if (!this.motion.gesture) {
                        setTimeout(track, 50);
                        return;
                    }
                    
                    // React to gestures
                    switch (this.motion.gesture) {
                        case 'sweep':
                            this.performFilterSweep();
                            break;
                            
                        case 'rise':
                            this.increaseEnergy();
                            break;
                            
                        case 'drop':
                            if (this.dj.phase === 'building' && this.dj.tension > 0.7) {
                                this.executeDrop();
                            }
                            break;
                            
                        case 'scratch':
                            this.performScratch();
                            break;
                    }
                    
                    this.motion.gesture = null;
                    setTimeout(track, 50);
                };
                
                track();
            }
            
            captureLiveElement() {
                const captureLength = Math.floor(
                    this.ctx.sampleRate * (0.5 + Math.random() * 2)
                );
                
                const buffer = this.ctx.createBuffer(1, captureLength, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Capture with position based on motion
                const offset = Math.floor(this.motion.x * this.ctx.sampleRate * 2);
                const startPos = (this.recordBuffer.writePos - captureLength - offset + this.recordBuffer.size) % this.recordBuffer.size;
                
                for (let i = 0; i < captureLength; i++) {
                    const pos = (startPos + i) % this.recordBuffer.size;
                    data[i] = this.recordBuffer.data[pos];
                }
                
                // Analyze and categorize
                this.processAndCategorizeSample(buffer);
            }
            
            processAndCategorizeSample(buffer) {
                const data = buffer.getChannelData(0);
                
                // Quick spectral analysis
                const fft = new Float32Array(2048);
                // Simplified - in real implementation would use proper FFT
                
                let lowEnergy = 0, midEnergy = 0, highEnergy = 0;
                let peakiness = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const sample = Math.abs(data[i]);
                    if (i < data.length * 0.1) lowEnergy += sample;
                    else if (i < data.length * 0.5) midEnergy += sample;
                    else highEnergy += sample;
                    
                    if (sample > 0.8) peakiness++;
                }
                
                // Categorize based on characteristics
                let category = 'ambient';
                
                if (peakiness > 10 && lowEnergy > midEnergy * 2) {
                    category = 'kicks';
                } else if (peakiness > 20 && highEnergy > midEnergy) {
                    category = 'hats';
                } else if (peakiness > 15) {
                    category = 'snares';
                } else if (lowEnergy > highEnergy * 3) {
                    category = 'bass';
                } else if (data.length > this.ctx.sampleRate) {
                    category = Math.random() > 0.5 ? 'pads' : 'leads';
                }
                
                // Add to pool
                this.samplePool[category].push({
                    buffer,
                    energy: lowEnergy + midEnergy + highEnergy,
                    character: { low: lowEnergy, mid: midEnergy, high: highEnergy },
                    timestamp: Date.now()
                });
                
                // Update UI
                this.updateSampleSlot(buffer);
                
                // Visual feedback
                this.createCaptureParticle();
            }
            
            updateSampleSlot(buffer) {
                const slots = this.ui.sampleDeck.children;
                let targetSlot = null;
                
                // Find empty slot
                for (let slot of slots) {
                    if (!slot.classList.contains('loaded')) {
                        targetSlot = slot;
                        break;
                    }
                }
                
                if (!targetSlot) {
                    // Replace oldest
                    targetSlot = slots[0];
                }
                
                targetSlot.classList.add('loaded');
                this.drawMiniWaveform(
                    targetSlot.querySelector('canvas'),
                    buffer.getChannelData(0)
                );
            }
            
            drawMiniWaveform(canvas, data) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(255, 140, 0, 0.8)';
                ctx.lineWidth = 1;
                
                const step = Math.ceil(data.length / width);
                
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    const sample = data[i * step] || 0;
                    const y = (1 + sample) * height / 2;
                    
                    if (i === 0) ctx.moveTo(i, y);
                    else ctx.lineTo(i, y);
                }
                ctx.stroke();
            }
            
            transitionPhase(newPhase) {
                this.dj.phase = newPhase;
                this.ui.phaseName.textContent = newPhase.toUpperCase();
                
                // Visual feedback
                document.querySelectorAll('.fx-unit').forEach(fx => {
                    fx.classList.remove('active');
                });
                
                if (newPhase === 'building') {
                    document.getElementById('fx-filter').classList.add('active');
                } else if (newPhase === 'peak') {
                    document.getElementById('fx-delay').classList.add('active');
                    document.getElementById('fx-distortion').classList.add('active');
                }
            }
            
            startBuildUp() {
                // Create rising tension
                const riser = this.ctx.createOscillator();
                const riserGain = this.ctx.createGain();
                
                riser.type = 'sawtooth';
                riser.frequency.setValueAtTime(100, this.ctx.currentTime);
                riser.frequency.exponentialRampToValueAtTime(
                    2000,
                    this.ctx.currentTime + 16
                );
                
                riserGain.gain.setValueAtTime(0, this.ctx.currentTime);
                riserGain.gain.linearRampToValueAtTime(
                    0.3,
                    this.ctx.currentTime + 16
                );
                
                riser.connect(riserGain);
                riserGain.connect(this.fx.reverb);
                
                riser.start();
                riser.stop(this.ctx.currentTime + 16);
                
                // Start filter automation
                this.automateFilters();
            }
            
            automateFilters() {
                const automate = () => {
                    if (this.dj.phase !== 'building') return;
                    
                    // Gradually close filters
                    const progress = this.dj.tension;
                    const freq = 20000 * (1 - progress * 0.8);
                    
                    this.decks.a.filter.frequency.value = freq;
                    this.decks.b.filter.frequency.value = freq;
                    
                    // Increase resonance
                    this.decks.a.filter.Q.value = 1 + progress * 10;
                    this.decks.b.filter.Q.value = 1 + progress * 10;
                    
                    setTimeout(automate, 100);
                };
                
                automate();
            }
            
            executeDrop() {
                // Impact
                const kick = this.ctx.createOscillator();
                const kickEnv = this.ctx.createGain();
                
                kick.type = 'sine';
                kick.frequency.setValueAtTime(150, this.ctx.currentTime);
                kick.frequency.exponentialRampToValueAtTime(
                    30,
                    this.ctx.currentTime + 0.5
                );
                
                kickEnv.gain.setValueAtTime(1, this.ctx.currentTime);
                kickEnv.gain.exponentialRampToValueAtTime(
                    0.01,
                    this.ctx.currentTime + 0.5
                );
                
                kick.connect(kickEnv);
                kickEnv.connect(this.masterBus);
                
                kick.start();
                kick.stop(this.ctx.currentTime + 0.5);
                
                // Open filters
                this.decks.a.filter.frequency.value = 20000;
                this.decks.b.filter.frequency.value = 20000;
                
                // Reset tension
                this.dj.tension = 0;
                this.dj.energy = 1;
                
                // Visual explosion
                this.createDropVisual();
            }
            
            performFilterSweep() {
                const deck = Math.random() > 0.5 ? this.decks.a : this.decks.b;
                const currentFreq = deck.filter.frequency.value;
                const targetFreq = this.motion.y * 19000 + 1000;
                
                deck.filter.frequency.exponentialRampToValueAtTime(
                    targetFreq,
                    this.ctx.currentTime + 0.1
                );
            }
            
            increaseEnergy() {
                this.dj.energy = Math.min(1, this.dj.energy + 0.1);
                this.dj.tension = Math.min(1, this.dj.tension + 0.05);
            }
            
            performScratch() {
                // Quick stutter effect
                const deck = this.decks.a.source ? this.decks.a : this.decks.b;
                if (!deck.source) return;
                
                // Rapid gain modulation
                const scratchTime = 0.05;
                const now = this.ctx.currentTime;
                
                deck.gain.gain.setValueAtTime(deck.volume, now);
                deck.gain.gain.linearRampToValueAtTime(0, now + scratchTime);
                deck.gain.gain.linearRampToValueAtTime(deck.volume, now + scratchTime * 2);
            }
            
            updateBuildMeter() {
                const sections = document.querySelectorAll('.build-section .build-fill');
                const progress = this.dj.tension;
                
                sections.forEach((section, i) => {
                    const sectionProgress = Math.max(0, Math.min(1, progress * 4 - i));
                    section.style.height = (sectionProgress * 100) + '%';
                });
            }
            
            showHint(text) {
                this.ui.hint.textContent = text;
                this.ui.hint.classList.add('show');
                this.ui.hint.style.left = (this.motion.x * 100) + '%';
                this.ui.hint.style.top = (this.motion.y * 100) + '%';
                
                setTimeout(() => {
                    this.ui.hint.classList.remove('show');
                }, 3000);
            }
            
            createCaptureParticle() {
                this.visuals.particles.push({
                    x: this.motion.x * window.innerWidth,
                    y: this.motion.y * window.innerHeight,
                    vx: (Math.random() - 0.5) * 5,
                    vy: (Math.random() - 0.5) * 5,
                    life: 1,
                    color: `hsl(${Math.random() * 60 + 20}, 70%, 50%)`
                });
            }
            
            createDropVisual() {
                // Shockwave effect
                for (let i = 0; i < 50; i++) {
                    const angle = (i / 50) * Math.PI * 2;
                    this.visuals.particles.push({
                        x: window.innerWidth / 2,
                        y: window.innerHeight / 2,
                        vx: Math.cos(angle) * 20,
                        vy: Math.sin(angle) * 20,
                        life: 1,
                        color: 'rgba(255, 0, 0, 0.8)'
                    });
                }
            }
            
            animate() {
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    this.drawWaveform();
                    this.drawSpectrum();
                    this.drawParticles();
                };
                
                draw();
            }
            
            drawWaveform() {
                const { ctx, canvas } = this.visuals.waveform;
                const time = new Uint8Array(this.recordBuffer.analyzer.frequencyBinCount);
                this.recordBuffer.analyzer.getByteTimeDomainData(time);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.1 + this.dj.energy * 0.3})`;
                ctx.lineWidth = 1 + this.dj.tension * 2;
                
                ctx.beginPath();
                const sliceWidth = canvas.width / time.length;
                
                for (let i = 0; i < time.length; i++) {
                    const v = time[i] / 128.0;
                    const y = v * canvas.height / 2;
                    
                    if (i === 0) ctx.moveTo(i * sliceWidth, y);
                    else ctx.lineTo(i * sliceWidth, y);
                }
                
                ctx.stroke();
            }
            
            drawSpectrum() {
                const { ctx, canvas } = this.visuals.spectrum;
                const freq = new Uint8Array(this.recordBuffer.analyzer.frequencyBinCount);
                this.recordBuffer.analyzer.getByteFrequencyData(freq);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / freq.length * 2.5;
                
                for (let i = 0; i < freq.length; i++) {
                    const height = freq[i] / 255 * canvas.height * 0.7;
                    
                    // Color based on phase
                    let hue;
                    switch (this.dj.phase) {
                        case 'building':
                            hue = 30 + this.dj.tension * 30; // Orange to red
                            break;
                        case 'peak':
                            hue = Math.sin(Date.now() * 0.01) * 60 + 300; // Purple flash
                            break;
                        default:
                            hue = 200; // Blue
                    }
                    
                    ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                    ctx.fillRect(
                        i * barWidth,
                        canvas.height - height,
                        barWidth - 1,
                        height
                    );
                }
            }
            
            drawParticles() {
                const { ctx, canvas } = this.visuals.particles;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Update and draw particles
                for (let i = this.visuals.particles.length - 1; i >= 0; i--) {
                    const p = this.visuals.particles[i];
                    
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life -= 0.02;
                    
                    if (p.life <= 0) {
                        this.visuals.particles.splice(i, 1);
                        continue;
                    }
                    
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 3 + (1 - p.life) * 10, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.globalAlpha = 1;
            }
        }
        
        // Initialize
        const gump = new GumpDJEngine();
    </script>
</body>
</html>
