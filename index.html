<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;color:#fff;font-family:system-ui;height:100vh;overflow:hidden;touch-action:none}
        #start{position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:24px;z-index:10}
        #start.off{display:none}
        .title{font-size:10px;letter-spacing:8px;opacity:0.4}
        .sub{font-size:20px;font-weight:200;letter-spacing:3px}
        button{width:100px;height:100px;border-radius:50%;background:transparent;border:1px solid #0fa;color:#0fa;font:inherit;font-size:9px;letter-spacing:2px;cursor:pointer;transition:0.3s}
        button:hover{background:#0fa;color:#000}
        .hint{font-size:9px;opacity:0.25;text-align:center;max-width:200px;line-height:1.5}
        #app{display:none;height:100vh}
        #app.on{display:block}
        canvas{position:fixed;inset:0;width:100%;height:100%}
        .hud{position:fixed;font-size:8px;letter-spacing:1px;opacity:0.3;z-index:5}
        .tl{top:16px;left:16px}
        .tr{top:16px;right:16px;text-align:right}
        .bl{bottom:16px;left:16px}
        .br{bottom:16px;right:16px;text-align:right}
        .v{font-size:11px;margin-top:3px;opacity:0.7}
    </style>
</head>
<body>
<div id="start">
    <div class="title">GUMP</div>
    <div class="sub">Grand Unified Music Project</div>
    <button id="go">ENTER</button>
    <div class="hint">Move through space. You are the instrument.</div>
</div>
<div id="app">
    <canvas id="c"></canvas>
    <div class="hud tl"><div>STAGE</div><div class="v" id="stage">VOID</div></div>
    <div class="hud tr"><div>FLOW</div><div class="v" id="flw">0</div></div>
    <div class="hud bl"><div>LAYERS</div><div class="v" id="layers">0</div></div>
    <div class="hud br"><div>JOURNEY</div><div class="v" id="journey">0:00</div></div>
</div>
<script>
// GUMP - Grand Unified Music Project
// A journey through sound and self

const PHI = 1.618033988749;
const TAU = Math.PI * 2;

// Scales for different emotional states
const SCALES = {
    void: [0, 5, 7],                    // sparse, open fifths
    phrygian: [0, 1, 3, 5, 7, 8, 10],   // dark, tense
    locrian: [0, 1, 3, 5, 6, 8, 10],    // unstable, diminished
    lydian: [0, 2, 4, 6, 7, 9, 11],     // bright, transcendent
    wholetone: [0, 2, 4, 6, 8, 10],     // dreamlike, floating
};

// Quick access for common scales
const PHRYGIAN = SCALES.phrygian;
const LOCRIAN = SCALES.locrian;

// THE JOURNEY - stages of the experience
const STAGES = {
    VOID: 0,        // sparse, uncertain - you're alone
    AWAKENING: 1,   // first sounds emerge - curiosity
    DESCENT: 2,     // going deeper - tension builds
    DEEP: 3,        // maximum darkness - disorientation
    EMERGENCE: 4,   // light breaking through - hope
    TRANSCEND: 5    // full release - frisson
};

// State
const F = {
    x: 0, y: 0, z: 0,
    vx: 0, vy: 0, vz: 0,
    speed: 0,
    phase: 0,
    density: 0,
    field: 0,
    lfo: 0,
    breath: 0,      // breath cycle (5 second period)
    orbit: 0        // spatial rotation
};

// Journey state
const J = {
    stage: STAGES.VOID,
    stageTime: 0,       // time in current stage
    totalTime: 0,       // total journey time
    intensity: 0,       // overall intensity
    tension: 0,         // tension level (for release)
    lastDrop: 0,        // time of last "drop"
    dropPending: false, // is a drop coming?
    frisson: 0,         // frisson intensity
    keyOffset: 0,       // current key (for modulation)
    silenceUntil: 0     // silence timestamp
};

// Memory
const M = {
    mode: 'building',
    tape: [],
    loopLen: 8,
    beatTime: 0.4,
    playhead: 0,
    lastBeat: 0,
    layers: [],
    activeLayer: null,
    blend: 0.6,
    beatDropped: false,
    beatIntensity: 0,
    darkness: 0
};

// Audio nodes
let ctx, master, reverb, reverbDistort, delay, subDrone, textureNoise;
let walls = [];
let binaural = null;    // binaural beat layer
let shimmer = null;     // high frequency shimmer
let whisper = null;     // vocal-like formant layer
let orbitSounds = [];   // sounds that move around you
let running = false;

// Mic
let micStream, micSource, micBuffer;
const MIC_BUFFER_SIZE = 48000 * 4;
let micWritePos = 0;

const ROOT = 55;
const BPM = 72; // slower for the journey

// ============ AUDIO ENGINE ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    M.beatTime = 60 / BPM / 2;

    // Master
    master = ctx.createGain();
    master.gain.value = 0.8;

    // Create waveshaper for saturation
    const saturator = createSaturator();

    // Dark reverb with distortion after it
    reverb = createDarkReverb();

    // Delay
    delay = ctx.createDelay(2);
    delay.delayTime.value = 60 / BPM * 0.75;
    const delayFb = ctx.createGain();
    delayFb.gain.value = 0.4;
    const delayFilter = ctx.createBiquadFilter();
    delayFilter.type = 'lowpass';
    delayFilter.frequency.value = 2000;

    delay.connect(delayFilter);
    delayFilter.connect(delayFb);
    delayFb.connect(delay);
    delay.connect(saturator);

    // Compression - aggressive
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -24;
    comp.ratio.value = 8;
    comp.attack.value = 0.002;
    comp.release.value = 0.1;
    comp.knee.value = 0;

    // Final chain
    saturator.connect(master);
    master.connect(comp);
    comp.connect(ctx.destination);

    // Create the sound sources
    createSubDrone();
    createWalls();
    createTexture();
    createBinaural();
    createShimmer();
    createWhisper();
    initOrbits();
    initMic();
}

// Waveshaper for that gritty saturation
function createSaturator() {
    const shaper = ctx.createWaveShaper();
    const samples = 44100;
    const curve = new Float32Array(samples);

    for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        // Soft clipping with odd harmonics
        curve[i] = Math.tanh(x * 2) * 0.8 + Math.tanh(x * 4) * 0.2;
    }

    shaper.curve = curve;
    shaper.oversample = '2x';
    return shaper;
}

// Dark reverb - long, filtered, with distortion
function createDarkReverb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.4;

    // Longer, darker taps
    const times = [0.05, 0.13, 0.21, 0.34, 0.55, 0.89, 1.44];
    const gains = [0.6, 0.5, 0.45, 0.35, 0.3, 0.25, 0.2];

    times.forEach((t, i) => {
        const d = ctx.createDelay(2);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = gains[i];
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 2500 - i * 300; // gets darker
        f.Q.value = 0.5;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
    });

    // Distortion AFTER reverb - key for that eerie sound
    reverbDistort = ctx.createWaveShaper();
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        const x = (i / 128) - 1;
        curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.7);
    }
    reverbDistort.curve = curve;

    output.connect(reverbDistort);
    reverbDistort.connect(master);

    return input;
}

// ============ SUB DRONE - THE FOUNDATION ============

function createSubDrone() {
    // Deep, rumbling sub that's always there
    const sub = ctx.createOscillator();
    const sub2 = ctx.createOscillator();
    const subGain = ctx.createGain();
    const subFilter = ctx.createBiquadFilter();

    sub.type = 'sine';
    sub.frequency.value = ROOT / 2; // 27.5 Hz - you feel it more than hear it

    sub2.type = 'sine';
    sub2.frequency.value = ROOT / 2 * 1.002; // beating

    subFilter.type = 'lowpass';
    subFilter.frequency.value = 80;

    subGain.gain.value = 0;

    sub.connect(subFilter);
    sub2.connect(subFilter);
    subFilter.connect(subGain);
    subGain.connect(master);

    sub.start();
    sub2.start();

    subDrone = { sub, sub2, gain: subGain, filter: subFilter };
}

// ============ THE WALLS - MASSIVE SUPERSAW CHORDS ============

function createWalls() {
    // 3 massive chord voices, each is a 7-oscillator supersaw
    const chordIntervals = [
        [0, 0],      // root
        [3, 1],      // minor 3rd + octave (cluster)
        [7, 13]      // 5th + b9 up high (the tension)
    ];

    chordIntervals.forEach((interval, idx) => {
        const wall = createSupersaw(ROOT * Math.pow(2, interval[0]/12 + interval[1]/12), idx);
        walls.push(wall);
    });
}

function createSupersaw(baseFreq, idx) {
    // 7 detuned oscillators - the classic supersaw
    const NUM_OSCS = 7;
    const oscs = [];
    const gains = [];
    const output = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    const panL = ctx.createGain();
    const panR = ctx.createGain();
    const merger = ctx.createChannelMerger(2);

    // Detune amounts (in cents) - asymmetric like the JP-8000
    const detunes = [-35, -20, -10, 0, 12, 24, 40];
    // Gains - center voice loudest
    const oscGains = [0.5, 0.7, 0.9, 1, 0.9, 0.7, 0.5];

    for (let i = 0; i < NUM_OSCS; i++) {
        const osc = ctx.createOscillator();
        const g = ctx.createGain();

        osc.type = 'sawtooth';
        osc.frequency.value = baseFreq;
        osc.detune.value = detunes[i];

        g.gain.value = oscGains[i] / NUM_OSCS;

        // Stereo spread - left voices detuned down, right detuned up
        if (i < 3) {
            osc.connect(g);
            g.connect(panL);
        } else if (i > 3) {
            osc.connect(g);
            g.connect(panR);
        } else {
            // Center goes to both
            osc.connect(g);
            g.connect(panL);
            g.connect(panR);
        }

        osc.start();
        oscs.push(osc);
        gains.push(g);
    }

    // Stereo output
    panL.connect(merger, 0, 0);
    panR.connect(merger, 0, 1);

    // Rich resonant filter
    filter.type = 'lowpass';
    filter.frequency.value = 800;
    filter.Q.value = 4;

    merger.connect(filter);
    filter.connect(output);
    output.gain.value = 0;
    output.connect(master);
    output.connect(reverb);
    output.connect(delay);

    return { oscs, gains, output, filter, baseFreq, panL, panR };
}

function updateWalls() {
    const now = ctx.currentTime;
    const S = getBlendedState();

    // LFO for slow movement
    F.lfo = Math.sin(now * 0.3) * 0.5 + 0.5;

    walls.forEach((w, i) => {
        // Amplitude - builds with movement and darkness
        let amp = (0.05 + S.speed * 0.15 + M.darkness * 0.1);

        // Position affects which voices are prominent
        if (i === 0) amp *= 0.8; // root always present
        if (i === 1) amp *= (1 + S.x) / 2; // minor 3rd on right side
        if (i === 2) amp *= (1 + S.y) / 2 * M.darkness; // tension voice builds

        w.output.gain.linearRampToValueAtTime(amp * 0.3, now + 0.2);

        // Filter - opens slowly, controlled by movement
        const filterBase = 400 + M.darkness * 1500;
        const filterMod = S.speed * 2000 + F.lfo * 500;
        w.filter.frequency.linearRampToValueAtTime(filterBase + filterMod, now + 0.15);
        w.filter.Q.linearRampToValueAtTime(2 + S.speed * 6, now + 0.15);

        // Subtle pitch drift
        const drift = Math.sin(now * (0.1 + i * 0.07)) * 5;
        w.oscs.forEach((osc, j) => {
            const baseDetune = [-35, -20, -10, 0, 12, 24, 40][j];
            osc.detune.linearRampToValueAtTime(baseDetune + drift, now + 0.1);
        });
    });

    // Sub drone - always rumbling, intensity varies
    const subAmp = 0.15 + S.speed * 0.2 + M.darkness * 0.15;
    subDrone.gain.gain.linearRampToValueAtTime(subAmp, now + 0.2);

    // Sub filter opens with intensity
    subDrone.filter.frequency.linearRampToValueAtTime(60 + S.speed * 40, now + 0.2);

    // Build darkness over time
    M.darkness = Math.min(1, M.darkness + 0.0005);
}

// ============ TEXTURE LAYER - FILTERED NOISE CHAOS ============

function createTexture() {
    // Continuous noise that morphs with movement
    const bufferSize = ctx.sampleRate * 2;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = noiseBuffer.getChannelData(0);

    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    noise.loop = true;

    const noiseGain = ctx.createGain();
    noiseGain.gain.value = 0;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'bandpass';
    noiseFilter.frequency.value = 1000;
    noiseFilter.Q.value = 5;

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(reverb);

    noise.start();

    textureNoise = { source: noise, gain: noiseGain, filter: noiseFilter };
}

function updateTexture() {
    const now = ctx.currentTime;
    const S = getBlendedState();

    // Noise level varies with journey stage
    const stageNoise = [0.02, 0.04, 0.08, 0.12, 0.06, 0.03][J.stage];
    const noiseAmp = S.speed * 0.08 + stageNoise;
    textureNoise.gain.gain.linearRampToValueAtTime(noiseAmp, now + 0.1);

    // Filter sweeps with position
    const freq = 500 + S.x * 2000 + S.y * 1500 + F.lfo * 1000;
    textureNoise.filter.frequency.linearRampToValueAtTime(freq, now + 0.1);
    textureNoise.filter.Q.linearRampToValueAtTime(3 + J.tension * 8, now + 0.1);
}

// ============ BINAURAL BEATS - ALTER CONSCIOUSNESS ============

function createBinaural() {
    // Two oscillators with slightly different frequencies in each ear
    // The difference creates a perceived "beat" that entrains brainwaves
    // Theta (4-8Hz) = dreamlike, meditative
    // Alpha (8-12Hz) = relaxed, aware

    const baseFreq = 100; // carrier frequency
    const merger = ctx.createChannelMerger(2);

    const oscL = ctx.createOscillator();
    const oscR = ctx.createOscillator();
    const gainL = ctx.createGain();
    const gainR = ctx.createGain();

    oscL.type = 'sine';
    oscR.type = 'sine';
    oscL.frequency.value = baseFreq;
    oscR.frequency.value = baseFreq + 6; // 6Hz difference = theta waves

    gainL.gain.value = 0;
    gainR.gain.value = 0;

    oscL.connect(gainL);
    oscR.connect(gainR);
    gainL.connect(merger, 0, 0);
    gainR.connect(merger, 0, 1);
    merger.connect(master);

    oscL.start();
    oscR.start();

    binaural = { oscL, oscR, gainL, gainR, baseFreq };
}

function updateBinaural() {
    if (!binaural) return;
    const now = ctx.currentTime;

    // Binaural intensity based on journey stage
    const stageAmp = [0.03, 0.05, 0.08, 0.12, 0.08, 0.15][J.stage];
    const amp = stageAmp * (0.5 + F.breath * 0.5);

    binaural.gainL.gain.linearRampToValueAtTime(amp, now + 0.5);
    binaural.gainR.gain.linearRampToValueAtTime(amp, now + 0.5);

    // Frequency difference changes with stage
    // Deeper stages = slower theta, transcendence = higher alpha
    const beatFreqs = [4, 5, 6, 7, 8, 10]; // Hz difference per stage
    const beatFreq = beatFreqs[J.stage];

    binaural.oscL.frequency.linearRampToValueAtTime(binaural.baseFreq, now + 1);
    binaural.oscR.frequency.linearRampToValueAtTime(binaural.baseFreq + beatFreq, now + 1);
}

// ============ SHIMMER - HIGH FREQUENCY TINGLE ============

function createShimmer() {
    // Very high frequencies that create that "tingle" sensation
    // Multiple detuned oscillators in the 3-6kHz range

    const oscs = [];
    const output = ctx.createGain();
    output.gain.value = 0;

    const freqs = [3000, 4000, 5000, 6000];
    freqs.forEach((f, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = f;
        osc.detune.value = Math.random() * 20 - 10;

        const g = ctx.createGain();
        g.gain.value = 0.1 / freqs.length;

        osc.connect(g);
        g.connect(output);
        osc.start();
        oscs.push({ osc, gain: g });
    });

    output.connect(reverb);
    shimmer = { oscs, output };
}

function updateShimmer() {
    if (!shimmer) return;
    const now = ctx.currentTime;

    // Shimmer emerges in later stages, peaks at transcendence
    const stageAmp = [0, 0, 0.02, 0.03, 0.08, 0.15][J.stage];
    const amp = stageAmp * J.frisson;

    shimmer.output.gain.linearRampToValueAtTime(amp, now + 0.3);

    // Slight frequency wobble
    shimmer.oscs.forEach((s, i) => {
        const wobble = Math.sin(now * (0.5 + i * 0.2)) * 50;
        s.osc.detune.linearRampToValueAtTime(wobble, now + 0.1);
    });
}

// ============ WHISPER - VOCAL-LIKE FORMANTS ============

function createWhisper() {
    // Filtered noise that sounds almost like distant voices
    // Uses formant frequencies to create vocal quality

    const bufferSize = ctx.sampleRate * 2;
    const noiseBuffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = noiseBuffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = noiseBuffer;
    noise.loop = true;

    // Formant filters (vowel-like resonances)
    const formants = [
        { freq: 700, Q: 10 },   // "ah"
        { freq: 1200, Q: 8 },   // "eh"
        { freq: 2500, Q: 6 }    // "ee" / presence
    ];

    const filters = formants.map(f => {
        const filter = ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = f.freq;
        filter.Q.value = f.Q;
        return filter;
    });

    const output = ctx.createGain();
    output.gain.value = 0;

    // Parallel formants
    filters.forEach(f => {
        noise.connect(f);
        f.connect(output);
    });

    output.connect(reverb);
    noise.start();

    whisper = { noise, filters, output };
}

function updateWhisper() {
    if (!whisper) return;
    const now = ctx.currentTime;

    // Whispers appear in deep/emergence stages
    const stageAmp = [0, 0, 0.01, 0.04, 0.03, 0.02][J.stage];
    const amp = stageAmp * (0.5 + F.breath * 0.5);

    whisper.output.gain.linearRampToValueAtTime(amp, now + 0.5);

    // Formants shift slowly, creating morphing "words"
    const shift = Math.sin(now * 0.2) * 200;
    whisper.filters[0].frequency.linearRampToValueAtTime(700 + shift, now + 0.5);
    whisper.filters[1].frequency.linearRampToValueAtTime(1200 - shift * 0.5, now + 0.5);
}

// ============ ORBITAL SOUNDS - SPATIAL MOVEMENT ============

function createOrbitSound(freq, radius) {
    // A sound that rotates around the listener in stereo

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const panL = ctx.createGain();
    const panR = ctx.createGain();
    const merger = ctx.createChannelMerger(2);

    osc.type = 'sine';
    osc.frequency.value = freq;
    gain.gain.value = 0;

    osc.connect(gain);
    gain.connect(panL);
    gain.connect(panR);
    panL.connect(merger, 0, 0);
    panR.connect(merger, 0, 1);
    merger.connect(master);
    merger.connect(reverb);

    osc.start();

    return { osc, gain, panL, panR, radius, angle: Math.random() * TAU };
}

function initOrbits() {
    // Create several orbital sounds at different frequencies
    const freqs = [ROOT * 2, ROOT * 3, ROOT * 4, ROOT * 5];
    freqs.forEach((f, i) => {
        orbitSounds.push(createOrbitSound(f, 0.8 - i * 0.15));
    });
}

function updateOrbits() {
    const now = ctx.currentTime;
    F.orbit += 0.005 * (1 + J.intensity);

    orbitSounds.forEach((o, i) => {
        // Rotate at different speeds
        o.angle += 0.01 * (1 + i * 0.3) * (1 + F.speed);

        // Pan based on angle
        const pan = Math.sin(o.angle);
        const depth = Math.cos(o.angle) * 0.5 + 0.5; // 0.5 to 1 (front/back simulation)

        o.panL.gain.linearRampToValueAtTime((1 - pan) * 0.5 * depth, now + 0.05);
        o.panR.gain.linearRampToValueAtTime((1 + pan) * 0.5 * depth, now + 0.05);

        // Amplitude based on stage
        const stageAmp = [0, 0.02, 0.04, 0.06, 0.08, 0.1][J.stage];
        o.gain.gain.linearRampToValueAtTime(stageAmp * (0.5 + F.speed * 0.5), now + 0.1);
    });
}

// ============ THE JOURNEY - STAGE PROGRESSION ============

function updateJourney() {
    const now = ctx.currentTime;
    const dt = 1/60; // approx frame time

    J.totalTime += dt;
    J.stageTime += dt;

    // Breath cycle - 5 second period
    F.breath = (Math.sin(now * TAU / 5) + 1) / 2;

    // LFO for slow movement
    F.lfo = Math.sin(now * 0.3) * 0.5 + 0.5;

    // Intensity builds with movement and time
    J.intensity = Math.min(1, J.intensity * 0.999 + F.speed * 0.01 + 0.0001);

    // Tension builds in certain stages
    if (J.stage === STAGES.DESCENT || J.stage === STAGES.DEEP) {
        J.tension = Math.min(1, J.tension + 0.0008 + F.speed * 0.002);
    } else {
        J.tension *= 0.995;
    }

    // Frisson builds in emergence/transcendence
    if (J.stage >= STAGES.EMERGENCE) {
        J.frisson = Math.min(1, J.frisson + 0.002);
    } else {
        J.frisson *= 0.99;
    }

    // Stage progression based on time and intensity
    const stageThresholds = [
        { time: 8, intensity: 0.1 },   // VOID → AWAKENING
        { time: 20, intensity: 0.25 }, // AWAKENING → DESCENT
        { time: 40, intensity: 0.5 },  // DESCENT → DEEP
        { time: 70, intensity: 0.7 },  // DEEP → EMERGENCE
        { time: 100, intensity: 0.85 } // EMERGENCE → TRANSCEND
    ];

    if (J.stage < STAGES.TRANSCEND) {
        const threshold = stageThresholds[J.stage];
        if (J.totalTime > threshold.time && J.intensity > threshold.intensity) {
            advanceStage();
        }
    }

    // Check for drop trigger
    if (J.tension > 0.8 && !J.dropPending && now - J.lastDrop > 15) {
        J.dropPending = true;
        scheduleDrop(now + 2); // drop in 2 seconds
    }

    // Update darkness based on stage
    M.darkness = [0, 0.1, 0.3, 0.7, 0.4, 0.1][J.stage];
}

function advanceStage() {
    J.stage = Math.min(STAGES.TRANSCEND, J.stage + 1);
    J.stageTime = 0;

    // Key modulation on stage change - instant emotion
    if (J.stage === STAGES.EMERGENCE) {
        modulateKey(1); // up a half step - the lift
    } else if (J.stage === STAGES.TRANSCEND) {
        modulateKey(2); // up a whole step - transcendence
    }
}

function modulateKey(semitones) {
    // Shift all pitched elements up - creates instant emotional lift
    J.keyOffset += semitones;

    walls.forEach(w => {
        const newFreq = w.baseFreq * Math.pow(2, J.keyOffset / 12);
        w.oscs.forEach(osc => {
            osc.frequency.linearRampToValueAtTime(newFreq, ctx.currentTime + 0.5);
        });
    });
}

// ============ THE DROP - SILENCE THEN RELEASE ============

function scheduleDrop(time) {
    // Everything cuts out, tension hangs, then SLAM back

    const now = ctx.currentTime;

    // Fade everything out
    setTimeout(() => {
        J.silenceUntil = ctx.currentTime + 1.5; // 1.5 seconds of near-silence
        master.gain.linearRampToValueAtTime(0.05, ctx.currentTime + 0.3);
    }, (time - now - 0.5) * 1000);

    // The return - everything slams back louder
    setTimeout(() => {
        master.gain.linearRampToValueAtTime(1.0, ctx.currentTime + 0.05);
        J.dropPending = false;
        J.lastDrop = ctx.currentTime;
        J.tension = 0;

        // Trigger frisson response
        J.frisson = Math.min(1, J.frisson + 0.5);

        // Big kick on the return
        playKick();
        playKick(); // double hit

        // Advance stage if ready
        if (J.stage < STAGES.TRANSCEND && J.intensity > 0.5) {
            advanceStage();
        }
    }, (time - now + 1.5) * 1000);
}

// ============ DARK MELODIC VOICES ============

function playDarkNote(semitones, duration) {
    const freq = ROOT * Math.pow(2, semitones / 12);
    const now = ctx.currentTime;

    // Supersaw voice for melody too
    const NUM = 5;
    const oscs = [];
    const output = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    const detunes = [-25, -10, 0, 10, 25];

    for (let i = 0; i < NUM; i++) {
        const osc = ctx.createOscillator();
        osc.type = i === 2 ? 'triangle' : 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = detunes[i];
        osc.connect(filter);
        osc.start(now);
        osc.stop(now + duration + 0.5);
        oscs.push(osc);
    }

    filter.type = 'lowpass';
    filter.frequency.value = 3000;
    filter.Q.value = 3;

    // Filter envelope
    filter.frequency.setValueAtTime(5000, now);
    filter.frequency.exponentialRampToValueAtTime(800, now + duration * 0.7);

    output.gain.setValueAtTime(0, now);
    output.gain.linearRampToValueAtTime(0.15, now + 0.01);
    output.gain.exponentialRampToValueAtTime(0.001, now + duration);

    filter.connect(output);
    output.connect(master);
    output.connect(delay);
    output.connect(reverb);
}

function playCluster() {
    // Cluster chord - notes fighting each other
    const now = ctx.currentTime;
    const scale = M.darkness > 0.5 ? LOCRIAN : PHRYGIAN;

    // Pick 3-4 close notes
    const root = Math.floor(F.y * 3 + 2) * 12; // octave from position
    const notes = [
        root + scale[0],
        root + scale[1], // b2 - the tension
        root + scale[2],
    ];

    // Sometimes add the tritone
    if (M.darkness > 0.3 && Math.random() > 0.5) {
        notes.push(root + 6); // tritone
    }

    notes.forEach((n, i) => {
        setTimeout(() => playDarkNote(n, M.beatTime * 4), i * 30);
    });
}

// ============ MICROPHONE CAPTURE ============

async function initMic() {
    try {
        micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        micSource = ctx.createMediaStreamSource(micStream);

        // Create buffer for granular
        micBuffer = ctx.createBuffer(1, MIC_BUFFER_SIZE, ctx.sampleRate);

        // Use ScriptProcessor to capture (AudioWorklet would be better but more complex)
        const processor = ctx.createScriptProcessor(4096, 1, 1);
        processor.onaudioprocess = (e) => {
            const input = e.inputBuffer.getChannelData(0);
            const buffer = micBuffer.getChannelData(0);

            for (let i = 0; i < input.length; i++) {
                buffer[micWritePos] = input[i];
                micWritePos = (micWritePos + 1) % MIC_BUFFER_SIZE;
            }
        };

        micSource.connect(processor);
        processor.connect(ctx.createGain()); // dummy connection to keep alive
    } catch (e) {
        console.log('Mic not available');
    }
}

function playGrain() {
    if (!micBuffer) return;

    const now = ctx.currentTime;
    const bufferData = micBuffer.getChannelData(0);

    // Find a loud section to grab
    let bestPos = 0, bestAmp = 0;
    for (let i = 0; i < 10; i++) {
        const pos = Math.floor(Math.random() * (MIC_BUFFER_SIZE - 4096));
        let amp = 0;
        for (let j = 0; j < 512; j++) {
            amp += Math.abs(bufferData[pos + j]);
        }
        if (amp > bestAmp) {
            bestAmp = amp;
            bestPos = pos;
        }
    }

    if (bestAmp < 10) return; // too quiet

    // Create grain
    const grainLen = 0.05 + Math.random() * 0.15;
    const grainSamples = Math.floor(grainLen * ctx.sampleRate);
    const grain = ctx.createBuffer(1, grainSamples, ctx.sampleRate);
    const grainData = grain.getChannelData(0);

    // Copy with envelope
    for (let i = 0; i < grainSamples; i++) {
        const env = Math.sin(Math.PI * i / grainSamples); // smooth envelope
        const srcIdx = (bestPos + i) % MIC_BUFFER_SIZE;
        grainData[i] = bufferData[srcIdx] * env;
    }

    // Play grain
    const source = ctx.createBufferSource();
    source.buffer = grain;

    // Random pitch shift (musical intervals)
    const pitchShifts = [0.5, 0.75, 1, 1, 1.5, 2];
    source.playbackRate.value = pitchShifts[Math.floor(Math.random() * pitchShifts.length)];

    const gain = ctx.createGain();
    gain.gain.value = 0.4;

    const filter = ctx.createBiquadFilter();
    filter.type = Math.random() > 0.5 ? 'lowpass' : 'bandpass';
    filter.frequency.value = 500 + Math.random() * 3000;
    filter.Q.value = 1 + Math.random() * 3;

    const pan = ctx.createStereoPanner();
    pan.pan.value = (Math.random() - 0.5) * 0.8;

    source.connect(filter);
    filter.connect(gain);
    gain.connect(pan);
    pan.connect(master);
    pan.connect(reverb);

    source.start(now);
}

// ============ BEAT ENGINE ============

function playKick() {
    const now = ctx.currentTime;

    // Sub oscillator
    const sub = ctx.createOscillator();
    sub.type = 'sine';
    sub.frequency.setValueAtTime(150, now);
    sub.frequency.exponentialRampToValueAtTime(40, now + 0.15);

    // Click
    const click = ctx.createOscillator();
    click.type = 'triangle';
    click.frequency.setValueAtTime(1000, now);
    click.frequency.exponentialRampToValueAtTime(100, now + 0.03);

    const subGain = ctx.createGain();
    const clickGain = ctx.createGain();
    const output = ctx.createGain();

    subGain.gain.setValueAtTime(0.8 * M.beatIntensity, now);
    subGain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

    clickGain.gain.setValueAtTime(0.5 * M.beatIntensity, now);
    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.05);

    output.gain.value = 0.7;

    sub.connect(subGain);
    click.connect(clickGain);
    subGain.connect(output);
    clickGain.connect(output);
    output.connect(master);

    sub.start(now);
    click.start(now);
    sub.stop(now + 0.4);
    click.stop(now + 0.1);
}

function playSnare() {
    const now = ctx.currentTime;

    // Noise burst
    const noiseLen = 0.15;
    const noise = ctx.createBuffer(1, ctx.sampleRate * noiseLen, ctx.sampleRate);
    const noiseData = noise.getChannelData(0);
    for (let i = 0; i < noiseData.length; i++) {
        noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.05));
    }

    const noiseSource = ctx.createBufferSource();
    noiseSource.buffer = noise;

    // Tone body
    const tone = ctx.createOscillator();
    tone.type = 'triangle';
    tone.frequency.value = 200;

    const noiseGain = ctx.createGain();
    const toneGain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 1000;

    noiseGain.gain.setValueAtTime(0.6 * M.beatIntensity, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);

    toneGain.gain.setValueAtTime(0.3 * M.beatIntensity, now);
    toneGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

    noiseSource.connect(filter);
    filter.connect(noiseGain);
    tone.connect(toneGain);
    noiseGain.connect(master);
    toneGain.connect(master);
    noiseGain.connect(reverb);

    noiseSource.start(now);
    tone.start(now);
    tone.stop(now + 0.15);
}

function playHat(open = false) {
    const now = ctx.currentTime;

    const len = open ? 0.2 : 0.05;
    const noise = ctx.createBuffer(1, ctx.sampleRate * len, ctx.sampleRate);
    const data = noise.getChannelData(0);
    for (let i = 0; i < data.length; i++) {
        data[i] = (Math.random() * 2 - 1);
    }

    const source = ctx.createBufferSource();
    source.buffer = noise;

    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 7000;

    gain.gain.setValueAtTime(0.25 * M.beatIntensity, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + len);

    source.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    source.start(now);
}

function updateBeat() {
    // Beat drops after 2 layers
    if (!M.beatDropped && M.layers.length >= 2) {
        M.beatDropped = true;
        M.beatIntensity = 0.3;
    }

    if (!M.beatDropped) return;

    // Intensity builds with layers
    const targetIntensity = 0.3 + M.layers.length * 0.2;
    M.beatIntensity += (targetIntensity - M.beatIntensity) * 0.01;
    M.beatIntensity = Math.min(1, M.beatIntensity);

    // Play beat elements based on playhead
    const beat = M.playhead;

    if (beat === 0 || beat === 4) playKick();
    if (beat === 2 || beat === 6) playSnare();
    if (M.beatIntensity > 0.5) {
        playHat(beat === 4);
    }
    if (M.beatIntensity > 0.7 && (beat === 3 || beat === 7)) {
        playKick(); // extra kicks at high intensity
    }
}

// ============ MEMORY SYSTEM ============

function snapshot() {
    return { x: F.x, y: F.y, speed: F.speed, density: F.density };
}

function updateMemory() {
    const now = ctx.currentTime;

    if (now - M.lastBeat >= M.beatTime) {
        M.lastBeat = now;

        if (M.mode === 'building') {
            M.tape.push(snapshot());
            if (M.tape.length >= M.loopLen) {
                M.mode = 'looping';
                M.playhead = 0;
            }
        } else {
            M.playhead = (M.playhead + 1) % M.loopLen;

            // Beat
            updateBeat();

            // Dark melodic events - clusters and tension
            if (M.playhead === 0 || M.playhead === 4) {
                // Cluster chords on downbeats
                if (F.speed > 0.15 || M.darkness > 0.3) {
                    playCluster();
                }
            }

            // Single dark notes on other beats
            if (M.playhead % 2 === 1 && F.speed > 0.2) {
                const scale = PHRYGIAN;
                const degree = scale[Math.floor((F.y + 1) * 3) % 7];
                const octave = Math.floor(F.x * 2 + 2) * 12;
                playDarkNote(degree + octave, M.beatTime * 3);
            }

            // Grains woven in
            if (M.playhead % 2 === 1 && F.speed > 0.1) {
                playGrain();
            }

            // Layer recording
            if (M.activeLayer) {
                M.activeLayer.push(snapshot());
                if (M.activeLayer.length >= M.loopLen) {
                    M.layers.push(M.activeLayer);
                    M.activeLayer = null;
                    if (M.layers.length > 3) M.layers.shift();
                }
            }
        }
    }
}

function getBlendedState() {
    if (M.mode === 'building' || M.tape.length === 0) {
        return { x: F.x, y: F.y, speed: F.speed };
    }

    const rec = M.tape[M.playhead];
    const live = 1 - M.blend;
    const loop = M.blend;

    let x = rec.x * loop + F.x * live;
    let y = rec.y * loop + F.y * live;
    let speed = rec.speed * loop + F.speed * live;

    M.layers.forEach((layer, li) => {
        const ls = layer[M.playhead];
        const w = 0.3 / (li + 1);
        x += ls.x * w;
        y += ls.y * w;
        speed += ls.speed * w;
    });

    return {
        x: Math.max(-1, Math.min(1, x)),
        y: Math.max(-1, Math.min(1, y)),
        speed: Math.min(1, speed)
    };
}

// ============ INPUT HANDLERS ============

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    F.vx = F.vx * 0.8 + (a.x || 0) * 0.02;
    F.vy = F.vy * 0.8 + (a.y || 0) * 0.02;
    F.vz = F.vz * 0.8 + (a.z || 0) * 0.02;

    F.speed = Math.min(1, Math.sqrt(F.vx*F.vx + F.vy*F.vy + F.vz*F.vz) / 3);
    F.density = F.density * 0.99 + F.speed * 0.01;
}

function onOrientation(e) {
    F.x = Math.max(-1, Math.min(1, (e.gamma || 0) / 45));
    F.y = Math.max(-1, Math.min(1, (e.beta || 0) / 45 - 1));
    F.field = (e.alpha || 0) / 360;
}

function onPointer(x, y) {
    const px = (x / window.innerWidth) * 2 - 1;
    const py = 1 - (y / window.innerHeight) * 2;

    F.vx = F.vx * 0.7 + (px - F.x) * 0.3;
    F.vy = F.vy * 0.7 + (py - F.y) * 0.3;

    F.x = px;
    F.y = py;

    F.speed = Math.min(1, Math.sqrt(F.vx*F.vx + F.vy*F.vy) * 3);
    F.density = F.density * 0.98 + F.speed * 0.02;
}

// ============ VISUALIZATION ============

let vc;
function initViz() {
    const canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const canvas = document.getElementById('c');
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

// Stage color palettes - each stage has its own vibe
const STAGE_COLORS = {
    0: { bg: [0, 0, 5], core: [180, 30, 30], ring: [200, 40, 20] },      // VOID - deep black, dim cyan
    1: { bg: [5, 5, 10], core: [200, 50, 40], ring: [180, 60, 30] },     // AWAKENING - emerging blue
    2: { bg: [10, 0, 15], core: [270, 60, 45], ring: [260, 50, 35] },    // DESCENT - purple tension
    3: { bg: [15, 0, 20], core: [300, 70, 35], ring: [280, 60, 30] },    // DEEP - deep magenta
    4: { bg: [10, 10, 20], core: [30, 80, 55], ring: [40, 70, 45] },     // EMERGENCE - golden hope
    5: { bg: [20, 20, 30], core: [50, 90, 70], ring: [60, 85, 60] }      // TRANSCEND - brilliant white-gold
};

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;
    const S = getBlendedState();
    const colors = STAGE_COLORS[J.stage];

    // Background - stage dependent, darkens during silence
    const silenceMult = ctx && ctx.currentTime < J.silenceUntil ? 0.3 : 1;
    vc.fillStyle = `rgba(${colors.bg[0] * silenceMult},${colors.bg[1] * silenceMult},${colors.bg[2] * silenceMult},${0.08 + (1-F.density) * 0.07})`;
    vc.fillRect(0, 0, w, h);

    const cx = w/2 + S.x * w * 0.25;
    const cy = h/2 - S.y * h * 0.25;
    const loopR = Math.min(w, h) * 0.4;

    // FRISSON PARTICLES - sparkles when frisson is high
    if (J.frisson > 0.2) {
        const numParticles = Math.floor(J.frisson * 50);
        for (let i = 0; i < numParticles; i++) {
            const angle = Math.random() * TAU;
            const dist = loopR * 0.3 + Math.random() * loopR * 0.8;
            const px = w/2 + Math.cos(angle) * dist;
            const py = h/2 + Math.sin(angle) * dist;
            const size = 1 + Math.random() * 3 * J.frisson;

            vc.beginPath();
            vc.arc(px, py, size, 0, TAU);
            vc.fillStyle = `rgba(255,255,${200 + Math.random() * 55},${J.frisson * 0.7})`;
            vc.fill();
        }
    }

    // TENSION WAVES - pulsing circles when tension builds
    if (J.tension > 0.3) {
        const numWaves = Math.floor(J.tension * 4);
        for (let i = 0; i < numWaves; i++) {
            const wavePhase = (F.phase * 0.5 + i * 0.25) % 1;
            const waveR = loopR * 0.5 + wavePhase * loopR * 0.7;
            vc.beginPath();
            vc.arc(w/2, h/2, waveR, 0, TAU);
            vc.strokeStyle = `rgba(${colors.ring[0]}, ${colors.ring[1]}%, ${colors.ring[2]}%, ${(1 - wavePhase) * J.tension * 0.3})`;
            vc.lineWidth = 2 + J.tension * 3;
            vc.stroke();
        }
    }

    // Outer loop ring
    if (M.tape.length > 0) {
        const progress = M.mode === 'building'
            ? M.tape.length / M.loopLen
            : (M.playhead + 1) / M.loopLen;

        vc.beginPath();
        vc.arc(w/2, h/2, loopR, -Math.PI/2, -Math.PI/2 + progress * Math.PI * 2);
        vc.strokeStyle = M.mode === 'building'
            ? 'rgba(255,100,100,0.4)'
            : `hsla(${colors.ring[0]}, ${colors.ring[1]}%, ${colors.ring[2]}%, 0.35)`;
        vc.lineWidth = M.beatDropped ? 4 + M.beatIntensity * 4 : 3;
        vc.stroke();
    }

    // Layer rings
    M.layers.forEach((_, i) => {
        vc.beginPath();
        vc.arc(w/2, h/2, loopR - 12 - i * 10, 0, Math.PI * 2);
        vc.strokeStyle = `hsla(${colors.ring[0]}, ${colors.ring[1]}%, ${colors.ring[2] + 10}%, ${0.15 + i * 0.08})`;
        vc.lineWidth = 2;
        vc.stroke();
    });

    // Recording ring
    if (M.activeLayer) {
        const recP = M.activeLayer.length / M.loopLen;
        vc.beginPath();
        vc.arc(w/2, h/2, loopR - 12 - M.layers.length * 10, -Math.PI/2, -Math.PI/2 + recP * Math.PI * 2);
        vc.strokeStyle = 'rgba(255,100,100,0.6)';
        vc.lineWidth = 3;
        vc.stroke();
    }

    // Beat pulse
    if (M.beatDropped) {
        const beatPulse = Math.sin(M.playhead * Math.PI / 4) * 0.5 + 0.5;
        vc.beginPath();
        vc.arc(w/2, h/2, loopR + 20 + beatPulse * 15 * M.beatIntensity, 0, Math.PI * 2);
        vc.strokeStyle = `rgba(255,200,100,${0.1 + beatPulse * 0.2 * M.beatIntensity})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Wall visualization - massive rings that pulse
    walls.forEach((wall, i) => {
        const amp = wall.output.gain.value;
        if (amp > 0.005) {
            const r = 50 + i * 40 + amp * 100;
            vc.beginPath();
            vc.arc(cx, cy, r, 0, Math.PI * 2);
            // Colors based on stage
            const hue = colors.core[0] - i * 15 + J.frisson * 30;
            vc.strokeStyle = `hsla(${hue}, ${colors.core[1] + 20}%, ${colors.core[2] + amp * 25}%, ${amp * 1.5})`;
            vc.lineWidth = 3 + amp * 10;
            vc.stroke();
        }
    });

    // ORBITAL VISUALIZATION - spinning lights
    orbitSounds.forEach((o, i) => {
        const orbitAmp = o.gain.gain.value;
        if (orbitAmp > 0.01) {
            const orbitR = loopR * 0.6 + i * 20;
            const ox = w/2 + Math.cos(o.angle) * orbitR;
            const oy = h/2 + Math.sin(o.angle) * orbitR;

            vc.beginPath();
            vc.arc(ox, oy, 4 + orbitAmp * 20, 0, TAU);
            vc.fillStyle = `hsla(${colors.core[0] + i * 30}, 70%, 60%, ${orbitAmp * 3})`;
            vc.fill();
        }
    });

    // Darkness fog creeping in
    if (M.darkness > 0.1) {
        const fogGr = vc.createRadialGradient(w/2, h/2, loopR * 0.5, w/2, h/2, loopR * 1.5);
        fogGr.addColorStop(0, 'transparent');
        fogGr.addColorStop(1, `rgba(20,0,30,${M.darkness * 0.4})`);
        vc.fillStyle = fogGr;
        vc.fillRect(0, 0, w, h);
    }

    // BINAURAL VISUALIZATION - subtle pulsing rings at breath rate
    if (binaural && J.stage > 0) {
        const binAmp = binaural.gainL.gain.value;
        if (binAmp > 0.01) {
            const binR = 80 + F.breath * 30;
            vc.beginPath();
            vc.arc(cx, cy, binR, 0, TAU);
            vc.strokeStyle = `rgba(100,150,255,${binAmp * 2})`;
            vc.lineWidth = 1 + F.breath * 2;
            vc.stroke();
        }
    }

    // Core - shifts color with stage
    const coreR = 30 + S.speed * 40 + J.frisson * 20;
    const gr = vc.createRadialGradient(cx, cy, 0, cx, cy, coreR);
    gr.addColorStop(0, `hsla(${colors.core[0]}, ${colors.core[1]}%, ${colors.core[2] + 20}%, ${0.5 + S.speed * 0.4 + J.frisson * 0.3})`);
    gr.addColorStop(0.5, `hsla(${colors.core[0] - 30}, ${colors.core[1] - 10}%, ${colors.core[2]}%, ${0.3 + S.speed * 0.2})`);
    gr.addColorStop(1, 'transparent');
    vc.fillStyle = gr;
    vc.beginPath();
    vc.arc(cx, cy, coreR, 0, Math.PI * 2);
    vc.fill();

    // GLITCH EFFECT - during high tension moments
    if (J.tension > 0.7 && Math.random() > 0.9) {
        const glitchH = 5 + Math.random() * 20;
        const glitchY = Math.random() * h;
        const glitchShift = (Math.random() - 0.5) * 30;

        // Slice and shift
        const imgData = vc.getImageData(0, glitchY, w, glitchH);
        vc.putImageData(imgData, glitchShift, glitchY);
    }

    // Mic activity indicator
    if (micBuffer) {
        const micLevel = micBuffer.getChannelData(0).slice(micWritePos - 512, micWritePos)
            .reduce((a, b) => a + Math.abs(b), 0) / 512;
        if (micLevel > 0.01) {
            vc.beginPath();
            vc.arc(cx, cy, coreR + 10 + micLevel * 50, 0, Math.PI * 2);
            vc.strokeStyle = `rgba(255,150,100,${micLevel * 2})`;
            vc.lineWidth = 2;
            vc.stroke();
        }
    }

    // STAGE INDICATOR - subtle text at bottom
    const stageNames = ['VOID', 'AWAKENING', 'DESCENT', 'DEEP', 'EMERGENCE', 'TRANSCEND'];
    vc.font = '10px system-ui';
    vc.fillStyle = `rgba(255,255,255,${0.1 + J.intensity * 0.2})`;
    vc.textAlign = 'center';
    vc.fillText(stageNames[J.stage], w/2, h - 30);
}

function updateUI() {
    // Stage names with emotional cues
    const stageNames = ['VOID', 'AWAKENING', 'DESCENT', 'DEEP', 'EMERGENCE', 'TRANSCEND'];
    let stageName = stageNames[J.stage];

    // Add tension/frisson indicators
    if (J.tension > 0.6) stageName += ' \u2191';  // tension rising
    if (J.frisson > 0.3) stageName += ' \u2728'; // sparkle for frisson

    document.getElementById('stage').textContent = stageName;
    document.getElementById('flw').textContent = F.speed.toFixed(2);
    document.getElementById('layers').textContent = M.layers.length + (M.activeLayer ? '+1' : '');

    // Journey time as MM:SS
    const mins = Math.floor(J.totalTime / 60);
    const secs = Math.floor(J.totalTime % 60);
    document.getElementById('journey').textContent = `${mins}:${secs.toString().padStart(2, '0')}`;
}

// ============ MAIN LOOP ============

function tick() {
    if (!running) return;

    F.phase += 0.01 * (1 + F.speed);

    // The journey evolves
    updateJourney();
    updateMemory();

    // Auto-start layer recording on significant movement
    if (M.mode === 'looping' && !M.activeLayer && F.speed > 0.35) {
        M.activeLayer = [];
    }

    // Update all sound layers
    updateWalls();
    updateTexture();
    updateBinaural();
    updateShimmer();
    updateWhisper();
    updateOrbits();

    draw();
    updateUI();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('start').classList.add('off');
    document.getElementById('app').classList.add('on');

    // Request permissions
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);
    document.addEventListener('mousemove', e => onPointer(e.clientX, e.clientY));
    document.addEventListener('touchmove', e => {
        e.preventDefault();
        onPointer(e.touches[0].clientX, e.touches[0].clientY);
    }, {passive: false});

    init();
    initViz();
    running = true;
    tick();
}

document.getElementById('go').addEventListener('click', start);
</script>
</body>
</html>
