<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Cinematic Void Engine</title>
  <script src="https://cdn.jsdelivr.net/npm/tone@14.7.77/build/Tone.js"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #1a1a1a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,107,53,0.7);
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #4a90e2 0%, rgba(74,144,226,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(74,144,226,0.7);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(155,89,182,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    .orb.recording {
      background: radial-gradient(circle, #ff0000 0%, rgba(255,0,0,0.4) 50%, transparent 80%);
      box-shadow: 0 0 100px rgba(255,0,0,0.8);
      animation: rec-pulse 0.5s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes rec-pulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.3); }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }
    
    .sample-indicator {
      position: fixed;
      top: 60px;
      left: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .sample-count {
      color: #ff6b35;
      font-weight: bold;
    }

    .synthesis-controls {
      position: fixed;
      bottom: 120px;
      left: 20px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
      z-index: 4;
    }

    .control-group {
      margin-bottom: 10px;
    }

    .control-label {
      font-size: 10px;
      margin-bottom: 5px;
      display: block;
    }

    .slider {
      width: 150px;
    }

    .mixer-panel {
      position: fixed;
      top: 100px;
      right: 20px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
      z-index: 4;
    }

    .layer-fader {
      display: flex;
      align-items: center;
      margin-bottom: 5px;
    }

    .fader-label {
      width: 60px;
      font-size: 10px;
    }

    .fader {
      width: 100px;
    }

    canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 1;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">TECHNIQUE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">SHEPARD TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="shepardBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">60</span></div>
      <div class="metric">KEY: <span id="keyDisplay">D MIN</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="sample-indicator">
      SAMPLES: <span class="sample-count" id="sampleCount">0</span>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>

  <canvas id="particleCanvas"></canvas>

  <div class="synthesis-controls" id="synthesisControls">
    <div class="control-group">
      <label class="control-label">Granular Density</label>
      <input type="range" id="granularDensity" min="0" max="1" step="0.01" value="0.5" class="slider">
    </div>
    <div class="control-group">
      <label class="control-label">Wavetable Position</label>
      <input type="range" id="wavetablePos" min="0" max="1" step="0.01" value="0" class="slider">
    </div>
    <div class="control-group">
      <label class="control-label">Additive Harmonics</label>
      <input type="range" id="additiveHarmonics" min="1" max="32" step="1" value="8" class="slider">
    </div>
    <div class="control-group">
      <label class="control-label">Subtractive Cutoff</label>
      <input type="range" id="subtractiveCutoff" min="20" max="20000" step="10" value="1000" class="slider">
    </div>
    <div class="control-group">
      <label class="control-label">Morph Factor</label>
      <input type="range" id="morphFactor" min="0" max="1" step="0.01" value="0.5" class="slider">
    </div>
  </div>

  <div class="mixer-panel" id="mixerPanel">
    <div class="layer-fader">
      <span class="fader-label">Kick</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.5">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Bass</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.4">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Hihat</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.15">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Snare</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.3">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Ostinato</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.25">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Harmony</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.2">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Pad</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.15">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Atmosphere</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.1">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Strings</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.3">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Brass</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.25">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Choir</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.2">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Shepard</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.15">
    </div>
    <div class="layer-fader">
      <span class="fader-label">Samples</span>
      <input type="range" class="fader" min="0" max="1" step="0.01" value="0.35">
    </div>
  </div>

  <script>
    class VoidEngine {
      constructor() {
        this.ctx = Tone.context;
        this.tone = Tone;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        this.bpm = 60;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D'];
        this.sectionLength = 32;
        
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.currentTechnique = 'waiting';
        
        this.currentTheme = 'awakening';
        this.themes = {
          awakening: { mood: 'mysterious', colors: ['#1a1a1a', '#2a2a2a'], text: 'The Journey Begins' },
          adventure: { mood: 'heroic', colors: ['#ff6b35', '#1a1a1a'], text: 'Into the Unknown' },
          tension: { mood: 'suspenseful', colors: ['#4a90e2', '#1a1a1a'], text: 'Rising Storm' },
          triumph: { mood: 'epic', colors: ['#9b59b6', '#e74c3c'], text: 'Epic Triumph' },
          reflection: { mood: 'serene', colors: ['#f39c12', '#1a1a1a'], text: 'Eternal Reflection' }
        };
        
        this.masterGain = null;
        this.limiter = null;
        this.layerVolumes = {};
        this.layerPanners = {};
        this.listener = null;
        this.reverb = null;
        this.delay = null;
        this.compressor = null;
        this.shepardVolume = null;
        this.ostinatoVolume = null;
        
        this.micStream = null;
        this.micSource = null;
        this.mediaRecorder = null;
        this.recording = false;
        this.recordedChunks = [];
        this.samples = [];
        this.maxSamples = 16;
        this.autoRecordCooldown = 0;
        this.recordingStartTime = 0;
        
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        this.shepardTones = []; 
        this.ostinatoPattern = [0, 2, 0, 5, 0, 3, 0, 7]; 
        this.ostinatoIndex = 0;
        this.shepardIntensity = 0;
        this.tensionBuildup = 0;
        
        this.synths = {};
        
        this.layers = {
          kick: false, bass: false, hihat: false, snare: false,
          ostinato: false, harmony: false, pad: false, atmosphere: false,
          strings: false, brass: false, choir: false, shepard: false,
          samples: false
        };
        
        this.key = 'D';
        this.scale = [0, 2, 3, 5, 7, 8, 10];
        this.chordProgression = [
          [0, 3, 7],    
          [10, 2, 5],   
          [5, 8, 0],    
          [7, 10, 2]    
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 293.66; 
        
        this.elements = {};
        this.spectrumBars = [];
        
        this.noise = null;
        
        this.synthesisParams = {
          granularDensity: 0.5,
          wavetablePos: 0,
          additiveHarmonics: 8,
          subtractiveCutoff: 1000,
          morphFactor: 0.5
        };

        this.particles = [];
        this.particleCanvas = null;
        this.particleCtx = null;

        this.coreVoidSound = null; // New core sound

        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'shepardBar', 'bpmDisplay',
         'keyDisplay', 'voiceCount', 'cinematicOverlay', 'themeText', 'spectrumViz',
         'sampleCount', 'synthesisControls', 'mixerPanel', 'particleCanvas']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupSpectrumVisualizer();
        this.setupSynthesisControls();
        this.setupMixerControls();
        this.setupParticleCanvas();
      }

      setupParticleCanvas() {
        this.particleCanvas = this.elements.particleCanvas;
        this.particleCtx = this.particleCanvas.getContext('2d');
        this.particleCanvas.width = window.innerWidth;
        this.particleCanvas.height = window.innerHeight;
        window.addEventListener('resize', () => {
          this.particleCanvas.width = window.innerWidth;
          this.particleCanvas.height = window.innerHeight;
        });
      }

      createParticles(count, color) {
        this.particles = [];
        for (let i = 0; i < count; i++) {
          this.particles.push({
            x: Math.random() * this.particleCanvas.width,
            y: this.particleCanvas.height + Math.random() * 50,
            size: Math.random() * 3 + 1,
            speed: Math.random() * 1 + 0.5,
            rotation: 0,
            opacity: 0,
            color: color || 'rgba(255,255,255,0.3)',
            delay: Math.random() * 5
          });
        }
      }

      animateParticles() {
        this.particleCtx.clearRect(0, 0, this.particleCanvas.width, this.particleCanvas.height);
        this.particles.forEach(p => {
          if (p.delay > 0) {
            p.delay -= 0.016;
            return;
          }
          p.y -= p.speed;
          p.rotation += 2;
          p.size += 0.01;
          if (p.opacity < 1 && p.y > this.particleCanvas.height * 0.9) p.opacity += 0.02;
          if (p.y < this.particleCanvas.height * 0.1) p.opacity -= 0.02;

          this.particleCtx.fillStyle = p.color.replace('0.3', p.opacity);
          this.particleCtx.beginPath();
          this.particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
          this.particleCtx.fill();

          if (p.y < -20 || p.opacity <= 0) {
            p.y = this.particleCanvas.height + 20;
            p.size = Math.random() * 3 + 1;
            p.opacity = 0;
            p.delay = Math.random() * 5;
          }
        });
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = (i * 12) + 'px';
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          if (e.alpha !== null) {
            this.orientation.alpha = e.alpha;
            this.orientation.beta = e.beta;
            this.orientation.gamma = e.gamma;
            this.updateListenerOrientation();
          }
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        this.listener.forwardX.setValueAtTime(forwardX, Tone.now());
        this.listener.forwardY.setValueAtTime(forwardY, Tone.now());
        this.listener.forwardZ.setValueAtTime(forwardZ, Tone.now());
        this.listener.upX.setValueAtTime(upX, Tone.now());
        this.listener.upY.setValueAtTime(upY, Tone.now());
        this.listener.upZ.setValueAtTime(upZ, Tone.now());
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              alert('Motion permission required for unraveling the void');
              return;
            }
          }

          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              alert('Orientation permission required for spatial unravel');
              return;
            }
          }

          await Tone.start();
          this.setupAudioChain();
          this.setupSynths();
          await this.setupMicrophone();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.startSequencer();
          this.animate();
          
        } catch (e) {
          console.error('Failed to start engine:', e);
          alert('Failed to initialize. Please try again and ensure microphone permission is granted.');
        }
      }

      setupSynths() {
        this.synths.kick = new Tone.MembraneSynth().connect(this.layerPanners.kick);
        this.synths.bass = new Tone.Synth({ oscillator: { type: 'sawtooth' } }).connect(this.layerPanners.bass);
        this.synths.hihat = new Tone.MetalSynth({ frequency: 8000 }).connect(this.layerPanners.hihat);
        this.synths.snare = new Tone.NoiseSynth({ noise: { type: 'white' } }).connect(this.layerPanners.snare);
        this.synths.ostinato = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8, oscillator: { type: 'sawtooth' } }).connect(this.layerPanners.ostinato);
        this.synths.harmony = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 12, oscillator: { type: 'sine' } }).connect(this.layerPanners.harmony);
        this.synths.pad = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 10, oscillator: { type: 'sine' } }).connect(this.layerPanners.pad);
        this.synths.atmosphere = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 6, oscillator: { type: 'sine' } }).connect(this.layerPanners.atmosphere);
        this.synths.strings = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 16, oscillator: { type: 'sawtooth' } }).connect(this.layerPanners.strings);
        this.synths.brass = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 8, oscillator: { type: 'sawtooth' } }).connect(this.layerPanners.brass);
        this.synths.choir = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 12, oscillator: { type: 'triangle' } }).connect(this.layerPanners.choir);
        this.synths.shepard = new Tone.PolySynth(Tone.Synth, { maxPolyphony: 6, oscillator: { type: 'sine' } }).connect(this.layerPanners.shepard);
        this.synths.samples = new Tone.Players().connect(this.layerPanners.samples);
      }

      setupAudioChain() {
        this.analyser = new Tone.Analyser('fft', 128);
        this.masterGain = new Tone.Volume(0).toDestination();
        this.limiter = new Tone.Limiter(-6).connect(this.masterGain);
        this.compressor = new Tone.Compressor({
          threshold: -24,
          knee: 16,
          ratio: 8,
          attack: 0.005,
          release: 0.15
        }).connect(this.limiter);
        
        this.reverb = new Tone.Reverb({
          decay: 6,
          preDelay: 0.2
        }).connect(this.limiter);
        
        this.delay = new Tone.PingPongDelay({
          delayTime: 0.375,
          feedback: 0.35,
          wet: 0.25
        }).connect(this.limiter);
        
        this.listener = Tone.Listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        this.listener.forwardX.value = 0;
        this.listener.forwardY.value = 0;
        this.listener.forwardZ.value = -1;
        this.listener.upX.value = 0;
        this.listener.upY.value = 1;
        this.listener.upZ.value = 0;

        const layerNames = ['kick', 'bass', 'hihat', 'snare', 'ostinato', 'harmony', 'pad', 'atmosphere', 'strings', 'brass', 'choir', 'shepard', 'samples'];
        layerNames.forEach(name => {
          this.layerPanners[name] = new Tone.Panner3D();
          this.layerPanners[name].connect(this.compressor);
        });
        
        this.setupProceduralNoise();
        this.setupCoreVoidSound();
        this.setLayerPositions();
      }

      setupCoreVoidSound() {
        this.coreVoidSound = new Tone.NoiseSynth({
          noise: {
            type: 'brown'
          },
          envelope: {
            attack: 2,
            decay: 0.5,
            sustain: 1,
            release: 2
          }
        }).connect(this.reverb);
        this.coreVoidSound.volume.value = -20; // Low volume for ambient core sound
        this.coreVoidSound.triggerAttack();
      }

      setupProceduralNoise() {
        this.noise = new Tone.Noise('pink');
        this.noiseFilter = new Tone.Filter(1000, 'bandpass', -24);
        this.noiseVolume = new Tone.Volume(-30).connect(this.layerPanners.atmosphere);
        this.noise.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseVolume);
        this.noise.start();
      }

      updateProceduralNoise(avgMotion, variance) {
        this.noiseFilter.frequency.value = 500 + avgMotion * 100 + variance * 50;
        this.noiseFilter.Q.value = 5 + variance * 2;
        this.noiseVolume.volume.value = -30 + (this.shepardIntensity * 10);
      }

      async setupMicrophone() {
        try {
          this.micStream = await navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: false,
              noiseSuppression: false,
              autoGainControl: false
            }
          });
          
          this.mediaRecorder = new MediaRecorder(this.micStream);
          this.mediaRecorder.ondataavailable = e => this.recordedChunks.push(e.data);
          this.mediaRecorder.onstop = () => this.processRecording();
          
        } catch (e) {
          console.error('Microphone setup failed:', e);
          alert('Microphone access denied or error. Please allow microphone permission to enable sampling.');
        }
      }

      startRecording() {
        if (this.recording || this.autoRecordCooldown > 0 || !this.mediaRecorder) return;
        
        this.recording = true;
        this.recordedChunks = [];
        this.recordingStartTime = Tone.now();
        this.mediaRecorder.start();
        
        this.elements.orb.classList.add('recording');
      }

      stopRecording() {
        if (!this.recording) return;
        
        this.recording = false;
        this.mediaRecorder.stop();
        
        this.elements.orb.classList.remove('recording');
        
        this.autoRecordCooldown = 60;
      }

      async processRecording() {
        const blob = new Blob(this.recordedChunks, { type: 'audio/webm' });
        const arrayBuffer = await blob.arrayBuffer();
        const audioBuffer = await this.ctx.decodeAudioData(arrayBuffer);
        
        if (audioBuffer.duration < 0.1) {
          return;
        }
        
        this.processSample(audioBuffer);
      }

      autoCorrelate(buffer) {
        const sampleRate = buffer.sampleRate;
        const data = buffer.getChannelData(0);
        const SIZE = data.length;
        const MAX_SAMPLES = Math.floor(SIZE / 2);
        let best_offset = -1;
        let best_correlation = 0;
        let rms = 0;

        for (let i = 0; i < SIZE; i++) {
          rms += data[i] * data[i];
        }
        rms = Math.sqrt(rms / SIZE);

        if (rms < 0.01) return -1;

        let lastCorrelation = 1;
        for (let offset = 20; offset < MAX_SAMPLES; offset++) {
          let correlation = 0;

          for (let i = 0; i < SIZE - offset; i++) {
            correlation += Math.abs(data[i] * data[i + offset]);
          }
          correlation = 1 - (correlation / SIZE);
          correlation = Math.abs(correlation);

          if (correlation > best_correlation) {
            best_correlation = correlation;
            best_offset = offset;
          }

          if (correlation > 0.9 && correlation > lastCorrelation) {
            break;
          }

          lastCorrelation = correlation;
        }

        if (best_correlation > 0.01) {
          return sampleRate / best_offset;
        }
        return -1;
      }

      async processSample(buffer) {
        try {
          const detectedPitch = this.autoCorrelate(buffer);
          
          let closestNote = 0;
          let closestDistance = Infinity;
          
          if (detectedPitch > 0) {
            for (let octave = 1; octave < 6; octave++) {
              for (let note of this.scale) {
                const noteFreq = this.noteToFreq(note, octave);
                const distance = Math.abs(Math.log(detectedPitch / noteFreq));
                if (distance < closestDistance) {
                  closestDistance = distance;
                  closestNote = note;
                }
              }
            }
          }
          
          const targetFreq = this.noteToFreq(closestNote, 3);
          const pitchShift = detectedPitch > 0 ? targetFreq / detectedPitch : 1;
          
          const beatDuration = 60 / this.bpm;
          const sampleDuration = buffer.duration;
          const beatsInSample = Math.round(sampleDuration / beatDuration);
          const targetDuration = beatsInSample * beatDuration;
          const alpha = targetDuration / sampleDuration;
          
          const synthesizedBuffer = await this.applyHybridSynthesis(buffer, pitchShift, alpha);

          const sample = {
            buffer: synthesizedBuffer,
            originalBuffer: buffer,
            pitchShift,
            detectedPitch,
            closestNote,
            originalDuration: sampleDuration,
            beatsInSample,
            volume: new Tone.Volume(0),
            panner: new Tone.Panner3D(),
            elevation: Math.random() * 5,
            distance: 2 + Math.random() * 8,
            lastBpm: this.bpm,
            player: null
          };
          
          sample.volume.connect(sample.panner);
          sample.panner.connect(this.layerVolumes.samples);
          
          this.samples.push(sample);
          if (this.samples.length > this.maxSamples) {
            const oldSample = this.samples.shift();
            if (oldSample.player) oldSample.player.dispose();
          }
          
          this.elements.sampleCount.textContent = this.samples.length;
          
          this.playSample(sample);
          
        } catch (e) {
          console.error('Sample processing failed:', e);
        }
      }

      async applyHybridSynthesis(buffer, pitchShift, alpha) {
        const stretched = await Tone.Offline(async () => {
          const player = new Tone.BufferSource(buffer);
          player.playbackRate = alpha;
          player.toDestination();
          player.start(0);
        }, buffer.duration / alpha);
        
        const toneBuffer = new Tone.Buffer(await stretched.toArray());

        const granular = new Tone.GrainPlayer({
          buffer: toneBuffer,
          grainSize: 0.05 + 0.1 * this.synthesisParams.granularDensity,
          overlap: 0.05,
          playbackRate: pitchShift,
          loop: true
        });

        const wtPartials = this.generateWavetableFromBuffer(toneBuffer.get(), this.synthesisParams.wavetablePos);

        const wavetable = new Tone.WaveTable(wtPartials);
        const wtSynth = new Tone.Synth({ oscillator: wavetable });

        const additivePartials = Array.from({ length: this.synthesisParams.additiveHarmonics }, (_, i) => 1 / (i + 1));
        const additive = new Tone.Synth({ oscillator: { partials: additivePartials } });

        const filter = new Tone.Filter(this.synthesisParams.subtractiveCutoff, 'lowpass');

        const ksBuffer = await this.karplusStrongSynthesis(toneBuffer.length());

        const morphed = await this.spectralMorph(toneBuffer.get(), ksBuffer, this.synthesisParams.morphFactor);

        const duration = morphed.duration;
        const rendered = await Tone.Offline(async offline => {
          const offlineSource = new Tone.BufferSource(morphed).start(0);
          offlineSource.connect(granular);
          granular.connect(wtSynth);
          wtSynth.connect(additive);
          additive.connect(filter);
          filter.toDestination();
        }, duration);

        return rendered.toAudioBuffer();
      }

      generateWavetableFromBuffer(buffer, position) {
        const length = 2048;
        const start = Math.floor(position * (buffer.length - length));
        const data = buffer;
        const wt = [];
        for (let i = 0; i < length; i++) {
          wt.push(data[start + i] || 0);
        }
        return wt;
      }

      async karplusStrongSynthesis(length) {
        const buffer = await Tone.Offline(() => {
          const noise = new Tone.Noise('white').start(0);
          const delay = new Tone.FeedbackDelay(1 / 440, 0.99);
          const lp = new Tone.Filter(1000, 'lowpass');
          noise.connect(delay);
          delay.connect(lp);
          lp.toDestination();
        }, length / Tone.context.sampleRate);

        return buffer.toAudioBuffer();
      }

      async spectralMorph(buffer1, buffer2, factor) {
        const length = Math.min(buffer1.length, buffer2.length);
        const morphed = new Float32Array(length);
        for (let i = 0; i < length; i++) {
          morphed[i] = buffer1[i] * (1 - factor) + buffer2[i] * factor;
        }
        const newBuffer = await Tone.context.createBuffer(1, length, Tone.context.sampleRate);
        newBuffer.copyToChannel(morphed, 0);
        return newBuffer;
      }

      updateSampleSynthesis() {
        this.samples.forEach(sample => {
          if (sample.player) {
            sample.player.grainSize = 0.05 + 0.1 * this.synthesisParams.granularDensity;
          }
        });
      }

      setupSynthesisControls() {
        ['granularDensity', 'wavetablePos', 'additiveHarmonics', 'subtractiveCutoff', 'morphFactor'].forEach(param => {
          const slider = document.getElementById(param);
          slider.addEventListener('input', (e) => {
            this.synthesisParams[param] = parseFloat(e.target.value);
            this.updateSampleSynthesis();
          });
        });
      }

      setupMixerControls() {
        const faders = this.elements.mixerPanel.querySelectorAll('.fader');
        const labels = this.elements.mixerPanel.querySelectorAll('.fader-label');
        Array.from(faders).forEach((fader, i) => {
          const layer = labels[i].textContent.toLowerCase();
          fader.addEventListener('input', (e) => {
            if (this.layerVolumes[layer]) {
              this.layerVolumes[layer].volume.value = Tone.gainToDb(parseFloat(e.target.value));
            }
          });
        });
      }

      playSample(sample) {
        if (sample.player) sample.player.dispose();
        
        sample.player = new Tone.GrainPlayer({
          url: new Tone.Buffer(sample.buffer),
          grainSize: 0.05 + 0.1 * this.synthesisParams.granularDensity,
          overlap: 0.05,
          playbackRate: sample.pitchShift,
          loop: true
        }).connect(sample.volume);
        
        sample.panner.setPosition(sample.pan || (Math.random() - 0.5) * 10, sample.elevation, -sample.distance);
        
        const duration = sample.beatsInSample * (60 / this.bpm);
        sample.player.start();
        sample.player.stop(`+${duration}`);
        
        sample.volume.volume.value = Tone.gainToDb(sample.gain || 0.7);
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.015;
          this.velocity.y += acc.y * 0.015;
          this.updatePosition();
          
          this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
          
          if (newMotion > 4 && Date.now() - this.lastStepTime > 250) {
            this.stepCounter++;
            this.lastStepTime = Date.now();
            this.syncBPMToSteps();
          }
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 100;
          const velocityY = (newY - lastMouse.y) / dt * 100;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.15;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          this.orientation.alpha = (newX / 100) * 360;
          this.orientation.beta = (newY - 50) * 1.8;
          this.orientation.gamma = 0;
          this.updateListenerOrientation();
          
          lastMouse = { x: newX, y: newY, time: now };
        });
        
        window.addEventListener('keydown', e => {
          if (!this.active) return;
          if (e.key === 'r' || e.key === 'R') {
            if (!this.recording) {
              this.startRecording();
            } else {
              this.stopRecording();
            }
          }
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.8 + newMotion * 0.2;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 150) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        if (!this.firstMovement && this.motion > 1.5) {
          this.firstMovement = true;
          this.evolveToTribal();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        const variance = this.intensity;
        const recentHistory = this.motionHistory.slice(-40);
        const isRhythmic = recentHistory.filter(m => m > 2.5).length > 20 && variance < 2;
        const isErratic = variance > 2.5 && avgMotion > 2;
        const isSustained = avgMotion > 2.5 && variance < 1.5;
        this.motionPattern = isErratic ? 'erratic' : isRhythmic ? 'rhythmic' : isSustained ? 'sustained' : 'calm';
        
        this.updateTechniques(avgMotion, variance);
        this.updateEvolution();
        
        this.updateProceduralNoise(avgMotion, variance);
        
        if (this.autoRecordCooldown > 0) {
          this.autoRecordCooldown--;
        } else {
          if ((isErratic && this.motion > 3) || 
              (isRhythmic && this.step % 16 === 0 && Math.random() < 0.3) ||
              (this.motionPattern === 'calm' && avgMotion < 0.5 && Math.random() < 0.1)) {
            this.startRecording();
          }
        }
      }

      updateTechniques(avgMotion, variance) {
        if (avgMotion > 2 && variance > 1.5) {
          this.shepardIntensity = Math.min(this.shepardIntensity + 0.02, 1);
          this.tensionBuildup = Math.min(this.tensionBuildup + 0.01, 1);
          this.currentTechnique = 'shepard-rising';
        } else if (avgMotion < 1) {
          this.shepardIntensity = Math.max(this.shepardIntensity - 0.01, 0);
          this.tensionBuildup = Math.max(this.tensionBuildup - 0.005, 0);
          this.currentTechnique = 'ostinato-calm';
        }
        
        this.buildPhase = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 2;
        this.releasePhase = this.motionPattern === 'calm' && this.totalMotion > 100;
        
        if (this.buildPhase) this.currentTechnique = 'build';
        if (this.releasePhase) this.currentTechnique = 'release';
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
      }

      syncBPMToSteps() {
        if (this.stepCounter < 4) return;
        
        const stepInterval = (Date.now() - this.lastStepTime * (this.stepCounter - 1)) / (this.stepCounter - 1);
        const targetBPM = 60 / (stepInterval / 1000) * 1.5;
        
        this.bpm = this.bpm * 0.6 + targetBPM * 0.4;
        this.bpm = Math.max(40, Math.min(180, this.bpm));
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        const activationThreshold = this.buildPhase ? 0.8 : 1.5;
        const deactivationThreshold = 0.6;
        
        this.layers.kick = avgMotion > activationThreshold || (this.layers.kick && avgMotion > deactivationThreshold);
        this.layers.bass = (avgMotion > 1.5 || (this.layers.bass && avgMotion > 0.8)) && (this.motionPattern !== 'calm');
        this.layers.hihat = (avgMotion > 2 || this.intensity > 1.5 || this.motionPattern === 'rhythmic');
        this.layers.snare = (avgMotion > 2.5 && this.intensity > 2) || (this.motionPattern === 'erratic');
        this.layers.ostinato = avgMotion > 1.2 && this.stage !== 'SILENCE';
        this.layers.harmony = (avgMotion > 3 || this.intensity > 2.5) && !this.releasePhase;
        this.layers.pad = avgMotion < 1.5 && this.totalMotion > 80 && this.releasePhase;
        this.layers.atmosphere = this.intensity < 1 && avgMotion < 1.5 && this.releasePhase;
        this.layers.strings = this.stage !== 'SILENCE' && avgMotion > 1.8;
        this.layers.brass = this.stage !== 'SILENCE' && this.intensity > 2.5 && this.buildPhase;
        this.layers.choir = this.stage === 'TRANSCENDENT' && avgMotion < 2 && this.releasePhase;
        this.layers.shepard = this.shepardIntensity > 0.1;
        this.layers.samples = this.samples.length > 0 && avgMotion > 0.5;
        
        this.evolutionProgress = Math.min(this.totalMotion / 1200, 3);
        this.subStage = Math.floor(this.evolutionProgress);
        
        if (this.stage === 'TRIBAL' && this.totalMotion > 300) {
          this.evolveToOrchestral();
        } else if (this.stage === 'ORCHESTRAL' && this.totalMotion > 700) {
          this.evolveToTranscendent();
        }
        
        let baseBPM = 60 + (avgMotion * 8) + (this.intensity * 5);
        baseBPM += (this.subStage * 15);
        if (this.stage === 'TRIBAL') baseBPM += 25;
        else if (this.stage === 'ORCHESTRAL') baseBPM += 45;
        else if (this.stage === 'TRANSCENDENT') baseBPM += 70;
        
        if (this.buildPhase) baseBPM *= 1.2;
        if (this.releasePhase) baseBPM *= 0.8;
        
        this.bpm = this.bpm * 0.85 + baseBPM * 0.15;
        this.bpm = Math.max(40, Math.min(180, this.bpm));
        
        this.updateCinematicTheme(avgMotion, this.intensity);
      }

      updateCinematicTheme(avgMotion, intensity) {
        let newTheme = 'awakening';
        if (avgMotion > 4 && intensity > 3 && this.buildPhase) newTheme = 'triumph';
        else if (avgMotion > 2.5 && intensity > 2) newTheme = 'tension';
        else if (avgMotion > 1.5) newTheme = 'adventure';
        else if (avgMotion < 1.5 && this.totalMotion > 150 && this.releasePhase) newTheme = 'reflection';
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.elements.themeText.textContent = this.themes[newTheme].text;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 4000);
        }
      }

      evolveToTribal() {
        this.stage = 'TRIBAL';
        this.elements.orb.classList.add('tribal');
        this.createParticles(40, 'rgba(255,107,53,0.3)');
      }

      evolveToOrchestral() {
        this.stage = 'ORCHESTRAL';
        this.elements.orb.classList.add('orchestral');
        this.createParticles(60, 'rgba(74,144,226,0.3)');
      }

      evolveToTranscendent() {
        this.stage = 'TRANSCENDENT';
        this.elements.orb.classList.add('transcendent');
        this.createParticles(80, 'rgba(155,89,182,0.3)');
      }

      startSequencer() {
        Tone.Transport.bpm.value = this.bpm;
        Tone.Transport.start();
        const loop = new Tone.Loop(time => {
          this.playStep(time);
          this.step = (this.step + 1) % this.sectionLength;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.updateHarmony();
          }
        }, "16n");

        loop.start(0);
      }

      playStep(time) {
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
        }
        
        if (this.layers.kick && this.step % 8 === 0) this.playKick(time);
        if (this.layers.bass && this.step % 4 === 0) this.playBass(time);
        if (this.layers.hihat && this.step % 2 === 1 && Math.random() < 0.7) this.playHihat(time);
        if (this.layers.snare && (this.step % 8 === 4 || (this.motionPattern === 'erratic' && this.step % 8 === 6 && Math.random() < 0.5))) this.playSnare(time);
        if (this.layers.ostinato && this.step % 2 === 0) this.playOstinato(time);
        if (this.layers.harmony && this.step % 16 === 0) this.playHarmony(time);
        if (this.layers.pad && this.step % 32 === 0 && this.releasePhase) this.playPad(time);
        if (this.layers.atmosphere && Math.random() < 0.03 && this.releasePhase) this.playAtmosphere(time);
        if (this.layers.strings && (this.step % 4 === 0 || this.buildPhase)) this.playStrings(time);
        if (this.layers.brass && this.step % 16 === 0 && this.buildPhase) this.playBrass(time);
        if (this.layers.choir && this.step % 32 === 0 && this.releasePhase) this.playChoir(time);
        if (this.layers.shepard && this.step % 8 === 0) this.playShepardTone(time);
        if (this.layers.samples && this.step % 4 === 0) this.triggerSamples(time);
      }

      triggerSamples(time) {
        this.samples.forEach(sample => {
          if (this.step % (sample.beatsInSample * 4) === 0 && Math.random() < 0.3 + this.motion * 0.1) {
            if (Math.abs(this.bpm - sample.lastBpm) > 5) {
              const alpha = (60 / this.bpm) / (60 / sample.lastBpm);
              sample.player.playbackRate = sample.pitchShift * alpha;
              sample.lastBpm = this.bpm;
            }
            sample.player.start(time);
          }
        });
      }

      playKick(time) {
        this.synths.kick.triggerAttackRelease('C1', '8n', time, 0.9);
      }

      playBass(time) {
        const note = Tone.Midi(this.bassNote + 24).toFrequency();
        this.synths.bass.triggerAttackRelease(note, '8n', time, 0.8);
      }

      playHihat(time) {
        this.synths.hihat.triggerAttackRelease('16n', time, 0.4);
      }

      playSnare(time) {
        this.synths.snare.triggerAttackRelease('16n', time, 0.6);
      }

      playOstinato(time) {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const note = Tone.Midi(noteIndex + 72).toNote();
        this.synths.ostinato.triggerAttackRelease(note, '8n', time, 0.6);
        this.ostinatoIndex++;
      }

      playHarmony(time) {
        const chord = this.chordProgression[this.currentChordIndex].map(interval => Tone.Midi(interval + 60).toNote());
        this.synths.harmony.triggerAttackRelease(chord, '1m', time, 0.2);
      }

      playPad(time) {
        const notes = this.scale.filter((_, i) => i % 2 === 0).map(note => Tone.Midi(note + 48).toNote());
        this.synths.pad.triggerAttackRelease(notes, '2m', time, 0.1);
      }

      playAtmosphere(time) {
        const note = Tone.Midi(this.scale[Math.floor(Math.random() * this.scale.length)] + 84).toFrequency();
        this.synths.atmosphere.triggerAttackRelease(note, '4m', time, 0.08);
      }

      playStrings(time) {
        const note = Tone.Midi(this.generativeMelody[this.step % this.melodyLength] + 60).toNote();
        this.synths.strings.triggerAttackRelease(note, '8n', time, 0.15);
      }

      playBrass(time) {
        const note = Tone.Midi(this.scale[Math.floor(this.scale.length / 2)] + 60).toNote();
        this.synths.brass.triggerAttackRelease(note, '1m', time, 0.4);
      }

      playChoir(time) {
        const chord = this.chordProgression[this.currentChordIndex].map(interval => Tone.Midi(interval + 72).toNote());
        this.synths.choir.triggerAttackRelease(chord, '2m', time, 0.12);
      }

      playShepardTone(time) {
        const baseFreq = 220;
        const shepardLayers = 6;
        
        for (let i = 0; i < shepardLayers; i++) {
          const freq = baseFreq * Math.pow(2, i);
          this.synths.shepard.triggerAttackRelease(freq, '1m', time, this.shepardIntensity / shepardLayers);
        }
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
      }

      noteToFreq(note, octave = 4) {
        return 293.66 * Math.pow(2, (note - 2) / 12 + (octave - 4));
      }

      updateUI() {
        this.elements.stageName.textContent = this.stage;
        this.elements.technique.textContent = this.currentTechnique.toUpperCase();
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = this.key + ' MIN';
        
        const motionPercent = Math.min((this.motion + this.intensity) * 10, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        const shepardPercent = this.shepardIntensity * 100;
        this.elements.shepardBar.style.width = shepardPercent + '%';
        
        const totalVoices = Object.values(this.synths).reduce((sum, synth) => sum + (synth.numberOfVoices ? synth.numberOfVoices : 1), 0);
        this.elements.voiceCount.textContent = totalVoices;
        
        if (this.analyser) {
          const values = this.analyser.getValue();
          this.spectrumBars.forEach((bar, i) => {
            const height = Math.max(0, (values[i] + 100) / 100 * 80);
            bar.style.height = height + 'px';
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          const theme = this.themes[this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 4, 1);
          const motionNorm = Math.min(this.motion / 6, 1);
          
          let bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
          bg += `${theme.colors[0]} ${5 * motionNorm}%, `;
          if (theme.colors[1]) bg += `${theme.colors[1]} ${20 * intensityNorm}%, `;
          bg += `#0a0a0a ${60 + 30 * intensityNorm}%`;
          bg += ')';
          
          document.body.style.background = bg;
          
          this.elements.cinematicOverlay.classList.toggle('active', this.buildPhase || this.intensity > 2);
          
          this.animateParticles();
          
          requestAnimationFrame(loop);
        };
        loop();
      }
    }

    new VoidEngine();
  </script>
</body>
</html>
