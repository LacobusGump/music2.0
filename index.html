<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
        }

        .orb {
            position: fixed;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 20px rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 10;
        }

        .orb.pulse {
            animation: pulse 0.15s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2.5); box-shadow: 0 0 40px rgba(255,255,255,0.8); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,0,0,0.9) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 30px rgba(255,0,0,0.8);
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>

    <script>
        'use strict';

        // AI Agent - Optimized
        class AI {
            constructor() {
                this.key = [0, 2, 3, 5, 7, 8, 10]; // A minor
                this.confidence = { pitch: 0, rhythm: 0 };
            }

            analyze(buffer, sr) {
                const data = buffer.getChannelData(0);
                const len = data.length;
                
                // RMS
                let rms = 0;
                for (let i = 0; i < len; i++) rms += data[i] * data[i];
                rms = Math.sqrt(rms / len);
                
                // ZCR
                let zcr = 0;
                for (let i = 1; i < len; i++) {
                    if ((data[i] >= 0) !== (data[i-1] >= 0)) zcr++;
                }
                zcr = zcr / (len / sr);
                
                // Pitch
                const pitch = this.getPitch(data, sr);
                
                // Spectral centroid
                let weighted = 0, sum = 0;
                for (let i = 0; i < len; i++) {
                    const mag = Math.abs(data[i]);
                    weighted += mag * (i / len * sr / 2);
                    sum += mag;
                }
                const centroid = sum > 0 ? weighted / sum : 0;
                
                // Classify
                let type = 'texture';
                if (rms > 0.1 && centroid < 200 && buffer.duration < 0.5) type = 'kick';
                else if (zcr > 2000 && zcr < 6000 && centroid > 200) type = 'snare';
                else if (centroid > 6000 && buffer.duration < 0.1) type = 'hats';
                else if (pitch && pitch < 200 && buffer.duration > 0.5) type = 'bass';
                else if (pitch && pitch > 200 && pitch < 1000) type = 'melody';
                
                return { type, pitch, rms, zcr, centroid };
            }

            getPitch(data, sr) {
                if (data.length < 512) return null;
                
                const maxLag = Math.min(data.length >> 1, 2000);
                const minLag = Math.floor(sr / 2000);
                
                let maxCorr = 0, bestLag = -1;
                
                for (let lag = minLag; lag < maxLag; lag++) {
                    let corr = 0;
                    for (let i = 0; i < data.length - lag; i++) {
                        corr += data[i] * data[i + lag];
                    }
                    if (corr > maxCorr) {
                        maxCorr = corr;
                        bestLag = lag;
                    }
                }
                
                const norm = Math.sqrt(data.reduce((s, x) => s + x * x, 0));
                this.confidence.pitch = norm > 0 ? maxCorr / (norm * norm) : 0;
                
                return this.confidence.pitch > 0.3 ? sr / bestLag : null;
            }

            tune(freq) {
                if (!freq) return 1;
                const midi = 69 + 12 * Math.log2(freq / 440);
                const note = Math.round(midi);
                const oct = Math.floor(note / 12);
                const deg = note % 12;
                
                let closest = this.key[0];
                let min = Math.abs(deg - closest);
                
                for (const k of this.key) {
                    const d = Math.abs(deg - k);
                    if (d < min) {
                        min = d;
                        closest = k;
                    }
                }
                
                const target = 440 * Math.pow(2, (oct * 12 + closest - 69) / 12);
                return target / freq;
            }

            pattern(type, step, intensity) {
                const patterns = {
                    kick: [0, 10, 16, 26],
                    snare: [8, 24],
                    hats: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
                    bass: [0, 3, 8, 11, 16, 19, 24, 27],
                    melody: [6, 14, 22, 30],
                    texture: [0, 16]
                };
                
                const p = patterns[type] || [];
                if (type === 'hats' && intensity < 0.3) {
                    return p.filter((_, i) => i % 4 === 2).includes(step) ? 0.4 : 0;
                }
                if (type === 'snare' && p.includes(step)) return 0.9;
                if (type === 'melody' && p.includes(step)) return Math.random() < intensity ? 0.6 : 0;
                
                return p.includes(step) ? 0.8 : 0;
            }
        }

        // Engine - Optimized
        class Engine {
            constructor() {
                this.ctx = null;
                this.ai = new AI();
                this.nodes = {};
                this.samples = new Map();
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, bpm: 85 };
                this.intensity = 0.3;
                this.orb = document.getElementById('orb');
                
                document.addEventListener('click', () => this.start());
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext();
                    
                    // Audio chain
                    this.nodes.out = this.ctx.createGain();
                    this.nodes.comp = this.ctx.createDynamicsCompressor();
                    this.nodes.comp.threshold.value = -12;
                    this.nodes.comp.ratio.value = 4;
                    
                    this.nodes.out.connect(this.nodes.comp);
                    this.nodes.comp.connect(this.ctx.destination);
                    
                    // Layers
                    ['kick', 'snare', 'hats', 'bass', 'melody', 'texture'].forEach(t => {
                        this.nodes[t] = this.ctx.createGain();
                        this.nodes[t].gain.value = {kick: 1, snare: 0.8, hats: 0.4, bass: 0.9, melody: 0.6, texture: 0.5}[t];
                        this.nodes[t].connect(this.nodes.out);
                        this.samples.set(t, []);
                    });
                    
                    // Create drums
                    await this.createDrums();
                    
                    // Mic
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.rec = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.nodes.rec.onaudioprocess = e => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            if (this.buffer.length > this.ctx.sampleRate * 3) this.stopRec();
                        }
                    };
                    
                    // Start
                    this.loop();
                    this.seq.last = this.ctx.currentTime;
                    requestAnimationFrame(() => this.tick());
                    
                    // Keys
                    document.onkeydown = e => {
                        if (e.key === ' ') this.toggle();
                        else if (e.key === 'ArrowUp') this.intensity = Math.min(1, this.intensity + 0.1);
                        else if (e.key === 'ArrowDown') this.intensity = Math.max(0, this.intensity - 0.1);
                    };
                    
                    // Motion
                    let last = { x: 0.5, y: 0.5 };
                    document.onmousemove = e => {
                        const x = e.clientX / window.innerWidth;
                        const y = e.clientY / window.innerHeight;
                        const vel = Math.sqrt(Math.pow(x - last.x, 2) + Math.pow(y - last.y, 2));
                        this.intensity = this.intensity * 0.9 + vel * 2;
                        last = { x, y };
                    };
                    
                } catch (e) {
                    console.error(e);
                }
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.rec);
                    this.nodes.rec.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.rec);
                this.nodes.rec.disconnect();
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > 0) {
                    const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    buf.getChannelData(0).set(this.buffer);
                    
                    const analysis = this.ai.analyze(buf, this.ctx.sampleRate);
                    const sample = {
                        buffer: buf,
                        rate: analysis.pitch ? this.ai.tune(analysis.pitch) : 1
                    };
                    
                    const list = this.samples.get(analysis.type);
                    if (list.length >= 3) list.shift();
                    list.push(sample);
                }
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // 808 Kick
                const kick = this.ctx.createBuffer(2, sr * 0.8, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const d = kick.getChannelData(ch);
                    for (let i = 0; i < d.length; i++) {
                        const t = i / sr;
                        const env = t < 0.01 ? t / 0.01 : Math.exp(-2.5 * (t - 0.01));
                        const pitch = 50 * Math.exp(-35 * t) + 25;
                        let s = Math.sin(2 * Math.PI * pitch * t) * 0.8;
                        s += Math.sin(4 * Math.PI * pitch * t) * 0.15 * Math.exp(-50 * t);
                        if (t < 0.005) s += (Math.random() * 2 - 1) * 0.3 * (1 - t / 0.005);
                        d[i] = Math.tanh(s * 1.5) * env;
                    }
                }
                
                // Snare
                const snare = this.ctx.createBuffer(2, sr * 0.25, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const d = snare.getChannelData(ch);
                    for (let i = 0; i < d.length; i++) {
                        const t = i / sr;
                        const env = (t < 0.003 ? t / 0.003 : 1) * Math.exp(-12 * t);
                        const tone = Math.sin(2 * Math.PI * 220 * t) * 0.3;
                        const noise = (Math.random() * 2 - 1) * 0.5;
                        d[i] = Math.tanh((tone * Math.exp(-15 * t) + noise * Math.exp(-8 * t)) * 2) * 0.8 * env;
                    }
                }
                
                // Hat
                const hat = this.ctx.createBuffer(2, sr * 0.08, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const d = hat.getChannelData(ch);
                    for (let i = 0; i < d.length; i++) {
                        const t = i / sr;
                        let s = 0;
                        [6000, 8000, 10000, 12000].forEach((f, j) => {
                            s += Math.sin(2 * Math.PI * f * t) * (0.2 / (j + 1));
                        });
                        d[i] = (s + (Math.random() * 2 - 1) * 0.3) * Math.exp(-80 * t) * 0.6;
                    }
                }
                
                // Sub
                const sub = this.ctx.createBuffer(2, sr * 2, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const d = sub.getChannelData(ch);
                    for (let i = 0; i < d.length; i++) {
                        const t = i / sr;
                        const env = Math.min(1, t / 0.01) * (t > 1.8 ? Math.max(0, 1 - (t - 1.8) / 0.2) : 1);
                        d[i] = Math.sin(2 * Math.PI * 55 * t) * env * 0.7;
                    }
                }
                
                // Add to samples
                this.samples.get('kick').push({ buffer: kick, rate: 1 });
                this.samples.get('snare').push({ buffer: snare, rate: 1 });
                this.samples.get('hats').push({ buffer: hat, rate: 1 });
                this.samples.get('bass').push({ buffer: sub, rate: 1 });
            }

            tick() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.seq.bpm / 4;
                
                if (now >= this.seq.last + beat) {
                    this.seq.last = now;
                    
                    // Pulse on beat
                    if (this.seq.step % 4 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 150);
                    }
                    
                    // Play patterns
                    ['kick', 'snare', 'hats', 'bass', 'melody', 'texture'].forEach(type => {
                        const vel = this.ai.pattern(type, this.seq.step, this.intensity);
                        if (vel > 0) this.play(type, vel);
                    });
                    
                    this.seq.step = (this.seq.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            play(type, vel) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                const sample = samples[Math.floor(Math.random() * samples.length)];
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate * (1 + (Math.random() - 0.5) * 0.01);
                gain.gain.value = vel * 0.8;
                
                src.connect(gain);
                gain.connect(this.nodes[type]);
                src.start();
            }

            loop() {
                // Auto-sample detection
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                
                setInterval(() => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    const avg = data.reduce((a, b) => a + b) / data.length / 255;
                    
                    if (avg > 0.02) {
                        // Check spectral variance
                        let variance = 0;
                        for (let i = 1; i < data.length; i++) {
                            variance += Math.abs(data[i] - data[i-1]);
                        }
                        
                        if (variance > 1000) {
                            this.toggle();
                            cooldown = 100; // 2 second cooldown
                        }
                    }
                }, 20);
            }
        }

        new Engine();
    </script>
</body>
</html>
