<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black">
<title>VOID ENGINE</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  user-select: none;
}

body {
  background: #000;
  color: #fff;
  overflow: hidden;
  touch-action: none;
  height: 100vh;
  width: 100vw;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, monospace;
  display: flex;
  align-items: center;
  justify-content: center;
  position: fixed;
}

.start-screen {
  text-align: center;
  z-index: 100;
  transition: opacity 1s ease;
}

.start-btn {
  width: 150px;
  height: 150px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
  border: 2px solid rgba(255,255,255,0.3);
  color: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 14px;
  letter-spacing: 2px;
  animation: pulse 3s ease-in-out infinite;
  backdrop-filter: blur(10px);
  -webkit-backdrop-filter: blur(10px);
}

@keyframes pulse {
  0%, 100% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.05); opacity: 1; }
}

.hidden {
  opacity: 0;
  pointer-events: none;
}

.orb {
  position: fixed;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: all 0.3s ease;
  pointer-events: none;
  z-index: 10;
}

.orb.pulse {
  animation: orbPulse 0.2s ease-out;
}

@keyframes orbPulse {
  0% { transform: translate(-50%, -50%) scale(1); }
  50% { transform: translate(-50%, -50%) scale(1.5); }
  100% { transform: translate(-50%, -50%) scale(1); }
}

.orb.evolve {
  background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, rgba(255,255,255,0.2) 50%, transparent 80%);
  box-shadow: 0 0 60px rgba(0,255,255,0.6);
}

.info {
  position: fixed;
  top: 20px;
  left: 20px;
  font-size: 11px;
  opacity: 0.7;
  z-index: 50;
  line-height: 1.4;
}

.status {
  position: fixed;
  bottom: 20px;
  right: 20px;
  font-size: 10px;
  opacity: 0.5;
  text-align: right;
  z-index: 50;
}

.instruction {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 12px;
  opacity: 0;
  transition: opacity 2s ease;
  text-align: center;
  margin-top: 60px;
  letter-spacing: 1px;
  pointer-events: none;
}

.instruction.show {
  opacity: 0.7;
}

.viz {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 80px;
  display: flex;
  align-items: flex-end;
  justify-content: space-around;
  pointer-events: none;
  z-index: 5;
}

.viz-bar {
  width: 2%;
  background: linear-gradient(0deg, rgba(255,255,255,0.6), transparent);
  transition: height 0.1s ease;
  opacity: 0.7;
}
</style>
</head>
<body>
<div class="start-screen" id="startScreen">
  <div class="start-btn" id="startBtn">ENTER</div>
</div>

<div class="orb" id="orb"></div>

<div class="info" id="info">
  <div>PHASE: <span id="phase">VOID</span></div>
  <div>ENERGY: <span id="energy">0</span>%</div>
  <div>BPM: <span id="bpm">60</span></div>
</div>

<div class="status" id="status">
  <div id="voices">VOICES: 0</div>
  <div id="motion">MOTION: 0</div>
</div>

<div class="instruction" id="instruction">MOVE TO CREATE</div>

<div class="viz" id="viz"></div>

<script>
'use strict';

class VoidEngine {
  constructor() {
    this.ctx = null;
    this.active = false;
    
    // Core parameters
    this.motion = 0;
    this.energy = 0;
    this.phase = 'VOID';
    this.bpm = 60;
    this.step = 0;
    
    // Audio nodes
    this.masterGain = null;
    this.compressor = null;
    this.filter = null;
    this.reverb = null;
    this.analyser = null;
    
    // Voice management
    this.maxVoices = 12; // Reduced for mobile
    this.activeVoices = [];
    
    // Motion tracking
    this.lastMotion = { x: 0, y: 0, z: 0 };
    this.motionHistory = [];
    this.touchActive = false;
    
    // Musical state
    this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
    this.root = 220; // A3
    this.chordIndex = 0;
    this.chords = [[0,2,4], [3,5,0], [1,3,5], [4,0,2]];
    
    // Layers
    this.layers = {
      bass: false,
      melody: false,
      pad: false,
      percussion: false
    };
    
    // Visual
    this.vizBars = [];
    this.freqData = null;
    
    this.init();
  }
  
  init() {
    // Setup UI
    document.getElementById('startBtn').onclick = () => this.start();
    
    // Create visualizer bars
    const viz = document.getElementById('viz');
    for (let i = 0; i < 32; i++) {
      const bar = document.createElement('div');
      bar.className = 'viz-bar';
      viz.appendChild(bar);
      this.vizBars.push(bar);
    }
    
    // Setup motion detection
    this.setupMotion();
  }
  
  setupMotion() {
    // Device motion for mobile
    if (window.DeviceMotionEvent) {
      window.addEventListener('devicemotion', (e) => {
        if (!this.active) return;
        
        const acc = e.accelerationIncludingGravity || e.acceleration;
        if (acc && acc.x !== null) {
          const mag = Math.sqrt(
            Math.pow(acc.x - this.lastMotion.x, 2) +
            Math.pow(acc.y - this.lastMotion.y, 2) +
            Math.pow(acc.z - this.lastMotion.z, 2)
          );
          
          this.updateMotion(mag * 0.5);
          this.lastMotion = { x: acc.x, y: acc.y, z: acc.z };
        }
      });
    }
    
    // Touch/mouse fallback
    let lastTouch = { x: 0, y: 0, time: 0 };
    
    const handleMove = (x, y) => {
      if (!this.active) return;
      
      const now = Date.now();
      const dt = Math.max(1, now - lastTouch.time);
      const dx = x - lastTouch.x;
      const dy = y - lastTouch.y;
      const speed = Math.sqrt(dx * dx + dy * dy) / dt;
      
      this.updateMotion(speed * 5);
      lastTouch = { x, y, time: now };
    };
    
    window.addEventListener('touchmove', (e) => {
      e.preventDefault();
      this.touchActive = true;
      handleMove(e.touches[0].clientX, e.touches[0].clientY);
    }, { passive: false });
    
    window.addEventListener('touchend', () => {
      this.touchActive = false;
    });
    
    window.addEventListener('mousemove', (e) => {
      handleMove(e.clientX, e.clientY);
    });
  }
  
  updateMotion(value) {
    this.motion = this.motion * 0.7 + value * 0.3;
    this.motionHistory.push(this.motion);
    if (this.motionHistory.length > 30) this.motionHistory.shift();
    
    // Update energy
    const avg = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
    this.energy = Math.min(100, avg * 10);
    
    // Phase transitions
    if (this.energy > 75 && this.phase !== 'CHAOS') {
      this.evolve('CHAOS');
    } else if (this.energy > 50 && this.phase === 'VOID') {
      this.evolve('FLOW');
    } else if (this.energy > 25 && this.phase === 'VOID') {
      this.evolve('AWAKE');
    } else if (this.energy < 10 && this.phase !== 'VOID') {
      this.evolve('VOID');
    }
    
    // Update BPM
    this.bpm = 60 + this.energy * 1.2;
    
    // Update layers
    this.layers.bass = this.energy > 20;
    this.layers.melody = this.energy > 35;
    this.layers.pad = this.energy > 15 && this.energy < 60;
    this.layers.percussion = this.energy > 40;
  }
  
  evolve(newPhase) {
    this.phase = newPhase;
    document.getElementById('phase').textContent = newPhase;
    
    const orb = document.getElementById('orb');
    if (newPhase === 'CHAOS') {
      orb.classList.add('evolve');
    } else {
      orb.classList.remove('evolve');
    }
    
    // Show instruction
    const instruction = document.getElementById('instruction');
    const messages = {
      'VOID': 'MOVE TO CREATE',
      'AWAKE': 'RHYTHM EMERGING',
      'FLOW': 'HARMONY FOUND',
      'CHAOS': 'TRANSCENDENCE'
    };
    instruction.textContent = messages[newPhase];
    instruction.classList.add('show');
    setTimeout(() => instruction.classList.remove('show'), 3000);
  }
  
  async start() {
    try {
      // Request permissions for iOS
      if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        await DeviceMotionEvent.requestPermission();
      }
      
      // Create audio context
      this.ctx = new (window.AudioContext || window.webkitAudioContext)();
      await this.ctx.resume();
      
      // Setup audio chain
      this.setupAudio();
      
      // Hide start screen
      document.getElementById('startScreen').classList.add('hidden');
      
      // Start engine
      this.active = true;
      this.startSequencer();
      this.animate();
      
      // Initial instruction
      setTimeout(() => {
        document.getElementById('instruction').classList.add('show');
        setTimeout(() => document.getElementById('instruction').classList.remove('show'), 4000);
      }, 1000);
      
    } catch (e) {
      console.error('Start failed:', e);
      alert('Please allow motion access and try again');
    }
  }
  
  setupAudio() {
    // Create main audio chain
    this.masterGain = this.ctx.createGain();
    this.masterGain.gain.value = 0.7;
    
    this.compressor = this.ctx.createDynamicsCompressor();
    this.compressor.threshold.value = -24;
    this.compressor.knee.value = 30;
    this.compressor.ratio.value = 12;
    this.compressor.attack.value = 0.003;
    this.compressor.release.value = 0.25;
    
    this.filter = this.ctx.createBiquadFilter();
    this.filter.type = 'lowpass';
    this.filter.frequency.value = 5000;
    this.filter.Q.value = 1;
    
    // Simple reverb using delay
    this.reverb = this.ctx.createDelay(0.5);
    this.reverb.delayTime.value = 0.05;
    const reverbGain = this.ctx.createGain();
    reverbGain.gain.value = 0.3;
    const reverbFeedback = this.ctx.createGain();
    reverbFeedback.gain.value = 0.5;
    
    this.reverb.connect(reverbFeedback);
    reverbFeedback.connect(this.reverb);
    this.reverb.connect(reverbGain);
    
    // Analyzer for visualization
    this.analyser = this.ctx.createAnalyser();
    this.analyser.fftSize = 64;
    this.freqData = new Uint8Array(this.analyser.frequencyBinCount);
    
    // Connect chain
    this.compressor.connect(this.filter);
    this.filter.connect(this.masterGain);
    this.masterGain.connect(this.analyser);
    this.analyser.connect(this.ctx.destination);
    
    // Reverb send
    this.filter.connect(reverbGain);
    reverbGain.connect(this.ctx.destination);
  }
  
  startSequencer() {
    const sequence = () => {
      if (!this.active) return;
      
      // Trigger sounds based on step
      if (this.step % 4 === 0) {
        document.getElementById('orb').classList.add('pulse');
        setTimeout(() => document.getElementById('orb').classList.remove('pulse'), 200);
        
        if (this.layers.bass) this.playBass();
        if (this.layers.percussion) this.playKick();
      }
      
      if (this.step % 8 === 4 && this.layers.percussion) {
        this.playSnare();
      }
      
      if (this.step % 2 === 0 && this.layers.melody) {
        this.playMelody();
      }
      
      if (this.step % 16 === 0) {
        if (this.layers.pad) this.playPad();
        this.chordIndex = (this.chordIndex + 1) % this.chords.length;
      }
      
      this.step++;
      
      // Schedule next step
      const interval = 60000 / (this.bpm * 4); // 16th notes
      setTimeout(sequence, interval);
    };
    
    sequence();
  }
  
  playBass() {
    if (!this.allocateVoice()) return;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    const note = this.scale[this.chords[this.chordIndex][0]];
    const freq = this.root * Math.pow(2, note / 12) / 2;
    
    osc.type = 'sine';
    osc.frequency.value = freq;
    
    gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
    
    osc.connect(gain);
    gain.connect(this.compressor);
    
    osc.start();
    osc.stop(this.ctx.currentTime + 0.5);
    
    this.trackVoice(osc, 0.5);
  }
  
  playKick() {
    if (!this.allocateVoice()) return;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    osc.type = 'sine';
    osc.frequency.setValueAtTime(60, this.ctx.currentTime);
    osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);
    
    gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
    
    osc.connect(gain);
    gain.connect(this.compressor);
    
    osc.start();
    osc.stop(this.ctx.currentTime + 0.2);
    
    this.trackVoice(osc, 0.2);
  }
  
  playSnare() {
    if (!this.allocateVoice()) return;
    
    const noise = this.ctx.createBufferSource();
    const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
    const data = buffer.getChannelData(0);
    
    for (let i = 0; i < data.length; i++) {
      data[i] = (Math.random() * 2 - 1) * (1 - i / data.length);
    }
    
    noise.buffer = buffer;
    
    const gain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    filter.type = 'highpass';
    filter.frequency.value = 1000;
    
    gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
    
    noise.connect(filter);
    filter.connect(gain);
    gain.connect(this.compressor);
    
    noise.start();
    
    this.trackVoice(noise, 0.1);
  }
  
  playMelody() {
    if (!this.allocateVoice()) return;
    
    const osc = this.ctx.createOscillator();
    const gain = this.ctx.createGain();
    
    const chord = this.chords[this.chordIndex];
    const note = this.scale[chord[Math.floor(Math.random() * chord.length)]];
    const octave = Math.random() > 0.5 ? 1 : 2;
    const freq = this.root * Math.pow(2, note / 12) * octave;
    
    osc.type = 'triangle';
    osc.frequency.value = freq;
    
    gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
    
    osc.connect(gain);
    gain.connect(this.compressor);
    
    osc.start();
    osc.stop(this.ctx.currentTime + 0.3);
    
    this.trackVoice(osc, 0.3);
  }
  
  playPad() {
    const chord = this.chords[this.chordIndex];
    
    chord.forEach((noteIndex, i) => {
      if (!this.allocateVoice()) return;
      
      const osc = this.ctx.createOscillator();
      const gain = this.ctx.createGain();
      
      const note = this.scale[noteIndex];
      const freq = this.root * Math.pow(2, note / 12);
      
      osc.type = 'sine';
      osc.frequency.value = freq;
      
      gain.gain.setValueAtTime(0, this.ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0.05, this.ctx.currentTime + 1);
      gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
      
      osc.connect(gain);
      gain.connect(this.compressor);
      gain.connect(this.reverb);
      
      osc.start();
      osc.stop(this.ctx.currentTime + 4);
      
      this.trackVoice(osc, 4);
    });
  }
  
  allocateVoice() {
    // Clean up finished voices
    this.activeVoices = this.activeVoices.filter(v => 
      this.ctx.currentTime < v.endTime
    );
    
    return this.activeVoices.length < this.maxVoices;
  }
  
  trackVoice(source, duration) {
    this.activeVoices.push({
      source,
      endTime: this.ctx.currentTime + duration
    });
  }
  
  animate() {
    const render = () => {
      if (!this.active) return;
      
      // Update UI
      document.getElementById('energy').textContent = Math.round(this.energy);
      document.getElementById('bpm').textContent = Math.round(this.bpm);
      document.getElementById('voices').textContent = `VOICES: ${this.activeVoices.length}`;
      document.getElementById('motion').textContent = `MOTION: ${this.motion.toFixed(2)}`;
      
      // Update visualizer
      if (this.analyser) {
        this.analyser.getByteFrequencyData(this.freqData);
        this.vizBars.forEach((bar, i) => {
          const height = (this.freqData[i] / 255) * 60;
          bar.style.height = height + 'px';
        });
      }
      
      // Update background
      const hue = (Date.now() / 100) % 360;
      const sat = 20 + this.energy * 0.5;
      const light = 5 + this.energy * 0.1;
      document.body.style.background = `hsl(${hue}, ${sat}%, ${light}%)`;
      
      requestAnimationFrame(render);
    };
    
    requestAnimationFrame(render);
  }
}

// Initialize
const engine = new VoidEngine();

// Prevent zoom and scroll on mobile
document.addEventListener('gesturestart', e => e.preventDefault());
document.addEventListener('gesturechange', e => e.preventDefault());
document.addEventListener('gestureend', e => e.preventDefault());
document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });

// Keep screen awake
if ('wakeLock' in navigator) {
  document.addEventListener('visibilitychange', async () => {
    if (document.visibilityState === 'visible') {
      await navigator.wakeLock.request('screen');
    }
  });
}
</script>
</body>
</html>
