<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            height: 100vh;
            cursor: none;
        }

        #canvas3d {
            width: 100%;
            height: 100%;
        }

        /* Minimal floating orb */
        .orb {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.1), transparent);
            border: 1px solid rgba(255,255,255,0.1);
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            backdrop-filter: blur(10px);
        }

        .orb:hover {
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,0.2), transparent);
            transform: translateX(-50%) scale(1.1);
        }

        .orb.recording {
            background: radial-gradient(circle at 30% 30%, rgba(255,100,100,0.4), transparent);
            border-color: rgba(255,100,100,0.4);
            animation: pulse 1s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.2); }
        }

        /* Minimal quality indicator */
        .quality {
            position: fixed;
            top: 20px;
            right: 20px;
            font-size: 10px;
            letter-spacing: 2px;
            opacity: 0.3;
            text-transform: uppercase;
        }

        /* Loading */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 12px;
            letter-spacing: 3px;
            text-transform: uppercase;
            opacity: 0.5;
            transition: opacity 0.5s;
        }

        /* Hidden controls - only visible on hover */
        .controls {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 20px;
            opacity: 0;
            transition: opacity 0.3s;
        }

        body:hover .controls {
            opacity: 0.3;
        }

        .control {
            width: 4px;
            height: 30px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            position: relative;
            cursor: pointer;
        }

        .control-value {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: rgba(255,255,255,0.6);
            border-radius: 2px;
            transition: height 0.1s;
        }

        /* Subtle notification */
        .notification {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.5s;
        }

        .notification.show {
            opacity: 0.5;
        }
    </style>
</head>
<body>
    <canvas id="canvas3d"></canvas>
    <div class="quality">96k</div>
    <div class="loading" id="loading">initializing</div>
    <div class="notification" id="notification"></div>
    
    <div class="controls">
        <div class="control" data-param="roomSize">
            <div class="control-value" style="height: 50%"></div>
        </div>
        <div class="control" data-param="reverb">
            <div class="control-value" style="height: 20%"></div>
        </div>
        <div class="control" data-param="distance">
            <div class="control-value" style="height: 30%"></div>
        </div>
    </div>
    
    <div class="orb" id="orb"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        'use strict';

        class SpatialEngine {
            constructor() {
                // Core audio properties
                this.ctx = null;
                this.sampleRate = 96000;
                this.nodes = new Map();
                this.layers = [];
                this.recording = false;
                this.recordBuffer = null;
                this.recordIndex = 0;
                
                // Spatial parameters
                this.params = {
                    roomSize: 0.5,
                    reverb: 0.2,
                    distance: 0.3
                };
                
                // HRTF lookup table (pre-calculated for performance)
                this.hrtf = new Map();
                this.initHRTF();
                
                // Three.js
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.sources = [];
                
                // Auto-start on click
                document.addEventListener('click', () => this.init(), { once: true });
            }

            async init() {
                if (this.ctx) return;
                
                // Create audio context
                this.ctx = new AudioContext({ 
                    sampleRate: this.sampleRate,
                    latencyHint: 'playback'
                });
                
                // Build audio graph
                this.buildAudioGraph();
                
                // Setup mic
                await this.setupMic();
                
                // Setup 3D
                this.setup3D();
                
                // Bind UI
                this.bindUI();
                
                // Hide loading
                const loading = document.getElementById('loading');
                loading.style.opacity = '0';
                setTimeout(() => loading.style.display = 'none', 500);
                
                // Start render loop
                this.animate();
            }

            buildAudioGraph() {
                // Master limiter
                const limiter = this.ctx.createDynamicsCompressor();
                limiter.threshold.value = -3;
                limiter.knee.value = 0;
                limiter.ratio.value = 20;
                limiter.attack.value = 0.001;
                limiter.release.value = 0.1;
                
                // Master gain
                const master = this.ctx.createGain();
                master.gain.value = 0.9;
                
                // Convolution reverb
                const convolver = this.ctx.createConvolver();
                const convolverGain = this.ctx.createGain();
                convolverGain.gain.value = this.params.reverb;
                
                // Connections
                master.connect(limiter);
                limiter.connect(this.ctx.destination);
                master.connect(convolver);
                convolver.connect(convolverGain);
                convolverGain.connect(limiter);
                
                // Store nodes
                this.nodes.set('master', master);
                this.nodes.set('limiter', limiter);
                this.nodes.set('convolver', convolver);
                this.nodes.set('convolverGain', convolverGain);
                
                // Generate impulse
                this.updateImpulse();
            }

            async setupMic() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate
                        }
                    });
                    
                    const mic = this.ctx.createMediaStreamSource(stream);
                    const recorder = this.ctx.createScriptProcessor(2048, 1, 1);
                    
                    // Pre-allocate record buffer (30 seconds max)
                    this.recordBuffer = new Float32Array(this.sampleRate * 30);
                    
                    recorder.onaudioprocess = (e) => {
                        if (!this.recording) return;
                        
                        const input = e.inputBuffer.getChannelData(0);
                        const remaining = this.recordBuffer.length - this.recordIndex;
                        const toCopy = Math.min(input.length, remaining);
                        
                        this.recordBuffer.set(input.subarray(0, toCopy), this.recordIndex);
                        this.recordIndex += toCopy;
                        
                        if (this.recordIndex >= this.recordBuffer.length) {
                            this.stopRecording();
                        }
                    };
                    
                    this.nodes.set('mic', mic);
                    this.nodes.set('recorder', recorder);
                    
                } catch (e) {
                    console.error('Mic setup failed:', e);
                    this.notify('mic access denied');
                }
            }

            initHRTF() {
                // Pre-calculate HRTF for common angles
                for (let azimuth = -180; azimuth <= 180; azimuth += 15) {
                    for (let elevation = -90; elevation <= 90; elevation += 15) {
                        const key = `${azimuth}_${elevation}`;
                        
                        // Simplified HRTF model
                        const azRad = azimuth * Math.PI / 180;
                        const elRad = elevation * Math.PI / 180;
                        
                        // ITD in samples
                        const itd = 0.0003 * Math.sin(azRad) * Math.cos(elRad) * this.sampleRate;
                        
                        // ILD as gain ratio
                        const ild = 0.5 + 0.5 * Math.sin(azRad) * Math.cos(elRad);
                        
                        this.hrtf.set(key, {
                            leftDelay: Math.max(0, -itd),
                            rightDelay: Math.max(0, itd),
                            leftGain: Math.min(1, 2 - ild),
                            rightGain: Math.min(1, ild)
                        });
                    }
                }
            }

            createSpatialSource(buffer, position) {
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.loop = true;
                
                // Panner for basic 3D
                const panner = this.ctx.createPanner();
                panner.panningModel = 'HRTF';
                panner.distanceModel = 'inverse';
                panner.refDistance = 1;
                panner.maxDistance = 100;
                panner.rolloffFactor = 1;
                panner.coneInnerAngle = 360;
                panner.coneOuterAngle = 0;
                panner.coneOuterGain = 0;
                
                // Set position
                panner.positionX.value = position.x;
                panner.positionY.value = position.y;
                panner.positionZ.value = position.z;
                
                // Gain for layer control
                const gain = this.ctx.createGain();
                gain.gain.value = 0.8;
                
                // Connect
                source.connect(panner);
                panner.connect(gain);
                gain.connect(this.nodes.get('master'));
                
                return { source, panner, gain };
            }

            updateImpulse() {
                const length = Math.floor(this.sampleRate * this.params.roomSize * 2);
                const impulse = this.ctx.createBuffer(2, length, this.sampleRate);
                
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    
                    // Early reflections
                    const earlyCount = Math.floor(length * 0.1);
                    for (let i = 0; i < earlyCount; i++) {
                        if (Math.random() < 0.001) {
                            data[i] = (Math.random() - 0.5) * Math.exp(-i / earlyCount * 3);
                        }
                    }
                    
                    // Diffuse tail
                    for (let i = earlyCount; i < length; i++) {
                        data[i] = (Math.random() - 0.5) * Math.exp(-i / length * 3) * 0.1;
                    }
                }
                
                this.nodes.get('convolver').buffer = impulse;
            }

            startRecording() {
                if (this.recording) return;
                
                this.recording = true;
                this.recordIndex = 0;
                
                // Connect recording chain
                const mic = this.nodes.get('mic');
                const recorder = this.nodes.get('recorder');
                
                mic.connect(recorder);
                recorder.connect(this.ctx.destination);
                
                // Update UI
                document.getElementById('orb').classList.add('recording');
                this.notify('recording');
            }

            stopRecording() {
                if (!this.recording) return;
                
                this.recording = false;
                
                // Disconnect
                const mic = this.nodes.get('mic');
                const recorder = this.nodes.get('recorder');
                
                mic.disconnect(recorder);
                recorder.disconnect();
                
                // Update UI
                document.getElementById('orb').classList.remove('recording');
                
                // Process recording
                if (this.recordIndex > this.sampleRate * 0.1) {
                    this.createLayer();
                    this.notify('layer created');
                }
            }

            createLayer() {
                // Create buffer from recording
                const buffer = this.ctx.createBuffer(1, this.recordIndex, this.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer.subarray(0, this.recordIndex));
                
                // Random position in space
                const position = {
                    x: (Math.random() - 0.5) * 10,
                    y: Math.random() * 5,
                    z: (Math.random() - 0.5) * 10
                };
                
                // Create spatial source
                const spatial = this.createSpatialSource(buffer, position);
                
                // Create visual
                const visual = this.createVisual(position);
                
                // Store layer
                const layer = {
                    id: Date.now(),
                    buffer,
                    spatial,
                    visual,
                    position
                };
                
                this.layers.push(layer);
                
                // Start playback
                spatial.source.start();
            }

            setup3D() {
                // Scene
                this.scene = new THREE.Scene();
                this.scene.fog = new THREE.Fog(0x000000, 1, 50);
                
                // Camera
                this.camera = new THREE.PerspectiveCamera(
                    75,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                // Renderer
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas3d'),
                    antialias: true,
                    alpha: false
                });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Lights
                const ambient = new THREE.AmbientLight(0x111111);
                this.scene.add(ambient);
                
                // Camera animation
                this.cameraAngle = 0;
                this.cameraRadius = 15;
                this.cameraHeight = 8;
                
                // Resize handler
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                });
            }

            createVisual(position) {
                // Create glowing orb
                const geometry = new THREE.SphereGeometry(0.5, 16, 16);
                const material = new THREE.MeshBasicMaterial({
                    color: new THREE.Color(`hsl(${Math.random() * 360}, 70%, 50%)`),
                    transparent: true,
                    opacity: 0.8
                });
                
                const mesh = new THREE.Mesh(geometry, material);
                mesh.position.copy(position);
                
                // Add glow
                const glowGeometry = new THREE.SphereGeometry(0.7, 16, 16);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: material.color,
                    transparent: true,
                    opacity: 0.2
                });
                
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                mesh.add(glow);
                
                this.scene.add(mesh);
                
                return { mesh, glow };
            }

            bindUI() {
                // Record button
                const orb = document.getElementById('orb');
                orb.addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (this.recording) {
                        this.stopRecording();
                    } else {
                        this.startRecording();
                    }
                });
                
                // Parameter controls
                document.querySelectorAll('.control').forEach(control => {
                    const param = control.dataset.param;
                    const value = control.querySelector('.control-value');
                    
                    control.addEventListener('click', (e) => {
                        const rect = control.getBoundingClientRect();
                        const percent = 1 - (e.clientY - rect.top) / rect.height;
                        
                        this.params[param] = percent;
                        value.style.height = (percent * 100) + '%';
                        
                        // Apply changes
                        if (param === 'roomSize') {
                            this.updateImpulse();
                        } else if (param === 'reverb') {
                            this.nodes.get('convolverGain').gain.value = percent * 0.5;
                        }
                    });
                });
                
                // Keyboard
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space') {
                        e.preventDefault();
                        orb.click();
                    }
                });
            }

            notify(text) {
                const notification = document.getElementById('notification');
                notification.textContent = text;
                notification.classList.add('show');
                
                setTimeout(() => {
                    notification.classList.remove('show');
                }, 2000);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                
                // Rotate camera
                this.cameraAngle += 0.002;
                this.camera.position.x = Math.cos(this.cameraAngle) * this.cameraRadius;
                this.camera.position.y = this.cameraHeight;
                this.camera.position.z = Math.sin(this.cameraAngle) * this.cameraRadius;
                this.camera.lookAt(0, 2, 0);
                
                // Animate sources
                this.layers.forEach((layer, i) => {
                    const visual = layer.visual;
                    const time = Date.now() * 0.001;
                    
                    // Gentle floating
                    visual.mesh.position.y = layer.position.y + Math.sin(time + i) * 0.2;
                    
                    // Rotation
                    visual.mesh.rotation.y += 0.01;
                    
                    // Pulsing glow
                    const scale = 1 + Math.sin(time * 2 + i) * 0.2;
                    visual.glow.scale.set(scale, scale, scale);
                });
                
                this.renderer.render(this.scene, this.camera);
            }
        }

        // Start engine
        new SpatialEngine();
    </script>
</body>
</html>
