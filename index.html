<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: EDM Drop Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000000;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(0,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.buildup {
      background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,0,255,0.7);
    }
    
    .orb.drop {
      background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(0,255,0,0.7);
    }
    
    .orb.breakdown {
      background: radial-gradient(circle, #ff9900 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(255,153,0,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    .orb.riddim {
      background: radial-gradient(circle, #ffff00 0%, #ff0000 25%, #00ffff 50%, #ff00ff 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(255,255,0,1);
      filter: drop-shadow(0 0 80px rgba(255,0,0,0.8));
    }
    
    .orb.void {
      background: radial-gradient(circle, #4b0082 0%, rgba(75,0,130,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(75,0,130,0.4);
      filter: drop-shadow(0 0 20px rgba(75,0,130,0.2));
      animation: voidBreathe 3s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes voidBreathe {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(0,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class GUMPEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 140;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.lastMotionTime = Date.now();
        
        // Gesture Recognition
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        // Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.voidPhase = false;
        this.currentTechnique = 'waiting';
        this.transposition = 0;
        
        // Cinematic Themes (Adapted to EDM/Dubstep/Grime)
        this.currentTheme = 'buildup';
        this.themes = {
          buildup: { mood: 'tense', colors: ['#ff00ff', '#000000'], text: 'Tension Rising' },
          drop: { mood: 'aggressive', colors: ['#00ff00', '#000000'], text: 'Bass Drop' },
          breakdown: { mood: 'chill', colors: ['#ff9900', '#000000'], text: 'Break It Down' },
          riddim: { mood: 'grimy', colors: ['#ffff00', '#ff0000'], text: 'Riddim Flow' },
          glitch: { mood: 'chaotic', colors: ['#00ffff', '#ff00ff'], text: 'Glitch Out' },
          void: { mood: 'dark', colors: ['#4b0082', '#000000'], text: 'Silent Void' }
        };
        
        // Song Profiles (Dubstep/Grime/EDM inspired)
        this.songs = [
          {
            name: 'GUMP Wobble Tension',
            influences: 'Skrillex blended with Burial; aggressive wobbly bass drops with grimy atmospheres, half-time rhythms, and dark synths inspired by dubstep and grime intensity',
            key: 'D',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [3,7,10], [5,8,12], [7,10,14]],
            ostinatoPattern: [0,1,7,1,0,1,7,1],
            phraseStructure: ['A', 'A', 'B', 'B', 'C', 'C'],
            defaultTheme: 'drop',
            layerBiases: {
              eightOhEight: 1.1,
              sub: 0.9,
              hats: 0.9,
              clap: 1.3,
              wobble: 0.6,
              supersaw: 1.0,
              fx: 0.6,
              lead: 0.9,
              growl: 1.1,
              vocal: 1.2,
              riser: 0.8,
              chop: 0.8,
              buildup: 1.0,
              dropimpact: 1.1,
              voxfx: 1.2,
              whispervox: 0.9
            }
          },
          {
            name: 'GUMP Grime Epic Build',
            influences: 'Rusko blended with Kode9; epic grime rhythms with driving wobbles, tense builds, and dark textures inspired by classic dubstep and grime unease',
            key: 'F',
            mode: 'minor',
            bpmBase: 140,
            chordProgression: [[0,3,7], [5,8,12], [10,14,17], [3,7,10]],
            ostinatoPattern: [0,3,10,3,0,3,10,3],
            phraseStructure: ['A', 'B', 'A', 'C', 'D'],
            defaultTheme: 'buildup',
            layerBiases: {
              eightOhEight: 1.0,
              sub: 0.7,
              hats: 1.0,
              clap: 1.2,
              wobble: 0.7,
              supersaw: 1.1,
              fx: 0.7,
              lead: 1.2,
              growl: 1.0,
              vocal: 1.3,
              riser: 1.0,
              chop: 0.6,
              buildup: 0.9,
              dropimpact: 1.0,
              voxfx: 1.3,
              whispervox: 1.0
            }
          },
          {
            name: 'GUMP EDM Texture Drop',
            influences: 'Excision blended with Zeds Dead; heavy EDM drops with pulsing wobbles, minimalist grime rhythms, and aggressive atmospheres inspired by riddim and dubstep aggression',
            key: 'C',
            mode: 'minor',
            bpmBase: 150,
            chordProgression: [[0,3,7], [2,5,9], [7,10,14], [5,9,12]],
            ostinatoPattern: [0,2,7,2,0,2,7,2],
            phraseStructure: ['A', 'B', 'C', 'A', 'D', 'D'],
            defaultTheme: 'drop',
            layerBiases: {
              eightOhEight: 1.2,
              sub: 0.8,
              hats: 0.9,
              clap: 1.4,
              wobble: 0.8,
              supersaw: 1.2,
              fx: 0.5,
              lead: 1.3,
              growl: 1.5,
              vocal: 1.4,
              riser: 0.9,
              chop: 0.7,
              buildup: 1.1,
              dropimpact: 1.2,
              voxfx: 1.0,
              whispervox: 0.8
            }
          },
          {
            name: 'GUMP Riddim Pulse',
            influences: 'Caspa blended with Knife Party; riddim dubstep tension with electronic pulsing motifs, immersive half-time rhythms, and dark grime pads inspired by dubstep and EDM suspense',
            key: 'G',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [3,7,10], [5,8,12], [7,10,14]],
            ostinatoPattern: [0,1,7,1,0,1,7,1],
            phraseStructure: ['A', 'A', 'B', 'C', 'B', 'D'],
            defaultTheme: 'riddim',
            layerBiases: {
              eightOhEight: 1.1,
              sub: 1.0,
              hats: 1.0,
              clap: 1.1,
              wobble: 0.7,
              supersaw: 0.8,
              fx: 0.8,
              lead: 0.9,
              growl: 0.9,
              vocal: 1.0,
              riser: 0.9,
              chop: 1.0,
              buildup: 1.0,
              dropimpact: 1.1,
              voxfx: 1.1,
              whispervox: 1.0
            }
          },
          {
            name: 'GUMP Dark EDM Code',
            influences: 'Deadmau5 blended with Porter Robinson; emotional EDM builds with pulsing wobbles, tense minimalist motifs, and ambient swells inspired by progressive EDM and grime anxiety',
            key: 'A',
            mode: 'minor',
            bpmBase: 128,
            chordProgression: [[0,3,7], [5,8,12], [10,14,17], [3,7,10]],
            ostinatoPattern: [0,3,10,3,0,3,10,3],
            phraseStructure: ['A', 'B', 'C', 'D', 'E'],
            defaultTheme: 'breakdown',
            layerBiases: {
              eightOhEight: 1.3,
              sub: 1.0,
              hats: 1.1,
              clap: 1.2,
              wobble: 0.9,
              supersaw: 0.9,
              fx: 0.8,
              lead: 0.8,
              growl: 1.0,
              vocal: 0.9,
              riser: 1.0,
              chop: 1.0,
              buildup: 0.9,
              dropimpact: 1.0,
              voxfx: 0.9,
              whispervox: 0.9
            }
          },
          {
            name: 'GUMP Hybrid Riddim Fusion',
            influences: 'Skrillex & Rusko blended with Burial; hybrid riddim with grimy electronic pulses, wobble builds, minimalist tension, and pulsing motifs inspired by dubstep and grime',
            key: 'F',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [6,10,13], [2,6,9], [4,8,11]],
            ostinatoPattern: [0,1,11,1,0,1,11,1],
            phraseStructure: ['A', 'B', 'A', 'C', 'D', 'E'],
            defaultTheme: 'riddim',
            layerBiases: {
              eightOhEight: 1.0,
              sub: 0.8,
              hats: 0.8,
              clap: 1.0,
              wobble: 0.6,
              supersaw: 1.0,
              fx: 0.7,
              lead: 1.0,
              growl: 0.9,
              vocal: 1.1,
              riser: 0.8,
              chop: 0.7,
              buildup: 0.8,
              dropimpact: 0.9,
              voxfx: 1.0,
              whispervox: 1.0
            }
          },
          {
            name: 'GUMP Grime Emotional Drop',
            influences: 'Kode9 & Excision blended with Zeds Dead; grime thematic with emotional dynamics, pulsing tense atmospheres, pulsing minimalist electronic motifs inspired by dubstep and EDM',
            key: 'B',
            mode: 'minor',
            bpmBase: 140,
            chordProgression: [[0,3,7], [3,6,9], [5,8,11], [7,10,13]],
            ostinatoPattern: [0,3,7,3,0,3,7,3],
            phraseStructure: ['A', 'B', 'C', 'B', 'D', 'D'],
            defaultTheme: 'glitch',
            layerBiases: {
              eightOhEight: 1.2,
              sub: 0.9,
              hats: 1.0,
              clap: 1.3,
              wobble: 0.8,
              supersaw: 0.8,
              fx: 0.6,
              lead: 1.0,
              growl: 1.1,
              vocal: 0.9,
              riser: 0.9,
              chop: 0.8,
              buildup: 1.0,
              dropimpact: 1.0,
              voxfx: 0.9,
              whispervox: 0.8
            }
          }
        ];
        this.currentSongIndex = 0;
        this.songStartTime = 0;
        
        // AUDIO SYSTEM - Enhanced for EDM depth
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.basePositions = {};
        this.layerPositions = {};
        this.layerTargets = {};
        this.layerPanScales = {
          eightOhEight: 0.1, sub: 0.2, hats: 0.8, clap: 0.3,
          wobble: 1.2, supersaw: 1.5, fx: 3.0,
          lead: 1.8, growl: 1.0, vocal: 2.5, riser: 3.5,
          chop: 2.0, buildup: 2.5, dropimpact: 0.5,
          voxfx: 1.0, whispervox: 1.5
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.lowBoost = null;
        this.saturator = null;
        this.riserGain = null;
        this.wobbleGain = null;
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Techniques
        this.riserTones = []; 
        this.wobblePattern = [0,3,7,10,7,3,7,10]; 
        this.wobbleIndex = 0;
        this.wobbleIntensity = 0;
        this.dropBuildup = 0;
        this.glitchProbability = 0;
        
        // Voice Pool - Adjusted for new layers
        this.voicePool = {
          eightOhEight: { max: 3, active: [] },
          sub: { max: 4, active: [] },
          hats: { max: 6, active: [] }, 
          clap: { max: 3, active: [] },
          wobble: { max: 8, active: [] },
          supersaw: { max: 12, active: [] },
          fx: { max: 6, active: [] },
          lead: { max: 16, active: [] }, 
          growl: { max: 8, active: [] },
          vocal: { max: 12, active: [] },
          riser: { max: 6, active: [] },
          chop: { max: 8, active: [] },
          buildup: { max: 2, active: [] },
          dropimpact: { max: 2, active: [] },
          voxfx: { max: 2, active: [] },
          whispervox: { max: 4, active: [] }
        };
        
        // Layers - Adapted for EDM (hats as hi-hats)
        this.layers = {
          eightOhEight: false, sub: false, hats: false, clap: false,
          wobble: false, supersaw: false, fx: false,
          lead: false, growl: false, vocal: false, riser: false,
          chop: false, buildup: false, dropimpact: false,
          voxfx: false, whispervox: false
        };
        
        // Musical Elements - Adapted progressions to match dubstep drops
        this.key = 'D';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
        this.mode = 'phrygian';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          pentatonic: [0, 2, 4, 7, 9],
          blues: [0, 3, 5, 6, 7, 10],
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          wholeTone: [0, 2, 4, 6, 8, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [0,1,7],  // i Dm
          [8,12,15], // VI Bb
          [3,7,10],  // III F
          [10,14,17] // VII C
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 293.66; 
        
        this.elements = {};
        this.spectrumBars = [];
        
        // Procedural Noise for Glitch FX
        this.noiseSource = null;
        this.noiseFilter = null;
        this.noiseGain = null;

        // Easter Eggs
        this.easterEggs = {
          konamiSequence: [],
          goldenRatio: false,
          perfectCircle: false,
          chaosAttractor: false,
          fibonacciSpiral: false,
          riserInfinity: false,
          harmonicWave: false
        };
        
        this.specialEvents = {
          glitchStorm: 0,
          timeDilation: 0,
          dimensionalRift: 0,
          harmonicResonance: 0
        };

        // Environment
        this.weather = null;
        this.dayOfWeek = new Date().getDay();
        
        this.init();
      }

      init() {
        ['evolutionSpace', 'orb',
         'cinematicOverlay', 'spectrumViz', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
        this.start();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 1.5625}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupInteractionListeners() {
        let touchSequence = [];
        
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.clientX, y: e.clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        setInterval(() => {
          const now = Date.now();
          touchSequence = touchSequence.filter(touch => now - touch.time < 5000);
        }, 2000);

        // Konami Code listener
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;
        
        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              this.triggerKonamiEasterEgg();
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
      }

      analyzeGesture(sequence) {
        if (sequence.length < 3) return;
        
        const recent = sequence.slice(-10);
        const distances = [];
        const angles = [];
        
        for (let i = 1; i < recent.length; i++) {
          const dx = recent[i].x - recent[i-1].x;
          const dy = recent[i].y - recent[i-1].y;
          distances.push(Math.sqrt(dx*dx + dy*dy));
          angles.push(Math.atan2(dy, dx));
        }
        
        // Spiral detection
        let angleSum = 0;
        for (let i = 1; i < angles.length; i++) {
          let diff = angles[i] - angles[i-1];
          if (diff > Math.PI) diff -= 2 * Math.PI;
          if (diff < -Math.PI) diff += 2 * Math.PI;
          angleSum += diff;
        }
        
        if (Math.abs(angleSum) > Math.PI * 2) {
          this.gestureRecognition.spiral += 0.3;
          if (this.gestureRecognition.spiral > 1 && !this.easterEggs.fibonacciSpiral) {
            this.triggerFibonacciSpiral();
          }
        }
        
        // Decay gestures
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.01);
        });
      }

      triggerKonamiEasterEgg() {
        console.log(' The user wants to modify the existing HTML code for the GUMP: EDM Drop Engine. Key points:

- Good job on adding dubstep, but remove the "upload dub" option entirely. No file upload.

- Stop showing words in the UI. Just the dot (orb) for orientation.

- Make it more dubstep: delete some pads if needed, fine with deleting anything to sound more dub, but try to use the engine in this code. Needs to run just as well.

The UI should be minimal: only the orb, no text, no bars, no instructions, etc.

Remove the upload section completely.

To make it more dubstep: Dubstep is characterized by heavy bass, wobbles, drops, half-time rhythms, etc. The code already has elements like wobble, growl, sub, etc.

I can simplify by removing some layers that are less dubstep-y, like supersaw (more trance/EDM), atmopad (ambient), vocal (unless chopped), etc. Focus on core dubstep: 808, sub, wobble, growl, hats, clap/snare, risers, impacts.

The engine should stay, just prune some parts.

The code needs to run just as well, meaning no breaking changes.

First, remove the upload section: remove the HTML div for uploadSection and the script part for setupSampleUpload, and remove any references to samples (since no upload, fallback to synth always).

In play functions, they check for sample, if not, use synth. Since no upload, always synth.

Remove the upload HTML and script.

For UI: remove all ui-corner divs, instruction, theme-text, spectrum-viz, impact-flash, cinematic-overlay.

In the evolution-space div, only keep the orb.

Remove start-screen, as it's already hidden after start.

But keep the start button to awaken.

User said "just the dot", but to start, need the start button.

After start, only the orb.

Remove all text elements.

In style, remove styles for removed elements.

In script, remove references to removed elements.

For more dubstep: perhaps remove layers like supersaw, lead, vocal, atmopad, glitchpad, chop, voxfx, whispervox. Keep eightOhEight, sub, hats, clap, wobble, growl, fx, riser, buildup, dropimpact.

Adjust the songs to be more dubstep focused.

Remove some song profiles that are less dubstep.

Keep the ones with Skrillex, Rusko, Excision, Caspa influences.

Remove Deadmau5 one, as it's more progressive.

In layerBiases, remove removed layers.

In voicePool, layers, layerGains, etc., remove removed ones.

In setLayerPositions, remove removed.

In setupAudioChain, update layerNames and levels.

This will simplify the code.

Also, since no words, remove updateUI parts that set text.

Keep the orb animation.

In animate, keep background changes, orb position.

Remove cinematicOverlay toggle, etc.

To make it sound more dub, perhaps increase biases for wobble, growl, etc.

But since using the engine, keep logic.

User said "delete some of the pads if you want", pads probably mean atmopad, glitchpad.

Yes.

Also, "we need it more dub step, so you can delete some of the pads"

Dub step, meaning dubstep.

Ok.

Now, to implement: I need to output the modified HTML code.

No tools needed, as it's code modification.<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: EDM Drop Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000000;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(0,255,255,0.3);
      color: #00ffff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 3s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(0,255,255,0.6);
      background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(0,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(0,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(0,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.buildup {
      background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,0,255,0.7);
    }
    
    .orb.drop {
      background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(0,255,0,0.7);
    }
    
    .orb.breakdown {
      background: radial-gradient(circle, #ff9900 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(255,153,0,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    .orb.riddim {
      background: radial-gradient(circle, #ffff00 0%, #ff0000 25%, #00ffff 50%, #ff00ff 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(255,255,0,1);
      filter: drop-shadow(0 0 80px rgba(255,0,0,0.8));
    }
    
    .orb.void {
      background: radial-gradient(circle, #4b0082 0%, rgba(75,0,130,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(75,0,130,0.4);
      filter: drop-shadow(0 0 20px rgba(75,0,130,0.2));
      animation: voidBreathe 3s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes voidBreathe {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(0,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
  </div>

  <script>
    class GUMPEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 140;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.lastMotionTime = Date.now();
        
        // Gesture Recognition
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        // Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.voidPhase = false;
        this.currentTechnique = 'waiting';
        this.transposition = 0;
        
        // Cinematic Themes (Adapted to EDM/Dubstep/Grime)
        this.currentTheme = 'buildup';
        this.themes = {
          buildup: { mood: 'tense', colors: ['#ff00ff', '#000000'], text: 'Tension Rising' },
          drop: { mood: 'aggressive', colors: ['#00ff00', '#000000'], text: 'Bass Drop' },
          breakdown: { mood: 'chill', colors: ['#ff9900', '#000000'], text: 'Break It Down' },
          riddim: { mood: 'grimy', colors: ['#ffff00', '#ff0000'], text: 'Riddim Flow' },
          glitch: { mood: 'chaotic', colors: ['#00ffff', '#ff00ff'], text: 'Glitch Out' },
          void: { mood: 'dark', colors: ['#4b0082', '#000000'], text: 'Silent Void' }
        };
        
        // Song Profiles (Dubstep focused)
        this.songs = [
          {
            name: 'GUMP Wobble Tension',
            influences: 'Skrillex blended with Burial; aggressive wobbly bass drops with grimy atmospheres, half-time rhythms, and dark synths inspired by dubstep and grime intensity',
            key: 'D',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [3,7,10], [5,8,12], [7,10,14]],
            ostinatoPattern: [0,1,7,1,0,1,7,1],
            phraseStructure: ['A', 'A', 'B', 'B', 'C', 'C'],
            defaultTheme: 'drop',
            layerBiases: {
              eightOhEight: 1.1,
              sub: 0.9,
              hats: 0.9,
              clap: 1.3,
              wobble: 0.6,
              fx: 0.6,
              growl: 1.1,
              riser: 0.8,
              buildup: 1.0,
              dropimpact: 1.1
            }
          },
          {
            name: 'GUMP Grime Epic Build',
            influences: 'Rusko blended with Kode9; epic grime rhythms with driving wobbles, tense builds, and dark textures inspired by classic dubstep and grime unease',
            key: 'F',
            mode: 'minor',
            bpmBase: 140,
            chordProgression: [[0,3,7], [5,8,12], [10,14,17], [3,7,10]],
            ostinatoPattern: [0,3,10,3,0,3,10,3],
            phraseStructure: ['A', 'B', 'A', 'C', 'D'],
            defaultTheme: 'buildup',
            layerBiases: {
              eightOhEight: 1.0,
              sub: 0.7,
              hats: 1.0,
              clap: 1.2,
              wobble: 0.7,
              fx: 0.7,
              growl: 1.0,
              riser: 1.0,
              buildup: 0.9,
              dropimpact: 1.0
            }
          },
          {
            name: 'GUMP EDM Texture Drop',
            influences: 'Excision blended with Zeds Dead; heavy EDM drops with pulsing wobbles, minimalist grime rhythms, and aggressive atmospheres inspired by riddim and dubstep aggression',
            key: 'C',
            mode: 'minor',
            bpmBase: 150,
            chordProgression: [[0,3,7], [2,5,9], [7,10,14], [5,9,12]],
            ostinatoPattern: [0,2,7,2,0,2,7,2],
            phraseStructure: ['A', 'B', 'C', 'A', 'D', 'D'],
            defaultTheme: 'drop',
            layerBiases: {
              eightOhEight: 1.2,
              sub: 0.8,
              hats: 0.9,
              clap: 1.4,
              wobble: 0.8,
              fx: 0.5,
              growl: 1.5,
              riser: 0.9,
              buildup: 1.1,
              dropimpact: 1.2
            }
          },
          {
            name: 'GUMP Riddim Pulse',
            influences: 'Caspa blended with Knife Party; riddim dubstep tension with electronic pulsing motifs, immersive half-time rhythms, and dark grime pads inspired by dubstep and EDM suspense',
            key: 'G',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [3,7,10], [5,8,12], [7,10,14]],
            ostinatoPattern: [0,1,7,1,0,1,7,1],
            phraseStructure: ['A', 'A', 'B', 'C', 'B', 'D'],
            defaultTheme: 'riddim',
            layerBiases: {
              eightOhEight: 1.1,
              sub: 1.0,
              hats: 1.0,
              clap: 1.1,
              wobble: 0.7,
              fx: 0.8,
              growl: 0.9,
              riser: 0.9,
              buildup: 1.0,
              dropimpact: 1.1
            }
          },
          {
            name: 'GUMP Hybrid Riddim Fusion',
            influences: 'Skrillex & Rusko blended with Burial; hybrid riddim with grimy electronic pulses, wobble builds, minimalist tension, and pulsing motifs inspired by dubstep and grime',
            key: 'F',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [6,10,13], [2,6,9], [4,8,11]],
            ostinatoPattern: [0,1,11,1,0,1,11,1],
            phraseStructure: ['A', 'B', 'A', 'C', 'D', 'E'],
            defaultTheme: 'riddim',
            layerBiases: {
              eightOhEight: 1.0,
              sub: 0.8,
              hats: 0.8,
              clap: 1.0,
              wobble: 0.6,
              fx: 0.7,
              growl: 0.9,
              riser: 0.8,
              buildup: 0.8,
              dropimpact: 0.9
            }
          }
        ];
        this.currentSongIndex = 0;
        this.songStartTime = 0;
        
        // AUDIO SYSTEM - Enhanced for EDM depth
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.basePositions = {};
        this.layerPositions = {};
        this.layerTargets = {};
        this.layerPanScales = {
          eightOhEight: 0.1, sub: 0.2, hats: 0.8, clap: 0.3,
          wobble: 1.2, fx: 3.0,
          growl: 1.0, riser: 3.5,
          buildup: 2.5, dropimpact: 0.5
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.lowBoost = null;
        this.saturator = null;
        this.riserGain = null;
        this.wobbleGain = null;
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Techniques
        this.riserTones = []; 
        this.wobblePattern = [0,3,7,10,7,3,7,10]; 
        this.wobbleIndex = 0;
        this.wobbleIntensity = 0;
        this.dropBuildup = 0;
        this.glitchProbability = 0;
        
        // Voice Pool - Adjusted for new layers
        this.voicePool = {
          eightOhEight: { max: 3, active: [] },
          sub: { max: 4, active: [] },
          hats: { max: 6, active: [] }, 
          clap: { max: 3, active: [] },
          wobble: { max: 8, active: [] },
          fx: { max: 6, active: [] },
          growl: { max: 8, active: [] },
          riser: { max: 6, active: [] },
          buildup: { max: 2, active: [] },
          dropimpact: { max: 2, active: [] }
        };
        
        // Layers - Adapted for EDM (hats as hi-hats)
        this.layers = {
          eightOhEight: false, sub: false, hats: false, clap: false,
          wobble: false, fx: false,
          growl: false, riser: false,
          buildup: false, dropimpact: false
        };
        
        // Musical Elements - Adapted progressions to match dubstep drops
        this.key = 'D';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
        this.mode = 'phrygian';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          pentatonic: [0, 2, 4, 7, 9],
          blues: [0, 3, 5, 6, 7, 10],
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          wholeTone: [0, 2, 4, 6, 8, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [0,1,7],  // i Dm
          [8,12,15], // VI Bb
          [3,7,10],  // III F
          [10,14,17] // VII C
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 293.66; 
        
        this.elements = {};
        
        // Procedural Noise for Glitch FX
        this.noiseSource = null;
        this.noiseFilter = null;
        this.noiseGain = null;

        // Easter Eggs
        this.easterEggs = {
          konamiSequence: [],
          goldenRatio: false,
          perfectCircle: false,
          chaosAttractor: false,
          fibonacciSpiral: false,
          riserInfinity: false,
          harmonicWave: false
        };
        
        this.specialEvents = {
          glitchStorm: 0,
          timeDilation: 0,
          dimensionalRift: 0,
          harmonicResonance: 0
        };

        // Environment
        this.weather = null;
        this.dayOfWeek = new Date().getDay();
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupInteractionListeners();
      }

      setupInteractionListeners() {
        let touchSequence = [];
        
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.clientX, y: e.clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        setInterval(() => {
          const now = Date.now();
          touchSequence = touchSequence.filter(touch => now - touch.time < 5000);
        }, 2000);

        // Konami Code listener
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;
        
        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              this.triggerKonamiEasterEgg();
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
      }

      analyzeGesture(sequence) {
        if (sequence.length < 3) return;
        
        const recent = sequence.slice(-10);
        const distances = [];
        const angles = [];
        
        for (let i = 1; i < recent.length; i++) {
          const dx = recent[i].x - recent[i-1].x;
          const dy = recent[i].y - recent[i-1].y;
          distances.push(Math.sqrt(dx*dx + dy*dy));
          angles.push(Math.atan2(dy, dx));
        }
        
        // Spiral detection
        let angleSum = 0;
        for (let i = 1; i < angles.length; i++) {
          let diff = angles[i] - angles[i-1];
          if (diff > Math.PI) diff -= 2 * Math.PI;
          if (diff < -Math.PI) diff += 2 * Math.PI;
          angleSum += diff;
        }
        
        if (Math.abs(angleSum) > Math.PI * 2) {
          this.gestureRecognition.spiral += 0.3;
          if (this.gestureRecognition.spiral > 1 && !this.easterEggs.fibonacciSpiral) {
            this.triggerFibonacciSpiral();
          }
        }
        
        // Decay gestures
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.01);
        });
      }

      triggerKonamiEasterEgg() {
        console.log('ðŸŽ® KONAMI CODE ACTIVATED: Infinite Drop Mode');
        this.specialEvents.dimensionalRift = 2;
        this.bpm *= 1.5;
        this.layers.buildup = true;
        this.currentTheme = 'glitch';
        this.evolveToRiddim();
      }

      triggerFibonacciSpiral() {
        console.log('ðŸŒ€ FIBONACCI SPIRAL DETECTED: Golden Wobble Harmony');
        this.easterEggs.fibonacciSpiral = true;
        this.layers.riser = true;
        this.wobbleIntensity = 1;
        this.playGoldenRatioChord();
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          if (e.alpha !== null) {
            this.orientation.alpha = e.alpha;
            this.orientation.beta = e.beta;
            this.orientation.gamma = e.gamma;
            this.updateListenerOrientation();
          }
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        this.listener.forwardX.value = forwardX;
        this.listener.forwardY.value = forwardY;
        this.listener.forwardZ.value = forwardZ;
        this.listener.upX.value = upX;
        this.listener.upY.value = upY;
        this.listener.upZ.value = upZ;
      }

      async start() {
        try {
          let motionGranted = true;
          let orientationGranted = true;

          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              motionGranted = false;
              console.log('Motion permission not granted, continuing with mouse input');
            }
          }

          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              orientationGranted = false;
              console.log('Orientation permission not granted');
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setLayerPositions();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          this.active = true;
          this.setSong(0);
          this.songStartTime = Date.now();
          this.startSequencer();
          this.animate();
          
          // Get environment data
          this.fetchEnvironmentData();

          if (!motionGranted && !orientationGranted) {
            // Fallback to simulated motion if no permissions
            this.simulateMotion();
          }
          
        } catch (e) {
          console.error('Failed to start engine:', e);
        }
      }

      simulateMotion() {
        let time = 0;
        const simulate = () => {
          if (!this.active || this.motion > 0) return;
          time += 0.05;
          const simulatedMotion = Math.sin(time) * 2 + 2;
          this.updateMotion(simulatedMotion);
          requestAnimationFrame(simulate);
        };
        simulate();
      }

      setSong(index) {
        const song = this.songs[index];
        const fadeTime = 2;

        this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + fadeTime);

        setTimeout(() => {
          this.key = song.key;
          this.mode = song.mode;
          this.scale = this.scales[this.mode];
          this.bpm = song.bpmBase;
          this.chordProgression = song.chordProgression;
          this.wobblePattern = song.ostinatoPattern;
          this.phraseStructure = song.phraseStructure;
          this.currentTheme = song.defaultTheme;
          this.currentSongIndex = index;

          // Reset states
          this.phraseCount = 0;
          this.phrase = this.phraseStructure[0];
          this.wobbleIndex = 0;
          this.currentChordIndex = 0;
          this.transposition = 0;
          this.wobbleIntensity = 0;
          this.dropBuildup = 0;

          // Clear active voices
          Object.keys(this.voicePool).forEach(layer => {
            this.voicePool[layer].active.forEach(voice => {
              if (voice.source) voice.source.stop();
            });
            this.voicePool[layer].active = [];
          });

          console.log(`Transitioned to song: ${song.name} (Influences: ${song.influences})`);

          this.masterGain.gain.linearRampToValueAtTime(0.65, this.ctx.currentTime + fadeTime);

          this.songStartTime = Date.now();
        }, fadeTime * 1000);
      }

      fetchEnvironmentData() {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            fetch(`https://api.open-meteo.com/v1/forecast?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&current_weather=true`)
              .then(res => res.json())
              .then(data => {
                this.weather = data.current_weather;
                this.updateFromEnvironment();
              })
              .catch(err => console.error('Weather fetch error:', err));
          },
          (err) => {
            console.error('Geolocation error:', err);
            this.weather = { temperature: 20, weathercode: 0, windspeed: 5 };
            this.updateFromEnvironment();
          },
          { enableHighAccuracy: true }
        );
      }

      updateFromEnvironment() {
        if (this.weather) {
          const temp = this.weather.temperature;
          const weatherCode = this.weather.weathercode;

          // Influence BPM based on temperature
          this.bpm += (temp - 15) * 0.5;
          this.bpm = Math.max(100, Math.min(160, this.bpm));

          // Weather code influence
          if (weatherCode >= 61 && weatherCode <= 67) { // Rain
            this.layers.fx = true;
            this.convolver.buffer = this.createReverbBuffer(8);
            this.currentTheme = 'breakdown';
          } else if (weatherCode <= 3) { // Clear
            this.currentTheme = 'buildup';
          } else if (weatherCode >= 71 && weatherCode <= 77) { // Snow
            this.currentTheme = 'glitch';
          }

          // Adjust intensity based on wind
          this.intensity += this.weather.windspeed / 20;
        }

        // Day of week influence
        const days = ['minor', 'phrygian', 'dorian', 'minor', 'phrygian', 'mixolydian', 'locrian'];
        this.mode = days[this.dayOfWeek];
        this.scale = this.scales[this.mode];

        const keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        this.key = keys[this.dayOfWeek];
      }

      createReverbBuffer(time) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 3);
            data[i] = (Math.random() * 2 - 1) * decay * 0.3;
          }
        }
        return buffer;
      }

      makeDistortionCurve(amount) {
        const k = amount;
        const n = 22050;
        const curve = new Float32Array(n);
        const deg = Math.PI / 180;
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 128;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -6; 
        this.limiter.knee.value = 1;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.001;
        this.limiter.release.value = 0.01;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.65;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 12;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        
        this.lowBoost = this.ctx.createBiquadFilter();
        this.lowBoost.type = 'lowshelf';
        this.lowBoost.frequency.value = 120;
        this.lowBoost.gain.value = 6; 
        
        this.saturator = this.ctx.createWaveShaper();
        this.saturator.curve = this.makeDistortionCurve(3);
        this.saturator.oversample = '4x';
        
        this.listener = this.ctx.listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(6);
        
        this.delay = this.ctx.createDelay(0.8);
        this.delay.delayTime.value = 0.375;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.35;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.25;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // Layer setup with updated levels and new layers
        const layerNames = ['eightOhEight', 'sub', 'hats', 'clap', 'wobble', 'fx', 'growl', 'riser', 'buildup', 'dropimpact'];
        const layerLevels = [1.2, 1.1, 0.15, 0.3, 0.25, 0.12, 0.2, 0.1, 0.3, 0.5]; 
        
        layerNames.forEach((name, i) => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];

          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';
          this.layerPanners[name].distanceModel = 'inverse';
          this.layerPanners[name].refDistance = 1;
          this.layerPanners[name].maxDistance = 10000;
          this.layerPanners[name].rolloffFactor = 1.0;
          this.layerPanners[name].coneInnerAngle = 360;
          this.layerPanners[name].coneOuterAngle = 0;
          this.layerPanners[name].coneOuterGain = 0;

          this.layerPositions[name] = {x: 0, y: 0, z: 0};
          this.basePositions[name] = {x: 0, y: 0, z: 0};
          this.layerTargets[name] = {x: 0, y: 0, z: 0};

          this.layerGains[name].connect(this.layerPanners[name]);
          this.layerPanners[name].connect(this.compressor);

          // Selective reverb sends - added voxfx and whispervox
          if (['growl', 'fx', 'eightOhEight', 'clap'].includes(name)) {
            this.layerGains[name].connect(this.convolver);
          }
          
          // Selective delay sends
          if (['wobble', 'clap', 'growl'].includes(name)) {
            this.layerGains[name].connect(this.delay);
          }
        });
        
        this.riserGain = this.ctx.createGain();
        this.riserGain.gain.value = 0.15;
        this.wobbleGain = this.ctx.createGain();
        this.wobbleGain.gain.value = 0.25;
        
        // Audio chain connections
        this.compressor.connect(this.lowBoost);
        this.lowBoost.connect(this.saturator);
        this.saturator.connect(this.limiter);
        this.convolver.connect(this.limiter);
        delayMix.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.setupProceduralNoise();
      }

      setupProceduralNoise() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        this.noiseSource = this.ctx.createBufferSource();
        this.noiseSource.buffer = buffer;
        this.noiseSource.loop = true;

        this.noiseFilter = this.ctx.createBiquadFilter();
        this.noiseFilter.type = 'bandpass';
        this.noiseFilter.frequency.value = 1000;
        this.noiseFilter.Q.value = 10;

        this.noiseGain = this.ctx.createGain();
        this.noiseGain.gain.value = 0.04;

        this.noiseSource.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseGain);
        this.noiseGain.connect(this.layerPanners.fx);
        this.noiseSource.start();
      }

      updateProceduralNoise(avgMotion, variance) {
        this.noiseFilter.frequency.value = 300 + avgMotion * 100 + variance * 50;
        this.noiseFilter.Q.value = 5 + variance * 2;
        this.noiseGain.gain.value = 0.05 + (this.wobbleIntensity * 0.1);
      }

      setLayerPositions() {
        const positions = {
          eightOhEight: {x: 0, y: 0, z: -2},
          sub: {x: 0, y: -1, z: -3},
          hats: {x: 0, y: 1, z: -4},
          clap: {x: 0, y: 0, z: -1},
          wobble: {x: -2, y: 0, z: -5},
          fx: {x: 0, y: 3, z: 10},
          growl: {x: 5, y: 0, z: -6},
          riser: {x: 0, y: 4, z: -10},
          buildup: {x: 0, y: 6, z: -20},
          dropimpact: {x: 0, y: -3, z: -1}
        };

        Object.keys(positions).forEach(name => {
          const pos = positions[name];
          this.basePositions[name] = {...pos};
          this.layerPositions[name] = {...pos};
          this.layerTargets[name] = {...pos};
          if (this.layerPanners[name]) {
            this.layerPanners[name].positionX.value = pos.x;
            this.layerPanners[name].positionY.value = pos.y;
            this.layerPanners[name].positionZ.value = pos.z;
          }
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.015;
          this.velocity.y += acc.y * 0.015;
          this.updatePosition();
          
          this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
          
          if (newMotion > 4 && Date.now() - this.lastStepTime > 250) {
            this.stepCounter++;
            this.lastStepTime = Date.now();
            this.syncBPMToSteps();
          }
          
          if (newMotion > 4) {
            this.gestureRecognition.shake += 0.3;
            if (this.gestureRecognition.shake > 2) {
              this.triggerShakeEffects();
            }
          }
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 100;
          const velocityY = (newY - lastMouse.y) / dt * 100;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.3;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          this.orientation.alpha = (newX / 100) * 360;
          this.orientation.beta = (newY - 50) * 1.8;
          this.orientation.gamma = 0;
          this.updateListenerOrientation();
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.8 + newMotion * 0.2;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 150) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        // Track last motion for void state
        if (this.motion > 0.3) {
          this.lastMotionTime = Date.now();
          if (this.voidPhase) {
            this.exitVoidState();
          }
        }
        
        if (Date.now() - this.lastMotionTime > 5000 && !this.voidPhase) {
          this.enterVoidState();
        }
        
        if (!this.firstMovement && this.motion > 1.5) {
          this.firstMovement = true;
          this.evolveToBuildup();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        const variance = this.intensity;
        const recentHistory = this.motionHistory.slice(-40);
        const isRhythmic = recentHistory.filter(m => m > 2.5).length > 20 && variance < 2;
        const isErratic = variance > 2.5 && avgMotion > 2;
        const isSustained = avgMotion > 2.5 && variance < 1.5;
        const isChaotic = variance > 4 && avgMotion > 4;
        this.motionPattern = isChaotic ? 'chaotic' : isErratic ? 'erratic' : isRhythmic ? 'rhythmic' : isSustained ? 'sustained' : 'calm';
        
        this.updateTechniques(avgMotion, variance);
        this.updateEvolution();
        
        // Update procedural noise
        this.updateProceduralNoise(avgMotion, variance);
      }

      enterVoidState() {
        console.log('ðŸŒŒ ENTERING VOID STATE: Silent Breakdown');
        this.voidPhase = true;
        this.stage = 'VOID';
        this.elements.orb.className = 'orb void';
        this.currentTheme = 'void';
        
        // Fade out all active layers
        Object.keys(this.layerGains).forEach(layer => {
          this.layerGains[layer].gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        });
        Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
        
        // Play void ambience
        this.playVoidAmbience();
      }

      exitVoidState() {
        console.log('ðŸŒŒ EXITING VOID STATE: Returning to Buildup');
        this.voidPhase = false;
        this.stage = 'BUILDUP';
        this.elements.orb.className = 'orb buildup';
        this.currentTheme = 'buildup';
        
        // Kickstart basic layers to ensure smooth transition
        this.layers.hats = true;
        this.layers.fx = true;
        this.layers.wobble = true;
        this.layers.sub = true;
        this.layers.eightOhEight = true;
        this.motionHistory = Array(150).fill(3); // Boost history to activate layers
        this.totalMotion += 300; // Boost total to pass thresholds
        this.evolveToBuildup(); // Force evolution
        
        // Switch to next song in order
        this.currentSongIndex = (this.currentSongIndex + 1) % this.songs.length;
        this.setSong(this.currentSongIndex);
      }

      playVoidAmbience() {
        // Glitch pad with binaural beats for depth
        const duration = 20;
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < 3; i++) {
          const oscLeft = this.ctx.createOscillator();
          const gainLeft = this.ctx.createGain();
          const filterLeft = this.ctx.createBiquadFilter();
          
          oscLeft.type = 'sine';
          oscLeft.frequency.value = 110 * Math.pow(2, i / 4);
          
          filterLeft.type = 'lowpass';
          filterLeft.frequency.value = 400;
          filterLeft.Q.value = 0.5;
          
          gainLeft.gain.setValueAtTime(0, now);
          gainLeft.gain.linearRampToValueAtTime(0.05, now + 5);
          gainLeft.gain.setValueAtTime(0.05, now + duration - 5);
          gainLeft.gain.linearRampToValueAtTime(0, now + duration);
          
          oscLeft.connect(filterLeft).connect(gainLeft).connect(this.convolver);
          gainLeft.connect(this.masterGain);
          this.layerPanners.fx.positionX.value = -1;
          
          oscLeft.start(now);
          oscLeft.stop(now + duration);
          
          const oscRight = this.ctx.createOscillator();
          const gainRight = this.ctx.createGain();
          const filterRight = this.ctx.createBiquadFilter();
          
          oscRight.type = 'sine';
          oscRight.frequency.value = 110 * Math.pow(2, i / 4) + 0.5; // Slight detune for binaural
        
          filterRight.type = 'lowpass';
          filterRight.frequency.value = 400;
          filterRight.Q.value = 0.5;
          
          gainRight.gain.setValueAtTime(0, now);
          gainRight.gain.linearRampToValueAtTime(0.05, now + 5);
          gainRight.gain.setValueAtTime(0.05, now + duration - 5);
          gainRight.gain.linearRampToValueAtTime(0, now + duration);
          
          oscRight.connect(filterRight).connect(gainRight).connect(this.convolver);
          gainRight.connect(this.masterGain);
          this.layerPanners.fx.positionX.value = 1;
          
          oscRight.start(now);
          oscRight.stop(now + duration);
        }
        
        // Continue void ambience if still in void state
        if (this.voidPhase && this.active) {
          setTimeout(() => this.playVoidAmbience(), 15000);
        }
      }

      updateTechniques(avgMotion, variance) {
        if (avgMotion > 2 && variance > 1.5) {
          this.wobbleIntensity = Math.min(this.wobbleIntensity + 0.02, 1);
          this.dropBuildup = Math.min(this.dropBuildup + 0.01, 1);
          this.currentTechnique = 'wobble-rising';
        } else if (avgMotion < 1) {
          this.wobbleIntensity = Math.max(this.wobbleIntensity - 0.01, 0);
          this.dropBuildup = Math.max(this.dropBuildup - 0.005, 0);
          this.currentTechnique = 'wobble-calm';
        }
        
        this.buildPhase = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 2;
        this.releasePhase = this.motionPattern === 'calm' && this.totalMotion > 100;
        this.climaxPhase = this.motionPattern === 'chaotic' && variance > 4;
        this.dimensionalPhase = this.specialEvents.dimensionalRift > 0 || this.easterEggs.fibonacciSpiral;
        
        if (this.climaxPhase) this.currentTechnique = 'drop';
        else if (this.buildPhase) this.currentTechnique = 'buildup';
        else if (this.releasePhase) this.currentTechnique = 'breakdown';
        else if (this.dimensionalPhase) this.currentTechnique = 'riddim';
        
        this.glitchProbability = Math.min(variance / 10, 0.3);
        if (this.motionPattern === 'chaotic') this.glitchProbability += 0.2;
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
      }

      syncBPMToSteps() {
        if (this.stepCounter < 4) return;
        
        const stepInterval = (Date.now() - this.lastStepTime * (this.stepCounter - 1)) / (this.stepCounter - 1);
        const targetBPM = 60 / (stepInterval / 1000) * 1.5;
        
        this.bpm = this.bpm * 0.6 + targetBPM * 0.4;
        this.bpm = Math.max(100, Math.min(160, this.bpm));
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        if (this.voidPhase) {
          Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
          return;
        }
        
        const song = this.songs[this.currentSongIndex];
        const activationThreshold = (this.buildPhase ? 0.8 : 1.5) * (song.layerBiases || {})['eightOhEight'] || 1.0; 
        
        // More nuanced layer activation based on motion type and song biases
        this.layers.eightOhEight = (this.motionPattern === 'rhythmic' || this.motionPattern === 'chaotic') && avgMotion > activationThreshold * (song.layerBiases.eightOhEight || 1.0);
        this.layers.sub = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 1.5 * (song.layerBiases.sub || 1.0);
        this.layers.hats = true; // Hi-hats always on after start for EDM feel
        this.layers.clap = this.motionPattern === 'erratic' || this.intensity > 2 * (song.layerBiases.clap || 1.0);
        this.layers.wobble = this.motionPattern !== 'calm' && this.stage !== 'SILENCE' && avgMotion > 0.5 * (song.layerBiases.wobble || 1.0);
        this.layers.fx = true; // Always on for EDM texture, biased
        this.layers.growl = this.buildPhase && this.intensity > 2.0 * (song.layerBiases.growl || 1.0);
        this.layers.riser = this.wobbleIntensity > 0.1 || this.buildPhase * (song.layerBiases.riser || 1.0);
        this.layers.buildup = this.buildPhase && this.gestureRecognition.sustained > 0.5 * (song.layerBiases.buildup || 1.0);
        this.layers.dropimpact = this.gestureRecognition.shake > 0.5 || this.climaxPhase * (song.layerBiases.dropimpact || 1.0);
        
        this.evolutionProgress = Math.min(this.totalMotion / 1200, 3);
        this.subStage = Math.floor(this.evolutionProgress);
        
        if (this.stage === 'BUILDUP' && this.totalMotion > 300) {
          this.evolveToDrop();
        } else if (this.stage === 'DROP' && this.totalMotion > 700) {
          this.evolveToBreakdown();
        } else if (this.stage === 'BREAKDOWN' && this.totalMotion > 1200 && this.dimensionalPhase) {
          this.evolveToRiddim();
        }
        
        let baseBPM = 140 + (avgMotion * 5) + (this.intensity * 3);
        baseBPM += (this.subStage * 10);
        if (this.stage === 'BUILDUP') baseBPM += 10;
        else if (this.stage === 'DROP') baseBPM += 20;
        else if (this.stage === 'BREAKDOWN') baseBPM -= 20;
        else if (this.stage === 'RIDDIM') baseBPM += 10;
        
        if (this.buildPhase) baseBPM *= 1.1;
        if (this.releasePhase) baseBPM *= 0.9;
        if (this.climaxPhase) baseBPM *= 1.2;
        
        this.bpm = this.bpm * 0.85 + baseBPM * 0.15;
        this.bpm = Math.max(100, Math.min(160, this.bpm));
        
        this.updateCinematicTheme(avgMotion, this.intensity);
      }

      updateCinematicTheme(avgMotion, intensity) {
        let newTheme = 'buildup';
        
        if (this.voidPhase) newTheme = 'void';
        else if (this.dimensionalPhase) newTheme = 'riddim';
        else if (this.motionPattern === 'chaotic' || intensity > 4) newTheme = 'glitch';
        else if (avgMotion > 4 && intensity > 3 && this.buildPhase) newTheme = 'drop';
        else if (avgMotion > 2.5 && intensity > 2) newTheme = 'riddim';
        else if (avgMotion > 1.5) newTheme = 'buildup';
        else if (avgMotion < 1.5 && this.totalMotion > 150 && this.releasePhase) newTheme = 'breakdown';
        
        if (this.songs[this.currentSongIndex].name.includes('Code')) {
          newTheme = 'glitch'; // Override for glitchy tense feel
        }
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
        }
      }

      triggerShakeEffects() {
        console.log('ðŸŒªï¸ SHAKE DETECTED: Drop Unleashed');
        this.gestureRecognition.shake = 0;
        this.specialEvents.glitchStorm = 2;
        this.layers.dropimpact = true;
        this.bpm += 10;
      }

      evolveToBuildup() {
        this.voidPhase = false;
        this.stage = 'BUILDUP';
        this.elements.orb.className = 'orb buildup';
        this.createParticles(40, '#ff00ff', '#ff00ff');
        console.log('ðŸ”¥ BUILDUP EVOLUTION: Tension Builds');
      }

      evolveToDrop() {
        this.stage = 'DROP';
        this.transposition += 7;
        this.elements.orb.className = 'orb drop';
        this.createParticles(60, '#00ff00');
        console.log('ðŸŒŠ DROP EVOLUTION: Bass Hits Hard');
      }

      evolveToBreakdown() {
        this.stage = 'BREAKDOWN';
        this.transposition += 7;
        this.elements.orb.className = 'orb breakdown';
        this.createParticles(80, '#ff9900');
        console.log('âœ¨ BREAKDOWN EVOLUTION: Chill Vibes');
      }

      evolveToRiddim() {
        this.stage = 'RIDDIM';
        this.elements.orb.className = 'orb riddim';
        this.createParticles(100, '#ffff00');
        this.dimensionalPhase = true;
        console.log('ðŸŒŒ RIDDIM EVOLUTION: Grimy Flow');
      }

      createParticles(count, color) {
        const existing = document.querySelector('.particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.background = color;
          particle.style.animationDelay = Math.random() * 12 + 's';
          particle.style.animationDuration = (6 + Math.random() * 8) + 's';
          container.appendChild(particle);
        }
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.updateHarmony();
          }
          
          const interval = (60 / this.bpm) * 250;
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep() {
        // Skip playback during void phase
        if (this.voidPhase) return;
        
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
        }
        
        // Rhythmic patterns
        if (this.layers.eightOhEight && this.step % 4 === 0) this.playEightOhEight(); 
        if (this.layers.sub && this.step % 4 === 0) this.playSub();
        if (this.layers.hats && this.step % 4 === 0) this.playHats();
        if (this.layers.clap && this.step % 8 === 4) this.playClap();
        if (this.layers.wobble && this.step % 1 === 0) this.playWobble();
        if (this.layers.fx && Math.random() < 0.03 && this.releasePhase) this.playFx();
        if (this.layers.growl && this.step % 16 === 0 && this.buildPhase) this.playGrowl();
        if (this.layers.riser && this.step % 8 === 0) this.playRiser();
        if (this.layers.buildup && this.step % 64 === 0) this.playBuildup();
        if (this.layers.dropimpact && Math.random() < 0.3) this.playDropImpact();
        
        // Glitch effects in chaotic mode
        if (this.motionPattern === 'chaotic' && Math.random() < this.glitchProbability) {
          this.applyGlitchEffect();
        }
        
        // Update special events
        Object.keys(this.specialEvents).forEach(event => {
          this.specialEvents[event] = Math.max(0, this.specialEvents[event] - 0.01);
        });
      }

      applyGlitchEffect() {
        // Temporary distortion or detune on random layer
        const layers = Object.keys(this.layers).filter(l => this.layers[l]);
        if (layers.length === 0) return;
        const randomLayer = layers[Math.floor(Math.random() * layers.length)];
        const glitchDuration = 0.1 + Math.random() * 0.2;
        
        const detuneAmount = (Math.random() - 0.5) * 200;
        // Assuming we can add a temporary wave shaper or detune, but for simplicity, adjust gain or filter
        this.layerGains[randomLayer].gain.linearRampToValueAtTime(1.0, this.ctx.currentTime + glitchDuration / 2); 
        this.layerGains[randomLayer].gain.linearRampToValueAtTime(0.65, this.ctx.currentTime + glitchDuration);
        console.log(`Glitch applied to ${randomLayer}`);
      }

      playEightOhEight() {
        const osc = this.ctx.createOscillator();
        const subOsc = this.ctx.createOscillator();
        const extraSub = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const comp = this.ctx.createDynamicsCompressor();
        
        if (!this.allocateVoice('eightOhEight', osc, gain, 0.8)) return;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(55 + this.intensity * 5, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(28, this.ctx.currentTime + 0.8); 
        
        subOsc.type = 'sine';
        subOsc.frequency.value = 35;
        subOsc.frequency.exponentialRampToValueAtTime(18, this.ctx.currentTime + 0.8);

        extraSub.type = 'sine';
        extraSub.frequency.value = 25;
        extraSub.frequency.exponentialRampToValueAtTime(15, this.ctx.currentTime + 0.8);
        
        env.gain.setValueAtTime(1.4, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8); 
        
        comp.threshold.value = -20;
        comp.ratio.value = 8;
        
        gain.gain.value = 1.4;
        
        osc.connect(env);
        subOsc.connect(env);
        extraSub.connect(env);
        env.connect(comp).connect(gain).connect(this.layerGains.eightOhEight);
        osc.start();
        subOsc.start();
        extraSub.start();
        osc.stop(this.ctx.currentTime + 0.8);
        subOsc.stop(this.ctx.currentTime + 0.8);
        extraSub.stop(this.ctx.currentTime + 0.8);
      }

      playSub() {
        const noteIndex = this.bassNote % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 1);
        
        const osc = this.ctx.createOscillator();
        const subOsc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('sub', osc, gain, 0.8)) return;
        
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        subOsc.type = 'sine';
        subOsc.frequency.value = freq / 2;
        
        filter.type = 'lowpass';
        filter.frequency.value = 80 + this.motion * 20;
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(1.2, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8); 
        
        gain.gain.value = 1.0;
        
        osc.connect(filter);
        subOsc.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.sub);
        osc.start();
        subOsc.start();
        osc.stop(this.ctx.currentTime + 0.8);
        subOsc.stop(this.ctx.currentTime + 0.8);
      }

      playHats() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('hats', noise, gain, 0.05)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 5000;
        filter.Q.value = 1;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
        
        gain.gain.value = 0.3;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.hats);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.05);
      }

      playClap() {
        const osc1 = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('clap', osc1, gain, 0.15)) return;
        
        osc1.type = 'triangle';
        osc1.frequency.setValueAtTime(160 + this.intensity * 10, this.ctx.currentTime);
        osc1.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.05);
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.15, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1.5;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
        
        gain.gain.value = 0.5;
        
        osc1.connect(filter).connect(env).connect(gain).connect(this.layerGains.clap);
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.clap);
        osc1.start();
        noise.start();
        osc1.stop(this.ctx.currentTime + 0.15);
        noise.stop(this.ctx.currentTime + 0.15);
      }

      playWobble() {
        const noteIndex = this.wobblePattern[this.wobbleIndex % this.wobblePattern.length];
        const freq = this.noteToFreq(noteIndex, 2);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        
        if (!this.allocateVoice('wobble', osc, gain, 0.25)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        lfo.type = 'sawtooth';
        lfo.frequency.value = 20 + this.intensity * 20;
        lfo.connect(filter.frequency);
        lfo.start();
        lfo.stop(this.ctx.currentTime + 0.25);
        
        filter.type = 'lowpass';
        filter.frequency.value = 200 + this.motion * 50;
        filter.Q.value = 15;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
        
        gain.gain.value = 0.6;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.wobble);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.25);
        
        this.wobbleIndex++;
      }

      playFx() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 5);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('fx', osc, gain, 20)) return;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 100 + 100; 
        filter.Q.value = 12;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 20);
        
        gain.gain.value = 0.1;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.fx);
        osc.start();
        osc.stop(this.ctx.currentTime + 20);
        
        this.noiseGain.gain.linearRampToValueAtTime(0.12, this.ctx.currentTime + 4); 
      }

      playGrowl() {
        const note = this.scale[Math.floor(this.scale.length / 2)];
        const freq = this.noteToFreq(note, 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const vibrato = this.ctx.createOscillator();
        
        if (!this.allocateVoice('growl', osc, gain, 3)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        vibrato.type = 'sine';
        vibrato.frequency.value = 5;
        vibrato.connect(osc.detune);
        vibrato.start();
        vibrato.stop(this.ctx.currentTime + 3);
        
        filter.type = 'lowpass';
        filter.frequency.value = 600 + this.intensity * 200; 
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(0.1, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 1.5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.growl);
        osc.start();
        osc.stop(this.ctx.currentTime + 3);
      }

      playRiser() {
        const baseFreq = 200;
        const riserLayers = 6; 
        
        for (let i = 0; i < riserLayers; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('riser', osc, gain, 4)) return;
          
          const freq = baseFreq * Math.pow(2, i / 2);
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(freq * 1.2, this.ctx.currentTime + 4); 
          
          const amplitude = Math.sin((i / riserLayers) * Math.PI) * this.wobbleIntensity;
          
          env.gain.setValueAtTime(amplitude, this.ctx.currentTime);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          gain.gain.value = 0.35;
          
          osc.connect(env).connect(gain).connect(this.layerGains.riser);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
        }
      }

      playBuildup() {
        const duration = 5 + this.intensity * 3;
        const osc = this.ctx.createOscillator();
        const lowSweep = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('buildup', osc, gain, duration)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(2500, this.ctx.currentTime + duration);
        
        lowSweep.type = 'sine';
        lowSweep.frequency.setValueAtTime(20, this.ctx.currentTime);
        lowSweep.frequency.exponentialRampToValueAtTime(60, this.ctx.currentTime + duration);
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.4;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(120, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(12000, this.ctx.currentTime + duration);
        filter.Q.value = 6;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + duration);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter);
        lowSweep.connect(filter);
        noise.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.buildup);
        
        osc.start();
        lowSweep.start();
        noise.start();
        osc.stop(this.ctx.currentTime + duration);
        lowSweep.stop(this.ctx.currentTime + duration);
        noise.stop(this.ctx.currentTime + duration);
      }

      playDropImpact() {
        const freq = 50 + 30; 
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('dropimpact', osc, gain, 1.5)) return;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq * 2.5, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 0.08);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 12, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(freq * 3, this.ctx.currentTime + 0.4);
        filter.Q.value = 6;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.3, this.ctx.currentTime + 0.04);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        gain.gain.value = 0.8;
        
        osc.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.dropimpact);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
      }

      playGoldenRatioChord() {
        console.log('âœ¨ GOLDEN RATIO CHORD: Divine Wobble');
        const phi = 1.618033988749;
        const baseFreq = 220;
        const duration = 12;
        
        const ratios = [1, phi, phi * phi, 1 / phi];
        
        ratios.forEach((ratio, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('riser', osc, gain, duration)) return;
          
          osc.type = 'sine';
          osc.frequency.value = baseFreq * ratio;
          
          filter.type = 'bandpass';
          filter.frequency.value = baseFreq * ratio;
          filter.Q.value = 20;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 3);
          env.gain.setValueAtTime(0.3, this.ctx.currentTime + duration - 3);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          gain.gain.value = 0.15;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.riser);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        });
        
        this.easterEggs.goldenRatio = true;
      }

      allocateVoice(layer, source, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) return false;
        
        pool.active = pool.active.filter(voice => {
          if (voice && voice.source && this.ctx.currentTime > voice.startTime + duration + 0.1) {
            voice.source.stop();
            return false;
          }
          return true;
        });
        
        if (pool.active.length >= pool.max) {
          const oldest = pool.active.shift();
          if (oldest && oldest.source) {
            oldest.gain.gain.setValueAtTime(0, this.ctx.currentTime);
            oldest.source.stop(this.ctx.currentTime + 0.01);
          }
        }
        
        const voice = { source, gain: gainNode, startTime: this.ctx.currentTime };
        pool.active.push(voice);
        
        setTimeout(() => {
          const index = pool.active.indexOf(voice);
          if (index !== -1) pool.active.splice(index, 1);
        }, duration * 1000 + 100);
        
        return true;
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
      }

      noteToFreq(note, octave = 4) {
        const semitones = this.keyOffsets[this.key] + note + this.transposition;
        return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          const theme = this.themes[this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 4, 1);
          const motionNorm = Math.min(this.motion / 6, 1);
          
          let bg;
          if (this.voidPhase) {
            const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
            bg = `radial-gradient(circle at 50% 50%, rgba(75, 0, 130, ${0.1 + breathe * 0.1}) 5%, rgba(139,0,139,0.05 + breathe * 0.05) 20%, #000000 60%)`;
          } else if (this.dimensionalPhase) {
            const hue = (Date.now() / 10 % 360);
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 70%, ${20 + intensityNorm * 30}%) ${5 * motionNorm}%, hsl(${(hue + 120) % 360}, 70%, ${15 + intensityNorm * 20}%) ${20 * intensityNorm}%, #000000 ${60 + 30 * intensityNorm}%)`;
          } else {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
            bg += `${theme.colors[0]} ${5 * motionNorm}%, `;
            if (theme.colors[1]) bg += `${theme.colors[1]} ${20 * intensityNorm}%, `;
            bg += `#000000 ${60 + 30 * intensityNorm}%`;
            bg += ')';
          }
          
          document.body.style.background = bg;
          
          // Update dynamic 3D panning
          const targetX = Math.cos(this.direction * Math.PI / 180) * (this.motion + this.intensity) * 3;
          const targetY = Math.sin(this.direction * Math.PI / 180) * (this.motion + this.intensity) * 3;
          const targetZ = (this.orientation.gamma / 90) * (this.motion + this.intensity) * 2;
          
          Object.keys(this.layerPanners).forEach(name => {
            const scale = this.layerPanScales[name] || 1;
            const tx = this.basePositions[name].x + targetX * scale;
            const ty = this.basePositions[name].y + targetY * scale;
            const tz = this.basePositions[name].z + targetZ * scale;
            
            const pos = this.layerPositions[name];
            pos.x += (tx - pos.x) * this.panningLerp;
            pos.y += (ty - pos.y) * this.panningLerp;
            pos.z += (tz - pos.z) * this.panningLerp;
            
            if (this.layerPanners[name]) {
              this.layerPanners[name].positionX.value = pos.x;
              this.layerPanners[name].positionY.value = pos.y;
              this.layerPanners[name].positionZ.value = pos.z;
            }
          });
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    new GUMPEngine();
  </script>
</body>
</html>
