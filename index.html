<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Modulated Cinematic Void Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 3px;
      backdrop-filter: blur(15px);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
      transform: scale(1.1);
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.4) 40%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 60px rgba(255,255,255,0.6);
      backdrop-filter: blur(8px);
      filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));
      cursor: grab;
    }
    
    .orb:active {
      cursor: grabbing;
    }
    
    .orb.pulse {
      transform: translate(-50%, -50%) scale(1.5);
    }
    
    .orb.void {
      opacity: 0.5;
      box-shadow: 0 0 100px rgba(255,215,0,0.6);
      filter: drop-shadow(0 0 40px rgba(255,215,0,0.4));
    }
    
    .ui-minimal {
      position: fixed;
      top: 15px;
      left: 15px;
      font-size: 9px;
      color: rgba(255,255,255,0.6);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.2);
      padding: 8px 12px;
      border-radius: 4px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .stage-name {
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 4px;
      font-weight: bold;
    }
    
    .metric {
      margin: 2px 0;
      font-size: 8px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: normal;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.7) 100%);
      opacity: 0;
      transition: opacity 4s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .waveform {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
      pointer-events: none;
      z-index: 3;
      opacity: 0.6;
    }
    
    .wave-bar {
      position: absolute;
      bottom: 0;
      width: 16px;
      background: linear-gradient(0deg, rgba(255,255,255,0.6), rgba(255,255,255,0.1));
      border-radius: 2px 2px 0 0;
      transition: height 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">DRAG ORB TO MODULATE SOUND</div>
    
    <div class="ui-minimal" id="uiMinimal">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">BPM: <span id="bpmDisplay">60</span> | INTENSITY: <span id="intensityDisplay">0%</span></div>
    </div>
    
    <div class="waveform" id="waveform"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class ModulatedVoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        this.bpm = 60;
        this.step = 0;
        
        this.motion = 0;
        this.intensity = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.firstMovement = false;
        this.noMotionCounter = 0;
        this.isVoid = true;
        
        this.stage = 'VOID';
        this.totalMotion = 0;
        
        this.masterGain = null;
        this.limiter = null;
        this.compressor = null;
        this.masterEQ = null;
        this.reverb = null;
        this.delay = null;
        
        this.listener = null;
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        this.layers = ['strings', 'harmonics', 'drums', 'bass', 'melody', 'ambient', 'healing'];
        this.layerGains = {};
        this.layerCompressors = {};
        this.layerEQs = {};
        this.layerPanners = {};
        this.layerFilters = {};
        
        this.key = 'C';
        this.mode = 'major';
        this.scale = [0, 2, 4, 5, 7, 9, 11];
        this.chordProgression = [[0, 4, 7], [5, 9, 0], [7, 11, 2], [0, 4, 7]];
        this.currentChordIndex = 0;
        
        this.healingFrequencies = [174, 285, 396, 417, 528, 639, 741, 852, 963];
        
        this.ambientNoise = null;
        this.ambientGain = null;
        this.ambientFilter = null;
        this.ambientLFO = null;
        
        this.elements = {};
        this.waveBars = [];
        this.isDragging = false;
        this.dragOffset = { x: 0, y: 0 };
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'bpmDisplay', 'intensityDisplay', 'uiMinimal',
         'cinematicOverlay', 'waveform', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupWaveformVisualizer();
        this.setupOrbDrag();
      }

      setupOrbDrag() {
        const orb = this.elements.orb;
        
        const startDrag = (e) => {
          e.preventDefault();
          this.isDragging = true;
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          this.dragOffset.x = clientX - orb.getBoundingClientRect().left;
          this.dragOffset.y = clientY - orb.getBoundingClientRect().top;
        };
        
        const drag = (e) => {
          if (!this.isDragging) return;
          e.preventDefault();
          const clientX = e.touches ? e.touches[0].clientX : e.clientX;
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          this.pos.x = ((clientX - this.dragOffset.x) / window.innerWidth) * 100;
          this.pos.y = ((clientY - this.dragOffset.y) / window.innerHeight) * 100;
          this.pos.x = Math.max(0, Math.min(100, this.pos.x));
          this.pos.y = Math.max(0, Math.min(100, this.pos.y));
          this.motion = 5; // Simulate motion during drag
          this.noMotionCounter = 0;
          if (this.isVoid) this.exitVoid();
        };
        
        const endDrag = () => {
          this.isDragging = false;
        };
        
        orb.addEventListener('mousedown', startDrag);
        orb.addEventListener('touchstart', startDrag);
        window.addEventListener('mousemove', drag);
        window.addEventListener('touchmove', drag);
        window.addEventListener('mouseup', endDrag);
        window.addEventListener('touchend', endDrag);
      }

      setupWaveformVisualizer() {
        for (let i = 0; i < 16; i++) {
          const bar = document.createElement('div');
          bar.className = 'wave-bar';
          bar.style.left = (i * (100 / 16)) + '%';
          bar.style.width = (100 / 16) + '%';
          bar.style.height = '0px';
          this.elements.waveform.appendChild(bar);
          this.waveBars.push(bar);
        }
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          this.orientation.alpha = e.alpha || 0;
          this.orientation.beta = e.beta || 0;
          this.orientation.gamma = e.gamma || 0;
          this.updateListenerOrientation();
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;
        const now = this.ctx.currentTime;
        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;
        
        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);
        
        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);
        
        this.listener.forwardX.linearRampToValueAtTime(forwardX, now + 0.05);
        this.listener.forwardY.linearRampToValueAtTime(forwardY, now + 0.05);
        this.listener.forwardZ.linearRampToValueAtTime(forwardZ, now + 0.05);
        this.listener.upX.linearRampToValueAtTime(upX, now + 0.05);
        this.listener.upY.linearRampToValueAtTime(upY, now + 0.05);
        this.listener.upZ.linearRampToValueAtTime(upZ, now + 0.05);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent.requestPermission === 'function') {
            await DeviceMotionEvent.requestPermission();
          }
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }

          this.ctx = new AudioContext({ sampleRate: 48000 }); // Higher sample rate for quality
          await this.ctx.resume();
          this.setupAudioChain();
          this.setupAmbientBackground();
          this.setLayerPositions();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 5000);
          }, 1500);

          this.active = true;
          this.startSequencer();
          this.animate();
        } catch (e) {
          console.error('Failed to start engine:', e);
        }
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 2048;
        this.analyser.smoothingTimeConstant = 0.8;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -3;
        this.limiter.knee.value = 2;
        this.limiter.ratio.value = 18;
        this.limiter.attack.value = 0.002;
        this.limiter.release.value = 0.05;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -18;
        this.compressor.knee.value = 8;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.004;
        this.compressor.release.value = 0.15;
        
        this.masterEQ = this.createMultibandEQ();
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.9;
        
        this.reverb = this.ctx.createConvolver();
        this.reverb.buffer = this.createReverbBuffer(4);
        const reverbGain = this.ctx.createGain();
        reverbGain.gain.value = 0.3;
        this.reverb.connect(reverbGain);
        reverbGain.connect(this.compressor);
        
        this.delay = this.ctx.createDelay(1.5);
        this.delay.delayTime.value = 0.45;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.4;
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.type = 'lowpass';
        delayFilter.frequency.value = 3500;
        delayFilter.Q.value = 0.8;
        this.delay.connect(delayFilter);
        delayFilter.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.2;
        this.delay.connect(delayMix);
        delayMix.connect(this.compressor);
        
        this.listener = this.ctx.listener;
        
        this.layers.forEach(layer => {
          this.layerGains[layer] = this.ctx.createGain();
          this.layerCompressors[layer] = this.ctx.createDynamicsCompressor();
          this.layerEQs[layer] = this.createLayerEQ(layer);
          this.layerPanners[layer] = this.ctx.createPanner();
          this.layerPanners[layer].panningModel = 'HRTF';
          this.layerPanners[layer].distanceModel = 'inverse';
          this.layerPanners[layer].refDistance = 0.5;
          this.layerPanners[layer].maxDistance = 5000;
          this.layerPanners[layer].rolloffFactor = 1.2;
          this.layerPanners[layer].coneInnerAngle = 45;
          this.layerPanners[layer].coneOuterAngle = 90;
          this.layerPanners[layer].coneOuterGain = -12;
          
          this.layerFilters[layer] = this.ctx.createBiquadFilter();
          this.layerFilters[layer].type = 'lowpass';
          this.layerFilters[layer].frequency.value = 18000;
          this.layerFilters[layer].Q.value = 0.6;
          
          this.layerGains[layer].connect(this.layerFilters[layer]);
          this.layerFilters[layer].connect(this.layerCompressors[layer]);
          this.layerCompressors[layer].connect(this.layerEQs[layer]);
          this.layerEQs[layer].connect(this.layerPanners[layer]);
          this.layerPanners[layer].connect(this.compressor);
          
          if (['strings', 'harmonics', 'ambient', 'healing', 'melody'].includes(layer)) {
            const revSend = this.ctx.createGain();
            revSend.gain.value = layer === 'ambient' ? 0.45 : layer === 'healing' ? 0.35 : 0.25;
            this.layerPanners[layer].connect(revSend);
            revSend.connect(this.reverb);
          }
          
          if (['harmonics', 'melody', 'healing'].includes(layer)) {
            const delSend = this.ctx.createGain();
            delSend.gain.value = 0.25;
            this.layerPanners[layer].connect(delSend);
            delSend.connect(this.delay);
          }
        });
        
        this.compressor.connect(this.masterEQ);
        this.masterEQ.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      createMultibandEQ() {
        const input = this.ctx.createGain();
        
        const lowShelf = this.ctx.createBiquadFilter();
        lowShelf.type = 'lowshelf';
        lowShelf.frequency.value = 100;
        lowShelf.gain.value = 1.5;
        
        const lowMid = this.ctx.createBiquadFilter();
        lowMid.type = 'peaking';
        lowMid.frequency.value = 350;
        lowMid.Q.value = 0.9;
        lowMid.gain.value = 0.8;
        
        const highMid = this.ctx.createBiquadFilter();
        highMid.type = 'peaking';
        highMid.frequency.value = 2200;
        highMid.Q.value = 0.9;
        highMid.gain.value = 1.2;
        
        const highShelf = this.ctx.createBiquadFilter();
        highShelf.type = 'highshelf';
        highShelf.frequency.value = 10000;
        highShelf.gain.value = 2.5;
        
        input.connect(lowShelf);
        lowShelf.connect(lowMid);
        lowMid.connect(highMid);
        highMid.connect(highShelf);
        
        return input;
      }

      createLayerEQ(layer) {
        const input = this.ctx.createGain();
        
        const low = this.ctx.createBiquadFilter();
        low.type = 'lowshelf';
        low.frequency.value = 150;
        low.gain.value = layer === 'drums' || layer === 'bass' ? 3 : layer === 'ambient' ? -3 : 0;
        
        const mid = this.ctx.createBiquadFilter();
        mid.type = 'peaking';
        mid.frequency.value = 1200;
        mid.Q.value = 1.2;
        mid.gain.value = layer === 'strings' || layer === 'melody' ? 2 : layer === 'harmonics' ? -1.5 : 0;
        
        const high = this.ctx.createBiquadFilter();
        high.type = 'highshelf';
        high.frequency.value = 6000;
        high.gain.value = layer === 'healing' || layer === 'ambient' ? 2 : layer === 'drums' ? -2 : 1;
        
        input.connect(low);
        low.connect(mid);
        mid.connect(high);
        
        return input;
      }

      createReverbBuffer(length) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * length, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 4);
          }
        }
        return buffer;
      }

      setupAmbientBackground() {
        const bufferSize = this.ctx.sampleRate * 5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        let last = 0;
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          data[i] = (last + (0.01 * white)) / 1.01;
          last = data[i];
          data[i] *= 4;
        }
        
        this.ambientNoise = this.ctx.createBufferSource();
        this.ambientNoise.buffer = buffer;
        this.ambientNoise.loop = true;
        
        this.ambientFilter = this.ctx.createBiquadFilter();
        this.ambientFilter.type = 'lowpass';
        this.ambientFilter.frequency.value = 300;
        this.ambientFilter.Q.value = 0.3;
        
        this.ambientGain = this.ctx.createGain();
        this.ambientGain.gain.value = 0.05;
        
        this.ambientLFO = this.ctx.createOscillator();
        this.ambientLFO.type = 'sine';
        this.ambientLFO.frequency.value = 0.1;
        const lfoGain = this.ctx.createGain();
        lfoGain.gain.value = 100;
        this.ambientLFO.connect(lfoGain);
        lfoGain.connect(this.ambientFilter.frequency);
        
        this.ambientNoise.connect(this.ambientFilter);
        this.ambientFilter.connect(this.ambientGain);
        this.ambientGain.connect(this.layerGains.ambient);
        this.ambientNoise.start();
        this.ambientLFO.start();
      }

      setLayerPositions() {
        const positions = {
          strings: { x: 0, y: 0, z: -4 },
          harmonics: { x: 3, y: -3, z: -6 },
          drums: { x: -3, y: 3, z: -2 },
          bass: { x: 3, y: 3, z: -3 },
          melody: { x: -3, y: -3, z: -5 },
          ambient: { x: 0, y: 4, z: 12 },
          healing: { x: 0, y: 2, z: 10 }
        };
        
        Object.entries(positions).forEach(([layer, pos]) => {
          this.layerPanners[layer].positionX.value = pos.x;
          this.layerPanners[layer].positionY.value = pos.y;
          this.layerPanners[layer].positionZ.value = pos.z;
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc) return;
          
          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.motion = this.motion * 0.85 + newMotion * 0.15;
          this.motionHistory.push(this.motion);
          if (this.motionHistory.length > 30) this.motionHistory.shift();
          
          this.intensity = this.motionHistory.reduce((sum, m) => sum + m, 0) / this.motionHistory.length;
          
          this.velocity.x += acc.x * 0.02;
          this.velocity.y += acc.y * 0.02;
          this.pos.x = Math.max(0, Math.min(100, this.pos.x + this.velocity.x));
          this.pos.y = Math.max(0, Math.min(100, this.pos.y + this.velocity.y));
          this.velocity.x *= 0.92;
          this.velocity.y *= 0.92;
          
          this.lastAccel = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
          
          if (this.motion > 1 && !this.firstMovement) {
            this.firstMovement = true;
            this.stage = 'ACTIVE';
          }
          
          if (this.motion > 4) {
            this.triggerDrums();
          }
          
          if (this.motion < 0.4) {
            this.noMotionCounter++;
            if (this.noMotionCounter > 40) this.enterVoid();
          } else {
            this.noMotionCounter = 0;
            if (this.isVoid) this.exitVoid();
          }
          
          this.updateModulation();
          this.updateAmbient();
        });
      }

      updateModulation() {
        const now = this.ctx.currentTime;
        const normX = this.pos.x / 100;
        const normY = this.pos.y / 100; // 0 top, 1 bottom
        
        const drumsVal = (1 - normX) * normY;
        const bassVal = normX * normY;
        const melodyVal = (1 - normX) * (1 - normY);
        const harmonicsVal = normX * (1 - normY);
        
        this.layerGains.drums.gain.linearRampToValueAtTime(drumsVal * 0.8, now + 0.2);
        this.layerGains.bass.gain.linearRampToValueAtTime(bassVal * 0.7, now + 0.2);
        this.layerGains.melody.gain.linearRampToValueAtTime(melodyVal * 0.6, now + 0.2);
        this.layerGains.harmonics.gain.linearRampToValueAtTime(harmonicsVal * 0.5, now + 0.2);
        
        // Complexity for drums: adjust BPM or add layers
        this.bpm = 50 + drumsVal * 70 + this.intensity * 10;
        
        // Spatial adjustment
        this.layerPanners.drums.positionX.linearRampToValueAtTime(-5 + normX * 10, now + 0.2);
        this.layerPanners.drums.positionY.linearRampToValueAtTime(5 - normY * 10, now + 0.2);
        
        this.layerPanners.bass.positionX.linearRampToValueAtTime(5 - normX * 10, now + 0.2);
        this.layerPanners.bass.positionY.linearRampToValueAtTime(5 - normY * 10, now + 0.2);
        
        this.layerPanners.melody.positionX.linearRampToValueAtTime(-5 + normX * 10, now + 0.2);
        this.layerPanners.melody.positionY.linearRampToValueAtTime(-5 + normY * 10, now + 0.2);
        
        this.layerPanners.harmonics.positionX.linearRampToValueAtTime(5 - normX * 10, now + 0.2);
        this.layerPanners.harmonics.positionY.linearRampToValueAtTime(-5 + normY * 10, now + 0.2);
      }

      playStrings(now) {
        const baseFreq = this.noteToFreq(this.chordProgression[this.currentChordIndex][0], 3);
        const voices = 4; // Multi-voice for richness
        
        for (let v = 0; v < voices; v++) {
          const freq = baseFreq * (1 + (v - voices/2) * 0.002); // Slight detune
          const delayTime = 1 / freq;
          const bufferSize = Math.floor(this.ctx.sampleRate * delayTime);
          const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
          const data = buffer.getChannelData(0);
          for (let i = 0; i < bufferSize; i++) {
            data[i] = (Math.random() * 2 - 1) * (1 - i / bufferSize); // Saw-like excitation
          }
          
          const source = this.ctx.createBufferSource();
          source.buffer = buffer;
          source.loop = true;
          
          const delay = this.ctx.createDelay(delayTime);
          delay.delayTime.value = delayTime;
          
          const feedback = this.ctx.createGain();
          feedback.gain.value = 0.997 - v * 0.001; // Vary feedback for depth
          
          const lowpass = this.ctx.createBiquadFilter();
          lowpass.type = 'lowpass';
          lowpass.frequency.value = freq * 1.5 + v * 50;
          lowpass.Q.value = 0.5;
          
          const env = this.ctx.createGain();
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.4, now + 1.5);
          env.gain.exponentialRampToValueAtTime(0.001, now + 12);
          
          source.connect(lowpass);
          lowpass.connect(delay);
          delay.connect(feedback);
          feedback.connect(lowpass);
          delay.connect(env);
          env.connect(this.layerGains.strings);
          
          source.start(now);
          setTimeout(() => source.stop(), 12000);
        }
      }

      playHarmonics(now) {
        const chord = this.chordProgression[this.currentChordIndex];
        chord.forEach((note, i) => {
          const baseFreq = this.noteToFreq(note, 4 + i);
          for (let h = 1; h <= 5; h++) { // Additive synthesis
            const osc = this.ctx.createOscillator();
            osc.type = 'sine';
            osc.frequency.value = baseFreq * h;
            osc.detune.value = (Math.random() - 0.5) * 2;
            
            const env = this.ctx.createGain();
            env.gain.setValueAtTime(0, now);
            env.gain.linearRampToValueAtTime(0.25 / h, now + 1.2);
            env.gain.exponentialRampToValueAtTime(0.001, now + 8);
            
            osc.connect(env);
            env.connect(this.layerGains.harmonics);
            osc.start(now);
            osc.stop(now + 8);
          }
        });
      }

      triggerDrums() {
        const now = this.ctx.currentTime;
        const kickFreq = 55 + this.motion * 3;
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(kickFreq * 4, now);
        osc.frequency.exponentialRampToValueAtTime(kickFreq, now + 0.04);
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0.9, now);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.25);
        
        const comp = this.ctx.createDynamicsCompressor();
        comp.threshold.value = -12;
        comp.ratio.value = 6;
        
        osc.connect(comp);
        comp.connect(env);
        env.connect(this.layerGains.drums);
        osc.start(now);
        osc.stop(now + 0.25);
      }

      playBass(now) {
        const baseFreq = this.noteToFreq(this.chordProgression[this.currentChordIndex][0], 2);
        const delayTime = 1 / baseFreq;
        const bufferSize = Math.floor(this.ctx.sampleRate * delayTime);
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.sin(Math.PI * i / bufferSize); // Smooth excitation
        }
        
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        
        const delay = this.ctx.createDelay(delayTime);
        delay.delayTime.value = delayTime;
        
        const feedback = this.ctx.createGain();
        feedback.gain.value = 0.992;
        
        const lowpass = this.ctx.createBiquadFilter();
        lowpass.type = 'lowpass';
        lowpass.frequency.value = baseFreq * 1.2;
        lowpass.Q.value = 1.5;
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.7, now + 0.1);
        env.gain.exponentialRampToValueAtTime(0.001, now + 1.5);
        
        source.connect(lowpass);
        lowpass.connect(delay);
        delay.connect(feedback);
        feedback.connect(lowpass);
        delay.connect(env);
        env.connect(this.layerGains.bass);
        
        source.start(now);
        setTimeout(() => source.stop(), 1500);
      }

      playMelody(now) {
        const noteIndex = Math.floor(Math.random() * this.scale.length);
        const freq = this.noteToFreq(this.scale[noteIndex], 5);
        const osc = this.ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(800, now);
        filter.frequency.exponentialRampToValueAtTime(3000, now + 0.3);
        filter.frequency.exponentialRampToValueAtTime(1000, now + 2);
        filter.Q.value = 2;
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.5, now + 0.05);
        env.gain.exponentialRampToValueAtTime(0.001, now + 2);
        
        osc.connect(filter);
        filter.connect(env);
        env.connect(this.layerGains.melody);
        osc.start(now);
        osc.stop(now + 2);
      }

      playHealing(now) {
        const freqIndex = this.step % this.healingFrequencies.length;
        const freq = this.healingFrequencies[freqIndex];
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.15, now + 3);
        env.gain.exponentialRampToValueAtTime(0.001, now + 12);
        
        osc.connect(env);
        env.connect(this.layerGains.healing);
        osc.start(now);
        osc.stop(now + 12);
      }

      updateAmbient() {
        const now = this.ctx.currentTime;
        const targetFreq = 250 + Math.sin(now * 0.05) * 80 + this.intensity * 30;
        this.ambientFilter.frequency.linearRampToValueAtTime(targetFreq, now + 0.15);
        this.ambientGain.gain.linearRampToValueAtTime(0.04 + this.intensity * 0.01, now + 0.15);
      }

      enterVoid() {
        if (this.isVoid) return;
        this.isVoid = true;
        this.elements.orb.classList.add('void');
        this.elements.stageName.textContent = 'VOID';
        const now = this.ctx.currentTime;
        this.layerGains.strings.gain.linearRampToValueAtTime(0.2, now + 1.5);
        this.layerGains.harmonics.gain.linearRampToValueAtTime(0, now + 1.5);
        this.layerGains.drums.gain.linearRampToValueAtTime(0, now + 1.5);
        this.layerGains.bass.gain.linearRampToValueAtTime(0, now + 1.5);
        this.layerGains.melody.gain.linearRampToValueAtTime(0, now + 1.5);
        this.layerGains.healing.gain.linearRampToValueAtTime(0.4, now + 1.5);
      }

      exitVoid() {
        this.isVoid = false;
        this.elements.orb.classList.remove('void');
        this.elements.stageName.textContent = 'ACTIVE';
        const now = this.ctx.currentTime;
        this.layerGains.strings.gain.linearRampToValueAtTime(0.5, now + 1.5);
        this.layerGains.healing.gain.linearRampToValueAtTime(0, now + 1.5);
        this.updateModulation(); // Restore modulated gains
      }

      noteToFreq(note, octave) {
        return 440 * Math.pow(2, (note + (octave - 4) * 12) / 12);
      }

      updateUI() {
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.intensityDisplay.textContent = Math.round(this.intensity * 10) + '%';
        
        this.analyser.getByteFrequencyData(this.dataArray);
        this.waveBars.forEach((bar, i) => {
          const start = i * 32;
          const avg = this.dataArray.slice(start, start + 32).reduce((a, b) => a + b, 0) / 32;
          bar.style.height = (avg / 255 * 60) + 'px';
        });
      }

      animate() {
        requestAnimationFrame(this.animate.bind(this));
        if (!this.active) return;
        
        this.elements.orb.style.left = this.pos.x + '%';
        this.elements.orb.style.top = this.pos.y + '%';
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          const now = this.ctx.currentTime;
          this.playStep(now);
          if (!this.isVoid) {
            if (this.step % 2 === 0) this.playBass(now);
            if (this.step % 4 === 0) this.playMelody(now);
          }
          this.updateUI();
          this.step = (this.step + 1) % 16;
          const interval = 60000 / this.bpm / 4;
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep(now) {
        if (this.isVoid) {
          this.playHealing(now);
        } else {
          this.playStrings(now);
          this.playHarmonics(now);
        }
      }
    }

    new ModulatedVoidEngine();
  </script>
</body>
</html>
