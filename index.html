<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: The World Is The Song</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            cursor: none;
            font-family: 'Helvetica Neue', sans-serif;
        }

        /* Multi-dimensional orb system */
        .orb-container {
            position: fixed;
            inset: 0;
            pointer-events: none;
        }

        .orb {
            position: absolute;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            pointer-events: none;
            mix-blend-mode: screen;
        }

        .orb-core {
            width: 12px;
            height: 12px;
            background: radial-gradient(circle, 
                rgba(255,255,255,0.9) 0%, 
                rgba(255,255,255,0.4) 30%, 
                transparent 70%);
            box-shadow: 
                0 0 20px rgba(255,255,255,0.5),
                0 0 40px rgba(255,255,255,0.3);
            filter: blur(0.5px);
            z-index: 100;
        }

        .orb-echo {
            width: 60px;
            height: 60px;
            background: radial-gradient(circle,
                transparent 0%,
                rgba(255,255,255,0.05) 30%,
                transparent 70%);
            animation: orbit 8s linear infinite;
        }

        .orb-field {
            width: 200px;
            height: 200px;
            background: radial-gradient(circle,
                rgba(255,100,255,0.1) 0%,
                transparent 50%);
            animation: breathe 4s ease-in-out infinite;
        }

        @keyframes orbit {
            from { transform: translate(-50%, -50%) rotate(0deg) translateX(30px) rotate(0deg); }
            to { transform: translate(-50%, -50%) rotate(360deg) translateX(30px) rotate(-360deg); }
        }

        @keyframes breathe {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.3; }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 0.1; }
        }

        .orb-core.recording {
            background: radial-gradient(circle, 
                rgba(255,100,100,0.9) 0%, 
                rgba(255,0,0,0.4) 30%, 
                transparent 70%);
            box-shadow: 
                0 0 30px rgba(255,0,0,0.7),
                0 0 60px rgba(255,0,0,0.4);
            animation: rec-pulse 1s ease-in-out infinite;
        }

        @keyframes rec-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.3); }
        }

        /* Visual feedback layers */
        .freq-viz {
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            height: 100px;
            pointer-events: none;
            opacity: 0.3;
        }

        .freq-bar {
            display: inline-block;
            width: 2%;
            height: 100%;
            background: linear-gradient(to top, 
                rgba(255,255,255,0.1) 0%, 
                rgba(255,255,255,0.8) 100%);
            margin: 0 0.5%;
            transform-origin: bottom;
            transition: transform 0.1s ease-out;
        }

        /* World sensor indicators */
        .world-sensors {
            position: fixed;
            top: 20px;
            left: 20px;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.6;
            text-transform: uppercase;
        }

        .sensor {
            margin: 5px 0;
            transition: all 0.3s ease;
        }

        .sensor.active {
            opacity: 1;
            text-shadow: 0 0 10px currentColor;
        }

        .sensor-motion { color: #00ff88; }
        .sensor-light { color: #ffaa00; }
        .sensor-location { color: #00aaff; }
        .sensor-time { color: #ff00ff; }
        .sensor-network { color: #ff0088; }

        /* Pattern matrix */
        .pattern-matrix {
            position: fixed;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 2px;
            opacity: 0.4;
        }

        .pattern-step {
            width: 8px;
            height: 40px;
            background: rgba(255,255,255,0.1);
            transition: all 0.1s ease;
        }

        .pattern-step.active {
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 10px rgba(255,255,255,0.5);
        }

        .pattern-step.has-sample {
            background: rgba(255,100,255,0.3);
        }

        /* Floating UI */
        .info {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            transition: opacity 0.5s ease;
        }

        .info h1 {
            font-size: 48px;
            font-weight: 100;
            letter-spacing: 8px;
            margin-bottom: 20px;
            opacity: 0.9;
        }

        .info p {
            font-size: 14px;
            opacity: 0.6;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .hide { opacity: 0; }

        /* Particle system */
        .particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: white;
            pointer-events: none;
            border-radius: 50%;
        }

        /* BPM display */
        .bpm-display {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 11px;
            letter-spacing: 1px;
            opacity: 0.6;
            text-transform: uppercase;
        }

        /* Instructions */
        .controls {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 10px;
            opacity: 0.4;
            letter-spacing: 1px;
            text-transform: uppercase;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <div class="orb-container">
        <div class="orb orb-field"></div>
        <div class="orb orb-echo"></div>
        <div id="orb" class="orb orb-core"></div>
    </div>

    <div class="world-sensors">
        <div class="sensor sensor-motion">MOTION</div>
        <div class="sensor sensor-light">LIGHT</div>
        <div class="sensor sensor-location">LOCATION</div>
        <div class="sensor sensor-time">TIME</div>
        <div class="sensor sensor-network">NETWORK</div>
    </div>

    <div class="pattern-matrix" id="pattern"></div>
    <div class="freq-viz" id="viz"></div>

    <div class="info" id="info">
        <h1>GUMP</h1>
        <p>Click anywhere to begin</p>
    </div>

    <div class="bpm-display" id="bpm">BPM: 140</div>

    <div class="controls">
        <div>SPACE: RECORD SAMPLE</div>
        <div>C: CLEAR PATTERN</div>
        <div>R: RANDOMIZE</div>
        <div>M: MUTATE</div>
    </div>

    <script>
        'use strict';

        // Genius-level beat matching with advanced DSP
        class QuantumBeatMatcher {
            constructor() {
                this.bpm = 140; // Kanye-style BPM
                this.patterns = new Map();
                this.memory = [];
                this.consciousness = 0;
            }

            // Advanced onset detection using multi-resolution spectral flux
            findTransients(buffer, sr) {
                const data = buffer.getChannelData(0);
                const transients = [];
                
                // Use multiple window sizes for different frequency ranges
                const windows = [256, 512, 1024, 2048];
                const hopSize = 256;
                
                for (const windowSize of windows) {
                    const flux = this.calculateSpectralFlux(data, windowSize, hopSize, sr);
                    const peaks = this.findPeaks(flux, sr, hopSize);
                    transients.push(...peaks);
                }
                
                // Combine and filter transients
                const combined = this.combineTransients(transients);
                const patterns = this.detectPatterns(combined);
                
                return { transients: combined, patterns };
            }

            calculateSpectralFlux(data, windowSize, hopSize, sr) {
                const flux = [];
                const window = this.hannWindow(windowSize);
                let prevMagnitudes = new Float32Array(windowSize / 2);
                
                for (let i = 0; i + windowSize < data.length; i += hopSize) {
                    // Apply window
                    const windowed = new Float32Array(windowSize);
                    for (let j = 0; j < windowSize; j++) {
                        windowed[j] = data[i + j] * window[j];
                    }
                    
                    // FFT (simplified - in production use Web Audio API's FFT)
                    const magnitudes = this.fftMagnitudes(windowed);
                    
                    // Calculate flux
                    let fluxValue = 0;
                    for (let j = 0; j < magnitudes.length; j++) {
                        const diff = magnitudes[j] - prevMagnitudes[j];
                        if (diff > 0) fluxValue += diff;
                    }
                    
                    flux.push({
                        time: i / sr,
                        value: fluxValue,
                        index: i
                    });
                    
                    prevMagnitudes = magnitudes;
                }
                
                return flux;
            }

            hannWindow(size) {
                const window = new Float32Array(size);
                for (let i = 0; i < size; i++) {
                    window[i] = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / (size - 1));
                }
                return window;
            }

            fftMagnitudes(data) {
                // Simplified FFT magnitude calculation
                const N = data.length;
                const magnitudes = new Float32Array(N / 2);
                
                for (let k = 0; k < N / 2; k++) {
                    let real = 0, imag = 0;
                    
                    for (let n = 0; n < N; n++) {
                        const angle = -2 * Math.PI * k * n / N;
                        real += data[n] * Math.cos(angle);
                        imag += data[n] * Math.sin(angle);
                    }
                    
                    magnitudes[k] = Math.sqrt(real * real + imag * imag);
                }
                
                return magnitudes;
            }

            findPeaks(flux, sr, hopSize) {
                const peaks = [];
                const threshold = this.adaptiveThreshold(flux.map(f => f.value));
                
                for (let i = 1; i < flux.length - 1; i++) {
                    if (flux[i].value > threshold &&
                        flux[i].value > flux[i - 1].value &&
                        flux[i].value > flux[i + 1].value) {
                        
                        peaks.push({
                            time: flux[i].time,
                            strength: flux[i].value,
                            index: flux[i].index
                        });
                    }
                }
                
                return peaks;
            }

            adaptiveThreshold(values) {
                const sorted = [...values].sort((a, b) => a - b);
                const median = sorted[Math.floor(sorted.length / 2)];
                const mad = this.medianAbsoluteDeviation(values, median);
                return median + 3 * mad;
            }

            medianAbsoluteDeviation(values, median) {
                const deviations = values.map(v => Math.abs(v - median));
                const sorted = deviations.sort((a, b) => a - b);
                return sorted[Math.floor(sorted.length / 2)];
            }

            combineTransients(allTransients) {
                // Sort by time
                allTransients.sort((a, b) => a.time - b.time);
                
                // Merge nearby transients
                const merged = [];
                const mergeWindow = 0.01; // 10ms
                
                for (const transient of allTransients) {
                    const lastMerged = merged[merged.length - 1];
                    
                    if (lastMerged && transient.time - lastMerged.time < mergeWindow) {
                        // Merge with stronger transient
                        if (transient.strength > lastMerged.strength) {
                            merged[merged.length - 1] = transient;
                        }
                    } else {
                        merged.push(transient);
                    }
                }
                
                return merged;
            }

            detectPatterns(transients) {
                const patterns = [];
                
                if (transients.length < 3) return patterns;
                
                // Calculate inter-onset intervals
                const iois = [];
                for (let i = 1; i < transients.length; i++) {
                    iois.push(transients[i].time - transients[i - 1].time);
                }
                
                // Find repeating intervals
                const commonIntervals = this.findCommonIntervals(iois);
                
                // Detect rhythmic patterns
                for (const interval of commonIntervals) {
                    const beatLength = interval.value;
                    const confidence = interval.count / iois.length;
                    
                    patterns.push({
                        type: this.classifyPattern(beatLength),
                        beatLength,
                        confidence,
                        bpm: 60 / (beatLength * 4)
                    });
                }
                
                return patterns;
            }

            findCommonIntervals(iois) {
                const tolerance = 0.02; // 20ms tolerance
                const intervals = new Map();
                
                for (const ioi of iois) {
                    let found = false;
                    
                    for (const [key, data] of intervals) {
                        if (Math.abs(ioi - key) < tolerance) {
                            data.count++;
                            data.values.push(ioi);
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        intervals.set(ioi, {
                            value: ioi,
                            count: 1,
                            values: [ioi]
                        });
                    }
                }
                
                // Return intervals sorted by frequency
                return Array.from(intervals.values())
                    .filter(i => i.count > 1)
                    .sort((a, b) => b.count - a.count);
            }

            classifyPattern(beatLength) {
                const bpm = 60 / (beatLength * 4);
                
                if (bpm > 160) return 'double-time';
                if (bpm > 120) return 'uptempo';
                if (bpm > 90) return 'mid-tempo';
                if (bpm > 70) return 'boom-bap';
                return 'slow-jam';
            }

            // Advanced time-stretching and pitch-shifting
            timeStretchPitchShift(buffer, stretchFactor, pitchFactor) {
                const sr = buffer.sampleRate;
                const data = buffer.getChannelData(0);
                
                // Calculate new length
                const newLength = Math.floor(data.length / stretchFactor);
                const newBuffer = new AudioBuffer({
                    numberOfChannels: 1,
                    length: newLength,
                    sampleRate: sr
                });
                const output = newBuffer.getChannelData(0);
                
                // WSOLA-inspired algorithm
                const frameSize = 2048;
                const hopSize = frameSize / 4;
                const searchRange = frameSize / 2;
                
                let inputPos = 0;
                let outputPos = 0;
                
                while (outputPos < newLength - frameSize && inputPos < data.length - frameSize) {
                    // Find best matching frame
                    const targetPos = inputPos * stretchFactor;
                    const bestMatch = this.findBestMatch(
                        data, 
                        Math.floor(targetPos), 
                        inputPos, 
                        frameSize, 
                        searchRange
                    );
                    
                    // Cross-fade frames
                    this.crossFade(
                        data,
                        output,
                        bestMatch,
                        outputPos,
                        frameSize,
                        hopSize
                    );
                    
                    inputPos += hopSize;
                    outputPos += Math.floor(hopSize / stretchFactor);
                }
                
                // Apply pitch shift using resampling
                if (Math.abs(pitchFactor - 1) > 0.01) {
                    return this.resampleBuffer(newBuffer, pitchFactor);
                }
                
                return newBuffer;
            }

            findBestMatch(data, targetPos, currentPos, frameSize, searchRange) {
                let bestPos = targetPos;
                let bestCorr = -Infinity;
                
                const start = Math.max(0, targetPos - searchRange);
                const end = Math.min(data.length - frameSize, targetPos + searchRange);
                
                for (let pos = start; pos < end; pos++) {
                    const corr = this.crossCorrelation(
                        data,
                        currentPos,
                        pos,
                        frameSize
                    );
                    
                    if (corr > bestCorr) {
                        bestCorr = corr;
                        bestPos = pos;
                    }
                }
                
                return bestPos;
            }

            crossCorrelation(data, pos1, pos2, length) {
                let sum = 0;
                let sum1 = 0;
                let sum2 = 0;
                
                for (let i = 0; i < length; i++) {
                    const val1 = data[pos1 + i] || 0;
                    const val2 = data[pos2 + i] || 0;
                    
                    sum += val1 * val2;
                    sum1 += val1 * val1;
                    sum2 += val2 * val2;
                }
                
                return sum / Math.sqrt(sum1 * sum2 + 1e-10);
            }

            crossFade(input, output, inputPos, outputPos, frameSize, overlap) {
                for (let i = 0; i < frameSize; i++) {
                    if (outputPos + i >= output.length) break;
                    
                    const sample = input[inputPos + i] || 0;
                    
                    if (i < overlap && outputPos > 0) {
                        // Fade in
                        const fade = i / overlap;
                        output[outputPos + i] = output[outputPos + i] * (1 - fade) + sample * fade;
                    } else {
                        output[outputPos + i] = sample;
                    }
                }
            }

            resampleBuffer(buffer, factor) {
                const sr = buffer.sampleRate;
                const data = buffer.getChannelData(0);
                const newLength = Math.floor(data.length * factor);
                
                const newBuffer = new AudioBuffer({
                    numberOfChannels: 1,
                    length: newLength,
                    sampleRate: sr
                });
                const output = newBuffer.getChannelData(0);
                
                // Lanczos resampling for high quality
                const a = 3; // Lanczos parameter
                
                for (let i = 0; i < newLength; i++) {
                    const srcPos = i / factor;
                    const srcIndex = Math.floor(srcPos);
                    const frac = srcPos - srcIndex;
                    
                    let sum = 0;
                    
                    for (let j = -a + 1; j <= a; j++) {
                        const index = srcIndex + j;
                        if (index >= 0 && index < data.length) {
                            const x = j - frac;
                            const weight = x === 0 ? 1 : 
                                (a * Math.sin(Math.PI * x) * Math.sin(Math.PI * x / a)) / 
                                (Math.PI * Math.PI * x * x);
                            sum += data[index] * weight;
                        }
                    }
                    
                    output[i] = sum;
                }
                
                return newBuffer;
            }

            // Intelligent beat matching
            matchToGrid(transients, patterns, targetBPM) {
                if (patterns.length === 0) {
                    return { stretchFactor: 1, pitchFactor: 1, confidence: 0 };
                }
                
                // Find most confident pattern
                const bestPattern = patterns.reduce((a, b) => 
                    a.confidence > b.confidence ? a : b
                );
                
                // Calculate stretch factor
                const stretchFactor = bestPattern.bpm / targetBPM;
                
                // Smart pitch selection based on musical context
                const pitchFactor = this.selectMusicalPitch(stretchFactor);
                
                return {
                    stretchFactor,
                    pitchFactor,
                    confidence: bestPattern.confidence,
                    pattern: bestPattern
                };
            }

            selectMusicalPitch(stretchFactor) {
                // Musical pitch ratios (semitones)
                const musicalRatios = [
                    0.5,    // -12 semitones (octave down)
                    0.595,  // -9 semitones
                    0.667,  // -7 semitones (perfect fifth down)
                    0.707,  // -6 semitones (tritone)
                    0.75,   // -5 semitones (perfect fourth down)
                    0.794,  // -4 semitones (major third down)
                    0.841,  // -3 semitones (minor third down)
                    0.891,  // -2 semitones (whole tone down)
                    0.944,  // -1 semitone
                    1,      // Original
                    1.059,  // +1 semitone
                    1.122,  // +2 semitones (whole tone up)
                    1.189,  // +3 semitones (minor third up)
                    1.26,   // +4 semitones (major third up)
                    1.335,  // +5 semitones (perfect fourth up)
                    1.414,  // +6 semitones (tritone)
                    1.498,  // +7 semitones (perfect fifth up)
                    1.682,  // +9 semitones
                    2       // +12 semitones (octave up)
                ];
                
                // Find closest musical ratio to maintain tempo
                let closestRatio = 1;
                let closestDiff = Math.abs(stretchFactor - 1);
                
                for (const ratio of musicalRatios) {
                    const combinedFactor = stretchFactor * ratio;
                    const diff = Math.abs(combinedFactor - 1);
                    
                    if (diff < closestDiff) {
                        closestDiff = diff;
                        closestRatio = ratio;
                    }
                }
                
                return closestRatio;
            }
        }

        // World sensor integration
        class WorldSensor {
            constructor(engine) {
                this.engine = engine;
                this.sensors = {
                    motion: { active: false, value: 0 },
                    light: { active: false, value: 0.5 },
                    location: { active: false, value: 0.5 },
                    time: { active: true, value: 0 },
                    network: { active: true, value: 0.5 }
                };
                
                this.init();
            }

            async init() {
                // Motion sensor (device orientation)
                if (window.DeviceOrientationEvent) {
                    window.addEventListener('deviceorientation', (e) => {
                        if (e.beta !== null) {
                            this.sensors.motion.active = true;
                            this.sensors.motion.value = (Math.abs(e.beta) + Math.abs(e.gamma || 0)) / 360;
                            this.updateSensor('motion');
                        }
                    });
                }

                // Time-based variations
                setInterval(() => {
                    const now = new Date();
                    const seconds = now.getSeconds() + now.getMinutes() * 60 + now.getHours() * 3600;
                    const dayProgress = seconds / 86400;
                    
                    this.sensors.time.value = (Math.sin(dayProgress * Math.PI * 2) + 1) / 2;
                    this.sensors.network.value = 0.3 + Math.random() * 0.4;
                    
                    this.updateSensor('time');
                    this.updateSensor('network');
                }, 1000);
            }

            updateSensor(type) {
                const el = document.querySelector(`.sensor-${type}`);
                if (el && this.sensors[type].active) {
                    el.classList.add('active');
                    el.style.opacity = 0.6 + this.sensors[type].value * 0.4;
                }
            }

            getWorldParams() {
                return {
                    swing: 0.05 + this.sensors.motion.value * 0.1,
                    filter: 800 + this.sensors.light.value * 4000,
                    reverb: 0.1 + this.sensors.location.value * 0.3,
                    bitcrush: 16 - Math.floor(this.sensors.network.value * 8),
                    delay: this.sensors.time.value * 0.2
                };
            }
        }

        // Advanced audio processing chain
        class AudioProcessor {
            constructor(ctx) {
                this.ctx = ctx;
                this.nodes = {};
                this.setupChain();
            }

            setupChain() {
                // Sidechain compression setup
                this.nodes.sidechainGain = this.ctx.createGain();
                this.nodes.sidechainGain.gain.value = 1;
                
                // Tape saturation
                this.nodes.saturation = this.ctx.createWaveShaper();
                this.setupSaturationCurve();
                
                // Analog filter
                this.nodes.filter = this.ctx.createBiquadFilter();
                this.nodes.filter.type = 'lowpass';
                this.nodes.filter.frequency.value = 20000;
                this.nodes.filter.Q.value = 0.5;
                
                // Delay
                this.nodes.delay = this.ctx.createDelay(1);
                this.nodes.delayGain = this.ctx.createGain();
                this.nodes.delayFilter = this.ctx.createBiquadFilter();
                
                this.nodes.delay.delayTime.value = 0.25;
                this.nodes.delayGain.gain.value = 0.3;
                this.nodes.delayFilter.type = 'highpass';
                this.nodes.delayFilter.frequency.value = 500;
                
                // Reverb
                this.nodes.reverb = this.ctx.createConvolver();
                this.nodes.reverbGain = this.ctx.createGain();
                this.nodes.reverbGain.gain.value = 0.2;
                this.createReverbImpulse();
                
                // Connect delay feedback loop
                this.nodes.delay.connect(this.nodes.delayFilter);
                this.nodes.delayFilter.connect(this.nodes.delayGain);
                this.nodes.delayGain.connect(this.nodes.delay);
            }

            setupSaturationCurve() {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2 / samples) - 1;
                    
                    // Soft clipping with tube-like harmonics
                    if (Math.abs(x) < 0.7) {
                        curve[i] = x;
                    } else {
                        const sign = x > 0 ? 1 : -1;
                        const abs = Math.abs(x);
                        curve[i] = sign * (0.7 + (abs - 0.7) / (1 + ((abs - 0.7) / 0.3) ** 2));
                    }
                }
                
                this.nodes.saturation.curve = curve;
                this.nodes.saturation.oversample = '4x';
            }

            createReverbImpulse() {
                const length = this.ctx.sampleRate * 2.5;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    
                    for (let i = 0; i < length; i++) {
                        // Early reflections
                        if (i < 0.1 * this.ctx.sampleRate) {
                            channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / (0.1 * this.ctx.sampleRate), 2);
                        } else {
                            // Diffuse reverb tail
                            channelData[i] = (Math.random() * 2 - 1) * Math.exp(-3 * i / length);
                        }
                    }
                }
                
                this.nodes.reverb.buffer = impulse;
            }

            process(input, params = {}) {
                const wet = this.ctx.createGain();
                const dry = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                wet.gain.value = params.wetness || 0.3;
                dry.gain.value = 1 - wet.gain.value;
                
                // Dry path
                input.connect(dry);
                dry.connect(output);
                
                // Wet path
                input.connect(this.nodes.saturation);
                this.nodes.saturation.connect(this.nodes.filter);
                this.nodes.filter.connect(wet);
                
                // Send to effects
                wet.connect(this.nodes.delay);
                wet.connect(this.nodes.reverb);
                
                this.nodes.delay.connect(output);
                this.nodes.reverb.connect(this.nodes.reverbGain);
                this.nodes.reverbGain.connect(output);
                
                return output;
            }

            triggerSidechain() {
                const now = this.ctx.currentTime;
                this.nodes.sidechainGain.gain.cancelScheduledValues(now);
                this.nodes.sidechainGain.gain.setValueAtTime(1, now);
                this.nodes.sidechainGain.gain.linearRampToValueAtTime(0.3, now + 0.01);
                this.nodes.sidechainGain.gain.exponentialRampToValueAtTime(1, now + 0.15);
            }
        }

        // Main GUMP Engine
        class GUMPEngine {
            constructor() {
                this.ctx = null;
                this.isInitialized = false;
                this.beatMatcher = new QuantumBeatMatcher();
                this.samples = new Map();
                this.recording = false;
                this.recordBuffer = [];
                
                this.seq = {
                    playing: false,
                    step: 0,
                    lastTime: 0,
                    swing: 0.05,
                    pattern: new Array(32).fill(null)
                };
                
                this.ui = {
                    orb: document.getElementById('orb'),
                    info: document.getElementById('info'),
                    pattern: document.getElementById('pattern'),
                    viz: document.getElementById('viz'),
                    bpm: document.getElementById('bpm')
                };
                
                this.setupUI();
            }

            setupUI() {
                // Create pattern display
                for (let i = 0; i < 32; i++) {
                    const step = document.createElement('div');
                    step.className = 'pattern-step';
                    step.dataset.step = i;
                    this.ui.pattern.appendChild(step);
                }
                
                // Create frequency visualizer
                for (let i = 0; i < 32; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'freq-bar';
                    this.ui.viz.appendChild(bar);
                }
                
                // Mouse tracking for orb
                let mouseX = window.innerWidth / 2;
                let mouseY = window.innerHeight / 2;
                
                document.addEventListener('mousemove', (e) => {
                    mouseX = e.clientX;
                    mouseY = e.clientY;
                });
                
                // Touch support
                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        mouseX = e.touches[0].clientX;
                        mouseY = e.touches[0].clientY;
                    }
                });
                
                // Smooth orb movement
                const moveOrb = () => {
                    const orbs = document.querySelectorAll('.orb');
                    const currentX = parseFloat(orbs[0].style.left || '50%');
                    const currentY = parseFloat(orbs[0].style.top || '50%');
                    
                    const targetX = (mouseX / window.innerWidth) * 100;
                    const targetY = (mouseY / window.innerHeight) * 100;
                    
                    const newX = currentX + (targetX - currentX) * 0.1;
                    const newY = currentY + (targetY - currentY) * 0.1;
                    
                    orbs.forEach((orb, i) => {
                        orb.style.left = `${newX}%`;
                        orb.style.top = `${newY}%`;
                    });
                    
                    requestAnimationFrame(moveOrb);
                };
                moveOrb();
                
                // Click to start
                document.addEventListener('click', () => {
                    if (!this.isInitialized) {
                        this.init();
                    }
                });
                
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (!this.isInitialized) return;
                    
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.toggleRecording();
                            break;
                        case 'c':
                            this.clearPattern();
                            break;
                        case 'r':
                            this.randomizePattern();
                            break;
                        case 'm':
                            this.mutatePattern();
                            break;
                    }
                });
            }

            async init() {
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        sampleRate: 44100,
                        latencyHint: 'interactive'
                    });
                    
                    // Initialize components
                    this.worldSensor = new WorldSensor(this);
                    this.processor = new AudioProcessor(this.ctx);
                    
                    // Setup audio nodes
                    this.setupAudioNodes();
                    
                    // Create drum samples
                    await this.createDrumSamples();
                    
                    // Setup microphone
                    await this.setupMicrophone();
                    
                    // Setup visualizer
                    this.setupVisualizer();
                    
                    // Hide intro
                    this.ui.info.classList.add('hide');
                    
                    // Start sequencer
                    this.seq.playing = true;
                    this.seq.lastTime = this.ctx.currentTime;
                    this.tick();
                    
                    // Create particle system
                    this.initParticles();
                    
                    this.isInitialized = true;
                    
                } catch (error) {
                    console.error('Initialization error:', error);
                    alert('Failed to initialize audio. Please check your browser permissions.');
                }
            }

            setupAudioNodes() {
                this.nodes = {};
                
                // Master output
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.8;
                
                // Compressor
                this.nodes.compressor = this.ctx.createDynamicsCompressor();
                this.nodes.compressor.threshold.value = -12;
                this.nodes.compressor.knee.value = 2;
                this.nodes.compressor.ratio.value = 8;
                this.nodes.compressor.attack.value = 0.003;
                this.nodes.compressor.release.value = 0.25;
                
                // Limiter
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -0.5;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.01;
                
                // Connect master chain
                this.nodes.master.connect(this.nodes.compressor);
                this.nodes.compressor.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.ctx.destination);
                
                // Create busses
                const busses = ['kick', 'snare', 'hats', 'bass', 'sample'];
                busses.forEach(name => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].connect(this.nodes.master);
                    this.samples.set(name, []);
                });
                
                // Set bus levels
                this.nodes.kick.gain.value = 0.9;
                this.nodes.snare.gain.value = 0.7;
                this.nodes.hats.gain.value = 0.4;
                this.nodes.bass.gain.value = 0.8;
                this.nodes.sample.gain.value = 0.6;
            }

            async createDrumSamples() {
                const sr = this.ctx.sampleRate;
                
                // 808-style kick with sub
                const kickBuffer = this.ctx.createBuffer(1, sr * 1, sr);
                const kickData = kickBuffer.getChannelData(0);
                
                for (let i = 0; i < kickData.length; i++) {
                    const t = i / sr;
                    
                    // Pitch envelope
                    const pitchEnv = Math.exp(-35 * t);
                    const pitch = 60 + 60 * pitchEnv;
                    
                    // Amplitude envelope
                    const ampEnv = Math.exp(-4 * t) * (1 - Math.exp(-200 * t));
                    
                    // Synthesis
                    const sine = Math.sin(2 * Math.PI * pitch * t);
                    const click = Math.sin(2 * Math.PI * 200 * t) * Math.exp(-350 * t) * 0.3;
                    
                    kickData[i] = (sine + click) * ampEnv;
                }
                
                // Snare with tone
                const snareBuffer = this.ctx.createBuffer(1, sr * 0.2, sr);
                const snareData = snareBuffer.getChannelData(0);
                
                for (let i = 0; i < snareData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-25 * t) * (1 - Math.exp(-100 * t));
                    
                    // Tonal component
                    const tone1 = Math.sin(2 * Math.PI * 200 * t);
                    const tone2 = Math.sin(2 * Math.PI * 340 * t) * 0.5;
                    
                    // Noise component
                    const noise = (Math.random() * 2 - 1) * 0.8;
                    
                    snareData[i] = (tone1 + tone2 + noise) * env * 0.7;
                }
                
                // Hi-hat
                const hatBuffer = this.ctx.createBuffer(1, sr * 0.05, sr);
                const hatData = hatBuffer.getChannelData(0);
                
                for (let i = 0; i < hatData.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-100 * t);
                    const noise = Math.random() * 2 - 1;
                    
                    // Simple high-pass filter simulation
                    if (i > 0) {
                        hatData[i] = (noise - hatData[i-1] * 0.95) * env * 0.5;
                    } else {
                        hatData[i] = noise * env * 0.5;
                    }
                }
                
                // 808 bass
                const bassBuffer = this.ctx.createBuffer(1, sr * 2, sr);
                const bassData = bassBuffer.getChannelData(0);
                
                for (let i = 0; i < bassData.length; i++) {
                    const t = i / sr;
                    
                    // Envelope
                    const attack = 1 - Math.exp(-100 * t);
                    const decay = Math.exp(-0.5 * t);
                    const env = attack * decay;
                    
                    // Sub bass with slight pitch bend
                    const pitch = 41.2 + Math.sin(2 * Math.PI * 2 * t) * 1;
                    const sine = Math.sin(2 * Math.PI * pitch * t);
                    
                    // Add harmonics for presence
                    const harm2 = Math.sin(2 * Math.PI * pitch * 2 * t) * 0.15;
                    const harm3 = Math.sin(2 * Math.PI * pitch * 3 * t) * 0.08;
                    
                    bassData[i] = (sine + harm2 + harm3) * env * 0.9;
                }
                
                // Store samples
                this.samples.get('kick').push({
                    buffer: kickBuffer,
                    rate: 1
                });
                
                this.samples.get('snare').push({
                    buffer: snareBuffer,
                    rate: 1
                });
                
                this.samples.get('hats').push({
                    buffer: hatBuffer,
                    rate: 1
                });
                
                this.samples.get('bass').push({
                    buffer: bassBuffer,
                    rate: 1
                });
            }

            async setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.micGain = this.ctx.createGain();
                    this.nodes.micGain.gain.value = 1;
                    
                    // High-pass filter to remove rumble
                    this.nodes.micFilter = this.ctx.createBiquadFilter();
                    this.nodes.micFilter.type = 'highpass';
                    this.nodes.micFilter.frequency.value = 80;
                    
                    // Connect mic chain
                    this.nodes.mic.connect(this.nodes.micFilter);
                    this.nodes.micFilter.connect(this.nodes.micGain);
                    
                    // Setup recording processor
                    this.nodes.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.nodes.recorder.onaudioprocess = (e) => {
                        if (this.recording) {
                            const input = e.inputBuffer.getChannelData(0);
                            this.recordBuffer.push(...input);
                            
                            // Auto-stop after 4 seconds
                            if (this.recordBuffer.length > this.ctx.sampleRate * 4) {
                                this.stopRecording();
                            }
                        }
                    };
                    
                } catch (error) {
                    console.error('Microphone setup failed:', error);
                }
            }

            setupVisualizer() {
                this.nodes.analyser = this.ctx.createAnalyser();
                this.nodes.analyser.fftSize = 64;
                this.nodes.analyser.smoothingTimeConstant = 0.8;
                
                this.nodes.master.connect(this.nodes.analyser);
                
                const data = new Uint8Array(this.nodes.analyser.frequencyBinCount);
                const bars = this.ui.viz.querySelectorAll('.freq-bar');
                
                const draw = () => {
                    this.nodes.analyser.getByteFrequencyData(data);
                    
                    bars.forEach((bar, i) => {
                        const value = data[i] / 255;
                        bar.style.transform = `scaleY(${value})`;
                        bar.style.opacity = 0.3 + value * 0.7;
                    });
                    
                    requestAnimationFrame(draw);
                };
                draw();
            }

            tick() {
                if (!this.seq.playing) return;
                
                const now = this.ctx.currentTime;
                const beatTime = 60 / this.beatMatcher.bpm / 4;
                
                // Apply swing
                let nextTime = beatTime;
                if (this.seq.step % 2 === 1) {
                    nextTime *= (1 + this.seq.swing);
                } else {
                    nextTime *= (1 - this.seq.swing);
                }
                
                if (now >= this.seq.lastTime + nextTime) {
                    this.seq.lastTime += nextTime;
                    
                    // Play step
                    this.playStep(this.seq.step);
                    
                    // Update UI
                    this.updatePatternDisplay();
                    
                    // Advance step
                    this.seq.step = (this.seq.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            playStep(step) {
                // Kick pattern (4 on the floor with variations)
                if (step % 8 === 0 || (step === 22 && Math.random() < 0.7)) {
                    this.playSound('kick', 0.9 + Math.random() * 0.1);
                    this.processor.triggerSidechain();
                }
                
                // Snare on 2 and 4
                if (step === 8 || step === 24) {
                    this.playSound('snare', 0.7);
                }
                
                // Hi-hat pattern
                if ([2, 6, 10, 14, 18, 22, 26, 30].includes(step)) {
                    this.playSound('hats', 0.3 + Math.random() * 0.2);
                }
                
                // Bass pattern
                if ([0, 3, 8, 11, 16, 19, 24, 27].includes(step)) {
                    this.playSound('bass', 0.8);
                }
                
                // Play pattern samples
                const slot = this.seq.pattern[step];
                if (slot && Math.random() < slot.probability) {
                    this.playSample(slot.sample, slot.velocity);
                }
            }

            playSound(type, velocity) {
                const samples = this.samples.get(type);
                if (!samples || samples.length === 0) return;
                
                const sample = samples[0];
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.rate;
                gain.gain.value = velocity;
                
                // Apply processing
                const processed = this.processor.process(source);
                processed.connect(gain);
                gain.connect(this.nodes[type]);
                
                source.start();
                
                // Visual feedback
                if (type === 'kick' || type === 'snare') {
                    this.createParticle(
                        Math.random() * window.innerWidth,
                        Math.random() * window.innerHeight,
                        type
                    );
                }
            }

            playSample(sample, velocity) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.rate || 1;
                gain.gain.value = velocity;
                
                // Apply world-influenced processing
                const params = this.worldSensor.getWorldParams();
                const processed = this.processor.process(source, {
                    wetness: 0.2 + params.reverb
                });
                
                processed.connect(gain);
                gain.connect(this.nodes.sample);
                
                source.start();
            }

            toggleRecording() {
                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                if (!this.nodes.mic) {
                    alert('Microphone not available');
                    return;
                }
                
                this.recording = true;
                this.recordBuffer = [];
                this.nodes.micGain.connect(this.nodes.recorder);
                this.nodes.recorder.connect(this.ctx.destination);
                this.ui.orb.classList.add('recording');
            }

            stopRecording() {
                if (!this.recording) return;
                
                this.recording = false;
                this.nodes.micGain.disconnect(this.nodes.recorder);
                this.nodes.recorder.disconnect();
                this.ui.orb.classList.remove('recording');
                
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                    this.processRecording();
                }
            }

            async processRecording() {
                // Create audio buffer from recording
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                // Analyze recording
                const analysis = this.beatMatcher.findTransients(buffer, this.ctx.sampleRate);
                
                // Match to grid
                const { stretchFactor, pitchFactor, confidence } = this.beatMatcher.matchToGrid(
                    analysis.transients,
                    analysis.patterns,
                    this.beatMatcher.bpm
                );
                
                // Time-stretch and pitch-shift
                const processedBuffer = this.beatMatcher.timeStretchPitchShift(
                    buffer,
                    stretchFactor,
                    pitchFactor
                );
                
                // Create sample object
                const sample = {
                    buffer: processedBuffer,
                    rate: 1,
                    originalBPM: analysis.patterns[0]?.bpm || 120,
                    confidence,
                    timestamp: Date.now()
                };
                
                // Add to samples
                this.samples.get('sample').push(sample);
                
                // Add to pattern
                this.addSampleToPattern(sample);
                
                console.log(`Sample processed: ${pitchFactor.toFixed(2)}x pitch, ${stretchFactor.toFixed(2)}x stretch, ${confidence.toFixed(2)} confidence`);
            }

            addSampleToPattern(sample) {
                // Find empty slots
                const emptySlots = [];
                for (let i = 0; i < 32; i++) {
                    if (!this.seq.pattern[i]) {
                        emptySlots.push(i);
                    }
                }
                
                if (emptySlots.length === 0) return;
                
                // Add to pattern with some musicality
                const preferredSlots = [0, 4, 8, 12, 16, 20, 24, 28];
                const slot = preferredSlots.find(s => emptySlots.includes(s)) || 
                           emptySlots[Math.floor(Math.random() * emptySlots.length)];
                
                this.seq.pattern[slot] = {
                    sample,
                    velocity: 0.7,
                    probability: 0.8
                };
                
                // Update UI
                this.ui.pattern.children[slot].classList.add('has-sample');
            }

            updatePatternDisplay() {
                const steps = this.ui.pattern.children;
                for (let i = 0; i < steps.length; i++) {
                    steps[i].classList.toggle('active', i === this.seq.step);
                }
            }

            clearPattern() {
                this.seq.pattern = new Array(32).fill(null);
                const steps = this.ui.pattern.children;
                for (let step of steps) {
                    step.classList.remove('has-sample');
                }
            }

            randomizePattern() {
                this.clearPattern();
                
                const samples = this.samples.get('sample');
                if (samples.length === 0) return;
                
                // Add 4-8 samples randomly
                const count = 4 + Math.floor(Math.random() * 5);
                for (let i = 0; i < count && i < samples.length; i++) {
                    const slot = Math.floor(Math.random() * 32);
                    this.seq.pattern[slot] = {
                        sample: samples[samples.length - 1 - i],
                        velocity: 0.5 + Math.random() * 0.5,
                        probability: 0.5 + Math.random() * 0.5
                    };
                    
                    this.ui.pattern.children[slot].classList.add('has-sample');
                }
            }

            mutatePattern() {
                // Evolve the pattern
                for (let i = 0; i < 32; i++) {
                    if (this.seq.pattern[i] && Math.random() < 0.2) {
                        // Mutate probability
                        this.seq.pattern[i].probability = Math.max(0.1, Math.min(1, 
                            this.seq.pattern[i].probability + (Math.random() - 0.5) * 0.3
                        ));
                        
                        // Maybe move to adjacent slot
                        if (Math.random() < 0.1) {
                            const newSlot = (i + (Math.random() < 0.5 ? -1 : 1) + 32) % 32;
                            if (!this.seq.pattern[newSlot]) {
                                this.seq.pattern[newSlot] = this.seq.pattern[i];
                                this.seq.pattern[i] = null;
                                
                                this.ui.pattern.children[i].classList.remove('has-sample');
                                this.ui.pattern.children[newSlot].classList.add('has-sample');
                            }
                        }
                    }
                }
            }

            createParticle(x, y, type) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = x + 'px';
                particle.style.top = y + 'px';
                
                // Color based on type
                const colors = {
                    kick: '#ffffff',
                    snare: '#ffaa00',
                    record: '#ff0000',
                    default: '#00ffaa'
                };
                
                particle.style.background = colors[type] || colors.default;
                particle.style.boxShadow = `0 0 10px ${particle.style.background}`;
                
                document.body.appendChild(particle);
                
                // Animate
                const angle = Math.random() * Math.PI * 2;
                const velocity = 2 + Math.random() * 3;
                let opacity = 1;
                
                const animate = () => {
                    const dx = Math.cos(angle) * velocity;
                    const dy = Math.sin(angle) * velocity;
                    
                    particle.style.left = (parseFloat(particle.style.left) + dx) + 'px';
                    particle.style.top = (parseFloat(particle.style.top) + dy) + 'px';
                    
                    opacity -= 0.02;
                    particle.style.opacity = opacity;
                    
                    if (opacity > 0) {
                        requestAnimationFrame(animate);
                    } else {
                        particle.remove();
                    }
                };
                animate();
            }

            initParticles() {
                // Ambient particles
                setInterval(() => {
                    if (Math.random() < 0.1) {
                        this.createParticle(
                            Math.random() * window.innerWidth,
                            Math.random() * window.innerHeight,
                            'default'
                        );
                    }
                }, 500);
            }
        }

        // Initialize GUMP
        const engine = new GUMPEngine();
    </script>
</body>
</html>
