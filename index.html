<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - AI Music From Your World</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 40% 60%, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 1s ease;
    }

    .app { width: 100%; max-width: 400px; padding: 20px; text-align: center; }

    .logo {
      font-size: clamp(3rem, 12vw, 5rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      animation: pulse 3s ease-in-out infinite;
    }

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }

    .tagline { font-size: 1.1rem; opacity: 0.8; margin-bottom: 1.5rem; font-weight: 300; }

    .btn {
      padding: 15px 30px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 25px;
      font-size: 1rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 8px 20px rgba(0,255,170,0.3);
      margin: 8px;
    }

    .btn:hover { transform: translateY(-2px); box-shadow: 0 12px 30px rgba(0,255,170,0.5); }

    .weather-status {
      font-size: 0.9rem;
      margin-bottom: 1rem;
      padding: 8px 15px;
      background: rgba(0,255,170,0.1);
      border-radius: 15px;
      border: 1px solid rgba(0,255,170,0.2);
    }

    .footstep-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 60px;
      height: 60px;
      background: radial-gradient(circle, #00ffaa, transparent);
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: transform 0.2s ease, opacity 0.4s ease;
      opacity: 0;
      z-index: 5;
    }

    .footstep-indicator.active {
      transform: translate(-50%, -50%) scale(1);
      opacity: 0.7;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin: 15px 0;
    }

    .stat {
      background: rgba(0,255,170,0.1);
      padding: 10px;
      border-radius: 10px;
      border: 1px solid rgba(0,255,170,0.2);
    }

    .stat-value { font-size: 1.2rem; font-weight: 700; color: #00ffaa; }
    .stat-label { font-size: 0.65rem; opacity: 0.7; margin-top: 3px; }

    .status {
      font-size: 0.85rem;
      color: #4ecdc4;
      opacity: 0.8;
      animation: breathe 2s ease-in-out infinite;
    }

    @keyframes breathe { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }

    .error {
      color: #ff4444;
      font-size: 0.85rem;
      margin-top: 1rem;
      padding: 8px;
      background: rgba(255,0,0,0.1);
      border-radius: 8px;
      border: 1px solid rgba(255,0,0,0.3);
    }

    .hidden { display: none !important; }

    body.void {
      background: radial-gradient(circle at 60% 40%, #0a0014 0%, #1a0f2e 40%, #2e1a3e 100%);
      color: #ff88cc;
    }

    body.void .logo {
      background: linear-gradient(45deg, #ff88cc, #88aaff, #ccaa88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    body.rain {
      background: radial-gradient(circle at 40% 60%, #0a0a1a 0%, #1a2a3e 40%, #0f3460 100%);
    }

    body.storm {
      background: radial-gradient(circle at 40% 60%, #2a0a0a 0%, #3a1a1e 40%, #4e2a3e 100%);
      animation: lightning 6s infinite;
    }

    body.snow {
      background: radial-gradient(circle at 40% 60%, #e6f3ff 0%, #b3d9ff 40%, #80bfff 100%);
      color: #333;
    }

    body.snow .logo {
      background: linear-gradient(45deg, #0066cc, #003d7a, #001a33);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    @keyframes lightning {
      0%, 90%, 100% { filter: brightness(1); }
      91%, 92%, 94%, 96% { filter: brightness(2) contrast(1.5); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="logo">GUMP</div>
    <div class="tagline">Music From Your World</div>
    <div class="weather-status" id="weather">üå§Ô∏è Loading weather...</div>
    <button class="btn" id="start">üéµ Start Music</button>
    <button class="btn hidden" id="stop">‚èπ Stop</button>
    <div class="error hidden" id="error"></div>
    <div class="footstep-indicator" id="footstep"></div>
    <div class="stats hidden" id="stats">
      <div class="stat">
        <div class="stat-value" id="steps">0</div>
        <div class="stat-label">Steps</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bpm">120</div>
        <div class="stat-label">BPM</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="weather-mode">CLEAR</div>
        <div class="stat-label">Weather</div>
      </div>
    </div>
    <div class="status hidden" id="status">Sensing your steps...</div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.steps = 0;
        this.lastStepTime = 0;
        this.bpm = 120;
        this.last = { x: 0, y: 0, z: 0 };
        this.stepHistory = [];
        this.stepTimestamps = [];
        this.void = false;
        this.weather = 'clear';
        this.weatherSources = [];
        this.voidOscs = [];
        this.step = 0;

        // Musical state
        this.patterns = {
          kick: [
            { hit: 1, vel: 0.8 }, { hit: 0, vel: 0 }, { hit: 0, vel: 0 }, { hit: 0, vel: 0 },
            { hit: 0, vel: 0 }, { hit: 0, vel: 0 }, { hit: 1, vel: 0.6 }, { hit: 0, vel: 0 }
          ],
          snare: [
            { hit: 0, vel: 0 }, { hit: 0, vel: 0 }, { hit: 0, vel: 0 }, { hit: 0, vel: 0 },
            { hit: 1, vel: 0.7 }, { hit: 0, vel: 0 }, { hit: 0, vel: 0 }, { hit: 0, vel: 0 }
          ],
          hat: [
            { hit: 0, vel: 0 }, { hit: 1, vel: 0.3 }, { hit: 0, vel: 0 }, { hit: 1, vel: 0.2 },
            { hit: 0, vel: 0 }, { hit: 1, vel: 0.4 }, { hit: 0, vel: 0 }, { hit: 1, vel: 0.3 }
          ]
        };

        this.init();
      }

      init() {
        document.getElementById('start').onclick = () => this.start();
        document.getElementById('stop').onclick = () => this.stop();
        this.getWeather();
        this.setupErrorHandling();
      }

      setupErrorHandling() {
        window.addEventListener('error', (e) => this.showError('Error: ' + e.message));
      }

      showError(message) {
        console.error('GUMP Error:', message);
        const errorEl = document.getElementById('error');
        errorEl.textContent = message;
        errorEl.classList.remove('hidden');
        setTimeout(() => errorEl.classList.add('hidden'), 5000);
      }

      async getWeather() {
        try {
          document.getElementById('weather').textContent = 'üåç Getting location...';
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
          });

          document.getElementById('weather').textContent = 'üå§Ô∏è Fetching weather...';
          const API_KEY = 'YOUR_API_KEY_HERE'; // Replace with your OpenWeatherMap API key
          const url = `https://api.openweathermap.org/data/2.5/weather?lat=${pos.coords.latitude}&lon=${pos.coords.longitude}&appid=${API_KEY}&units=metric`;

          const response = await fetch(url);
          if (!response.ok) throw new Error('Weather API unavailable');

          const data = await response.json();
          this.setWeatherFromData(data);
        } catch (error) {
          console.error('Weather fetch failed:', error.message);
          this.setDefaultWeather();
        }
      }

      setWeatherFromData(data) {
        const condition = data.weather[0].main.toLowerCase();
        const temp = Math.round(data.main.temp);
        const location = data.name || 'Unknown';

        if (condition.includes('storm') || condition.includes('thunderstorm')) {
          this.weather = 'storm';
        } else if (condition.includes('rain') || condition.includes('drizzle')) {
          this.weather = 'rain';
        } else if (condition.includes('snow')) {
          this.weather = 'snow';
        } else {
          this.weather = 'clear';
        }

        this.applyWeatherTheme();
        document.getElementById('weather').textContent = `üå§Ô∏è ${location} ‚Ä¢ ${temp}¬∞C ‚Ä¢ ${this.weather.toUpperCase()}`;
        if (this.active) this.startWeatherAudio();
      }

      setDefaultWeather() {
        this.weather = 'clear';
        this.applyWeatherTheme();
        document.getElementById('weather').textContent = 'üå§Ô∏è Clear (simulated)';
        if (this.active) this.startWeatherAudio();
      }

      applyWeatherTheme() {
        document.body.className = this.void ? 'void' : this.weather;
        document.getElementById('weather-mode').textContent = this.weather.toUpperCase();
      }

      async start() {
        if (this.active) return;

        try {
          console.log('Starting GUMP...');
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            console.log('Requesting motion permission...');
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') throw new Error('Motion permission denied');
          } else if (!window.DeviceMotionEvent) {
            throw new Error('Device motion not supported');
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          console.log('AudioContext created, state:', this.ctx.state);

          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.setValueAtTime(0.8, this.ctx.currentTime);
          this.masterGain.connect(this.ctx.destination);
          this.weatherGain = this.ctx.createGain();
          this.weatherGain.gain.setValueAtTime(0.4, this.ctx.currentTime);
          this.weatherGain.connect(this.masterGain);

          if (this.ctx.state === 'suspended') {
            console.log('Attempting to resume AudioContext...');
            await this.ctx.resume();
            if (this.ctx.state === 'suspended') throw new Error('AudioContext failed to resume');
          }
          console.log('AudioContext resumed, state:', this.ctx.state);

          // Play loud test sound
          this.playTestSound();

          this.active = true;
          this.show(['stats', 'status', 'stop']);
          this.hide(['start']);

          console.log('Registering motion event listener...');
          window.addEventListener('devicemotion', e => this.handleMotion(e), { passive: true });
          this.startEngine();
          this.startWeatherAudio();
        } catch (e) {
          this.showError('Failed to start: ' + e.message);
          console.error('Start failed:', e.message);
          this.active = false;
          this.show(['start']);
          this.hide(['stats', 'status', 'stop']);
        }
      }

      playTestSound() {
        console.log('Playing test sound (440Hz, 1s)...');
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(440, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime); // Louder for testing
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        osc.connect(gain).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 1);
      }

      stop() {
        this.active = false;
        this.weatherSources.forEach(source => {
          console.log('Stopping weather source');
          source.stop();
        });
        this.voidOscs.forEach(osc => {
          console.log('Stopping void oscillator');
          osc.stop();
        });
        this.weatherSources = [];
        this.voidOscs = [];
        this.steps = 0;
        this.step = 0;
        this.stepHistory = [];
        this.stepTimestamps = [];
        this.show(['start']);
        this.hide(['stats', 'status', 'stop']);
        document.body.className = '';
        if (this.ctx) {
          console.log('Closing AudioContext...');
          this.ctx.close().catch(e => console.error('Error closing AudioContext:', e.message));
          this.ctx = null;
        }
      }

      handleMotion(event) {
        if (!this.active) return;

        const acc = event.accelerationIncludingGravity;
        if (!acc || acc.z === null) {
          this.showError('No motion data available');
          console.warn('No motion data:', acc);
          return;
        }

        const dz = Math.abs(acc.z - this.last.z);
        this.stepHistory.push(dz);
        if (this.stepHistory.length > 20) this.stepHistory.shift();

        const avg = this.stepHistory.length > 0 ? this.stepHistory.reduce((a, b) => a + b, 0) / this.stepHistory.length : 0;
        const threshold = Math.max(0.8, avg * 1.1); // Very sensitive
        const now = Date.now();

        console.log(`Motion: dz=${dz.toFixed(2)}, avg=${avg.toFixed(2)}, threshold=${threshold.toFixed(2)}, timeSinceLast=${now - this.lastStepTime}`);

        if (dz > threshold && now - this.lastStepTime > 200) {
          this.steps++;
          this.lastStepTime = now;
          this.stepTimestamps.push(now);
          if (this.stepTimestamps.length > 10) this.stepTimestamps.shift();
          console.log(`Step detected! Total steps: ${this.steps}`);
          this.showFootstepIndicator();
          this.playStepSound();
          this.updateBPM();
        }

        this.last = { x: acc.x, y: acc.y, z: acc.z };
        this.updateState();
        this.updateVisuals();
      }

      showFootstepIndicator() {
        const indicator = document.getElementById('footstep');
        indicator.classList.add('active');
        setTimeout(() => indicator.classList.remove('active'), 200);
      }

      updateBPM() {
        if (this.stepTimestamps.length < 2) return;

        const intervals = [];
        for (let i = 1; i < this.stepTimestamps.length; i++) {
          intervals.push(this.stepTimestamps[i] - this.stepTimestamps[i - 1]);
        }
        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        this.bpm = Math.min(160, Math.max(80, 60000 / avgInterval));
        console.log(`BPM updated: ${Math.round(this.bpm)} (avg interval: ${avgInterval.toFixed(2)}ms)`);
      }

      updateState() {
        const stillTime = Date.now() - this.lastStepTime;
        const wasVoid = this.void;

        this.void = stillTime > 2000;
        if (this.void !== wasVoid) {
          document.body.classList.toggle('void', this.void);
          if (this.void) {
            console.log('Entering void mode');
            this.startVoidAmbient();
            document.getElementById('status').textContent = '‚ú® Floating in the void...';
          } else {
            console.log('Exiting void mode');
            this.stopVoidAmbient();
            this.applyWeatherTheme();
            document.getElementById('status').textContent = 'üéµ Flowing with your steps...';
          }
        }
      }

      updateVisuals() {
        document.getElementById('steps').textContent = this.steps;
        document.getElementById('bpm').textContent = Math.round(this.bpm);
      }

      startVoidAmbient() {
        this.stopVoidAmbient();
        console.log('Starting void ambient sounds');
        const frequencies = [220, 277.18];
        frequencies.forEach((freq, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 1 + i * 0.5);
          osc.connect(gain).connect(this.masterGain);
          osc.start(this.ctx.currentTime);
          this.voidOscs.push(osc);
        });
      }

      stopVoidAmbient() {
        console.log('Stopping void ambient sounds');
        this.voidOscs.forEach(osc => osc.stop());
        this.voidOscs = [];
      }

      startEngine() {
        console.log('Starting music engine');
        const tick = () => {
          if (!this.active) return;

          if (this.step % 8 === 0) {
            this.playBeat();
          }

          this.step = (this.step + 1) % 8;
          setTimeout(tick, 60000 / this.bpm / 4);
        };
        tick();
      }

      playBeat() {
        const pattern = this.patterns;
        if (pattern.kick[this.step].hit) {
          console.log('Playing kick');
          this.kick(pattern.kick[this.step].vel);
        }
        if (pattern.snare[this.step].hit) {
          console.log('Playing snare');
          this.snare(pattern.snare[this.step].vel);
        }
        if (pattern.hat[this.step].hit) {
          console.log('Playing hat');
          this.hat(pattern.hat[this.step].vel);
        }
      }

      playStepSound() {
        console.log('Playing step sound');
        this.kick(0.9);
        if (Math.random() < 0.5) this.snare(0.6);
        if (Math.random() < 0.7) this.hat(0.3);
      }

      kick(velocity) {
        console.log('Kick triggered, velocity:', velocity);
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        osc.type = 'sine';
        osc.frequency.setValueAtTime(55, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.1);

        gain.gain.setValueAtTime(velocity, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        panner.pan.setValueAtTime(Math.random() * 0.4 - 0.2, this.ctx.currentTime);

        osc.connect(gain).connect(panner).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 0.4);
      }

      snare(velocity) {
        console.log('Snare triggered, velocity:', velocity);
        const noise = this.ctx.createBufferSource();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        gain.gain.setValueAtTime(velocity, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        panner.pan.setValueAtTime(Math.random() * 0.4 - 0.2, this.ctx.currentTime);

        noise.connect(gain).connect(panner).connect(this.masterGain);
        noise.start(this.ctx.currentTime);
      }

      hat(velocity) {
        console.log('Hat triggered, velocity:', velocity);
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        osc.type = 'square';
        osc.frequency.setValueAtTime(10000, this.ctx.currentTime);

        gain.gain.setValueAtTime(velocity * 0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.03);
        panner.pan.setValueAtTime(Math.random() * 0.4 - 0.2, this.ctx.currentTime);

        osc.connect(gain).connect(panner).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 0.03);
      }

      startWeatherAudio() {
        console.log('Starting weather audio:', this.weather);
        this.weatherSources.forEach(source => {
          console.log('Stopping weather source');
          source.stop();
        });
        this.weatherSources = [];

        switch (this.weather) {
          case 'rain':
            this.playRainSound();
            break;
          case 'storm':
            this.playStormSound();
            break;
          case 'snow':
            this.playSnowSound();
            break;
          default:
            break;
        }
      }

      playRainSound() {
        console.log('Playing rain sound');
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.08;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        source.connect(gain).connect(this.weatherGain);
        source.start(this.ctx.currentTime);
        this.weatherSources.push(source);
      }

      playStormSound() {
        console.log('Playing storm sound');
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.15;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        source.connect(gain).connect(this.weatherGain);
        source.start(this.ctx.currentTime);
        this.weatherSources.push(source);

        setInterval(() => {
          if (Math.random() < 0.1 && this.active) this.playThunder();
        }, 8000);
      }

      playThunder() {
        console.log('Playing thunder sound');
        const time = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 4;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.2));
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.7, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 4);
        source.connect(gain).connect(this.weatherGain);
        source.start(time);
        this.weatherSources.push(source);
      }

      playSnowSound() {
        console.log('Playing snow sound');
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.05;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        source.connect(gain).connect(this.weatherGain);
        source.start(this.ctx.currentTime);
        this.weatherSources.push(source);
      }

      show(ids) { ids.forEach(id => document.getElementById(id).classList.remove('hidden')); }
      hide(ids) { ids.forEach(id => document.getElementById(id).classList.add('hidden')); }
    }

    new GUMP();
  </script>
</body>
</html>
