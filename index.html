<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Spatial Motion AI Music</title>
  <style>
    /* ... keep your CSS, it's great ... */
  </style>
</head>
<body>
  <!-- ... your HTML exactly as is ... -->
  <div class="particles" id="particles"></div>
  <div class="app">
    <div class="logo" id="logo">GUMP</div>
    <div class="tagline" id="tagline">Your Life, Soundtracked by AI</div>
    <button class="start-btn" id="start">ðŸŽµ Start Spatial Audio</button>
    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>
    <div class="stats hidden" id="stats">
      <div class="stat" id="motionStat">
        <div class="stat-value" id="motion">0</div>
        <div class="stat-label">Motion</div>
      </div>
      <div class="stat" id="bpmStat">
        <div class="stat-value" id="bpm">95</div>
        <div class="stat-label">BPM</div>
      </div>
      <div class="stat" id="grooveStat">
        <div class="stat-value" id="groove">CHILL</div>
        <div class="stat-label">State</div>
      </div>
    </div>
    <div class="status hidden" id="status">ðŸŽµ Flowing with your vibe...</div>
    <div class="error hidden" id="error"></div>
  </div>

  <script>
    // Helper for random slow LFO
    function slowLFO(min, max, period = 6000) {
      return () => {
        const now = Date.now() % period;
        const phase = now / period * 2 * Math.PI;
        return min + (max - min) * (0.5 + 0.5 * Math.sin(phase));
      }
    }

    class SpatialAI {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 95;
        this.pos = { x: 50, y: 50 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.state = 'CHILL';
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.heavenOscillators = [];
        this.arps = [];
        this.reverb = null;

        this.scale = [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25];
        this.chords = [[0,2,4,6], [5,0,2,4], [3,5,0,2], [4,6,1,3]];
        this.currentChord = 0;
        this.patterns = {
          kick: [1,0,0,0,0,0,1,0,0,0,1,0,0,0,0,0],
          snare: [0,0,0,0,1,0,0,0,0,0,0,0,1,0,0,0],
          hat:   [1,1,0,1,1,0,1,1,0,1,1,0,1,1,0,1]
        };

        // Layer gains for zone mixing
        this.padGainL = null;
        this.padGainR = null;
        this.subGain = null;
        this.shimmerGain = null;
        this.noiseGain = null;

        this.lfo = slowLFO(300, 800, 12000);

        this.init();
      }

      init() {
        document.getElementById('start').onclick = () => this.start();
      }

      createReverb() {
        if (!this.ctx) return;
        this.reverb = this.ctx.createConvolver();
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * 2.5, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2.5);
          }
        }
        this.reverb.buffer = buffer;
        this.reverb.connect(this.ctx.destination);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') throw new Error('Permission denied');
          }
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();

          // Zone-based pad layers
          this.padGainL = this.ctx.createGain();
          this.padGainR = this.ctx.createGain();
          this.subGain = this.ctx.createGain();
          this.shimmerGain = this.ctx.createGain();
          this.noiseGain = this.ctx.createGain();

          this.padGainL.gain.value = 0.5;
          this.padGainR.gain.value = 0.5;
          this.subGain.gain.value = 0.3;
          this.shimmerGain.gain.value = 0.0;
          this.noiseGain.gain.value = 0.1;

          // All connect to reverb for immersion
          this.padGainL.connect(this.reverb);
          this.padGainR.connect(this.reverb);
          this.subGain.connect(this.reverb);
          this.shimmerGain.connect(this.reverb);
          this.noiseGain.connect(this.reverb);

          document.getElementById('start').classList.add('hidden');
          ['viz', 'stats', 'status'].forEach(id => 
            document.getElementById(id).classList.remove('hidden')
          );

          this.active = true;
          this.startSensors();
          this.startGroove();
          this.animate();
          this.monitorTranscendence();
          this.runZoneLayers();
        } catch (e) {
          this.showError('Motion sensors unavailable. Please use a mobile device.');
        }
      }

      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);
          this.motion = Math.min(100, Math.sqrt(dx*dx + dy*dy + dz*dz) * 15);
          this.last = { x: acc.x, y: acc.y, z: acc.z };
          if (this.motion > 8) this.lastMotionTime = Date.now();
          this.pos.x = Math.max(5, Math.min(95, 50 + acc.x * 3));
          this.pos.y = Math.max(5, Math.min(95, 50 + acc.y * 3));
          this.updateState();
          // Zone mix
          if (this.padGainL && this.padGainR && this.subGain && this.shimmerGain) {
            let x = this.pos.x / 100;
            let y = this.pos.y / 100;
            // X = more shimmer right, more sub left
            this.padGainL.gain.value = 0.5 + 0.3 * (1 - x);
            this.padGainR.gain.value = 0.5 + 0.3 * x;
            this.shimmerGain.gain.value = 0.1 + 0.7 * x;
            this.subGain.gain.value = 0.2 + 0.6 * (1 - x);
            this.noiseGain.gain.value = 0.1 + 0.2 * y;
          }
        });
      }

      monitorTranscendence() {
        const check = () => {
          if (!this.active) return;
          const stillTime = Date.now() - this.lastMotionTime;
          const shouldTranscend = stillTime > 1700;
          if (shouldTranscend && !this.transcendent) this.enterTranscendence();
          else if (!shouldTranscend && this.transcendent) this.exitTranscendence();
          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 1700) / 4000);
            this.deepenVoid();
          }
          setTimeout(check, 100);
        };
        check();
      }

      enterTranscendence() {
        this.transcendent = true;
        this.state = 'HEAVEN';
        ['logo','tagline','viz','orb','motionStat','bpmStat','grooveStat','motion','bpm','groove','status']
          .forEach(id => { const el = document.getElementById(id); if (el) el.classList.add('transcendent'); });
        document.body.classList.add('transcendent');
        this.createParticles();
        this.startHeavenLayers();
      }
      exitTranscendence() {
        this.transcendent = false;
        this.state = 'CHILL';
        ['logo','tagline','viz','orb','motionStat','bpmStat','grooveStat','motion','bpm','groove','status']
          .forEach(id => { const el = document.getElementById(id); if (el) el.classList.remove('transcendent'); });
        document.body.classList.remove('transcendent');
        this.clearParticles();
        this.stopHeavenLayers();
      }
      createParticles() {
        const container = document.getElementById('particles');
        container.classList.add('active');
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 6 + 's';
          container.appendChild(particle);
        }
      }
      clearParticles() {
        const container = document.getElementById('particles');
        container.classList.remove('active');
        setTimeout(() => container.innerHTML = '', 2000);
      }
      deepenVoid() {
        // Deepen the void, nothing to change here, you nailed the atmosphere.
        if (this.transcendentIntensity > 0.4 && Math.random() < 0.007) this.voidWhisper();
        if (this.transcendentIntensity > 0.7 && Math.random() < 0.005) this.voidBell();
      }
      voidWhisper() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        osc.type = 'triangle';
        osc.frequency.value = 200 + Math.random() * 200;
        filter.type = 'bandpass';
        filter.frequency.value = 500;
        filter.Q.value = 8;
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.02, this.ctx.currentTime + 0.5);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 6);
      }
      voidBell() {
        const freq = [174, 207, 261, 311][Math.floor(Math.random() * 4)];
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = freq;
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.06, this.ctx.currentTime + 0.2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 6);
      }
      startHeavenLayers() {
        // Lush evolving cloud
        const chord = this.chords[this.currentChord];
        chord.forEach(note => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = this.scale[note] * 0.5;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.10, this.ctx.currentTime + 3);
          osc.connect(gain).connect(this.reverb);
          osc.start();
          this.heavenOscillators.push({ osc, gain });
        });
      }
      stopHeavenLayers() {
        this.heavenOscillators.forEach(({ osc, gain }) => {
          try {
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
            osc.stop(this.ctx.currentTime + 2);
          } catch (e) {}
        });
        this.heavenOscillators = [];
      }

      updateState() {
        if (this.transcendent) {
          this.state = 'HEAVEN';
          this.bpm = 70 + (this.transcendentIntensity * 30);
          return;
        }
        if (this.motion < 15) {
          this.state = 'CHILL';
          this.bpm = 85 + this.motion * 0.3;
        } else if (this.motion < 45) {
          this.state = 'FLOW';
          this.bpm = 95 + this.motion * 0.2;
        } else {
          this.state = 'ENERGY';
          this.bpm = 110 + this.motion * 0.15;
        }
      }

      // ---- MUSIC ENGINE ----
      startGroove() {
        const tick = () => {
          if (!this.active) return;
          if (this.transcendent) {
            // Void/Heaven percussion
            if (this.step % 8 === 0) this.etherealKick();
            if (this.step % 16 === 8 && this.transcendentIntensity > 0.2) this.heavenSnare();
            if (this.step % 32 === 16 && this.transcendentIntensity > 0.5) this.voidPulse();
            if (this.step % 8 === 4 && this.transcendentIntensity > 0.3) this.cloudPad();
          } else {
            // Real, analog drum machine (not just beeps)
            if (this.patterns.kick[this.step]) this.kick();
            if (this.patterns.snare[this.step]) this.snare();
            if (this.patterns.hat[this.step] && this.motion > 10) this.hat();
            if (this.step % 8 === 0) this.bass();
            if (this.motion > 25 && this.step % 4 === 0) this.motionArp();
          }
          this.step = (this.step + 1) % 16;
          if (this.step === 0) this.currentChord = (this.currentChord + 1) % this.chords.length;
          setTimeout(tick, 60000 / this.bpm / 4);
        };
        tick();
      }

      // --- Upgraded analog drum voices ---
      kick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(72, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(36, this.ctx.currentTime + 0.07);
        gain.gain.setValueAtTime(0.7, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.23);
        osc.connect(gain).connect(this.padGainL); // Route kick to pad zone for natural blend
        osc.start();
        osc.stop(this.ctx.currentTime + 0.23);
      }
      snare() {
        // Analog snare: noise + very short sine
        const bufferSize = this.ctx.sampleRate * 0.15;
        const noiseBuffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const output = noiseBuffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) output[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = noiseBuffer;

        const noiseGain = this.ctx.createGain();
        noiseGain.gain.setValueAtTime(0.32, this.ctx.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.09);

        noise.connect(noiseGain).connect(this.padGainR);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.11);

        // Snap layer
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(220, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.09, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.08);
        osc.connect(gain).connect(this.padGainR);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
      }
      hat() {
        // Simple analog hihat: highpass filtered noise burst
        const bufferSize = this.ctx.sampleRate * 0.06;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const hp = this.ctx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 4000;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.13, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.04);
        noise.connect(hp).connect(gain).connect(this.noiseGain);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.06);
      }
      bass() {
        // Sub bass, blends with subGain (zone-mixable)
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'triangle';
        osc.frequency.value = this.scale[this.chords[this.currentChord][0]] * 0.5;
        gain.gain.setValueAtTime(0.18, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.35);
        osc.connect(gain).connect(this.subGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.37);
      }
      cloudPad() {
        // Heavenly shimmer
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 880 + 44 * Math.random();
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.07, this.ctx.currentTime + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
        osc.connect(gain).connect(this.shimmerGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 3.1);
      }
      motionArp() {
        // Arpeggiator when moving energetically
        const chord = this.chords[this.currentChord];
        for (let i = 0; i < chord.length; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'triangle';
          osc.frequency.value = this.scale[chord[i]];
          gain.gain.setValueAtTime(0.09, this.ctx.currentTime + i * 0.04);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + i * 0.04 + 0.15);
          osc.connect(gain).connect(this.padGainL);
          osc.start(this.ctx.currentTime + i * 0.04);
          osc.stop(this.ctx.currentTime + i * 0.04 + 0.18);
        }
      }
      etherealKick() {
        // Void/Heaven kick
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(38, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(24, this.ctx.currentTime + 0.22);
        gain.gain.setValueAtTime(0.23, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.65);
        osc.connect(gain).connect(this.padGainL);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.65);
      }
      heavenSnare() {
        // Heavenly snare: gentle filtered noise
        const bufferSize = this.ctx.sampleRate * 0.21;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 3;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.09, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.23);
        noise.connect(filter).connect(gain).connect(this.padGainR);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.25);
      }
      voidPulse() {
        // Deep saw pad for void
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.value = 52;
        gain.gain.setValueAtTime(0.11, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.1);
        osc.connect(gain).connect(this.padGainL);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.2);
      }
      runZoneLayers() {
        // Always-on pads with slowly modulated filter/pan for a living universe
        // Left zone pad
        const padOscL = this.ctx.createOscillator();
        padOscL.type = 'triangle';
        padOscL.frequency.value = 164; // Root pad
        const padGainL = this.padGainL;
        const lfoL = this.ctx.createOscillator();
        const lfoGainL = this.ctx.createGain();
        lfoL.type = 'sine';
        lfoL.frequency.value = 0.02 + Math.random() * 0.06;
        lfoGainL.gain.value = 50;
        lfoL.connect(lfoGainL).connect(padOscL.frequency);
        padOscL.connect(padGainL);
        lfoL.start();
        padOscL.start();

        // Right zone pad
        const padOscR = this.ctx.createOscillator();
        padOscR.type = 'triangle';
        padOscR.frequency.value = 262;
        const padGainR = this.padGainR;
        const lfoR = this.ctx.createOscillator();
        const lfoGainR = this.ctx.createGain();
        lfoR.type = 'sine';
        lfoR.frequency.value = 0.013 + Math.random() * 0.03;
        lfoGainR.gain.value = 31;
        lfoR.connect(lfoGainR).connect(padOscR.frequency);
        padOscR.connect(padGainR);
        lfoR.start();
        padOscR.start();

        // Sub (center)
        const subOsc = this.ctx.createOscillator();
        subOsc.type = 'sine';
        subOsc.frequency.value = 49;
        subOsc.connect(this.subGain);
        subOsc.start();

        // Shimmer (right)
        const shimmerOsc = this.ctx.createOscillator();
        shimmerOsc.type = 'triangle';
        shimmerOsc.frequency.value = 1046;
        shimmerOsc.connect(this.shimmerGain);
        shimmerOsc.start();

        // Continuous "atmosphere" noise
        const bufferSize = this.ctx.sampleRate * 2.5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        noise.loop = true;
        noise.connect(this.noiseGain);
        noise.start();
      }
      animate() {
        const update = () => {
          if (!this.active) return;
          document.getElementById('motion').textContent = Math.round(this.motion);
          document.getElementById('bpm').textContent = Math.round(this.bpm);
          document.getElementById('groove').textContent = this.state;
          const orb = document.getElementById('orb');
          orb.style.left = this.pos.x + '%';
          orb.style.top = this.pos.y + '%';
          requestAnimationFrame(update);
        };
        update();
      }
      showError(msg) {
        const error = document.getElementById('error');
        error.textContent = msg;
        error.classList.remove('hidden');
      }
    }
    new SpatialAI();
  </script>
</body>
</html>
