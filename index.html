<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>GUMP: Meta Engine</title>
    <style>
        :root {
            --phi: 1.618033988749895;
            --bg: #000;
            --glow: #ff00ff;
        }
    
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }
    
        body {
            background: var(--bg);
            overflow: hidden;
            height: 100vh;
            font-family: -apple-system, sans-serif;
            font-weight: 100;
            cursor: none;
        }
    
        /* Custom Cursor */
        .cursor {
            position: fixed;
            width: 20px;
            height: 20px;
            border: 1px solid var(--glow);
            border-radius: 50%;
            pointer-events: none;
            z-index: 10000;
            mix-blend-mode: screen;
            transition: transform 0.1s ease;
        }
    
        .cursor-trail {
            position: fixed;
            width: 40px;
            height: 40px;
            background: radial-gradient(circle, var(--glow) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0.2;
            z-index: 9999;
        }
    
        /* Fibonacci Spiral Layout */
        .fibonacci-container {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
    
        .golden-rect {
            position: absolute;
            border: 1px solid rgba(255,0,255,0.1);
            pointer-events: none;
        }
    
        /* Core Orb - Center of Spiral */
        .core-orb {
            width: 233px;
            height: 233px;
            position: absolute;
            top: 50%;
            left: 38.2%;
            transform: translate(-50%, -50%);
            cursor: pointer;
            z-index: 100;
        }
    
        .orb-inner {
            width: 100%;
            height: 100%;
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.2) 0%,
                var(--glow) 23.6%,
                rgba(255,0,255,0.5) 38.2%,
                rgba(138,0,255,0.3) 61.8%,
                transparent 100%);
            box-shadow: 0 0 100px var(--glow),
                       inset 0 0 50px rgba(255,255,255,0.2);
            animation: breathe 4s ease-in-out infinite;
        }
    
        @keyframes breathe {
            0%, 100% { transform: scale(1) rotate(0deg); filter: brightness(1); }
            50% { transform: scale(1.05) rotate(180deg); filter: brightness(1.3); }
        }
    
        .orb-ring {
            position: absolute;
            inset: -20px;
            border-radius: 50%;
            background: conic-gradient(from 0deg,
                transparent,
                var(--glow),
                transparent,
                var(--glow),
                transparent);
            animation: spin 10s linear infinite;
            opacity: 0.5;
        }
    
        @keyframes spin {
            100% { transform: rotate(360deg); }
        }
    
        /* Sample Nodes - Fibonacci Positions */
        .sample-node {
            position: absolute;
            width: 55px;
            height: 55px;
            border-radius: 50%;
            background: radial-gradient(circle at center,
                rgba(255,0,255,0.2) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,0,255,0.3);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: var(--glow);
            opacity: 0.5;
        }
    
        .sample-node.loaded {
            background: radial-gradient(circle at center,
                var(--glow) 0%,
                rgba(255,0,255,0.5) 38.2%,
                transparent 100%);
            opacity: 1;
            animation: pulse 2s ease-in-out infinite;
        }
    
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.1); }
        }
    
        .sample-node.playing {
            box-shadow: 0 0 30px var(--glow);
            transform: scale(0.9);
        }
    
        /* Spectrum Visualizer - Full Screen */
        .spectrum-canvas {
            position: fixed;
            inset: 0;
            opacity: 0.5;
            pointer-events: none;
            mix-blend-mode: screen;
        }
    
        /* Waveform Scope */
        .waveform-scope {
            position: fixed;
            bottom: 34px;
            left: 50%;
            transform: translateX(-50%);
            width: 377px;
            height: 89px;
            border: 1px solid rgba(255,0,255,0.2);
            background: rgba(0,0,0,0.5);
            opacity: 0.7;
        }
    
        /* Info Overlay */
        .info-overlay {
            position: fixed;
            top: 21px;
            left: 21px;
            font-size: 13px;
            color: rgba(255,255,255,0.5);
            letter-spacing: 2px;
            text-transform: uppercase;
            line-height: 1.618;
        }
    
        .info-value {
            color: var(--glow);
            font-weight: 300;
        }
    
        /* Control Gestures */
        .gesture-indicator {
            position: fixed;
            bottom: 21px;
            right: 21px;
            font-size: 11px;
            color: rgba(255,255,255,0.3);
            text-align: right;
            line-height: 1.618;
        }
    
        /* Particle System */
        .particle {
            position: fixed;
            width: 2px;
            height: 2px;
            background: var(--glow);
            pointer-events: none;
            border-radius: 50%;
        }
    
        /* Start Screen */
        .start-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            cursor: pointer;
        }
    
        .start-text {
            font-size: 144px;
            font-weight: 100;
            color: var(--glow);
            opacity: 0;
            animation: fadeIn 2s ease forwards;
            text-shadow: 0 0 50px var(--glow);
        }
    
        @keyframes fadeIn {
            to { opacity: 1; }
        }
    
        /* Atmospheric Layers */
        .atmosphere-layer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0.03;
        }
    
        .atmosphere-1 {
            background: radial-gradient(circle at 61.8% 38.2%, var(--glow) 0%, transparent 50%);
            animation: drift1 34s ease-in-out infinite;
        }
    
        .atmosphere-2 {
            background: radial-gradient(circle at 38.2% 61.8%, rgba(138,0,255,1) 0%, transparent 50%);
            animation: drift2 55s ease-in-out infinite;
        }
    
        @keyframes drift1 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(-34px, 21px) scale(1.2); }
        }
    
        @keyframes drift2 {
            0%, 100% { transform: translate(0, 0) scale(1); }
            50% { transform: translate(21px, -34px) scale(0.8); }
        }
    
        /* Mobile Optimization */
        @media (max-width: 768px) {
            .start-text { font-size: 89px; }
            .waveform-scope { width: 233px; }
            .info-overlay { font-size: 11px; }
            .cursor, .cursor-trail { display: none; }
        }
        /* Mic Warning */
        .mic-warning {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: red;
            background: rgba(0,0,0,0.7);
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <!-- Cursor -->
    <div class="cursor" id="cursor"></div>
    <div class="cursor-trail" id="cursorTrail"></div>
    <!-- Start -->
    <div class="start-screen" id="startScreen">
        <div class="start-text">GUMP</div>
    </div>
    <!-- Atmosphere -->
    <div class="atmosphere-layer atmosphere-1"></div>
    <div class="atmosphere-layer atmosphere-2"></div>
    <!-- Main -->
    <div class="fibonacci-container" id="mainContainer" style="display: none;">
        <!-- Golden Rectangles -->
        <div class="golden-rect" style="width: 610px; height: 377px; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>
        <div class="golden-rect" style="width: 377px; height: 233px; top: 50%; left: 50%; transform: translate(-31%, -50%);"></div>
        <div class="golden-rect" style="width: 233px; height: 144px; top: 50%; left: 50%; transform: translate(-19%, -31%);"></div>
    
        <!-- Core Orb -->
        <div class="core-orb" id="coreOrb">
            <div class="orb-ring"></div>
            <div class="orb-inner"></div>
        </div>
    
        <!-- Sample Nodes -->
        <div id="sampleNodes"></div>
    </div>
    <!-- Visualizers -->
    <canvas class="spectrum-canvas" id="spectrumCanvas"></canvas>
    <canvas class="waveform-scope" id="waveformScope"></canvas>
    <!-- Info -->
    <div class="info-overlay" id="info">
        <div><span class="info-value" id="bpm">120</span> BPM</div>
        <div><span class="info-value" id="key">A</span> MINOR</div>
        <div>COMPLEXITY <span class="info-value" id="complexity">0</span>%</div>
        <div>SAMPLES <span class="info-value" id="samples">0</span></div>
    </div>
    <!-- Gestures -->
    <div class="gesture-indicator">
        CLICK: CAPTURE<br>
        MOVE: MODULATE<br>
        SPACE: CLEAR
    </div>
    <script>
        'use strict';
        class GUMPMeta {
            constructor() {
                this.ctx = null;
                this.isRunning = false;
            
                // Buses & Effects
                this.master = null;
                this.layers = {};
                this.effects = {};
            
                // Samples & Synthesis
                this.samples = new Map();
                this.nodes = [];
                this.currentNodeIndex = 0;
            
                // Musical State
                this.bpm = 120;
                this.key = 'A';
                this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor
                this.currentBar = 0;
                this.nextEventTime = 0;
                this.patternLength = 16;
            
                // AI State
                this.complexity = 0;
                this.energy = 0.5;
                this.vibe = 'mellow'; // Changed from mood to vibe
                this.pattern = null;
                this.firstSampleAnalyzed = false;
            
                // Ambient Capture
                this.micStream = null;
                this.isListening = false;
                this.captureBuffer = [];
                this.hasMic = false;
            
                // UI
                this.ui = {};
                this.mouseX = 0;
                this.mouseY = 0;
            
                // Visualization
                this.analyser = null;
                this.scopeAnalyser = null;
            
                this.init();
            }
        
            init() {
                // Cache elements
                ['startScreen', 'mainContainer', 'coreOrb', 'sampleNodes',
                 'spectrumCanvas', 'waveformScope', 'cursor', 'cursorTrail',
                 'bpm', 'key', 'complexity', 'samples', 'info'].forEach(id => {
                    this.ui[id] = document.getElementById(id);
                });
            
                // Create sample nodes in Fibonacci positions
                this.createFibonacciNodes();
            
                // Events
                this.ui.startScreen.addEventListener('click', () => this.start());
                this.ui.coreOrb.addEventListener('click', () => this.captureNow());
                document.addEventListener('keydown', e => this.handleKey(e));
                document.addEventListener('mousemove', e => this.handleMouse(e));
                document.addEventListener('touchmove', e => this.handleTouch(e));
            
                // Setup visualizers
                this.setupVisualizers();
            }
        
            async start() {
                // Create audio context with high fidelity
                this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                    latencyHint: 'playback',
                    sampleRate: 96000 // Increased for audiophiles
                });
            
                await this.ctx.resume();
            
                // Initialize audio system
                await this.initAudio();
            
                // Setup microphone
                await this.setupMic();
            
                // Start engines
                this.startSequencer();
                this.startAmbientCapture();
            
                // UI transition
                this.ui.startScreen.style.display = 'none';
                this.ui.mainContainer.style.display = 'block';
            
                // Start visuals
                this.animate();
            
                // Immediate ambient drone based on environment
                this.startDrone();
            
                // Start listening for first sample to set vibe
                this.complexity = 0;
                this.ui.complexity.textContent = Math.floor(this.complexity);
            
                this.isRunning = true;
            
                // Show mic warning if no access
                if (!this.hasMic) {
                    const warning = document.createElement('div');
                    warning.className = 'mic-warning';
                    warning.textContent = 'Microphone access denied or unavailable. Using generated samples instead. For real ambient sampling, serve this file over HTTP/HTTPS (not file://) and grant permission.';
                    document.body.appendChild(warning);
                } else {
                    const tip = document.createElement('div');
                    tip.className = 'mic-warning';
                    tip.style.color = 'yellow';
                    tip.textContent = 'Use headphones to avoid feedback loops with speakers.';
                    document.body.appendChild(tip);
                }
            }
        
            async initAudio() {
                // Master chain with enhanced gain for fidelity
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.95;
            
                // Analyzers with higher FFT for precision
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 8192;
            
                this.scopeAnalyser = this.ctx.createAnalyser();
                this.scopeAnalyser.fftSize = 4096;
            
                // Layers with fine-tuned gains
                const layerNames = ['kick', 'bass', 'snare', 'perc', 'hats', 'mid', 'high', 'air'];
                layerNames.forEach(name => {
                    const gain = this.ctx.createGain();
                    gain.gain.value = name === 'kick' ? 1.2 : name === 'bass' ? 1.1 : name === 'snare' ? 0.9 : 0.8;
                    this.layers[name] = gain;
                });
            
                // Create high-fidelity effects chain
                await this.createEffects();
            
                // Routing with analyzers
                Object.values(this.layers).forEach(layer => {
                    layer.connect(this.effects.eq.input);
                });
            
                this.effects.eq.connect(this.effects.multiband);
                this.effects.multiband.connect(this.effects.space.input);
                this.effects.space.connect(this.effects.comp);
                this.effects.comp.connect(this.effects.saturator);
                this.effects.saturator.connect(this.effects.limiter);
                this.effects.limiter.connect(this.master);
            
                this.master.connect(this.analyser);
                this.master.connect(this.scopeAnalyser);
                this.master.connect(this.ctx.destination);
            }
        
            async createEffects() {
                // Enhanced Parametric EQ for audiophile clarity
                this.effects.eq = {
                    input: this.ctx.createGain(),
                    low: this.ctx.createBiquadFilter(),
                    lowMid: this.ctx.createBiquadFilter(),
                    mid: this.ctx.createBiquadFilter(),
                    highMid: this.ctx.createBiquadFilter(),
                    high: this.ctx.createBiquadFilter(),
                    output: this.ctx.createGain()
                };
            
                this.effects.eq.low.type = 'lowshelf';
                this.effects.eq.low.frequency.value = 80;
                this.effects.eq.low.gain.value = 2;
            
                this.effects.eq.lowMid.type = 'peaking';
                this.effects.eq.lowMid.frequency.value = 200;
                this.effects.eq.lowMid.Q.value = 0.6;
                this.effects.eq.lowMid.gain.value = -1.5;
            
                this.effects.eq.mid.type = 'peaking';
                this.effects.eq.mid.frequency.value = 800;
                this.effects.eq.mid.Q.value = 0.8;
                this.effects.eq.mid.gain.value = 1;
            
                this.effects.eq.highMid.type = 'peaking';
                this.effects.eq.highMid.frequency.value = 4000;
                this.effects.eq.highMid.Q.value = 0.6;
                this.effects.eq.highMid.gain.value = 2.5;
            
                this.effects.eq.high.type = 'highshelf';
                this.effects.eq.high.frequency.value = 12000;
                this.effects.eq.high.gain.value = 3;
            
                this.effects.eq.input.connect(this.effects.eq.low);
                this.effects.eq.low.connect(this.effects.eq.lowMid);
                this.effects.eq.lowMid.connect(this.effects.eq.mid);
                this.effects.eq.mid.connect(this.effects.eq.highMid);
                this.effects.eq.highMid.connect(this.effects.eq.high);
                this.effects.eq.high.connect(this.effects.eq.output);
            
                this.effects.eq.connect = (dest) => this.effects.eq.output.connect(dest);
            
                // Multiband Dynamics with finer control
                this.effects.multiband = this.ctx.createDynamicsCompressor();
                this.effects.multiband.threshold.value = -28;
                this.effects.multiband.knee.value = 10;
                this.effects.multiband.ratio.value = 4;
                this.effects.multiband.attack.value = 0.002;
                this.effects.multiband.release.value = 0.08;
            
                // Bus Compressor
                this.effects.comp = this.ctx.createDynamicsCompressor();
                this.effects.comp.threshold.value = -14;
                this.effects.comp.knee.value = 5;
                this.effects.comp.ratio.value = 5;
                this.effects.comp.attack.value = 0.008;
                this.effects.comp.release.value = 0.04;
            
                // Spatial Processor with longer reverb for immersion
                this.effects.space = await this.createSpace();
            
                // High-fidelity Saturator
                this.effects.saturator = this.ctx.createWaveShaper();
                this.effects.saturator.curve = this.makeSaturationCurve(8); // Softer for fidelity
                this.effects.saturator.oversample = '4x';
            
                // Brickwall Limiter
                this.effects.limiter = this.ctx.createDynamicsCompressor();
                this.effects.limiter.threshold.value = -0.2;
                this.effects.limiter.knee.value = 0;
                this.effects.limiter.ratio.value = 30;
                this.effects.limiter.attack.value = 0.0005;
                this.effects.limiter.release.value = 0.005;
            }
        
            async createSpace() {
                const convolver = this.ctx.createConvolver();
            
                // Create immersive hall reverb with longer tail
                const length = this.ctx.sampleRate * 8;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
            
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                    
                        // Early reflections with more detail
                        if (i < this.ctx.sampleRate * 0.15) {
                            if (i % Math.floor(this.ctx.sampleRate * 0.01) === 0) {
                                data[i] = (Math.random() - 0.5) * 0.6 * decay;
                            }
                        }
                    
                        // Diffuse field with smoother noise
                        data[i] += (Math.random() - 0.5) * decay * 0.25;
                    
                        // Parametric low-pass for natural decay
                        if (i > 0) {
                            const cutoff = 0.98 - (i / length) * 0.6;
                            data[i] = data[i] * (1 - cutoff) + data[i-1] * cutoff;
                        }
                    }
                }
            
                convolver.buffer = impulse;
            
                // Wet/dry mix for control
                const input = this.ctx.createGain();
                const dry = this.ctx.createGain();
                const wet = this.ctx.createGain();
                const output = this.ctx.createGain();
            
                dry.gain.value = 0.6;
                wet.gain.value = 0.4;
            
                input.connect(dry);
                input.connect(convolver);
                convolver.connect(wet);
            
                const merger = this.ctx.createGain();
                dry.connect(merger);
                wet.connect(merger);
                merger.connect(output);
            
                return {
                    input,
                    connect: (dest) => output.connect(dest)
                };
            }
        
            async setupMic() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: true, // Enabled to prevent feedback
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 96000,
                            channelCount: 2 // Stereo for high fidelity
                        }
                    });
                
                    this.micStream = this.ctx.createMediaStreamSource(stream);
                    const micGain = this.ctx.createGain();
                    micGain.gain.value = 1;
                
                    const processor = this.ctx.createScriptProcessor(8192, 2, 2); // Larger buffer
                    processor.onaudioprocess = (e) => {
                        if (this.isListening) {
                            const left = e.inputBuffer.getChannelData(0);
                            const right = e.inputBuffer.getChannelData(1);
                            const mono = new Float32Array(left.length);
                            for (let i = 0; i < left.length; i++) {
                                mono[i] = (left[i] + right[i]) / 2;
                            }
                            this.processAmbientAudio(mono);
                        }
                    };
                
                    const mute = this.ctx.createGain();
                    mute.gain.value = 0;
                
                    this.micStream.connect(micGain);
                    micGain.connect(processor);
                    processor.connect(mute);
                    mute.connect(this.ctx.destination);
                
                    this.hasMic = true;
                } catch (e) {
                    console.error('Mic access failed:', e);
                    this.hasMic = false;
                }
            }
        
            startDrone() {
                // Ambient drone starting low, evolves with samples
                const osc = this.ctx.createOscillator();
                osc.type = 'sine';
                osc.frequency.value = 55; // A1
            
                const osc2 = this.ctx.createOscillator();
                osc2.type = 'sine';
                osc2.frequency.value = 55.1; // Slight detune for richness
            
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.12, this.ctx.currentTime + 3);
            
                osc.connect(gain);
                osc2.connect(gain);
                gain.connect(this.layers.bass);
            
                osc.start();
                osc2.start();
            }
        
            startSequencer() {
                const schedule = () => {
                    while (this.nextEventTime < this.ctx.currentTime + 0.1) {
                        const bar = Math.floor(this.currentBar / 16);
                        const step = this.currentBar % 16;
                    
                        // Generate pattern if needed
                        if (step === 0 && bar % 4 === 0) {
                            this.generatePattern();
                        }
                    
                        // Play pattern
                        if (this.pattern) {
                            this.playStep(step, this.nextEventTime);
                        }
                    
                        // Advance
                        this.nextEventTime += 60 / this.bpm / 4;
                        this.currentBar++;
                    
                        // Evolve complexity gradually
                        if (this.currentBar % 16 === 0) {
                            this.complexity = Math.min(100, this.complexity + 1); // Increase for layering
                            this.ui.complexity.textContent = Math.floor(this.complexity);
                        }
                    }
                
                    setTimeout(schedule, 20); // Tighter scheduling
                };
            
                this.nextEventTime = this.ctx.currentTime;
                schedule();
            }
        
            generatePattern() {
                const vibePatterns = {
                    'dark': { // Low energy, low freq dominant
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [4, 12, 20, 28],
                        bass: [0, 8, 16, 24],
                        mid: [12, 28],
                        high: [20]
                    },
                    'energetic': { // High energy, fast peaks
                        kick: [0, 4, 8, 12, 16, 20, 24, 28],
                        snare: [2, 6, 10, 14, 18, 22, 26, 30],
                        hats: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
                        bass: [0, 16],
                        mid: [4, 20],
                        high: [8, 24]
                    },
                    'melodic': { // Pitch dominant, mid freq
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [2, 6, 10, 14, 18, 22, 26, 30],
                        bass: [0, 8, 16, 24],
                        mid: [4, 12, 20, 28],
                        high: [1, 5, 9, 13, 17, 21, 25, 29]
                    },
                    'ambient': { // Low zcr, sustained
                        kick: [0],
                        snare: [],
                        hats: [8, 24],
                        bass: [0, 16],
                        mid: [4, 20],
                        high: [12, 28]
                    },
                    'mellow': {
                        kick: [0, 16],
                        snare: [8, 24],
                        hats: [4, 12, 20, 28],
                        bass: [0, 16],
                        mid: [8, 24],
                        high: [4, 20]
                    }
                };
              
                const basePattern = vibePatterns[this.vibe] || vibePatterns['mellow'];
              
                const pattern = {};
                Object.keys(basePattern).forEach(layer => {
                    pattern[layer] = new Array(this.patternLength).fill(false);
                    basePattern[layer].forEach(step => {
                        if (step < this.patternLength) {
                            pattern[layer][step % this.patternLength] = true;
                        }
                    });
                });
            
                // Add branching complexity based on samples
                Object.keys(pattern).forEach(layer => {
                    for (let i = 0; i < this.patternLength; i++) {
                        const fractalValue = this.fractalNoise(i, layer.length);
                        const threshold = 0.5 - (this.complexity / 100 * 0.3);
                        if (fractalValue > threshold) {
                            pattern[layer][i] = true;
                        }
                    }
                });
            
                this.pattern = pattern;
            }
        
            fractalNoise(x, seed) {
                const scale1 = Math.sin(x * 0.08 + seed) * 0.5 + 0.5;
                const scale2 = Math.sin(x * 0.25 + seed * 2.5) * 0.3 + 0.5;
                const scale3 = Math.sin(x * 0.6 + seed * 3.5) * 0.2 + 0.5;
                return (scale1 + scale2 + scale3) / 3;
            }
        
            playStep(step, time) {
                // Visual pulse on beat
                if (step % 4 === 0) {
                    setTimeout(() => {
                        this.ui.coreOrb.style.filter = 'brightness(1.5)';
                        setTimeout(() => {
                            this.ui.coreOrb.style.filter = 'brightness(1)';
                        }, 50);
                    }, (time - this.ctx.currentTime) * 1000);
                }
            
                // Play layers
                Object.keys(this.pattern).forEach(layer => {
                    if (this.pattern[layer][step]) {
                        this.triggerLayer(layer, time);
                    }
                });
            
                // Play samples with layering
                this.samples.forEach((sample, idx) => {
                    if (sample && sample.pattern && sample.pattern[step]) {
                        this.playSample(idx, time);
                    }
                });
            }
        
            triggerLayer(layer, time) {
                const samplesInLayer = Array.from(this.samples.values()).filter(s => s.layer === layer);
                if (samplesInLayer.length === 0) return;
            
                const idx = Math.floor(Math.random() * samplesInLayer.length);
                const sample = samplesInLayer[idx];
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.pitch || 1;
            
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0.6, time);
                gain.gain.exponentialRampToValueAtTime(0.001, time + sample.buffer.duration * 0.9);
            
                source.connect(gain);
                gain.connect(this.layers[layer]);
            
                source.start(time);
            }
        
            playSample(idx, time) {
                const sample = this.samples.get(idx);
                if (!sample) return;
            
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                source.playbackRate.value = sample.pitch || 1;
            
                const gain = this.ctx.createGain();
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(sample.gain || 0.6, time + 0.005);
                gain.gain.exponentialRampToValueAtTime(0.001, time + sample.buffer.duration * 0.95);
            
                source.connect(gain);
                gain.connect(this.layers[sample.layer]);
            
                source.start(time);
                source.stop(time + sample.buffer.duration);
            
                // Visual feedback
                const node = this.nodes[idx];
                node.classList.add('playing');
                setTimeout(() => node.classList.remove('playing'), 80);
            }
        
            startAmbientCapture() {
                if (this.hasMic) {
                    this.isListening = true;
                    setInterval(() => {
                        if (this.captureBuffer.length > this.ctx.sampleRate * 0.3) {
                            this.processCapturedAudio();
                        }
                    }, 1000); // Faster detection
                } else {
                    setInterval(() => this.generateFakeSample(), 2000);
                }
            }
        
            processAmbientAudio(data) {
                // Enhanced energy detection with peak analysis
                let energy = 0;
                let peaks = 0;
                for (let i = 0; i < data.length; i++) {
                    energy += data[i] * data[i];
                    if (i > 0 && Math.abs(data[i]) > 0.05 && Math.abs(data[i-1]) <= 0.05) {
                        peaks++;
                    }
                }
                energy = Math.sqrt(energy / data.length);
            
                if (energy > 0.01) { // Increased threshold to avoid noise/feedback
                    this.captureBuffer.push(...data);
                }
            
                // Limit buffer to 5 seconds
                if (this.captureBuffer.length > this.ctx.sampleRate * 5) {
                    this.captureBuffer = this.captureBuffer.slice(-this.ctx.sampleRate * 5);
                }
            }
        
            processCapturedAudio() {
                if (this.captureBuffer.length < this.ctx.sampleRate * 0.05) return;
            
                // Dynamic trim based on energy
                const trimLength = Math.min(this.captureBuffer.length, this.ctx.sampleRate * 1.5);
                const startIdx = this.captureBuffer.length - trimLength;
                const trimmedBuffer = this.captureBuffer.slice(startIdx);
            
                const buffer = this.ctx.createBuffer(1, trimmedBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(trimmedBuffer);
            
                this.createSampleFromBuffer(buffer);
            
                this.captureBuffer = [];
            }
        
            generateFakeSample() {
                const length = this.ctx.sampleRate * (0.3 + Math.random() * 0.7);
                const buffer = this.ctx.createBuffer(1, length, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                const freq = 80 + Math.random() * 500;
                for (let i = 0; i < length; i++) {
                    data[i] = Math.sin(i / this.ctx.sampleRate * freq * 2 * Math.PI) * Math.exp(-i / length * 4);
                }
            
                this.createSampleFromBuffer(buffer);
            }
        
            createSampleFromBuffer(buffer) {
                const idx = this.currentNodeIndex % 16;
            
                const analysis = this.analyzeSample(buffer);
                const layer = this.categorizeSample(analysis);
                const playbackRate = analysis.pitch > 0 ? this.quantizePitch(analysis.pitch) / analysis.pitch : 1;
            
                // Pattern generation with branching
                const pattern = new Array(16).fill(false);
                const density = 0.15 + this.complexity / 150;
                for (let i = 0; i < 16; i++) {
                    if (Math.random() < density) {
                        pattern[i] = true;
                    }
                }
            
                this.samples.set(idx, {
                    buffer: buffer,
                    pitch: playbackRate,
                    gain: 0.6,
                    pattern: pattern,
                    layer: layer
                });
            
                this.nodes[idx].classList.add('loaded');
                this.nodes[idx].textContent = '●';
                this.ui.samples.textContent = this.samples.size;
            
                this.currentNodeIndex++;
            
                // If first sample, set global params
                if (!this.firstSampleAnalyzed) {
                    this.setGlobalFromFirstSample(analysis);
                    this.firstSampleAnalyzed = true;
                }
            }
        
            setGlobalFromFirstSample(analysis) {
                // Determine vibe from first sample
                if (analysis.pitch < 150 && analysis.rms > 0.15) {
                    this.vibe = 'dark';
                } else if (analysis.zcr > 5000 && analysis.rms > 0.1) {
                    this.vibe = 'energetic';
                } else if (analysis.pitch > 200 && analysis.pitch < 800) {
                    this.vibe = 'melodic';
                } else if (analysis.duration > 1 && analysis.rms < 0.05) {
                    this.vibe = 'ambient';
                } else {
                    this.vibe = 'mellow';
                }
            
                // Set BPM from tempo estimation
                if (analysis.tempo > 60 && analysis.tempo < 180) {
                    this.bpm = Math.round(analysis.tempo);
                    this.ui.bpm.textContent = this.bpm;
                }
            
                // Set key from pitch
                if (analysis.pitch > 0) {
                    const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                    const semitones = Math.round(12 * Math.log2(analysis.pitch / 440) + 69 - 69 % 12) % 12;
                    this.key = keys[semitones];
                    this.ui.key.textContent = this.key;
                }
            
                // Branching paths: adjust scale
                if (this.vibe === 'dark') {
                    this.scale = [0, 2, 3, 5, 7, 8, 10]; // Minor
                } else if (this.vibe === 'energetic') {
                    this.scale = [0, 2, 4, 5, 7, 9, 11]; // Major
                } else if (this.vibe === 'melodic') {
                    this.scale = [0, 2, 3, 5, 7, 9, 10]; // Harmonic minor
                } else if (this.vibe === 'ambient') {
                    this.scale = [0, 2, 4, 7, 9]; // Pentatonic
                }
            }
        
            analyzeSample(buffer) {
                const data = buffer.getChannelData(0);
                const len = data.length;
              
                // RMS Energy
                let rms = 0;
                for (let i = 0; i < len; i++) {
                    rms += data[i] * data[i];
                }
                rms = Math.sqrt(rms / len);
              
                // Zero crossing rate
                let zcr = 0;
                for (let i = 1; i < len; i++) {
                    if ((data[i] >= 0) !== (data[i-1] >= 0)) {
                        zcr++;
                    }
                }
                zcr /= buffer.duration;
              
                // Pitch detection with improved autocorrelation
                let pitch = 0;
                if (len > 2048) {
                    const maxDelay = Math.min(len >> 1, 4000);
                    const minDelay = 20;
                    let maxCorrelation = 0;
                    let bestDelay = -1;
                  
                    for (let delay = minDelay; delay < maxDelay; delay++) {
                        let correlation = 0;
                        for (let i = 0; i < len - delay; i++) {
                            correlation += data[i] * data[i + delay];
                        }
                        if (correlation > maxCorrelation) {
                            maxCorrelation = correlation;
                            bestDelay = delay;
                        }
                    }
                  
                    if (maxCorrelation > rms * rms * len * 0.25 && bestDelay > 0) {
                        pitch = this.ctx.sampleRate / bestDelay;
                    }
                }
              
                // Tempo from wave peaks (autocorrelation for beat)
                let tempo = 120;
                const peakDelays = [];
                for (let i = 1; i < len - 1; i++) {
                    if (data[i] > data[i-1] && data[i] > data[i+1] && data[i] > 0.05) {
                        peakDelays.push(i);
                    }
                }
                if (peakDelays.length > 1) {
                    let intervals = [];
                    for (let j = 1; j < peakDelays.length; j++) {
                        intervals.push(peakDelays[j] - peakDelays[j-1]);
                    }
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    tempo = 60 / (avgInterval / this.ctx.sampleRate);
                }
              
                return {
                    rms,
                    zcr,
                    pitch,
                    tempo,
                    duration: buffer.duration
                };
            }
        
            categorizeSample(analysis) {
                const { rms, zcr, pitch, duration, tempo } = analysis;
              
                // Branching categorization
                if (pitch < 100 && rms > 0.2 && duration < 0.6) return 'kick';
                if (zcr > 4000 && rms > 0.05 && rms < 0.15 && duration < 0.8) return 'snare';
                if (zcr > 7000 && duration < 0.15) return 'hats';
                if (pitch < 200 && duration > 0.4) return 'bass';
                if (pitch >= 200 && pitch < 1200 && tempo < 100) return 'mid';
                if (pitch > 1200 || zcr > 10000) return 'high';
                return 'perc';
            }
        
            quantizePitch(frequency) {
                const rootFreq = 55; // A1
              
                const semitones = 12 * Math.log2(frequency / rootFreq);
                const octave = Math.floor(semitones / 12);
                const note = semitones % 12;
              
                let closest = this.scale[0];
                let minDistance = Math.abs(note - closest);
              
                for (const scaleNote of this.scale) {
                    const distance = Math.abs(note - scaleNote);
                    if (distance < minDistance) {
                        minDistance = distance;
                        closest = scaleNote;
                    }
                }
              
                return rootFreq * Math.pow(2, (octave * 12 + closest) / 12);
            }
        
            captureNow() {
                if (this.captureBuffer.length > 0) {
                    this.processCapturedAudio();
                }
            }
        
            createFibonacciNodes() {
                const positions = [];
                const phi = 1.618033988749895;
            
                // Generate Fibonacci spiral positions
                for (let i = 0; i < 16; i++) {
                    const angle = i * 137.5 * Math.PI / 180; // Golden angle
                    const radius = 50 + i * 15;
                
                    const x = 50 + radius * Math.cos(angle) * 0.3;
                    const y = 50 + radius * Math.sin(angle) * 0.3;
                
                    positions.push({ x, y });
                }
            
                // Create nodes
                positions.forEach((pos, idx) => {
                    const node = document.createElement('div');
                    node.className = 'sample-node';
                    node.style.left = pos.x + '%';
                    node.style.top = pos.y + '%';
                    node.style.transform = 'translate(-50%, -50%)';
                
                    node.addEventListener('click', () => {
                        if (this.samples.has(idx)) {
                            this.playSample(idx, this.ctx.currentTime);
                        }
                    });
                
                    this.ui.sampleNodes.appendChild(node);
                    this.nodes.push(node);
                });
            }
        
            setupVisualizers() {
                // Spectrum
                const spectrum = this.ui.spectrumCanvas;
                spectrum.width = window.innerWidth * 2; // Higher res
                spectrum.height = window.innerHeight * 2;
                spectrum.style.width = window.innerWidth + 'px';
                spectrum.style.height = window.innerHeight + 'px';
            
                // Waveform
                const scope = this.ui.waveformScope;
                scope.width = 377 * 2;
                scope.height = 89 * 2;
                scope.style.width = '377px';
                scope.style.height = '89px';
            }
        
            handleKey(e) {
                if (e.key === ' ') {
                    e.preventDefault();
                    this.clearAll();
                }
            }
        
            handleMouse(e) {
                this.mouseX = e.clientX;
                this.mouseY = e.clientY;
            
                // Update cursor
                this.ui.cursor.style.left = e.clientX + 'px';
                this.ui.cursor.style.top = e.clientY + 'px';
            
                this.ui.cursorTrail.style.left = e.clientX + 'px';
                this.ui.cursorTrail.style.top = e.clientY + 'px';
            
                // Modulate effects
                if (this.isRunning) {
                    const x = e.clientX / window.innerWidth;
                    const y = e.clientY / window.innerHeight;
                
                    // Modulate EQ dynamically
                    this.effects.eq.highMid.frequency.value = 1500 + x * 5000;
                    this.effects.eq.highMid.gain.value = -4 + y * 12;
                
                    // Energy for vibe adjustment
                    this.energy = Math.sqrt(x * x + y * y) / Math.sqrt(2);
                    this.updateVibe();
                }
            }
        
            updateVibe() {
                // Dynamic vibe shift with mouse
                if (this.energy > 0.85) this.vibe = 'energetic';
                else if (this.energy > 0.65) this.vibe = 'melodic';
                else if (this.energy > 0.45) this.vibe = 'dark';
                else if (this.energy > 0.25) this.vibe = 'ambient';
                else this.vibe = 'mellow';
            }
        
            handleTouch(e) {
                if (e.touches[0]) {
                    this.handleMouse(e.touches[0]);
                }
            }
        
            clearAll() {
                this.samples.clear();
                this.nodes.forEach(node => {
                    node.classList.remove('loaded');
                    node.textContent = '';
                });
                this.ui.samples.textContent = '0';
                this.complexity = 0;
                this.ui.complexity.textContent = '0';
                this.firstSampleAnalyzed = false;
            
                // Particles for clear effect
                for (let i = 0; i < 60; i++) {
                    this.createParticle();
                }
            }
        
            createParticle() {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = '50%';
                particle.style.top = '50%';
                document.body.appendChild(particle);
            
                const angle = Math.random() * Math.PI * 2;
                const velocity = 120 + Math.random() * 250;
                const lifetime = 800 + Math.random() * 1200;
            
                let x = 0, y = 0;
                const start = Date.now();
            
                const update = () => {
                    const elapsed = Date.now() - start;
                    const progress = elapsed / lifetime;
                
                    if (progress >= 1) {
                        particle.remove();
                        return;
                    }
                
                    x += Math.cos(angle) * velocity * 0.016;
                    y += Math.sin(angle) * velocity * 0.016;
                
                    particle.style.transform = `translate(${x}px, ${y}px)`;
                    particle.style.opacity = 1 - progress;
                
                    requestAnimationFrame(update);
                };
            
                update();
            }
        
            animate() {
                requestAnimationFrame(() => this.animate());
            
                // Enhanced Spectrum visualization
                if (this.analyser) {
                    const canvas = this.ui.spectrumCanvas;
                    const ctx = canvas.getContext('2d');
                    const data = new Uint8Array(this.analyser.frequencyBinCount);
                    this.analyser.getByteFrequencyData(data);
                
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                    const barWidth = canvas.width / data.length * 2.5;
                
                    for (let i = 0; i < data.length; i++) {
                        const height = (data[i] / 255) * canvas.height * 1.2;
                        const x = i * barWidth;
                    
                        const gradient = ctx.createLinearGradient(0, canvas.height - height, 0, canvas.height);
                        gradient.addColorStop(0, `rgba(255, 0, 255, ${data[i] / 255 * 0.8})`);
                        gradient.addColorStop(1, 'rgba(138, 0, 255, 0.08)');
                    
                        ctx.fillStyle = gradient;
                        ctx.fillRect(x, canvas.height - height, barWidth - 1, height);
                    }
                }
            
                // Waveform scope with higher res
                if (this.scopeAnalyser) {
                    const scope = this.ui.waveformScope;
                    const ctx = scope.getContext('2d');
                    const data = new Uint8Array(this.scopeAnalyser.fftSize);
                    this.scopeAnalyser.getByteTimeDomainData(data);
                
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
                    ctx.fillRect(0, 0, scope.width, scope.height);
                
                    ctx.beginPath();
                    ctx.strokeStyle = '#ff00ff';
                    ctx.lineWidth = 2;
                
                    const sliceWidth = scope.width / data.length;
                    let x = 0;
                
                    for (let i = 0; i < data.length; i++) {
                        const v = data[i] / 128;
                        const y = v * scope.height / 2;
                    
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    
                        x += sliceWidth;
                    }
                
                    ctx.stroke();
                }
            }
        
            makeSaturationCurve(amount) {
                const samples = 88200; // Higher for fidelity
                const curve = new Float32Array(samples);
            
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2 / samples) - 1;
                    curve[i] = Math.tanh(x * amount) / Math.tanh(amount);
                }
            
                return curve;
            }
        }
    
        // Start
        window.addEventListener('DOMContentLoaded', () => {
            window.gump = new GUMPMeta();
        });
    </script>
</body>
</html>
