<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Cinematic Life Soundtrack</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #f8f8f8;
      color: #333;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,0,0,0.05) 0%, transparent 70%);
      border: 1px solid rgba(0,0,0,0.1);
      color: #333;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      letter-spacing: 1px;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      animation: breathe 4s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(0,0,0,0.2);
      background: radial-gradient(circle, rgba(0,0,0,0.1) 0%, transparent 70%);
    }
    
    @keyframes breathe {
      0%, 100% { transform: scale(1); box-shadow: 0 0 10px rgba(0,0,0,0.05); }
      50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(0,0,0,0.1); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: radial-gradient(circle, #333 0%, rgba(51,51,51,0.6) 30%, transparent 70%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 20px rgba(0,0,0,0.1);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beatPulse 0.1s ease-out;
    }
    
    @keyframes beatPulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.8); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff4757 0%, rgba(255,71,87,0.6) 40%, transparent 80%);
      box-shadow: 0 0 30px rgba(255,71,87,0.3);
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #3742fa 0%, rgba(55,66,250,0.6) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(55,66,250,0.3);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #8e44ad 0%, #e74c3c 30%, #f39c12 60%, transparent 90%);
      box-shadow: 0 0 60px rgba(142,68,173,0.4);
      animation: transcendentGlow 2s ease-in-out infinite;
    }
    
    @keyframes transcendentGlow {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.3); }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(0,0,0,0.6);
      font-weight: normal;
      letter-spacing: 1px;
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .stage-name {
      font-size: 13px;
      color: rgba(0,0,0,0.9);
      margin-bottom: 4px;
    }
    
    .metric {
      margin: 2px 0;
    }
    
    .bar {
      width: 60px;
      height: 2px;
      background: rgba(0,0,0,0.1);
      margin: 2px 0;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: rgba(0,0,0,0.6);
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      border-radius: 50%;
      background: rgba(0,0,0,0.1);
      animation: float 8s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(0,0,0,0.5);
      text-align: center;
      letter-spacing: 1px;
      opacity: 0;
      transition: opacity 1s ease;
      margin-top: 60px;
    }
    
    .instruction.show { opacity: 1; }

    /* New cinematic styles */
    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.3) 100%);
      opacity: 0;
      transition: opacity 2s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.4);
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .theme-text.visible { opacity: 1; }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO COMPOSE YOUR STORY</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
    </div>
  </div>

  <!-- New elements for cinematic feel -->
  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.active = false;
        
        // Musical Structure - Enhanced for Zimmer-like dynamics: longer builds, tension/release, motif development
        this.bpm = 60; // Start slower for dramatic build
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D']; // Extended AABA + C + D for build to climax and resolution
        this.sectionLength = 64; // Even longer phrases for epic cinematic arcs
        this.motif = [0, 2, 4, 7, 9]; // Simple motif that can be varied/developed
        
        // Motion & Position - More sophisticated detection with acceleration patterns for dynamics
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0; // 0-360 degrees
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.stepCounter = 0; // Detect walking rhythm
        this.lastStepTime = 0;
        this.accelPatterns = []; // Track patterns for builds/tension
        
        // Evolution System - Smoother, more stages with Zimmer-inspired narrative acts
        this.stage = 'SILENCE';
        this.subStage = 0; // 0-4 within each stage for finer gradual evolution
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        
        // Cinematic Themes - Expanded for more narrative depth
        this.currentTheme = 'awakening';
        this.themes = {
          awakening: { mood: 'introspective', colors: ['#f8f8f8', '#e0e0e0'], text: 'The Journey Begins', scaleType: 'major' },
          adventure: { mood: 'energetic', colors: ['#ff4757', '#f8f8f8'], text: 'Into the Unknown', scaleType: 'major' },
          tension: { mood: 'suspenseful', colors: ['#3742fa', '#f8f8f8'], text: 'Rising Challenges', scaleType: 'minor' },
          triumph: { mood: 'victorious', colors: ['#8e44ad', '#e74c3c'], text: 'Epic Triumph', scaleType: 'major' },
          reflection: { mood: 'serene', colors: ['#f39c12', '#f8f8f8'], text: 'Moments of Reflection', scaleType: 'minor' },
          climax: { mood: 'intense', colors: ['#e74c3c', '#2c3e50'], text: 'The Final Stand', scaleType: 'phrygian' } // New for peak moments
        };
        
        // Audio Chain - Enhanced for professional engineering: EQ, distortion, wider stereo
        this.masterGain = null;
        this.kickGain = null;
        this.bassGain = null;
        this.leadGain = null;
        this.padGain = null;
        this.reverb = null;
        this.delay = null;
        this.compressor = null;
        this.panner = null;
        this.lowEQ = null; // For bass rumble
        this.highEQ = null; // For air/sparkle
        this.distortion = null; // For grit in intense moments
        
        // Layer Management - More layers for orchestral richness, Zimmer-style hybrids
        this.layers = {
          kick: false,
          bass: false,
          hihat: false,
          snare: false,
          lead: false,
          harmony: false,
          pad: false,
          atmosphere: false,
          strings: false,
          brass: false,
          choir: false,
          percussionEnsemble: false, // New: taikos, toms for epic percussion
          hybridPulse: false,         // New: electronic/orchestral hybrid pulses
          ostinato: false             // New: repeating motifs for tension
        };
        
        // Musical Elements - More adaptive, with motif variations and key modulations
        this.key = 'C';
        this.scale = [0, 2, 4, 5, 7, 9, 11]; // Major by default
        this.chordProgression = [[0,4,7], [5,9,0], [7,11,2], [0,4,7]]; // Base I-V-vi-IV
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.motifVariation = 0; // 0: base, 1: inverted, 2: augmented
        
        this.oscillators = new Set();
        this.elements = {};
        
        this.init();
      }

      init() {
        // Get DOM elements
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'motionBar', 'cinematicOverlay', 'themeText']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
      }

      async start() {
        try {
          // Request motion permissions
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') {
              alert('Motion permission required for your personal soundtrack');
              return;
            }
          }

          // Initialize audio
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();

          // Start evolution
          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 3000);
          }, 500);

          this.active = true;
          this.startSequencer();
          this.animate();
          
        } catch (e) {
          console.error('Failed to start:', e);
          alert('Failed to initialize. Please try again.');
        }
      }

      setupAudioChain() {
        // Master chain
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        
        // Compressor for cinematic dynamic range
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -30; // More aggressive for punch
        this.compressor.knee.value = 25;
        this.compressor.ratio.value = 16;
        this.compressor.attack.value = 0.002;
        this.compressor.release.value = 0.3;
        
        // Panner for spatial audio
        this.panner = this.ctx.createStereoPanner();
        
        // Reverb - Longer and richer
        this.reverb = this.ctx.createConvolver();
        const reverbTime = 6; // Even longer for vast spaces
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 3); // Slower decay for tail
            data[i] = (Math.random() * 2 - 1) * decay * 0.3;
          }
        }
        this.reverb.buffer = buffer;
        
        // Delay - With modulation for movement
        this.delay = this.ctx.createDelay(0.6);
        this.delay.delayTime.value = 0.45;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.5;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.35;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // New: Distortion for grit
        this.distortion = this.ctx.createWaveShaper();
        const curve = new Float32Array(1024);
        for (let i = 0; i < 1024; i++) {
          const x = i / 1024 * 2 - 1;
          curve[i] = (3 + 10) * x * 20 * (Math.PI + 10) / (Math.PI + 10 * Math.abs(x) + 3);
        }
        this.distortion.curve = curve;
        this.distortion.oversample = '4x';
        
        // New: EQ for polish
        this.lowEQ = this.ctx.createBiquadFilter();
        this.lowEQ.type = 'lowshelf';
        this.lowEQ.frequency.value = 120;
        this.lowEQ.gain.value = 0; // Dynamic
        
        this.highEQ = this.ctx.createBiquadFilter();
        this.highEQ.type = 'highshelf';
        this.highEQ.frequency.value = 8000;
        this.highEQ.gain.value = 0; // Dynamic
        
        // Layer gains
        this.kickGain = this.ctx.createGain();
        this.bassGain = this.ctx.createGain();
        this.leadGain = this.ctx.createGain();
        this.padGain = this.ctx.createGain();
        
        // Connect with enhanced chain
        this.kickGain.connect(this.lowEQ);
        this.bassGain.connect(this.lowEQ);
        this.leadGain.connect(this.reverb);
        this.padGain.connect(this.reverb);
        
        this.reverb.connect(this.distortion);
        this.distortion.connect(this.panner);
        delayMix.connect(this.panner);
        this.lowEQ.connect(this.highEQ);
        this.highEQ.connect(this.panner);
        this.panner.connect(this.compressor);
        this.compressor.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      setupMotionDetection() {
        // Device motion - Enhanced with pattern recognition
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.01;
          this.velocity.y += acc.y * 0.01;
          this.updatePosition();
          
          // Direction
          this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
          
          // Step detection
          if (newMotion > 3 && Date.now() - this.lastStepTime > 300) {
            this.stepCounter++;
            this.lastStepTime = Date.now();
            this.syncBPMToSteps();
          }
          
          // Pattern detection for dynamics (e.g., sudden stops for tension)
          this.accelPatterns.push(newMotion);
          if (this.accelPatterns.length > 60) this.accelPatterns.shift();
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        // Mouse fallback
        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 50;
          const velocityY = (newY - lastMouse.y) / dt * 50;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.1;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.8 + newMotion * 0.2; // Slightly smoother
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 180) this.motionHistory.shift(); // Longer history for patterns
        
        this.totalMotion += this.motion;
        
        if (!this.firstMovement && this.motion > 1) {
          this.firstMovement = true;
          this.evolveToTribal();
        }
        
        // Intensity with pattern analysis
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        // Detect sudden changes for dynamics
        if (this.accelPatterns.length > 10) {
          const recentAvg = this.accelPatterns.slice(-10).reduce((a,b)=>a+b,0)/10;
          if (recentAvg < avgMotion * 0.5) this.intensity *= 1.5; // Sudden stop: tension build
        }
        
        this.updateEvolution();
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.85;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.85;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
      }

      syncBPMToSteps() {
        if (this.stepCounter < 5) return;
        
        const stepInterval = (Date.now() - this.lastStepTime * (this.stepCounter - 1)) / (this.stepCounter - 1);
        const targetBPM = 60 / (stepInterval / 1000) * 2;
        
        this.bpm = this.bpm * 0.6 + targetBPM * 0.4; // Smoother sync
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        // Adaptive layers - Finer control
        this.layers.kick = avgMotion > 0.4;
        this.layers.bass = avgMotion > 0.8;
        this.layers.hihat = avgMotion > 1.2 || this.intensity > 0.8;
        this.layers.snare = avgMotion > 1.8 && this.intensity > 1.2;
        this.layers.lead = avgMotion > 2.2;
        this.layers.harmony = avgMotion > 2.8 || this.intensity > 1.8;
        this.layers.pad = avgMotion < 0.8 && this.totalMotion > 100;
        this.layers.atmosphere = this.intensity < 0.4 && avgMotion < 0.8;
        this.layers.strings = this.stage !== 'SILENCE' && avgMotion > 1.5;
        this.layers.brass = this.stage === 'TRANSCENDENT' && this.intensity > 1.8;
        this.layers.choir = this.stage === 'TRANSCENDENT' && avgMotion < 1.2;
        this.layers.percussionEnsemble = avgMotion > 3 || this.intensity > 2.5;
        this.layers.hybridPulse = this.stage !== 'SILENCE' && this.intensity > 1;
        this.layers.ostinato = this.currentTheme === 'tension' || this.currentTheme === 'climax';
        
        // Evolution with sub-stages
        this.evolutionProgress = Math.min(this.totalMotion / 800, 4); // Slower progression
        this.subStage = Math.floor(this.evolutionProgress);
        
        if (this.stage === 'TRIBAL' && this.totalMotion > 300) {
          this.evolveToOrchestral();
        } else if (this.stage === 'ORCHESTRAL' && this.totalMotion > 600) {
          this.evolveToTranscendent();
        }
        
        // Dynamic BPM with theme influence
        let baseBPM = 50 + (avgMotion * 6) + (this.intensity * 4);
        baseBPM += (this.subStage * 12);
        if (this.stage === 'TRIBAL') baseBPM += 25;
        else if (this.stage === 'ORCHESTRAL') baseBPM += 45;
        else if (this.stage === 'TRANSCENDENT') baseBPM += 70;
        
        if (this.currentTheme === 'reflection') baseBPM *= 0.8; // Slow for serenity
        else if (this.currentTheme === 'climax') baseBPM *= 1.2; // Rush for peak
        
        this.bpm = this.bpm * 0.85 + baseBPM * 0.15;
        
        // Update theme
        this.updateCinematicTheme(avgMotion, this.intensity);
        
        // Dynamic EQ and distortion
        this.lowEQ.gain.value = 2 + this.intensity * 3; // Boost low end with intensity
        this.highEQ.gain.value = -2 + this.motion * 2; // Add air with motion
        this.distortion.connect(this.panner); // Always in chain, but control amount implicitly via sends
      }

      updateCinematicTheme(avgMotion, intensity) {
        let newTheme = 'awakening';
        if (avgMotion > 4 && intensity > 2.5) newTheme = 'climax';
        else if (avgMotion > 3 && intensity > 2) newTheme = 'triumph';
        else if (avgMotion > 2 && intensity > 1.5) newTheme = 'tension';
        else if (avgMotion > 1) newTheme = 'adventure';
        else if (avgMotion < 1 && this.totalMotion > 150) newTheme = 'reflection';
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.elements.themeText.textContent = this.themes[newTheme].text;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 4000);
          
          // Update scale based on theme
          const scaleType = this.themes[newTheme].scaleType;
          if (scaleType === 'minor') {
            this.scale = [0, 2, 3, 5, 7, 8, 10];
          } else if (scaleType === 'phrygian') {
            this.scale = [0, 1, 3, 5, 7, 8, 10]; // Dark, tense mode for climax
          } else {
            this.scale = [0, 2, 4, 5, 7, 9, 11];
          }
          
          // Occasional key modulation for drama
          if (Math.random() < 0.2 && newTheme !== 'awakening') {
            this.key = ['C', 'D', 'E', 'F', 'G', 'A', 'B'][Math.floor(Math.random() * 7)];
          }
          
          // Vary motif
          this.motifVariation = Math.floor(Math.random() * 3);
        }
      }

      evolveToTribal() {
        this.stage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.createParticles(40, '#ff4757');
        console.log('ðŸ”¥ TRIBAL EVOLUTION: The Adventure Awakens');
      }

      evolveToOrchestral() {
        this.stage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.createParticles(60, '#3742fa');
        console.log('ðŸŽ¼ ORCHESTRAL EVOLUTION: Symphony of Challenges');
      }

      evolveToTranscendent() {
        this.stage = 'TRANSCENDENT';
        this.elements.orb.className = 'orb transcendent';
        this.createParticles(80, '#8e44ad');
        console.log('âœ¨ TRANSCENDENT EVOLUTION: Legendary Climax');
      }

      createParticles(count, color) {
        const existing = document.querySelector('.particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.background = color;
          particle.style.animationDelay = Math.random() * 8 + 's';
          particle.style.animationDuration = (3 + Math.random() * 5) + 's'; // Varied speeds
          container.appendChild(particle);
        }
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          // Phrase changes with motif development
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.updateHarmony();
            
            // Develop motif every few phrases
            if (this.phraseCount % 4 === 0) {
              this.developMotif();
            }
          }
          
          const interval = (60 / this.bpm) * 62.5; // 64th notes for finer control
          setTimeout(tick, interval);
        };
        tick();
      }

      developMotif() {
        // Vary motif for composition depth
        if (this.motifVariation === 1) { // Inverted
          this.motif = this.motif.map(n => 12 - n).reverse();
        } else if (this.motifVariation === 2) { // Augmented (stretched)
          this.motif = this.motif.map(n => n * 1.5).map(Math.floor);
        } else { // Base with transposition
          const transpose = Math.floor(Math.random() * 5) - 2;
          this.motif = this.motif.map(n => (n + transpose + 12) % 12);
        }
      }

      playStep() {
        // Pulse
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 100);
        }
        
        // Panning with more width
        this.panner.pan.value = Math.sin(this.direction * Math.PI / 180) * 0.7;
        
        // Play layers with Zimmer-like variations: builds, swells, hybrids
        if (this.layers.kick && this.step % 8 === 0) this.playKick();
        if (this.layers.bass && this.step % 4 === 0) this.playBass();
        if (this.layers.hihat && (this.step % 2 === 1 || (this.intensity > 2 && this.step % 1 === 0))) this.playHihat(); // Denser in intensity
        if (this.layers.snare && (this.step % 8 === 4 || (this.intensity > 2 && this.step % 8 === 6))) this.playSnare();
        if (this.layers.lead && this.step % 4 === 2) this.playLead();
        if (this.layers.harmony && this.step % 16 === 0) this.playHarmony();
        if (this.layers.pad && this.step % 32 === 0) this.playPad();
        if (this.layers.atmosphere && Math.random() < 0.04 * (1 - this.motion / 6)) this.playAtmosphere();
        if (this.layers.strings && this.step % 8 === 0) this.playStrings();
        if (this.layers.brass && this.step % 16 === 0 && this.intensity > 1.5) this.playBrass();
        if (this.layers.choir && this.step % 32 === 0 && this.motion < 2) this.playChoir();
        if (this.layers.percussionEnsemble && (this.step % 4 === 0 || this.step % 8 === 2)) this.playPercussionEnsemble();
        if (this.layers.hybridPulse && this.step % 2 === 0) this.playHybridPulse();
        if (this.layers.ostinato && this.step % 1 === 0) this.playOstinato();
      }

      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(70 + this.intensity * 15, this.ctx.currentTime); // Deeper, more rumble
        osc.frequency.exponentialRampToValueAtTime(25, this.ctx.currentTime + 0.4);
        
        gain.gain.setValueAtTime(1.0, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        osc.connect(gain).connect(this.kickGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      playBass() {
        if (this.oscillators.size > 25) return;
        
        const noteIndex = this.bassNote % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 0 + Math.floor(this.subStage / 2)); // Ultra low for Zimmer bass
        
        // Multi-osc for thickness
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'sine';
        osc2.frequency.value = freq * 2.01; // Slight detune
        
        filter.type = 'lowpass';
        filter.frequency.value = 100 + this.motion * 40 + this.intensity * 30;
        filter.Q.value = 4 + this.intensity * 2;
        
        gain.gain.setValueAtTime(0.6, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.bassGain);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 0.8);
        osc2.stop(this.ctx.currentTime + 0.8);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => { this.oscillators.delete(osc1); this.oscillators.delete(osc2); }, 800);
      }

      playHihat() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'square';
        osc.frequency.value = 6000 + Math.random() * 4000 + this.intensity * 1500;
        
        filter.type = 'highpass';
        filter.frequency.value = 4000 + this.motion * 600;
        filter.Q.value = 2 + this.intensity;
        
        gain.gain.setValueAtTime(0.12, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.12 - this.intensity * 0.04);
        
        osc.connect(filter).connect(gain).connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.12);
      }

      playSnare() {
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc1.type = 'triangle';
        osc1.frequency.value = 160 + this.intensity * 30;
        osc2.type = 'square';
        osc2.frequency.value = 6000 + this.motion * 600;
        
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        osc1.connect(gain).connect(this.masterGain);
        osc2.connect(gain);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 0.3);
        osc2.stop(this.ctx.currentTime + 0.1);
      }

      playLead() {
        if (this.oscillators.size > 20) return;
        
        // Use motif for lead
        const motifIndex = this.step % this.motif.length;
        const noteIndex = (this.motif[motifIndex] + this.scale.length) % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 4 + Math.floor(this.subStage / 2));
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = this.currentTheme === 'triumph' || this.currentTheme === 'climax' ? 'sawtooth' : 'square';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 700 + this.motion * 200 + this.intensity * 150;
        filter.Q.value = 5 + this.intensity * 2;
        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);
        
        osc.connect(filter).connect(gain).connect(this.leadGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.6);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 600);
      }

      playHarmony() {
        if (this.oscillators.size > 30) return;
        
        const chord = this.chordProgression[this.currentChordIndex];
        chord.forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 3 + i);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4); // Longer for sustains
          
          osc.connect(gain).connect(this.leadGain);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 4000);
        });
      }

      playPad() {
        if (this.oscillators.size > 35) return;
        
        this.scale.forEach((note, i) => {
          const freq = this.noteToFreq(note, 1 + i % 3);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.003); // Thicker detune
          
          filter.type = 'lowpass';
          filter.frequency.value = 300 + this.motion * 80 + this.intensity * 60;
          filter.Q.value = 0.6;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.08, this.ctx.currentTime + 3);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 12); // Epic swells
          
          osc.connect(filter).connect(gain).connect(this.padGain);
          osc.start();
          osc.stop(this.ctx.currentTime + 12);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 12000);
        });
      }

      playAtmosphere() {
        if (this.oscillators.size > 40) return;
        
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 5 + Math.random() * 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 150 + Math.random() * 300;
        filter.Q.value = 12 + this.intensity * 3;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.04, this.ctx.currentTime + 4);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 18);
        
        osc.connect(filter).connect(gain).connect(this.padGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 18);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 18000);
      }

      playStrings() {
        if (this.oscillators.size > 45) return;
        
        const chord = this.chordProgression[this.currentChordIndex];
        chord.forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 2 + i);
          
          // Multi-osc for string section feel
          const osc1 = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc1.type = 'sawtooth';
          osc1.frequency.value = freq * 1.005;
          osc2.type = 'sawtooth';
          osc2.frequency.value = freq * 0.995;
          
          gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 5);
          
          osc1.connect(gain).connect(this.reverb);
          osc2.connect(gain);
          osc1.start();
          osc2.start();
          osc1.stop(this.ctx.currentTime + 5);
          osc2.stop(this.ctx.currentTime + 5);
          
          this.oscillators.add(osc1);
          this.oscillators.add(osc2);
          setTimeout(() => { this.oscillators.delete(osc1); this.oscillators.delete(osc2); }, 5000);
        });
      }

      playBrass() {
        if (this.oscillators.size > 50) return;
        
        const note = this.scale[Math.floor(this.scale.length / 2 + this.intensity)];
        const freq = this.noteToFreq(note, 3);
        
        // Layered for fanfare
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 1.01;
        
        filter.type = 'lowpass';
        filter.frequency.value = 500 + this.intensity * 300;
        filter.Q.value = 6;
        
        gain.gain.setValueAtTime(0.35, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.leadGain);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 2);
        osc2.stop(this.ctx.currentTime + 2);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => { this.oscillators.delete(osc1); this.oscillators.delete(osc2); }, 2000);
      }

      playChoir() {
        if (this.oscillators.size > 55) return;
        
        this.chordProgression[this.currentChordIndex].forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 4 + i % 3);
          
          // Multi-osc for vocal formants
          const osc1 = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc1.type = 'triangle';
          osc1.frequency.value = freq * 1.002;
          osc2.type = 'sine';
          osc2.frequency.value = freq * 2.005;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.12, this.ctx.currentTime + 5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 15);
          
          osc1.connect(gain).connect(this.reverb);
          osc2.connect(gain);
          osc1.start();
          osc2.start();
          osc1.stop(this.ctx.currentTime + 15);
          osc2.stop(this.ctx.currentTime + 15);
          
          this.oscillators.add(osc1);
          this.oscillators.add(osc2);
          setTimeout(() => { this.oscillators.delete(osc1); this.oscillators.delete(osc2); }, 15000);
        });
      }

      // New layers for Zimmer touch

      playPercussionEnsemble() {
        // Taiko-like deep drums + toms
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(100 + this.intensity * 20, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.6);
        
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.7);
        
        osc.connect(gain).connect(this.kickGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.7);
      }

      playHybridPulse() {
        // Electronic pulse with orchestral bite
        const freq = this.noteToFreq(this.scale[0], 2); // Root note
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc1.type = 'pulse'; // Note: 'square' as proxy for pulse
        osc1.frequency.value = freq / 2;
        osc2.type = 'sawtooth';
        osc2.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = 200 + this.motion * 50;
        filter.Q.value = 10 + this.intensity;
        
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.bassGain);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 0.2);
        osc2.stop(this.ctx.currentTime + 0.2);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => { this.oscillators.delete(osc1); this.oscillators.delete(osc2); }, 200);
      }

      playOstinato() {
        // Repeating motif fragment for tension
        if (this.oscillators.size > 60 || this.step % 2 !== 0) return;
        
        const motifFrag = this.motif.slice(0, 3); // Short repeat
        const noteIndex = motifFrag[this.step % 3];
        const freq = this.noteToFreq(noteIndex, 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        osc.connect(gain).connect(this.delay);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 300);
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
        
        // Occasional progression variation for dynamics
        if (this.phrase === 'C' || this.phrase === 'D') {
          this.chordProgression = [[0,3,7], [4,7,11], [5,8,0], [0,3,7]]; // Shift to minor for tension
        } else {
          this.chordProgression = [[0,4,7], [5,9,0], [7,11,2], [0,4,7]];
        }
      }

      noteToFreq(note, octave = 4) {
        // Adjust for key
        const base = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 }[this.key];
        return 440 * Math.pow(2, (base + note) / 12 + (octave - 4));
      }

      updateUI() {
        this.elements.stageName.textContent = `${this.stage} - ${this.subStage + 1}`;
        const motionPercent = Math.min((this.motion + this.intensity * 1.5) * 7, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          const theme = this.themes[this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 4, 1);
          const motionNorm = Math.min(this.motion / 6, 1);
          
          let bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
          bg += `${theme.colors[0]} ${8 * motionNorm}%, `;
          if (theme.colors[1]) bg += `${theme.colors[1]} ${25 * intensityNorm}%, `;
          bg += `#f8f8f8 ${60 + 30 * intensityNorm}%`;
          bg += ')';
          
          document.body.style.background = bg;
          
          this.elements.cinematicOverlay.classList.toggle('active', this.intensity > 1.2);
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    // Initialize GUMP
    new GUMP();
  </script>
</body>
</html>
