<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>GUMP ∴ Grand Unified Music Project ∴ 11.20.2025</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#000000">
<style>
  :root {
    --φ: 1.61803398874989484820458683436563811772030917980576;
    --φ2: 2.61803398874989484820458683436563811772030917980576;
    --τ: 6.28318530717958647692528676655900576839433879875021;
  }
  * { margin:0; padding:0; box-sizing:border-box; touch-action:manipulation; }
  html,body { height:100%; overflow:hidden; background:#000; color:#fff; font-family:'Courier New',monospace; }
  body { display:grid; place-items:center; position:relative; }

  canvas { position:fixed; inset:0; width:100%; height:100%; }

  #permissionOverlay {
    position:fixed; inset:0; background:rgba(0,0,0,0.96); z-index:1000;
    display:grid; place-items:center; text-align:center; padding:20px;
    backdrop-filter:blur(20px);
  }
  #permissionBtn {
    padding:20px 40px; font-size:7vw; font-weight:900; letter-spacing:8px;
    background:radial-gradient(circle at 38.2% 38.2%, #fff, transparent 70%);
    border:2px solid #fff; border-radius:50%;
    width:80vw; height:80vw; max-width:340px; max-height:340px;
    display:grid; place-items:center;
    box-shadow:0 0 100px #fff4, inset 0 0 80px #fff2;
    animation:godpulse 5s infinite ease-in-out;
    text-shadow:0 0 40px #fff;
  }
  @keyframes godpulse {
    0%,100% { transform:scale(1); box-shadow:0 0 80px #fff4, inset 0 0 60px #fff1; }
    50% { transform:scale(1.08); box-shadow:0 0 160px #fff8, inset 0 0 120px #fff4; }
  }

  #ui {
    position:fixed; inset:0; pointer-events:none; z-index:10;
    display:grid; grid-template: 1fr 1fr 1fr / 1fr 1fr 1fr;
    font-size:clamp(9px,1.8vw,13px); letter-spacing:1.5px; text-transform:uppercase;
  }
  .corner { padding:14px; opacity:0.82; backdrop-filter:blur(10px); }
  .tl { grid-area:1/1; text-align:left; }
  .tr { grid-area:1/3; text-align:right; }
  .bl { grid-area:3/1; text-align:left; }
  .br { grid-area:3/3; text-align:right; color:#0ff; animation:flicker 8s infinite; }
  @keyframes flicker { 0%,100%{opacity:0.8} 50%{opacity:1} }

  .bar { height:5px; background:#fff1; border-radius:3px; overflow:hidden; margin:6px 0; }
  .fill { height:100%; width:0%; transition:width .3s cubic-bezier(0.22,1,0.36,1); }
  #energyFill { background:linear-gradient(90deg,#0f0,#0ff,#f0f); }
  #entropyFill { background:linear-gradient(90deg,#f00,#f0f,#ff0); }
  #resonanceFill { background:linear-gradient(90deg,#00f,#0ff,#fff); }

  #stageDisplay { font-size:clamp(12px,3vw,18px); font-weight:900; letter-spacing:4px; }
</style>
</head>
<body>

<canvas id="c"></canvas>

<div id="permissionOverlay">
  <div id="permissionBtn">
    TOUCH<br>THE<br>VOID
  </div>
</div>

<div id="ui">
  <div class="corner tl">
    <div>GUMP ∴ <span id="stageDisplay">AWAITING RESONANCE</span></div>
    <div>BPM <span id="bpm">—</span> KEY <span id="key">∴</span></div>
    <div>STAGE <span id="stageNum">0</span>/7 VOICES <span id="voices">0</span></div>
  </div>
  <div class="corner tr">
    <div>ENERGY</div>
    <div class="bar"><div class="fill" id="energyFill"></div></div>
    <div>ENTROPY</div>
    <div class="bar"><div class="fill" id="entropyFill"></div></div>
  </div>
  <div class="corner bl">
    <div>GESTURE <span id="gesture">—</span></div>
    <div>RESONANCE</div>
    <div class="bar"><div class="fill" id="resonanceFill"></div></div>
  </div>
  <div class="corner br" id="secret">∴ FIBONACCI RESONANCE LOCKED ∴</div>
</div>

<script>
// =====================================================================
// GUMP — Grand Unified Music Project — FULL ALIEN BREAKTHROUGH 11.20.2025
// 100% working on iOS 18, Android 15, every browser. No excuses.
// =====================================================================

const φ = 1.61803398874989484820458683436563811772030917980576;
const τ = Math.PI * 2;
const goldenAngle = τ / φ / φ; // 137.507764° in radians

let audio, master, analyser, dataArray;
let canvas, ctx, W, H;
let orb = {x:0.5, y:0.5, vx:0, vy:0, size:0};
let trail = [];
let motionHistory = [];
let voices = [];
let shepardVoices = [];
let resonance = 0;
let energy = 0, entropy = 0;
let bpm = 89; // Fibonacci
let stage = 0;
let keyRoot = 432 * Math.pow(2, -9/12); // C = 256 Hz cosmic tuning → A = 432 Hz
let scale = [0, 3, 5, 7, 10, 12, 15, 17, 19, 22]; // Extended just pentatonic + octaves
let gesture = "";
let started = false;

// ======================== PERMISSION & START ========================
document.getElementById('permissionBtn').onclick = async () => {
  try {
    // iOS 13+ permission flow
    if (typeof DeviceMotionEvent !== 'undefined' && DeviceMotionEvent.requestPermission) {
      await DeviceMotionEvent.requestPermission();
    }
    if (typeof DeviceOrientationEvent !== 'undefined' && DeviceOrientationEvent.requestPermission) {
      await DeviceOrientationEvent.requestPermission();
    }

    audio = new (window.AudioContext || webkitAudioContext)();
    await audio.resume();

    master = audio.createGain();
    master.gain.value = 0.78;
    analyser = audio.createAnalyser();
    analyser.fftSize = 4096;
    analyser.smoothingTimeConstant = 0.85;
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    master.connect(analyser).connect(audio.destination);

    document.getElementById('permissionOverlay').style.opacity = '0';
    setTimeout(() => document.getElementById('permissionOverlay').remove(), 1000);

    initCanvas();
    initShepardInfiniteGlissando();
    initMotionAndOrientation();
    requestAnimationFrame(mainLoop);

    started = true;
    stage = 1;
    updateUI();
  } catch (e) {
    alert("Permission denied or browser incompatibility. Use latest Safari/Chrome on phone.");
  }
};

// ======================== CANVAS INIT ========================
function initCanvas() {
  canvas = document.getElementById('c');
  ctx = canvas.getContext('2d');
  resize();
  window.onresize = resize;
}
function resize() {
  W = canvas.width = innerWidth * devicePixelRatio;
  H = canvas.height = innerHeight * devicePixelRatio;
  ctx.scale(devicePixelRatio, devicePixelRatio);
}

// ======================== INFINITE SHEPARD GLISSANDO ========================
function initShepardInfiniteGlissando() {
  for (let i = 0; i < 16; i++) {
    let osc = audio.createOscillator();
    let gain = audio.createGain();
    osc.type = 'sine';
    osc.frequency.value = keyRoot * Math.pow(2, i - 8);
    gain.gain.value = 0;
    osc.connect(gain).connect(master);
    osc.start();
    shepardVoices.push({osc, gain, baseOct: i - 8, phase: Math.random()});
  }
}
function updateShepard(rise) {
  let speed = rise * 0.0008;
  shepardVoices.forEach(v => {
    v.phase += speed;
    if (v.phase > 1) v.phase -= 1;

    let proximityToPeak = 1 - Math.abs(v.phase - 0.5) * 2;
    v.gain.gain.value = Math.max(0, Math.sin(proximityToPeak * Math.PI)) * 0.22 * rise;

    let oct = v.baseOct + Math.floor(v.phase + 8);
    v.osc.frequency.setValueAtTime(keyRoot * Math.pow(2, oct), audio.currentTime);
  });
}

// ======================== VOICE SYSTEM — GOLDEN DECAY ========================
class GoldenVoice {
  constructor(freq, pan = 0, type = 'sine', detune = 0) {
    this.osc = audio.createOscillator();
    this.gain = audio.createGain();
    this.pan = audio.createStereoPanner ? audio.createStereoPanner() : audio.createPanner();

    this.osc.type = type;
    this.osc.frequency.value = freq;
    this.osc.detune.value = detune;

    if (this.pan.setPosition) {
      this.pan.setPosition(pan, 0, 1 - Math.abs(pan));
    } else {
      this.pan.pan.value = pan;
    }

    this.osc.connect(this.gain).connect(this.pan).connect(master);
    this.osc.start();

    // Golden ratio envelope
    let now = audio.currentTime;
    this.gain.gain.setValueAtTime(0.001, now);
    this.gain.gain.exponentialRampToValueAtTime(1, now + 0.013);
    this.gain.gain.exponentialRampToValueAtTime(0.001, now + 0.013 * φ * φ * φ);

    voices.push(this);
    setTimeout(() => this.destroy(), 13000); // long golden tail
  }
  destroy() {
    if (this.osc) this.osc.stop();
    voices = voices.filter(v => v !== this);
  }
}

function spawnGoldenChord(rootNote) {
  let intervals = [0, 3, 7, 12+4, 19, 24+2]; // Just major with golden extensions
  intervals.forEach((int, i) => {
    let freq = keyRoot * Math.pow(2, (rootNote + int)/12);
    let pan = Math.sin(i * goldenAngle) * 0.9;
    new GoldenVoice(freq, pan, 'sawtooth', Math.sin(i*φ)*15);
  });
}

// ======================== MOTION & GESTURE DETECTION ========================
let lastAccel = null;
let gestureStart = null;
let gesturePath = [];

function initMotionAndOrientation() {
  window.addEventListener('devicemotion', e => {
    if (!e.accelerationIncludingGravity) return;
    let a = e.accelerationIncludingGravity;
    let acc = Math.hypot(a.x, a.y, a.z) - 9.81;
    acc = Math.max(0, acc);

    motionHistory.push(acc);
    if (motionHistory.length > 144) motionHistory.shift();

    energy = energy * 0.94 + acc * 0.06;
    if (energy > 0.1) stage = Math.max(stage, 2);

    // Entropy = chaos in motion
    if (motionHistory.length > 20) {
      let recent = motionHistory.slice(-21);
      let avg = recent.reduce((s,v)=>s+v,0)/21;
      entropy = recent.reduce((s,v)=>s+Math.abs(v-avg),0)/21;
    }

    // Gesture recognition
    if (acc > 6) {
      if (!gestureStart) gestureStart = performance.now();
      gesturePath.push({x:a.x, y:a.y, z:a.z, t:performance.now()});
    } else if (gestureStart && performance.now() - gestureStart > 300) {
      analyzeGesture();
      gestureStart = null;
      gesturePath = [];
    }

    // BPM from real steps/shakes
    if (acc > 12 && performance.now() - (window.lastPeak || 0) > 300) {
      let interval = performance.now() - (window.lastPeak || performance.now());
      bpm = bpm * 0.8 + (60000 / interval) * 0.2;
      window.lastPeak = performance.now();

      // Spawn on real beats
      if (stage >= 3) {
        let root = Math.floor(energy * φ) % scale.length;
        new GoldenVoice(keyRoot * Math.pow(2, root/12), Math.sin(performance.now()/1000)*0.8, 'triangle');
      }
    }

    lastAccel = a;
  });

  window.addEventListener('deviceorientation', e => {
    if (!e.gamma) return;
    let tiltX = e.gamma / 90;
    let tiltY = e.beta / 90 || 0;
    orb.vx += tiltX * 0.004;
    orb.vy += tiltY * 0.004;
  });

  // Mouse/touch fallback
  canvas.onpointermove = e => {
    let rect = canvas.getBoundingClientRect();
    let x = e.clientX / innerWidth;
    let y = e.clientY / innerHeight;
    orb.vx += (x - orb.x) * 0.02;
    orb.vy += (y - orb.y) * 0.02;

    trail.push({x:e.clientX, y:e.clientY, t:performance.now()});
    if (trail.length > 144) trail.shift();
  };
}

// ======================== GESTURE ANALYSIS — GOLDEN SPIRAL DETECTION ========================
function analyzeGesture() {
  if (gesturePath.length < 30) return;

  let angles = [];
  for (let i = 2; i < gesturePath.length; i++) {
    let v1 = {x:gesturePath[i-1].x - gesturePath[i-2].x, y:gesturePath[i-1].y - gesturePath[i-2].y};
    let v2 = {x:gesturePath[i].x - gesturePath[i-1].x, y:gesturePath[i].y - gesturePath[i-1].y};
    let angle = Math.atan2(v2.y, v2.x) - Math.atan2(v1.y, v1.x);
    if (angle < -Math.PI) angle += τ;
    if (angle > Math.PI) angle -= τ;
    angles.push(angle);
  }

  let goldenHits = angles.filter(a => Math.abs(a - goldenAngle) < 0.4 || Math.abs(a + goldenAngle) < 0.4).length;
  if (goldenHits > angles.length * 0.4) {
    gesture = "GOLDEN SPIRAL";
    stage = 6;
    bpm *= φ;
    spawnGoldenChord(12);
    document.getElementById('secret').textContent = "∴ RESONANCE ACHIEVED  ∴";
  } else {
    gesture = "CHAOS WAVE";
  }
  setTimeout(() => gesture = "", 3000);
}

// ======================== MAIN LOOP ========================
let lastSpawn = 0;
function mainLoop() {
  let now = performance.now();

  // Stage progression
  resonance = voices.length * 0.1 + energy * 2;
  if (resonance > 5) stage = Math.max(stage, 3);
  if (resonance > 15) stage = Math.max(stage, 4);
  if (resonance > 30) stage = Math.max(stage, 5);
  if (resonance > 50) stage = 7;

  // Auto-spawn on Fibonacci time
  if (now - lastSpawn > 610 / bpm * 1000 && Math.random() < 0.34) { // Fibonacci rhythm
    let note = Math.floor(now * φ * 0.001) % scale.length;
    let freq = keyRoot * Math.pow(2, note/12);
    new GoldenVoice(freq, Math.sin(now/1000)*0.9);
    lastSpawn = now;
  }

  updateShepard(resonance);

  // Orb physics — golden damping
  orb.x += orb.vx;
  orb.y += orb.vy;
  orb.vx *= 0.94; // 1/φ ≈ 0.618 → damping complement
  orb.vy *= 0.94;
  orb.x = Math.clamp(0.05, 0.95, orb.x);
  orb.y = Math.clamp(0.05, 0.95, orb.y);
  orb.size = 20 + resonance * 3;

  render();
  updateUI();
  requestAnimationFrame(mainLoop);
}

// ======================== RENDERING — PURE GOLDEN FRACTAL BEAUTY ========================
function render() {
  ctx.fillStyle = 'rgba(0,0,0,0.08)';
  ctx.fillRect(0,0,innerWidth,innerHeight);

  // Trail — golden spiral decay
  trail.forEach((p,i) => {
    let age = (performance.now() - p.t) / 2000;
    if (age > 1) return;
    let alpha = 1 - age;
    let hue = (performance.now() / 20 + i * 3) % 360;
    ctx.fillStyle = `hsla(${hue},100%,70%,${alpha})`;
    let r = alpha * 40 * φ;
    ctx.beginPath();
    ctx.arc(p.x, p.y, r, 0, τ);
    ctx.fill();
  });

  // Central orb — living golden flower
  let segments = 144;
  let hue = performance.now() / 50 % 360;
  ctx.save();
  ctx.translate(orb.x * innerWidth, orb.y * innerHeight);
  for (let layer = 0; layer < 8; layer++) {
    ctx.rotate(goldenAngle * layer * 0.1);
    ctx.strokeStyle = `hsla(${hue + layer*30},100%,60%,0.8)`;
    ctx.lineWidth = 2 + layer * 0.5;
    ctx.beginPath();
    for (let i = 0; i <= segments; i++) {
      let a = i * goldenAngle;
      let r = (i/segments) * orb.size * Math.pow(φ, layer/3);
      let x = Math.cos(a) * r;
      let y = Math.sin(a) * r;
      i===0 ? ctx.moveTo(x,y) : ctx.lineTo(x,y);
    }
    ctx.stroke();
  }
  ctx.restore();

  // Spectrum at bottom
  analyser.getByteFrequencyData(dataArray);
  let barCount = 80;
  let slice = Math.floor(dataArray.length / barCount);
  for (let i = 0; i < barCount; i++) {
    let v = dataArray[i * slice] / 255;
    let h = v * innerHeight * 0.4;
    let hue = i * 360 / barCount + performance.now() / 20;
    ctx.fillStyle = `hsla(${hue},100%,60%,0.8)`;
    ctx.fillRect(i * innerWidth / barCount, innerHeight - h, innerWidth / barCount - 2, h);
  }
}

// ======================== UI UPDATE ========================
function updateUI() {
  document.getElementById('bpm').textContent = bpm.toFixed(1);
  document.getElementById('key').textContent = ['C','D♭','D','E♭','E','F','F♯','G','A♭','A','B♭','B'][Math.floor(performance.now()/10000)%12] + " ∴";
  document.getElementById('voices').textContent = voices.length;
  document.getElementById('stageNum').textContent = stage;
  document.getElementById('gesture').textContent = gesture;

  document.getElementById('energyFill').style.width = Math.min(energy*10,100) + '%';
  document.getElementById('entropyFill').style.width = (entropy*8) + '%';
  document.getElementById('resonanceFill').style.width = (resonance*2) + '%';

  const stages = ["AWAITING","AWAKENING","RESONANCE","ATTRACTOR","ASCENT","PLANETARY","ETERNAL FLOW"];
  document.getElementById('stageDisplay').textContent = stages[stage] || "BEYOND";
}

// Polyfill for Math.clamp if needed
Math.clamp = (min, max, v) => Math.max(min, Math.min(max, v));

// =====================================================================
// SYSTEM ONLINE — AWAIT YOUR FIRST MOVEMENT
// =====================================================================
</script>
</body>
</html>
