<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP - Unified Motion Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
            border: 2px solid rgba(255,255,255,0.3);
            color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 4s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
            50% { transform: scale(1.05); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
        }

        .evolution-space {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active { opacity: 1; }

        .orb {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 40px rgba(255,255,255,0.5);
            pointer-events: none;
            z-index: 10;
        }

        .orb.pulse {
            animation: beat 0.15s ease-out;
        }

        @keyframes beat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,0,0,0.7);
        }

        .orb.processing {
            background: radial-gradient(circle, rgba(100,100,255,0.8) 0%, rgba(0,0,255,0.3) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(0,0,255,0.7);
        }

        .orb.void {
            background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(147,112,219,0.4);
            animation: voidBreathe 3s ease-in-out infinite;
        }

        @keyframes voidBreathe {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                opacity: 0.7; 
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.2); 
                opacity: 1; 
            }
        }

        .ui-corner {
            position: fixed;
            font-size: 11px;
            color: rgba(255,255,255,0.8);
            font-weight: normal;
            letter-spacing: 1px;
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
        }

        .ui-corner.top-left {
            top: 20px;
            left: 20px;
        }

        .ui-corner.bottom-left {
            bottom: 20px;
            left: 20px;
        }

        .ui-corner.top-right {
            top: 20px;
            right: 20px;
        }

        .stage-name {
            font-size: 14px;
            color: rgba(255,255,255,0.9);
            margin-bottom: 8px;
            font-weight: bold;
        }

        .metric {
            margin: 3px 0;
            font-size: 10px;
        }

        .bar {
            width: 80px;
            height: 3px;
            background: rgba(255,255,255,0.2);
            margin: 3px 0;
            border-radius: 2px;
            overflow: hidden;
        }

        .bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4a90e2, #9b59b6);
            width: 0%;
            transition: width 0.3s ease;
            border-radius: 2px;
        }

        .sample-indicator {
            position: fixed;
            bottom: 30px;
            right: 30px;
            font-size: 12px;
            color: rgba(255,255,255,0.6);
            text-transform: uppercase;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.5s ease;
        }

        .sample-indicator.visible { opacity: 1; }

        .instruction {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 14px;
            color: rgba(255,255,255,0.7);
            text-align: center;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 2s ease;
            margin-top: 80px;
        }

        .instruction.show { opacity: 1; }

        .particles {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255,255,255,0.3);
            animation: float 10s linear infinite;
        }

        @keyframes float {
            0% { 
                transform: translateY(100vh) scale(0); 
                opacity: 0; 
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { 
                transform: translateY(-20vh) scale(1.5); 
                opacity: 0; 
            }
        }

        .spectrum-viz {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            pointer-events: none;
            z-index: 3;
        }

        .spectrum-bar {
            position: absolute;
            bottom: 0;
            width: 6px;
            background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
            border-radius: 3px 3px 0 0;
            transition: height 0.1s ease;
        }
    </style>
</head>
<body>
    <div class="start-screen" id="startScreen">
        <div class="start-btn" id="startBtn">AWAKEN</div>
    </div>

    <div class="evolution-space" id="evolutionSpace">
        <div class="orb" id="orb"></div>
        
        <div class="instruction" id="instruction">MOVE TO SAMPLE THE WORLD</div>
        
        <div class="ui-corner top-left">
            <div class="stage-name" id="stageName">SILENCE</div>
            <div class="metric">MODE: <span id="mode">WAITING</span></div>
            <div class="metric">SAMPLES: <span id="sampleCount">0</span></div>
        </div>
        
        <div class="ui-corner bottom-left">
            <div class="metric">MOTION ENERGY</div>
            <div class="bar">
                <div class="bar-fill" id="motionBar"></div>
            </div>
            <div class="metric">EVOLUTION</div>
            <div class="bar">
                <div class="bar-fill" id="evolutionBar"></div>
            </div>
        </div>
        
        <div class="ui-corner top-right">
            <div class="metric">BPM: <span id="bpmDisplay">75</span></div>
            <div class="metric">ACTIVE: <span id="activeDisplay">0</span></div>
        </div>
        
        <div class="spectrum-viz" id="spectrumViz"></div>
    </div>

    <div class="sample-indicator" id="sampleIndicator"></div>

    <script>
        'use strict';

        class UnifiedEngine {
            constructor() {
                // Core
                this.ctx = null;
                this.active = false;
                this.elements = {};
                
                // Motion System (from VoidEngine)
                this.motion = 0;
                this.intensity = 0;
                this.direction = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.lastMotionTime = Date.now();
                this.voidPhase = false;
                this.totalMotion = 0;
                
                // Sampling System
                this.recording = false;
                this.preBuffer = [];
                this.buffer = [];
                this.preBufferIndex = 0;
                this.samples = new Map();
                this.activeSamples = new Map();
                this.sampleQueue = [];
                this.maxSamples = 6;
                
                // Musical System
                this.bpm = 75;
                this.beatMatcher = new BeatMatcher();
                this.seq = { step: 0, swing: 0.15 };
                this.evolution = new Evolution();
                this.nodes = {};
                this.lofi = null;
                
                // Visual System
                this.analyser = null;
                this.dataArray = null;
                this.spectrumBars = [];
                this.stage = 'SILENCE';
                this.currentTheme = 'awakening';
                
                this.init();
            }

            init() {
                ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
                 'stageName', 'mode', 'sampleCount', 'motionBar', 'evolutionBar', 
                 'bpmDisplay', 'activeDisplay', 'spectrumViz', 'sampleIndicator']
                .forEach(id => this.elements[id] = document.getElementById(id));
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotionDetection();
                this.setupSpectrumVisualizer();
            }

            setupSpectrumVisualizer() {
                for (let i = 0; i < 48; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'spectrum-bar';
                    bar.style.left = `${i * 2.08}%`;
                    bar.style.height = '0px';
                    this.elements.spectrumViz.appendChild(bar);
                    this.spectrumBars.push(bar);
                }
            }

            setupMotionDetection() {
                // Device motion
                window.addEventListener('devicemotion', e => {
                    if (!this.active) return;
                    
                    const acc = e.accelerationIncludingGravity;
                    if (!acc || acc.x === null) return;

                    const dx = Math.abs(acc.x - this.lastAccel.x);
                    const dy = Math.abs(acc.y - this.lastAccel.y);
                    const dz = Math.abs(acc.z - this.lastAccel.z);
                    
                    const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;
                    this.updateMotion(newMotion);
                    
                    this.velocity.x += acc.x * 0.015;
                    this.velocity.y += acc.y * 0.015;
                    this.updatePosition();
                    
                    this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
                    this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
                });

                // Mouse fallback
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    const velocityX = (newX - lastMouse.x) / dt * 100;
                    const velocityY = (newY - lastMouse.y) / dt * 100;
                    
                    const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.15;
                    this.updateMotion(mouseMotion);
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
                    
                    lastMouse = { x: newX, y: newY, time: now };
                });
            }

            updateMotion(newMotion) {
                this.motion = this.motion * 0.8 + newMotion * 0.2;
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 150) this.motionHistory.shift();
                
                this.totalMotion += this.motion;
                
                // Track last motion for void state
                if (this.motion > 0.5) {
                    this.lastMotionTime = Date.now();
                    if (this.voidPhase) {
                        this.exitVoidState();
                    }
                }
                
                // Enter void after 8 seconds of no motion
                if (Date.now() - this.lastMotionTime > 8000 && !this.voidPhase && this.active) {
                    this.enterVoidState();
                }
                
                // Calculate motion patterns
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
                
                const variance = this.intensity;
                const recentHistory = this.motionHistory.slice(-40);
                const isRhythmic = recentHistory.filter(m => m > 2.5).length > 20 && variance < 2;
                const isErratic = variance > 2.5 && avgMotion > 2;
                const isSustained = avgMotion > 2.5 && variance < 1.5;
                const isChaotic = variance > 4 && avgMotion > 4;
                
                this.motionPattern = isChaotic ? 'chaotic' : isErratic ? 'erratic' : isRhythmic ? 'rhythmic' : isSustained ? 'sustained' : 'calm';
                
                // Update musical evolution based on motion
                this.updateEvolution();
            }

            updatePosition() {
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;
                
                if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
                if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
                
                this.pos.x = Math.max(5, Math.min(95, this.pos.x));
                this.pos.y = Math.max(5, Math.min(95, this.pos.y));
                
                this.velocity.x *= 0.9;
                this.velocity.y *= 0.9;
            }

            updateEvolution() {
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                
                // Evolve complexity based on motion
                this.evolution.evolve(avgMotion, this.intensity, this.motionPattern);
                
                // Update BPM based on motion and evolution
                let targetBPM = 75 + (avgMotion * 5) + (this.intensity * 3);
                targetBPM += this.evolution.complexity * 10;
                
                if (this.motionPattern === 'rhythmic') targetBPM *= 1.1;
                if (this.motionPattern === 'chaotic') targetBPM *= 1.3;
                
                this.bpm = this.bpm * 0.9 + targetBPM * 0.1;
                this.bpm = Math.max(60, Math.min(140, this.bpm));
                
                // Update stage
                if (this.totalMotion < 100) this.stage = 'AWAKENING';
                else if (this.totalMotion < 300) this.stage = 'EXPLORING';
                else if (this.totalMotion < 600) this.stage = 'BUILDING';
                else if (this.totalMotion < 1000) this.stage = 'FLOWING';
                else this.stage = 'TRANSCENDENT';
            }

            enterVoidState() {
                console.log('ðŸŒŒ Entering void state...');
                this.voidPhase = true;
                this.elements.orb.className = 'orb void';
                this.elements.mode.textContent = 'VOID';
                
                // Fade out active samples gradually
                this.activeSamples.forEach((src, sample) => {
                    const gain = src.gain || src;
                    if (gain && gain.gain) {
                        gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2);
                    }
                });
                
                // Clear queue
                this.sampleQueue = [];
            }

            exitVoidState() {
                console.log('ðŸŒŸ Exiting void state...');
                this.voidPhase = false;
                this.elements.orb.className = 'orb';
                this.elements.mode.textContent = 'ACTIVE';
                
                // Restart evolution
                this.evolution.reset();
            }

            async start() {
                try {
                    // Request permissions if needed
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }

                    this.ctx = new AudioContext({ sampleRate: 44100, latencyHint: 'interactive' });
                    await this.ctx.resume();
                    
                    this.setupAudioChain();
                    await this.setupMicrophone();
                    await this.createInstruments();
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    setTimeout(() => {
                        this.elements.instruction.classList.add('show');
                        setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
                    }, 1000);

                    this.active = true;
                    this.startSequencer();
                    this.startAutoSampler();
                    this.animate();
                    
                    // Key handlers
                    document.onkeydown = e => {
                        if (e.key === ' ') {
                            e.preventDefault();
                            this.toggleRecording();
                        }
                    };
                    
                } catch (e) {
                    console.error('Init error:', e);
                    alert('Failed to initialize. Please try again.');
                }
            }

            setupAudioChain() {
                // Analysis
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 128;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                
                // Master chain
                this.nodes.master = this.ctx.createGain();
                this.nodes.master.gain.value = 0.8;
                
                this.nodes.limiter = this.ctx.createDynamicsCompressor();
                this.nodes.limiter.threshold.value = -3;
                this.nodes.limiter.knee.value = 0;
                this.nodes.limiter.ratio.value = 20;
                this.nodes.limiter.attack.value = 0.001;
                this.nodes.limiter.release.value = 0.01;
                
                // Warmth
                this.nodes.warmth = this.ctx.createBiquadFilter();
                this.nodes.warmth.type = 'lowshelf';
                this.nodes.warmth.frequency.value = 200;
                this.nodes.warmth.gain.value = 3;
                
                // Setup layers
                const layers = {
                    kick: 0.9, bass: 0.8, hat: 0.3, 
                    sample: 0.6, vinyl: 0.1
                };
                
                Object.entries(layers).forEach(([name, vol]) => {
                    this.nodes[name] = this.ctx.createGain();
                    this.nodes[name].gain.value = vol;
                    this.nodes[name].connect(this.nodes.master);
                    this.samples.set(name, []);
                });
                
                // Connect chain
                this.nodes.master.connect(this.nodes.warmth);
                this.nodes.warmth.connect(this.nodes.limiter);
                this.nodes.limiter.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Create LoFi processor
                this.lofi = new LoFi(this.ctx);
            }

            async setupMicrophone() {
                const stream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 44100
                    }
                });
                
                this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                
                // Pre-buffer for instant capture
                this.nodes.preRec = this.ctx.createScriptProcessor(2048, 1, 1);
                this.preBuffer = new Float32Array(this.ctx.sampleRate * 2); // 2 sec rolling buffer
                this.preBufferIndex = 0;
                
                this.nodes.preRec.onaudioprocess = e => {
                    const input = e.inputBuffer.getChannelData(0);
                    
                    // Rolling buffer
                    for (let i = 0; i < input.length; i++) {
                        this.preBuffer[this.preBufferIndex] = input[i];
                        this.preBufferIndex = (this.preBufferIndex + 1) % this.preBuffer.length;
                    }
                    
                    // Active recording
                    if (this.recording) {
                        this.buffer.push(...input);
                        if (this.buffer.length > this.ctx.sampleRate * 4) {
                            this.stopRecording();
                        }
                    }
                };
                
                this.nodes.mic.connect(this.nodes.preRec);
                this.nodes.preRec.connect(this.ctx.destination);
            }

            async createInstruments() {
                const sr = this.ctx.sampleRate;
                
                // Punchy kick
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.pow(1 - t * 2, 3);
                    const pitch = 55 * Math.exp(-35 * t);
                    const click = Math.sin(2 * Math.PI * 1000 * t) * Math.exp(-100 * t) * 0.3;
                    kd[i] = (Math.sin(2 * Math.PI * pitch * t) + click) * env;
                }
                
                // Sub bass
                const bass = this.ctx.createBuffer(1, sr * 1, sr);
                const bd = bass.getChannelData(0);
                for (let i = 0; i < bd.length; i++) {
                    const t = i / sr;
                    const env = t < 0.02 ? t / 0.02 : Math.exp(-2 * (t - 0.02));
                    bd[i] = Math.sin(2 * Math.PI * 40 * t) * env * 0.8;
                }
                
                // Crisp hat
                const hat = this.ctx.createBuffer(1, sr * 0.03, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-200 * t);
                    hd[i] = (Math.random() * 2 - 1) * env * 0.8;
                }
                
                // Vinyl loop
                const vinyl = this.ctx.createBuffer(2, sr * 10, sr);
                for (let ch = 0; ch < 2; ch++) {
                    const vd = vinyl.getChannelData(ch);
                    for (let i = 0; i < vd.length; i++) {
                        vd[i] = (Math.random() - 0.5) * 0.02;
                        if (Math.random() < 0.0001) {
                            vd[i] = (Math.random() - 0.5) * 0.2;
                        }
                    }
                }
                
                // Store samples
                this.samples.get('kick').push({ buffer: kick, rate: 1 });
                this.samples.get('bass').push({ buffer: bass, rate: 1 });
                this.samples.get('hat').push({ buffer: hat, rate: 1 });
                
                // Start vinyl
                const vinylSource = this.ctx.createBufferSource();
                vinylSource.buffer = vinyl;
                vinylSource.loop = true;
                vinylSource.connect(this.nodes.vinyl);
                vinylSource.start();
            }

            toggleRecording() {
                if (this.recording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                // Include pre-buffer for instant capture
                this.buffer = [];
                
                // Add last 0.5 seconds from pre-buffer
                const preCapture = this.ctx.sampleRate * 0.5;
                const startIdx = (this.preBufferIndex - preCapture + this.preBuffer.length) % this.preBuffer.length;
                
                for (let i = 0; i < preCapture; i++) {
                    const idx = (startIdx + i) % this.preBuffer.length;
                    this.buffer.push(this.preBuffer[idx]);
                }
                
                this.recording = true;
                this.elements.orb.classList.add('recording');
                this.showIndicator('RECORDING...');
            }

            stopRecording() {
                this.recording = false;
                this.elements.orb.classList.remove('recording');
                this.elements.orb.classList.add('processing');
                this.showIndicator('PROCESSING...');
                
                // Process immediately
                setTimeout(() => this.processSample(), 10);
            }

            processSample() {
                if (this.buffer.length < this.ctx.sampleRate * 0.2) {
                    this.elements.orb.classList.remove('processing');
                    return;
                }
                
                // Create buffer
                const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                buf.getChannelData(0).set(this.buffer);
                
                // Find transients
                const transients = this.beatMatcher.findTransients(buf);
                
                // Trim silence from start
                const data = buf.getChannelData(0);
                let startIdx = 0;
                for (let i = 0; i < data.length; i++) {
                    if (Math.abs(data[i]) > 0.01) {
                        startIdx = i;
                        break;
                    }
                }
                
                // Create trimmed buffer
                const trimmed = this.ctx.createBuffer(1, data.length - startIdx, this.ctx.sampleRate);
                trimmed.getChannelData(0).set(data.slice(startIdx));
                
                // Queue sample for next beat
                const stretch = this.beatMatcher.quantize(trimmed.duration);
                const pitch = [0.5, 0.667, 1, 1.5, 2][Math.floor(Math.random() * 5)];
                
                this.queueSample({
                    buffer: trimmed,
                    rate: stretch * pitch,
                    transients,
                    evolution: 0
                });
                
                this.elements.orb.classList.remove('processing');
                this.showIndicator('SAMPLE QUEUED');
            }

            queueSample(sample) {
                this.sampleQueue.push(sample);
                
                // Remove oldest if we have too many
                if (this.sampleQueue.length > this.maxSamples) {
                    this.sampleQueue.shift();
                }
            }

            startSequencer() {
                const beatLength = 60 / this.bpm / 4;
                let nextTime = this.ctx.currentTime;
                
                const schedule = () => {
                    const currentTime = this.ctx.currentTime;
                    
                    // Schedule ahead
                    while (nextTime < currentTime + 0.1) {
                        const step = this.seq.step;
                        
                        // Check for queued samples on downbeat
                        if (step % 16 === 0 && this.sampleQueue.length > 0) {
                            const sample = this.sampleQueue.shift();
                            this.addSampleToLoop(sample);
                            this.showIndicator('SAMPLE ADDED TO LOOP');
                        }
                        
                        // Get patterns based on evolution
                        const patterns = this.evolution.getPatterns();
                        
                        // Schedule hits
                        if (patterns.kick[step % 16]) {
                            this.scheduleHit('kick', nextTime, 0.9);
                        }
                        
                        if (patterns.bass[step % 16]) {
                            this.scheduleBass(this.evolution.getBassNote(step), nextTime);
                        }
                        
                        if (patterns.hat[step % 16]) {
                            const velocity = 0.3 + Math.random() * 0.2;
                            this.scheduleHit('hat', nextTime, velocity);
                        }
                        
                        // Visual pulse
                        if (step % 4 === 0) {
                            setTimeout(() => {
                                this.elements.orb.classList.add('pulse');
                                setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                            }, (nextTime - currentTime) * 1000);
                        }
                        
                        this.seq.step = (step + 1) % 32;
                        nextTime += beatLength;
                    }
                    
                    setTimeout(schedule, 25);
                };
                
                schedule();
            }

            addSampleToLoop(sample) {
                const samples = this.samples.get('sample');
                
                // Evolution stages for sample
                sample.evolution = 0;
                
                // Remove oldest active sample if at limit
                if (samples.length >= 4) {
                    const oldest = samples.shift();
                    if (this.activeSamples.has(oldest)) {
                        const src = this.activeSamples.get(oldest);
                        src.stop();
                        this.activeSamples.delete(oldest);
                    }
                }
                
                samples.push(sample);
                
                // Start playing immediately
                this.playSampleLoop(sample);
                
                // Schedule evolution stages
                setTimeout(() => {
                    sample.evolution = 1;
                    this.showIndicator('SAMPLE EVOLVING...');
                }, 8000);
                
                setTimeout(() => {
                    sample.evolution = 2;
                    this.showIndicator('SAMPLE LOCKED IN');
                }, 16000);
            }

            playSampleLoop(sample) {
                if (this.activeSamples.has(sample)) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                
                // Sync loop to beat
                const beatLength = 60 / this.bpm;
                src.loopEnd = Math.min(sample.buffer.duration, beatLength * 4);
                
                // Filter based on evolution
                filter.type = 'lowpass';
                filter.frequency.value = 20000 - (sample.evolution * 5000);
                filter.Q.value = 1 + sample.evolution;
                
                // Gain based on sample count and evolution
                const sampleCount = this.samples.get('sample').length;
                gain.gain.value = 0.6 / Math.sqrt(sampleCount);
                
                // Process through lofi
                const processed = this.lofi.process(src, sample.evolution * 0.3);
                processed.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample);
                
                // Start on next bar
                const nextBar = Math.ceil(this.ctx.currentTime / (beatLength * 4)) * (beatLength * 4);
                src.start(nextBar);
                
                this.activeSamples.set(sample, src);
                
                // Dynamic filter automation
                const automate = () => {
                    if (!this.activeSamples.has(sample)) return;
                    
                    const now = this.ctx.currentTime;
                    const mod = 5000 + Math.sin(now * 0.2) * 3000 * (1 - sample.evolution * 0.3);
                    filter.frequency.linearRampToValueAtTime(mod, now + 0.1);
                    
                    // Sidechain compression effect
                    if (this.seq.step % 4 === 0) {
                        gain.gain.cancelScheduledValues(now);
                        gain.gain.setValueAtTime(gain.gain.value * 0.5, now);
                        gain.gain.linearRampToValueAtTime(0.6 / Math.sqrt(sampleCount), now + 0.1);
                    }
                    
                    requestAnimationFrame(automate);
                };
                automate();
            }

            scheduleHit(type, time, velocity) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                const sample = samples[Math.floor(Math.random() * samples.length)];
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                src.buffer = sample.buffer;
                gain.gain.value = velocity;
                
                src.connect(gain);
                gain.connect(this.nodes[type]);
                
                src.start(time);
            }

            scheduleBass(note, time) {
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                osc.type = 'sine';
                osc.frequency.value = note;
                
                // Sub layer
                const sub = this.ctx.createOscillator();
                sub.type = 'sine';
                sub.frequency.value = note / 2;
                
                // Filter
                filter.type = 'lowpass';
                filter.frequency.value = note * 4;
                filter.Q.value = 3;
                
                // Envelope
                const duration = 60 / this.bpm * 2;
                gain.gain.setValueAtTime(0, time);
                gain.gain.linearRampToValueAtTime(0.6, time + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.3, time + duration * 0.3);
                gain.gain.exponentialRampToValueAtTime(0.01, time + duration);
                
                // Connect
                osc.connect(filter);
                sub.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.bass);
                
                osc.start(time);
                sub.start(time);
                osc.stop(time + duration);
                sub.stop(time + duration);
            }

            startAutoSampler() {
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                let threshold = 0.1;
                
                const detect = () => {
                    if (this.recording || cooldown > 0 || this.voidPhase) {
                        cooldown--;
                        requestAnimationFrame(detect);
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    // Adaptive threshold
                    let sum = 0;
                    let peaks = 0;
                    
                    // Focus on musical frequencies (80Hz - 4kHz)
                    for (let i = 4; i < 200; i++) {
                        sum += data[i];
                        if (data[i] > 150) peaks++;
                    }
                    
                    const avg = sum / 196;
                    threshold = threshold * 0.95 + avg * 0.05;
                    
                    // Detect based on motion state
                    const detectionThreshold = this.motionPattern === 'calm' ? 1.5 : 2;
                    
                    if (peaks > 10 && avg > threshold * detectionThreshold) {
                        console.log('Auto-sampling detected');
                        this.startRecording();
                        cooldown = 150; // 3 second cooldown
                    }
                    
                    requestAnimationFrame(detect);
                };
                
                detect();
            }

            showIndicator(text) {
                this.elements.sampleIndicator.textContent = text;
                this.elements.sampleIndicator.classList.add('visible');
                setTimeout(() => {
                    this.elements.sampleIndicator.classList.remove('visible');
                }, 2000);
            }

            createParticles(count, color) {
                const existing = document.querySelector('.particles');
                if (existing) existing.remove();
                
                const container = document.createElement('div');
                container.className = 'particles';
                document.body.appendChild(container);
                
                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = Math.random() * 10 + 's';
                    particle.style.animationDuration = (8 + Math.random() * 4) + 's';
                    container.appendChild(particle);
                }
            }

            updateUI() {
                // Update text
                this.elements.stageName.textContent = this.voidPhase ? 'VOID' : this.stage;
                this.elements.mode.textContent = this.motionPattern.toUpperCase();
                this.elements.sampleCount.textContent = this.samples.get('sample').length;
                this.elements.bpmDisplay.textContent = Math.round(this.bpm);
                this.elements.activeDisplay.textContent = this.activeSamples.size;
                
                // Update bars
                const motionPercent = Math.min(this.motion * 15, 100);
                this.elements.motionBar.style.width = motionPercent + '%';
                
                const evolutionPercent = (this.evolution.complexity / 3) * 100;
                this.elements.evolutionBar.style.width = evolutionPercent + '%';
                
                // Update spectrum
                if (this.analyser) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    this.spectrumBars.forEach((bar, i) => {
                        const height = (this.dataArray[i] / 255) * 60;
                        bar.style.height = height + 'px';
                        
                        // Color based on frequency and state
                        let hue = 200;
                        if (this.voidPhase) hue = 270;
                        else if (this.stage === 'TRANSCENDENT') hue = (Date.now() / 20 + i * 5) % 360;
                        else if (this.motionPattern === 'chaotic') hue = 0;
                        else if (this.motionPattern === 'rhythmic') hue = 120;
                        
                        const saturation = 50 + (this.dataArray[i] / 255) * 50;
                        bar.style.background = `linear-gradient(0deg, hsla(${hue}, ${saturation}%, 50%, 0.8), hsla(${hue}, ${saturation}%, 70%, 0.2))`;
                    });
                }
            }

            animate() {
                const loop = () => {
                    if (!this.active) return;
                    
                    // Update orb position
                    this.elements.orb.style.left = this.pos.x + '%';
                    this.elements.orb.style.top = this.pos.y + '%';
                    
                    // Update UI
                    if (this.seq.step % 4 === 0) {
                        this.updateUI();
                    }
                    
                    // Dynamic background
                    const intensityNorm = Math.min(this.intensity / 4, 1);
                    const motionNorm = Math.min(this.motion / 6, 1);
                    
                    let bg;
                    if (this.voidPhase) {
                        const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
                        bg = `radial-gradient(circle at 50% 50%, rgba(147, 112, 219, ${0.1 + breathe * 0.1}) 5%, rgba(75, 0, 130, ${0.05 + breathe * 0.05}) 20%, #000000 60%)`;
                    } else if (this.stage === 'TRANSCENDENT') {
                        const hue = (Date.now() / 50) % 360;
                        bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 70%, ${10 + intensityNorm * 20}%) ${5 + motionNorm * 15}%, #000000 80%)`;
                    } else {
                        const r = Math.floor(255 * intensityNorm * 0.3);
                        const g = Math.floor(255 * motionNorm * 0.3);
                        const b = Math.floor(255 * (1 - intensityNorm) * 0.3);
                        bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgb(${r}, ${g}, ${b}) ${5 + motionNorm * 20}%, #000000 70%)`;
                    }
                    
                    document.body.style.background = bg;
                    
                    // Particles based on stage
                    if (this.stage === 'BUILDING' && !document.querySelector('.particles')) {
                        this.createParticles(30, 'rgba(255,255,255,0.3)');
                    } else if (this.stage === 'TRANSCENDENT' && document.querySelectorAll('.particle').length < 50) {
                        this.createParticles(50, 'rgba(147,112,219,0.5)');
                    }
                    
                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
        }

        // Beat Matcher
        class BeatMatcher {
            constructor() {
                this.bpm = 75;
                this.cache = new Map();
            }

            findTransients(buffer) {
                const key = buffer.length;
                if (this.cache.has(key)) return this.cache.get(key);

                const data = buffer.getChannelData(0);
                const transients = [];
                const windowSize = 512;
                let prevEnergy = 0;
                
                for (let i = 0; i < data.length - windowSize; i += windowSize) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += Math.abs(data[i + j]);
                    }
                    energy /= windowSize;
                    
                    if (energy > prevEnergy * 1.5 && energy > 0.05) {
                        transients.push({ 
                            time: i / buffer.sampleRate, 
                            energy,
                            index: i 
                        });
                    }
                    prevEnergy = energy;
                }
                
                this.cache.set(key, transients);
                return transients;
            }

            quantize(duration) {
                const beatLength = 60 / this.bpm;
                const bars = [0.25, 0.5, 1, 2, 4];
                
                for (const bar of bars) {
                    const target = beatLength * bar;
                    if (Math.abs(duration - target) < beatLength * 0.25) {
                        return target / duration;
                    }
                }
                
                return (beatLength * 2) / duration;
            }
        }

        // LoFi Processor
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
                this.setupNodes();
            }

            setupNodes() {
                this.filter = this.ctx.createBiquadFilter();
                this.filter.type = 'lowpass';
                this.filter.frequency.value = 3000;
                this.filter.Q.value = 1;

                this.bitcrusher = this.ctx.createWaveShaper();
                const bits = 6;
                const n = 256;
                const curve = new Float32Array(n);
                const step = 2 / n;
                
                for (let i = 0; i < n; i++) {
                    const x = -1 + step * i;
                    curve[i] = Math.round(x * bits) / bits;
                }
                
                this.bitcrusher.curve = curve;
                this.bitcrusher.oversample = 'none';
            }

            process(source, amount = 1) {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                const dry = this.ctx.createGain();
                const wet = this.ctx.createGain();
                
                dry.gain.value = 1 - amount;
                wet.gain.value = amount;
                
                source.connect(input);
                input.connect(dry);
                input.connect(this.bitcrusher);
                this.bitcrusher.connect(this.filter);
                this.filter.connect(wet);
                
                dry.connect(output);
                wet.connect(output);
                
                return output;
            }
        }

        // Musical Evolution
        class Evolution {
            constructor() {
                this.complexity = 0;
                this.energy = 0.5;
                this.bassNotes = [40, 43, 45, 47, 50, 52]; // E, G, A, B, D, E
                this.patterns = {
                    kick: [
                        [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,0, 0,0,1,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,1, 0,0,1,0, 1,0,0,0, 0,0,1,0],
                        [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0]
                    ],
                    bass: [
                        [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0],
                        [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                        [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
                        [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0]
                    ],
                    hat: [
                        [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                        [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
                        [1,1,1,0, 1,0,1,1, 1,0,1,0, 1,1,1,0],
                        [1,1,1,1, 1,0,1,1, 1,1,1,0, 1,1,1,1]
                    ]
                };
            }

            evolve(avgMotion, intensity, pattern) {
                // Gradual evolution based on motion
                const target = Math.min(3, avgMotion / 2 + intensity / 3);
                this.complexity = this.complexity * 0.95 + target * 0.05;
                
                // Energy oscillation
                this.energy = 0.5 + Math.sin(Date.now() * 0.0001) * 0.3;
                
                // Boost complexity for certain patterns
                if (pattern === 'rhythmic') this.complexity = Math.min(3, this.complexity + 0.1);
                if (pattern === 'chaotic') this.complexity = 3;
            }

            reset() {
                this.complexity = 0;
                this.energy = 0.5;
            }

            getPatterns() {
                const idx = Math.floor(this.complexity);
                return {
                    kick: this.patterns.kick[idx] || this.patterns.kick[0],
                    bass: this.patterns.bass[idx] || this.patterns.bass[0],
                    hat: this.patterns.hat[idx] || this.patterns.hat[0]
                };
            }

            getBassNote(step) {
                const progressions = [
                    [0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3],
                    [0, 0, 2, 2, 1, 1, 3, 3, 0, 0, 2, 2, 4, 4, 3, 3],
                    [0, 0, 4, 4, 2, 2, 1, 1, 0, 0, 3, 3, 2, 2, 1, 1],
                    [0, 2, 0, 3, 1, 3, 1, 4, 0, 2, 0, 5, 1, 3, 1, 2]
                ];
                
                const idx = Math.floor(this.complexity);
                const progression = progressions[idx] || progressions[0];
                return this.bassNotes[progression[step % 16]];
            }
        }

        // Initialize
        new UnifiedEngine();
    </script>
</body>
</html>
