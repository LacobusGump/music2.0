<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #111;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 2s ease;
        }
        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.1) 0%, transparent 70%);
            border: 2px solid rgba(255, 165, 0, 0.3);
            color: #ffa500;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 2s ease-in-out infinite;
            z-index: 100;
        }
        .start-btn:hover {
            border-color: rgba(255, 165, 0, 0.6);
            transform: scale(1.05);
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255, 165, 0, 0.2); }
            50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(255, 165, 0, 0.4); }
        }
        .orb {
            position: absolute;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 165, 0, 0.8) 0%, rgba(255, 165, 0, 0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.2s ease;
            box-shadow: 0 0 30px rgba(255, 165, 0, 0.5);
            opacity: 0;
        }
        .orb.active { opacity: 1; }
        .orb.recording {
            background: radial-gradient(circle, rgba(0, 255, 0, 0.8) 0%, rgba(0, 255, 0, 0.3) 50%, transparent 80%);
            box-shadow: 0 0 40px rgba(0, 255, 0, 0.6);
            animation: recordingPulse 1s ease-in-out infinite;
        }
        @keyframes recordingPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
        .waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            display: flex;
            align-items: flex-end;
            justify-content: center;
            gap: 2px;
            opacity: 0;
            transition: opacity 1s ease;
        }
        .waveform.active { opacity: 1; }
        .wave-bar {
            width: 4px;
            height: 2px;
            background: rgba(255, 165, 0, 0.6);
            transition: height 0.1s ease;
            border-radius: 2px;
        }
        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }
        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(255, 165, 0, 0.4);
            animation: float 8s linear infinite;
        }
        @keyframes float {
            0% { transform: translateY(100vh) scale(0); opacity: 0; }
            10% { opacity: 0.8; }
            90% { opacity: 0.8; }
            100% { transform: translateY(-20vh) scale(1); opacity: 0; }
        }
    </style>
</head>
<body>
    <div id="startBtn" class="start-btn">GUMP</div>
    <div id="orb" class="orb"></div>
    <div id="waveform" class="waveform"></div>
    <div class="particles" id="particles"></div>

    <script>
        class LofiSamplerEngine {
            constructor() {
                this.ctx = null;
                this.active = false;
                this.microphone = null;
                this.analyser = null;
                this.dataArray = null;
                this.recorder = null;
                this.recordBuffer = [];
                this.isRecording = false;
                this.sampleThreshold = 0.05;
                this.samplingCooldown = 1500;
                this.lastSampleTime = 0;
                this.maxRecordTime = 2.5;
                this.samples = [];
                this.layers = { drums: [], bass: [], melody: [], pads: [] };
                this.bpm = 80;
                this.step = 0;
                this.motion = 0;
                this.pos = { x: 50, y: 50 };
                this.motionHistory = [];
                this.vinylNoise = null;
                this.lowpass = null;
                this.crusher = null;
                this.reverb = null;
                this.masterGain = null;
                this.elements = {
                    startBtn: document.getElementById('startBtn'),
                    orb: document.getElementById('orb'),
                    waveform: document.getElementById('waveform'),
                    particles: document.getElementById('particles')
                };
                this.waveBars = [];
                this.init();
            }

            init() {
                this.elements.startBtn.onclick = () => this.start();
                this.createWaveBars(50);
                this.setupMotion();
            }

            createWaveBars(count) {
                for (let i = 0; i < count; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'wave-bar';
                    this.elements.waveform.appendChild(bar);
                    this.waveBars.push(bar);
                }
            }

            setupMotion() {
                let lastMouse = { x: 0, y: 0, time: 0 };
                document.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    const now = Date.now();
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const dt = now - lastMouse.time || 1;
                    const vel = Math.sqrt(dx*dx + dy*dy) / dt;
                    this.motion = this.motion * 0.8 + vel * 0.2;
                    this.motionHistory.push(this.motion);
                    if (this.motionHistory.length > 30) this.motionHistory.shift();
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                    this.pos.x = (e.clientX / window.innerWidth) * 100;
                    this.pos.y = (e.clientY / window.innerHeight) * 100;
                });

                window.addEventListener('devicemotion', e => {
                    if (!this.active || !e.accelerationIncludingGravity) return;
                    const acc = e.accelerationIncludingGravity;
                    const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
                    this.motion = this.motion * 0.8 + mag * 0.02;
                    this.motionHistory.push(this.motion);
                    if (this.motionHistory.length > 30) this.motionHistory.shift();
                });
            }

            async start() {
                try {
                    if (typeof DeviceMotionEvent.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        await DeviceOrientationEvent.requestPermission();
                    }
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: { 
                            echoCancellation: false, 
                            noiseSuppression: false, 
                            autoGainControl: false 
                        } 
                    });
                    this.ctx = new AudioContext();
                    await this.ctx.resume();
                    this.setupAudioNodes();
                    this.setupMicrophone(stream);
                    this.elements.startBtn.style.display = 'none';
                    this.elements.orb.classList.add('active');
                    this.elements.waveform.classList.add('active');
                    this.active = true;
                    this.startLoop();
                    this.startSequencer();
                    this.createVinylNoise();
                } catch (err) {
                    console.error('Startup error:', err);
                }
            }

            setupAudioNodes() {
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.85;
                this.masterGain.connect(this.ctx.destination);

                this.lowpass = this.ctx.createBiquadFilter();
                this.lowpass.type = 'lowpass';
                this.lowpass.frequency.value = 3000;
                this.lowpass.Q.value = 0.5;

                this.crusher = this.ctx.createWaveShaper();
                this.crusher.curve = this.makeCrusherCurve(8);
                this.crusher.oversample = '2x';

                this.reverb = this.ctx.createConvolver();
                this.reverb.buffer = this.createReverbBuffer(2);

                this.lowpass.connect(this.crusher);
                this.crusher.connect(this.reverb);
                this.reverb.connect(this.masterGain);
            }

            makeCrusherCurve(bits) {
                const samples = 1024;
                const curve = new Float32Array(samples);
                const step = 2 / (2 ** bits - 1);
                for (let i = 0; i < samples; i++) {
                    curve[i] = Math.floor((i / samples) / step) * step - 1;
                }
                return curve;
            }

            createReverbBuffer(length) {
                const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * length, this.ctx.sampleRate);
                for (let c = 0; c < 2; c++) {
                    const data = buffer.getChannelData(c);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 3);
                    }
                }
                return buffer;
            }

            createVinylNoise() {
                const bufferSize = this.ctx.sampleRate * 2;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                    data[i] = (Math.random() * 2 - 1) * 0.02;
                }
                const noise = this.ctx.createBufferSource();
                noise.buffer = buffer;
                noise.loop = true;
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1000;
                filter.Q.value = 0.5;
                noise.connect(filter).connect(this.masterGain);
                noise.start();
                this.vinylNoise = noise;
            }

            setupMicrophone(stream) {
                this.microphone = this.ctx.createMediaStreamSource(stream);
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 1024;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                this.microphone.connect(this.analyser);

                this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                this.recorder.onaudioprocess = e => {
                    if (this.isRecording) {
                        this.recordBuffer.push(...e.inputBuffer.getChannelData(0));
                        if (this.recordBuffer.length / this.ctx.sampleRate >= this.maxRecordTime) {
                            this.processSample();
                        }
                    }
                };
            }

            startLoop() {
                const loop = () => {
                    if (!this.active) return;
                    this.analyser.getByteFrequencyData(this.dataArray);
                    this.updateViz();
                    this.checkForSample();
                    this.updateEffects();
                    this.updateBackground();
                    requestAnimationFrame(loop);
                };
                loop();
            }

            updateViz() {
                const avg = this.dataArray.reduce((a, b) => a + b, 0) / this.dataArray.length / 255;
                this.elements.orb.style.transform = `translate(-50%, -50%) scale(${1 + avg * 0.5})`;
                this.waveBars.forEach((bar, i) => {
                    const val = this.dataArray[i * 2] / 255;
                    bar.style.height = `${val * 60}px`;
                });
                if (Math.random() < avg * 0.1) this.createParticles(3 + Math.floor(avg * 5));
            }

            createParticles(count) {
                for (let i = 0; i < count; i++) {
                    const p = document.createElement('div');
                    p.className = 'particle';
                    p.style.left = `${this.pos.x + (Math.random() - 0.5) * 10}%`;
                    p.style.top = `${this.pos.y + (Math.random() - 0.5) * 10}%`;
                    p.style.animationDelay = `${Math.random() * 2}s`;
                    this.elements.particles.appendChild(p);
                    setTimeout(() => p.remove(), 8000);
                }
            }

            checkForSample() {
                const now = Date.now();
                if (now - this.lastSampleTime < this.samplingCooldown || this.isRecording) return;
                const avgLevel = this.dataArray.reduce((a, b) => a + b, 0) / this.dataArray.length / 255;
                if (avgLevel > this.sampleThreshold) {
                    this.isRecording = true;
                    this.recordBuffer = [];
                    this.microphone.connect(this.recorder);
                    this.recorder.connect(this.ctx.destination);
                    this.elements.orb.classList.add('recording');
                    setTimeout(() => this.processSample(), this.maxRecordTime * 1000);
                }
            }

            processSample() {
                this.isRecording = false;
                this.microphone.disconnect(this.recorder);
                this.recorder.disconnect();
                this.elements.orb.classList.remove('recording');
                if (this.recordBuffer.length < this.ctx.sampleRate * 0.5) return;

                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.copyToChannel(Float32Array.from(this.recordBuffer), 0);

                // Lofi processing
                const offline = new OfflineAudioContext(1, buffer.length, this.ctx.sampleRate);
                const source = offline.createBufferSource();
                source.buffer = buffer;

                const lp = offline.createBiquadFilter();
                lp.type = 'lowpass';
                lp.frequency.value = 2500 + Math.random() * 1000;
                lp.Q.value = 0.5;

                const crusher = offline.createWaveShaper();
                crusher.curve = this.makeCrusherCurve(6 + Math.floor(Math.random() * 4));

                const rev = offline.createConvolver();
                rev.buffer = this.createReverbBuffer(1.5);

                source.connect(lp).connect(crusher).connect(rev).connect(offline.destination);
                source.start();

                offline.startRendering().then(processed => {
                    // Pitch detection and auto-tune
                    const pitch = this.detectPitch(processed);
                    const targetPitch = this.snapToLofiScale(pitch);
                    const shift = targetPitch / pitch;

                    const tuned = new OfflineAudioContext(1, processed.length, this.ctx.sampleRate);
                    const tunedSource = tuned.createBufferSource();
                    tunedSource.buffer = processed;
                    tunedSource.playbackRate.value = shift;
                    tunedSource.connect(tuned.destination);
                    tunedSource.start();

                    tuned.startRendering().then(finalBuffer => {
                        const sample = { buffer: finalBuffer, duration: finalBuffer.duration };
                        this.samples.push(sample);
                        this.categorizeSample(sample);
                    });
                });

                this.lastSampleTime = Date.now();
            }

            detectPitch(buffer) {
                const data = buffer.getChannelData(0);
                let maxCorr = 0;
                let bestLag = 0;
                for (let lag = 20; lag < 2000; lag++) {
                    let corr = 0;
                    for (let i = 0; i < data.length - lag; i++) {
                        corr += data[i] * data[i + lag];
                    }
                    if (corr > maxCorr) {
                        maxCorr = corr;
                        bestLag = lag;
                    }
                }
                return this.ctx.sampleRate / bestLag;
            }

            snapToLofiScale(pitch) {
                const notes = [130.81, 146.83, 164.81, 174.61, 196.00, 220.00, 246.94, 261.63]; // C3 to C4 minor pentatonic-ish for lofi
                return notes.reduce((prev, curr) => Math.abs(curr - pitch) < Math.abs(prev - pitch) ? curr : prev);
            }

            categorizeSample(sample) {
                const offline = new OfflineAudioContext(1, sample.buffer.length, this.ctx.sampleRate);
                const analyser = offline.createAnalyser();
                analyser.fftSize = 2048;
                const source = offline.createBufferSource();
                source.buffer = sample.buffer;
                source.connect(analyser).connect(offline.destination);
                source.start();
                offline.startRendering().then(() => {
                    const freqData = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(freqData);
                    const low = freqData.slice(0, 50).reduce((a,b)=>a+b,0)/50;
                    const mid = freqData.slice(50, 200).reduce((a,b)=>a+b,0)/150;
                    const high = freqData.slice(200).reduce((a,b)=>a+b,0)/ (freqData.length - 200);

                    if (low > mid && low > high) this.layers.bass.push(sample);
                    else if (high > mid && high > low) this.layers.drums.push(sample);
                    else if (mid > low && mid > high) this.layers.melody.push(sample);
                    else this.layers.pads.push(sample);
                });
            }

            startSequencer() {
                const beatDuration = () => 60 / this.bpm / 4 * 1000;
                const sequencer = () => {
                    if (!this.active) return;
                    this.playBeat();
                    setTimeout(sequencer, beatDuration());
                };
                sequencer();
            }

            playBeat() {
                this.step = (this.step + 1) % 16;
                const avgMotion = this.motionHistory.reduce((a,b)=>a+b,0)/this.motionHistory.length || 0;
                this.bpm = 70 + avgMotion * 10;

                // Drums on 1 and 3, hats on offbeats
                if (this.layers.drums.length > 0) {
                    if (this.step % 8 === 0) this.playProcessedSample(this.getRandomSample(this.layers.drums), 0.8, 0.9); // Kick-ish
                    if (this.step % 8 === 4) this.playProcessedSample(this.getRandomSample(this.layers.drums), 0.7, 1.1); // Snare-ish
                    if (this.step % 2 === 1) this.playProcessedSample(this.getRandomSample(this.layers.drums), 0.4, 1.5); // Hat-ish
                }

                // Bass on every beat, short
                if (this.layers.bass.length > 0 && this.step % 4 === 0) {
                    this.playProcessedSample(this.getRandomSample(this.layers.bass), 0.9, 0.8, 0.3);
                }

                // Melody occasional
                if (this.layers.melody.length > 0 && Math.random() < 0.3) {
                    this.playProcessedSample(this.getRandomSample(this.layers.melody), 0.6, 1 + (Math.random() - 0.5)*0.2, 1 + Math.random());
                }

                // Pads sustained
                if (this.layers.pads.length > 0 && this.step % 16 === 0) {
                    this.playProcessedSample(this.getRandomSample(this.layers.pads), 0.5, 0.8 + Math.random()*0.4, 4 + Math.random()*4);
                }
            }

            getRandomSample(layer) {
                return layer[Math.floor(Math.random() * layer.length)] || {buffer: new AudioBuffer({length:1, sampleRate: this.ctx.sampleRate})};
            }

            playProcessedSample(sample, vol, rate = 1, dur = sample.duration) {
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                source.playbackRate.value = rate;
                const gain = this.ctx.createGain();
                gain.gain.value = vol;
                source.connect(gain).connect(this.lowpass);
                source.start(0, Math.random() * (sample.duration - dur), dur);
            }

            updateEffects() {
                const avgMotion = this.motionHistory.reduce((a,b)=>a+b,0)/this.motionHistory.length || 0;
                this.lowpass.frequency.value = 2000 + avgMotion * 1000;
                this.masterGain.gain.value = 0.85 - avgMotion * 0.1;
            }

            updateBackground() {
                const intensity = Math.min(this.motion / 5, 1);
                document.body.style.background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255, 165, 0, ${0.2 + intensity * 0.3}) 10%, #111 50%)`;
            }
        }

        new LofiSamplerEngine();
    </script>
</body>
</html>
