<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP SUPREME</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
            font-family: -apple-system, BlinkMacSystemFont, sans-serif;
        }

        #orb {
            position: fixed;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle at 30% 30%, rgba(255,255,255,1), rgba(255,255,255,0.2));
            box-shadow: 0 0 120px rgba(255,255,255,0.8), 
                        0 0 60px rgba(255,255,255,0.6),
                        inset -10px -10px 20px rgba(0,0,0,0.3);
            transition: all 0.15s ease-out;
            z-index: 1000;
            pointer-events: none;
        }

        #orb.recording {
            background: radial-gradient(circle at 30% 30%, #ff0000, #660000);
            box-shadow: 0 0 150px #ff0000, 
                        0 0 80px #ff0000,
                        inset -10px -10px 20px rgba(0,0,0,0.5);
            transform: scale(1.2);
        }

        #orb.beat {
            transform: scale(1.3);
            box-shadow: 0 0 200px rgba(255,255,255,1), 
                        0 0 100px rgba(255,255,255,0.8);
        }

        #orb.god-mode {
            background: radial-gradient(circle at 30% 30%, #ff00ff, #00ffff);
            animation: godPulse 2s ease-in-out infinite;
        }

        @keyframes godPulse {
            0%, 100% { transform: scale(1) rotate(0deg); filter: hue-rotate(0deg); }
            50% { transform: scale(1.5) rotate(180deg); filter: hue-rotate(180deg); }
        }

        .status {
            position: fixed;
            top: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
            text-transform: uppercase;
            text-align: center;
        }

        .status.visible {
            opacity: 0.7;
        }

        .hint {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 11px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 2s;
            text-transform: uppercase;
            text-align: center;
            max-width: 80%;
        }

        .hint.visible {
            opacity: 0.5;
        }

        .producer-status {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 10px;
            letter-spacing: 2px;
            opacity: 0;
            transition: opacity 0.5s;
            text-transform: uppercase;
            color: #ff00ff;
        }

        .producer-status.visible {
            opacity: 0.6;
        }

        .visualizer {
            position: fixed;
            inset: 0;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s;
        }

        .visualizer.active {
            opacity: 1;
        }

        .pattern-grid {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(16, 20px);
            gap: 2px;
            opacity: 0;
            transition: opacity 0.5s;
        }

        .pattern-grid.visible {
            opacity: 0.6;
        }

        .pattern-step {
            width: 20px;
            height: 20px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            transition: all 0.1s;
        }

        .pattern-step.active {
            background: rgba(255,255,255,0.8);
            box-shadow: 0 0 10px rgba(255,255,255,0.8);
        }

        .pattern-step.current {
            background: rgba(255,0,255,0.6);
        }

        .ai-personality {
            position: fixed;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            letter-spacing: 4px;
            opacity: 0;
            transition: all 0.5s;
            text-transform: uppercase;
            font-weight: bold;
        }

        .ai-personality.visible {
            opacity: 0.8;
        }

        .waveform {
            position: fixed;
            top: 50%;
            left: 0;
            right: 0;
            height: 100px;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.5s;
            pointer-events: none;
        }

        .waveform.visible {
            opacity: 0.3;
        }

        .controls-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            font-size: 9px;
            letter-spacing: 1px;
            opacity: 0.3;
            text-align: right;
            line-height: 1.5;
        }

        .effect-pad {
            position: fixed;
            width: 200px;
            height: 200px;
            bottom: 150px;
            right: 50px;
            background: radial-gradient(circle at center, rgba(255,255,255,0.1), transparent);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 10px;
            opacity: 0;
            transition: opacity 0.5s;
            cursor: crosshair;
        }

        .effect-pad.visible {
            opacity: 0.6;
        }

        .effect-dot {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #fff;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 20px #fff;
        }
    </style>
</head>
<body>
    <canvas id="visualizer" class="visualizer"></canvas>
    <canvas id="waveform" class="waveform"></canvas>
    <div id="orb"></div>
    <div id="status" class="status"></div>
    <div id="producer-status" class="producer-status"></div>
    <div id="ai-personality" class="ai-personality"></div>
    <div id="hint" class="hint">Click anywhere to begin</div>
    <div id="pattern-grid" class="pattern-grid"></div>
    <div id="effect-pad" class="effect-pad">
        <div id="effect-dot" class="effect-dot"></div>
    </div>
    <div class="controls-hint">
        SPACE: Sample<br>
        G: God Mode<br>
        1-5: AI Personality<br>
        P: Pattern Mode<br>
        X: Effects Pad<br>
        R: Reverse<br>
        T: Tap Tempo<br>
        S: Stutter<br>
        Hold SPACE: Clear
    </div>

    <script>
        'use strict';

        // GUMP SUPREME - The ultimate beat experience
        class GUMP {
            constructor() {
                this.ctx = null;
                this.isInitialized = false;
                this.isRecording = false;
                this.recordBuffer = [];
                this.samples = new Map();
                this.loops = [];
                
                // Tempo and timing
                this.bpm = 72;
                this.swing = 0.15;
                this.currentStep = 0;
                this.barCount = 0;
                this.tapTimes = [];
                
                // Visual elements
                this.orb = document.getElementById('orb');
                this.status = document.getElementById('status');
                this.producerStatus = document.getElementById('producer-status');
                this.aiPersonality = document.getElementById('ai-personality');
                this.hint = document.getElementById('hint');
                this.patternGrid = document.getElementById('pattern-grid');
                this.effectPad = document.getElementById('effect-pad');
                this.effectDot = document.getElementById('effect-dot');
                
                // Producer AI state with personalities
                this.producer = {
                    energy: 0,
                    complexity: 0,
                    evolution: 0,
                    mood: 'building',
                    godMode: false,
                    personality: 'kanye', // kanye, dilla, flylo, arca, sophie
                    decisions: [],
                    memory: [], // AI learns from patterns
                    structurePosition: 0, // song structure tracking
                    intensity: 0
                };
                
                // Pattern sequencer
                this.patternMode = false;
                this.customPattern = this.initializeEmptyPattern();
                
                // Effects state
                this.effectPadVisible = false;
                this.effectX = 0.5;
                this.effectY = 0.5;
                this.stutterActive = false;
                this.reverseMode = false;
                
                // Performance features
                this.sidechain = {
                    active: false,
                    amount: 0
                };
                
                // Initialize pattern grid
                this.initializePatternGrid();
                
                // Track mouse
                document.addEventListener('mousemove', (e) => {
                    this.orb.style.left = e.clientX + 'px';
                    this.orb.style.top = e.clientY + 'px';
                });
                
                // Init on click
                document.addEventListener('click', (e) => {
                    if (!this.isInitialized) {
                        this.init();
                    }
                });
                
                // Show hint
                setTimeout(() => this.hint.classList.add('visible'), 500);
            }

            async init() {
                try {
                    // Create audio context with optimal settings
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });

                    // Build the complete signal chain
                    this.buildMasterChain();
                    
                    // Create expanded drum kit
                    this.createDrumKit();
                    
                    // Setup microphone
                    await this.setupMicrophone();
                    
                    // Initialize visualizers
                    this.initVisualizer();
                    this.initWaveform();
                    
                    // Create the intro sequence
                    this.scheduleIntro();
                    
                    // Setup all controls
                    this.setupControls();
                    
                    // Start the producer AI
                    this.startProducerAI();
                    
                    this.isInitialized = true;
                    this.hint.innerHTML = 'SPACE to sample • G for god mode • 1-5 for AI personality<br>P for patterns • X for effects • More in bottom right';
                    
                    console.log('GUMP SUPREME initialized - prepare for the experience');

                } catch (err) {
                    console.error('Failed to initialize:', err);
                    this.status.textContent = 'Failed to initialize';
                    this.status.classList.add('visible');
                }
            }

            buildMasterChain() {
                // Master gain
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.95;

                // Multi-band compressor simulation
                this.lowComp = this.ctx.createDynamicsCompressor();
                this.lowComp.threshold.value = -10;
                this.lowComp.ratio.value = 4;
                
                this.midComp = this.ctx.createDynamicsCompressor();
                this.midComp.threshold.value = -12;
                this.midComp.ratio.value = 3;
                
                this.highComp = this.ctx.createDynamicsCompressor();
                this.highComp.threshold.value = -15;
                this.highComp.ratio.value = 2;

                // Bus compressor for glue
                this.busComp = this.ctx.createDynamicsCompressor();
                this.busComp.threshold.value = -8;
                this.busComp.knee.value = 3;
                this.busComp.ratio.value = 4;
                this.busComp.attack.value = 0.01;
                this.busComp.release.value = 0.1;

                // EQ section
                this.lowShelf = this.ctx.createBiquadFilter();
                this.lowShelf.type = 'lowshelf';
                this.lowShelf.frequency.value = 150;
                this.lowShelf.gain.value = 4;

                this.midEQ = this.ctx.createBiquadFilter();
                this.midEQ.type = 'peaking';
                this.midEQ.frequency.value = 2000;
                this.midEQ.Q.value = 0.7;
                this.midEQ.gain.value = 2;

                this.highShelf = this.ctx.createBiquadFilter();
                this.highShelf.type = 'highshelf';
                this.highShelf.frequency.value = 8000;
                this.highShelf.gain.value = 3;

                // Soft clipper using waveshaper
                this.clipper = this.ctx.createWaveShaper();
                this.clipper.curve = this.makeSoftClipCurve();
                this.clipper.oversample = '4x';

                // Final limiter
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -0.5;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                // Connect master chain
                this.master.connect(this.busComp);
                this.busComp.connect(this.lowShelf);
                this.lowShelf.connect(this.midEQ);
                this.midEQ.connect(this.highShelf);
                this.highShelf.connect(this.clipper);
                this.clipper.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);

                // Create buses with advanced processing
                this.createDrumBus();
                this.createSampleBus();
                this.createSendEffects();

                // Analyzers
                this.analyzer = this.ctx.createAnalyser();
                this.analyzer.fftSize = 4096;
                this.analyzer.smoothingTimeConstant = 0.85;
                this.limiter.connect(this.analyzer);

                this.waveformAnalyzer = this.ctx.createAnalyser();
                this.waveformAnalyzer.fftSize = 2048;
                this.master.connect(this.waveformAnalyzer);
            }

            createDrumBus() {
                this.drumBus = this.ctx.createGain();
                this.drumBus.gain.value = 1;
                
                // Drum compression
                this.drumComp = this.ctx.createDynamicsCompressor();
                this.drumComp.threshold.value = -6;
                this.drumComp.ratio.value = 6;
                this.drumComp.attack.value = 0.003;
                this.drumComp.release.value = 0.1;
                
                // Drum saturation
                this.drumSaturator = this.ctx.createWaveShaper();
                this.drumSaturator.curve = this.makeDistortionCurve(20);
                
                // Drum filter
                this.drumFilter = this.ctx.createBiquadFilter();
                this.drumFilter.frequency.value = 20000;
                
                // Sidechain compression simulation
                this.sidechainGain = this.ctx.createGain();
                this.sidechainGain.gain.value = 1;
                
                // Connect drum chain
                this.drumBus.connect(this.drumComp);
                this.drumComp.connect(this.drumSaturator);
                this.drumSaturator.connect(this.drumFilter);
                this.drumFilter.connect(this.sidechainGain);
                this.sidechainGain.connect(this.master);
            }

            createSampleBus() {
                this.sampleBus = this.ctx.createGain();
                this.sampleBus.gain.value = 0.8;
                
                // Sample processing chain
                this.sampleFilter = this.ctx.createBiquadFilter();
                this.sampleFilter.frequency.value = 5000;
                this.sampleFilter.Q.value = 1;
                
                // Bit crusher simulation
                this.bitCrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                this.bitDepth = 16;
                this.sampleRateReduction = 1;
                
                this.bitCrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    const bits = this.bitDepth;
                    const max = Math.pow(2, bits) - 1;
                    
                    for (let i = 0; i < input.length; i += this.sampleRateReduction) {
                        // Bit reduction
                        let sample = input[i];
                        sample = Math.round(sample * max) / max;
                        
                        // Sample rate reduction
                        for (let j = 0; j < this.sampleRateReduction && i + j < output.length; j++) {
                            output[i + j] = sample;
                        }
                    }
                };
                
                // Granular processor
                this.granularGain = this.ctx.createGain();
                this.granularGain.gain.value = 0;
                
                // Connect sample chain
                this.sampleBus.connect(this.sampleFilter);
                this.sampleFilter.connect(this.bitCrusher);
                this.bitCrusher.connect(this.sidechainGain);
                this.bitCrusher.connect(this.granularGain);
                this.granularGain.connect(this.master);
            }

            createSendEffects() {
                // Send 1: Lush Reverb
                this.reverbSend = this.ctx.createGain();
                this.reverbSend.gain.value = 0.3;
                this.lushReverb = this.createAdvancedReverb(2, 0.8);
                this.reverbSend.connect(this.lushReverb.input);
                this.lushReverb.output.connect(this.master);
                
                // Send 2: Ping-pong Delay
                this.delaySend = this.ctx.createGain();
                this.delaySend.gain.value = 0.2;
                this.pingPongDelay = this.createPingPongDelay(0.375, 0.6);
                this.delaySend.connect(this.pingPongDelay.input);
                this.pingPongDelay.output.connect(this.master);
                
                // Send 3: Chorus/Flanger
                this.chorusSend = this.ctx.createGain();
                this.chorusSend.gain.value = 0;
                this.chorus = this.createChorus();
                this.chorusSend.connect(this.chorus.input);
                this.chorus.output.connect(this.master);
                
                // Send 4: Distortion
                this.distortionSend = this.ctx.createGain();
                this.distortionSend.gain.value = 0;
                this.heavyDistortion = this.ctx.createWaveShaper();
                this.heavyDistortion.curve = this.makeDistortionCurve(100);
                this.distortionSend.connect(this.heavyDistortion);
                this.heavyDistortion.connect(this.master);
            }

            createAdvancedReverb(seconds, decay) {
                const length = this.ctx.sampleRate * seconds;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        // More complex reverb algorithm
                        const n = length - i;
                        channelData[i] = (Math.random() * 2 - 1) * 
                                       Math.pow(1 - i / length, decay) *
                                       (1 + Math.sin(i * 0.0001) * 0.2); // Modulation
                    }
                }
                
                const convolver = this.ctx.createConvolver();
                convolver.buffer = impulse;
                
                const input = this.ctx.createGain();
                const wet = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                // Pre-delay
                const preDelay = this.ctx.createDelay(0.1);
                preDelay.delayTime.value = 0.03;
                
                // EQ the reverb
                const reverbHighCut = this.ctx.createBiquadFilter();
                reverbHighCut.type = 'lowpass';
                reverbHighCut.frequency.value = 8000;
                
                wet.gain.value = 0.7;
                
                input.connect(preDelay);
                preDelay.connect(convolver);
                convolver.connect(reverbHighCut);
                reverbHighCut.connect(wet);
                wet.connect(output);
                
                return { input, output };
            }

            createPingPongDelay(time, feedback) {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                const merger = this.ctx.createChannelMerger(2);
                const splitter = this.ctx.createChannelSplitter(2);
                
                // Left and right delays
                const delayL = this.ctx.createDelay(2);
                const delayR = this.ctx.createDelay(2);
                delayL.delayTime.value = time;
                delayR.delayTime.value = time * 1.5;
                
                // Feedback paths
                const feedbackL = this.ctx.createGain();
                const feedbackR = this.ctx.createGain();
                feedbackL.gain.value = feedback;
                feedbackR.gain.value = feedback;
                
                // Filters in feedback path
                const filterL = this.ctx.createBiquadFilter();
                const filterR = this.ctx.createBiquadFilter();
                filterL.frequency.value = 3000;
                filterR.frequency.value = 3000;
                
                // Connect ping-pong network
                input.connect(splitter);
                splitter.connect(delayL, 0);
                splitter.connect(delayR, 1);
                
                delayL.connect(filterL);
                filterL.connect(feedbackL);
                feedbackL.connect(delayR);
                
                delayR.connect(filterR);
                filterR.connect(feedbackR);
                feedbackR.connect(delayL);
                
                delayL.connect(merger, 0, 0);
                delayR.connect(merger, 0, 1);
                merger.connect(output);
                
                return { input, output };
            }

            createChorus() {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                
                // Multiple delay lines for chorus
                const delays = [];
                const lfos = [];
                const depths = [0.002, 0.003, 0.004];
                const rates = [0.5, 0.7, 0.9];
                
                for (let i = 0; i < 3; i++) {
                    const delay = this.ctx.createDelay(0.1);
                    delay.delayTime.value = 0.02;
                    
                    const lfo = this.ctx.createOscillator();
                    lfo.frequency.value = rates[i];
                    
                    const lfoGain = this.ctx.createGain();
                    lfoGain.gain.value = depths[i];
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(delay.delayTime);
                    lfo.start();
                    
                    input.connect(delay);
                    delay.connect(output);
                    
                    delays.push(delay);
                    lfos.push(lfo);
                }
                
                // Dry signal
                input.connect(output);
                
                return { input, output };
            }

            makeSoftClipCurve() {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    // More aggressive soft clipping
                    curve[i] = Math.sign(x) * Math.tanh(Math.abs(x) * 2) * 0.95;
                }
                
                return curve;
            }

            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                const deg = Math.PI / 180;
                
                for (let i = 0; i < samples; i++) {
                    const x = (i / samples) * 2 - 1;
                    curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
                }
                
                return curve;
            }

            createDrumKit() {
                // Expanded drum kit
                this.drums = {
                    kick: this.synthesizeKick(),
                    kick808: this.synthesize808(),
                    snare: this.synthesizeSnare(),
                    rimshot: this.synthesizeRimshot(),
                    hihat: this.synthesizeHihat(),
                    openhat: this.synthesizeOpenHat(),
                    clap: this.synthesizeClap(),
                    perc: this.synthesizePerc(),
                    conga: this.synthesizeConga(),
                    cowbell: this.synthesizeCowbell(),
                    crash: this.synthesizeCrash(),
                    ride: this.synthesizeRide()
                };
            }

            synthesizeKick() {
                const duration = 0.8;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Pitch envelope: starts at 120Hz, drops to 45Hz
                    const pitch = 120 * Math.exp(-35 * t) + 45;
                    
                    // Amplitude envelope with punch
                    const amp = Math.exp(-3 * t) * (1 - 0.5 * t);
                    
                    // Main tone
                    let sample = Math.sin(2 * Math.PI * pitch * t) * amp;
                    
                    // Add click for punch (first 5ms)
                    if (t < 0.005) {
                        sample += Math.sin(2 * Math.PI * 4000 * t) * (1 - t * 200) * 0.3;
                    }
                    
                    // Add harmonics for beef
                    sample += Math.sin(4 * Math.PI * pitch * t) * amp * 0.15;
                    sample += Math.sin(8 * Math.PI * pitch * t) * amp * 0.05;
                    
                    // Soft clip
                    data[i] = Math.tanh(sample * 1.5) * 0.9;
                }
                
                return buffer;
            }

            synthesize808() {
                const duration = 2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Long decay 808
                    const pitch = 55 * Math.exp(-8 * t) + 35;
                    const amp = Math.exp(-0.5 * t);
                    
                    // Pure sine for that 808 sound
                    let sample = Math.sin(2 * Math.PI * pitch * t) * amp;
                    
                    // Slight saturation
                    sample = Math.tanh(sample * 2) * 0.8;
                    
                    data[i] = sample;
                }
                
                return buffer;
            }

            synthesizeSnare() {
                const duration = 0.25;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Layer 1: Pitched tone (body)
                const toneFreq1 = 200;
                const toneFreq2 = 340;
                
                // Layer 2: Noise burst
                let previousNoise = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    
                    // Envelopes
                    const toneEnv = Math.exp(-20 * t) * (1 - t * 2);
                    const noiseEnv = Math.exp(-30 * t);
                    const clickEnv = t < 0.003 ? (1 - t * 333) : 0;
                    
                    // Tone component - two detuned sine waves
                    const tone1 = Math.sin(2 * Math.PI * toneFreq1 * t);
                    const tone2 = Math.sin(2 * Math.PI * toneFreq2 * t);
                    const toneComponent = (tone1 + tone2 * 0.8) * toneEnv * 0.4;
                    
                    // Noise component with high-pass filtering
                    const whiteNoise = Math.random() * 2 - 1;
                    const highpassedNoise = whiteNoise - previousNoise * 0.95;
                    previousNoise = whiteNoise;
                    const noiseComponent = highpassedNoise * noiseEnv * 0.6;
                    
                    // Click/attack transient
                    const click = Math.sin(2 * Math.PI * 3500 * t + Math.sin(8000 * t)) * clickEnv * 0.5;
                    
                    // Mix all components
                    let sample = toneComponent + noiseComponent + click;
                    
                    // Add subtle ring modulation for character
                    sample *= (1 + 0.3 * Math.sin(2 * Math.PI * 1700 * t));
                    
                    // Soft saturation
                    data[i] = Math.tanh(sample * 1.2) * 0.85;
                }
                
                return buffer;
            }

            synthesizeRimshot() {
                const duration = 0.1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-100 * t);
                    
                    // Multiple tones for metallic sound
                    let sample = Math.sin(2 * Math.PI * 800 * t) * 0.5;
                    sample += Math.sin(2 * Math.PI * 1200 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * 1600 * t) * 0.2;
                    
                    // Add click
                    if (t < 0.002) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 500);
                    }
                    
                    data[i] = sample * env * 0.7;
                }
                
                return buffer;
            }

            synthesizeHihat() {
                const duration = 0.05;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                let previousSample = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-200 * t);
                    
                    // Metallic noise
                    let sample = (Math.random() * 2 - 1);
                    
                    // Add some high frequencies
                    sample += Math.sin(2 * Math.PI * 8000 * t) * 0.1;
                    sample += Math.sin(2 * Math.PI * 12000 * t) * 0.05;
                    
                    // High-pass filter
                    const filtered = sample - previousSample * 0.95;
                    previousSample = sample;
                    
                    data[i] = filtered * env * 0.8;
                }
                
                return buffer;
            }

            synthesizeOpenHat() {
                const duration = 0.3;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                let previousSample = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-6 * t);
                    
                    // Metallic noise
                    let sample = (Math.random() * 2 - 1);
                    
                    // Add ringing frequencies
                    sample += Math.sin(2 * Math.PI * 5000 * t) * 0.15;
                    sample += Math.sin(2 * Math.PI * 7500 * t) * 0.1;
                    sample += Math.sin(2 * Math.PI * 10000 * t) * 0.05;
                    
                    // High-pass
                    const filtered = sample - previousSample * 0.9;
                    previousSample = sample;
                    
                    data[i] = filtered * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeClap() {
                const duration = 0.15;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                // Multiple short bursts
                const clapTimes = [0, 0.01, 0.025, 0.03];
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    let sample = 0;
                    
                    for (const clapTime of clapTimes) {
                        if (t >= clapTime && t < clapTime + 0.02) {
                            const localT = t - clapTime;
                            const env = Math.exp(-100 * localT);
                            sample += (Math.random() * 2 - 1) * env * (0.7 + Math.random() * 0.3);
                        }
                    }
                    
                    data[i] = sample * 0.7;
                }
                
                return buffer;
            }

            synthesizePerc() {
                const duration = 0.1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-50 * t);
                    
                    // Wood block sound with vibrato
                    const vibrato = Math.sin(2 * Math.PI * 20 * t) * 200;
                    const freq = 800 + vibrato;
                    let sample = Math.sin(2 * Math.PI * freq * t);
                    
                    // Add harmonics
                    sample += Math.sin(2 * Math.PI * freq * 2 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * freq * 3 * t) * 0.1;
                    
                    // Add click
                    if (t < 0.002) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 500);
                    }
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeConga() {
                const duration = 0.2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-15 * t);
                    
                    // Conga frequencies
                    let sample = Math.sin(2 * Math.PI * 220 * t) * 0.6;
                    sample += Math.sin(2 * Math.PI * 330 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * 440 * t) * 0.1;
                    
                    // Add slap
                    if (t < 0.005) {
                        sample += (Math.random() * 2 - 1) * (1 - t * 200) * 0.5;
                    }
                    
                    data[i] = sample * env * 0.8;
                }
                
                return buffer;
            }

            synthesizeCowbell() {
                const duration = 0.3;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-10 * t);
                    
                    // Cowbell frequencies (inharmonic)
                    let sample = Math.sin(2 * Math.PI * 560 * t) * 0.5;
                    sample += Math.sin(2 * Math.PI * 845 * t) * 0.5;
                    
                    // Add metallic character
                    sample *= (1 + 0.5 * Math.sin(2 * Math.PI * 40 * t));
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            synthesizeCrash() {
                const duration = 2;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-1.5 * t);
                    
                    // Complex metallic sound
                    let sample = 0;
                    
                    // Multiple inharmonic partials
                    const freqs = [523, 787, 1046, 1319, 1568, 1976, 2349, 2794];
                    freqs.forEach((freq, index) => {
                        sample += Math.sin(2 * Math.PI * freq * t) * (1 / (index + 1));
                    });
                    
                    // Add noise
                    sample += (Math.random() * 2 - 1) * 0.3;
                    
                    // Ring modulation
                    sample *= (1 + 0.5 * Math.sin(2 * Math.PI * 70 * t));
                    
                    data[i] = sample * env * 0.5;
                }
                
                return buffer;
            }

            synthesizeRide() {
                const duration = 1;
                const buffer = this.ctx.createBuffer(1, duration * this.ctx.sampleRate, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    const t = i / this.ctx.sampleRate;
                    const env = Math.exp(-3 * t);
                    
                    // Ride bell tone
                    let sample = Math.sin(2 * Math.PI * 2000 * t) * 0.3;
                    sample += Math.sin(2 * Math.PI * 3000 * t) * 0.2;
                    sample += Math.sin(2 * Math.PI * 4500 * t) * 0.1;
                    
                    // Add shimmer
                    sample += (Math.random() * 2 - 1) * 0.1;
                    
                    data[i] = sample * env * 0.6;
                }
                
                return buffer;
            }

            async setupMicrophone() {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    this.micSource = this.ctx.createMediaStreamSource(stream);
                    
                    // Create a script processor for recording
                    this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                    this.recorder.onaudioprocess = (e) => {
                        if (this.isRecording) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            this.recordBuffer.push(...inputData);
                            
                            // Auto-stop after 8 seconds
                            if (this.recordBuffer.length > this.ctx.sampleRate * 8) {
                                this.stopRecording();
                            }
                        }
                    };
                    
                } catch (err) {
                    console.log('Microphone not available');
                    this.hint.textContent = 'Click to play (no mic access)';
                }
            }

            initializeEmptyPattern() {
                return {
                    kick: [],
                    kick808: [],
                    snare: [],
                    rimshot: [],
                    hihat: [],
                    openhat: [],
                    clap: [],
                    perc: [],
                    conga: [],
                    cowbell: []
                };
            }

            initializePatternGrid() {
                // Create 16 step grid
                for (let i = 0; i < 16; i++) {
                    const step = document.createElement('div');
                    step.className = 'pattern-step';
                    step.dataset.step = i;
                    
                    step.addEventListener('click', (e) => {
                        if (this.patternMode) {
                            e.stopPropagation();
                            this.togglePatternStep(i);
                        }
                    });
                    
                    this.patternGrid.appendChild(step);
                }
            }

            togglePatternStep(step) {
                // Toggle kick pattern for now (could be expanded)
                const index = this.customPattern.kick.indexOf(step);
                if (index > -1) {
                    this.customPattern.kick.splice(index, 1);
                } else {
                    this.customPattern.kick.push(step);
                }
                
                // Update visual
                this.updatePatternGrid();
            }

            updatePatternGrid() {
                const steps = this.patternGrid.querySelectorAll('.pattern-step');
                steps.forEach((stepEl, i) => {
                    stepEl.classList.toggle('active', this.customPattern.kick.includes(i));
                    stepEl.classList.toggle('current', i === this.currentStep % 16);
                });
            }

            initVisualizer() {
                const canvas = document.getElementById('visualizer');
                const ctx = canvas.getContext('2d');
                
                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                };
                resize();
                window.addEventListener('resize', resize);
                
                this.visualizerCtx = ctx;
                this.visualizerCanvas = canvas;
                
                // Initialize particle system
                this.particles = [];
                for (let i = 0; i < 100; i++) {
                    this.particles.push({
                        x: Math.random() * canvas.width,
                        y: Math.random() * canvas.height,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        size: Math.random() * 3 + 1,
                        hue: Math.random() * 360
                    });
                }
            }

            initWaveform() {
                const canvas = document.getElementById('waveform');
                const ctx = canvas.getContext('2d');
                
                const resize = () => {
                    canvas.width = window.innerWidth;
                    canvas.height = 100;
                };
                resize();
                window.addEventListener('resize', resize);
                
                this.waveformCtx = ctx;
                this.waveformCanvas = canvas;
            }

            animateVisualizer() {
                if (!this.analyzer || this.producer.energy < 0.2) return;
                
                const canvas = this.visualizerCanvas;
                const ctx = this.visualizerCtx;
                const bufferLength = this.analyzer.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                const particles = this.particles;
                
                const draw = () => {
                    if (this.producer.energy < 0.2) {
                        canvas.classList.remove('active');
                        return;
                    }
                    
                    canvas.classList.add('active');
                    requestAnimationFrame(draw);
                    
                    this.analyzer.getByteFrequencyData(dataArray);
                    
                    // Different visualizations based on AI personality
                    if (this.producer.personality === 'kanye') {
                        this.drawKanyeViz(ctx, dataArray);
                    } else if (this.producer.personality === 'dilla') {
                        this.drawDillaViz(ctx, dataArray);
                    } else if (this.producer.personality === 'flylo') {
                        this.drawFlyLoViz(ctx, dataArray);
                    } else if (this.producer.personality === 'arca') {
                        this.drawArcaViz(ctx, dataArray);
                    } else if (this.producer.personality === 'sophie') {
                        this.drawSophieViz(ctx, dataArray);
                    }
                    
                    // Update particles
                    const bass = dataArray[0] / 255;
                    particles.forEach(p => {
                        p.x += p.vx + bass * 5 * (Math.random() - 0.5);
                        p.y += p.vy + bass * 5 * (Math.random() - 0.5);
                        
                        if (p.x < 0 || p.x > canvas.width) p.vx *= -1;
                        if (p.y < 0 || p.y > canvas.height) p.vy *= -1;
                        
                        p.hue += this.producer.evolution * 5;
                    });
                };
                
                draw();
            }

            drawKanyeViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Bold, geometric shapes
                const bass = dataArray[0] / 255;
                const mid = dataArray[Math.floor(dataArray.length / 2)] / 255;
                
                ctx.save();
                ctx.translate(canvas.width / 2, canvas.height / 2);
                ctx.rotate(this.ctx.currentTime * 0.1);
                
                // Diamond shape
                ctx.strokeStyle = `hsl(${this.ctx.currentTime * 50}, 100%, 50%)`;
                ctx.lineWidth = 5 + bass * 20;
                ctx.beginPath();
                ctx.moveTo(0, -100 - bass * 200);
                ctx.lineTo(100 + mid * 200, 0);
                ctx.lineTo(0, 100 + bass * 200);
                ctx.lineTo(-100 - mid * 200, 0);
                ctx.closePath();
                ctx.stroke();
                
                ctx.restore();
            }

            drawDillaViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Wonky, off-grid circles
                for (let i = 0; i < dataArray.length; i += 20) {
                    const value = dataArray[i] / 255;
                    const x = (i / dataArray.length) * canvas.width;
                    const y = canvas.height / 2 + Math.sin(this.ctx.currentTime + i) * 100;
                    
                    ctx.beginPath();
                    ctx.arc(x, y, value * 50, 0, Math.PI * 2);
                    ctx.fillStyle = `hsla(${30 + value * 30}, 70%, 50%, ${value * 0.5})`;
                    ctx.fill();
                }
            }

            drawFlyLoViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.02)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Psychedelic waveforms
                ctx.beginPath();
                for (let i = 0; i < dataArray.length; i++) {
                    const value = dataArray[i] / 255;
                    const x = (i / dataArray.length) * canvas.width;
                    const y = canvas.height / 2 + value * 200 * Math.sin(this.ctx.currentTime * 2 + i * 0.1);
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.strokeStyle = `hsla(${this.ctx.currentTime * 100}, 100%, 50%, 0.8)`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            drawArcaViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                
                // Glitchy, distorted shapes
                for (let i = 0; i < 10; i++) {
                    const index = Math.floor(Math.random() * dataArray.length);
                    const value = dataArray[index] / 255;
                    
                    if (value > 0.5) {
                        ctx.save();
                        ctx.translate(
                            Math.random() * canvas.width,
                            Math.random() * canvas.height
                        );
                        ctx.scale(value * 5, value * 5);
                        ctx.rotate(Math.random() * Math.PI * 2);
                        
                        ctx.fillStyle = `hsla(${Math.random() * 360}, 100%, 50%, ${value * 0.3})`;
                        ctx.fillRect(-50, -50, 100, 100);
                        
                        ctx.restore();
                    }
                }
                
                // Fade out
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
            }

            drawSophieViz(ctx, dataArray) {
                const canvas = ctx.canvas;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Hyper-digital, crystalline structures
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                for (let i = 0; i < dataArray.length; i += 10) {
                    const value = dataArray[i] / 255;
                    const angle = (i / dataArray.length) * Math.PI * 2;
                    const radius = 100 + value * 300;
                    
                    const x = centerX + Math.cos(angle) * radius;
                    const y = centerY + Math.sin(angle) * radius;
                    
                    ctx.beginPath();
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(x, y);
                    
                    const nextAngle = ((i + 10) / dataArray.length) * Math.PI * 2;
                    const nextRadius = 100 + (dataArray[Math.min(i + 10, dataArray.length - 1)] / 255) * 300;
                    const nextX = centerX + Math.cos(nextAngle) * nextRadius;
                    const nextY = centerY + Math.sin(nextAngle) * nextRadius;
                    
                    ctx.lineTo(nextX, nextY);
                    ctx.closePath();
                    
                    ctx.fillStyle = `hsla(${300 + value * 60}, 100%, 50%, ${value * 0.5})`;
                    ctx.fill();
                }
            }

            animateWaveform() {
                if (!this.waveformAnalyzer || !this.loops.length) return;
                
                const canvas = this.waveformCanvas;
                const ctx = this.waveformCtx;
                const bufferLength = this.waveformAnalyzer.fftSize;
                const dataArray = new Float32Array(bufferLength);
                
                const draw = () => {
                    if (!this.loops.length) {
                        canvas.classList.remove('visible');
                        return;
                    }
                    
                    canvas.classList.add('visible');
                    requestAnimationFrame(draw);
                    
                    this.waveformAnalyzer.getFloatTimeDomainData(dataArray);
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = `hsla(${this.producer.evolution * 360}, 100%, 50%, 0.8)`;
                    ctx.beginPath();
                    
                    const sliceWidth = canvas.width / bufferLength;
                    let x = 0;
                    
                    for (let i = 0; i < bufferLength; i++) {
                        const v = dataArray[i];
                        const y = (v + 1) / 2 * canvas.height;
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    ctx.stroke();
                };
                
                draw();
            }

            scheduleIntro() {
                const startTime = this.ctx.currentTime + 0.1;
                const beat = 60 / this.bpm;
                
                // Different intro based on personality
                const intros = {
                    kanye: this.createKanyeIntro(),
                    dilla: this.createDillaIntro(),
                    flylo: this.createFlyLoIntro(),
                    arca: this.createArcaIntro(),
                    sophie: this.createSophieIntro()
                };
                
                const intro = intros[this.producer.personality] || intros.kanye;
                
                // Schedule intro hits
                intro.forEach(hit => {
                    this.scheduleSound(hit.sound, startTime + hit.time, hit.vel);
                });
                
                // Start main loop after intro
                setTimeout(() => {
                    this.startMainLoop();
                }, beat * 16 * 1000);
            }

            createKanyeIntro() {
                const beat = 60 / this.bpm;
                return [
                    // Bar 1 - Sparse kick
                    { time: 0, sound: 'kick', vel: 0.6 },
                    { time: beat * 2, sound: 'kick', vel: 0.4 },
                    
                    // Bar 2 - Add ghost kicks
                    { time: beat * 4, sound: 'kick', vel: 0.8 },
                    { time: beat * 5.5, sound: 'kick', vel: 0.3 },
                    { time: beat * 6, sound: 'kick', vel: 0.5 },
                    
                    // Bar 3 - Introduce hats
                    { time: beat * 8, sound: 'kick', vel: 0.9 },
                    { time: beat * 8.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 9, sound: 'hihat', vel: 0.4 },
                    { time: beat * 9.5, sound: 'hihat', vel: 0.3 },
                    { time: beat * 10, sound: 'kick', vel: 0.5 },
                    { time: beat * 10.5, sound: 'hihat', vel: 0.4 },
                    
                    // Bar 4 - Build tension
                    { time: beat * 12, sound: 'kick', vel: 1 },
                    { time: beat * 12.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 13, sound: 'snare', vel: 0.6 },
                    { time: beat * 13.5, sound: 'hihat', vel: 0.4 },
                    { time: beat * 14, sound: 'kick', vel: 0.7 },
                    { time: beat * 14.5, sound: 'hihat', vel: 0.5 },
                    { time: beat * 15, sound: 'snare', vel: 0.5 },
                    { time: beat * 15.5, sound: 'snare', vel: 0.4 }
                ];
            }

            createDillaIntro() {
                const beat = 60 / this.bpm;
                return [
                    // Wonky timing, drunk groove
                    { time: 0, sound: 'kick', vel: 0.7 },
                    { time: beat * 0.9, sound: 'hihat', vel: 0.3 },
                    { time: beat * 2.1, sound: 'kick', vel: 0.5 },
                    { time: beat * 2.4, sound: 'snare', vel: 0.4 },
                    { time: beat * 3.7, sound: 'hihat', vel: 0.4 },
                    { time: beat * 4.2, sound: 'kick', vel: 0.8 },
                    { time: beat * 5.9, sound: 'rimshot', vel: 0.5 },
                    { time: beat * 6.1, sound: 'kick', vel: 0.4 },
                    { time: beat * 7.8, sound: 'snare', vel: 0.6 },
                    { time: beat * 8.3, sound: 'kick', vel: 0.9 }
                ];
            }

            createFlyLoIntro() {
                const beat = 60 / this.bpm;
                return [
                    // Atmospheric, spacey
                    { time: 0, sound: 'crash', vel: 0.3 },
                    { time: beat * 2, sound: 'kick', vel: 0.4 },
                    { time: beat * 2.5, sound: 'hihat', vel: 0.2 },
                    { time: beat * 3, sound: 'hihat', vel: 0.2 },
                    { time: beat * 4, sound: 'kick', vel: 0.5 },
                    { time: beat * 4.5, sound: 'perc', vel: 0.3 },
                    { time: beat * 6, sound: 'snare', vel: 0.4 },
                    { time: beat * 7, sound: 'ride', vel: 0.3 },
                    { time: beat * 8, sound: 'kick', vel: 0.6 }
                ];
            }

            createArcaIntro() {
                const beat = 60 / this.bpm;
                return [
                    // Chaotic, glitchy
                    { time: 0, sound: 'kick', vel: 1 },
                    { time: beat * 0.25, sound: 'kick', vel: 0.5 },
                    { time: beat * 0.5, sound: 'snare', vel: 0.8 },
                    { time: beat * 1.75, sound: 'clap', vel: 0.6 },
                    { time: beat * 2, sound: 'kick', vel: 0.9 },
                    { time: beat * 3.5, sound: 'rimshot', vel: 0.7 },
                    { time: beat * 4, sound: 'kick808', vel: 0.8 },
                    { time: beat * 6.25, sound: 'cowbell', vel: 0.5 },
                    { time: beat * 7, sound: 'crash', vel: 0.4 }
                ];
            }

            createSophieIntro() {
                const beat = 60 / this.bpm;
                return [
                    // Hyper-clean, synthetic
                    { time: 0, sound: 'kick', vel: 1 },
                    { time: beat * 0.5, sound: 'hihat', vel: 0.9 },
                    { time: beat * 1, sound: 'hihat', vel: 0.9 },
                    { time: beat * 1.5, sound: 'hihat', vel: 0.9 },
                    { time: beat * 2, sound: 'snare', vel: 1 },
                    { time: beat * 3, sound: 'kick', vel: 1 },
                    { time: beat * 4, sound: 'kick', vel: 1 },
                    { time: beat * 4.5, sound: 'clap', vel: 0.8 },
                    { time: beat * 5, sound: 'clap', vel: 0.8 },
                    { time: beat * 6, sound: 'kick808', vel: 1 }
                ];
            }

            scheduleSound(sound, time, velocity = 1, bus = null) {
                const source = this.ctx.createBufferSource();
                const gainNode = this.ctx.createGain();
                
                source.buffer = this.drums[sound];
                
                // Producer AI can modify velocity
                const producerMultiplier = this.producer.godMode ? 
                    1 + Math.random() * 0.5 * this.producer.intensity : 1;
                
                gainNode.gain.value = velocity * producerMultiplier;
                
                // Add slight pitch variation based on personality
                const pitchVariation = {
                    kanye: 0.02,
                    dilla: 0.08,
                    flylo: 0.05,
                    arca: 0.15,
                    sophie: 0.01
                };
                source.playbackRate.value = 1 + (Math.random() - 0.5) * (pitchVariation[this.producer.personality] || 0.02);
                
                // Producer can add extra effects
                let finalConnection = source;
                
                if (this.producer.complexity > 0.7 && Math.random() < 0.3) {
                    const filter = this.ctx.createBiquadFilter();
                    filter.type = Math.random() > 0.5 ? 'highpass' : 'lowpass';
                    filter.frequency.value = 200 + Math.random() * 5000;
                    filter.Q.value = 1 + Math.random() * 10;
                    
                    finalConnection.connect(filter);
                    finalConnection = filter;
                }
                
                // Reverse mode
                if (this.reverseMode && Math.random() < 0.3) {
                    source.playbackRate.value *= -1;
                }
                
                // Stutter effect
                if (this.stutterActive) {
                    const stutterGain = this.ctx.createGain();
                    stutterGain.gain.setValueAtTime(0, time);
                    for (let i = 0; i < 8; i++) {
                        stutterGain.gain.setValueAtTime(1, time + i * 0.03);
                        stutterGain.gain.setValueAtTime(0, time + i * 0.03 + 0.015);
                    }
                    finalConnection.connect(stutterGain);
                    finalConnection = stutterGain;
                }
                
                finalConnection.connect(gainNode);
                
                // Connect to appropriate bus
                gainNode.connect(bus || this.drumBus);
                
                // Send to effects based on personality and state
                if (this.producer.godMode) {
                    const sendAmount = this.producer.complexity * 0.5;
                    gainNode.connect(this.reverbSend.gain.value = sendAmount, this.reverbSend);
                    gainNode.connect(this.delaySend.gain.value = sendAmount * 0.7, this.delaySend);
                    
                    if (this.producer.personality === 'flylo' || this.producer.personality === 'arca') {
                        gainNode.connect(this.chorusSend.gain.value = sendAmount * 0.3, this.chorusSend);
                    }
                }
                
                source.start(time);
                
                // Trigger sidechain
                if (sound === 'kick' || sound === 'kick808') {
                    this.triggerSidechain(time);
                }
                
                // Visual feedback
                const delay = (time - this.ctx.currentTime) * 1000;
                if (delay >= 0 && delay < 100) {
                    setTimeout(() => {
                        this.orb.classList.add('beat');
                        setTimeout(() => this.orb.classList.remove('beat'), 50);
                    }, delay);
                }
            }

            triggerSidechain(time) {
                if (!this.sidechain.active) return;
                
                const attack = 0.01;
                const hold = 0.05;
                const release = 0.15;
                
                // Duck the sample bus
                this.sidechainGain.gain.cancelScheduledValues(time);
                this.sidechainGain.gain.setValueAtTime(this.sidechainGain.gain.value, time);
                this.sidechainGain.gain.linearRampToValueAtTime(1 - this.sidechain.amount, time + attack);
                this.sidechainGain.gain.setValueAtTime(1 - this.sidechain.amount, time + attack + hold);
                this.sidechainGain.gain.linearRampToValueAtTime(1, time + attack + hold + release);
            }

            startMainLoop() {
                const beat = 60 / this.bpm;
                const sixteenth = beat / 4;
                let nextTime = this.ctx.currentTime;
                
                // Patterns for different personalities
                const patterns = {
                    kanye: {
                        kick: [0, 10, 20, 22],
                        snare: [8, 24],
                        hihat: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30],
                        openhat: [14, 30],
                        clap: [8, 24],
                        perc: [5, 13, 21, 29]
                    },
                    dilla: {
                        kick: [0, 7, 16, 22, 26],
                        snare: [9, 25],
                        hihat: [0, 3, 6, 8, 11, 14, 16, 19, 22, 24, 27, 30],
                        rimshot: [5, 21],
                        perc: [13, 29]
                    },
                    flylo: {
                        kick: [0, 11, 22],
                        snare: [8, 19, 24],
                        hihat: [2, 6, 10, 14, 18, 22, 26, 30],
                        ride: [0, 16],
                        perc: [5, 13, 21, 27],
                        crash: []
                    },
                    arca: {
                        kick: [0, 3, 10, 11, 20, 23, 27],
                        kick808: [16],
                        snare: [7, 15, 23, 31],
                        rimshot: [4, 12, 28],
                        clap: [8, 24],
                        conga: [5, 13, 21],
                        cowbell: [2, 18]
                    },
                    sophie: {
                        kick: [0, 4, 8, 12, 16, 20, 24, 28],
                        kick808: [0, 16],
                        snare: [8, 24],
                        hihat: [2, 6, 10, 14, 18, 22, 26, 30],
                        clap: [8, 12, 24, 28],
                        perc: []
                    }
                };
                
                const loop = () => {
                    const currentTime = this.ctx.currentTime;
                    
                    // Schedule ahead
                    while (nextTime < currentTime + 0.1) {
                        const step = this.currentStep % 32;
                        
                        // Track bars for producer AI
                        if (step === 0) {
                            this.barCount++;
                            this.updateProducerState();
                            
                            // Update pattern grid
                            if (this.patternMode) {
                                this.updatePatternGrid();
                            }
                        }
                        
                        // Apply swing to off-beats
                        let swingOffset = 0;
                        if (step % 2 === 1) {
                            swingOffset = sixteenth * this.swing * 
                                (this.producer.personality === 'dilla' ? 1.5 : 1);
                        }
                        
                        // Choose pattern based on mode
                        let pattern;
                        if (this.patternMode && step < 16) {
                            pattern = this.customPattern;
                        } else {
                            pattern = patterns[this.producer.personality] || patterns.kanye;
                        }
                        
                        // Let producer AI decide what to play
                        const producerPattern = this.producer.godMode ? 
                            this.producerDecidePattern(pattern, step) : pattern;
                        
                        // Schedule hits
                        Object.entries(producerPattern).forEach(([sound, steps]) => {
                            if (steps.includes(step)) {
                                let velocity = 0.8;
                                
                                // Velocity variations based on personality
                                if (this.producer.personality === 'dilla') {
                                    velocity = 0.4 + Math.random() * 0.4;
                                } else if (sound === 'hihat') {
                                    velocity = step % 4 === 0 ? 0.6 : 0.4;
                                } else if (sound === 'kick' && step === 0) {
                                    velocity = 1;
                                }
                                
                                // Producer can override velocity
                                if (this.producer.godMode) {
                                    velocity *= 0.5 + this.producer.energy * 0.5;
                                }
                                
                                this.scheduleSound(sound, nextTime + swingOffset, velocity);
                            }
                        });
                        
                        // Trigger samples with producer processing
                        if (step === 0 && this.loops.length > 0) {
                            this.triggerSampleLoop(nextTime);
                        }
                        
                        this.currentStep++;
                        nextTime += sixteenth;
                    }
                    
                    requestAnimationFrame(loop);
                };
                
                loop();
            }

            startProducerAI() {
                // Producer AI that evolves the mix over time
                setInterval(() => {
                    if (!this.producer.godMode) return;
                    
                    // Analyze current state
                    const sampleCount = this.loops.length;
                    const timeElapsed = this.barCount * 4 * 60 / this.bpm; // seconds
                    
                    // Update intensity based on personality
                    this.updateProducerIntensity(timeElapsed, sampleCount);
                    
                    // Make production decisions
                    const decisions = this.makeProductionDecisions(timeElapsed, sampleCount);
                    
                    // Update effects based on state
                    this.updateEffects();
                    
                    // Show status
                    if (decisions.length > 0) {
                        this.producerStatus.textContent = decisions[0];
                        this.producerStatus.classList.add('visible');
                        setTimeout(() => {
                            this.producerStatus.classList.remove('visible');
                        }, 2000);
                    }
                    
                }, 2000);
            }

            updateProducerIntensity(timeElapsed, sampleCount) {
                const personalities = {
                    kanye: () => {
                        // Bold, confident builds
                        if (timeElapsed < 30) {
                            this.producer.energy = Math.min(1, timeElapsed / 30);
                            this.producer.intensity = 0.8;
                        } else if (timeElapsed > 120 && timeElapsed < 150) {
                            // Epic breakdown
                            this.producer.energy = 0.3;
                            this.producer.intensity = 1;
                        } else {
                            this.producer.energy = 0.8 + Math.sin(timeElapsed * 0.05) * 0.2;
                            this.producer.intensity = 0.9;
                        }
                    },
                    dilla: () => {
                        // Laid back, groovy
                        this.producer.energy = 0.4 + Math.sin(timeElapsed * 0.03) * 0.3;
                        this.producer.intensity = 0.6;
                        this.swing = 0.2 + Math.sin(timeElapsed * 0.02) * 0.05;
                    },
                    flylo: () => {
                        // Psychedelic journeys
                        this.producer.energy = 0.5 + Math.sin(timeElapsed * 0.02) * 0.5;
                        this.producer.intensity = Math.min(1, timeElapsed / 180);
                        this.producer.complexity = Math.min(1, sampleCount * 0.3 + timeElapsed / 200);
                    },
                    arca: () => {
                        // Chaotic, unpredictable
                        this.producer.energy = Math.random() * 0.5 + 0.5;
                        this.producer.intensity = Math.random();
                        if (Math.random() < 0.1) {
                            // Random glitch
                            this.bpm = 72 + (Math.random() - 0.5) * 20;
                        }
                    },
                    sophie: () => {
                        // Hyper-produced, perfect
                        this.producer.energy = timeElapsed % 32 < 16 ? 1 : 0.6;
                        this.producer.intensity = 1;
                        this.producer.complexity = 0.8;
                        this.sidechain.active = true;
                        this.sidechain.amount = 0.7;
                    }
                };
                
                const updateFunc = personalities[this.producer.personality] || personalities.kanye;
                updateFunc();
                
                // Complexity based on samples
                this.producer.complexity = Math.min(1, sampleCount * 0.25 + timeElapsed / 180);
                
                // Evolution increases over time
                this.producer.evolution = Math.min(1, timeElapsed / 240);
            }

            makeProductionDecisions(timeElapsed, sampleCount) {
                const decisions = [];
                
                // Song structure decisions
                const section = Math.floor(timeElapsed / 32) % 4;
                const sections = ['Intro', 'Verse', 'Chorus', 'Bridge'];
                this.producer.structurePosition = section;
                
                // Make decisions based on section
                if (this.barCount % 8 === 0) {
                    const rand = Math.random();
                    
                    if (section === 0 && rand < 0.3) {
                        // Intro: build up
                        decisions.push('Building tension...');
                        this.drumFilter.frequency.linearRampToValueAtTime(20000, this.ctx.currentTime + 4);
                    } else if (section === 1 && rand < 0.4) {
                        // Verse: create space
                        decisions.push('Creating space');
                        this.drumBus.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 0.5);
                        this.sampleBus.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.5);
                    } else if (section === 2 && rand < 0.5) {
                        // Chorus: full energy
                        decisions.push('Drop the beat!');
                        this.drumBus.gain.linearRampToValueAtTime(1.2, this.ctx.currentTime + 0.1);
                        this.master.gain.linearRampToValueAtTime(1.1, this.ctx.currentTime + 0.1);
                    } else if (section === 3 && rand < 0.4) {
                        // Bridge: experimental
                        decisions.push('Getting weird...');
                        this.applyCreativeEffect();
                    }
                }
                
                return decisions;
            }

            applyCreativeEffect() {
                const effects = [
                    () => {
                        // Bit crush
                        this.bitDepth = Math.floor(Math.random() * 8) + 4;
                        this.sampleRateReduction = Math.floor(Math.random() * 4) + 1;
                        setTimeout(() => {
                            this.bitDepth = 16;
                            this.sampleRateReduction = 1;
                        }, 4000);
                    },
                    () => {
                        // Filter sweep
                        const startFreq = 200;
                        const endFreq = 15000;
                        this.drumFilter.frequency.linearRampToValueAtTime(startFreq, this.ctx.currentTime);
                        this.drumFilter.frequency.linearRampToValueAtTime(endFreq, this.ctx.currentTime + 2);
                        this.drumFilter.Q.value = 10;
                    },
                    () => {
                        // Reverse all samples
                        this.reverseMode = true;
                        setTimeout(() => {
                            this.reverseMode = false;
                        }, 2000);
                    },
                    () => {
                        // Heavy distortion burst
                        this.distortionSend.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 0.1);
                        this.distortionSend.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 2);
                    },
                    () => {
                        // Tempo glitch
                        const originalBPM = this.bpm;
                        this.bpm *= 0.5;
                        setTimeout(() => {
                            this.bpm = originalBPM;
                        }, 1000);
                    }
                ];
                
                const effect = effects[Math.floor(Math.random() * effects.length)];
                effect();
            }

            updateProducerState() {
                if (!this.producer.godMode) return;
                
                // Update AI personality display
                this.aiPersonality.textContent = `AI: ${this.producer.personality.toUpperCase()}`;
                this.aiPersonality.classList.add('visible');
                
                // Every 4 bars, make a production decision
                if (this.barCount % 4 === 0) {
                    const rand = Math.random();
                    
                    if (rand < 0.2 && this.producer.energy > 0.5) {
                        // Drop out drums briefly
                        this.drumBus.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.1);
                        this.drumBus.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.5);
                        this.producerStatus.textContent = 'Drum dropout';
                        this.producerStatus.classList.add('visible');
                    } else if (rand < 0.4 && this.loops.length > 1) {
                        // Emphasize samples
                        this.sampleBus.gain.linearRampToValueAtTime(1.2, this.ctx.currentTime + 0.1);
                        this.sampleBus.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 2);
                        this.producerStatus.textContent = 'Sample focus';
                        this.producerStatus.classList.add('visible');
                    } else if (rand < 0.6) {
                        // Filter sweep
                        const startFreq = 200 + Math.random() * 1000;
                        const endFreq = 5000 + Math.random() * 10000;
                        this.drumFilter.frequency.linearRampToValueAtTime(startFreq, this.ctx.currentTime);
                        this.drumFilter.frequency.linearRampToValueAtTime(endFreq, this.ctx.currentTime + 2);
                        this.producerStatus.textContent = 'Filter sweep';
                        this.producerStatus.classList.add('visible');
                    }
                    
                    setTimeout(() => {
                        this.producerStatus.classList.remove('visible');
                    }, 2000);
                }
                
                // Start visualizer when energy is high enough
                if (this.producer.energy > 0.2 && !this.visualizerActive) {
                    this.visualizerActive = true;
                    this.animateVisualizer();
                }
                
                // Start waveform when samples exist
                if (this.loops.length > 0 && !this.waveformActive) {
                    this.waveformActive = true;
                    this.animateWaveform();
                }
            }

            producerDecidePattern(originalPattern, step) {
                // Producer can modify patterns in god mode
                const pattern = JSON.parse(JSON.stringify(originalPattern));
                
                // Personality-specific modifications
                if (this.producer.personality === 'dilla') {
                    // Add humanization
                    Object.keys(pattern).forEach(sound => {
                        if (Math.random() < 0.1) {
                            // Random ghost notes
                            pattern[sound] = pattern[sound].map(s => 
                                s + (Math.random() < 0.3 ? Math.floor(Math.random() * 3) - 1 : 0)
                            ).filter(s => s >= 0 && s < 32);
                        }
                    });
                } else if (this.producer.personality === 'arca') {
                    // Glitch patterns
                    if (Math.random() < 0.2) {
                        const sounds = Object.keys(pattern);
                        const randomSound = sounds[Math.floor(Math.random() * sounds.length)];
                        pattern[randomSound].push(step);
                    }
                } else if (this.producer.personality === 'sophie') {
                    // Precision and repetition
                    if (step % 4 === 0 && this.producer.energy > 0.8) {
                        pattern.kick.push(step);
                        pattern.kick808 = [step];
                    }
                }
                
                // General modifications based on energy/complexity
                if (this.producer.complexity > 0.5 && Math.random() < 0.2) {
                    if (!pattern.kick.includes(step) && step % 4 === 2) {
                        pattern.kick.push(step);
                    }
                }
                
                // Remove hits for space
                if (this.producer.energy < 0.5 && Math.random() < 0.3) {
                    pattern.hihat = pattern.hihat.filter(s => s % 4 === 0);
                }
                
                // Add percussion flourishes
                if (this.producer.evolution > 0.7 && Math.random() < 0.1) {
                    const percSounds = ['perc', 'conga', 'cowbell', 'rimshot'];
                    const randomPerc = percSounds[Math.floor(Math.random() * percSounds.length)];
                    if (pattern[randomPerc]) {
                        pattern[randomPerc].push(step);
                    }
                }
                
                return pattern;
            }

            updateEffects() {
                // Drum effects based on energy
                this.drumBus.gain.value = 0.8 + this.producer.energy * 0.2;
                
                // Reverb amount
                this.reverbSend.gain.linearRampToValueAtTime(
                    this.producer.energy * 0.3 * (this.producer.personality === 'flylo' ? 1.5 : 1), 
                    this.ctx.currentTime + 0.5
                );
                
                // Sample effects get wilder over time
                const distortionAmount = 10 + this.producer.evolution * 90;
                this.heavyDistortion.curve = this.makeDistortionCurve(distortionAmount);
                
                // Filter movement
                const filterFreq = 1000 + this.producer.complexity * 15000;
                this.sampleFilter.frequency.linearRampToValueAtTime(
                    filterFreq,
                    this.ctx.currentTime + 0.5
                );
                
                // Delay feedback increases with evolution
                this.delaySend.gain.linearRampToValueAtTime(
                    0.2 + this.producer.evolution * 0.3,
                    this.ctx.currentTime + 0.5
                );
                
                // Update based on XY pad if visible
                if (this.effectPadVisible) {
                    this.updateXYEffects();
                }
            }

            updateXYEffects() {
                // X-axis: Filter frequency
                const filterFreq = 200 + this.effectX * 15000;
                this.drumFilter.frequency.linearRampToValueAtTime(filterFreq, this.ctx.currentTime + 0.1);
                this.sampleFilter.frequency.linearRampToValueAtTime(filterFreq * 0.8, this.ctx.currentTime + 0.1);
                
                // Y-axis: Effect sends
                this.reverbSend.gain.linearRampToValueAtTime(this.effectY * 0.5, this.ctx.currentTime + 0.1);
                this.delaySend.gain.linearRampToValueAtTime((1 - this.effectY) * 0.5, this.ctx.currentTime + 0.1);
                
                // Corner effects
                if (this.effectX > 0.8 && this.effectY > 0.8) {
                    this.chorusSend.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.1);
                    this.distortionSend.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.1);
                } else if (this.effectX < 0.2 && this.effectY < 0.2) {
                    this.bitDepth = 8;
                    this.sampleRateReduction = 4;
                } else {
                    this.chorusSend.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                    this.distortionSend.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 0.1);
                    this.bitDepth = 16;
                    this.sampleRateReduction = 1;
                }
            }

            toggleRecording() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }

            startRecording() {
                if (!this.micSource) return;
                
                this.isRecording = true;
                this.recordBuffer = [];
                this.orb.classList.add('recording');
                this.status.textContent = 'Recording...';
                this.status.classList.add('visible');
                
                // Connect mic to recorder
                this.micSource.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
            }

            stopRecording() {
                this.isRecording = false;
                this.orb.classList.remove('recording');
                this.status.classList.remove('visible');
                
                // Disconnect
                try {
                    this.micSource.disconnect(this.recorder);
                    this.recorder.disconnect();
                } catch (e) {}
                
                // Process if we have enough audio
                if (this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                    this.processSample();
                }
            }

            processSample() {
                // Create buffer from recording
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                // Find loop points (4 bars)
                const barLength = this.ctx.sampleRate * 60 / this.bpm * 4;
                const loopLength = Math.min(buffer.length, barLength);
                
                // Create perfectly looped buffer
                const loopBuffer = this.ctx.createBuffer(1, Math.floor(loopLength), this.ctx.sampleRate);
                const sourceData = buffer.getChannelData(0);
                const loopData = loopBuffer.getChannelData(0);
                
                // Advanced processing based on AI personality
                this.processAudioForPersonality(sourceData, loopData, loopLength);
                
                // Store the loop with metadata
                this.loops.push({
                    buffer: loopBuffer,
                    playing: null,
                    effects: {
                        filter: null,
                        delay: null,
                        reverb: null,
                        distortion: null,
                        granular: null
                    },
                    grains: [],
                    personality: this.producer.personality,
                    timestamp: this.ctx.currentTime
                });
                
                // Keep only last 8 loops for more layers
                if (this.loops.length > 8) {
                    const removed = this.loops.shift();
                    if (removed.playing) {
                        removed.playing.stop();
                    }
                }
                
                // AI learns from the sample
                this.producer.memory.push({
                    energy: this.analyzeEnergy(loopBuffer),
                    spectralCentroid: this.analyzeSpectralCentroid(loopBuffer),
                    timestamp: this.ctx.currentTime
                });
                
                this.status.textContent = `Sample ${this.loops.length} ready • ${this.producer.personality} processing`;
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
                
                // Auto-enable god mode after 4 samples
                if (this.loops.length === 4 && !this.producer.godMode) {
                    this.toggleGodMode();
                }
            }

            processAudioForPersonality(sourceData, loopData, loopLength) {
                const fadeLength = 100;
                
                switch (this.producer.personality) {
                    case 'kanye':
                        // Aggressive compression and saturation
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            
                            // Hard compression
                            sample = Math.sign(sample) * Math.min(Math.abs(sample) * 2, 1);
                            
                            // Saturation
                            sample = Math.tanh(sample * 3) * 0.9;
                            
                            // Fade in/out
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            
                            loopData[i] = sample;
                        }
                        break;
                        
                    case 'dilla':
                        // Vinyl warmth and slight pitch wobble
                        let phase = 0;
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            
                            // Vinyl crackle
                            if (Math.random() < 0.001) {
                                sample += (Math.random() - 0.5) * 0.1;
                            }
                            
                            // Warm saturation
                            sample = Math.tanh(sample * 1.5) * 0.8;
                            
                            // Slight pitch wobble
                            phase += 0.0001 + Math.sin(i * 0.00001) * 0.00005;
                            const wobbleIndex = Math.floor(i + Math.sin(phase) * 10) % sourceData.length;
                            sample = sample * 0.7 + sourceData[wobbleIndex] * 0.3;
                            
                            // Fade in/out
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            
                            loopData[i] = sample;
                        }
                        break;
                        
                    case 'flylo':
                        // Psychedelic filtering and delays
                        let delayBuffer = new Float32Array(4000);
                        let delayIndex = 0;
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            
                            // Resonant filter simulation
                            if (i > 1) {
                                const cutoff = 0.5 + Math.sin(i * 0.0001) * 0.4;
                                sample = sample * cutoff + loopData[i-1] * (1 - cutoff) * 0.9;
                            }
                            
                            // Psychedelic delay
                            const delayed = delayBuffer[delayIndex];
                            delayBuffer[delayIndex] = sample + delayed * 0.5;
                            sample = sample + delayed * 0.3;
                            delayIndex = (delayIndex + 1) % delayBuffer.length;
                            
                            // Fade in/out
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            
                            loopData[i] = Math.tanh(sample) * 0.8;
                        }
                        break;
                        
                    case 'arca':
                        // Glitchy, stuttery processing
                        let glitchBuffer = [];
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            
                            // Random glitches
                            if (Math.random() < 0.05) {
                                // Repeat section
                                const glitchLength = Math.floor(Math.random() * 1000) + 100;
                                for (let j = 0; j < glitchLength && i + j < loopLength; j++) {
                                    glitchBuffer.push(sourceData[i]);
                                }
                            }
                            
                            // Use glitch buffer if available
                            if (glitchBuffer.length > 0) {
                                sample = glitchBuffer.shift();
                            }
                            
                            // Extreme filtering
                            sample = Math.sign(sample) * Math.pow(Math.abs(sample), 0.5);
                            
                            // Fade in/out
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            
                            loopData[i] = sample * 0.9;
                        }
                        break;
                        
                    case 'sophie':
                        // Hyper-clean, synthetic processing
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            
                            // Extreme high-pass
                            if (i > 0) {
                                sample = sample - sourceData[i-1] * 0.98;
                            }
                            
                            // Hard limiting
                            sample = Math.max(-0.95, Math.min(0.95, sample * 2));
                            
                            // Perfect fades
                            const fadeCurve = x => x * x * (3 - 2 * x); // Smooth step
                            if (i < fadeLength) sample *= fadeCurve(i / fadeLength);
                            if (i > loopLength - fadeLength) sample *= fadeCurve((loopLength - i) / fadeLength);
                            
                            loopData[i] = sample;
                        }
                        break;
                        
                    default:
                        // Standard processing
                        for (let i = 0; i < loopLength; i++) {
                            let sample = sourceData[i];
                            if (i < fadeLength) sample *= i / fadeLength;
                            if (i > loopLength - fadeLength) sample *= (loopLength - i) / fadeLength;
                            loopData[i] = sample;
                        }
                }
            }

            analyzeEnergy(buffer) {
                const data = buffer.getChannelData(0);
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i];
                }
                return Math.sqrt(sum / data.length);
            }

            analyzeSpectralCentroid(buffer) {
                // Simple spectral centroid approximation
                const data = buffer.getChannelData(0);
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 0; i < data.length / 2; i++) {
                    const magnitude = Math.abs(data[i]);
                    weightedSum += magnitude * i;
                    magnitudeSum += magnitude;
                }
                
                return magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
            }

            triggerSampleLoop(time) {
                // Play all loops with evolving processing
                this.loops.forEach((loop, index) => {
                    // Stop previous instance
                    if (loop.playing) {
                        loop.playing.stop(time);
                    }
                    
                    // Create new source
                    const source = this.ctx.createBufferSource();
                    const gainNode = this.ctx.createGain();
                    
                    source.buffer = loop.buffer;
                    source.loop = true;
                    
                    // Create effect chain for this loop
                    const filter = this.ctx.createBiquadFilter();
                    const delay = this.createDelay(0.375 * ((index % 4) + 1), 0.3 + index * 0.05);
                    const reverb = this.createAdvancedReverb(1 + index * 0.3, 0.7 + index * 0.05);
                    const distortion = this.ctx.createWaveShaper();
                    
                    // Configure effects based on loop age and producer state
                    const ageMultiplier = 1 + (this.ctx.currentTime - loop.timestamp) / 100;
                    
                    filter.type = ['lowpass', 'bandpass', 'highpass'][index % 3];
                    filter.frequency.value = 1000 + index * 1000 * ageMultiplier;
                    filter.Q.value = 2 + this.producer.complexity * 10;
                    
                    // More distortion on older loops
                    const distAmount = 10 + index * 15 + this.producer.evolution * 40 * ageMultiplier;
                    distortion.curve = this.makeDistortionCurve(distAmount);
                    distortion.oversample = '4x';
                    
                    // Gain based on layer and AI decisions
                    const baseGain = (0.8 - (index * 0.08)) * (0.5 + this.producer.energy * 0.5);
                    gainNode.gain.value = baseGain;
                    
                    // Granular synthesis for extreme processing
                    if (index > 3 && this.producer.evolution > 0.5) {
                        this.setupGranularProcessing(loop, source, time);
                    }
                    
                    // Connect chain
                    source.connect(filter);
                    filter.connect(distortion);
                    distortion.connect(gainNode);
                    gainNode.connect(this.sampleBus);
                    
                    // Parallel effects with more sends for older loops
                    const wetAmount = Math.min(0.8, 0.2 + index * 0.1);
                    gainNode.connect(delay.input);
                    delay.output.gain.value = wetAmount;
                    delay.output.connect(this.sampleBus);
                    
                    gainNode.connect(reverb.input);
                    reverb.output.gain.value = wetAmount * 0.7;
                    reverb.output.connect(this.sampleBus);
                    
                    // Extreme effects for later loops
                    if (index > 5) {
                        gainNode.connect(this.chorusSend);
                        gainNode.connect(this.distortionSend);
                    }
                    
                    source.start(time);
                    loop.playing = source;
                    loop.effects = { filter, delay, reverb, distortion };
                    
                    // Animate effects over time
                    const animateEffects = () => {
                        if (loop.playing === source) {
                            const now = this.ctx.currentTime;
                            
                            // Complex LFO network
                            const lfo1 = Math.sin(now * (0.1 + index * 0.05)) * 0.5 + 0.5;
                            const lfo2 = Math.sin(now * (0.2 + index * 0.03)) * 0.5 + 0.5;
                            const lfo3 = Math.sin(now * 0.05) * 0.5 + 0.5;
                            
                            // Evolve filter frequency
                            const baseFreq = 500 + this.producer.evolution * 3000;
                            filter.frequency.value = baseFreq + lfo1 * (15000 - index * 1000);
                            
                            // Modulate Q based on energy
                            filter.Q.value = 1 + this.producer.energy * 15 + lfo2 * 10;
                            
                            // Gain automation
                            const targetGain = baseGain * (0.7 + lfo3 * 0.3);
                            gainNode.gain.linearRampToValueAtTime(targetGain, now + 0.1);
                            
                            // Delay feedback modulation
                            if (loop.effects.delay && loop.effects.delay.output) {
                                const feedbackAmount = 0.3 + this.producer.evolution * 0.4 + lfo1 * 0.2;
                                // Note: This would need the delay to expose feedback control
                            }
                            
                            requestAnimationFrame(animateEffects);
                        }
                    };
                    
                    if (this.producer.godMode) {
                        animateEffects();
                    }
                });
            }

            setupGranularProcessing(loop, source, startTime) {
                // Create grains for granular synthesis
                const grainDuration = 0.05;
                const grainOverlap = 0.5;
                const grainInterval = grainDuration * (1 - grainOverlap);
                
                let grainTime = startTime;
                const createGrain = () => {
                    if (loop.playing !== source) return;
                    
                    const grain = this.ctx.createBufferSource();
                    const grainEnv = this.ctx.createGain();
                    const grainPan = this.ctx.createStereoPanner();
                    
                    grain.buffer = loop.buffer;
                    
                    // Random grain position
                    const position = Math.random();
                    grain.start(grainTime, position * loop.buffer.duration, grainDuration);
                    
                    // Pitch variation
                    grain.playbackRate.value = 0.5 + Math.random() * 1;
                    
                    // Envelope
                    grainEnv.gain.setValueAtTime(0, grainTime);
                    grainEnv.gain.linearRampToValueAtTime(0.2, grainTime + grainDuration * 0.3);
                    grainEnv.gain.linearRampToValueAtTime(0, grainTime + grainDuration);
                    
                    // Random panning
                    grainPan.pan.value = (Math.random() - 0.5) * 2;
                    
                    // Connect
                    grain.connect(grainEnv);
                    grainEnv.connect(grainPan);
                    grainPan.connect(this.granularGain);
                    
                    grainTime += grainInterval;
                    
                    // Schedule next grain
                    if (grainTime < this.ctx.currentTime + 2) {
                        setTimeout(createGrain, grainInterval * 1000);
                    }
                };
                
                // Start grain generation
                createGrain();
            }

            toggleGodMode() {
                this.producer.godMode = !this.producer.godMode;
                
                if (this.producer.godMode) {
                    this.orb.classList.add('god-mode');
                    this.status.innerHTML = 'GOD MODE ACTIVATED<br>' + this.producer.personality.toUpperCase() + ' AI ONLINE';
                    this.status.classList.add('visible');
                    
                    // Boost everything
                    this.master.gain.linearRampToValueAtTime(1.1, this.ctx.currentTime + 0.5);
                    
                    // Enable all features
                    this.sidechain.active = true;
                    this.sidechain.amount = 0.5;
                    
                    // Start visualizer
                    this.animateVisualizer();
                    
                    // Show AI personality
                    this.aiPersonality.textContent = `AI: ${this.producer.personality.toUpperCase()}`;
                    this.aiPersonality.classList.add('visible');
                } else {
                    this.orb.classList.remove('god-mode');
                    this.status.textContent = 'God mode deactivated';
                    this.status.classList.add('visible');
                    
                    // Reset to normal
                    this.master.gain.linearRampToValueAtTime(0.95, this.ctx.currentTime + 0.5);
                    this.sidechain.active = false;
                    
                    this.aiPersonality.classList.remove('visible');
                }
                
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }

            togglePatternMode() {
                this.patternMode = !this.patternMode;
                
                if (this.patternMode) {
                    this.patternGrid.classList.add('visible');
                    this.status.textContent = 'Pattern mode: Click steps to program';
                } else {
                    this.patternGrid.classList.remove('visible');
                    this.status.textContent = 'Pattern mode off';
                }
                
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }

            setAIPersonality(personality) {
                const personalities = ['kanye', 'dilla', 'flylo', 'arca', 'sophie'];
                if (personalities.includes(personality)) {
                    this.producer.personality = personality;
                    
                    // Reset some parameters based on personality
                    switch (personality) {
                        case 'kanye':
                            this.bpm = 72;
                            this.swing = 0.15;
                            break;
                        case 'dilla':
                            this.bpm = 85;
                            this.swing = 0.25;
                            break;
                        case 'flylo':
                            this.bpm = 75;
                            this.swing = 0.1;
                            break;
                        case 'arca':
                            this.bpm = 130;
                            this.swing = 0;
                            break;
                        case 'sophie':
                            this.bpm = 140;
                            this.swing = 0;
                            break;
                    }
                    
                    this.status.textContent = `AI Personality: ${personality.toUpperCase()}`;
                    this.status.classList.add('visible');
                    setTimeout(() => this.status.classList.remove('visible'), 2000);
                    
                    if (this.producer.godMode) {
                        this.aiPersonality.textContent = `AI: ${personality.toUpperCase()}`;
                    }
                }
            }

            toggleEffectPad() {
                this.effectPadVisible = !this.effectPadVisible;
                
                if (this.effectPadVisible) {
                    this.effectPad.classList.add('visible');
                    
                    // Setup XY pad interaction
                    const updatePosition = (e) => {
                        const rect = this.effectPad.getBoundingClientRect();
                        this.effectX = (e.clientX - rect.left) / rect.width;
                        this.effectY = 1 - (e.clientY - rect.top) / rect.height; // Invert Y
                        
                        this.effectX = Math.max(0, Math.min(1, this.effectX));
                        this.effectY = Math.max(0, Math.min(1, this.effectY));
                        
                        this.effectDot.style.left = (this.effectX * 100) + '%';
                        this.effectDot.style.top = ((1 - this.effectY) * 100) + '%';
                        
                        this.updateXYEffects();
                    };
                    
                    this.effectPad.onmousedown = (e) => {
                        updatePosition(e);
                        this.effectPad.onmousemove = updatePosition;
                    };
                    
                    this.effectPad.onmouseup = () => {
                        this.effectPad.onmousemove = null;
                    };
                    
                    this.effectPad.onmouseleave = () => {
                        this.effectPad.onmousemove = null;
                    };
                    
                    this.status.textContent = 'Effect pad: X=Filter, Y=FX Send';
                } else {
                    this.effectPad.classList.remove('visible');
                    this.status.textContent = 'Effect pad off';
                }
                
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
            }

            tapTempo() {
                const now = performance.now();
                this.tapTimes.push(now);
                
                // Keep only last 8 taps
                if (this.tapTimes.length > 8) {
                    this.tapTimes.shift();
                }
                
                // Calculate tempo from tap intervals
                if (this.tapTimes.length > 1) {
                    let totalInterval = 0;
                    for (let i = 1; i < this.tapTimes.length; i++) {
                        totalInterval += this.tapTimes[i] - this.tapTimes[i-1];
                    }
                    
                    const avgInterval = totalInterval / (this.tapTimes.length - 1);
                    const newBPM = Math.round(60000 / avgInterval);
                    
                    if (newBPM > 40 && newBPM < 200) {
                        this.bpm = newBPM;
                        this.status.textContent = `Tempo: ${this.bpm} BPM`;
                        this.status.classList.add('visible');
                        setTimeout(() => this.status.classList.remove('visible'), 2000);
                    }
                }
            }

            setupControls() {
                // Keyboard controls
                document.addEventListener('keydown', (e) => {
                    if (e.repeat) return;
                    
                    switch (e.code) {
                        case 'Space':
                            e.preventDefault();
                            if (this.isInitialized) {
                                this.toggleRecording();
                            }
                            break;
                            
                        case 'KeyG':
                            if (this.isInitialized) {
                                this.toggleGodMode();
                            }
                            break;
                            
                        case 'KeyP':
                            if (this.isInitialized) {
                                this.togglePatternMode();
                            }
                            break;
                            
                        case 'KeyX':
                            if (this.isInitialized) {
                                this.toggleEffectPad();
                            }
                            break;
                            
                        case 'KeyR':
                            if (this.isInitialized) {
                                this.reverseMode = !this.reverseMode;
                                this.status.textContent = this.reverseMode ? 'Reverse mode ON' : 'Reverse mode OFF';
                                this.status.classList.add('visible');
                                setTimeout(() => this.status.classList.remove('visible'), 1000);
                            }
                            break;
                            
                        case 'KeyT':
                            if (this.isInitialized) {
                                this.tapTempo();
                            }
                            break;
                            
                        case 'KeyS':
                            if (this.isInitialized) {
                                this.stutterActive = true;
                            }
                            break;
                            
                        case 'Digit1':
                            if (this.isInitialized) {
                                this.setAIPersonality('kanye');
                            }
                            break;
                            
                        case 'Digit2':
                            if (this.isInitialized) {
                                this.setAIPersonality('dilla');
                            }
                            break;
                            
                        case 'Digit3':
                            if (this.isInitialized) {
                                this.setAIPersonality('flylo');
                            }
                            break;
                            
                        case 'Digit4':
                            if (this.isInitialized) {
                                this.setAIPersonality('arca');
                            }
                            break;
                            
                        case 'Digit5':
                            if (this.isInitialized) {
                                this.setAIPersonality('sophie');
                            }
                            break;
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    switch (e.code) {
                        case 'KeyS':
                            this.stutterActive = false;
                            break;
                    }
                });
                
                // Hold space to clear samples
                let spaceHoldTimer;
                document.addEventListener('keydown', (e) => {
                    if (e.code === 'Space' && !e.repeat && this.isInitialized) {
                        spaceHoldTimer = setTimeout(() => {
                            this.clearSamples();
                        }, 1000);
                    }
                });
                
                document.addEventListener('keyup', (e) => {
                    if (e.code === 'Space') {
                        clearTimeout(spaceHoldTimer);
                    }
                });
            }

            clearSamples() {
                this.loops.forEach(loop => {
                    if (loop.playing) {
                        loop.playing.stop();
                    }
                });
                this.loops = [];
                this.producer.memory = [];
                
                this.status.textContent = 'All samples cleared';
                this.status.classList.add('visible');
                setTimeout(() => this.status.classList.remove('visible'), 2000);
                
                // Reset some producer state
                this.producer.complexity = 0;
                this.producer.evolution = 0;
            }
        }

        // Initialize GUMP SUPREME
        const gump = new GUMP();
    </script>
</body>
</html>
