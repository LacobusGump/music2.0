<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GUMP: World Orchestra</title>
  <meta name="viewport" content="width=device-width,initial-scale=1.0">
  <style>
    html,body {height:100%;margin:0;padding:0;overflow:hidden;font-family:system-ui,sans-serif;}
    body {background:linear-gradient(135deg,#0a0e1a 0%,#1a1530 100%);transition:background 3s;}
    .intro {position:fixed;inset:0;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:20;transition:opacity 1s;}
    .intro-title {font-size:clamp(2rem,6vw,3rem);font-weight:900;color:#e5f8ff;text-shadow:0 0 40px #7fdaff;margin-bottom:1rem;animation:glow 3s ease-in-out infinite alternate;}
    .intro-subtitle {font-size:clamp(1rem,3vw,1.5rem);color:#b3e3f9;opacity:.8;margin-bottom:2rem;letter-spacing:1px;}
    .intro-credits {font-size:1rem;color:#8bb5d9;opacity:.6;margin-bottom:3rem;}
    .intro-btn {background:linear-gradient(45deg,#00cfff,#ed9fe7);color:#111;font-weight:700;padding:18px 40px;border-radius:30px;border:none;cursor:pointer;font-size:1.1rem;transition:transform .2s;}
    .intro-btn:hover {transform:scale(1.05);}
    @keyframes glow {0%{text-shadow:0 0 20px #7fdaff;}100%{text-shadow:0 0 60px #7fdaff,0 0 80px #b3e3f9;}}
    .app {position:fixed;inset:0;opacity:0;transition:opacity 1.5s;display:flex;align-items:center;justify-content:center;}
    .orb-container {position:relative;width:min(60vw,400px);height:min(60vw,400px);display:flex;align-items:center;justify-content:center;}
    .orb {width:120px;height:120px;border-radius:50%;background:radial-gradient(circle at 40% 30%,#4a90e2,#1a2040);box-shadow:0 0 80px rgba(74,144,226,.6);transition:all 2s;animation:pulse 4s ease-in-out infinite;}
    .orb-glow {position:absolute;inset:-100px;border-radius:50%;background:radial-gradient(circle,rgba(74,144,226,.3),transparent 70%);filter:blur(20px);animation:rotate 20s linear infinite;}
    @keyframes pulse {0%,100%{transform:scale(1);}50%{transform:scale(1.1);}}
    @keyframes rotate {0%{transform:rotate(0deg);}100%{transform:rotate(360deg);}}
    .cue {position:absolute;top:20px;left:50%;transform:translateX(-50%);color:#fff;font-size:1.1rem;font-weight:500;opacity:0;transition:opacity 1s;text-align:center;background:rgba(0,0,0,.5);padding:8px 16px;border-radius:20px;backdrop-filter:blur(10px);}
    .cue.show {opacity:1;}
    .status {position:absolute;bottom:20px;left:50%;transform:translateX(-50%);color:#aaa;font-size:.9rem;text-align:center;}
    .hidden {display:none!important;}
  </style>
</head>
<body>
  <div class="intro" id="intro">
    <div class="intro-title">GUMP: World Orchestra</div>
    <div class="intro-subtitle">Music from Your World</div>
    <div class="intro-credits">Enhanced by Claude • Inspired by James McCandless</div>
    <button class="intro-btn" id="introBtn">Enter the Symphony</button>
  </div>
  <div class="app hidden" id="app">
    <div class="orb-container">
      <div class="orb-glow"></div>
      <div class="orb" id="orb"></div>
    </div>
    <div class="cue" id="cue"></div>
    <div class="status" id="status">Initializing...</div>
  </div>
  <script>
    class WorldOrchestra {
      constructor() {
        this.ctx = null; this.voices = []; this.active = false;
        this.world = {lat:40.7128,lon:-74.0060,weather:'clear',temp:20,time:new Date(),city:'New York'};
        this.motion = {x:0,y:0,z:0,lastMove:0,energy:0,heading:0};
        this.music = {tempo:120,key:0,mode:'major',section:'intro',tick:0,bar:0};
        this.visual = {hue:220,sat:70,light:50,energy:0};
        this.init();
      }
      
      init() {
        document.getElementById('introBtn').onclick = () => this.start();
      }
      
      async start() {
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupReverb();
          this.hideIntro();
          this.getLocation();
          this.startMotion();
          this.startClock();
          this.active = true;
          this.updateStatus('Listening to your world...');
        } catch (e) {
          this.updateStatus('Audio initialization failed');
        }
      }
      
      hideIntro() {
        const intro = document.getElementById('intro');
        const app = document.getElementById('app');
        intro.style.opacity = '0';
        setTimeout(() => {
          intro.classList.add('hidden');
          app.classList.remove('hidden');
          app.style.opacity = '1';
        }, 1000);
      }
      
      setupReverb() {
        this.reverb = this.ctx.createConvolver();
        const length = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
          }
        }
        this.reverb.buffer = buffer;
        this.reverb.connect(this.ctx.destination);
      }
      
      async getLocation() {
        try {
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {timeout: 5000});
          });
          this.world.lat = pos.coords.latitude;
          this.world.lon = pos.coords.longitude;
          await this.getWeather();
          await this.getCity();
        } catch (e) {
          this.updateStatus('Using default location');
        }
      }
      
      async getWeather() {
        try {
          const url = `https://api.open-meteo.com/v1/forecast?latitude=${this.world.lat}&longitude=${this.world.lon}&current_weather=true&hourly=temperature_2m,weathercode&timezone=auto`;
          const response = await fetch(url);
          const data = await response.json();
          this.world.temp = Math.round(data.current_weather.temperature);
          this.world.weather = this.mapWeather(data.current_weather.weathercode);
        } catch (e) {
          this.world.weather = 'unknown';
        }
      }
      
      async getCity() {
        try {
          const url = `https://api.bigdatacloud.net/data/reverse-geocode-client?latitude=${this.world.lat}&longitude=${this.world.lon}&localityLanguage=en`;
          const response = await fetch(url);
          const data = await response.json();
          this.world.city = data.city || data.locality || 'Unknown';
        } catch (e) {
          this.world.city = 'Unknown';
        }
      }
      
      mapWeather(code) {
        const weatherMap = {
          0: 'clear', 1: 'partly_cloudy', 2: 'cloudy', 3: 'overcast',
          45: 'foggy', 48: 'foggy', 51: 'drizzle', 53: 'drizzle', 55: 'drizzle',
          61: 'rain', 63: 'rain', 65: 'rain', 71: 'snow', 73: 'snow', 75: 'snow',
          95: 'thunderstorm', 96: 'thunderstorm', 99: 'thunderstorm'
        };
        return weatherMap[code] || 'unknown';
      }
      
      startMotion() {
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
          DeviceMotionEvent.requestPermission().then(response => {
            if (response === 'granted') this.enableMotion();
          });
        } else {
          this.enableMotion();
        }
      }
      
      enableMotion() {
        window.addEventListener('devicemotion', (e) => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (acc) {
            const newX = acc.x || 0, newY = acc.y || 0, newZ = acc.z || 0;
            const dx = newX - this.motion.x, dy = newY - this.motion.y, dz = newZ - this.motion.z;
            this.motion.energy = Math.sqrt(dx*dx + dy*dy + dz*dz);
            this.motion.x = newX; this.motion.y = newY; this.motion.z = newZ;
            if (this.motion.energy > 0.5) this.motion.lastMove = Date.now();
          }
        });
      }
      
      startClock() {
        setInterval(() => {
          if (!this.active) return;
          this.updateWorld();
          this.updateMusic();
          this.generateMusic();
          this.updateVisuals();
          this.music.tick = (this.music.tick + 1) % 16;
          if (this.music.tick === 0) this.music.bar++;
        }, 60000 / this.music.tempo / 4);
      }
      
      updateWorld() {
        this.world.time = new Date();
        const hour = this.world.time.getHours();
        this.world.period = hour < 6 ? 'night' : hour < 12 ? 'morning' : hour < 18 ? 'day' : 'evening';
        this.world.season = this.getSeason();
        this.world.isWeekend = [0, 6].includes(this.world.time.getDay());
      }
      
      getSeason() {
        const month = this.world.time.getMonth();
        if (month < 3 || month === 11) return 'winter';
        if (month < 6) return 'spring';
        if (month < 9) return 'summer';
        return 'autumn';
      }
      
      updateMusic() {
        const timeSinceMove = Date.now() - this.motion.lastMove;
        const isStill = timeSinceMove > 3000;
        
        // Tempo based on motion and time
        this.music.tempo = 60 + (this.motion.energy * 30) + (this.world.period === 'night' ? -10 : 10);
        
        // Key based on weather and location
        const weatherKeys = {clear: 0, rain: 3, snow: 7, cloudy: 2, thunderstorm: 10};
        this.music.key = (weatherKeys[this.world.weather] || 0) + (this.world.temp > 20 ? 2 : 0);
        
        // Mode based on time and weather
        this.music.mode = (this.world.period === 'night' || this.world.weather === 'rain') ? 'minor' : 'major';
        
        // Section based on motion
        this.music.section = isStill ? 'ambient' : this.motion.energy > 2 ? 'energetic' : 'flowing';
        
        // Show contextual cues
        if (this.music.tick === 0 && this.music.bar % 8 === 0) {
          this.showCue();
        }
      }
      
      showCue() {
        const cues = [
          `${this.world.period.charAt(0).toUpperCase() + this.world.period.slice(1)} ${this.world.weather} • ${this.world.city}`,
          `${this.world.temp}°C • ${this.music.section} • ${this.music.mode}`,
          `${this.world.season} vibes • ${this.world.isWeekend ? 'Weekend' : 'Weekday'}`,
          `Motion: ${this.motion.energy.toFixed(1)} • Key: ${this.music.key}`
        ];
        
        const cue = document.getElementById('cue');
        cue.textContent = cues[Math.floor(Math.random() * cues.length)];
        cue.classList.add('show');
        setTimeout(() => cue.classList.remove('show'), 3000);
      }
      
      generateMusic() {
        this.clearVoices();
        
        if (this.music.section === 'ambient') {
          this.generateAmbient();
        } else {
          this.generateRhythmic();
        }
      }
      
      generateAmbient() {
        if (this.music.tick % 8 === 0) {
          this.playPad([0, 2, 4, 7], 0.08, 4);
        }
        if (this.music.tick === 6 && Math.random() < 0.3) {
          this.playBell();
        }
      }
      
      generateRhythmic() {
        // Drums
        if (this.music.tick % 4 === 0) this.playKick();
        if (this.music.tick % 8 === 4) this.playSnare();
        if (this.music.tick % 2 === 0 && this.motion.energy > 1) this.playHat();
        
        // Harmony
        if (this.music.tick % 4 === 0) {
          const chord = this.getChord();
          this.playPad(chord, 0.05, 2);
        }
        
        // Bass
        if (this.music.tick % 2 === 0) {
          this.playBass();
        }
      }
      
      getChord() {
        const progressions = {
          major: [[0,2,4],[3,5,7],[0,2,4],[1,3,5]],
          minor: [[0,2,4],[1,3,5],[0,2,4],[3,5,7]]
        };
        const prog = progressions[this.music.mode];
        return prog[this.music.bar % 4].map(n => n + this.music.key);
      }
      
      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + 0.3);
        this.voices.push({osc, gain});
      }
      
      playSnare() {
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        source.buffer = buffer;
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        source.connect(filter).connect(gain).connect(this.ctx.destination);
        source.start(); source.stop(this.ctx.currentTime + 0.1);
        this.voices.push({osc: source, gain});
      }
      
      playHat() {
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        source.buffer = buffer;
        filter.type = 'highpass';
        filter.frequency.value = 8000;
        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
        source.connect(filter).connect(gain).connect(this.ctx.destination);
        source.start(); source.stop(this.ctx.currentTime + 0.05);
        this.voices.push({osc: source, gain});
      }
      
      playPad(chord, volume, duration) {
        const now = this.ctx.currentTime;
        chord.forEach((note, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const freq = 220 * Math.pow(2, note / 12);
          osc.frequency.value = freq;
          osc.type = this.music.section === 'ambient' ? 'sine' : 'triangle';
          gain.gain.setValueAtTime(volume, now);
          gain.gain.linearRampToValueAtTime(volume * 0.7, now + duration * 0.8);
          gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
          osc.connect(gain).connect(this.reverb);
          osc.start(now + i * 0.02);
          osc.stop(now + duration);
          this.voices.push({osc, gain});
        });
      }
      
      playBass() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const freq = 110 * Math.pow(2, this.music.key / 12);
        osc.frequency.value = freq;
        osc.type = 'sawtooth';
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        osc.connect(gain).connect(this.ctx.destination);
        osc.start(); osc.stop(this.ctx.currentTime + 0.2);
        this.voices.push({osc, gain});
      }
      
      playBell() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.frequency.value = 880 + Math.random() * 220;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        osc.connect(gain).connect(this.reverb);
        osc.start(); osc.stop(this.ctx.currentTime + 2);
        this.voices.push({osc, gain});
      }
      
      clearVoices() {
        this.voices.forEach(voice => {
          try {
            voice.gain.gain.cancelScheduledValues(this.ctx.currentTime);
            voice.gain.gain.setValueAtTime(0.001, this.ctx.currentTime);
            voice.osc.stop(this.ctx.currentTime + 0.1);
          } catch (e) {}
        });
        this.voices = [];
      }
      
      updateVisuals() {
        const orb = document.getElementById('orb');
        
        // Color based on world state
        this.visual.hue = 220 + (this.world.temp * 2) + (this.music.key * 10);
        this.visual.sat = 60 + (this.motion.energy * 10);
        this.visual.light = 40 + (this.world.period === 'day' ? 20 : 0);
        this.visual.energy = this.motion.energy;
        
        // Weather colors
        const weatherColors = {
          clear: 220, rain: 240, snow: 200, cloudy: 260, thunderstorm: 280, foggy: 300
        };
        this.visual.hue = weatherColors[this.world.weather] || 220;
        
        orb.style.background = `radial-gradient(circle at 40% 30%, hsl(${this.visual.hue}, ${this.visual.sat}%, ${this.visual.light + 20}%), hsl(${this.visual.hue}, ${this.visual.sat}%, ${this.visual.light - 20}%))`;
        orb.style.boxShadow = `0 0 ${60 + this.visual.energy * 20}px hsla(${this.visual.hue}, ${this.visual.sat}%, ${this.visual.light}%, 0.6)`;
        
        // Background gradient
        document.body.style.background = `linear-gradient(135deg, hsl(${this.visual.hue}, 30%, 8%), hsl(${this.visual.hue + 30}, 25%, 12%))`;
      }
      
      updateStatus(message) {
        document.getElementById('status').textContent = message;
      }
    }
    
    new WorldOrchestra();
  </script>
</body>
</html>
