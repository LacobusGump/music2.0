<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <title>GUMP: Environmental Resonance Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 3s cubic-bezier(0.25, 0.1, 0.25, 1);
    }
    
    .portal {
      width: 300px;
      height: 300px;
      position: relative;
      cursor: pointer;
      transition: all 0.6s ease;
    }
    
    .portal-ring {
      position: absolute;
      border-radius: 50%;
      border: 2px solid rgba(255,255,255,0.2);
      inset: 0;
      animation: rotate 20s linear infinite;
    }
    
    .portal-ring:nth-child(2) {
      inset: 20px;
      animation-duration: 15s;
      animation-direction: reverse;
    }
    
    .portal-ring:nth-child(3) {
      inset: 40px;
      animation-duration: 10s;
    }
    
    .portal-core {
      position: absolute;
      inset: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.9) 0%, rgba(255,255,255,0.1) 50%, transparent 70%);
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 300;
      letter-spacing: 4px;
      font-size: 18px;
      backdrop-filter: blur(20px);
      transition: all 0.3s ease;
      box-shadow: 0 0 60px rgba(255,255,255,0.5);
    }
    
    .portal:hover .portal-core {
      transform: scale(1.1);
      box-shadow: 0 0 100px rgba(255,255,255,0.8);
    }
    
    @keyframes rotate {
      from { transform: rotate(0deg); }
      to { transform: rotate(360deg); }
    }
    
    .universe {
      position: fixed;
      inset: 0;
      opacity: 0;
      transition: opacity 2s ease;
      pointer-events: none;
    }
    
    .universe.active {
      opacity: 1;
      pointer-events: auto;
    }
    
    .consciousness {
      position: absolute;
      width: 60px;
      height: 60px;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }
    
    .consciousness-core {
      width: 100%;
      height: 100%;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, transparent 70%);
      box-shadow: 0 0 100px rgba(255,255,255,0.8);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .consciousness.resonating .consciousness-core {
      animation: resonate 0.3s ease-out;
    }
    
    @keyframes resonate {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.5); filter: brightness(2); }
    }
    
    .env-data {
      position: fixed;
      top: 20px;
      left: 20px;
      font-size: 11px;
      font-family: 'Courier New', monospace;
      letter-spacing: 1px;
      opacity: 0.8;
      background: rgba(0,0,0,0.5);
      padding: 15px;
      border-radius: 10px;
      backdrop-filter: blur(10px);
      max-width: 200px;
    }
    
    .env-item {
      margin: 8px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .env-icon {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
    }
    
    .env-value {
      flex: 1;
      text-align: right;
      color: rgba(255,255,255,0.9);
    }
    
    .magic-indicator {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 12px;
      letter-spacing: 3px;
      text-transform: uppercase;
      opacity: 0;
      transition: all 1s ease;
    }
    
    .magic-indicator.visible {
      opacity: 0.8;
    }
    
    .harmony-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 150px;
      pointer-events: none;
    }
    
    .harmony-wave {
      position: absolute;
      bottom: 0;
      width: 100%;
      height: 100%;
      opacity: 0.3;
    }
    
    .particle-field {
      position: fixed;
      inset: 0;
      pointer-events: none;
    }
    
    .env-particle {
      position: absolute;
      width: 4px;
      height: 4px;
      border-radius: 50%;
      background: rgba(255,255,255,0.6);
      animation: drift 20s linear infinite;
    }
    
    @keyframes drift {
      from {
        transform: translate(0, 100vh) scale(0);
        opacity: 0;
      }
      10% {
        opacity: 1;
      }
      90% {
        opacity: 1;
      }
      to {
        transform: translate(0, -100vh) scale(1.5);
        opacity: 0;
      }
    }
    
    .permission-modal {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      backdrop-filter: blur(10px);
    }
    
    .permission-modal.show {
      display: flex;
    }
    
    .permission-content {
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 20px;
      padding: 40px;
      text-align: center;
      max-width: 400px;
    }
    
    .permission-content h2 {
      margin-bottom: 20px;
      font-weight: 300;
      letter-spacing: 2px;
    }
    
    .permission-content p {
      margin-bottom: 30px;
      opacity: 0.8;
      line-height: 1.6;
    }
    
    .permission-btn {
      background: rgba(255,255,255,0.1);
      border: 1px solid rgba(255,255,255,0.3);
      color: white;
      padding: 15px 40px;
      border-radius: 30px;
      cursor: pointer;
      font-size: 16px;
      letter-spacing: 2px;
      transition: all 0.3s ease;
    }
    
    .permission-btn:hover {
      background: rgba(255,255,255,0.2);
      transform: scale(1.05);
    }
    
    .hidden { display: none !important; }
    
    @media (max-width: 768px) {
      .portal { width: 250px; height: 250px; }
      .env-data { font-size: 10px; padding: 10px; }
      .permission-content { padding: 30px; margin: 20px; }
    }
  </style>
</head>
<body>
  <div class="portal" id="portal">
    <div class="portal-ring"></div>
    <div class="portal-ring"></div>
    <div class="portal-ring"></div>
    <div class="portal-core" id="portalCore">SENSE</div>
  </div>
  
  <div class="universe" id="universe">
    <div class="consciousness" id="consciousness">
      <div class="consciousness-core"></div>
    </div>
    
    <div class="env-data" id="envData">
      <div class="env-item">
        <div class="env-icon">üåç</div>
        <div class="env-value" id="locationVal">detecting...</div>
      </div>
      <div class="env-item">
        <div class="env-icon">üå°Ô∏è</div>
        <div class="env-value" id="tempVal">--¬∞</div>
      </div>
      <div class="env-item">
        <div class="env-icon">‚è∞</div>
        <div class="env-value" id="timeVal">--:--</div>
      </div>
      <div class="env-item">
        <div class="env-icon">üíì</div>
        <div class="env-value" id="pulseVal">-- bpm</div>
      </div>
      <div class="env-item">
        <div class="env-icon">üé≠</div>
        <div class="env-value" id="moodVal">sensing...</div>
      </div>
    </div>
    
    <div class="harmony-viz" id="harmonyViz">
      <canvas class="harmony-wave" id="waveCanvas"></canvas>
    </div>
    
    <div class="magic-indicator" id="magicIndicator">ENVIRONMENTAL RESONANCE ACTIVE</div>
    
    <div class="particle-field" id="particleField"></div>
  </div>
  
  <div class="permission-modal" id="permissionModal">
    <div class="permission-content">
      <h2>ENABLE SENSING</h2>
      <p>This experience reads your environment - location, time, weather, and movement - to create music that resonates with your unique moment in spacetime.</p>
      <button class="permission-btn" id="enableBtn">ACTIVATE SENSORS</button>
    </div>
  </div>

  <script>
    // Environmental Resonance Engine
    class MagicMusicEngine {
      constructor() {
        this.active = false;
        this.ctx = null;
        
        // Environmental data
        this.env = {
          location: { lat: null, lon: null, city: 'Unknown' },
          time: { hour: 0, minute: 0, dayOfWeek: 0, season: 'unknown' },
          weather: { temp: 20, condition: 'clear', pressure: 1013, humidity: 50 },
          motion: { intensity: 0, pattern: 'still', direction: 0 },
          biorhythm: { physical: 0, emotional: 0, intellectual: 0 },
          mood: 'neutral',
          activity: 'resting'
        };
        
        // Music state
        this.key = 'C';
        this.mode = 'major';
        this.bpm = 60;
        this.intensity = 0;
        this.harmonic = 1;
        this.evolution = 0;
        
        // Audio nodes
        this.nodes = {};
        this.voices = new Map();
        this.maxVoices = 32;
        
        // Scales and harmony
        this.scales = {
          major: [0, 2, 4, 5, 7, 9, 11],
          minor: [0, 2, 3, 5, 7, 8, 10],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          aeolian: [0, 2, 3, 5, 7, 8, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10]
        };
        
        // Sensor data
        this.sensors = {
          motion: { x: 0, y: 0, z: 0 },
          orientation: { alpha: 0, beta: 0, gamma: 0 },
          touch: { x: 50, y: 50 },
          mouse: { x: 50, y: 50 }
        };
        
        // Initialize
        this.elements = {};
        this.init();
      }
      
      init() {
        // Get DOM elements
        ['portal', 'portalCore', 'universe', 'consciousness', 'envData',
         'locationVal', 'tempVal', 'timeVal', 'pulseVal', 'moodVal',
         'harmonyViz', 'waveCanvas', 'magicIndicator', 'particleField',
         'permissionModal', 'enableBtn'].forEach(id => {
          this.elements[id] = document.getElementById(id);
        });
        
        // Setup canvas
        this.setupCanvas();
        
        // Event listeners
        this.elements.portal.addEventListener('click', () => this.start());
        this.elements.enableBtn.addEventListener('click', () => this.enableSensors());
        
        // Start environmental monitoring
        this.monitorEnvironment();
      }
      
      setupCanvas() {
        const canvas = this.elements.waveCanvas;
        const resize = () => {
          canvas.width = window.innerWidth;
          canvas.height = 150;
        };
        resize();
        window.addEventListener('resize', resize);
        
        this.waveCtx = canvas.getContext('2d');
        this.waveData = new Array(128).fill(0);
      }
      
      async start() {
        if (this.active) return;
        
        // Check for permissions on mobile
        if (this.needsPermissions()) {
          this.elements.permissionModal.classList.add('show');
          return;
        }
        
        await this.initAudio();
      }
      
      needsPermissions() {
        return typeof DeviceMotionEvent?.requestPermission === 'function' ||
               typeof DeviceOrientationEvent?.requestPermission === 'function';
      }
      
      async enableSensors() {
        try {
          // Request permissions
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            await DeviceMotionEvent.requestPermission();
          }
          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }
          
          this.elements.permissionModal.classList.remove('show');
          await this.initAudio();
        } catch (e) {
          console.error('Permission denied:', e);
        }
      }
      
      async initAudio() {
        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          if (this.ctx.state === 'suspended') await this.ctx.resume();
          
          this.setupAudioGraph();
          this.setupSensors();
          
          // Transition UI
          this.elements.portal.style.transform = 'scale(0)';
          this.elements.portal.style.opacity = '0';
          setTimeout(() => {
            this.elements.portal.classList.add('hidden');
            this.elements.universe.classList.add('active');
          }, 600);
          
          this.active = true;
          this.startGenerating();
          this.animate();
          
          // Show magic indicator
          setTimeout(() => {
            this.elements.magicIndicator.classList.add('visible');
            setTimeout(() => {
              this.elements.magicIndicator.classList.remove('visible');
            }, 3000);
          }, 2000);
          
        } catch (e) {
          console.error('Audio init failed:', e);
        }
      }
      
      setupAudioGraph() {
        // Master chain
        this.nodes.analyser = this.ctx.createAnalyser();
        this.nodes.analyser.fftSize = 256;
        this.analyserData = new Uint8Array(this.nodes.analyser.frequencyBinCount);
        
        this.nodes.compressor = this.ctx.createDynamicsCompressor();
        this.nodes.compressor.threshold.value = -24;
        this.nodes.compressor.knee.value = 30;
        this.nodes.compressor.ratio.value = 12;
        this.nodes.compressor.attack.value = 0.003;
        this.nodes.compressor.release.value = 0.25;
        
        this.nodes.limiter = this.ctx.createDynamicsCompressor();
        this.nodes.limiter.threshold.value = -6;
        this.nodes.limiter.knee.value = 3;
        this.nodes.limiter.ratio.value = 20;
        this.nodes.limiter.attack.value = 0.001;
        this.nodes.limiter.release.value = 0.01;
        
        this.nodes.masterGain = this.ctx.createGain();
        this.nodes.masterGain.gain.value = 0.7;
        
        // Spatial reverb
        this.nodes.convolver = this.ctx.createConvolver();
        this.createReverbImpulse();
        
        // Delay network
        this.nodes.delay = this.ctx.createDelay(1);
        this.nodes.delay.delayTime.value = 0.375;
        this.nodes.delayFeedback = this.ctx.createGain();
        this.nodes.delayFeedback.gain.value = 0.4;
        this.nodes.delayMix = this.ctx.createGain();
        this.nodes.delayMix.gain.value = 0.3;
        
        // Connect delay
        this.nodes.delay.connect(this.nodes.delayFeedback);
        this.nodes.delayFeedback.connect(this.nodes.delay);
        this.nodes.delay.connect(this.nodes.delayMix);
        
        // Master chain
        this.nodes.compressor.connect(this.nodes.limiter);
        this.nodes.convolver.connect(this.nodes.limiter);
        this.nodes.delayMix.connect(this.nodes.limiter);
        this.nodes.limiter.connect(this.nodes.analyser);
        this.nodes.analyser.connect(this.nodes.masterGain);
        this.nodes.masterGain.connect(this.ctx.destination);
      }
      
      createReverbImpulse() {
        const length = this.ctx.sampleRate * 4;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let channel = 0; channel < 2; channel++) {
          const data = impulse.getChannelData(channel);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, 2);
            data[i] = (Math.random() * 2 - 1) * decay * 0.3;
          }
        }
        
        this.nodes.convolver.buffer = impulse;
      }
      
      setupSensors() {
        // Motion detection
        window.addEventListener('devicemotion', e => {
          if (!e.accelerationIncludingGravity) return;
          this.sensors.motion = {
            x: e.accelerationIncludingGravity.x || 0,
            y: e.accelerationIncludingGravity.y || 0,
            z: e.accelerationIncludingGravity.z || 0
          };
          this.updateMotion();
        });
        
        // Orientation
        window.addEventListener('deviceorientation', e => {
          this.sensors.orientation = {
            alpha: e.alpha || 0,
            beta: e.beta || 0,
            gamma: e.gamma || 0
          };
        });
        
        // Touch
        window.addEventListener('touchmove', e => {
          const touch = e.touches[0];
          this.sensors.touch = {
            x: (touch.clientX / window.innerWidth) * 100,
            y: (touch.clientY / window.innerHeight) * 100
          };
          this.updatePosition();
        }, { passive: true });
        
        // Mouse fallback
        window.addEventListener('mousemove', e => {
          this.sensors.mouse = {
            x: (e.clientX / window.innerWidth) * 100,
            y: (e.clientY / window.innerHeight) * 100
          };
          if (!('ontouchstart' in window)) {
            this.sensors.touch = this.sensors.mouse;
            this.updatePosition();
          }
        });
      }
      
      monitorEnvironment() {
        // Time monitoring
        const updateTime = () => {
          const now = new Date();
          this.env.time = {
            hour: now.getHours(),
            minute: now.getMinutes(),
            dayOfWeek: now.getDay(),
            season: this.getSeason(now)
          };
          this.updateTimeDisplay();
        };
        updateTime();
        setInterval(updateTime, 1000);
        
        // Get location and weather
        this.getLocationAndWeather();
        
        // Biorhythm calculation
        this.calculateBiorhythms();
      }
      
      getSeason(date) {
        const month = date.getMonth();
        if (month >= 2 && month <= 4) return 'spring';
        if (month >= 5 && month <= 7) return 'summer';
        if (month >= 8 && month <= 10) return 'autumn';
        return 'winter';
      }
      
      async getLocationAndWeather() {
        try {
          // Get location
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true
            });
          });
          
          this.env.location.lat = pos.coords.latitude;
          this.env.location.lon = pos.coords.longitude;
          
          // Get weather
          const weatherUrl = `https://api.open-meteo.com/v1/forecast?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&current_weather=true`;
          const response = await fetch(weatherUrl);
          const data = await response.json();
          
          if (data.current_weather) {
            this.env.weather = {
              temp: data.current_weather.temperature,
              condition: this.getWeatherCondition(data.current_weather.weathercode),
              pressure: 1013, // Default
              humidity: 50 // Default
            };
            this.updateWeatherDisplay();
          }
          
          // Reverse geocode for city
          this.elements.locationVal.textContent = `${pos.coords.latitude.toFixed(2)}¬∞, ${pos.coords.longitude.toFixed(2)}¬∞`;
          
        } catch (e) {
          console.log('Location/weather fetch failed:', e);
          this.elements.locationVal.textContent = 'Local';
        }
      }
      
      getWeatherCondition(code) {
        if (code <= 3) return 'clear';
        if (code <= 48) return 'cloudy';
        if (code <= 67) return 'rainy';
        if (code <= 77) return 'snowy';
        if (code <= 82) return 'stormy';
        return 'unknown';
      }
      
      calculateBiorhythms() {
        // Simplified biorhythm based on time of day
        const hour = new Date().getHours();
        const dayProgress = hour / 24;
        
        this.env.biorhythm = {
          physical: Math.sin(dayProgress * Math.PI * 2) * 0.5 + 0.5,
          emotional: Math.sin((dayProgress + 0.33) * Math.PI * 2) * 0.5 + 0.5,
          intellectual: Math.sin((dayProgress + 0.66) * Math.PI * 2) * 0.5 + 0.5
        };
        
        // Determine mood
        const avg = (this.env.biorhythm.physical + this.env.biorhythm.emotional + this.env.biorhythm.intellectual) / 3;
        if (avg > 0.7) this.env.mood = 'energetic';
        else if (avg > 0.5) this.env.mood = 'balanced';
        else if (avg > 0.3) this.env.mood = 'calm';
        else this.env.mood = 'contemplative';
        
        this.elements.moodVal.textContent = this.env.mood;
      }
      
      updateMotion() {
        const m = this.sensors.motion;
        const intensity = Math.sqrt(m.x * m.x + m.y * m.y + m.z * m.z) / 10;
        this.env.motion.intensity = this.env.motion.intensity * 0.9 + intensity * 0.1;
        
        // Determine activity
        if (this.env.motion.intensity > 2) this.env.activity = 'active';
        else if (this.env.motion.intensity > 0.5) this.env.activity = 'moving';
        else this.env.activity = 'resting';
        
        // Update BPM
        const pulseBPM = 60 + this.env.motion.intensity * 30;
        this.elements.pulseVal.textContent = Math.round(pulseBPM) + ' bpm';
      }
      
      updatePosition() {
        const pos = this.sensors.touch;
        this.elements.consciousness.style.left = pos.x + '%';
        this.elements.consciousness.style.top = pos.y + '%';
      }
      
      updateTimeDisplay() {
        const t = this.env.time;
        this.elements.timeVal.textContent = 
          `${t.hour.toString().padStart(2, '0')}:${t.minute.toString().padStart(2, '0')}`;
      }
      
      updateWeatherDisplay() {
        this.elements.tempVal.textContent = Math.round(this.env.weather.temp) + '¬∞';
      }
      
      startGenerating() {
        // Main generative loop
        this.generate();
        
        // Harmonic evolution
        setInterval(() => this.evolveHarmony(), 8000);
        
        // Environmental particles
        setInterval(() => this.createParticle(), 2000);
      }
      
      generate() {
        if (!this.active) return;
        
        // Calculate musical parameters from environment
        this.calculateMusicalParameters();
        
        // Generate sounds based on environment
        this.generateEnvironmentalSounds();
        
        // Schedule next generation
        const interval = (60 / this.bpm) * 1000 / 4;
        setTimeout(() => this.generate(), interval);
      }
      
      calculateMusicalParameters() {
        // Time-based key selection
        const hour = this.env.time.hour;
        const keys = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'Db', 'Ab', 'Eb', 'Bb', 'F'];
        this.key = keys[hour % 12];
        
        // Weather-based mode
        switch(this.env.weather.condition) {
          case 'clear': this.mode = 'lydian'; break;
          case 'cloudy': this.mode = 'dorian'; break;
          case 'rainy': this.mode = 'aeolian'; break;
          case 'snowy': this.mode = 'major'; break;
          case 'stormy': this.mode = 'phrygian'; break;
          default: this.mode = 'major';
        }
        
        // Activity-based BPM
        const baseBPM = 60 + this.env.weather.temp * 1.5;
        const activityMultiplier = this.env.activity === 'active' ? 1.5 : 
                                  this.env.activity === 'moving' ? 1.2 : 1;
        this.bpm = baseBPM * activityMultiplier * (0.5 + this.env.biorhythm.physical);
        this.bpm = Math.max(40, Math.min(160, this.bpm));
        
        // Mood-based intensity
        this.intensity = this.env.mood === 'energetic' ? 0.8 :
                        this.env.mood === 'balanced' ? 0.5 :
                        this.env.mood === 'calm' ? 0.3 : 0.2;
        
        // Evolution
        this.evolution = (this.evolution + 0.001) % 1;
      }
      
      generateEnvironmentalSounds() {
        const scale = this.scales[this.mode];
        const rootFreq = this.noteToFreq(this.key, 2);
        
        // Heartbeat (always present)
        if (Math.random() < 0.25) {
          this.playHeartbeat(rootFreq);
        }
        
        // Environmental layers based on conditions
        if (this.env.time.hour >= 6 && this.env.time.hour <= 18) {
          // Daytime sounds
          if (Math.random() < 0.3) this.playDayBird(scale, rootFreq);
          if (Math.random() < 0.2 && this.env.weather.condition === 'clear') {
            this.playWarmth(scale, rootFreq);
          }
        } else {
          // Nighttime sounds
          if (Math.random() < 0.2) this.playNightAmbience(scale, rootFreq);
          if (Math.random() < 0.15) this.playStars(scale, rootFreq);
        }
        
        // Weather sounds
        switch(this.env.weather.condition) {
          case 'rainy':
            if (Math.random() < 0.4) this.playRainDrop(scale, rootFreq);
            break;
          case 'stormy':
            if (Math.random() < 0.1) this.playThunder(rootFreq);
            break;
          case 'snowy':
            if (Math.random() < 0.3) this.playCrystal(scale, rootFreq);
            break;
        }
        
        // Motion-reactive sounds
        if (this.env.motion.intensity > 0.5) {
          if (Math.random() < this.env.motion.intensity * 0.3) {
            this.playMotionWave(scale, rootFreq);
          }
        }
        
        // Biorhythm harmonics
        if (this.env.biorhythm.emotional > 0.7 && Math.random() < 0.2) {
          this.playEmotionalSwell(scale, rootFreq);
        }
      }
      
      playHeartbeat(rootFreq) {
        const voice = this.createVoice('heartbeat', 0.8);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(rootFreq / 4, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(rootFreq / 8, this.ctx.currentTime + 0.3);
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.6 * this.intensity, this.ctx.currentTime + 0.02);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        gain.gain.value = 0.5;
        
        osc.connect(env).connect(gain).connect(this.nodes.compressor);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.8);
        
        // Visual pulse
        this.elements.consciousness.classList.add('resonating');
        setTimeout(() => this.elements.consciousness.classList.remove('resonating'), 300);
      }
      
      playDayBird(scale, rootFreq) {
        const voice = this.createVoice('bird', 1.5);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        
        const note = scale[Math.floor(Math.random() * scale.length)];
        const freq = rootFreq * Math.pow(2, note / 12 + 2);
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 1.5, this.ctx.currentTime + 0.1);
        osc.frequency.exponentialRampToValueAtTime(freq * 1.2, this.ctx.currentTime + 0.3);
        
        filter.type = 'bandpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.3 * this.intensity, this.ctx.currentTime + 0.05);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.convolver);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
      }
      
      playWarmth(scale, rootFreq) {
        const voice = this.createVoice('warmth', 4);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        
        const note = scale[0]; // Root
        const freq = rootFreq * 2;
        
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 2);
        filter.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 4);
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.2 * this.intensity, this.ctx.currentTime + 1);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
        
        gain.gain.value = 0.3;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.convolver);
        osc.start();
        osc.stop(this.ctx.currentTime + 4);
      }
      
      playNightAmbience(scale, rootFreq) {
        const voice = this.createVoice('night', 6);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        const note = scale[4]; // Fifth
        const freq = rootFreq * Math.pow(2, note / 12 - 1);
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        // LFO for mysterious wobble
        lfo.type = 'sine';
        lfo.frequency.value = 0.2;
        lfoGain.gain.value = 10;
        lfo.connect(lfoGain).connect(osc.frequency);
        
        filter.type = 'lowpass';
        filter.frequency.value = 400;
        filter.Q.value = 10;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.15 * this.intensity, this.ctx.currentTime + 2);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.convolver);
        lfo.start();
        osc.start();
        osc.stop(this.ctx.currentTime + 6);
        lfo.stop(this.ctx.currentTime + 6);
      }
      
      playStars(scale, rootFreq) {
        // Multiple high frequency sparkles
        for (let i = 0; i < 3; i++) {
          setTimeout(() => {
            const voice = this.createVoice('star', 0.5);
            if (!voice) return;
            
            const { osc, gain, env } = voice;
            const note = scale[Math.floor(Math.random() * scale.length)];
            const freq = rootFreq * Math.pow(2, note / 12 + 3);
            
            osc.type = 'sine';
            osc.frequency.value = freq * (1 + Math.random() * 0.1);
            
            env.gain.setValueAtTime(0, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.1 * this.intensity, this.ctx.currentTime + 0.01);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
            
            gain.gain.value = 0.3;
            
            osc.connect(env).connect(gain).connect(this.nodes.delay);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.5);
          }, i * 100);
        }
      }
      
      playRainDrop(scale, rootFreq) {
        const voice = this.createVoice('rain', 0.3);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        
        const note = scale[Math.floor(Math.random() * scale.length)];
        const freq = rootFreq * Math.pow(2, note / 12 + 1);
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq * 4, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 0.3);
        
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1;
        
        env.gain.setValueAtTime(0.2 * this.intensity, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        gain.gain.value = 0.5;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.convolver);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
      }
      
      playThunder(rootFreq) {
        const voice = this.createVoice('thunder', 2);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = rootFreq / 8;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(50, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(500, this.ctx.currentTime + 0.2);
        filter.frequency.exponentialRampToValueAtTime(50, this.ctx.currentTime + 2);
        filter.Q.value = 10;
        
        env.gain.setValueAtTime(0.5 * this.intensity, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        gain.gain.value = 0.6;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.compressor);
        osc.start();
        osc.stop(this.ctx.currentTime + 2);
      }
      
      playCrystal(scale, rootFreq) {
        const voice = this.createVoice('crystal', 3);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        
        const note = scale[Math.floor(Math.random() * scale.length)];
        const freq = rootFreq * Math.pow(2, note / 12 + 2);
        
        osc.type = 'triangle';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = 20;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.15 * this.intensity, this.ctx.currentTime + 0.5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.convolver);
        osc.start();
        osc.stop(this.ctx.currentTime + 3);
      }
      
      playMotionWave(scale, rootFreq) {
        const voice = this.createVoice('motion', 1);
        if (!voice) return;
        
        const { osc, gain, env } = voice;
        const filter = this.ctx.createBiquadFilter();
        
        const note = scale[Math.floor(this.env.motion.intensity * scale.length) % scale.length];
        const freq = rootFreq * Math.pow(2, note / 12);
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        osc.detune.value = this.env.motion.intensity * 10;
        
        filter.type = 'lowpass';
        filter.frequency.value = 500 + this.env.motion.intensity * 500;
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.3 * this.env.motion.intensity, this.ctx.currentTime + 0.1);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        
        gain.gain.value = 0.5;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.nodes.compressor);
        osc.start();
        osc.stop(this.ctx.currentTime + 1);
      }
      
      playEmotionalSwell(scale, rootFreq) {
        // Chord based on emotional state
        const chord = [0, 4, 7]; // Major triad
        
        chord.forEach((interval, i) => {
          const voice = this.createVoice('emotion', 5);
          if (!voice) return;
          
          const { osc, gain, env } = voice;
          const note = scale[(interval + i) % scale.length];
          const freq = rootFreq * Math.pow(2, note / 12 + 1);
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(
            0.2 * this.intensity * this.env.biorhythm.emotional, 
            this.ctx.currentTime + 2
          );
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 5);
          
          gain.gain.value = 0.3;
          
          osc.connect(env).connect(gain).connect(this.nodes.convolver);
          osc.start();
          osc.stop(this.ctx.currentTime + 5);
        });
      }
      
      createVoice(type, duration) {
        // Voice management
        if (this.voices.size >= this.maxVoices) {
          const oldest = this.voices.entries().next().value;
          if (oldest) {
            oldest[1].osc.stop();
            this.voices.delete(oldest[0]);
          }
        }
        
        const id = Date.now() + Math.random();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        const voice = { osc, gain, env, type, startTime: this.ctx.currentTime };
        this.voices.set(id, voice);
        
        // Schedule cleanup
        setTimeout(() => {
          this.voices.delete(id);
        }, duration * 1000 + 100);
        
        return voice;
      }
      
      noteToFreq(key, octave) {
        const notes = { 
          'C': 261.63, 'C#': 277.18, 'Db': 277.18, 'D': 293.66, 
          'D#': 311.13, 'Eb': 311.13, 'E': 329.63, 'F': 349.23,
          'F#': 369.99, 'Gb': 369.99, 'G': 392.00, 'G#': 415.30,
          'Ab': 415.30, 'A': 440.00, 'A#': 466.16, 'Bb': 466.16, 'B': 493.88
        };
        const baseFreq = notes[key] || 261.63;
        return baseFreq * Math.pow(2, octave - 4);
      }
      
      evolveHarmony() {
        // Gradual harmonic evolution
        this.harmonic = 1 + Math.sin(this.evolution * Math.PI * 2) * 0.5;
        
        // Adjust reverb based on time and weather
        const reverbAmount = this.env.time.hour < 6 || this.env.time.hour > 20 ? 0.4 : 0.2;
        const wetGain = this.ctx.createGain();
        wetGain.gain.value = reverbAmount + (this.env.weather.condition === 'rainy' ? 0.2 : 0);
        
        // Update delay feedback based on activity
        this.nodes.delayFeedback.gain.setTargetAtTime(
          0.3 + this.env.motion.intensity * 0.2,
          this.ctx.currentTime,
          0.5
        );
      }
      
      createParticle() {
        const particle = document.createElement('div');
        particle.className = 'env-particle';
        particle.style.left = Math.random() * 100 + '%';
        particle.style.animationDuration = (15 + Math.random() * 10) + 's';
        particle.style.animationDelay = Math.random() * 5 + 's';
        
        // Color based on environment
        const hue = (this.env.time.hour * 15) + (this.env.weather.temp * 2);
        particle.style.background = `hsl(${hue}, 50%, 70%)`;
        
        this.elements.particleField.appendChild(particle);
        
        // Remove after animation
        setTimeout(() => particle.remove(), 25000);
      }
      
      animate() {
        if (!this.active) return;
        
        // Update visualization
        if (this.nodes.analyser) {
          this.nodes.analyser.getByteFrequencyData(this.analyserData);
          this.drawWaveform();
        }
        
        // Background color based on environment
        const timeHue = (this.env.time.hour / 24) * 60; // 0-60
        const weatherSat = this.env.weather.condition === 'clear' ? 20 : 5;
        const moodLight = this.env.mood === 'energetic' ? 15 : 
                         this.env.mood === 'calm' ? 5 : 10;
        
        document.body.style.background = `hsl(${220 + timeHue}, ${weatherSat}%, ${moodLight}%)`;
        
        requestAnimationFrame(() => this.animate());
      }
      
      drawWaveform() {
        const ctx = this.waveCtx;
        const width = ctx.canvas.width;
        const height = ctx.canvas.height;
        
        ctx.clearRect(0, 0, width, height);
        
        // Draw frequency data as flowing waves
        ctx.strokeStyle = `rgba(255, 255, 255, 0.3)`;
        ctx.lineWidth = 2;
        
        for (let offset = 0; offset < 3; offset++) {
          ctx.beginPath();
          
          for (let i = 0; i < this.analyserData.length; i++) {
            const x = (i / this.analyserData.length) * width;
            const y = height - (this.analyserData[i] / 255) * height * 0.8 - offset * 20;
            
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
          }
          
          ctx.stroke();
        }
      }
    }
    
    // Initialize the magic
    const engine = new MagicMusicEngine();
  </script>
</body>
</html>
