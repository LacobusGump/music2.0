<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI DJ Live Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
            --fib233: 144px;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }
        #spiral.active {
            opacity: 0.03;
        }
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }
        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.03) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }
        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }
        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }
        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        .record-indicator {
            position: fixed;
            bottom: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib89);
            height: var(--fib89);
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.13);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.382s ease;
        }
        .record-indicator.recording {
            background: rgba(255,0,0,0.21);
            border-color: rgba(255,0,0,0.34);
            animation: recordPulse 1.618s ease-in-out infinite;
        }
        @keyframes recordPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.13); }
        }
        .record-dot {
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: rgba(255,255,255,0.21);
            transition: all 0.382s ease;
        }
        .record-indicator.recording .record-dot {
            background: rgba(255,0,0,0.618);
        }
        .motion-field {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            line-height: var(--phi);
        }
        .motion-value {
            font-size: var(--fib13);
            opacity: 0.618;
        }
        .outfits {
            position: fixed;
            top: var(--fib55);
            right: var(--fib55);
            display: grid;
            gap: var(--fib8);
            grid-template-columns: repeat(2, var(--fib55));
        }
        .outfit {
            width: var(--fib55);
            height: var(--fib55);
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            cursor: pointer;
            transition: all 0.382s ease;
            position: relative;
            overflow: hidden;
        }
        .outfit:hover {
            border-color: rgba(255,255,255,0.21);
            background: rgba(255,255,255,0.05);
        }
        .outfit.active {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.08);
        }
        .outfit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: var(--outfit-color, rgba(255,255,255,0.21));
            transition: all 0.382s ease;
        }
        .outfit.cosmic::after { --outfit-color: rgba(138,43,226,0.618); }
        .outfit.urban::after { --outfit-color: rgba(255,140,0,0.618); }
        .outfit.nature::after { --outfit-color: rgba(34,139,34,0.618); }
        .outfit.minimal::after { --outfit-color: rgba(255,255,255,0.382); }
        #waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--fib144);
            pointer-events: none;
            opacity: 0.21;
        }
        .sample-bank {
            position: fixed;
            bottom: var(--fib55);
            right: var(--fib55);
            display: flex;
            gap: var(--fib5);
            opacity: 0.382;
        }
        .sample-slot {
            width: var(--fib13);
            height: var(--fib13);
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            transition: all 0.382s ease;
        }
        .sample-slot.filled {
            background: rgba(255,255,255,0.34);
            animation: samplePulse 2.618s ease-in-out infinite;
        }
        @keyframes samplePulse {
            0%, 100% { transform: scale(1); opacity: 0.34; }
            50% { transform: scale(1.382); opacity: 0.618; }
        }
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.13;
        }
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            animation: loading 1.618s ease-in-out infinite;
        }
        @keyframes loading {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.382; }
        }
    </style>
</head>
<body>
    <canvas id="spiral"></canvas>
    <canvas id="canvas"></canvas>
    <canvas id="waveform"></canvas>
   
    <div class="title">AI DJ Live Sampler</div>
   
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
   
    <div class="interface" id="interface">
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
        </div>
       
        <div class="outfits">
            <div class="outfit cosmic active" data-outfit="cosmic"></div>
            <div class="outfit urban" data-outfit="urban"></div>
            <div class="outfit nature" data-outfit="nature"></div>
            <div class="outfit minimal" data-outfit="minimal"></div>
        </div>
       
        <div class="record-indicator" id="recordIndicator">
            <div class="record-dot"></div>
        </div>
       
        <div class="sample-bank" id="sampleBank"></div>
    </div>
   
    <div class="loading" id="loading">AWAKENING...</div>
    <script>
        class AIDJEngine {
            constructor() {
                this.ctx = null;
                this.masterGain = null;
                this.compressor = null;
                this.reverb = null;
                this.analyser = null;
               
                this.sampler = {
                    banks: new Array(8).fill(null),
                    currentBank: 0,
                    isRecording: false,
                    recorder: null,
                    stream: null,
                    processor: null
                };
               
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: [],
                    pattern: 'still',
                    intensity: 0,
                    lastAccel: { x: 0, y: 0, z: 0 }
                };
               
                this.outfit = 'cosmic';
                this.phi = 1.618033988749;
                this.fibSequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
                this.currentStep = 0;
                this.bpm = 80;
               
                this.elements = {};
                this.canvases = {};
                this.animationId = null;
               
                this.init();
            }
           
            init() {
                ['start', 'interface', 'loading', 'motionValue', 'recordIndicator', 'sampleBank']
                    .forEach(id => this.elements[id] = document.getElementById(id));
               
                ['spiral', 'canvas', 'waveform']
                    .forEach(id => {
                        const canvas = document.getElementById(id);
                        this.canvases[id] = {
                            canvas,
                            ctx: canvas.getContext('2d')
                        };
                    });
               
                this.elements.start.addEventListener('click', () => this.begin());
               
                document.querySelectorAll('.outfit').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.outfit').forEach(o => o.classList.remove('active'));
                        e.target.classList.add('active');
                        this.outfit = e.target.dataset.outfit;
                        this.updateSoundscape();
                    });
                });
               
                this.elements.recordIndicator.addEventListener('click', () => this.toggleRecording());
               
                for (let i = 0; i < 8; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'sample-slot';
                    slot.dataset.index = i;
                    this.elements.sampleBank.appendChild(slot);
                }
               
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
               
                this.drawFibonacciSpiral();
            }
           
            resizeCanvases() {
                Object.values(this.canvases).forEach(({ canvas }) => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
            }
           
            drawFibonacciSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 400;
               
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
               
                let a = 0, b = 1;
                let angle = 0;
               
                for (let i = 0; i < 13; i++) {
                    const radius = b * scale;
                   
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(angle) * a * scale,
                        centerY + Math.sin(angle) * a * scale,
                        radius,
                        angle,
                        angle + Math.PI / 2
                    );
                    ctx.stroke();
                   
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                }
            }
           
            async begin() {
                this.elements.loading.style.display = 'block';
                this.elements.start.style.display = 'none';
               
                try {
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                   
                    this.sampler.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                   
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                   
                    this.setupAudioChain();
                   
                    this.setupMotionDetection();
                   
                    this.setupSampler();
                   
                    this.elements.loading.style.display = 'none';
                    this.elements.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');
                   
                    this.startEngine();
                   
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.elements.loading.textContent = 'PERMISSION NEEDED';
                }
            }
           
            setupAudioChain() {
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -3;
                this.compressor.knee.value = 3;
                this.compressor.ratio.value = 20;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.1;
               
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;
               
                this.reverb = this.ctx.createConvolver();
                this.createReverbImpulse();
               
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
               
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
               
                this.reverbSend = this.ctx.createGain();
                this.reverbSend.gain.value = 0.3;
                this.masterGain.connect(this.reverbSend);
                this.reverbSend.connect(this.reverb);
                this.reverb.connect(this.compressor);
            }
           
            createReverbImpulse() {
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
               
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.3;
                    }
                }
               
                this.reverb.buffer = impulse;
            }
           
            setupMotionDetection() {
                window.addEventListener('devicemotion', (e) => {
                    if (!e.accelerationIncludingGravity) return;
                   
                    const { x, y, z } = e.accelerationIncludingGravity;
                    const dx = Math.abs(x - this.motion.lastAccel.x);
                    const dy = Math.abs(y - this.motion.lastAccel.y);
                    const dz = Math.abs(z - this.motion.lastAccel.z);
                   
                    const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    this.updateMotion(magnitude);
                   
                    this.motion.lastAccel = { x, y, z };
                });
               
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', (e) => {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMouse.time);
                   
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                   
                    this.updateMotion(velocity * 10);
                   
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                });
            }
           
            updateMotion(value) {
                this.motion.current = value;
                this.motion.smoothed = this.motion.smoothed * 0.8 + value * 0.2;
               
                this.motion.history.push(this.motion.smoothed);
                if (this.motion.history.length > 89) {
                    this.motion.history.shift();
                }
               
                const avg = this.motion.history.reduce((a, b) => a + b, 0) / this.motion.history.length;
                const variance = this.motion.history.reduce((sum, m) => sum + Math.abs(m - avg), 0) / this.motion.history.length;
               
                this.motion.intensity = Math.min(1, variance / 5);
               
                if (avg < 0.5) this.motion.pattern = 'still';
                else if (variance < 1) this.motion.pattern = 'steady';
                else if (variance < 3) this.motion.pattern = 'flowing';
                else this.motion.pattern = 'chaotic';
               
                this.elements.motionValue.textContent = this.motion.smoothed.toFixed(3);
               
                const targetBPM = 80 + (this.motion.smoothed * 55);
                this.bpm = this.bpm * 0.95 + targetBPM * 0.05;
            }
           
            setupSampler() {
                this.sampler.processor = this.ctx.createScriptProcessor(4096, 1, 1);
                this.sampler.processor.onaudioprocess = (e) => {
                    if (this.sampler.isRecording) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        this.processSample(inputData);
                    }
                };
               
                const source = this.ctx.createMediaStreamSource(this.sampler.stream);
                source.connect(this.sampler.processor);
                this.sampler.processor.connect(this.ctx.destination);
            }
           
            toggleRecording() {
                if (this.sampler.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
            }
           
            startRecording() {
                this.sampler.isRecording = true;
                this.elements.recordIndicator.classList.add('recording');
               
                const emptyIndex = this.sampler.banks.findIndex(bank => bank === null);
                if (emptyIndex === -1) {
                    this.sampler.currentBank = (this.sampler.currentBank + 1) % 8;
                } else {
                    this.sampler.currentBank = emptyIndex;
                }
               
                this.sampler.banks[this.sampler.currentBank] = {
                    data: [],
                    peaks: [],
                    rhythm: null,
                    pitch: null,
                    timestamp: Date.now()
                };
            }
           
            stopRecording() {
                this.sampler.isRecording = false;
                this.elements.recordIndicator.classList.remove('recording');
               
                const bank = this.sampler.banks[this.sampler.currentBank];
                if (bank && bank.data.length > 0) {
                    this.analyzeSample(bank);
                   
                    const slot = this.elements.sampleBank.children[this.sampler.currentBank];
                    slot.classList.add('filled');
                   
                    this.integrateSample(this.sampler.currentBank);
                }
            }
           
            processSample(inputData) {
                const bank = this.sampler.banks[this.sampler.currentBank];
                if (!bank) return;
               
                bank.data.push(...inputData);
               
                const threshold = 0.3;
                for (let i = 1; i < inputData.length - 1; i++) {
                    if (inputData[i] > threshold &&
                        inputData[i] > inputData[i-1] &&
                        inputData[i] > inputData[i+1]) {
                        bank.peaks.push({
                            index: bank.data.length - inputData.length + i,
                            value: inputData[i]
                        });
                    }
                }
            }
           
            analyzeSample(bank) {
                if (bank.peaks.length > 2) {
                    const intervals = [];
                    for (let i = 1; i < bank.peaks.length; i++) {
                        intervals.push(bank.peaks[i].index - bank.peaks[i-1].index);
                    }
                   
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    bank.rhythm = {
                        bpm: (60 * this.ctx.sampleRate) / avgInterval,
                        pattern: intervals.map(i => i / avgInterval)
                    };
                }
               
                bank.pitch = this.detectPitch(bank.data);
               
                const buffer = this.ctx.createBuffer(1, bank.data.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(bank.data);
                bank.buffer = buffer;
            }
           
            detectPitch(data) {
                const sampleRate = this.ctx.sampleRate;
                const minFreq = 80;
                const maxFreq = 800;
                const minPeriod = Math.floor(sampleRate / maxFreq);
                const maxPeriod = Math.floor(sampleRate / minFreq);
               
                let maxCorrelation = 0;
                let bestPeriod = 0;
               
                for (let period = minPeriod; period < maxPeriod; period++) {
                    let correlation = 0;
                    for (let i = 0; i < data.length - period; i++) {
                        correlation += data[i] * data[i + period];
                    }
                   
                    if (correlation > maxCorrelation) {
                        maxCorrelation = correlation;
                        bestPeriod = period;
                    }
                }
               
                return bestPeriod > 0 ? sampleRate / bestPeriod : 0;
            }
           
            integrateSample(bankIndex) {
                const bank = this.sampler.banks[bankIndex];
                if (!bank || !bank.buffer) return;
               
                const grainPlayer = {
                    buffer: bank.buffer,
                    rhythm: bank.rhythm,
                    pitch: bank.pitch,
                    grainSize: 0.1,
                    grainOverlap: 0.5,
                    playbackRate: 1,
                    active: true
                };
               
                bank.player = grainPlayer;
               
                this.scheduleGrains(bankIndex);
            }
           
            scheduleGrains(bankIndex) {
                const bank = this.sampler.banks[bankIndex];
                if (!bank || !bank.player || !bank.player.active) return;
               
                const now = this.ctx.currentTime;
                const { buffer, grainSize, playbackRate } = bank.player;
               
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
               
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                const startOffset = Math.random() * (buffer.duration - grainSize);
                source.playbackRate.value = playbackRate * (1 + this.motion.intensity * 0.5);
               
                filter.type = 'bandpass';
                filter.frequency.value = this.getOutfitFrequency();
                filter.Q.value = 2 + this.motion.intensity * 5;
               
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + grainSize * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + grainSize);
               
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
               
                source.start(now, startOffset, grainSize);
               
                const nextTime = grainSize * (1 - bank.player.grainOverlap) * (2 - this.motion.intensity);
                setTimeout(() => this.scheduleGrains(bankIndex), nextTime * 1000);
            }
           
            getOutfitFrequency() {
                const frequencies = {
                    cosmic: 432 * this.phi,
                    urban: 440 * 1.5,
                    nature: 256 * this.phi,
                    minimal: 440
                };
                return frequencies[this.outfit] || 440;
            }
           
            updateSoundscape() {
                this.sampler.banks.forEach((bank, index) => {
                    if (bank && bank.player) {
                        const outfitModulation = {
                            cosmic: { rate: 1, overlap: 0.7 },
                            urban: { rate: 1.2, overlap: 0.3 },
                            nature: { rate: 0.8, overlap: 0.5 },
                            minimal: { rate: 1, overlap: 0.1 }
                        };
                       
                        const mod = outfitModulation[this.outfit];
                        bank.player.playbackRate = mod.rate;
                        bank.player.grainOverlap = mod.overlap;
                    }
                });
            }
           
            startEngine() {
                this.sequence();
               
                this.animate();
               
                this.generateAtmosphere();
            }
           
            sequence() {
                const beat = () => {
                    this.currentStep = (this.currentStep + 1) % 144;
                   
                    if (this.fibSequence.includes(this.currentStep % 21)) {
                        this.triggerFibonacciEvent();
                    }
                   
                    const interval = (60 / this.bpm) * 1000;
                    setTimeout(beat, interval);
                };
               
                beat();
            }
           
            triggerFibonacciEvent() {
                const baseFreq = 55 * Math.pow(this.phi, this.currentStep % 8);
               
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                osc.type = 'sine';
                osc.frequency.value = baseFreq;
               
                filter.type = 'lowpass';
                filter.frequency.value = baseFreq * 3;
                filter.Q.value = this.motion.intensity * 10 + 1;
               
                const now = this.ctx.currentTime;
                const duration = 60 / this.bpm;
               
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.1 * (1 - this.motion.intensity), now + duration * 0.1);
                gain.gain.exponentialRampToValueAtTime(0.001, now + duration);
               
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
               
                osc.start(now);
                osc.stop(now + duration);
            }
           
            generateAtmosphere() {
                const createDrone = () => {
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const filter = this.ctx.createBiquadFilter();
                   
                    const baseFreq = this.getOutfitFrequency() / 4;
                   
                    osc1.type = 'triangle';
                    osc1.frequency.value = baseFreq;
                   
                    osc2.type = 'triangle';
                    osc2.frequency.value = baseFreq * this.phi;
                   
                    filter.type = 'lowpass';
                    filter.frequency.value = 200 + this.motion.smoothed * 100;
                    filter.Q.value = 5;
                   
                    const now = this.ctx.currentTime;
                    const duration = 13;
                   
                    gain.gain.setValueAtTime(0, now);
                    gain.gain.linearRampToValueAtTime(0.05, now + 3);
                    gain.gain.setValueAtTime(0.05, now + duration - 3);
                    gain.gain.linearRampToValueAtTime(0, now + duration);
                   
                    osc1.connect(filter);
                    osc2.connect(filter);
                    filter.connect(gain);
                    gain.connect(this.masterGain);
                   
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + duration);
                    osc2.stop(now + duration);
                   
                    setTimeout(createDrone, 8000);
                };
               
                createDrone();
            }
           
            animate() {
                const draw = () => {
                    this.animationId = requestAnimationFrame(draw);
                   
                    this.drawWaveform();
                   
                    this.drawMotionField();
                };
               
                draw();
            }
           
            drawWaveform() {
                const { ctx, canvas } = this.canvases.waveform;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
               
                this.analyser.getByteTimeDomainData(dataArray);
               
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
               
                ctx.lineWidth = 1;
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.13 + this.motion.intensity * 0.21})`;
                ctx.beginPath();
               
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
               
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                   
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                   
                    x += sliceWidth;
                }
               
                ctx.stroke();
            }
           
            drawMotionField() {
                const { ctx, canvas } = this.canvases.canvas;
               
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
               
                const particleCount = this.fibSequence[Math.floor(this.motion.intensity * 11)];
               
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 50 + this.motion.smoothed * 100;
                   
                    const x = canvas.width / 2 + Math.cos(angle + Date.now() * 0.001) * radius;
                    const y = canvas.height / 2 + Math.sin(angle + Date.now() * 0.001) * radius;
                   
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + this.motion.intensity * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.13 * (1 - this.motion.intensity)})`;
                    ctx.fill();
                }
            }
        }
       
        const gump = new AIDJEngine();
    </script>
</body>
</html>
