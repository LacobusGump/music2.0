<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>OMNI // SPECTRAL ENGINE v1.0.4</title>
    <style>
        :root {
            --bg: #010203;
            --accent: #00ffa3;
            --accent-dim: rgba(0, 255, 163, 0.2);
            --warn: #ff0055;
            --text: #e0e0e0;
            --font-main: 'JetBrains Mono', 'Fira Code', 'Courier New', monospace;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-font-smoothing: antialiased; }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: var(--font-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .sys-header {
            padding: 15px 25px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--accent-dim);
            background: rgba(5, 5, 5, 0.8);
            z-index: 100;
        }

        .sys-title {
            font-size: 14px;
            letter-spacing: 2px;
            font-weight: 700;
            color: var(--accent);
        }

        .sys-stats {
            display: flex;
            gap: 20px;
            font-size: 10px;
            text-transform: uppercase;
        }

        #viewport-container {
            flex: 1;
            position: relative;
            background: radial-gradient(circle at center, #050810 0%, #010203 100%);
        }

        canvas#gl-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }

        .ui-overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            padding: 25px;
            z-index: 50;
        }

        .module-grid {
            display: grid;
            grid-template-columns: repeat(12, 1fr);
            gap: 15px;
            flex: 1;
        }

        .panel {
            grid-column: span 3;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid var(--accent-dim);
            padding: 15px;
            backdrop-filter: blur(10px);
            pointer-events: auto;
        }

        .panel-header {
            font-size: 9px;
            color: var(--accent);
            margin-bottom: 12px;
            border-bottom: 1px solid var(--accent-dim);
            padding-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        #boot-screen {
            position: fixed;
            inset: 0;
            background: var(--bg);
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }

        .boot-loader {
            width: 300px;
            height: 2px;
            background: #111;
            position: relative;
            overflow: hidden;
        }

        .boot-progress {
            position: absolute;
            left: 0;
            height: 100%;
            width: 0%;
            background: var(--accent);
            box-shadow: 0 0 15px var(--accent);
            transition: width 0.1s;
        }

        .btn-engage {
            background: transparent;
            border: 1px solid var(--accent);
            color: var(--accent);
            padding: 15px 40px;
            font-family: var(--font-main);
            font-size: 16px;
            letter-spacing: 5px;
            cursor: pointer;
            transition: all 0.3s;
            opacity: 0;
            pointer-events: none;
        }

        .btn-engage.ready {
            opacity: 1;
            pointer-events: auto;
        }

        .btn-engage:hover {
            background: var(--accent);
            color: #000;
            box-shadow: 0 0 30px var(--accent);
        }

        #log-window {
            height: 120px;
            overflow: hidden;
            font-size: 9px;
            color: #666;
            margin-top: auto;
        }

        .stat-value { color: var(--accent); }
    </style>
</head>
<body>

<div id="boot-screen">
    <div class="sys-title">OMNI // NEURAL ARCHITECTURE</div>
    <div class="boot-loader"><div id="boot-bar" class="boot-progress"></div></div>
    <div id="boot-status" style="font-size: 10px; color: #444;">LOADING CORE MODULES...</div>
    <button id="boot-btn" class="btn-engage">ENGAGE</button>
</div>

<header class="sys-header">
    <div class="sys-title">OMNI<span>_ENGINE</span></div>
    <div class="sys-stats">
        <div>SR: <span id="stat-sr" class="stat-value">44100</span></div>
        <div>LATENCY: <span id="stat-lat" class="stat-value">--</span></div>
        <div>ENTROPY: <span id="val-entropy" class="stat-value">0%</span></div>
    </div>
</header>

<div id="viewport-container">
    <canvas id="gl-canvas"></canvas>
    <div class="ui-overlay">
        <div class="module-grid">
            <div class="panel">
                <div class="panel-header">Spectral Analysis</div>
                <div id="spectral-stats">INITIALIZING...</div>
            </div>
        </div>
        <div id="log-window"></div>
    </div>
</div>

<script>
// ============================================================================
// OMNI CORE SYSTEM - INTEGRATED BUILD v1.0.4
// ============================================================================

const OMNI = {
    VERSION: "1.0.4",
    Config: {
        SAMPLE_RATE: 44100,
        FFT_SIZE: 2048,
        RING_BUFFER_SECONDS: 12,
        GRAIN_MAX_POLYPHONY: 64,
        MOTION_SENSITIVITY: 1.5
    },

    State: {
        isInitialized: false,
        isRecording: false,
        energy: 0,
        centroid: 0,
        entropy: 0,
        flux: 0,
        tilt: { x: 0, y: 0, z: 0 },
        activeGrains: 0,
        modValue: 0,
        manualScrub: 0
    },

    Math: {
        lerp: (a, b, t) => a + (b - a) * t,
        clamp: (val, min, max) => Math.max(min, Math.min(max, val)),
        
        createHannWindow: (size) => {
            const window = new Float32Array(size);
            for (let i = 0; i < size; i++) {
                window[i] = 0.5 * (1 - Math.cos((2 * Math.PI * i) / (size - 1)));
            }
            return window;
        },

        calculateRMS: (buffer) => {
            let sum = 0;
            const len = buffer.length;
            for (let i = 0; i < len; i++) sum += buffer[i] * buffer[i];
            return Math.sqrt(sum / len);
        },

        calculateZCR: (buffer) => {
            let zcr = 0;
            for (let i = 1; i < buffer.length; i++) {
                if ((buffer[i] >= 0 && buffer[i-1] < 0) || (buffer[i] < 0 && buffer[i-1] >= 0)) zcr++;
            }
            return zcr / buffer.length;
        },

        ampToDb: (amp) => 20 * Math.log10(Math.max(amp, 0.0001)),
        dbToAmp: (db) => Math.pow(10, db / 20)
    },

    UI: {
        log: (msg, type = 'info') => {
            const win = document.getElementById('log-window');
            const div = document.createElement('div');
            const colors = { info: '#666', warn: '#ff0055', success: '#00ffa3', error: '#ff0055' };
            div.style.color = colors[type] || colors.info;
            div.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
            win.prepend(div);
            if (win.children.length > 15) win.removeChild(win.lastChild);
        },
        updateBoot: (progress, status) => {
            document.getElementById('boot-bar').style.width = progress + '%';
            document.getElementById('boot-status').textContent = status;
            if (progress >= 100) {
                setTimeout(() => {
                    document.getElementById('boot-btn').classList.add('ready');
                }, 500);
            }
        }
    }
};

// ============================================================================
// AUDIO KERNEL
// ============================================================================

const KERNEL = {
    ctx: null,
    analyser: null,
    micSource: null,

    async init() {
        try {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            this.analyser = this.ctx.createAnalyser();
            this.analyser.fftSize = OMNI.Config.FFT_SIZE;
            this.analyser.smoothingTimeConstant = 0.8;

            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            this.micSource = this.ctx.createMediaStreamSource(stream);
            this.micSource.connect(this.analyser);

            OMNI.UI.log("AUDIO_KERNEL: MICROPHONE_ACTIVE");
            return true;
        } catch (e) {
            OMNI.UI.log("AUDIO_KERNEL: MIC_ACCESS_DENIED", "error");
            throw e;
        }
    }
};

// ============================================================================
// NEURAL MEMORY (Ring Buffer)
// ============================================================================

class NeuralMemory {
    constructor(seconds, sampleRate) {
        this.sampleRate = sampleRate;
        this.length = seconds * sampleRate;
        this.buffer = new Float32Array(this.length);
        this.writePtr = 0;
        this.isFull = false;
    }

    write(inputData) {
        for (let i = 0; i < inputData.length; i++) {
            this.buffer[this.writePtr] = inputData[i];
            this.writePtr++;
            if (this.writePtr >= this.length) {
                this.writePtr = 0;
                this.isFull = true;
            }
        }
    }

    read(offsetSeconds, durationSamples) {
        const startOffset = Math.floor(offsetSeconds * this.sampleRate);
        let readPtr = (this.writePtr - startOffset - durationSamples);
        while (readPtr < 0) readPtr += this.length;
        
        const outBuffer = new Float32Array(durationSamples);
        for (let i = 0; i < durationSamples; i++) {
            outBuffer[i] = this.buffer[(readPtr + i) % this.length];
        }
        return outBuffer;
    }
}

const Memory = new NeuralMemory(OMNI.Config.RING_BUFFER_SECONDS, OMNI.Config.SAMPLE_RATE);

// ============================================================================
// SENSOR FUSION
// ============================================================================

class SensorFusion {
    constructor() {
        this.motion = { x: 0, y: 0, z: 0, velocity: 0 };
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        this.history = new Float32Array(64);
        this.ptr = 0;
    }

    init() {
        if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
            DeviceMotionEvent.requestPermission()
                .then(response => {
                    if (response === 'granted') this.listen();
                })
                .catch(console.error);
        } else {
            this.listen();
        }
    }

    listen() {
        window.addEventListener('devicemotion', (e) => {
            const acc = e.accelerationIncludingGravity || { x: 0, y: 0, z: 0 };
            this.motion.x = acc.x || 0;
            this.motion.y = acc.y || 0;
            this.motion.z = acc.z || 0;
            
            const v = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2) - 9.8; 
            this.motion.velocity = Math.max(0, v);
            
            OMNI.State.tilt.x = acc.x || 0;
            OMNI.State.tilt.y = acc.y || 0;
            
            this.trackHistory(this.motion.velocity);
        });

        window.addEventListener('deviceorientation', (e) => {
            this.orientation.alpha = e.alpha || 0;
            this.orientation.beta = e.beta || 0;
            this.orientation.gamma = e.gamma || 0;
            
            OMNI.State.entropy = OMNI.Math.clamp(Math.abs(e.beta || 0) / 90, 0, 1);
        });
    }

    trackHistory(val) {
        this.history[this.ptr] = val;
        this.ptr = (this.ptr + 1) % this.history.length;
        
        let totalChange = 0;
        for(let i = 1; i < this.history.length; i++) {
            totalChange += Math.abs(this.history[i] - this.history[i-1]);
        }
        OMNI.State.flux = totalChange / this.history.length;
    }
}

const Sensors = new SensorFusion();

// ============================================================================
// SPECTRAL ANALYZER
// ============================================================================

class SpectralAnalyzer {
    constructor(fftSize, sampleRate) {
        this.fftSize = fftSize;
        this.sampleRate = sampleRate;
        this.binCount = fftSize / 2;
        
        this.freqData = new Uint8Array(this.binCount);
        this.floatFreqData = new Float32Array(this.binCount);
        this.timeData = new Float32Array(fftSize);
        
        this.stats = {
            centroid: 0,
            flatness: 0,
            peakFreq: 0,
            energy: 0
        };
    }

    analyze(webAudioAnalyser) {
        webAudioAnalyser.getByteFrequencyData(this.freqData);
        webAudioAnalyser.getFloatFrequencyData(this.floatFreqData);
        webAudioAnalyser.getFloatTimeDomainData(this.timeData);

        this.stats.energy = OMNI.Math.calculateRMS(this.timeData);
        this.stats.centroid = this.calculateCentroid();
        this.stats.flatness = this.calculateFlatness();
        this.stats.peakFreq = this.calculatePeakFrequency();

        OMNI.State.energy = this.stats.energy;
        OMNI.State.centroid = this.stats.centroid;
        
        return this.stats;
    }

    calculateCentroid() {
        let sum = 0;
        let weightedSum = 0;
        for (let i = 0; i < this.binCount; i++) {
            const magnitude = this.freqData[i];
            sum += magnitude;
            weightedSum += magnitude * (i * this.sampleRate / this.fftSize);
        }
        return sum === 0 ? 0 : weightedSum / sum;
    }

    calculateFlatness() {
        let gSum = 0;
        let aSum = 0;
        const norm = 1.0 / 255.0;

        for (let i = 0; i < this.binCount; i++) {
            const mag = this.freqData[i] * norm + 0.0001;
            aSum += mag;
            gSum += Math.log(mag);
        }

        const arithmetic = aSum / this.binCount;
        const geometric = Math.exp(gSum / this.binCount);
        
        return geometric / arithmetic;
    }

    calculatePeakFrequency() {
        let maxMag = -Infinity;
        let peakBin = 0;
        for (let i = 0; i < this.binCount; i++) {
            if (this.freqData[i] > maxMag) {
                maxMag = this.freqData[i];
                peakBin = i;
            }
        }
        return peakBin * (this.sampleRate / this.fftSize);
    }
}

const Analyzer = new SpectralAnalyzer(OMNI.Config.FFT_SIZE, OMNI.Config.SAMPLE_RATE);

// ============================================================================
// SPECTRAL GRAIN
// ============================================================================

class SpectralGrain {
    constructor(ctx, destination) {
        this.ctx = ctx;
        this.destination = destination;
        
        this.source = null;
        this.gain = this.ctx.createGain();
        this.filter = this.ctx.createBiquadFilter();
        this.panner = this.ctx.createStereoPanner();

        this.filter.connect(this.panner);
        this.panner.connect(this.gain);
        this.gain.connect(this.destination);

        this.isActive = false;
        this.startTime = 0;
    }

    trigger(audioBuffer, params) {
        const now = this.ctx.currentTime;
        this.isActive = true;
        this.startTime = now;

        // Create new source each time
        this.source = this.ctx.createBufferSource();
        this.source.buffer = audioBuffer;
        this.source.playbackRate.value = params.playbackRate || 1.0;
        
        this.filter.type = params.filterType || 'bandpass';
        this.filter.frequency.setValueAtTime(params.filterFreq || 1000, now);
        this.filter.Q.value = params.Q || 1.0;

        this.panner.pan.setValueAtTime(OMNI.Math.clamp(params.pan || 0, -1, 1), now);

        this.gain.gain.setValueAtTime(0, now);
        this.gain.gain.linearRampToValueAtTime(params.amp || 0.5, now + 0.01);
        this.gain.gain.exponentialRampToValueAtTime(0.001, now + params.duration);

        this.source.connect(this.filter);
        this.source.start(now, params.offset, params.duration);
        
        this.source.onended = () => {
            this.isActive = false;
            OMNI.State.activeGrains = Math.max(0, OMNI.State.activeGrains - 1);
        };
    }
}

// ============================================================================
// VOICE MANAGER
// ============================================================================

class VoiceManager {
    constructor(ctx, masterBus) {
        this.ctx = ctx;
        this.masterBus = masterBus;
        this.poolSize = OMNI.Config.GRAIN_MAX_POLYPHONY;
        this.pool = [];
        this.initPool();
    }

    initPool() {
        for (let i = 0; i < this.poolSize; i++) {
            this.pool.push(new SpectralGrain(this.ctx, this.masterBus));
        }
        OMNI.UI.log(`VOICE_MANAGER: ${this.poolSize} NODES ALLOCATED`);
    }

    getNextAvailableVoice() {
        let voice = this.pool.find(v => !v.isActive);

        if (!voice) {
            voice = this.pool.reduce((oldest, current) => {
                return (current.startTime < oldest.startTime) ? current : oldest;
            });
            if (voice.source) voice.source.stop();
            voice.isActive = false;
        }

        OMNI.State.activeGrains++;
        return voice;
    }
}

let Voices;

// ============================================================================
// ADAPTIVE SEQUENCER
// ============================================================================

class AdaptiveSequencer {
    constructor() {
        this.baseBPM = 120;
        this.nextEventTime = 0;
        this.stepIndex = 0;
        this.subdivision = 0.25;
        this.rhythmMatrix = [1, 0.5, 0.75, 0, 1, 0.25, 0.5, 0.9];
        this.isRunning = false;
    }

    process(currentTime, audioCtx) {
        if (!this.isRunning) return;

        while (this.nextEventTime < currentTime + 0.1) {
            this.scheduleStep(this.nextEventTime, audioCtx);
            this.advanceStep();
        }
    }

    advanceStep() {
        const tempoMod = OMNI.Math.lerp(0.5, 2.0, OMNI.State.flux);
        const secondsPerBeat = 60.0 / (this.baseBPM * tempoMod);
        
        this.nextEventTime += this.subdivision * secondsPerBeat;
        this.stepIndex = (this.stepIndex + 1) % 128;
    }

    scheduleStep(time, ctx) {
        const prob = this.rhythmMatrix[this.stepIndex % this.rhythmMatrix.length];
        
        if (Math.random() * (1.1 - OMNI.State.energy) < prob) {
            if (this.stepIndex % 4 === 0) {
                this.triggerNeuralEvent(time, 'lowpass', 150, 0.8, 0.4);
            }
            
            if (OMNI.State.centroid > 3000 && Math.random() > 0.5) {
                this.triggerNeuralEvent(time, 'highpass', OMNI.State.centroid, 0.2, 0.1);
            }
        }
    }

    triggerNeuralEvent(time, type, freq, amp, dur) {
        if (!Voices) return;
        
        const grain = Voices.getNextAvailableVoice();
        const offset = Math.random() * (OMNI.Config.RING_BUFFER_SECONDS - 1);
        const pRate = OMNI.Math.lerp(0.5, 2.0, OMNI.State.entropy);

        // Create audio buffer from memory
        const durationSamples = Math.floor(dur * OMNI.Config.SAMPLE_RATE);
        const memData = Memory.read(offset, durationSamples);
        const buffer = KERNEL.ctx.createBuffer(1, durationSamples, OMNI.Config.SAMPLE_RATE);
        buffer.copyToChannel(memData, 0);

        grain.trigger(buffer, {
            offset: 0,
            duration: dur,
            playbackRate: pRate,
            filterType: type,
            filterFreq: freq,
            amp: amp * OMNI.State.energy * 2,
            pan: OMNI.State.tilt.x / 10,
            Q: 10
        });
    }

    start() {
        this.isRunning = true;
        this.nextEventTime = KERNEL.ctx.currentTime;
        OMNI.UI.log("SEQUENCER: NEURAL_GRID_ACTIVE");
    }
}

const Sequencer = new AdaptiveSequencer();

// ============================================================================
// VISUAL ENGINE
// ============================================================================

class VisualEngine {
    constructor(canvasId) {
        this.canvas = document.getElementById(canvasId);
        this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');
        if (!this.gl) { 
            OMNI.UI.log("WEBGL_FAILURE: FALLBACK_REQUIRED", "warn"); 
            return; 
        }

        this.program = null;
        this.init();
    }

    init() {
        const vs = `
            attribute vec2 position;
            void main() { gl_Position = vec4(position, 0.0, 1.0); }
        `;

        const fs = `
            precision highp float;
            uniform vec2 u_resolution;
            uniform float u_time;
            uniform float u_entropy;

            float hash(vec2 p) {
                return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);
            }

            void main() {
                vec2 uv = gl_FragCoord.xy / u_resolution.xy;
                
                float spec = hash(vec2(uv.x, u_time * 0.1)) * u_entropy;
                vec3 color = vec3(0.0, u_entropy * 0.8, spec * 0.9);
                
                float scanline = sin(uv.y * 800.0 + u_time * 10.0) * 0.1;
                float beam = smoothstep(0.01, 0.0, abs(uv.y - spec));
                
                color += vec3(0.0, beam, beam * 0.5);
                color *= (1.0 - scanline);

                gl_FragColor = vec4(color * spec, 1.0);
            }
        `;

        this.program = this.createProgram(vs, fs);
        this.gl.useProgram(this.program);

        this.positionLocation = this.gl.getAttribLocation(this.program, "position");
        this.resolutionLocation = this.gl.getUniformLocation(this.program, "u_resolution");
        this.timeLocation = this.gl.getUniformLocation(this.program, "u_time");
        this.entropyLocation = this.gl.getUniformLocation(this.program, "u_entropy");

        this.buffer = this.gl.createBuffer();
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([
            -1, -1, 1, -1, -1, 1,
            -1, 1, 1, -1, 1, 1,
        ]), this.gl.STATIC_DRAW);

        OMNI.UI.log("VISUAL_ENGINE: SHADER_PIPELINE_STABLE");
    }

    render(time, spectralArray) {
        if (!this.gl) return;
        
        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
        this.gl.useProgram(this.program);

        this.gl.uniform2f(this.resolutionLocation, this.canvas.width, this.canvas.height);
        this.gl.uniform1f(this.timeLocation, time * 0.001);
        this.gl.uniform1f(this.entropyLocation, OMNI.State.entropy);

        this.gl.enableVertexAttribArray(this.positionLocation);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);
        this.gl.vertexAttribPointer(this.positionLocation, 2, this.gl.FLOAT, false, 0, 0);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 6);
    }

    createProgram(vsSource, fsSource) {
        const vs = this.gl.createShader(this.gl.VERTEX_SHADER);
        this.gl.shaderSource(vs, vsSource);
        this.gl.compileShader(vs);
        
        const fs = this.gl.createShader(this.gl.FRAGMENT_SHADER);
        this.gl.shaderSource(fs, fsSource);
        this.gl.compileShader(fs);
        
        const prog = this.gl.createProgram();
        this.gl.attachShader(prog, vs);
        this.gl.attachShader(prog, fs);
        this.gl.linkProgram(prog);
        return prog;
    }
}

let Graphics;

// ============================================================================
// MASTER CONTROLLER
// ============================================================================

class OmniController {
    constructor() {
        this.rafId = null;
        this.lastTime = 0;
        this.masterGain = null;
        this.limiter = null;
        this.audioProcessor = null;
    }

    async start() {
        OMNI.UI.updateBoot(20, "INITIALIZING_AUDIO_KERNEL...");
        
        await KERNEL.init();
        
        this.masterGain = KERNEL.ctx.createGain();
        this.limiter = KERNEL.ctx.createDynamicsCompressor();
        
        this.limiter.threshold.setValueAtTime(-1.0, KERNEL.ctx.currentTime);
        this.limiter.knee.setValueAtTime(40, KERNEL.ctx.currentTime);
        this.limiter.ratio.setValueAtTime(12, KERNEL.ctx.currentTime);
        this.limiter.attack.setValueAtTime(0.003, KERNEL.ctx.currentTime);
        this.limiter.release.setValueAtTime(0.25, KERNEL.ctx.currentTime);
        
        this.masterGain.connect(this.limiter);
        this.limiter.connect(KERNEL.ctx.destination);

        OMNI.UI.updateBoot(40, "ALLOCATING_VOICE_POOLS...");
        
        Voices = new VoiceManager(KERNEL.ctx, this.masterGain);

        OMNI.UI.updateBoot(60, "BOOTING_VISUAL_NERVOUS_SYSTEM...");
        
        Graphics = new VisualEngine('gl-canvas');
        this.handleResize();
        window.addEventListener('resize', () => this.handleResize());

        OMNI.UI.updateBoot(80, "LINKING_SENSORS...");
        
        Sensors.init();
        
        // Setup audio processing for memory buffer
        this.setupAudioProcessing();
        
        Sequencer.start();

        OMNI.UI.updateBoot(100, "SYSTEM_ONLINE");
        
        this.run(0);
        
        OMNI.State.isInitialized = true;
        OMNI.UI.log("OMNI_ENGINE_V1: FULL_STACK_IGNITION", "success");
        
        // Hide boot screen
        setTimeout(() => {
            document.getElementById('boot-screen').style.display = 'none';
        }, 1000);
    }

    setupAudioProcessing() {
        // Create script processor to feed memory buffer
        this.audioProcessor = KERNEL.ctx.createScriptProcessor(4096, 1, 1);
        KERNEL.analyser.connect(this.audioProcessor);
        this.audioProcessor.connect(KERNEL.ctx.destination);
        
        this.audioProcessor.onaudioprocess = (e) => {
            const input = e.inputBuffer.getChannelData(0);
            Memory.write(input);
        };
    }

    handleResize() {
        if (!Graphics || !Graphics.canvas) return;
        const dpr = window.devicePixelRatio || 1;
        Graphics.canvas.width = window.innerWidth * dpr;
        Graphics.canvas.height = window.innerHeight * dpr;
    }

    run(time) {
        const dt = time - this.lastTime;
        this.lastTime = time;

        if (KERNEL.ctx) {
            const stats = Analyzer.analyze(KERNEL.analyser);
            Sequencer.process(KERNEL.ctx.currentTime, KERNEL.ctx);
            
            if (Graphics) {
                Graphics.render(time, Analyzer.freqData);
            }

            this.updateHUD(stats);
        }

        this.rafId = requestAnimationFrame((t) => this.run(t));
    }

    updateHUD(stats) {
        document.getElementById('stat-lat').textContent = 
            (KERNEL.ctx.baseLatency * 1000).toFixed(1) + "ms";
        
        const entropyVal = (stats.flatness * 100).toFixed(1);
        document.getElementById('val-entropy').textContent = entropyVal + "%";
        
        document.getElementById('spectral-stats').innerHTML = `
            Energy: ${(stats.energy * 100).toFixed(1)}%<br>
            Centroid: ${Math.round(stats.centroid)}Hz<br>
            Peak: ${Math.round(stats.peakFreq)}Hz<br>
            Grains: ${OMNI.State.activeGrains}
        `;
    }
}

const Main = new OmniController();

// ============================================================================
// BOOTSTRAP
// ============================================================================

class OmniBootstrap {
    constructor() {
        this.isPoweredOn = false;
    }

    async ignite() {
        if (this.isPoweredOn) return;
        
        console.log("%c OMNI OS v1.0.4 : INITIALIZING ", "background: #000; color: #0f0; font-weight: bold;");
        
        OMNI.UI.log("MEMORY_MATRIX: 12S BUFFER ALLOCATED");
        OMNI.UI.log("SENSOR_FUSION: STANDBY");
        OMNI.UI.log("SPECTRAL_KERNEL: FFT_SIZE 2048 INITIALIZED");
        OMNI.UI.log("HEURISTICS: CENTROID, FLATNESS, PEAK_DETECTION READY");
        
        try {
            await Main.start();
            this.isPoweredOn = true;
            this.setupGlobalHandlers();
        } catch (e) {
            this.emergencyShutdown(e);
        }
    }

    setupGlobalHandlers() {
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                if (KERNEL.ctx) KERNEL.ctx.suspend();
                OMNI.UI.log("SYSTEM: HIBERNATING", "warn");
            } else {
                if (KERNEL.ctx) KERNEL.ctx.resume();
                OMNI.UI.log("SYSTEM: AWAKENED");
            }
        });

        window.onerror = (msg, url, line) => {
            OMNI.UI.log(`CRITICAL_ERR: ${msg} @ ${line}`, "error");
            return false;
        };
    }

    emergencyShutdown(error) {
        console.error("OMNI_FATAL_EXCEPTION:", error);
        OMNI.UI.updateBoot(0, "SYSTEM_HALTED");
        if (KERNEL.ctx) KERNEL.ctx.close();
        OMNI.UI.log("SYSTEM HALTED: " + error.message, "error");
    }
}

const OMNI_BOOT = new OmniBootstrap();

document.getElementById('boot-btn').addEventListener('click', async () => {
    // Resume AudioContext for mobile
    if (KERNEL.ctx && KERNEL.ctx.state === 'suspended') {
        await KERNEL.ctx.resume();
    }
    
    document.getElementById('boot-btn').style.display = 'none';
    await OMNI_BOOT.ignite();
});

// Auto-show engage button after 1 second
setTimeout(() => {
    OMNI.UI.updateBoot(100, "READY_TO_ENGAGE");
}, 1000);
