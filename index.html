<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Environmental Sampling EDM Engine</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,20,20,0.1) 0%, transparent 70%);
            border: 3px solid rgba(255,20,20,0.4);
            color: #ff1414;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: samplePulse 2s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(255,20,20,0.8);
            background: radial-gradient(circle, rgba(255,20,20,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        .btn-text {
            font-size: 20px;
            margin-bottom: 8px;
        }

        .btn-subtext {
            font-size: 11px;
            opacity: 0.8;
            text-align: center;
            line-height: 1.2;
        }

        @keyframes samplePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255,20,20,0.3);
            }
            50% {
                transform: scale(1.06);
                box-shadow: 0 0 80px rgba(255,20,20,0.6);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff1414 0%, rgba(255,20,20,0.4) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 50px rgba(255,20,20,0.6);
            backdrop-filter: blur(8px);
            will-change: transform;
            z-index: 10;
        }

        .orb.pulse {
            animation: sampleBeat 0.15s ease-out;
        }

        @keyframes sampleBeat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.8); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.sampling {
            background: radial-gradient(circle, #ff6600 0%, rgba(255,102,0,0.5) 50%, transparent 80%);
            box-shadow: 0 0 70px rgba(255,102,0,0.8);
            animation: samplingActive 0.8s ease-in-out infinite;
        }

        .orb.chopping {
            background: radial-gradient(circle, #00ff88 0%, rgba(0,255,136,0.5) 50%, transparent 80%);
            box-shadow: 0 0 90px rgba(0,255,136,0.9);
            animation: choppingActive 0.4s ease-in-out infinite;
        }

        .orb.flipping {
            background: radial-gradient(circle, #8800ff 0%, rgba(136,0,255,0.5) 50%, transparent 80%);
            box-shadow: 0 0 120px rgba(136,0,255,1);
            animation: flippingActive 0.25s ease-in-out infinite;
        }

        .orb.dropping {
            background: radial-gradient(circle, #ffff00 0%, #ff0080 30%, #00ffff 60%, transparent 90%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 100px rgba(255,0,128,0.8));
            animation: droppingActive 0.15s ease-in-out infinite;
        }

        @keyframes samplingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.3) rotate(180deg); }
        }

        @keyframes choppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
        }

        @keyframes flippingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.7) rotate(360deg); }
        }

        @keyframes droppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            25% { transform: translate(-50%, -50%) scale(2.2); }
            50% { transform: translate(-50%, -50%) scale(1.6); }
            75% { transform: translate(-50%, -50%) scale(2.5); }
        }

        .hidden {
            display: none !important;
        }

        .sample-viz {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 280px;
            height: 100px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,20,20,0.3);
            border-radius: 12px;
            padding: 12px;
            font-size: 11px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .sample-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-weight: bold;
        }

        .sample-details {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            opacity: 0.8;
            margin-bottom: 8px;
        }

        .waveform {
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.5);
            border-radius: 6px;
            position: relative;
            overflow: hidden;
            border: 1px solid rgba(255,20,20,0.2);
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #ff1414, #ff6600, #ffff00);
            transition: height 0.08s ease;
            border-radius: 1px;
        }

        .controls {
            position: fixed;
            bottom: 20px;
            right: 20px;
            width: 240px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 16px;
            backdrop-filter: blur(15px);
            z-index: 100;
        }

        .control-section {
            margin-bottom: 12px;
        }

        .control-label {
            font-size: 10px;
            color: #ff6600;
            margin-bottom: 4px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .control-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
            font-size: 11px;
        }

        .slider {
            width: 120px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            position: relative;
            cursor: pointer;
        }

        .slider-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff1414, #ff6600);
            border-radius: 3px;
            transition: width 0.2s ease;
        }

        .slider-thumb {
            width: 14px;
            height: 14px;
            background: #fff;
            border-radius: 50%;
            position: absolute;
            top: -4px;
            transform: translateX(-50%);
            cursor: grab;
            box-shadow: 0 2px 6px rgba(0,0,0,0.3);
            transition: all 0.2s ease;
        }

        .slider-thumb:hover {
            transform: translateX(-50%) scale(1.2);
            cursor: grabbing;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,20,20,0.6);
            animation: particleFloat 6s linear infinite;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-10vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .layer-status {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            z-index: 100;
        }

        .layer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding: 4px 8px;
            border-radius: 6px;
            background: rgba(255,255,255,0.05);
            min-width: 140px;
        }

        .layer.active {
            background: rgba(255,20,20,0.2);
            border: 1px solid rgba(255,20,20,0.4);
            animation: layerPulse 0.3s ease;
        }

        @keyframes layerPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .layer-name {
            font-weight: bold;
            color: #ff6600;
        }

        .instructions {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 12px;
            padding: 12px;
            backdrop-filter: blur(15px);
            font-size: 10px;
            max-width: 200px;
            z-index: 100;
        }

        .instruction-group {
            margin-bottom: 8px;
        }

        .instruction-title {
            color: #ff6600;
            font-weight: bold;
            margin-bottom: 4px;
        }

        kbd {
            background: rgba(255,255,255,0.1);
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 9px;
            margin-right: 4px;
        }

        .debug-info {
            position: fixed;
            bottom: 140px;
            left: 20px;
            background: rgba(0,0,0,0.8);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            padding: 8px;
            font-size: 9px;
            font-family: monospace;
            z-index: 100;
            max-width: 200px;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            <div class="btn-text">START ENGINE</div>
            <div class="btn-subtext">SAMPLE THE WORLD<br>BUILD THE BEAT</div>
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
        
        <div id="sampleViz" class="sample-viz hidden">
            <div class="sample-info">
                <span id="sampleStatus">LISTENING...</span>
                <span id="sampleCount">0 SAMPLES</span>
            </div>
            <div class="sample-details">
                <span id="bpmDisplay">140 BPM</span>
                <span id="stageDisplay">LISTENING</span>
                <span id="motionDisplay">CALM</span>
            </div>
            <div class="waveform" id="waveform"></div>
        </div>

        <div id="controls" class="controls hidden">
            <div class="control-section">
                <div class="control-label">Sampling</div>
                <div class="control-row">
                    <span>Threshold</span>
                    <div class="slider" data-param="threshold">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Sensitivity</span>
                    <div class="slider" data-param="sensitivity">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
            <div class="control-section">
                <div class="control-label">Evolution</div>
                <div class="control-row">
                    <span>Chaos</span>
                    <div class="slider" data-param="chaos">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
                <div class="control-row">
                    <span>Speed</span>
                    <div class="slider" data-param="speed">
                        <div class="slider-fill"></div>
                        <div class="slider-thumb"></div>
                    </div>
                </div>
            </div>
        </div>

        <div id="layerStatus" class="layer-status hidden">
            <div style="font-weight: bold; margin-bottom: 8px; color: #ff6600;">SAMPLE LAYERS</div>
            <div class="layer" data-layer="kick">
                <span class="layer-name">KICK</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="snare">
                <span class="layer-name">SNARE</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="hats">
                <span class="layer-name">HATS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="bass">
                <span class="layer-name">BASS</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="lead">
                <span class="layer-name">LEAD</span>
                <span class="layer-count">0</span>
            </div>
            <div class="layer" data-layer="fx">
                <span class="layer-name">FX</span>
                <span class="layer-count">0</span>
            </div>
        </div>

        <div id="instructions" class="instructions hidden">
            <div class="instruction-group">
                <div class="instruction-title">Controls</div>
                <div><kbd>SPACE</kbd> Sample</div>
                <div><kbd>C</kbd> Chop</div>
                <div><kbd>F</kbd> Flip</div>
                <div><kbd>P</kbd> Pitch</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Layers</div>
                <div><kbd>1-6</kbd> Trigger</div>
            </div>
            <div class="instruction-group">
                <div class="instruction-title">Motion</div>
                <div>Move device or mouse</div>
            </div>
        </div>

        <div id="debugInfo" class="debug-info hidden">
            <div id="debugText">Debug Info</div>
        </div>
    </div>

    <script>
        class GUMPEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.active = false;
                this.masterGain = null;

                // Microphone
                this.microphone = null;
                this.micAnalyser = null;
                this.micDataArray = null;

                // Recording
                this.isRecording = false;
                this.recordBuffer = [];
                this.recordingStartTime = 0;
                this.maxRecordTime = 3;
                this.sampleThreshold = 0.02;
                this.lastSampleTime = 0;
                this.samplingCooldown = 2000;

                // Sample library
                this.sampleLibrary = [];
                this.sampleLayers = {
                    kick: { samples: [], gain: null },
                    snare: { samples: [], gain: null },
                    hats: { samples: [], gain: null },
                    bass: { samples: [], gain: null },
                    lead: { samples: [], gain: null },
                    fx: { samples: [], gain: null }
                };

                // Motion
                this.motion = 0;
                this.intensity = 0;
                this.pos = { x: 50, y: 50 };
                this.motionHistory = [];
                this.motionPattern = 'calm';

                // Music
                this.bpm = 140;
                this.step = 0;
                this.stage = 'LISTENING';
                this.isPlaying = false;
                this.lastBeatTime = 0;

                // Controls
                this.controls = {
                    threshold: 0.15,
                    sensitivity: 0.5,
                    chaos: 0.2,
                    speed: 0.5
                };

                // Built-in drums for testing
                this.builtInDrums = {
                    kick: null,
                    snare: null,
                    hat: null
                };

                this.elements = {};
                this.init();
            }

            init() {
                // Get DOM elements
                const elementIds = [
                    'startScreen', 'startBtn', 'evolutionSpace', 'orb', 'sampleViz',
                    'sampleStatus', 'sampleCount', 'bpmDisplay', 'stageDisplay', 
                    'motionDisplay', 'waveform', 'controls', 'layerStatus', 'instructions',
                    'debugInfo', 'debugText'
                ];
                
                elementIds.forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });

                // Setup event listeners
                this.elements.startBtn.addEventListener('click', () => this.start());
                this.setupControls();
                this.setupKeyboardControls();
                this.setupMotionTracking();
                this.createWaveformBars();
            }

            setupControls() {
                const sliders = document.querySelectorAll('.slider');
                
                sliders.forEach(slider => {
                    const param = slider.dataset.param;
                    const fill = slider.querySelector('.slider-fill');
                    const thumb = slider.querySelector('.slider-thumb');
                    
                    // Set initial positions
                    const initialValue = this.controls[param] || 0.5;
                    const percentage = initialValue * 100;
                    fill.style.width = percentage + '%';
                    thumb.style.left = percentage + '%';
                    
                    // Mouse events
                    slider.addEventListener('mousedown', (e) => {
                        e.preventDefault();
                        const rect = slider.getBoundingClientRect();
                        
                        const updateSlider = (clientX) => {
                            const x = Math.max(0, Math.min(clientX - rect.left, rect.width));
                            const percentage = (x / rect.width) * 100;
                            const value = x / rect.width;
                            
                            fill.style.width = percentage + '%';
                            thumb.style.left = percentage + '%';
                            this.controls[param] = value;
                            this.updateControlParameter(param, value);
                        };
                        
                        updateSlider(e.clientX);
                        
                        const handleMouseMove = (e) => updateSlider(e.clientX);
                        const handleMouseUp = () => {
                            document.removeEventListener('mousemove', handleMouseMove);
                            document.removeEventListener('mouseup', handleMouseUp);
                        };
                        
                        document.addEventListener('mousemove', handleMouseMove);
                        document.addEventListener('mouseup', handleMouseUp);
                    });
                });
            }

            updateControlParameter(param, value) {
                switch(param) {
                    case 'threshold':
                        this.sampleThreshold = 0.01 + (value * 0.1);
                        break;
                    case 'sensitivity':
                        this.samplingCooldown = 500 + ((1 - value) * 3000);
                        break;
                    case 'speed':
                        this.bpm = 100 + (value * 100);
                        break;
                }
            }

            setupKeyboardControls() {
                const keyMap = {
                    ' ': () => this.triggerSample(),
                    'c': () => this.chopSample(),
                    'f': () => this.flipSample(),
                    'p': () => this.pitchSample(),
                    '1': () => this.triggerLayer('kick'),
                    '2': () => this.triggerLayer('snare'),
                    '3': () => this.triggerLayer('hats'),
                    '4': () => this.triggerLayer('bass'),
                    '5': () => this.triggerLayer('lead'),
                    '6': () => this.triggerLayer('fx'),
                    'd': () => this.toggleDebug()
                };

                document.addEventListener('keydown', (e) => {
                    if (!this.active) return;
                    
                    const handler = keyMap[e.key.toLowerCase()];
                    if (handler) {
                        e.preventDefault();
                        handler();
                    }
                });

                // Click to sample
                document.addEventListener('click', (e) => {
                    if (!this.active || e.target.closest('.controls, .layer-status, .instructions, .start-screen')) return;
                    this.triggerSample();
                });
            }

            setupMotionTracking() {
                let lastMouse = { x: 0, y: 0, time: 0 };
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    if (lastMouse.time > 0) {
                        const dt = now - lastMouse.time;
                        const dx = newX - lastMouse.x;
                        const dy = newY - lastMouse.y;
                        const velocity = Math.sqrt(dx*dx + dy*dy) / Math.max(dt, 16) * 1000;
                        this.updateMotion(velocity * 0.01);
                    }
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    lastMouse = { x: newX, y: newY, time: now };
                });

                // Device motion
                window.addEventListener('devicemotion', (e) => {
                    if (!this.active || !e.accelerationIncludingGravity) return;
                    
                    const acc = e.accelerationIncludingGravity;
                    const magnitude = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
                    this.updateMotion(magnitude * 0.1);
                });
            }

            updateMotion(newMotion) {
                this.motion = this.motion * 0.8 + newMotion * 0.2;
                
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 60) {
                    this.motionHistory.shift();
                }
                
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = avgMotion;
                
                // Determine motion pattern
                if (avgMotion > 3) this.motionPattern = 'chaotic';
                else if (avgMotion > 1.5) this.motionPattern = 'active';
                else if (avgMotion > 0.5) this.motionPattern = 'rhythmic';
                else this.motionPattern = 'calm';
                
                this.updateStage();
            }

            updateStage() {
                const sampleCount = this.sampleLibrary.length;
                
                if (sampleCount === 0) {
                    this.stage = 'LISTENING';
                } else if (sampleCount < 3) {
                    this.stage = 'SAMPLING';
                } else if (sampleCount < 8) {
                    this.stage = 'CHOPPING';
                } else if (sampleCount < 15) {
                    this.stage = 'FLIPPING';
                } else {
                    this.stage = 'DROPPING';
                }
                
                this.updateOrbVisual();
            }

            updateOrbVisual() {
                const orb = this.elements.orb;
                orb.className = 'orb ' + this.stage.toLowerCase();
                orb.style.left = this.pos.x + '%';
                orb.style.top = this.pos.y + '%';
            }

            createWaveformBars() {
                const waveform = this.elements.waveform;
                const barCount = 60;
                
                for (let i = 0; i < barCount; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.left = (i * (100 / barCount)) + '%';
                    bar.style.width = (100 / barCount * 0.8) + '%';
                    bar.style.height = '2px';
                    waveform.appendChild(bar);
                }
            }

            async start() {
                try {
                    // Create audio context first
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Setup audio chain before mic request
                    this.setupAudioChain();
                    
                    // Create built-in drum sounds
                    await this.createBuiltInDrums();

                    // Request microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    await this.setupMicrophone(stream);

                    // Show interface
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    this.elements.sampleViz.classList.remove('hidden');
                    this.elements.controls.classList.remove('hidden');
                    this.elements.layerStatus.classList.remove('hidden');
                    this.elements.instructions.classList.remove('hidden');

                    this.active = true;
                    this.motionHistory = new Array(60).fill(0.1);
                    
                    // Add some initial samples
                    this.addInitialSamples();
                    
                    this.startVisualizationLoop();
                    this.startSequencer();
                    this.startAnimationLoop();

                    console.log('🎵 GUMP ENGINE STARTED');
                    
                } catch (error) {
                    console.error('Failed to start engine:', error);
                    alert('Failed to start engine: ' + error.message);
                }
            }

            setupAudioChain() {
                // Master gain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;
                this.masterGain.connect(this.ctx.destination);

                // Create layer gains
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const gain = this.ctx.createGain();
                    gain.gain.value = this.getLayerGain(layerName);
                    gain.connect(this.masterGain);
                    this.sampleLayers[layerName].gain = gain;
                });
            }

            getLayerGain(layerName) {
                const gains = {
                    kick: 1.0,
                    snare: 0.8,
                    hats: 0.6,
                    bass: 0.9,
                    lead: 0.7,
                    fx: 0.6
                };
                return gains[layerName] || 1.0;
            }

            async createBuiltInDrums() {
                // Create kick drum
                this.builtInDrums.kick = await this.createKickBuffer();
                
                // Create snare drum
                this.builtInDrums.snare = await this.createSnareBuffer();
                
                // Create hi-hat
                this.builtInDrums.hat = await this.createHatBuffer();
            }

            createKickBuffer() {
                const duration = 0.5;
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    // Sine wave with pitch envelope
                    const pitch = 60 * Math.exp(-35 * t);
                    data[i] = Math.sin(2 * Math.PI * pitch * t) * Math.exp(-4 * t);
                    // Add click
                    if (t < 0.005) {
                        data[i] += (Math.random() * 2 - 1) * 0.5 * (1 - t / 0.005);
                    }
                }

                return buffer;
            }

            createSnareBuffer() {
                const duration = 0.2;
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    // Mix of tone and noise
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.5;
                    const noise = (Math.random() * 2 - 1) * 0.5;
                    data[i] = (tone + noise) * Math.exp(-5 * t);
                }

                return buffer;
            }

            createHatBuffer() {
                const duration = 0.05;
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    // High frequency noise
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-100 * t);
                }

                return buffer;
            }

            async setupMicrophone(stream) {
                this.microphone = this.ctx.createMediaStreamSource(stream);
                
                // Create analyser
                this.micAnalyser = this.ctx.createAnalyser();
                this.micAnalyser.fftSize = 2048;
                this.micAnalyser.smoothingTimeConstant = 0.3;
                this.micDataArray = new Uint8Array(this.micAnalyser.frequencyBinCount);
                
                // Create script processor for recording
                this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                
                // Connect mic -> analyser
                this.microphone.connect(this.micAnalyser);
                
                // Setup recording
                this.recorder.onaudioprocess = (e) => {
                    if (this.isRecording) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        this.recordBuffer.push(...inputData);
                        
                        // Check max duration
                        const duration = this.recordBuffer.length / this.ctx.sampleRate;
                        if (duration >= this.maxRecordTime) {
                            this.stopRecording();
                        }
                    }
                };
            }

            addInitialSamples() {
                // Add built-in drums as initial samples
                const kickSample = {
                    id: 'kick_' + Date.now(),
                    buffer: this.builtInDrums.kick,
                    duration: this.builtInDrums.kick.duration,
                    analysis: { energy: 'high', brightness: 'dark', lowFreq: 0.8, midFreq: 0.2, highFreq: 0 }
                };
                
                const snareSample = {
                    id: 'snare_' + Date.now(),
                    buffer: this.builtInDrums.snare,
                    duration: this.builtInDrums.snare.duration,
                    analysis: { energy: 'medium', brightness: 'bright', lowFreq: 0.2, midFreq: 0.6, highFreq: 0.2 }
                };
                
                const hatSample = {
                    id: 'hat_' + Date.now(),
                    buffer: this.builtInDrums.hat,
                    duration: this.builtInDrums.hat.duration,
                    analysis: { energy: 'low', brightness: 'bright', lowFreq: 0, midFreq: 0.2, highFreq: 0.8 }
                };
                
                this.sampleLibrary.push(kickSample, snareSample, hatSample);
                this.sampleLayers.kick.samples.push(kickSample);
                this.sampleLayers.snare.samples.push(snareSample);
                this.sampleLayers.hats.samples.push(hatSample);
                
                console.log('📦 Added initial drum samples');
                this.updateStage();
            }

            startVisualizationLoop() {
                const loop = () => {
                    if (!this.active) return;

                    // Get mic data
                    if (this.micAnalyser) {
                        this.micAnalyser.getByteFrequencyData(this.micDataArray);
                        this.updateVisualization();

                        // Check for auto-sampling
                        const avgLevel = this.getAverageVolume();
                        const now = Date.now();
                        const canSample = now - this.lastSampleTime > this.samplingCooldown;
                        
                        if (avgLevel > this.sampleThreshold && canSample && !this.isRecording) {
                            this.startRecording();
                        }
                    }

                    requestAnimationFrame(loop);
                };
                loop();
            }

            getAverageVolume() {
                if (!this.micDataArray) return 0;
                let sum = 0;
                for (let i = 0; i < this.micDataArray.length; i++) {
                    sum += this.micDataArray[i];
                }
                return sum / this.micDataArray.length / 255;
            }

            updateVisualization() {
                // Update waveform bars
                const bars = this.elements.waveform.querySelectorAll('.waveform-bar');
                const dataStep = Math.floor(this.micDataArray.length / bars.length);
                
                bars.forEach((bar, i) => {
                    const dataIndex = i * dataStep;
                    const value = this.micDataArray[dataIndex] / 255;
                    const height = Math.max(2, value * 40);
                    bar.style.height = height + 'px';
                });

                // Update status displays
                this.elements.sampleStatus.textContent = this.isRecording ? 'RECORDING...' : this.stage;
                this.elements.sampleCount.textContent = `${this.sampleLibrary.length} SAMPLES`;
                this.elements.bpmDisplay.textContent = `${Math.round(this.bpm)} BPM`;
                this.elements.stageDisplay.textContent = this.stage;
                this.elements.motionDisplay.textContent = this.motionPattern.toUpperCase();

                // Update layer counts
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const count = this.sampleLayers[layerName].samples.length;
                    const layerEl = document.querySelector(`[data-layer="${layerName}"] .layer-count`);
                    if (layerEl) layerEl.textContent = count;
                });
            }

            startRecording() {
                if (this.isRecording) return;
                
                console.log('🎤 Recording...');
                this.isRecording = true;
                this.recordBuffer = [];
                this.recordingStartTime = Date.now();
                this.lastSampleTime = Date.now();
                
                // Connect recorder
                this.microphone.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
                
                this.updateOrbVisual();
            }

            stopRecording() {
                if (!this.isRecording) return;
                
                console.log('✅ Recording stopped');
                this.isRecording = false;
                
                // Disconnect recorder
                this.microphone.disconnect(this.recorder);
                this.recorder.disconnect();
                
                // Process recorded audio
                if (this.recordBuffer.length > 0) {
                    this.createSampleFromRecording();
                }
            }

            createSampleFromRecording() {
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                const sample = {
                    id: 'rec_' + Date.now(),
                    buffer: buffer,
                    duration: buffer.duration,
                    analysis: this.analyzeBuffer(buffer)
                };
                
                this.sampleLibrary.push(sample);
                this.categorizeSample(sample);
                this.updateStage();
                
                console.log(`📚 Sample added! Total: ${this.sampleLibrary.length}`);
            }

            analyzeBuffer(buffer) {
                const data = buffer.getChannelData(0);
                
                // Calculate RMS
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i];
                }
                const rms = Math.sqrt(sum / data.length);
                
                // Simple frequency analysis (zero-crossing rate)
                let zeroCrossings = 0;
                for (let i = 1; i < data.length; i++) {
                    if ((data[i] >= 0 && data[i-1] < 0) || (data[i] < 0 && data[i-1] >= 0)) {
                        zeroCrossings++;
                    }
                }
                const zcr = zeroCrossings / buffer.duration;
                
                // Determine characteristics
                const energy = rms > 0.1 ? 'high' : rms > 0.03 ? 'medium' : 'low';
                const brightness = zcr > 3000 ? 'bright' : 'dark';
                
                return {
                    rms,
                    zcr,
                    energy,
                    brightness,
                    lowFreq: brightness === 'dark' ? 0.7 : 0.3,
                    midFreq: 0.3,
                    highFreq: brightness === 'bright' ? 0.7 : 0.3
                };
            }

            categorizeSample(sample) {
                const { analysis } = sample;
                
                // Simple categorization based on characteristics
                let category = 'fx';
                
                if (analysis.energy === 'high' && analysis.brightness === 'dark') {
                    category = 'kick';
                } else if (analysis.energy === 'medium' && analysis.zcr > 2000) {
                    category = 'snare';
                } else if (analysis.brightness === 'bright' && analysis.energy === 'low') {
                    category = 'hats';
                } else if (analysis.brightness === 'dark' && analysis.energy === 'medium') {
                    category = 'bass';
                } else if (analysis.zcr > 1000 && analysis.zcr < 3000) {
                    category = 'lead';
                }
                
                this.sampleLayers[category].samples.push(sample);
                console.log(`🎯 Categorized as: ${category.toUpperCase()}`);
            }

            startSequencer() {
                if (this.isPlaying) return;
                this.isPlaying = true;

                const tick = () => {
                    if (!this.active || !this.isPlaying) return;

                    const now = this.ctx.currentTime;
                    const beatDuration = 60 / this.bpm / 4; // 16th notes
                    
                    if (now >= this.lastBeatTime + beatDuration) {
                        this.lastBeatTime = now;
                        this.playStep();
                        this.step = (this.step + 1) % 32;
                    }

                    requestAnimationFrame(tick);
                };

                this.lastBeatTime = this.ctx.currentTime;
                tick();
            }

            playStep() {
                // Visual pulse on downbeat
                if (this.step % 4 === 0) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }

                // Play patterns based on stage
                switch (this.stage) {
                    case 'SAMPLING':
                        this.playSamplingPattern();
                        break;
                    case 'CHOPPING':
                        this.playChoppingPattern();
                        break;
                    case 'FLIPPING':
                        this.playFlippingPattern();
                        break;
                    case 'DROPPING':
                        this.playDroppingPattern();
                        break;
                }
            }

            playSamplingPattern() {
                // Simple kick pattern
                if (this.step % 8 === 0) {
                    this.playLayerSample('kick');
                }
            }

            playChoppingPattern() {
                // Kick and snare
                if (this.step % 8 === 0) {
                    this.playLayerSample('kick');
                }
                if (this.step % 16 === 8) {
                    this.playLayerSample('snare');
                }
                // Occasional hats
                if (this.step % 4 === 2 && Math.random() < 0.5) {
                    this.playLayerSample('hats');
                }
            }

            playFlippingPattern() {
                // Full beat
                if (this.step % 8 === 0) {
                    this.playLayerSample('kick');
                }
                if (this.step % 8 === 4) {
                    this.playLayerSample('snare');
                }
                if (this.step % 2 === 0) {
                    this.playLayerSample('hats');
                }
                // Bass on downbeats
                if (this.step % 16 === 0 && this.sampleLayers.bass.samples.length > 0) {
                    this.playLayerSample('bass');
                }
            }

            playDroppingPattern() {
                this.playFlippingPattern();
                
                // Add chaos
                if (Math.random() < this.controls.chaos) {
                    const layers = ['kick', 'snare', 'hats', 'lead', 'fx'];
                    const randomLayer = layers[Math.floor(Math.random() * layers.length)];
                    this.playLayerSample(randomLayer);
                }
            }

            playLayerSample(layerName) {
                const layer = this.sampleLayers[layerName];
                if (!layer || layer.samples.length === 0) return;

                const sample = layer.samples[Math.floor(Math.random() * layer.samples.length)];
                this.playSample(sample, layerName);
                
                // Visual feedback
                const layerEl = document.querySelector(`[data-layer="${layerName}"]`);
                if (layerEl) {
                    layerEl.classList.add('active');
                    setTimeout(() => layerEl.classList.remove('active'), 200);
                }
            }

            playSample(sample, layerName) {
                if (!sample || !sample.buffer) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                gain.gain.value = 0.8;

                // Random variations
                if (this.controls.chaos > 0.3 && Math.random() < this.controls.chaos) {
                    source.playbackRate.value = 0.9 + Math.random() * 0.2;
                }

                source.connect(gain);
                gain.connect(this.sampleLayers[layerName].gain);

                source.start();
                
                // Update debug
                this.updateDebug(`Playing: ${layerName} (${sample.id})`);
            }

            // Manual triggers
            triggerSample() {
                if (this.isRecording) {
                    this.stopRecording();
                } else {
                    this.startRecording();
                }
                this.createParticles(5, '#ff1414');
            }

            chopSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                this.playChoppedSample(sample);
                this.createParticles(8, '#00ff88');
            }

            flipSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                this.playReversedSample(sample);
                this.createParticles(10, '#8800ff');
            }

            pitchSample() {
                if (this.sampleLibrary.length === 0) return;
                
                const sample = this.sampleLibrary[Math.floor(Math.random() * this.sampleLibrary.length)];
                const pitchShift = Math.pow(2, (Math.random() * 2 - 1));
                this.playPitchedSample(sample, pitchShift);
                this.createParticles(12, '#ffff00');
            }

            triggerLayer(layerName) {
                this.playLayerSample(layerName);
                this.createParticles(6, this.getLayerColor(layerName));
            }

            playChoppedSample(sample) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                gain.gain.value = 0.7;

                const chopDuration = Math.min(0.2, sample.duration * 0.25);
                const startOffset = Math.random() * (sample.duration - chopDuration);

                source.connect(gain);
                gain.connect(this.masterGain);

                source.start(0, startOffset, chopDuration);
            }

            playReversedSample(sample) {
                const reversedBuffer = this.ctx.createBuffer(
                    sample.buffer.numberOfChannels,
                    sample.buffer.length,
                    sample.buffer.sampleRate
                );
                
                for (let channel = 0; channel < sample.buffer.numberOfChannels; channel++) {
                    const original = sample.buffer.getChannelData(channel);
                    const reversed = reversedBuffer.getChannelData(channel);
                    for (let i = 0; i < original.length; i++) {
                        reversed[i] = original[original.length - 1 - i];
                    }
                }

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = reversedBuffer;
                gain.gain.value = 0.6;

                source.connect(gain);
                gain.connect(this.masterGain);
                source.start();
            }

            playPitchedSample(sample, pitchMultiplier) {
                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                source.playbackRate.value = pitchMultiplier;
                gain.gain.value = 0.7;

                source.connect(gain);
                gain.connect(this.masterGain);
                source.start();
            }

            getLayerColor(layerName) {
                const colors = {
                    kick: '#ff0000',
                    snare: '#ff8800',
                    hats: '#ffff00',
                    bass: '#8800ff',
                    lead: '#00ff88',
                    fx: '#00ffff'
                };
                return colors[layerName] || '#ffffff';
            }

            createParticles(count, color) {
                const container = document.querySelector('.particles') || (() => {
                    const div = document.createElement('div');
                    div.className = 'particles';
                    document.body.appendChild(div);
                    return div;
                })();

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = this.pos.x + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = (Math.random() * 0.5) + 's';
                    particle.style.animationDuration = (3 + Math.random() * 3) + 's';
                    
                    container.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 6000);
                }
            }

            startAnimationLoop() {
                const loop = () => {
                    if (!this.active) return;

                    this.updateOrbVisual();
                    this.updateBackground();

                    requestAnimationFrame(loop);
                };
                loop();
            }

            updateBackground() {
                const intensity = Math.min(this.intensity / 3, 1);
                const sampleIntensity = Math.min(this.sampleLibrary.length / 20, 1);

                let background;
                switch (this.stage) {
                    case 'LISTENING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(255,20,20,${0.1 + intensity * 0.2}) 20%, 
                                    #000000 60%)`;
                        break;
                    case 'SAMPLING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(255,102,0,${0.2 + intensity * 0.3}) 15%, 
                                    rgba(255,20,20,${0.1 + sampleIntensity * 0.2}) 35%, 
                                    #000000 70%)`;
                        break;
                    case 'CHOPPING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(0,255,136,${0.3 + intensity * 0.4}) 12%, 
                                    rgba(255,102,0,${0.15 + sampleIntensity * 0.25}) 30%, 
                                    #000000 60%)`;
                        break;
                    case 'FLIPPING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    rgba(136,0,255,${0.4 + intensity * 0.4}) 10%, 
                                    rgba(0,255,136,${0.2 + sampleIntensity * 0.3}) 25%, 
                                    #000000 50%)`;
                        break;
                    case 'DROPPING':
                        const hue = (Date.now() / 100) % 360;
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                                    hsl(${hue}, 80%, ${60 + intensity * 30}%) 8%, 
                                    hsl(${(hue + 120) % 360}, 70%, ${40 + sampleIntensity * 30}%) 20%, 
                                    hsl(${(hue + 240) % 360}, 60%, 20%) 40%, 
                                    #000000 70%)`;
                        break;
                    default:
                        background = '#000000';
                }

                document.body.style.background = background;
            }

            toggleDebug() {
                this.elements.debugInfo.classList.toggle('hidden');
            }

            updateDebug(message) {
                if (this.elements.debugText) {
                    this.elements.debugText.textContent = message + '\n' + 
                        `Samples: ${this.sampleLibrary.length} | ` +
                        `Recording: ${this.isRecording} | ` +
                        `Step: ${this.step}`;
                }
            }
        }

        // Initialize the engine
        const engine = new GUMPEngine();

        console.log('🎵 GUMP ENGINE LOADED - Click START to begin!');
    </script>
</body>
</html>
