<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP 2.0</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#0a0a0a;overflow:hidden;touch-action:none;height:100vh;font-family:system-ui,-apple-system,sans-serif}
        canvas{position:fixed;inset:0}

        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100;cursor:pointer;background:#0a0a0a}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 1s}
        #enter div{width:140px;height:140px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;flex-direction:column;gap:8px}
        #enter .title{font-size:11px;letter-spacing:6px;color:rgba(255,255,255,0.4)}
        #enter .sub{font-size:8px;letter-spacing:2px;color:rgba(255,255,255,0.2)}
        #enter:hover div{border-color:rgba(255,255,255,0.4)}

        /* DIAL SYSTEM */
        #dials{position:fixed;bottom:0;left:0;right:0;z-index:50;padding:15px 10px 25px;background:linear-gradient(transparent,rgba(0,0,0,0.9))}
        .dial{margin-bottom:12px}
        .dial-label{font-size:9px;letter-spacing:3px;color:rgba(255,255,255,0.3);margin-bottom:6px;text-transform:uppercase}
        .dial-track{display:flex;gap:3px;overflow-x:auto;scrollbar-width:none;-ms-overflow-style:none;padding:3px 0}
        .dial-track::-webkit-scrollbar{display:none}
        .dial-option{flex-shrink:0;padding:8px 16px;border-radius:20px;font-size:11px;color:rgba(255,255,255,0.4);background:rgba(255,255,255,0.05);border:1px solid rgba(255,255,255,0.1);cursor:pointer;transition:all 0.2s;user-select:none}
        .dial-option:hover{background:rgba(255,255,255,0.1)}
        .dial-option.active{background:rgba(255,255,255,0.15);color:rgba(255,255,255,0.9);border-color:rgba(255,255,255,0.3)}

        /* Status */
        #status{position:fixed;top:15px;left:15px;font-size:10px;color:rgba(255,255,255,0.25);z-index:40}
    </style>
</head>
<body>
<div id="enter">
    <div>
        <span class="title">GUMP</span>
        <span class="sub">tap to begin</span>
    </div>
</div>

<div id="dials" style="display:none">
    <div class="dial" id="beats-dial">
        <div class="dial-label">beats</div>
        <div class="dial-track">
            <div class="dial-option" data-value="none">none</div>
            <div class="dial-option active" data-value="lofi">lo-fi</div>
            <div class="dial-option" data-value="trap">trap</div>
            <div class="dial-option" data-value="jazz">jazz</div>
            <div class="dial-option" data-value="rock">rock</div>
        </div>
    </div>
    <div class="dial" id="bass-dial">
        <div class="dial-label">bass</div>
        <div class="dial-track">
            <div class="dial-option" data-value="none">none</div>
            <div class="dial-option active" data-value="sub">sub</div>
            <div class="dial-option" data-value="funk">funk</div>
            <div class="dial-option" data-value="synth">synth</div>
        </div>
    </div>
    <div class="dial" id="vibe-dial">
        <div class="dial-label">vibe</div>
        <div class="dial-track">
            <div class="dial-option" data-value="raw">raw</div>
            <div class="dial-option active" data-value="lofi">lo-fi</div>
            <div class="dial-option" data-value="polished">polished</div>
            <div class="dial-option" data-value="crushed">crushed</div>
        </div>
    </div>
</div>

<div id="status"></div>
<canvas id="c"></canvas>

<script>
// GUMP 2.0 - THE DIAL SYSTEM
// Genre dials + motion-controlled layers + vibe processing

const TAU = Math.PI * 2;

// ============ STATE ============

let ctx, master, vibeChain, comp;
let canvas, vc;
let running = false;

// Dial selections
let dials = {
    beats: 'lofi',
    bass: 'sub',
    vibe: 'lofi'
};

// Field state
let field = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    energy: 0,
    time: 0
};

// Layers created by motion
let layers = [];
const MAX_LAYERS = 6;

// Beat state
let beatTime = 0;
let beatPhase = 0;

// ============ GENRE CONFIGS ============

const BEAT_CONFIGS = {
    none: { bpm: 0, pattern: [] },
    lofi: {
        bpm: 72,
        swing: 0.15,
        pattern: [
            { time: 0, type: 'kick', vel: 0.8 },
            { time: 0.5, type: 'snare', vel: 0.5 },
            { time: 1, type: 'kick', vel: 0.6 },
            { time: 1.5, type: 'snare', vel: 0.7 },
            { time: 0.25, type: 'hat', vel: 0.2 },
            { time: 0.75, type: 'hat', vel: 0.25 },
            { time: 1.25, type: 'hat', vel: 0.2 },
            { time: 1.75, type: 'hat', vel: 0.3 }
        ]
    },
    trap: {
        bpm: 140,
        swing: 0,
        pattern: [
            { time: 0, type: 'kick', vel: 1.0 },
            { time: 0.75, type: 'kick', vel: 0.8 },
            { time: 1, type: 'snare', vel: 0.9 },
            { time: 1.5, type: 'kick', vel: 0.7 },
            // Rapid hats
            { time: 0, type: 'hat', vel: 0.4 },
            { time: 0.125, type: 'hat', vel: 0.2 },
            { time: 0.25, type: 'hat', vel: 0.35 },
            { time: 0.375, type: 'hat', vel: 0.2 },
            { time: 0.5, type: 'hat', vel: 0.4 },
            { time: 0.625, type: 'hat', vel: 0.2 },
            { time: 0.75, type: 'hat', vel: 0.35 },
            { time: 0.875, type: 'hat', vel: 0.2 },
            { time: 1.0, type: 'hat', vel: 0.4 },
            { time: 1.125, type: 'hat', vel: 0.2 },
            { time: 1.25, type: 'hat', vel: 0.35 },
            { time: 1.375, type: 'hat', vel: 0.2 },
            { time: 1.5, type: 'hat', vel: 0.4 },
            { time: 1.625, type: 'hat', vel: 0.2 },
            { time: 1.75, type: 'hat', vel: 0.35 },
            { time: 1.875, type: 'hat', vel: 0.2 }
        ]
    },
    jazz: {
        bpm: 95,
        swing: 0.3,
        pattern: [
            { time: 0, type: 'kick', vel: 0.5 },
            { time: 1.5, type: 'kick', vel: 0.4 },
            { time: 1, type: 'snare', vel: 0.3 },
            // Ride pattern
            { time: 0, type: 'ride', vel: 0.5 },
            { time: 0.33, type: 'ride', vel: 0.3 },
            { time: 0.66, type: 'ride', vel: 0.4 },
            { time: 1, type: 'ride', vel: 0.5 },
            { time: 1.33, type: 'ride', vel: 0.3 },
            { time: 1.66, type: 'ride', vel: 0.4 }
        ]
    },
    rock: {
        bpm: 120,
        swing: 0,
        pattern: [
            { time: 0, type: 'kick', vel: 1.0 },
            { time: 1, type: 'snare', vel: 0.9 },
            { time: 0.5, type: 'kick', vel: 0.7 },
            { time: 1.5, type: 'snare', vel: 0.85 },
            // Steady 8ths
            { time: 0, type: 'hat', vel: 0.5 },
            { time: 0.25, type: 'hat', vel: 0.4 },
            { time: 0.5, type: 'hat', vel: 0.5 },
            { time: 0.75, type: 'hat', vel: 0.4 },
            { time: 1, type: 'hat', vel: 0.5 },
            { time: 1.25, type: 'hat', vel: 0.4 },
            { time: 1.5, type: 'hat', vel: 0.5 },
            { time: 1.75, type: 'hat', vel: 0.4 }
        ]
    }
};

const BASS_CONFIGS = {
    none: { type: 'none' },
    sub: { type: 'sine', octave: -2, attack: 0.01, decay: 0.3 },
    funk: { type: 'sawtooth', octave: -1, attack: 0.005, decay: 0.15, filter: 800 },
    synth: { type: 'square', octave: -1, attack: 0.01, decay: 0.2, filter: 1200 }
};

const VIBE_CONFIGS = {
    raw: {
        filterFreq: 20000,
        distortion: 0,
        bitcrush: 0,
        reverbMix: 0.1,
        compression: 1
    },
    lofi: {
        filterFreq: 3500,
        distortion: 0.1,
        bitcrush: 0.15,
        reverbMix: 0.25,
        compression: 4
    },
    polished: {
        filterFreq: 18000,
        distortion: 0,
        bitcrush: 0,
        reverbMix: 0.2,
        compression: 6
    },
    crushed: {
        filterFreq: 2500,
        distortion: 0.4,
        bitcrush: 0.5,
        reverbMix: 0.15,
        compression: 8
    }
};

// ============ DRUMS ============

function playKick(vel = 1) {
    const now = ctx.currentTime;
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();

    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(40, now + 0.1);

    gain.gain.setValueAtTime(0.7 * vel, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

    osc.connect(gain);
    gain.connect(vibeChain.input);

    osc.start(now);
    osc.stop(now + 0.3);
}

function playSnare(vel = 1) {
    const now = ctx.currentTime;

    // Body
    const osc = ctx.createOscillator();
    const oscGain = ctx.createGain();
    osc.type = 'triangle';
    osc.frequency.setValueAtTime(200, now);
    osc.frequency.exponentialRampToValueAtTime(120, now + 0.05);
    oscGain.gain.setValueAtTime(0.3 * vel, now);
    oscGain.gain.exponentialRampToValueAtTime(0.001, now + 0.15);
    osc.connect(oscGain);
    oscGain.connect(vibeChain.input);
    osc.start(now);
    osc.stop(now + 0.15);

    // Noise
    const bufferSize = ctx.sampleRate * 0.1;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }
    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const noiseFilter = ctx.createBiquadFilter();
    noiseFilter.type = 'highpass';
    noiseFilter.frequency.value = 1000;

    const noiseGain = ctx.createGain();
    noiseGain.gain.setValueAtTime(0.4 * vel, now);
    noiseGain.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

    noise.connect(noiseFilter);
    noiseFilter.connect(noiseGain);
    noiseGain.connect(vibeChain.input);
    noise.start(now);
    noise.stop(now + 0.12);
}

function playHat(vel = 1) {
    const now = ctx.currentTime;

    const bufferSize = ctx.sampleRate * 0.05;
    const buffer = ctx.createBuffer(1, bufferSize, ctx.sampleRate);
    const data = buffer.getChannelData(0);
    for (let i = 0; i < bufferSize; i++) {
        data[i] = Math.random() * 2 - 1;
    }

    const noise = ctx.createBufferSource();
    noise.buffer = buffer;

    const filter = ctx.createBiquadFilter();
    filter.type = 'highpass';
    filter.frequency.value = 7000;

    const gain = ctx.createGain();
    gain.gain.setValueAtTime(0.15 * vel, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.04);

    noise.connect(filter);
    filter.connect(gain);
    gain.connect(vibeChain.input);
    noise.start(now);
    noise.stop(now + 0.05);
}

function playRide(vel = 1) {
    const now = ctx.currentTime;

    // Metallic tone
    const osc1 = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();

    osc1.type = 'sine';
    osc1.frequency.value = 350;
    osc2.type = 'sine';
    osc2.frequency.value = 471;

    gain.gain.setValueAtTime(0.08 * vel, now);
    gain.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

    osc1.connect(gain);
    osc2.connect(gain);
    gain.connect(vibeChain.input);

    osc1.start(now);
    osc2.start(now);
    osc1.stop(now + 0.5);
    osc2.stop(now + 0.5);
}

let lastTriggers = {};

function updateBeats(dt) {
    const config = BEAT_CONFIGS[dials.beats];
    if (!config || config.bpm === 0) return;

    const beatsPerSecond = config.bpm / 60;
    const barLength = 2; // 2 beats per pattern
    const barDuration = barLength / beatsPerSecond;

    beatTime += dt;
    const barProgress = (beatTime % barDuration) / barDuration * barLength;

    // Check each pattern element
    for (const hit of config.pattern) {
        let triggerTime = hit.time;

        // Apply swing to off-beats
        if (config.swing && triggerTime % 0.5 !== 0) {
            triggerTime += config.swing * 0.125;
        }

        const hitId = `${hit.type}-${hit.time}`;
        const prevPhase = lastTriggers[hitId] || -1;

        // Trigger if we crossed this beat
        if (barProgress >= triggerTime && prevPhase < triggerTime) {
            switch (hit.type) {
                case 'kick': playKick(hit.vel); break;
                case 'snare': playSnare(hit.vel); break;
                case 'hat': playHat(hit.vel); break;
                case 'ride': playRide(hit.vel); break;
            }
        }

        lastTriggers[hitId] = barProgress >= triggerTime ? triggerTime : -1;
    }

    // Reset at bar boundary
    if (barProgress < 0.1) {
        lastTriggers = {};
    }
}

// ============ BASS ============

let bassOsc = null;
let bassGain = null;
let bassFilter = null;

function initBass() {
    bassOsc = ctx.createOscillator();
    bassGain = ctx.createGain();
    bassFilter = ctx.createBiquadFilter();

    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 500;

    bassGain.gain.value = 0;

    bassOsc.connect(bassFilter);
    bassFilter.connect(bassGain);
    bassGain.connect(vibeChain.input);

    bassOsc.start();
}

function updateBass() {
    const config = BASS_CONFIGS[dials.bass];
    if (!config || config.type === 'none') {
        bassGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
        return;
    }

    // Bass follows motion Y position (lower = lower pitch)
    const baseFreq = 55; // A1
    const octaveRange = 1.5;
    const freq = baseFreq * Math.pow(2, (1 - field.y) * octaveRange + (config.octave || 0));

    bassOsc.type = config.type;
    bassOsc.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.05);

    // Volume based on movement
    const targetVol = field.energy > 0.02 ? 0.25 : 0.1;
    bassGain.gain.linearRampToValueAtTime(targetVol, ctx.currentTime + 0.1);

    // Filter
    const filterFreq = config.filter || 400;
    bassFilter.frequency.linearRampToValueAtTime(filterFreq + field.energy * 500, ctx.currentTime + 0.05);
}

// ============ LAYERS (Motion-created sounds) ============

const BASE_FREQ = 220;

function createLayer() {
    if (layers.length >= MAX_LAYERS) {
        const old = layers.shift();
        old.osc.stop();
    }

    // Frequency from Y position
    const octaves = 2;
    const freq = BASE_FREQ * Math.pow(2, (1 - field.y) * octaves);

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // Vary timbre by layer count
    const types = ['sine', 'triangle', 'sine', 'triangle', 'sine', 'sine'];
    osc.type = types[layers.length % types.length];
    osc.frequency.value = freq;

    filter.type = 'lowpass';
    filter.frequency.value = 2000;
    filter.Q.value = 1;

    // Volume decreases with each layer
    const vol = 0.08 * Math.pow(0.7, layers.length);
    gain.gain.value = vol;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(vibeChain.input);

    osc.start();

    layers.push({
        osc, gain, filter,
        freq, vol,
        phase: 0,
        loopLength: 1 + Math.random() * 2,
        birthTime: field.time
    });
}

function updateLayers(dt) {
    const now = ctx.currentTime;

    for (const layer of layers) {
        layer.phase += dt / layer.loopLength;
        if (layer.phase >= 1) layer.phase -= 1;

        // Pulsing envelope
        const env = 0.4 + 0.6 * Math.exp(-layer.phase * 3);
        layer.gain.gain.linearRampToValueAtTime(layer.vol * env, now + 0.02);

        // Subtle pitch drift
        const drift = Math.sin(field.time * 0.3 + layer.birthTime) * 0.003;
        layer.osc.frequency.linearRampToValueAtTime(layer.freq * (1 + drift), now + 0.05);
    }
}

// Orb system for layer creation
let orb = { active: false, x: 0.5, y: 0.5, velocity: 0 };

function updateOrb(dt) {
    if (!orb.active) {
        if (field.energy > 0.03) {
            orb.active = true;
            orb.x = field.x;
            orb.y = field.y;
            orb.velocity = 0.3 + field.energy;
        }
        return;
    }

    // Move toward center
    const dx = 0.5 - orb.x;
    const dy = 0.5 - orb.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 0.02) {
        orb.x += (dx / dist) * orb.velocity * dt;
        orb.y += (dy / dist) * orb.velocity * dt;
    }

    // Create layer when reaching center
    if (dist < 0.04) {
        createLayer();
        orb.active = false;
    }

    // Fade if no movement
    if (field.energy < 0.01) {
        orb.active = false;
    }
}

// ============ VIBE CHAIN ============

function createVibeChain() {
    const input = ctx.createGain();
    const output = ctx.createGain();

    // Low-pass filter
    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 20000;

    // Distortion (waveshaper)
    const distortion = ctx.createWaveShaper();
    const distCurve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
        const x = (i / 128) - 1;
        distCurve[i] = Math.tanh(x);
    }
    distortion.curve = distCurve;

    // Simple reverb
    const reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.2;

    const delays = [];
    const times = [0.03, 0.07, 0.11, 0.17, 0.25, 0.37, 0.5, 0.8];
    times.forEach((t, i) => {
        const d = ctx.createDelay(2);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = 0.2 * Math.pow(0.7, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 3000 - i * 300;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(reverbGain);
        delays.push({ delay: d, gain: g, filter: f });
    });

    input.connect(filter);
    filter.connect(distortion);
    distortion.connect(output);
    reverbGain.connect(output);

    return {
        input, output, filter, distortion, reverbGain, delays,
        update(config) {
            const now = ctx.currentTime;
            filter.frequency.linearRampToValueAtTime(config.filterFreq, now + 0.1);
            reverbGain.gain.linearRampToValueAtTime(config.reverbMix, now + 0.1);

            // Update distortion curve based on amount
            const amount = 1 + config.distortion * 10;
            for (let i = 0; i < 256; i++) {
                const x = (i / 128) - 1;
                distCurve[i] = Math.tanh(x * amount) / Math.tanh(amount);
            }
            distortion.curve = distCurve;
        }
    };
}

function updateVibe() {
    const config = VIBE_CONFIGS[dials.vibe];
    vibeChain.update(config);
}

// ============ INIT ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master chain
    comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.ratio.value = 4;
    comp.attack.value = 0.003;
    comp.release.value = 0.15;

    master = ctx.createGain();
    master.gain.value = 0.8;

    vibeChain = createVibeChain();

    vibeChain.output.connect(comp);
    comp.connect(master);
    master.connect(ctx.destination);

    initBass();

    // Canvas
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);

    // Dial interactions
    document.querySelectorAll('.dial-option').forEach(opt => {
        opt.addEventListener('click', () => {
            const dial = opt.closest('.dial');
            const dialId = dial.id.replace('-dial', '');

            // Deselect siblings
            dial.querySelectorAll('.dial-option').forEach(o => o.classList.remove('active'));
            opt.classList.add('active');

            // Update state
            dials[dialId] = opt.dataset.value;

            // Reset beat tracking when changing beats
            if (dialId === 'beats') {
                beatTime = 0;
                lastTriggers = {};
            }

            updateVibe();
        });
    });
}

// ============ INPUT ============

function onMove(nx, ny) {
    nx = Math.max(0, Math.min(1, nx));
    ny = Math.max(0, Math.min(1, ny));

    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = field.x * 0.7 + nx * 0.3;
    field.y = field.y * 0.7 + ny * 0.3;

    const speed = Math.sqrt(field.vx * field.vx + field.vy * field.vy);
    field.energy = field.energy * 0.85 + speed * 0.5;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const rawAx = (a.x || 0) / 8;
    const rawAy = (a.y || 0) / 8;

    field.vx = field.vx * 0.7 + rawAx * 0.3;
    field.vy = field.vy * 0.7 + rawAy * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.1));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.1));

    field.energy = field.energy * 0.85 + Math.sqrt(rawAx * rawAx + rawAy * rawAy) * 0.4;
}

function onOrientation(e) {
    const gx = Math.max(-1, Math.min(1, (e.gamma || 0) / 40));
    const gy = Math.max(-1, Math.min(1, (e.beta || 0) / 40 - 1));
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ VISUALS ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;

    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade
    vc.fillStyle = 'rgba(10, 10, 10, 0.1)';
    vc.fillRect(0, 0, w, h);

    // Center target
    const centerAlpha = 0.05 + (orb.active ? 0.1 : 0);
    vc.strokeStyle = `rgba(255, 255, 255, ${centerAlpha})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w / 2, h / 2, 30, 0, TAU);
    vc.stroke();

    // Layers as rings
    for (let i = 0; i < layers.length; i++) {
        const layer = layers[i];
        const pulse = Math.exp(-layer.phase * 3);
        const radius = 40 + i * 30 + pulse * 20;
        const alpha = 0.1 + pulse * 0.2;

        const hue = 200 + (layer.freq / BASE_FREQ) * 40;

        vc.beginPath();
        vc.arc(w / 2, h / 2, radius, 0, TAU);
        vc.strokeStyle = `hsla(${hue}, 40%, 60%, ${alpha})`;
        vc.lineWidth = 1 + pulse * 2;
        vc.stroke();
    }

    // Orb
    if (orb.active) {
        const ox = orb.x * w;
        const oy = orb.y * h;
        const r = 10 + field.energy * 15;

        const grad = vc.createRadialGradient(ox, oy, 0, ox, oy, r * 2);
        grad.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
        grad.addColorStop(0.5, 'rgba(200, 220, 255, 0.3)');
        grad.addColorStop(1, 'transparent');

        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(ox, oy, r * 2, 0, TAU);
        vc.fill();

        // Trail to center
        vc.strokeStyle = 'rgba(255, 255, 255, 0.1)';
        vc.beginPath();
        vc.moveTo(ox, oy);
        vc.lineTo(w / 2, h / 2);
        vc.stroke();
    }

    // Cursor
    const cx = field.x * w;
    const cy = field.y * h;
    const cr = 4 + field.energy * 20;

    vc.fillStyle = `rgba(255, 255, 255, ${0.2 + field.energy * 0.4})`;
    vc.beginPath();
    vc.arc(cx, cy, cr, 0, TAU);
    vc.fill();

    // Beat pulse indicator
    const config = BEAT_CONFIGS[dials.beats];
    if (config && config.bpm > 0) {
        const beatPulse = 1 - (beatTime % (60 / config.bpm)) / (60 / config.bpm);
        const pulseAlpha = beatPulse * 0.15;
        vc.strokeStyle = `rgba(255, 255, 255, ${pulseAlpha})`;
        vc.lineWidth = 2;
        vc.beginPath();
        vc.arc(w / 2, h / 2, 25 + beatPulse * 10, 0, TAU);
        vc.stroke();
    }
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    const dt = 0.016;
    field.time += dt;

    updateBeats(dt);
    updateBass();
    updateOrb(dt);
    updateLayers(dt);
    updateVibe();

    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('dials').style.display = 'block';

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    updateVibe();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
