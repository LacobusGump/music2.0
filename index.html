<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump - Active Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 21px;
            --fib34: 34px;
            --fib55: 55px;
            --fib89: 89px;
            --fib144: 144px;
            --fib233: 144px;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
            cursor: none;
        }
        /* Custom cursor that shows sampling */
        .cursor {
            position: fixed;
            width: var(--fib34);
            height: var(--fib34);
            border: 1px solid rgba(255,255,255,0.3);
            border-radius: 50%;
            pointer-events: none;
            transition: transform 0.1s ease;
            z-index: 9999;
        }
        .cursor.sampling {
            animation: cursorPulse 0.5s ease-out;
        }
        @keyframes cursorPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); opacity: 1; }
            100% { transform: translate(-50%, -50%) scale(2); opacity: 0; }
        }
        /* Start */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.03) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }
        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }
        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }
        /* Title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }
        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }
        /* Interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }
        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        /* Real-time input meter */
        .input-meter {
            position: fixed;
            top: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib233);
            height: var(--fib8);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }
        .input-level {
            height: 100%;
            background: linear-gradient(to right, #00ff00, #ffff00, #ff0000);
            width: 0%;
            transition: width 0.05s ease;
        }
        /* Phase indicator */
        .phase-indicator {
            position: fixed;
            top: var(--fib55);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib5);
            opacity: 0.618;
            text-align: center;
            transition: all 0.382s ease;
        }
        .phase-indicator.collecting {
            color: #00ff00;
            text-shadow: 0 0 var(--fib13) rgba(0, 255, 0, 0.5);
        }
        .phase-indicator.building {
            color: #ff8c00;
            text-shadow: 0 0 var(--fib13) rgba(255, 140, 0, 0.5);
        }
        .phase-indicator.dropping {
            color: #ff0000;
            text-shadow: 0 0 var(--fib21) rgba(255, 0, 0, 0.8);
            animation: phasePulse 0.25s ease-in-out infinite;
        }
        .phase-indicator.void {
            color: #8a2be2;
            text-shadow: 0 0 var(--fib34) rgba(138, 43, 226, 0.8);
        }
        @keyframes phasePulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.1); }
        }
        /* Motion vector display */
        .motion-vector {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            width: var(--fib89);
            height: var(--fib89);
            border: 1px solid rgba(255,255,255,0.1);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .motion-dot {
            width: var(--fib8);
            height: var(--fib8);
            background: rgba(255,255,255,0.618);
            border-radius: 50%;
            position: absolute;
            transition: all 0.1s ease;
        }
        /* Layer grid - visual representation of samples */
        .layer-grid {
            position: fixed;
            bottom: var(--fib55);
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(4, var(--fib55));
            grid-template-rows: repeat(2, var(--fib34));
            gap: var(--fib8);
        }
        .layer-cell {
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
            transition: all 0.382s ease;
        }
        .layer-cell.active {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.08);
        }
        .layer-cell.recording {
            animation: cellRecord 1s ease-in-out infinite;
        }
        @keyframes cellRecord {
            0%, 100% { background: rgba(255,0,0,0.1); }
            50% { background: rgba(255,0,0,0.3); }
        }
        .layer-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        /* BPM and timing */
        .timing-info {
            position: fixed;
            bottom: var(--fib34);
            right: var(--fib34);
            text-align: right;
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
        }
        .bpm-value {
            font-size: var(--fib21);
            opacity: 0.618;
        }
        /* Build energy bar */
        .energy-bar {
            position: fixed;
            left: var(--fib21);
            top: 50%;
            transform: translateY(-50%);
            width: var(--fib8);
            height: var(--fib144);
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
            opacity: 0;
            transition: opacity 0.618s ease;
        }
        .energy-bar.active {
            opacity: 0.618;
        }
        .energy-fill {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: linear-gradient(to top, #8a2be2, #ff0000, #ff8c00);
            height: 0%;
            transition: height 0.1s ease;
        }
        /* Sample trigger zones */
        .trigger-zone {
            position: fixed;
            border: 1px dashed rgba(255,255,255,0.1);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.382s ease;
        }
        .trigger-zone.active {
            opacity: 1;
            animation: zoneGlow 2s ease-in-out infinite;
        }
        @keyframes zoneGlow {
            0%, 100% { box-shadow: 0 0 var(--fib13) rgba(255,255,255,0.2); }
            50% { box-shadow: 0 0 var(--fib21) rgba(255,255,255,0.4); }
        }
        /* Canvas */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        #visualizer { z-index: 1; opacity: 0.3; }
        #particles { z-index: 2; opacity: 0.5; }
        #spiral { z-index: 0; opacity: 0.05; }
        /* Instructions */
        .instructions {
            position: fixed;
            top: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            transition: opacity 0.618s ease;
            text-align: center;
        }
        .instructions.show {
            opacity: 0.618;
        }
        /* New: Record button */
        .record-button {
            position: fixed;
            bottom: var(--fib34);
            left: var(--fib34);
            width: var(--fib55);
            height: var(--fib34);
            background: rgba(255,0,0,0.1);
            border: 1px solid rgba(255,0,0,0.3);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            opacity: 0.618;
            transition: all 0.382s ease;
        }
        .record-button.recording {
            background: rgba(255,0,0,0.5);
            animation: recordPulse 1s ease-in-out infinite;
        }
        @keyframes recordPulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        .record-text {
            font-size: var(--fib8);
            letter-spacing: var(--fib2);
        }
    </style>
</head>
<body>
    <div class="cursor" id="cursor"></div>
   
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
   
    <div class="title">Gump by James McCandless - Enhanced by Grok</div>
   
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
   
    <div class="interface" id="interface">
        <div class="input-meter">
            <div class="input-level" id="inputLevel"></div>
        </div>
       
        <div class="phase-indicator" id="phaseIndicator">INITIALIZING</div>
       
        <div class="instructions" id="instructions">MOVE TO SAMPLE • STILLNESS TO BUILD</div>
       
        <div class="motion-vector">
            <div class="motion-dot" id="motionDot"></div>
        </div>
       
        <div class="layer-grid" id="layerGrid">
            <!-- 8 cells will be created -->
        </div>
       
        <div class="timing-info">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">128</div>
        </div>
       
        <div class="energy-bar" id="energyBar">
            <div class="energy-fill" id="energyFill"></div>
        </div>
       
        <!-- Invisible trigger zones -->
        <div class="trigger-zone" id="zone0"></div>
        <div class="trigger-zone" id="zone1"></div>
        <div class="trigger-zone" id="zone2"></div>
        <div class="trigger-zone" id="zone3"></div>
        
        <!-- New: Record button -->
        <div class="record-button" id="recordButton">
            <span class="record-text">RECORD</span>
        </div>
    </div>
    <script>
        // Gump Active Sampling Engine - 10x Engineered Version
        // Improvements:
        // 1. Fixed normalization bug: Normalize data before setting to buffer.
        // 2. Added live mic passthrough with optional effects for true "world sampling" feel.
        // 3. Improved beat detection with energy history and auto-BPM adjustment.
        // 4. Added pitch detection for samples to tune to musical key.
        // 5. Made ambient samples loopable with seamless trimming.
        // 6. Enhanced phase transitions with beat-aligned scheduling.
        // 7. Added device motion support for mobile (accelerometer triggers sampling).
        // 8. Implemented recording of output mix and download as WAV.
        // 9. More dynamic patterns and effects based on AI-like rules (e.g., layer harmony).
        // 10. Optimized performance, added touch support, better visuals.

        class GumpActiveSampler {
            constructor() {
                // Audio context
                this.ctx = null;
                this.masterOut = null;
                
                // Circular buffer for continuous recording
                this.circularBuffer = {
                    size: 0, // Will be set to 10 seconds
                    data: null,
                    writeIndex: 0,
                    isRecording: false
                };
                
                // Real-time analysis
                this.realtime = {
                    inputNode: null,
                    analyser: null,
                    processor: null,
                    inputLevel: 0,
                    beatDetector: {
                        history: new Array(43).fill(0), // For beat detection
                        historyIndex: 0,
                        sensitivity: 1.3,
                        lastBeatTime: 0,
                        beatInterval: 0,
                        beatCount: 0,
                        tempBpm: []
                    },
                    pitchDetector: null // Added for pitch detection
                };
                
                // Motion tracking with immediate response
                this.motion = {
                    x: 0.5,
                    y: 0.5,
                    velocity: 0,
                    lastX: 0.5,
                    lastY: 0.5,
                    lastTime: 0,
                    isMoving: false,
                    stillnessTime: 0,
                    captureThreshold: 0.05, // Lowered for sensitivity
                    accel: { x: 0, y: 0, z: 0 } // For device motion
                };
                
                // Sample layers
                this.layers = Array(8).fill(null).map(() => ({
                    buffer: null,
                    isActive: false,
                    source: null,
                    gain: null,
                    filter: null,
                    pattern: null,
                    type: null,
                    loop: false,
                    pitch: 0 // Detected pitch
                }));
                
                // Musical state
                this.musical = {
                    bpm: 128,
                    currentBeat: 0,
                    nextBeatTime: 0,
                    phase: 'collecting', // collecting, building, dropping, void
                    energy: 0,
                    scale: [0, 3, 5, 7, 10], // Pentatonic for easy harmony
                    key: 60 // Middle C
                };
                
                // AI DJ Brain
                this.ai = {
                    layerCount: 0,
                    buildStartTime: 0,
                    dropScheduled: false,
                    arrangement: [],
                    sampleMemory: []
                };
                
                // Effects
                this.fx = {
                    reverb: null,
                    delay: null,
                    compressor: null,
                    filter: null,
                    dryGain: null // For live passthrough
                };
                
                // Visual elements
                this.ui = {};
                this.canvases = {};
                
                // Trigger zones for spatial sampling
                this.zones = [];
                
                // Recording
                this.recorder = {
                    node: null,
                    chunks: [],
                    isRecording: false
                };
                
                this.init();
            }
            
            init() {
                // Get UI elements
                this.ui = {
                    start: document.getElementById('start'),
                    interface: document.getElementById('interface'),
                    cursor: document.getElementById('cursor'),
                    inputLevel: document.getElementById('inputLevel'),
                    phaseIndicator: document.getElementById('phaseIndicator'),
                    instructions: document.getElementById('instructions'),
                    motionDot: document.getElementById('motionDot'),
                    layerGrid: document.getElementById('layerGrid'),
                    bpmValue: document.getElementById('bpmValue'),
                    energyBar: document.getElementById('energyBar'),
                    energyFill: document.getElementById('energyFill'),
                    recordButton: document.getElementById('recordButton')
                };
                
                // Create layer cells
                for (let i = 0; i < 8; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'layer-cell';
                    cell.dataset.index = i;
                    const canvas = document.createElement('canvas');
                    canvas.className = 'layer-waveform';
                    canvas.width = 55;
                    canvas.height = 34;
                    cell.appendChild(canvas);
                    this.ui.layerGrid.appendChild(cell);
                }
                
                // Setup canvases
                ['spiral', 'visualizer', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d'),
                        width: window.innerWidth,
                        height: window.innerHeight
                    };
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
                
                // Create trigger zones
                this.createTriggerZones();
                
                // Mouse and touch tracking
                this.setupMouseTracking();
                this.setupTouchTracking();
                
                // Device motion for mobile
                this.setupDeviceMotion();
                
                // Start button
                this.ui.start.addEventListener('click', () => this.begin());
                
                // Record button
                this.ui.recordButton.addEventListener('click', () => this.toggleRecording());
                
                // Draw fibonacci spiral
                this.drawSpiral();
                
                // Resize handler
                window.addEventListener('resize', () => this.handleResize());
            }
            
            setupMouseTracking() {
                let mouseTimer;
                
                const updateMotion = (e) => {
                    this.ui.cursor.style.left = e.clientX + 'px';
                    this.ui.cursor.style.top = e.clientY + 'px';
                    
                    const now = performance.now();
                    const dt = (now - this.motion.lastTime) / 1000 || 0.016;
                    
                    const newX = e.clientX / window.innerWidth;
                    const newY = e.clientY / window.innerHeight;
                    
                    const dx = newX - this.motion.lastX;
                    const dy = newY - this.motion.lastY;
                    
                    this.motion.velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                    this.motion.x = newX;
                    this.motion.y = newY;
                    
                    this.motion.lastX = newX;
                    this.motion.lastY = newY;
                    this.motion.lastTime = now;
                    
                    this.motion.isMoving = true;
                    this.motion.stillnessTime = 0;
                    clearTimeout(mouseTimer);
                    
                    mouseTimer = setTimeout(() => {
                        this.motion.isMoving = false;
                    }, 100);
                    
                    if (this.ui.motionDot) {
                        this.ui.motionDot.style.transform = `translate(${(newX - 0.5) * 80}px, ${(newY - 0.5) * 80}px)`;
                    }
                };
                
                document.addEventListener('mousemove', updateMotion);
            }
            
            setupTouchTracking() {
                let touchTimer;
                
                document.addEventListener('touchmove', (e) => {
                    if (e.touches.length > 0) {
                        const touch = e.touches[0];
                        this.ui.cursor.style.left = touch.clientX + 'px';
                        this.ui.cursor.style.top = touch.clientY + 'px';
                        
                        const now = performance.now();
                        const dt = (now - this.motion.lastTime) / 1000 || 0.016;
                        
                        const newX = touch.clientX / window.innerWidth;
                        const newY = touch.clientY / window.innerHeight;
                        
                        const dx = newX - this.motion.lastX;
                        const dy = newY - this.motion.lastY;
                        
                        this.motion.velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                        this.motion.x = newX;
                        this.motion.y = newY;
                        
                        this.motion.lastX = newX;
                        this.motion.lastY = newY;
                        this.motion.lastTime = now;
                        
                        this.motion.isMoving = true;
                        this.motion.stillnessTime = 0;
                        clearTimeout(touchTimer);
                        
                        touchTimer = setTimeout(() => {
                            this.motion.isMoving = false;
                        }, 100);
                        
                        if (this.ui.motionDot) {
                            this.ui.motionDot.style.transform = `translate(${(newX - 0.5) * 80}px, ${(newY - 0.5) * 80}px)`;
                        }
                    }
                }, { passive: false });
            }
            
            setupDeviceMotion() {
                if (window.DeviceMotionEvent) {
                    window.addEventListener('devicemotion', (e) => {
                        this.motion.accel.x = e.acceleration.x || 0;
                        this.motion.accel.y = e.acceleration.y || 0;
                        this.motion.accel.z = e.acceleration.z || 0;
                        
                        const accelMag = Math.sqrt(
                            this.motion.accel.x ** 2 +
                            this.motion.accel.y ** 2 +
                            this.motion.accel.z ** 2
                        );
                        
                        if (accelMag > 5) { // Shake threshold
                            this.motion.velocity = Math.max(this.motion.velocity, accelMag / 100);
                            this.motion.isMoving = true;
                            this.motion.stillnessTime = 0;
                        }
                    });
                }
            }
            
            createTriggerZones() {
                // More zones for better interaction (8 zones now)
                const positions = [
                    { top: '5%', left: '5%', width: '20%', height: '20%' },
                    { top: '5%', right: '5%', width: '20%', height: '20%' },
                    { bottom: '5%', left: '5%', width: '20%', height: '20%' },
                    { bottom: '5%', right: '5%', width: '20%', height: '20%' },
                    { top: '40%', left: '20%', width: '20%', height: '20%' },
                    { top: '40%', right: '20%', width: '20%', height: '20%' },
                    { top: '20%', left: '40%', width: '20%', height: '20%' },
                    { bottom: '20%', right: '40%', width: '20%', height: '20%' }
                ];
                
                positions.forEach((pos, i) => {
                    const zone = document.createElement('div');
                    zone.className = 'trigger-zone';
                    zone.id = `zone${i}`;
                    Object.assign(zone.style, pos);
                    document.body.appendChild(zone);
                    this.zones.push({
                        element: zone,
                        index: i,
                        lastTrigger: 0
                    });
                });
            }
            
            async begin() {
                this.ui.start.style.display = 'none';
                
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });
                    
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    // Setup audio chain
                    await this.setupAudio(stream);
                    
                    // Show interface
                    this.ui.interface.classList.add('active');
                    this.ui.instructions.classList.add('show');
                    
                    // Start the engine!
                    this.startEngine();
                    
                } catch (error) {
                    console.error('Setup failed:', error);
                    alert('Microphone access required. Please reload and allow access.');
                }
            }
            
            async setupAudio(stream) {
                // Input from microphone
                this.realtime.inputNode = this.ctx.createMediaStreamSource(stream);
                
                // Analyser for visualization and analysis
                this.realtime.analyser = this.ctx.createAnalyser();
                this.realtime.analyser.fftSize = 2048;
                this.realtime.analyser.smoothingTimeConstant = 0.8;
                
                // Circular buffer (10 seconds)
                this.circularBuffer.size = this.ctx.sampleRate * 10;
                this.circularBuffer.data = new Float32Array(this.circularBuffer.size);
                
                // Script processor for recording (deprecated but still works; AudioWorklet for future)
                this.realtime.processor = this.ctx.createScriptProcessor(2048, 1, 1);
                this.realtime.processor.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    // Passthrough live audio
                    for (let i = 0; i < input.length; i++) {
                        output[i] = input[i];
                    }
                    
                    this.processRealtimeAudio(input);
                };
                
                // Setup effects
                this.setupEffects();
                
                // Connect input chain
                this.realtime.inputNode.connect(this.realtime.analyser);
                this.realtime.inputNode.connect(this.realtime.processor);
                this.realtime.processor.connect(this.fx.dryGain); // Passthrough to effects
                
                // Start recording to circular buffer
                this.circularBuffer.isRecording = true;
                
                // Setup recorder
                this.recorder.node = this.ctx.createScriptProcessor(2048, 1, 1);
                this.recorder.node.onaudioprocess = (e) => {
                    if (this.recorder.isRecording) {
                        this.recorder.chunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
                    }
                };
                this.masterOut.connect(this.recorder.node);
                this.recorder.node.connect(this.ctx.destination); // Dummy connect
            }
            
            setupEffects() {
                // Master compressor
                this.fx.compressor = this.ctx.createDynamicsCompressor();
                this.fx.compressor.threshold.value = -18; // Adjusted for better dynamics
                this.fx.compressor.knee.value = 6;
                this.fx.compressor.ratio.value = 8;
                
                // Reverb with better impulse
                this.fx.reverb = this.ctx.createConvolver();
                const reverbTime = 3; // Longer reverb
                const reverbDecay = 4;
                const impulseSamples = this.ctx.sampleRate * reverbTime;
                const impulse = this.ctx.createBuffer(1, impulseSamples, this.ctx.sampleRate); // Mono for simplicity
                const channelData = impulse.getChannelData(0);
                for (let i = 0; i < impulseSamples; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / impulseSamples, reverbDecay);
                }
                this.fx.reverb.buffer = impulse;
                
                // Delay
                this.fx.delay = this.ctx.createDelay(1);
                this.fx.delay.delayTime.value = 60 / this.musical.bpm / 4; // 1/4 note
                this.fx.delayFeedback = this.ctx.createGain();
                this.fx.delayFeedback.gain.value = 0.5;
                this.fx.delayGain = this.ctx.createGain();
                this.fx.delayGain.gain.value = 0.4;
                
                // Master filter
                this.fx.filter = this.ctx.createBiquadFilter();
                this.fx.filter.type = 'lowpass';
                this.fx.filter.frequency.value = 18000; // Slightly rolled off
                
                // Dry gain for live passthrough
                this.fx.dryGain = this.ctx.createGain();
                this.fx.dryGain.gain.value = 0.3; // Low dry mix
                
                // Connect delay feedback
                this.fx.delay.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delay);
                this.fx.delay.connect(this.fx.delayGain);
                
                // Master output
                this.masterOut = this.ctx.createGain();
                this.masterOut.gain.value = 0.9;
                
                // Master chain
                this.masterOut.connect(this.fx.filter);
                this.fx.filter.connect(this.fx.compressor);
                this.fx.compressor.connect(this.ctx.destination);
                
                // Effects sends
                this.fx.reverbSend = this.ctx.createGain();
                this.fx.reverbSend.gain.value = 0.3;
                this.masterOut.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb);
                this.fx.reverb.connect(this.fx.compressor); // Fixed: through compressor
                
                this.fx.delaySend = this.ctx.createGain();
                this.fx.delaySend.gain.value = 0.2;
                this.masterOut.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delay);
                this.fx.delayGain.connect(this.fx.compressor); // Fixed
                
                // Connect dry
                this.fx.dryGain.connect(this.masterOut);
            }
            
            processRealtimeAudio(input) {
                // Write to circular buffer
                for (let i = 0; i < input.length; i++) {
                    this.circularBuffer.data[this.circularBuffer.writeIndex] = input[i];
                    this.circularBuffer.writeIndex = (this.circularBuffer.writeIndex + 1) % this.circularBuffer.size;
                }
                
                // Calculate input level
                let sum = 0;
                for (let i = 0; i < input.length; i++) {
                    sum += Math.abs(input[i]);
                }
                this.realtime.inputLevel = sum / input.length;
                
                // Update UI
                const levelPercent = Math.min(100, this.realtime.inputLevel * 500);
                this.ui.inputLevel.style.width = levelPercent + '%';
                
                // Improved beat detection
                this.detectBeatImproved(input);
            }
            
            detectBeatImproved(input) {
                // Energy calculation
                let energy = 0;
                for (let i = 0; i < input.length; i++) {
                    energy += input[i] * input[i];
                }
                energy = energy / input.length;
                
                // History average
                this.realtime.beatDetector.history[this.realtime.beatDetector.historyIndex] = energy;
                this.realtime.beatDetector.historyIndex = (this.realtime.beatDetector.historyIndex + 1) % this.realtime.beatDetector.history.length;
                
                let avg = 0;
                for (let val of this.realtime.beatDetector.history) {
                    avg += val;
                }
                avg /= this.realtime.beatDetector.history.length;
                
                const now = this.ctx.currentTime;
                if (energy > avg * this.realtime.beatDetector.sensitivity && now - this.realtime.beatDetector.lastBeatTime > 0.2) {
                    const interval = now - this.realtime.beatDetector.lastBeatTime;
                    this.realtime.beatDetector.lastBeatTime = now;
                    this.realtime.beatDetector.tempBpm.push(60 / interval);
                    
                    if (this.realtime.beatDetector.tempBpm.length > 8) {
                        this.realtime.beatDetector.tempBpm.shift();
                    }
                    
                    // Average BPM
                    if (this.realtime.beatDetector.tempBpm.length >= 4) {
                        let sumBpm = 0;
                        for (let bpm of this.realtime.beatDetector.tempBpm) {
                            sumBpm += bpm;
                        }
                        const newBpm = Math.round(sumBpm / this.realtime.beatDetector.tempBpm.length);
                        if (Math.abs(newBpm - this.musical.bpm) > 2) {
                            this.musical.bpm = newBpm;
                            this.ui.bpmValue.textContent = newBpm;
                            this.fx.delay.delayTime.value = 60 / this.musical.bpm / 4;
                        }
                    }
                }
            }
            
            startEngine() {
                // Resume context if suspended
                if (this.ctx.state === 'suspended') {
                    this.ctx.resume();
                }
                
                // Start scheduler
                this.startScheduler();
                
                // Start motion tracking
                this.trackMotion();
                
                // Start visualization
                this.animate();
                
                // Show instructions
                setTimeout(() => {
                    this.ui.instructions.textContent = 'MOVE OR SHAKE TO SAMPLE • STILLNESS BUILDS ENERGY';
                }, 3000);
            }
            
            startScheduler() {
                const scheduleAhead = 0.1;
                const loop = () => {
                    const now = this.ctx.currentTime;
                    
                    while (this.musical.nextBeatTime < now + scheduleAhead) {
                        this.onBeat(this.musical.nextBeatTime);
                        this.musical.nextBeatTime += 60 / this.musical.bpm / 16; // Finer resolution: 64th notes
                        this.musical.currentBeat += 0.25; // Adjust increment
                    }
                    
                    requestAnimationFrame(loop);
                };
                
                this.musical.nextBeatTime = this.ctx.currentTime;
                loop();
            }
            
            onBeat(time) {
                const beat = Math.floor(this.musical.currentBeat);
                
                // Play active layers
                this.layers.forEach((layer, i) => {
                    if (layer.isActive && layer.pattern) {
                        const step = beat % 16;
                        if (layer.pattern[step]) {
                            this.triggerLayer(i, time);
                        }
                    }
                });
                
                // Update energy
                if (this.musical.phase === 'building') {
                    this.musical.energy = Math.min(1, (this.musical.currentBeat / 4 - this.ai.buildStartTime) / 32); // Slower build
                    this.ui.energyFill.style.height = (this.musical.energy * 100) + '%';
                    
                    if (this.musical.energy >= 1 && !this.ai.dropScheduled) {
                        this.ai.dropScheduled = true;
                        this.scheduleDrop();
                    }
                }
                
                // Generate atmospheric elements every 32 beats
                if (beat % 32 === 0) {
                    this.generateAtmosphere();
                }
            }
            
            trackMotion() {
                const track = () => {
                    if (this.motion.isMoving && this.motion.velocity > this.motion.captureThreshold) {
                        this.checkZoneTriggers();
                    } else {
                        this.motion.stillnessTime += 16; // Approx 60fps
                        
                        if (this.motion.stillnessTime > 1000 && this.ai.layerCount < 8) { // Faster ambient capture
                            this.captureAmbient();
                            this.motion.stillnessTime = 0;
                        }
                    }
                    
                    this.updatePhase();
                    
                    requestAnimationFrame(track);
                };
                
                track();
            }
            
            checkZoneTriggers() {
                const now = Date.now();
                const x = this.motion.x * window.innerWidth;
                const y = this.motion.y * window.innerHeight;
                
                this.zones.forEach((zone, i) => {
                    const rect = zone.element.getBoundingClientRect();
                    
                    if (x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom) {
                        if (now - zone.lastTrigger > 500) { // Faster triggers
                            zone.lastTrigger = now;
                            zone.element.classList.add('active');
                            this.captureSample(i % 8); // Map to 8 types
                            
                            setTimeout(() => {
                                zone.element.classList.remove('active');
                            }, 300);
                        }
                    }
                });
            }
            
            captureSample(zoneIndex) {
                this.ui.cursor.classList.add('sampling');
                setTimeout(() => this.ui.cursor.classList.remove('sampling'), 300);
                
                let targetLayer = this.layers.findIndex(layer => !layer.isActive);
                if (targetLayer === -1) {
                    targetLayer = this.ai.sampleMemory.shift();
                }
                
                // Dynamic capture length based on velocity
                const captureSeconds = 0.5 + (1 - Math.min(1, this.motion.velocity)) * 2;
                const captureLength = Math.floor(this.ctx.sampleRate * captureSeconds);
                const captureData = new Float32Array(captureLength);
                
                const offset = Math.floor(Math.random() * this.ctx.sampleRate * 1); // Up to 1s back
                const startIndex = (this.circularBuffer.writeIndex - captureLength - offset + this.circularBuffer.size) % this.circularBuffer.size;
                
                for (let i = 0; i < captureLength; i++) {
                    const idx = (startIndex + i) % this.circularBuffer.size;
                    captureData[i] = this.circularBuffer.data[idx];
                }
                
                this.processCapture(captureData, targetLayer, zoneIndex);
            }
            
            captureAmbient() {
                let targetLayer = this.layers.findIndex(layer => !layer.isActive);
                if (targetLayer === -1) return;
                
                const captureLength = Math.floor(this.ctx.sampleRate * (3 + Math.random() * 2)); // 3-5s for ambient
                const captureData = new Float32Array(captureLength);
                
                const startIndex = (this.circularBuffer.writeIndex - captureLength + this.circularBuffer.size) % this.circularBuffer.size;
                
                for (let i = 0; i < captureLength; i++) {
                    const idx = (startIndex + i) % this.circularBuffer.size;
                    captureData[i] = this.circularBuffer.data[idx];
                }
                
                this.processCapture(captureData, targetLayer, -1);
            }
            
            processCapture(data, layerIndex, zoneIndex) {
                // Normalize first
                let maxVal = 0;
                for (let i = 0; i < data.length; i++) {
                    maxVal = Math.max(maxVal, Math.abs(data[i]));
                }
                if (maxVal > 0) {
                    const scale = 0.8 / maxVal;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= scale;
                    }
                }
                
                // Create buffer after normalize
                const buffer = this.ctx.createBuffer(1, data.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(data);
                
                // Energy analysis after normalize
                let energy = 0;
                for (let i = 0; i < data.length; i++) {
                    energy += data[i] * data[i];
                }
                
                // Detect pitch (simple autocorrelation)
                const pitch = this.detectPitch(data);
                
                // Determine type
                const types = ['kick', 'snare', 'hat', 'bass', 'pad', 'lead', 'fx', 'ambient'];
                const type = zoneIndex >= 0 ? types[zoneIndex % types.length] : 'ambient';
                
                // Generate pattern
                const pattern = this.generatePattern(type);
                
                // Setup layer
                const layer = this.layers[layerIndex];
                layer.buffer = buffer;
                layer.isActive = true;
                layer.type = type;
                layer.pattern = pattern;
                layer.pitch = pitch;
                layer.loop = (type === 'ambient' || type === 'pad');
                
                // If loop, trim to approximate beat length for seamless loop
                if (layer.loop) {
                    const beatLength = Math.floor(this.ctx.sampleRate * (60 / this.musical.bpm));
                    const trimmedLength = Math.min(data.length, beatLength * Math.floor(data.length / beatLength));
                    if (trimmedLength > 0) {
                        const trimmedBuffer = this.ctx.createBuffer(1, trimmedLength, this.ctx.sampleRate);
                        trimmedBuffer.getChannelData(0).set(data.subarray(0, trimmedLength));
                        layer.buffer = trimmedBuffer;
                    }
                }
                
                // Create nodes
                layer.gain = this.ctx.createGain();
                layer.gain.gain.value = 0.8;
                
                layer.filter = this.ctx.createBiquadFilter();
                layer.filter.type = 'lowpass';
                layer.filter.frequency.value = 5000;
                
                layer.gain.connect(layer.filter);
                layer.filter.connect(this.masterOut);
                
                // Update UI
                const cell = this.ui.layerGrid.children[layerIndex];
                cell.classList.add('active');
                this.drawWaveform(cell.querySelector('canvas'), data);
                
                // Track
                this.ai.layerCount++;
                this.ai.sampleMemory.push(layerIndex);
                if (this.ai.sampleMemory.length > 8) this.ai.sampleMemory.shift();
            }
            
            detectPitch(data) {
                // Simple autocorrelation pitch detection
                const minFreq = 50;
                const maxFreq = 1000;
                const minLag = Math.floor(this.ctx.sampleRate / maxFreq);
                const maxLag = Math.floor(this.ctx.sampleRate / minFreq);
                
                let bestLag = minLag;
                let bestCorr = -Infinity;
                
                for (let lag = minLag; lag <= maxLag; lag++) {
                    let corr = 0;
                    for (let i = 0; i < data.length - lag; i++) {
                        corr += data[i] * data[i + lag];
                    }
                    if (corr > bestCorr) {
                        bestCorr = corr;
                        bestLag = lag;
                    }
                }
                
                return this.ctx.sampleRate / bestLag;
            }
            
            generatePattern(type) {
                const basePatterns = {
                    kick: [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
                    snare: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                    hat: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
                    bass: [1,1,0,0, 1,0,0,0, 1,0,1,0, 0,0,0,0],
                    pad: [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                    lead: [0,0,1,0, 0,1,0,0, 0,0,1,0, 0,1,0,0],
                    fx: [0,0,0,1, 0,0,1,0, 0,1,0,0, 1,0,0,0],
                    ambient: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]
                };
                
                let pattern = basePatterns[type] || basePatterns.ambient;
                
                // Dynamic modification based on phase and layer count
                if (this.musical.phase === 'dropping') {
                    pattern = pattern.map((step, i) => (i % 4 === 0 || Math.random() > 0.5) ? 1 : step);
                } else if (this.musical.phase === 'void') {
                    pattern = pattern.map(step => Math.random() > 0.8 ? step : 0);
                } else if (this.ai.layerCount > 4) {
                    pattern = pattern.map((step, i) => (i % 2 === 0) ? 1 : step); // Denser
                }
                
                return pattern;
            }
            
            triggerLayer(index, time) {
                const layer = this.layers[index];
                if (!layer.buffer || !layer.isActive) return;
                
                const source = this.ctx.createBufferSource();
                source.buffer = layer.buffer;
                source.loop = layer.loop;
                
                // Tune playback rate to fit key (simple detune)
                const targetNote = this.musical.scale[index % this.musical.scale.length] + this.musical.key;
                const targetFreq = 440 * Math.pow(2, (targetNote - 69) / 12);
                source.playbackRate.value = targetFreq / layer.pitch;
                
                // Phase effects
                if (this.musical.phase === 'dropping') {
                    source.playbackRate.value *= 1 + (Math.random() - 0.5) * 0.2;
                    layer.filter.frequency.value = 1000 + Math.random() * 4000;
                    layer.filter.Q.value = 10 + Math.random() * 20;
                } else if (this.musical.phase === 'void') {
                    source.playbackRate.value *= 0.6 + Math.random() * 0.4;
                    layer.filter.frequency.value = 100 + Math.random() * 600;
                }
                
                source.connect(layer.gain);
                source.start(time);
                
                if (!layer.loop) {
                    source.stop(time + layer.buffer.duration);
                }
                
                // Visual
                const cell = this.ui.layerGrid.children[index];
                cell.classList.add('recording');
                setTimeout(() => cell.classList.remove('recording'), 150);
            }
            
            updatePhase() {
                const oldPhase = this.musical.phase;
                
                if (this.ai.layerCount < 3) {
                    this.musical.phase = 'collecting';
                } else if (this.ai.layerCount < 6) {
                    if (oldPhase === 'collecting') {
                        this.musical.phase = 'building';
                        this.ai.buildStartTime = this.musical.currentBeat / 4;
                        this.ui.energyBar.classList.add('active');
                    }
                } else if (this.ai.layerCount >= 7 && this.musical.energy >= 1) {
                    this.musical.phase = 'void';
                }
                
                if (oldPhase !== this.musical.phase) {
                    this.ui.phaseIndicator.textContent = this.musical.phase.toUpperCase();
                    this.ui.phaseIndicator.className = `phase-indicator ${this.musical.phase}`;
                    
                    if (this.musical.phase === 'building') {
                        this.createBuildEffects();
                    } else if (this.musical.phase === 'void') {
                        this.createVoidEffects();
                    }
                }
            }
            
            createBuildEffects() {
                const sweep = this.ctx.createOscillator();
                const sweepGain = this.ctx.createGain();
                
                sweep.type = 'sawtooth';
                sweep.frequency.setValueAtTime(80, this.ctx.currentTime);
                sweep.frequency.exponentialRampToValueAtTime(5000, this.ctx.currentTime + 16);
                
                sweepGain.gain.setValueAtTime(0, this.ctx.currentTime);
                sweepGain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 16);
                
                sweep.connect(sweepGain);
                sweepGain.connect(this.fx.filter);
                
                sweep.start();
                sweep.stop(this.ctx.currentTime + 16);
            }
            
            scheduleDrop() {
                // Schedule at next bar
                const beatsToNextBar = 16 - (this.musical.currentBeat % 16);
                const timeToDrop = beatsToNextBar * (60 / this.musical.bpm / 4);
                
                setTimeout(() => {
                    this.musical.phase = 'dropping';
                    this.ui.phaseIndicator.textContent = 'DROP!';
                    this.ui.energyBar.classList.remove('active');
                    
                    this.createDropImpact();
                    
                    // Intensify patterns
                    this.layers.forEach(layer => {
                        if (layer.isActive) {
                            layer.pattern = layer.pattern.map((_, i) => (i % 2 === 0 || Math.random() > 0.4) ? 1 : 0);
                        }
                    });
                    
                    this.createWobbleBass();
                }, timeToDrop * 1000);
            }
            
            createDropImpact() {
                const sub = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                
                sub.type = 'sine';
                sub.frequency.setValueAtTime(100, this.ctx.currentTime);
                sub.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 1.5);
                
                subGain.gain.setValueAtTime(1.2, this.ctx.currentTime);
                subGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 1.5);
                
                sub.connect(subGain);
                subGain.connect(this.masterOut);
                
                sub.start();
                sub.stop(this.ctx.currentTime + 1.5);
            }
            
            createWobbleBass() {
                const bass = this.ctx.createOscillator();
                const bassFilter = this.ctx.createBiquadFilter();
                const bassGain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                
                bass.type = 'sawtooth';
                bass.frequency.value = 60;
                
                bassFilter.type = 'lowpass';
                bassFilter.frequency.value = 200;
                bassFilter.Q.value = 20;
                
                lfo.type = 'triangle'; // Softer wobble
                lfo.frequency.value = 6;
                
                lfoGain.gain.value = 1000;
                
                bassGain.gain.value = 0.6;
                
                lfo.connect(lfoGain);
                lfoGain.connect(bassFilter.frequency);
                
                bass.connect(bassFilter);
                bassFilter.connect(bassGain);
                bassGain.connect(this.masterOut);
                
                bass.start();
                lfo.start();
                
                const stopTime = this.ctx.currentTime + (32 * 60 / this.musical.bpm);
                bass.stop(stopTime);
                lfo.stop(stopTime);
            }
            
            createVoidEffects() {
                this.fx.reverbSend.gain.value = 0.7;
                
                this.fx.filter.frequency.exponentialRampToValueAtTime(300, this.ctx.currentTime + 3);
                
                this.fx.delay.delayTime.value = 60 / this.musical.bpm / 1; // Whole note
                
                const drone = this.ctx.createOscillator();
                const droneGain = this.ctx.createGain();
                
                drone.type = 'sine';
                drone.frequency.value = 30; // Deeper
                droneGain.gain.value = 0.3;
                
                drone.connect(droneGain);
                droneGain.connect(this.fx.reverb);
                
                drone.start();
            }
            
            generateAtmosphere() {
                if (this.musical.phase === 'collecting') return;
                
                const noteIndex = Math.floor(Math.random() * this.musical.scale.length);
                const note = this.musical.scale[noteIndex];
                const freq = 440 * Math.pow(2, (this.musical.key + note - 69) / 12);
                
                const osc = this.ctx.createOscillator();
                const env = this.ctx.createGain();
                
                osc.type = 'triangle'; // Softer
                osc.frequency.value = freq;
                
                const now = this.ctx.currentTime;
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(0.1, now + 1);
                env.gain.exponentialRampToValueAtTime(0.001, now + 5);
                
                osc.connect(env);
                env.connect(this.fx.reverbSend);
                
                osc.start(now);
                osc.stop(now + 5);
            }
            
            toggleRecording() {
                if (this.recorder.isRecording) {
                    this.recorder.isRecording = false;
                    this.ui.recordButton.classList.remove('recording');
                    this.exportRecording();
                } else {
                    this.recorder.isRecording = true;
                    this.recorder.chunks = [];
                    this.ui.recordButton.classList.add('recording');
                }
            }
            
            exportRecording() {
                const length = this.recorder.chunks.reduce((acc, chunk) => acc + chunk.length, 0);
                const audioData = new Float32Array(length);
                let offset = 0;
                this.recorder.chunks.forEach(chunk => {
                    audioData.set(chunk, offset);
                    offset += chunk.length;
                });
                
                // Create WAV file
                const wav = this.floatToWav(audioData, this.ctx.sampleRate);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'gump-mix.wav';
                a.click();
                
                URL.revokeObjectURL(url);
            }
            
            floatToWav(data, sampleRate) {
                const buffer = new ArrayBuffer(44 + data.length * 2);
                const view = new DataView(buffer);
                
                // RIFF header
                this.writeString(view, 0, 'RIFF');
                view.setUint32(4, 36 + data.length * 2, true);
                this.writeString(view, 8, 'WAVE');
                // FMT subchunk
                this.writeString(view, 12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                // Data subchunk
                this.writeString(view, 36, 'data');
                view.setUint32(40, data.length * 2, true);
                
                // Write samples
                let offset = 44;
                for (let i = 0; i < data.length; i++, offset += 2) {
                    let s = Math.max(-1, Math.min(1, data[i]));
                    view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                }
                
                return buffer;
            }
            
            writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
            
            drawWaveform(canvas, data) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.lineWidth = 1.5;
                
                const step = Math.ceil(data.length / width);
                
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    let sum = 0;
                    for (let j = 0; j < step; j++) {
                        sum += Math.abs(data[i * step + j] || 0);
                    }
                    const amp = sum / step;
                    const y = height / 2 + amp * height / 2 * (Math.random() > 0.5 ? 1 : -1); // More dynamic
                    
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
            }
            
            drawSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
                ctx.lineWidth = 0.5;
                
                let r = 0;
                let angle = 0;
                
                ctx.beginPath();
                for (let i = 0; i < 1000; i++) { // Denser spiral
                    r = i * 0.3;
                    angle = i * 0.05;
                    
                    const x = centerX + r * Math.cos(angle);
                    const y = centerY + r * Math.sin(angle);
                    
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }
            
            animate() {
                const draw = () => {
                    this.drawVisualizer();
                    this.drawParticles();
                    
                    requestAnimationFrame(draw);
                };
                
                draw();
            }
            
            drawVisualizer() {
                const { ctx, canvas } = this.canvases.visualizer;
                const freq = new Uint8Array(this.realtime.analyser.frequencyBinCount);
                this.realtime.analyser.getByteFrequencyData(freq);
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.03)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / 128; // Fewer bars for performance
                
                for (let i = 0; i < 128; i++) {
                    const height = (freq[i * 8] || 0) / 255 * canvas.height * 0.8;
                    const hue = (i / 128) * 360 + (this.musical.currentBeat * 2);
                    
                    ctx.fillStyle = `hsla(${hue % 360}, 80%, 60%, 0.9)`;
                    ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 1, height);
                }
            }
            
            drawParticles() {
                const { ctx, canvas } = this.canvases.particles;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const time = Date.now() * 0.002;
                const count = 20 + this.ai.layerCount * 5; // More particles
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + time * 0.2;
                    const radius = 150 + Math.sin(time + i * 0.5) * 100;
                    
                    const x = canvas.width / 2 + Math.cos(angle) * radius * (this.motion.velocity + 0.1);
                    const y = canvas.height / 2 + Math.sin(angle) * radius * (this.motion.velocity + 0.1);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, 3 + this.musical.energy * 5, 0, Math.PI * 2);
                    
                    let color;
                    switch (this.musical.phase) {
                        case 'collecting':
                            color = `rgba(0, 255, 0, ${0.4 + this.musical.energy * 0.4})`;
                            break;
                        case 'building':
                            color = `rgba(255, ${140 + this.musical.energy * 115}, 0, 0.9)`;
                            break;
                        case 'dropping':
                            color = `rgba(255, 0, ${Math.sin(time * 15) * 127 + 128}, 0.9)`;
                            break;
                        case 'void':
                            color = 'rgba(138, 43, 226, 0.7)';
                            break;
                        default:
                            color = 'rgba(255, 255, 255, 0.6)';
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
            
            handleResize() {
                Object.values(this.canvases).forEach(({ canvas, ctx }) => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                    this.canvases.width = window.innerWidth;
                    this.canvases.height = window.innerHeight;
                });
                this.drawSpiral();
            }
        }
        
        // Start Gump
        const gump = new GumpActiveSampler();
    </script>
</body>
</html>
