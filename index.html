<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump - AI DJ Mind</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
            height: 100vh;
            overflow: hidden;
            cursor: none;
        }

        /* AI Brain Visualization */
        #ai-brain {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 300px;
            pointer-events: none;
        }

        .neural-ring {
            position: absolute;
            border: 1px solid rgba(138, 43, 226, 0.3);
            border-radius: 50%;
            animation: rotate 20s linear infinite;
        }

        .neural-ring:nth-child(1) {
            width: 100%;
            height: 100%;
            animation-duration: 15s;
        }

        .neural-ring:nth-child(2) {
            width: 80%;
            height: 80%;
            top: 10%;
            left: 10%;
            animation-duration: 20s;
            animation-direction: reverse;
        }

        .neural-ring:nth-child(3) {
            width: 60%;
            height: 60%;
            top: 20%;
            left: 20%;
            animation-duration: 10s;
        }

        @keyframes rotate {
            from { transform: rotate(0deg); }
            to { transform: rotate(360deg); }
        }

        .neural-ring.processing {
            border-color: rgba(255, 0, 255, 0.8);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.6);
        }

        /* Start Screen */
        .start-screen {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #000;
            z-index: 1000;
        }

        .start-button {
            padding: 20px 40px;
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            font-size: 14px;
            letter-spacing: 4px;
            cursor: pointer;
            transition: all 0.3s;
        }

        .start-button:hover {
            border-color: rgba(138, 43, 226, 0.8);
            box-shadow: 0 0 30px rgba(138, 43, 226, 0.4);
        }

        /* Kick Pulse */
        .kick-pulse {
            position: fixed;
            bottom: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255, 0, 0, 0.8), transparent);
            opacity: 0;
            pointer-events: none;
        }

        .kick-pulse.hit {
            animation: kickHit 0.3s ease-out;
        }

        @keyframes kickHit {
            0% {
                transform: translateX(-50%) scale(0.8);
                opacity: 1;
            }
            100% {
                transform: translateX(-50%) scale(1.5);
                opacity: 0;
            }
        }

        /* AI Status */
        .ai-status {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            font-size: 12px;
            letter-spacing: 2px;
            opacity: 0.8;
        }

        .ai-state {
            margin-top: 10px;
            font-size: 18px;
            font-weight: 300;
            color: #8a2be2;
        }

        /* Frequency Analyzer */
        .freq-analyzer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 150px;
            opacity: 0.3;
            pointer-events: none;
        }

        /* Sample Slots */
        .sample-matrix {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(8, 60px);
            gap: 10px;
        }

        .sample-cell {
            width: 60px;
            height: 40px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
            transition: all 0.3s;
        }

        .sample-cell.active {
            border-color: rgba(255, 0, 255, 0.8);
            box-shadow: 0 0 10px rgba(255, 0, 255, 0.4);
        }

        .sample-cell.processing {
            background: rgba(138, 43, 226, 0.2);
        }

        .sample-visual {
            width: 100%;
            height: 100%;
            position: absolute;
        }

        /* Processing Indicators */
        .process-indicator {
            position: fixed;
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0;
            transition: opacity 0.2s;
            pointer-events: none;
            background: rgba(0, 0, 0, 0.8);
            padding: 5px 10px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .process-indicator.show {
            opacity: 0.8;
        }

        /* Cursor */
        .ai-cursor {
            position: fixed;
            width: 40px;
            height: 40px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.1s;
            mix-blend-mode: exclusion;
        }

        .ai-cursor.capturing {
            border-color: rgba(255, 0, 255, 1);
            box-shadow: 0 0 20px rgba(255, 0, 255, 0.8);
            animation: pulse 0.5s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        /* Build Meter */
        .tension-meter {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            width: 4px;
            height: 300px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
        }

        .tension-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            background: linear-gradient(to top, #ff0000, #ff00ff, #00ffff);
            height: 0%;
            transition: height 0.1s;
        }

        /* Parameter Display */
        .param-display {
            position: fixed;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            letter-spacing: 1px;
            opacity: 0.6;
            font-family: 'Monaco', monospace;
        }

        .param {
            margin: 10px 0;
            display: flex;
            justify-content: space-between;
            width: 150px;
        }

        .param-value {
            color: #8a2be2;
        }

        /* Canvas layers */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #spectrum-canvas { z-index: 1; }
        #waveform-canvas { z-index: 2; opacity: 0.5; }
        #particle-canvas { z-index: 3; }
    </style>
</head>
<body>
    <canvas id="spectrum-canvas"></canvas>
    <canvas id="waveform-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>

    <div class="start-screen" id="startScreen">
        <button class="start-button" id="startButton">INITIALIZE AI</button>
    </div>

    <div class="ai-cursor" id="cursor"></div>

    <div id="ai-brain" style="display: none;">
        <div class="neural-ring"></div>
        <div class="neural-ring"></div>
        <div class="neural-ring"></div>
    </div>

    <div class="ai-status" style="display: none;">
        <div>GUMP AI SYSTEM</div>
        <div class="ai-state" id="aiState">LISTENING</div>
    </div>

    <div class="freq-analyzer">
        <canvas id="freqCanvas" width="1920" height="150"></canvas>
    </div>

    <div class="kick-pulse" id="kickPulse"></div>

    <div class="sample-matrix" id="sampleMatrix" style="display: none;"></div>

    <div class="tension-meter" style="display: none;">
        <div class="tension-fill" id="tensionFill"></div>
    </div>

    <div class="param-display" id="paramDisplay" style="display: none;">
        <div class="param">
            <span>SPECTRAL DENSITY</span>
            <span class="param-value" id="spectralDensity">0.00</span>
        </div>
        <div class="param">
            <span>HARMONIC RATIO</span>
            <span class="param-value" id="harmonicRatio">0.00</span>
        </div>
        <div class="param">
            <span>TRANSIENT DETECT</span>
            <span class="param-value" id="transientDetect">0.00</span>
        </div>
        <div class="param">
            <span>SIDECHAIN DEPTH</span>
            <span class="param-value" id="sidechainDepth">0.95</span>
        </div>
    </div>

    <div class="process-indicator" id="processIndicator"></div>

    <script>
        // GUMP: Superhuman AI DJ System
        class GumpAI {
            constructor() {
                // Core Audio
                this.audioContext = null;
                this.masterBus = null;
                
                // The Heartbeat - Massive 105 BPM Kick
                this.kick = {
                    oscillator: null,
                    sub: null,
                    envelope: null,
                    nextHit: 0,
                    bpm: 105,
                    playing: false
                };
                
                // AI Brain State
                this.aiState = {
                    mode: 'LISTENING',
                    tension: 0,
                    spectralMemory: new Float32Array(1024),
                    harmonicProfile: [],
                    capturedSounds: [],
                    processQueue: [],
                    musicalKey: 'Am', // Dark minor key
                    scale: [57, 59, 60, 62, 64, 65, 67], // A minor scale
                };
                
                // Audio Analysis
                this.analysis = {
                    input: null,
                    analyzer: null,
                    fftSize: 2048,
                    dataArray: null,
                    spectralCentroid: 0,
                    spectralFlux: 0,
                    zeroCrossingRate: 0,
                    previousSpectrum: null
                };
                
                // Recording Buffer (30 seconds)
                this.recordBuffer = {
                    size: 0,
                    data: null,
                    writePos: 0,
                    isRecording: false
                };
                
                // Granular Engine
                this.granular = {
                    grains: [],
                    maxGrains: 50,
                    grainSize: 0.05,
                    grainOverlap: 0.8
                };
                
                // Effects Processing
                this.fx = {
                    sidechain: null,
                    sidechainDepth: 0.95,
                    reverb: null,
                    distortion: null,
                    filter: null,
                    delay: null,
                    spectralGate: null
                };
                
                // Motion Tracking
                this.motion = {
                    x: 0.5,
                    y: 0.5,
                    velocity: 0,
                    history: [],
                    gesture: null
                };
                
                // Sound Transformation Chains
                this.transformChains = {
                    bass: this.createBassChain,
                    lead: this.createLeadChain,
                    texture: this.createTextureChain,
                    percussion: this.createPercussionChain
                };
                
                // Visual Elements
                this.visuals = {
                    spectrum: null,
                    waveform: null,
                    particles: []
                };
                
                // UI References
                this.ui = {};
                
                this.init();
            }
            
            init() {
                // Get UI elements
                this.ui = {
                    startScreen: document.getElementById('startScreen'),
                    startButton: document.getElementById('startButton'),
                    cursor: document.getElementById('cursor'),
                    brain: document.getElementById('ai-brain'),
                    status: document.querySelector('.ai-status'),
                    aiState: document.getElementById('aiState'),
                    kickPulse: document.getElementById('kickPulse'),
                    sampleMatrix: document.getElementById('sampleMatrix'),
                    tensionMeter: document.querySelector('.tension-meter'),
                    tensionFill: document.getElementById('tensionFill'),
                    paramDisplay: document.getElementById('paramDisplay'),
                    processIndicator: document.getElementById('processIndicator')
                };
                
                // Create sample matrix cells
                for (let i = 0; i < 16; i++) {
                    const cell = document.createElement('div');
                    cell.className = 'sample-cell';
                    cell.innerHTML = '<canvas class="sample-visual" width="60" height="40"></canvas>';
                    this.ui.sampleMatrix.appendChild(cell);
                }
                
                // Setup canvases
                this.setupVisuals();
                
                // Mouse tracking
                this.setupMotionTracking();
                
                // Start button
                this.ui.startButton.addEventListener('click', () => this.initialize());
            }
            
            setupVisuals() {
                const canvases = ['spectrum-canvas', 'waveform-canvas', 'particle-canvas'];
                canvases.forEach(id => {
                    const canvas = document.getElementById(id);
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
                
                // Frequency analyzer
                const freqCanvas = document.getElementById('freqCanvas');
                freqCanvas.width = window.innerWidth;
            }
            
            setupMotionTracking() {
                let lastTime = Date.now();
                
                document.addEventListener('mousemove', (e) => {
                    // Update cursor
                    this.ui.cursor.style.left = e.clientX + 'px';
                    this.ui.cursor.style.top = e.clientY + 'px';
                    
                    // Calculate motion
                    const now = Date.now();
                    const x = e.clientX / window.innerWidth;
                    const y = e.clientY / window.innerHeight;
                    
                    const dx = x - this.motion.x;
                    const dy = y - this.motion.y;
                    const dt = (now - lastTime) / 1000;
                    
                    this.motion.velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                    this.motion.x = x;
                    this.motion.y = y;
                    
                    // Track history
                    this.motion.history.push({ x, y, v: this.motion.velocity, t: now });
                    if (this.motion.history.length > 30) {
                        this.motion.history.shift();
                    }
                    
                    lastTime = now;
                });
            }
            
            async initialize() {
                // Hide start screen
                this.ui.startScreen.style.display = 'none';
                
                // Show AI interface
                this.ui.brain.style.display = 'block';
                this.ui.status.style.display = 'block';
                this.ui.sampleMatrix.style.display = 'grid';
                this.ui.tensionMeter.style.display = 'block';
                this.ui.paramDisplay.style.display = 'block';
                
                try {
                    // Create audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'interactive',
                        sampleRate: 48000
                    });
                    
                    // Get microphone access
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                    
                    // Setup audio system
                    await this.setupAudioSystem(stream);
                    
                    // Start the AI
                    this.startAI();
                    
                } catch (err) {
                    console.error('Failed to initialize:', err);
                    alert('Microphone access is required for the AI to hear your environment.');
                }
            }
            
            async setupAudioSystem(stream) {
                // Input from microphone
                this.analysis.input = this.audioContext.createMediaStreamSource(stream);
                
                // Analyzer
                this.analysis.analyzer = this.audioContext.createAnalyser();
                this.analysis.analyzer.fftSize = this.analysis.fftSize;
                this.analysis.analyzer.smoothingTimeConstant = 0.8;
                this.analysis.dataArray = new Uint8Array(this.analysis.analyzer.frequencyBinCount);
                this.analysis.previousSpectrum = new Float32Array(this.analysis.analyzer.frequencyBinCount);
                
                // Recording buffer
                this.recordBuffer.size = this.audioContext.sampleRate * 30;
                this.recordBuffer.data = new Float32Array(this.recordBuffer.size);
                
                // Script processor for recording
                const recorder = this.audioContext.createScriptProcessor(4096, 1, 1);
                recorder.onaudioprocess = (e) => {
                    this.processIncomingAudio(e.inputBuffer.getChannelData(0));
                };
                
                // Master bus with hard limiting
                this.masterBus = this.audioContext.createDynamicsCompressor();
                this.masterBus.threshold.value = -3;
                this.masterBus.knee.value = 0;
                this.masterBus.ratio.value = 20;
                this.masterBus.attack.value = 0.001;
                this.masterBus.release.value = 0.05;
                
                // Setup FX chain
                await this.setupEffectsChain();
                
                // Setup massive kick
                this.setupKick();
                
                // Connect input chain
                this.analysis.input.connect(this.analysis.analyzer);
                this.analysis.input.connect(recorder);
                recorder.connect(this.audioContext.destination); // Required
                
                // Master output
                this.masterBus.connect(this.audioContext.destination);
                
                // Start recording
                this.recordBuffer.isRecording = true;
            }
            
            setupKick() {
                // This is the heartbeat - the massive kick that drives everything
                const createKickHit = () => {
                    const now = this.audioContext.currentTime;
                    
                    // Main oscillator
                    const osc = this.audioContext.createOscillator();
                    osc.type = 'sine';
                    osc.frequency.setValueAtTime(150, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + 0.15);
                    
                    // Sub oscillator for massive low end
                    const sub = this.audioContext.createOscillator();
                    sub.type = 'sine';
                    sub.frequency.setValueAtTime(40, now);
                    sub.frequency.exponentialRampToValueAtTime(20, now + 0.3);
                    
                    // Punch oscillator
                    const punch = this.audioContext.createOscillator();
                    punch.type = 'square';
                    punch.frequency.setValueAtTime(60, now);
                    
                    // Envelopes
                    const env = this.audioContext.createGain();
                    env.gain.setValueAtTime(1, now);
                    env.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
                    
                    const subEnv = this.audioContext.createGain();
                    subEnv.gain.setValueAtTime(0.8, now);
                    subEnv.gain.exponentialRampToValueAtTime(0.01, now + 0.8);
                    
                    const punchEnv = this.audioContext.createGain();
                    punchEnv.gain.setValueAtTime(0.3, now);
                    punchEnv.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
                    
                    // Distortion for character
                    const dist = this.audioContext.createWaveShaper();
                    dist.curve = this.makeDistortionCurve(10);
                    
                    // Connect
                    osc.connect(env);
                    sub.connect(subEnv);
                    punch.connect(punchEnv);
                    
                    env.connect(dist);
                    subEnv.connect(this.fx.sidechain);
                    punchEnv.connect(dist);
                    dist.connect(this.fx.sidechain);
                    
                    // Start
                    osc.start(now);
                    sub.start(now);
                    punch.start(now);
                    
                    osc.stop(now + 0.5);
                    sub.stop(now + 0.8);
                    punch.stop(now + 0.02);
                    
                    // Visual pulse
                    this.ui.kickPulse.classList.remove('hit');
                    void this.ui.kickPulse.offsetWidth;
                    this.ui.kickPulse.classList.add('hit');
                    
                    // Sidechain everything
                    this.triggerSidechain();
                };
                
                // Start the kick loop
                const scheduleKick = () => {
                    if (!this.kick.playing) return;
                    
                    const now = this.audioContext.currentTime;
                    const beatLength = 60 / this.kick.bpm;
                    
                    if (now >= this.kick.nextHit) {
                        createKickHit();
                        this.kick.nextHit = now + beatLength;
                    }
                    
                    setTimeout(scheduleKick, 50);
                };
                
                this.kick.playing = true;
                this.kick.nextHit = this.audioContext.currentTime;
                scheduleKick();
            }
            
            async setupEffectsChain() {
                // Sidechain compressor (receives all non-kick audio)
                this.fx.sidechain = this.audioContext.createGain();
                this.fx.sidechain.gain.value = 1;
                
                // Massive reverb
                this.fx.reverb = this.audioContext.createConvolver();
                const reverbTime = 4;
                const reverbDecay = 2;
                const length = this.audioContext.sampleRate * reverbTime;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let ch = 0; ch < 2; ch++) {
                    const data = impulse.getChannelData(ch);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, reverbDecay);
                    }
                }
                this.fx.reverb.buffer = impulse;
                
                this.fx.reverbSend = this.audioContext.createGain();
                this.fx.reverbSend.gain.value = 0.3;
                
                // Spectral gate for interesting effects
                this.fx.spectralGate = this.audioContext.createBiquadFilter();
                this.fx.spectralGate.type = 'bandpass';
                this.fx.spectralGate.frequency.value = 1000;
                this.fx.spectralGate.Q.value = 20;
                
                // Delay for space
                this.fx.delay = this.audioContext.createDelay(2);
                this.fx.delay.delayTime.value = 60 / this.kick.bpm / 4; // 1/4 note
                
                this.fx.delayFeedback = this.audioContext.createGain();
                this.fx.delayFeedback.gain.value = 0.6;
                
                this.fx.delaySend = this.audioContext.createGain();
                this.fx.delaySend.gain.value = 0.2;
                
                // Master filter
                this.fx.filter = this.audioContext.createBiquadFilter();
                this.fx.filter.type = 'lowpass';
                this.fx.filter.frequency.value = 20000;
                this.fx.filter.Q.value = 1;
                
                // Connect sidechain to effects
                this.fx.sidechain.connect(this.fx.filter);
                this.fx.filter.connect(this.masterBus);
                
                // Connect sends
                this.fx.sidechain.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb);
                this.fx.reverb.connect(this.masterBus);
                
                this.fx.sidechain.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delay);
                this.fx.delay.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delay);
                this.fx.delay.connect(this.masterBus);
            }
            
            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = Math.tanh(x * amount);
                }
                
                return curve;
            }
            
            triggerSidechain() {
                // Duck everything when kick hits
                const now = this.audioContext.currentTime;
                this.fx.sidechain.gain.cancelScheduledValues(now);
                this.fx.sidechain.gain.setValueAtTime(this.fx.sidechain.gain.value, now);
                this.fx.sidechain.gain.linearRampToValueAtTime(1 - this.fx.sidechainDepth, now + 0.01);
                this.fx.sidechain.gain.exponentialRampToValueAtTime(1, now + 0.15);
            }
            
            processIncomingAudio(input) {
                // Record to circular buffer
                for (let i = 0; i < input.length; i++) {
                    this.recordBuffer.data[this.recordBuffer.writePos] = input[i];
                    this.recordBuffer.writePos = (this.recordBuffer.writePos + 1) % this.recordBuffer.size;
                }
                
                // Spectral analysis
                this.analysis.analyzer.getByteFrequencyData(this.analysis.dataArray);
                
                // Calculate spectral features
                this.calculateSpectralFeatures();
                
                // AI decides if this is interesting
                if (this.isInterestingSound()) {
                    this.captureAndProcess();
                }
            }
            
            calculateSpectralFeatures() {
                const data = this.analysis.dataArray;
                const nyquist = this.audioContext.sampleRate / 2;
                
                // Spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
                
                for (let i = 0; i < data.length; i++) {
                    const magnitude = data[i] / 255;
                    const frequency = (i / data.length) * nyquist;
                    weightedSum += frequency * magnitude;
                    magnitudeSum += magnitude;
                }
                
                this.analysis.spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                
                // Spectral flux (change over time)
                let flux = 0;
                for (let i = 0; i < data.length; i++) {
                    const diff = (data[i] / 255) - this.analysis.previousSpectrum[i];
                    flux += diff > 0 ? diff * diff : 0;
                }
                this.analysis.spectralFlux = Math.sqrt(flux);
                
                // Store current spectrum
                for (let i = 0; i < data.length; i++) {
                    this.analysis.previousSpectrum[i] = data[i] / 255;
                }
                
                // Update display
                this.updateParameters();
            }
            
            isInterestingSound() {
                // AI decision making based on:
                // 1. Spectral flux (sudden changes)
                // 2. Motion velocity (user engagement)
                // 3. Spectral centroid (frequency content)
                // 4. Current musical needs
                
                const threshold = 0.3 - (this.aiState.tension * 0.2); // Lower threshold as tension builds
                const interest = (this.analysis.spectralFlux * 0.4) + 
                               (this.motion.velocity * 0.3) +
                               (Math.abs(this.analysis.spectralCentroid - 1000) / 10000 * 0.3);
                
                return interest > threshold && this.motion.velocity > 0.1;
            }
            
            captureAndProcess() {
                // Show capture feedback
                this.ui.cursor.classList.add('capturing');
                setTimeout(() => this.ui.cursor.classList.remove('capturing'), 500);
                
                // Determine capture length based on motion
                const baseLength = 0.1; // 100ms minimum
                const maxLength = 2.0; // 2 seconds maximum
                const captureLength = baseLength + (this.motion.velocity * (maxLength - baseLength));
                
                const samples = Math.floor(this.audioContext.sampleRate * captureLength);
                const captureBuffer = new Float32Array(samples);
                
                // Capture from buffer
                const startPos = (this.recordBuffer.writePos - samples + this.recordBuffer.size) % this.recordBuffer.size;
                for (let i = 0; i < samples; i++) {
                    const pos = (startPos + i) % this.recordBuffer.size;
                    captureBuffer[i] = this.recordBuffer.data[pos];
                }
                
                // Add to AI processing queue
                this.aiState.processQueue.push({
                    buffer: captureBuffer,
                    timestamp: Date.now(),
                    motion: { x: this.motion.x, y: this.motion.y, v: this.motion.velocity },
                    spectralProfile: {
                        centroid: this.analysis.spectralCentroid,
                        flux: this.analysis.spectralFlux
                    }
                });
                
                // Process immediately
                this.processNextInQueue();
            }
            
            processNextInQueue() {
                if (this.aiState.processQueue.length === 0) return;
                
                const item = this.aiState.processQueue.shift();
                
                // Show processing state
                this.showProcessingIndicator('ANALYZING SPECTRUM');
                document.querySelectorAll('.neural-ring').forEach(ring => {
                    ring.classList.add('processing');
                });
                
                // AI decides how to transform this sound
                const transformations = this.decideTransformations(item);
                
                // Apply transformations in parallel
                transformations.forEach(transform => {
                    this.applyTransformation(item, transform);
                });
                
                // Update AI state
                this.aiState.capturedSounds.push(item);
                this.updateAIState();
                
                setTimeout(() => {
                    document.querySelectorAll('.neural-ring').forEach(ring => {
                        ring.classList.remove('processing');
                    });
                }, 500);
            }
            
            decideTransformations(item) {
                const transforms = [];
                
                // Always create a granular texture
                transforms.push({
                    type: 'granular',
                    params: {
                        grainSize: 0.05 + (item.motion.v * 0.1),
                        grainRate: 20 + (this.aiState.tension * 30),
                        spread: item.spectralProfile.flux
                    }
                });
                
                // If high spectral centroid, make a lead
                if (item.spectralProfile.centroid > 2000) {
                    transforms.push({
                        type: 'lead',
                        params: {
                            pitch: this.quantizeToScale(item.spectralProfile.centroid),
                            filter: 'highpass',
                            resonance: 10
                        }
                    });
                }
                
                // If low centroid, make bass
                if (item.spectralProfile.centroid < 500) {
                    transforms.push({
                        type: 'bass',
                        params: {
                            pitch: -24, // Two octaves down
                            filter: 'lowpass',
                            distortion: 0.8
                        }
                    });
                }
                
                // If high flux, make percussion
                if (item.spectralProfile.flux > 0.5) {
                    transforms.push({
                        type: 'percussion',
                        params: {
                            envelope: 'fast',
                            pitch: Math.random() * 12 - 6,
                            filter: 'bandpass'
                        }
                    });
                }
                
                return transforms;
            }
            
            quantizeToScale(frequency) {
                // Convert frequency to MIDI note
                const midiNote = 69 + 12 * Math.log2(frequency / 440);
                
                // Find nearest note in scale
                let nearest = this.aiState.scale[0];
                let minDiff = Math.abs(midiNote - nearest);
                
                for (const note of this.aiState.scale) {
                    const diff = Math.abs(midiNote - note);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearest = note;
                    }
                }
                
                return nearest;
            }
            
            applyTransformation(item, transform) {
                switch (transform.type) {
                    case 'granular':
                        this.createGranularTexture(item.buffer, transform.params);
                        break;
                    case 'lead':
                        this.createLead(item.buffer, transform.params);
                        break;
                    case 'bass':
                        this.createBass(item.buffer, transform.params);
                        break;
                    case 'percussion':
                        this.createPercussion(item.buffer, transform.params);
                        break;
                }
                
                // Update visual
                this.updateSampleMatrix(transform.type);
            }
            
            createGranularTexture(buffer, params) {
                const grainSchedule = () => {
                    if (this.granular.grains.length >= this.granular.maxGrains) return;
                    
                    const now = this.audioContext.currentTime;
                    
                    // Create grain
                    const grain = this.audioContext.createBufferSource();
                    const grainBuffer = this.audioContext.createBuffer(1, 
                        Math.floor(params.grainSize * this.audioContext.sampleRate),
                        this.audioContext.sampleRate
                    );
                    
                    // Copy random section of buffer
                    const startPos = Math.floor(Math.random() * (buffer.length - grainBuffer.length));
                    const grainData = grainBuffer.getChannelData(0);
                    
                    for (let i = 0; i < grainData.length; i++) {
                        // Apply window
                        const window = 0.5 - 0.5 * Math.cos(2 * Math.PI * i / grainData.length);
                        grainData[i] = buffer[startPos + i] * window;
                    }
                    
                    grain.buffer = grainBuffer;
                    
                    // Random pitch variation
                    grain.playbackRate.value = 0.5 + Math.random() * 1.5;
                    
                    // Spatial positioning
                    const panner = this.audioContext.createStereoPanner();
                    panner.pan.value = (Math.random() - 0.5) * params.spread;
                    
                    // Envelope
                    const env = this.audioContext.createGain();
                    env.gain.setValueAtTime(0, now);
                    env.gain.linearRampToValueAtTime(0.5, now + params.grainSize * 0.1);
                    env.gain.exponentialRampToValueAtTime(0.001, now + params.grainSize);
                    
                    // Connect
                    grain.connect(panner);
                    panner.connect(env);
                    env.connect(this.fx.spectralGate);
                    env.connect(this.fx.reverbSend);
                    
                    grain.start(now);
                    grain.stop(now + params.grainSize);
                    
                    // Schedule next grain
                    setTimeout(() => grainSchedule(), 1000 / params.grainRate);
                };
                
                grainSchedule();
            }
            
            createLead(buffer, params) {
                const source = this.audioContext.createBufferSource();
                const audioBuffer = this.audioContext.createBuffer(1, buffer.length, this.audioContext.sampleRate);
                audioBuffer.getChannelData(0).set(buffer);
                source.buffer = audioBuffer;
                
                // Pitch to scale
                const targetFreq = 440 * Math.pow(2, (params.pitch - 69) / 12);
                source.playbackRate.value = targetFreq / this.analysis.spectralCentroid;
                
                // Filter
                const filter = this.audioContext.createBiquadFilter();
                filter.type = params.filter;
                filter.frequency.value = 2000;
                filter.Q.value = params.resonance;
                
                // Envelope
                const env = this.audioContext.createGain();
                const now = this.audioContext.currentTime;
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(0.7, now + 0.1);
                env.gain.exponentialRampToValueAtTime(0.001, now + 2);
                
                // Connect
                source.connect(filter);
                filter.connect(env);
                env.connect(this.fx.sidechain);
                env.connect(this.fx.delaySend);
                
                source.start();
            }
            
            createBass(buffer, params) {
                const source = this.audioContext.createBufferSource();
                const audioBuffer = this.audioContext.createBuffer(1, buffer.length, this.audioContext.sampleRate);
                audioBuffer.getChannelData(0).set(buffer);
                source.buffer = audioBuffer;
                
                // Pitch down
                source.playbackRate.value = Math.pow(2, params.pitch / 12);
                
                // Heavy lowpass
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 200;
                filter.Q.value = 5;
                
                // Distortion
                const dist = this.audioContext.createWaveShaper();
                dist.curve = this.makeDistortionCurve(20);
                
                // Envelope
                const env = this.audioContext.createGain();
                const now = this.audioContext.currentTime;
                env.gain.setValueAtTime(0, now);
                env.gain.linearRampToValueAtTime(0.8, now + 0.05);
                env.gain.exponentialRampToValueAtTime(0.001, now + 1);
                
                // Connect
                source.connect(filter);
                filter.connect(dist);
                dist.connect(env);
                env.connect(this.fx.sidechain);
                
                source.start();
                source.loop = true;
                source.loopEnd = 60 / this.kick.bpm; // One bar
            }
            
            createPercussion(buffer, params) {
                const source = this.audioContext.createBufferSource();
                const audioBuffer = this.audioContext.createBuffer(1, 
                    Math.min(buffer.length, this.audioContext.sampleRate * 0.1), // Max 100ms
                    this.audioContext.sampleRate
                );
                
                // Copy only the attack portion
                const data = audioBuffer.getChannelData(0);
                for (let i = 0; i < data.length; i++) {
                    data[i] = buffer[i] || 0;
                }
                
                source.buffer = audioBuffer;
                source.playbackRate.value = Math.pow(2, params.pitch / 12);
                
                // Tight bandpass
                const filter = this.audioContext.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 1000 + Math.random() * 2000;
                filter.Q.value = 20;
                
                // Fast envelope
                const env = this.audioContext.createGain();
                const now = this.audioContext.currentTime;
                env.gain.setValueAtTime(1, now);
                env.gain.exponentialRampToValueAtTime(0.001, now + 0.05);
                
                // Connect
                source.connect(filter);
                filter.connect(env);
                env.connect(this.fx.sidechain);
                
                // Quantize to beat
                const beatTime = 60 / this.kick.bpm;
                const nextBeat = Math.ceil(now / beatTime) * beatTime;
                source.start(nextBeat);
            }
            
            updateSampleMatrix(type) {
                const cells = this.ui.sampleMatrix.querySelectorAll('.sample-cell');
                const emptyCell = Array.from(cells).find(cell => !cell.classList.contains('active'));
                
                if (emptyCell) {
                    emptyCell.classList.add('active', 'processing');
                    
                    // Draw visualization
                    const canvas = emptyCell.querySelector('canvas');
                    const ctx = canvas.getContext('2d');
                    
                    // Different visualization per type
                    ctx.fillStyle = {
                        'granular': 'rgba(138, 43, 226, 0.8)',
                        'lead': 'rgba(0, 255, 255, 0.8)',
                        'bass': 'rgba(255, 0, 0, 0.8)',
                        'percussion': 'rgba(255, 255, 0, 0.8)'
                    }[type] || 'rgba(255, 255, 255, 0.8)';
                    
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    setTimeout(() => {
                        emptyCell.classList.remove('processing');
                    }, 500);
                }
            }
            
            updateAIState() {
                // Calculate tension based on captured sounds
                this.aiState.tension = Math.min(1, this.aiState.capturedSounds.length / 20);
                
                // Update tension meter
                this.ui.tensionFill.style.height = (this.aiState.tension * 100) + '%';
                
                // Update AI state display
                if (this.aiState.tension < 0.3) {
                    this.aiState.mode = 'SEEKING';
                } else if (this.aiState.tension < 0.7) {
                    this.aiState.mode = 'BUILDING';
                } else {
                    this.aiState.mode = 'TRANSFORMING';
                }
                
                this.ui.aiState.textContent = this.aiState.mode;
                
                // Automate filter based on tension
                const filterFreq = 20000 - (this.aiState.tension * 15000);
                this.fx.filter.frequency.exponentialRampToValueAtTime(
                    filterFreq,
                    this.audioContext.currentTime + 0.1
                );
                
                // Increase reverb with tension
                this.fx.reverbSend.gain.value = 0.3 + (this.aiState.tension * 0.4);
            }
            
            showProcessingIndicator(text) {
                this.ui.processIndicator.textContent = text;
                this.ui.processIndicator.classList.add('show');
                this.ui.processIndicator.style.left = (this.motion.x * 100) + '%';
                this.ui.processIndicator.style.top = (this.motion.y * 100) + '%';
                
                setTimeout(() => {
                    this.ui.processIndicator.classList.remove('show');
                }, 1000);
            }
            
            updateParameters() {
                // Update parameter display
                document.getElementById('spectralDensity').textContent = 
                    (this.analysis.spectralCentroid / 10000).toFixed(2);
                document.getElementById('harmonicRatio').textContent = 
                    (this.analysis.spectralFlux).toFixed(2);
                document.getElementById('transientDetect').textContent = 
                    (this.motion.velocity).toFixed(2);
                document.getElementById('sidechainDepth').textContent = 
                    this.fx.sidechainDepth.toFixed(2);
            }
            
            startAI() {
                // Start the AI processing loop
                this.runAI();
                
                // Start visualization
                this.animate();
                
                this.showProcessingIndicator('AI INITIALIZED');
            }
            
            runAI() {
                const think = () => {
                    // AI makes decisions based on current state
                    
                    // Adjust sidechain depth based on energy
                    this.fx.sidechainDepth = 0.95 - (this.aiState.tension * 0.2);
                    
                    // Random parameter mutations
                    if (Math.random() < 0.1) {
                        this.fx.spectralGate.frequency.value = 
                            200 + Math.random() * 3000;
                        this.fx.spectralGate.Q.value = 
                            10 + Math.random() * 30;
                    }
                    
                    // Check if we need to clear old sounds
                    if (this.aiState.capturedSounds.length > 50) {
                        this.aiState.capturedSounds.shift();
                    }
                    
                    setTimeout(think, 100);
                };
                
                think();
            }
            
            animate() {
                const spectrumCanvas = document.getElementById('spectrum-canvas');
                const waveformCanvas = document.getElementById('waveform-canvas');
                const particleCanvas = document.getElementById('particle-canvas');
                const freqCanvas = document.getElementById('freqCanvas');
                
                const spectrumCtx = spectrumCanvas.getContext('2d');
                const waveformCtx = waveformCanvas.getContext('2d');
                const particleCtx = particleCanvas.getContext('2d');
                const freqCtx = freqCanvas.getContext('2d');
                
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    // Clear canvases
                    spectrumCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    spectrumCtx.fillRect(0, 0, spectrumCanvas.width, spectrumCanvas.height);
                    
                    waveformCtx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                    waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);
                    
                    particleCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    particleCtx.fillRect(0, 0, particleCanvas.width, particleCanvas.height);
                    
                    // Get frequency data
                    this.analysis.analyzer.getByteFrequencyData(this.analysis.dataArray);
                    
                    // Draw frequency spectrum at top
                    freqCtx.fillStyle = 'rgba(0, 0, 0, 0.8)';
                    freqCtx.fillRect(0, 0, freqCanvas.width, freqCanvas.height);
                    
                    const barWidth = freqCanvas.width / this.analysis.dataArray.length * 2;
                    
                    for (let i = 0; i < this.analysis.dataArray.length; i++) {
                        const height = (this.analysis.dataArray[i] / 255) * freqCanvas.height;
                        
                        const hue = 280 - (i / this.analysis.dataArray.length) * 60;
                        freqCtx.fillStyle = `hsla(${hue}, 70%, 50%, 0.8)`;
                        freqCtx.fillRect(i * barWidth, freqCanvas.height - height, barWidth - 1, height);
                    }
                    
                    // Draw waveform
                    const timeData = new Uint8Array(this.analysis.analyzer.frequencyBinCount);
                    this.analysis.analyzer.getByteTimeDomainData(timeData);
                    
                    waveformCtx.strokeStyle = `rgba(138, 43, 226, ${0.3 + this.aiState.tension * 0.5})`;
                    waveformCtx.lineWidth = 2;
                    waveformCtx.beginPath();
                    
                    const sliceWidth = waveformCanvas.width / timeData.length;
                    let x = 0;
                    
                    for (let i = 0; i < timeData.length; i++) {
                        const v = timeData[i] / 128.0;
                        const y = v * waveformCanvas.height / 2;
                        
                        if (i === 0) {
                            waveformCtx.moveTo(x, y);
                        } else {
                            waveformCtx.lineTo(x, y);
                        }
                        
                        x += sliceWidth;
                    }
                    
                    waveformCtx.stroke();
                    
                    // Update particles based on spectrum
                    for (let i = 0; i < 5; i++) {
                        if (Math.random() < this.aiState.tension) {
                            this.visuals.particles.push({
                                x: Math.random() * particleCanvas.width,
                                y: particleCanvas.height,
                                vy: -2 - Math.random() * 5,
                                vx: (Math.random() - 0.5) * 2,
                                life: 1,
                                size: 2 + Math.random() * 5
                            });
                        }
                    }
                    
                    // Draw and update particles
                    for (let i = this.visuals.particles.length - 1; i >= 0; i--) {
                        const p = this.visuals.particles[i];
                        
                        p.x += p.vx;
                        p.y += p.vy;
                        p.life -= 0.01;
                        
                        if (p.life <= 0 || p.y < 0) {
                            this.visuals.particles.splice(i, 1);
                            continue;
                        }
                        
                        particleCtx.fillStyle = `rgba(138, 43, 226, ${p.life * 0.8})`;
                        particleCtx.beginPath();
                        particleCtx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                        particleCtx.fill();
                    }
                };
                
                draw();
            }
        }
        
        // Initialize the AI
        const gump = new GumpAI();
    </script>
</body>
</html>
