<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 240px;
            height: 240px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,20,20,0.1) 0%, transparent 70%);
            border: 3px solid rgba(255,20,20,0.4);
            color: #ff1414;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-size: 20px;
            font-weight: bold;
            letter-spacing: 1px;
            backdrop-filter: blur(15px);
            transition: all 0.3s ease;
            animation: samplePulse 2s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(255,20,20,0.8);
            background: radial-gradient(circle, rgba(255,20,20,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        @keyframes samplePulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 40px rgba(255,20,20,0.3);
            }
            50% {
                transform: scale(1.06);
                box-shadow: 0 0 80px rgba(255,20,20,0.6);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: radial-gradient(circle, #ff1414 0%, rgba(255,20,20,0.4) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 50px rgba(255,20,20,0.6);
            backdrop-filter: blur(8px);
            will-change: transform;
            z-index: 10;
        }

        .orb.pulse {
            animation: sampleBeat 0.15s ease-out;
        }

        @keyframes sampleBeat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.8); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.sampling {
            background: radial-gradient(circle, #ff6600 0%, rgba(255,102,0,0.5) 50%, transparent 80%);
            box-shadow: 0 0 70px rgba(255,102,0,0.8);
            animation: samplingActive 0.8s ease-in-out infinite;
        }

        .orb.chopping {
            background: radial-gradient(circle, #00ff88 0%, rgba(0,255,136,0.5) 50%, transparent 80%);
            box-shadow: 0 0 90px rgba(0,255,136,0.9);
            animation: choppingActive 0.4s ease-in-out infinite;
        }

        .orb.flipping {
            background: radial-gradient(circle, #8800ff 0%, rgba(136,0,255,0.5) 50%, transparent 80%);
            box-shadow: 0 0 120px rgba(136,0,255,1);
            animation: flippingActive 0.25s ease-in-out infinite;
        }

        .orb.dropping {
            background: radial-gradient(circle, #ffff00 0%, #ff0080 30%, #00ffff 60%, transparent 90%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 100px rgba(255,0,128,0.8));
            animation: droppingActive 0.15s ease-in-out infinite;
        }

        .orb.tribal {
            background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,107,53,0.7);
        }
        
        .orb.orchestral {
            background: radial-gradient(circle, #4a90e2 0%, rgba(74,144,226,0.4) 50%, transparent 80%);
            box-shadow: 0 0 80px rgba(74,144,226,0.7);
        }
        
        .orb.transcendent {
            background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
            box-shadow: 0 0 120px rgba(155,89,182,0.8);
            animation: transcend 3s ease-in-out infinite;
        }
        
        .orb.dimensional {
            background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, #ffff00 50%, #00ff00 75%, transparent 95%);
            box-shadow: 0 0 200px rgba(0,255,255,1);
            filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
        }
        
        .orb.void {
            background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(147,112,219,0.4);
            filter: drop-shadow(0 0 20px rgba(147,112,219,0.2));
            animation: voidBreathe 3s ease-in-out infinite;
        }

        @keyframes transcend {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.4); }
        }

        @keyframes voidBreathe {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.7; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        }

        @keyframes samplingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.3) rotate(180deg); }
        }

        @keyframes choppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.5); }
        }

        @keyframes flippingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
            50% { transform: translate(-50%, -50%) scale(1.7) rotate(360deg); }
        }

        @keyframes droppingActive {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            25% { transform: translate(-50%, -50%) scale(2.2); }
            50% { transform: translate(-50%, -50%) scale(1.6); }
            75% { transform: translate(-50%, -50%) scale(2.5); }
        }

        .hidden {
            display: none !important;
        }

        .waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 40px;
            background: rgba(0,0,0,0.5);
            position: relative;
            overflow: hidden;
            border-top: 1px solid rgba(255,20,20,0.2);
            z-index: 100;
        }

        .waveform-bar {
            position: absolute;
            bottom: 0;
            width: 3px;
            background: linear-gradient(to top, #ff1414, #ff6600, #ffff00);
            transition: height 0.08s ease;
            border-radius: 1px;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }

        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            background: rgba(255,20,20,0.6);
            animation: particleFloat 6s linear infinite;
        }

        @keyframes particleFloat {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-10vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }

        .impact-flash {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255,255,255,0.1);
            opacity: 0;
            pointer-events: none;
            z-index: 10;
        }

        .impact-flash.active {
            opacity: 1;
            transition: opacity 0.15s ease-out;
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">GUMP</div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
        
        <div id="waveform" class="waveform hidden"></div>

        <div id="impactFlash" class="impact-flash"></div>
    </div>

    <script>
        class GUMPEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.active = false;
                this.masterGain = null;

                // Microphone
                this.microphone = null;
                this.micAnalyser = null;
                this.micDataArray = null;

                // Recording
                this.isRecording = false;
                this.recordBuffer = [];
                this.recordingStartTime = 0;
                this.maxRecordTime = 3;
                this.sampleThreshold = 0.02;
                this.lastSampleTime = 0;
                this.samplingCooldown = 2000;

                // Sample library
                this.sampleLibrary = [];
                this.sampleLayers = {
                    kick: { samples: [], gain: null },
                    snare: { samples: [], gain: null },
                    hats: { samples: [], gain: null },
                    bass: { samples: [], gain: null },
                    lead: { samples: [], gain: null },
                    fx: { samples: [], gain: null }
                };

                // Motion & Orientation
                this.motion = 0;
                this.intensity = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.orientation = { alpha: 0, beta: 0, gamma: 0 };

                // Music
                this.bpm = 140;
                this.step = 0;
                this.stage = 'LISTENING';
                this.isPlaying = false;
                this.lastBeatTime = 0;

                // Built-in drums for testing
                this.builtInDrums = {
                    kick: null,
                    snare: null,
                    hat: null
                };

                // Audio enhancements from second code
                this.limiter = null;
                this.compressor = null;
                this.lowBoost = null;
                this.saturator = null;
                this.listener = null;
                this.convolver = null;
                this.delay = null;
                this.layerPanners = {};
                this.layerPositions = {};
                this.layerTargets = {};
                this.layerPanScales = {};
                this.panningLerp = 0.02;
                this.noiseSource = null;
                this.noiseFilter = null;
                this.noiseGain = null;
                this.voicePool = {};

                this.elements = {};
                this.init();
            }

            init() {
                const elementIds = [
                    'startScreen', 'startBtn', 'evolutionSpace', 'orb', 'waveform', 'impactFlash'
                ];
                
                elementIds.forEach(id => {
                    this.elements[id] = document.getElementById(id);
                });

                this.elements.startBtn.addEventListener('click', () => this.start());
                this.setupMotionTracking();
                this.setupOrientationDetection();
                this.createWaveformBars();
            }

            setupMotionTracking() {
                let lastMouse = { x: 0, y: 0, time: 0 };
                
                document.addEventListener('mousemove', (e) => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    if (lastMouse.time > 0) {
                        const dt = now - lastMouse.time;
                        const dx = newX - lastMouse.x;
                        const dy = newY - lastMouse.y;
                        const velocity = Math.sqrt(dx*dx + dy*dy) / Math.max(dt, 16) * 1000;
                        this.updateMotion(velocity * 0.01);
                    }
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    lastMouse = { x: newX, y: newY, time: now };
                });

                window.addEventListener('devicemotion', (e) => {
                    if (!this.active || !e.accelerationIncludingGravity) return;
                    
                    const acc = e.accelerationIncludingGravity;
                    const magnitude = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z);
                    this.updateMotion(magnitude * 0.1);
                });
            }

            setupOrientationDetection() {
                window.addEventListener('deviceorientation', e => {
                    if (!this.active) return;
                    if (e.alpha !== null) {
                        this.orientation.alpha = e.alpha;
                        this.orientation.beta = e.beta;
                        this.orientation.gamma = e.gamma;
                        this.updateListenerOrientation();
                    }
                });
            }

            updateListenerOrientation() {
                if (!this.listener) return;

                const alphaRad = this.orientation.alpha * Math.PI / 180;
                const betaRad = this.orientation.beta * Math.PI / 180;
                const gammaRad = this.orientation.gamma * Math.PI / 180;

                const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
                const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
                const forwardZ = Math.sin(betaRad);

                const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
                const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
                const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

                this.listener.forwardX.value = forwardX;
                this.listener.forwardY.value = forwardY;
                this.listener.forwardZ.value = forwardZ;
                this.listener.upX.value = upX;
                this.listener.upY.value = upY;
                this.listener.upZ.value = upZ;
            }

            updateMotion(newMotion) {
                this.motion = this.motion * 0.8 + newMotion * 0.2;
                
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 60) {
                    this.motionHistory.shift();
                }
                
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = avgMotion;
                
                if (avgMotion > 3) this.motionPattern = 'chaotic';
                else if (avgMotion > 1.5) this.motionPattern = 'active';
                else if (avgMotion > 0.5) this.motionPattern = 'rhythmic';
                else this.motionPattern = 'calm';
                
                this.updateStage();
                this.updateProceduralNoise(avgMotion, this.intensity);
            }

            updateStage() {
                const sampleCount = this.sampleLibrary.length;
                
                if (sampleCount === 0) {
                    this.stage = 'LISTENING';
                } else if (sampleCount < 3) {
                    this.stage = 'SAMPLING';
                } else if (sampleCount < 8) {
                    this.stage = 'CHOPPING';
                } else if (sampleCount < 15) {
                    this.stage = 'FLIPPING';
                } else {
                    this.stage = 'DROPPING';
                }
                
                this.updateOrbVisual();
            }

            updateOrbVisual() {
                const orb = this.elements.orb;
                let className = 'orb ' + this.stage.toLowerCase();
                if (this.motionPattern === 'chaotic') className += ' dimensional';
                else if (this.motionPattern === 'active') className += ' transcendent';
                else if (this.motionPattern === 'rhythmic') className += ' orchestral';
                else if (this.motionPattern === 'calm') className += ' tribal';
                orb.className = className;
                orb.style.left = this.pos.x + '%';
                orb.style.top = this.pos.y + '%';
            }

            createWaveformBars() {
                const waveform = this.elements.waveform;
                const barCount = 60;
                
                for (let i = 0; i < barCount; i++) {
                    const bar = document.createElement('div');
                    bar.className = 'waveform-bar';
                    bar.style.left = (i * (100 / barCount)) + '%';
                    bar.style.width = (100 / barCount * 0.8) + '%';
                    bar.style.height = '2px';
                    waveform.appendChild(bar);
                }
            }

            async start() {
                try {
                    // Request permissions
                    if (typeof DeviceMotionEvent.requestPermission === 'function') {
                        const motionPermission = await DeviceMotionEvent.requestPermission();
                        if (motionPermission !== 'granted') {
                            console.log('Motion permission not granted');
                        }
                    }

                    if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                        const orientationPermission = await DeviceOrientationEvent.requestPermission();
                        if (orientationPermission !== 'granted') {
                            console.log('Orientation permission not granted');
                        }
                    }

                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    this.setupAudioChain();
                    await this.createBuiltInDrums();
                    await this.setupMicrophone(stream);
                    this.setupProceduralNoise();

                    // Show interface
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    this.elements.waveform.classList.remove('hidden');

                    this.active = true;
                    this.motionHistory = new Array(60).fill(0.1);
                    
                    this.addInitialSamples();
                    
                    this.startVisualizationLoop();
                    this.startSequencer();
                    this.startAnimationLoop();

                    console.log('🎵 GUMP ENGINE STARTED');
                    
                } catch (error) {
                    console.error('Failed to start engine:', error);
                }
            }

            setupAudioChain() {
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;
                this.masterGain.connect(this.ctx.destination);

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -6;
                this.limiter.knee.value = 1;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -24;
                this.compressor.knee.value = 12;
                this.compressor.ratio.value = 4;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.25;

                this.lowBoost = this.ctx.createBiquadFilter();
                this.lowBoost.type = 'lowshelf';
                this.lowBoost.frequency.value = 120;
                this.lowBoost.gain.value = 6;

                this.saturator = this.ctx.createWaveShaper();
                this.saturator.curve = this.makeDistortionCurve(3);
                this.saturator.oversample = '4x';

                this.listener = this.ctx.listener;
                this.listener.positionX.value = 0;
                this.listener.positionY.value = 0;
                this.listener.positionZ.value = 0;

                this.convolver = this.ctx.createConvolver();
                this.convolver.buffer = this.createReverbBuffer(6);

                this.delay = this.ctx.createDelay(0.8);
                this.delay.delayTime.value = 0.375;
                const delayFeedback = this.ctx.createGain();
                delayFeedback.gain.value = 0.35;
                const delayMix = this.ctx.createGain();
                delayMix.gain.value = 0.25;

                this.delay.connect(delayFeedback);
                delayFeedback.connect(this.delay);
                this.delay.connect(delayMix);

                // Layer setup
                Object.keys(this.sampleLayers).forEach(layerName => {
                    const gain = this.ctx.createGain();
                    gain.gain.value = this.getLayerGain(layerName);
                    gain.connect(this.masterGain);
                    this.sampleLayers[layerName].gain = gain;

                    this.layerPanners[layerName] = this.ctx.createPanner();
                    this.layerPanners[layerName].panningModel = 'HRTF';
                    this.layerPanners[layerName].distanceModel = 'inverse';
                    this.layerPanners[layerName].refDistance = 1;
                    this.layerPanners[layerName].maxDistance = 10000;
                    this.layerPanners[layerName].rolloffFactor = 1;
                    this.layerPanners[layerName].coneInnerAngle = 360;
                    this.layerPanners[layerName].coneOuterAngle = 0;
                    this.layerPanners[layerName].coneOuterGain = 0;

                    this.layerPositions[layerName] = {x: 0, y: 0, z: 0};
                    this.layerTargets[layerName] = {x: 0, y: 0, z: 0};
                    this.layerPanScales[layerName] = 1.0;

                    gain.connect(this.layerPanners[layerName]);
                    this.layerPanners[layerName].connect(this.compressor);
                });

                this.compressor.connect(this.lowBoost);
                this.lowBoost.connect(this.saturator);
                this.saturator.connect(this.limiter);
                this.convolver.connect(this.limiter);
                delayMix.connect(this.limiter);
                this.limiter.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            }

            makeDistortionCurve(amount) {
                const k = amount;
                const n = 22050;
                const curve = new Float32Array(n);
                const deg = Math.PI / 180;
                for (let i = 0; i < n; i++) {
                  const x = (i * 2) / n - 1;
                  curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
                }
                return curve;
            }

            createReverbBuffer(time) {
                const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
                for (let c = 0; c < 2; c++) {
                  const data = buffer.getChannelData(c);
                  for (let i = 0; i < data.length; i++) {
                    const decay = Math.pow(1 - i / data.length, 3);
                    data[i] = (Math.random() * 2 - 1) * decay * 0.3;
                  }
                }
                return buffer;
            }

            getLayerGain(layerName) {
                const gains = {
                    kick: 1.0,
                    snare: 0.8,
                    hats: 0.6,
                    bass: 0.9,
                    lead: 0.7,
                    fx: 0.6
                };
                return gains[layerName] || 1.0;
            }

            async createBuiltInDrums() {
                this.builtInDrums.kick = await this.createKickBuffer();
                this.builtInDrums.snare = await this.createSnareBuffer();
                this.builtInDrums.hat = await this.createHatBuffer();
            }

            createKickBuffer() {
                const duration = 0.5;
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    const pitch = 60 * Math.exp(-35 * t);
                    data[i] = Math.sin(2 * Math.PI * pitch * t) * Math.exp(-4 * t);
                    if (t < 0.005) {
                        data[i] += (Math.random() * 2 - 1) * 0.5 * (1 - t / 0.005);
                    }
                }

                return buffer;
            }

            createSnareBuffer() {
                const duration = 0.2;
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    const tone = Math.sin(2 * Math.PI * 200 * t) * 0.5;
                    const noise = (Math.random() * 2 - 1) * 0.5;
                    data[i] = (tone + noise) * Math.exp(-5 * t);
                }

                return buffer;
            }

            createHatBuffer() {
                const duration = 0.05;
                const sampleRate = this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, duration * sampleRate, sampleRate);
                const data = buffer.getChannelData(0);

                for (let i = 0; i < data.length; i++) {
                    const t = i / sampleRate;
                    data[i] = (Math.random() * 2 - 1) * Math.exp(-100 * t);
                }

                return buffer;
            }

            setupProceduralNoise() {
                const bufferSize = 2 * this.ctx.sampleRate;
                const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < bufferSize; i++) {
                  data[i] = Math.random() * 2 - 1;
                }

                this.noiseSource = this.ctx.createBufferSource();
                this.noiseSource.buffer = buffer;
                this.noiseSource.loop = true;

                this.noiseFilter = this.ctx.createBiquadFilter();
                this.noiseFilter.type = 'bandpass';
                this.noiseFilter.frequency.value = 1000;
                this.noiseFilter.Q.value = 10;

                this.noiseGain = this.ctx.createGain();
                this.noiseGain.gain.value = 0.04;

                this.noiseSource.connect(this.noiseFilter);
                this.noiseFilter.connect(this.noiseGain);
                this.noiseGain.connect(this.masterGain);
                this.noiseSource.start();
            }

            updateProceduralNoise(avgMotion, variance) {
                this.noiseFilter.frequency.value = 300 + avgMotion * 100 + variance * 50;
                this.noiseFilter.Q.value = 5 + variance * 2;
                this.noiseGain.gain.value = 0.05 + (this.intensity * 0.1);
            }

            async setupMicrophone(stream) {
                this.microphone = this.ctx.createMediaStreamSource(stream);
                
                this.micAnalyser = this.ctx.createAnalyser();
                this.micAnalyser.fftSize = 2048;
                this.micAnalyser.smoothingTimeConstant = 0.3;
                this.micDataArray = new Uint8Array(this.micAnalyser.frequencyBinCount);
                
                this.recorder = this.ctx.createScriptProcessor(4096, 1, 1);
                
                this.microphone.connect(this.micAnalyser);
                
                this.recorder.onaudioprocess = (e) => {
                    if (this.isRecording) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        this.recordBuffer.push(...inputData);
                        
                        const duration = this.recordBuffer.length / this.ctx.sampleRate;
                        if (duration >= this.maxRecordTime) {
                            this.stopRecording();
                        }
                    }
                };
            }

            addInitialSamples() {
                const kickSample = {
                    id: 'kick_' + Date.now(),
                    buffer: this.builtInDrums.kick,
                    duration: this.builtInDrums.kick.duration,
                    analysis: { energy: 'high', brightness: 'dark', lowFreq: 0.8, midFreq: 0.2, highFreq: 0 }
                };
                
                const snareSample = {
                    id: 'snare_' + Date.now(),
                    buffer: this.builtInDrums.snare,
                    duration: this.builtInDrums.snare.duration,
                    analysis: { energy: 'medium', brightness: 'bright', lowFreq: 0.2, midFreq: 0.6, highFreq: 0.2 }
                };
                
                const hatSample = {
                    id: 'hat_' + Date.now(),
                    buffer: this.builtInDrums.hat,
                    duration: this.builtInDrums.hat.duration,
                    analysis: { energy: 'low', brightness: 'bright', lowFreq: 0, midFreq: 0.2, highFreq: 0.8 }
                };
                
                this.sampleLibrary.push(kickSample, snareSample, hatSample);
                this.sampleLayers.kick.samples.push(kickSample);
                this.sampleLayers.snare.samples.push(snareSample);
                this.sampleLayers.hats.samples.push(hatSample);
                
                this.updateStage();
            }

            startVisualizationLoop() {
                const loop = () => {
                    if (!this.active) return;

                    if (this.micAnalyser) {
                        this.micAnalyser.getByteFrequencyData(this.micDataArray);
                        this.updateVisualization();

                        const avgLevel = this.getAverageVolume();
                        const now = Date.now();
                        const canSample = now - this.lastSampleTime > this.samplingCooldown;
                        
                        if (avgLevel > this.sampleThreshold && canSample && !this.isRecording) {
                            this.startRecording();
                        }
                    }

                    requestAnimationFrame(loop);
                };
                loop();
            }

            getAverageVolume() {
                if (!this.micDataArray) return 0;
                let sum = 0;
                for (let i = 0; i < this.micDataArray.length; i++) {
                    sum += this.micDataArray[i];
                }
                return sum / this.micDataArray.length / 255;
            }

            updateVisualization() {
                const bars = this.elements.waveform.querySelectorAll('.waveform-bar');
                const dataStep = Math.floor(this.micDataArray.length / bars.length);
                
                bars.forEach((bar, i) => {
                    const dataIndex = i * dataStep;
                    const value = this.micDataArray[dataIndex] / 255;
                    const height = Math.max(2, value * 40);
                    bar.style.height = height + 'px';
                });
            }

            startRecording() {
                if (this.isRecording) return;
                
                this.isRecording = true;
                this.recordBuffer = [];
                this.recordingStartTime = Date.now();
                this.lastSampleTime = Date.now();
                
                this.microphone.connect(this.recorder);
                this.recorder.connect(this.ctx.destination);
                
                this.updateOrbVisual();
            }

            stopRecording() {
                if (!this.isRecording) return;
                
                this.isRecording = false;
                
                this.microphone.disconnect(this.recorder);
                this.recorder.disconnect();
                
                if (this.recordBuffer.length > 0) {
                    this.createSampleFromRecording();
                }
            }

            createSampleFromRecording() {
                const buffer = this.ctx.createBuffer(1, this.recordBuffer.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(this.recordBuffer);
                
                const sample = {
                    id: 'rec_' + Date.now(),
                    buffer: buffer,
                    duration: buffer.duration,
                    analysis: this.analyzeBuffer(buffer)
                };
                
                this.sampleLibrary.push(sample);
                this.categorizeSample(sample);
                this.updateStage();
            }

            analyzeBuffer(buffer) {
                const data = buffer.getChannelData(0);
                
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i];
                }
                const rms = Math.sqrt(sum / data.length);
                
                let zeroCrossings = 0;
                for (let i = 1; i < data.length; i++) {
                    if ((data[i] >= 0 && data[i-1] < 0) || (data[i] < 0 && data[i-1] >= 0)) {
                        zeroCrossings++;
                    }
                }
                const zcr = zeroCrossings / buffer.duration;
                
                const energy = rms > 0.1 ? 'high' : rms > 0.03 ? 'medium' : 'low';
                const brightness = zcr > 3000 ? 'bright' : 'dark';
                
                return {
                    rms,
                    zcr,
                    energy,
                    brightness,
                    lowFreq: brightness === 'dark' ? 0.7 : 0.3,
                    midFreq: 0.3,
                    highFreq: brightness === 'bright' ? 0.7 : 0.3
                };
            }

            categorizeSample(sample) {
                const { analysis } = sample;
                
                let category = 'fx';
                
                if (analysis.energy === 'high' && analysis.brightness === 'dark') {
                    category = 'kick';
                } else if (analysis.energy === 'medium' && analysis.zcr > 2000) {
                    category = 'snare';
                } else if (analysis.brightness === 'bright' && analysis.energy === 'low') {
                    category = 'hats';
                } else if (analysis.brightness === 'dark' && analysis.energy === 'medium') {
                    category = 'bass';
                } else if (analysis.zcr > 1000 && analysis.zcr < 3000) {
                    category = 'lead';
                }
                
                this.sampleLayers[category].samples.push(sample);
            }

            startSequencer() {
                if (this.isPlaying) return;
                this.isPlaying = true;

                const tick = () => {
                    if (!this.active || !this.isPlaying) return;

                    const now = this.ctx.currentTime;
                    const beatDuration = 60 / this.bpm / 4;
                    
                    if (now >= this.lastBeatTime + beatDuration) {
                        this.lastBeatTime = now;
                        this.playStep();
                        this.step = (this.step + 1) % 32;
                    }

                    requestAnimationFrame(tick);
                };

                this.lastBeatTime = this.ctx.currentTime;
                tick();
            }

            playStep() {
                if (this.step % 4 === 0) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }

                switch (this.stage) {
                    case 'SAMPLING':
                        this.playSamplingPattern();
                        break;
                    case 'CHOPPING':
                        this.playChoppingPattern();
                        break;
                    case 'FLIPPING':
                        this.playFlippingPattern();
                        break;
                    case 'DROPPING':
                        this.playDroppingPattern();
                        break;
                }
            }

            playSamplingPattern() {
                if (this.step % 8 === 0) {
                    this.playLayerSample('kick');
                }
            }

            playChoppingPattern() {
                if (this.step % 8 === 0) {
                    this.playLayerSample('kick');
                }
                if (this.step % 16 === 8) {
                    this.playLayerSample('snare');
                }
                if (this.step % 4 === 2 && Math.random() < 0.5) {
                    this.playLayerSample('hats');
                }
            }

            playFlippingPattern() {
                if (this.step % 8 === 0) {
                    this.playLayerSample('kick');
                }
                if (this.step % 8 === 4) {
                    this.playLayerSample('snare');
                }
                if (this.step % 2 === 0) {
                    this.playLayerSample('hats');
                }
                if (this.step % 16 === 0 && this.sampleLayers.bass.samples.length > 0) {
                    this.playLayerSample('bass');
                }
            }

            playDroppingPattern() {
                this.playFlippingPattern();
                
                if (Math.random() < this.intensity * 0.1) {
                    const layers = ['kick', 'snare', 'hats', 'lead', 'fx'];
                    const randomLayer = layers[Math.floor(Math.random() * layers.length)];
                    this.playLayerSample(randomLayer);
                }
            }

            playLayerSample(layerName) {
                const layer = this.sampleLayers[layerName];
                if (!layer || layer.samples.length === 0) return;

                const sample = layer.samples[Math.floor(Math.random() * layer.samples.length)];
                this.playSample(sample, layerName);
            }

            playSample(sample, layerName) {
                if (!sample || !sample.buffer) return;

                const source = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();

                source.buffer = sample.buffer;
                gain.gain.value = 0.8;

                if (this.intensity > 0.3 && Math.random() < this.intensity * 0.1) {
                    source.playbackRate.value = 0.9 + Math.random() * 0.2;
                }

                source.connect(gain);
                gain.connect(this.sampleLayers[layerName].gain);

                source.start();
            }

            createParticles(count, color) {
                const container = document.querySelector('.particles') || (() => {
                    const div = document.createElement('div');
                    div.className = 'particles';
                    document.body.appendChild(div);
                    return div;
                })();

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = this.pos.x + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = (Math.random() * 0.5) + 's';
                    particle.style.animationDuration = (3 + Math.random() * 3) + 's';
                    
                    container.appendChild(particle);
                    
                    setTimeout(() => particle.remove(), 6000);
                }
            }

            startAnimationLoop() {
                const loop = () => {
                    if (!this.active) return;

                    this.updateOrbVisual();
                    this.updateBackground();

                    requestAnimationFrame(loop);
                };
                loop();
            }

            updateBackground() {
                const intensity = Math.min(this.intensity / 3, 1);
                const sampleIntensity = Math.min(this.sampleLibrary.length / 20, 1);

                let background;
                switch (this.stage) {
                    case 'LISTENING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,20,20,${0.1 + intensity * 0.2}) 20%, #000000 60%)`;
                        break;
                    case 'SAMPLING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,102,0,${0.2 + intensity * 0.3}) 15%, rgba(255,20,20,${0.1 + sampleIntensity * 0.2}) 35%, #000000 70%)`;
                        break;
                    case 'CHOPPING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(0,255,136,${0.3 + intensity * 0.4}) 12%, rgba(255,102,0,${0.15 + sampleIntensity * 0.25}) 30%, #000000 60%)`;
                        break;
                    case 'FLIPPING':
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(136,0,255,${0.4 + intensity * 0.4}) 10%, rgba(0,255,136,${0.2 + sampleIntensity * 0.3}) 25%, #000000 50%)`;
                        break;
                    case 'DROPPING':
                        const hue = (Date.now() / 100) % 360;
                        background = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 80%, ${60 + intensity * 30}%) 8%, hsl(${(hue + 120) % 360}, 70%, ${40 + sampleIntensity * 30}%) 20%, hsl(${(hue + 240) % 360}, 60%, 20%) 40%, #000000 70%)`;
                        break;
                    default:
                        background = '#000000';
                }

                document.body.style.background = background;
            }

            flashImpact() {
                this.elements.impactFlash.classList.add('active');
                setTimeout(() => this.elements.impactFlash.classList.remove('active'), 150);
            }
        }

        // Initialize the engine
        const engine = new GUMPEngine();
    </script>
</body>
</html>
