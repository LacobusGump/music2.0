<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Dubstep Drop Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000000;
      color: #00ff00;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,255,0,0.1) 0%, transparent 70%);
      border: 2px solid rgba(0,255,0,0.3);
      color: #00ff00;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(0,255,0,0.6);
      background: radial-gradient(circle, rgba(0,255,0,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(0,255,0,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(0,255,0,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(0,255,0,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.intro {
      background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,0,255,0.7);
    }
    
    .orb.buildup {
      background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(0,255,255,0.7);
    }
    
    .orb.drop {
      background: radial-gradient(circle, #ffff00 0%, #ff0000 40%, #00ff00 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(255,255,0,0.8);
      animation: wobble 0.5s ease-in-out infinite;
    }
    
    .orb.breakdown {
      background: radial-gradient(circle, #ff00ff 0%, #00ff00 25%, #ffff00 50%, #ff0000 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(255,0,255,1);
      filter: drop-shadow(0 0 80px rgba(0,255,0,0.8));
    }
    
    .orb.filth {
      background: radial-gradient(circle, #ff0000 0%, rgba(255,0,0,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(255,0,0,0.4);
      filter: drop-shadow(0 0 20px rgba(255,0,0,0.2));
      animation: glitch 0.1s linear infinite;
    }
    
    @keyframes wobble {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes glitch {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1) skew(5deg); 
        opacity: 1; 
      }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(0,255,0,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(0,255,0,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(0,255,0,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #00ffff, #ff00ff);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(0,255,0,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(0,255,0,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(0,255,0,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(0,255,0,0.8), rgba(0,255,0,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,255,0,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
DROP
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO TRIGGER THE DROP</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">TECHNIQUE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">WOBBLE DEPTH</div>
      <div class="bar">
        <div class="bar-fill" id="shepardBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">140</span></div>
      <div class="metric">KEY: <span id="keyDisplay">F MIN</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class DubstepEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 140;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.lastMotionTime = Date.now();
        
        // Gesture Recognition
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        // Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.voidPhase = false;
        this.currentTechnique = 'waiting';
        this.transposition = 0;
        
        // Cinematic Themes (Adapted to Dubstep)
        this.currentTheme = 'intro';
        this.themes = {
          intro: { mood: 'teasing', colors: ['#000000', '#00ff00'], text: 'Bass Tease' },
          buildup: { mood: 'rising', colors: ['#ff00ff', '#000000'], text: 'Buildup Hype' },
          drop: { mood: 'heavy', colors: ['#00ffff', '#000000'], text: 'Massive Drop' },
          breakdown: { mood: 'chill', colors: ['#ffff00', '#000000'], text: 'Breakdown Vibes' },
          filth: { mood: 'grimy', colors: ['#ff0000', '#000000'], text: 'Filthy Wobbles' },
          chaos: { mood: 'chaotic', colors: ['#ff0000', '#000000'], text: 'Chaos Drop' },
          massive: { mood: 'epic', colors: ['#00ff00', '#ff00ff'], text: 'Ultimate Bass' },
          void: { mood: 'silent', colors: ['#000000', '#0a0a0a'], text: 'Silent Void' },
          glitch: { mood: 'glitchy', colors: ['#00ff00', '#000000'], text: 'Glitch Pulse' }
        };
        
        // Song Profiles (Dubstep album-like structure)
        this.songs = [
          {
            name: 'GUMP Bass Assault',
            influences: 'Skrillex blended with Excision; heavy wobble bass with aggressive drops, syncopated rhythms, and glitchy effects inspired by Bangarang and X Up',
            key: 'F',
            mode: 'minor',
            bpmBase: 140,
            chordProgression: [[0,3,7], [7,10,14], [3,7,10], [10,14,17]],
            ostinatoPattern: [0,3,7,3,0,3,7,3],
            phraseStructure: ['A', 'A', 'B', 'B', 'C', 'C'],
            defaultTheme: 'drop',
            layerBiases: {
              kick: 1.2,
              bass: 1.5,
              hihat: 1.0,
              snare: 1.1,
              wobble: 1.4,
              sub: 1.3,
              growl: 1.2,
              laser: 0.9,
              vocal: 0.8,
              riser: 1.1,
              impact: 1.2,
              glitch: 1.0,
              atmosphere: 0.7,
              pad: 0.6,
              breath: 0.5,
              whisper: 0.4
            }
          },
          {
            name: 'GUMP Wobble Warfare',
            influences: 'Zomboy blended with Knife Party; filthy wobbles with heavy drops, half-time rhythms, and aggressive synths inspired by Rapture and Bonfire',
            key: 'D',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [3,7,10], [5,8,12], [7,10,14]],
            ostinatoPattern: [0,1,7,1,0,1,7,1],
            phraseStructure: ['A', 'B', 'A', 'C', 'D'],
            defaultTheme: 'filth',
            layerBiases: {
              kick: 1.1,
              bass: 1.4,
              hihat: 0.9,
              snare: 1.0,
              wobble: 1.5,
              sub: 1.2,
              growl: 1.3,
              laser: 1.0,
              vocal: 0.9,
              riser: 1.0,
              impact: 1.1,
              glitch: 1.2,
              atmosphere: 0.6,
              pad: 0.5,
              breath: 0.4,
              whisper: 0.3
            }
          },
          // Add more dubstep-inspired songs similarly...
          {
            name: 'GUMP Glitch Drop',
            influences: 'Flux Pavilion blended with Doctor P; melodic wobbles with massive drops, glitch hops, and bass lines inspired by Bass Cannon and Sweet Shop',
            key: 'G',
            mode: 'minor',
            bpmBase: 140,
            chordProgression: [[0,3,7], [5,8,12], [10,14,17], [3,7,10]],
            ostinatoPattern: [0,3,10,3,0,3,10,3],
            phraseStructure: ['A', 'B', 'C', 'D', 'E'],
            defaultTheme: 'glitch',
            layerBiases: {
              kick: 1.0,
              bass: 1.3,
              hihat: 0.8,
              snare: 0.9,
              wobble: 1.4,
              sub: 1.1,
              growl: 1.0,
              laser: 1.1,
              vocal: 1.0,
              riser: 0.9,
              impact: 1.0,
              glitch: 1.3,
              atmosphere: 0.5,
              pad: 0.4,
              breath: 0.3,
              whisper: 0.2
            }
          },
          // Continue adding up to 7 songs as in original
          {
            name: 'GUMP Heavy Filth',
            influences: 'Datsik blended with Must Die!; dark heavy bass with aggressive drops, distorted wobbles, and intense rhythms inspired by Firepower and Death & Magic',
            key: 'C',
            mode: 'phrygian',
            bpmBase: 140,
            chordProgression: [[0,1,7], [3,7,10], [5,8,12], [7,10,14]],
            ostinatoPattern: [0,1,7,1,0,1,7,1],
            phraseStructure: ['A', 'A', 'B', 'C', 'B', 'D'],
            defaultTheme: 'filth',
            layerBiases: {
              kick: 1.3,
              bass: 1.6,
              hihat: 1.1,
              snare: 1.2,
              wobble: 1.5,
              sub: 1.4,
              growl: 1.3,
              laser: 1.0,
              vocal: 0.7,
              riser: 1.2,
              impact: 1.3,
              glitch: 1.1,
              atmosphere: 0.8,
              pad: 0.7,
              breath: 0.6,
              whisper: 0.5
            }
          },
          {
            name: 'GUMP Melodic Wobble',
            influences: 'Seven Lions blended with Illenium; melodic dubstep with emotional drops, wobbly bass, and atmospheric builds inspired by Worlds Apart and Ascend',
            key: 'A',
            mode: 'minor',
            bpmBase: 140,
            chordProgression: [[0,3,7], [5,8,12], [10,14,17], [3,7,10]],
            ostinatoPattern: [0,3,10,3,0,3,10,3],
            phraseStructure: ['A', 'B', 'C', 'D', 'E'],
            defaultTheme: 'breakdown',
            layerBiases: {
              kick: 1.0,
              bass: 1.2,
              hihat: 0.8,
              snare: 0.9,
              wobble: 1.3,
              sub: 1.0,
              growl: 0.9,
              laser: 0.8,
              vocal: 1.2,
              riser: 1.0,
              impact: 0.9,
              glitch: 0.8,
              atmosphere: 1.0,
              pad: 1.1,
              breath: 1.0,
              whisper: 0.9
            }
          },
          {
            name: 'GUMP Riddim Rage',
            influences: 'Subtronics blended with SVDDEN DEATH; riddim dubstep with heavy riddim bass, aggressive drops, and glitchy elements inspired by Cyclops and VOYD',
            key: 'E',
            mode: 'minor',
            bpmBase: 150,
            chordProgression: [[0,3,7], [7,10,14], [3,7,10], [10,14,17]],
            ostinatoPattern: [0,7,12,7,0,7,12,7],
            phraseStructure: ['A', 'B', 'A', 'C', 'D', 'E'],
            defaultTheme: 'chaos',
            layerBiases: {
              kick: 1.4,
              bass: 1.7,
              hihat: 1.2,
              snare: 1.3,
              wobble: 1.6,
              sub: 1.5,
              growl: 1.4,
              laser: 1.1,
              vocal: 0.6,
              riser: 1.3,
              impact: 1.4,
              glitch: 1.5,
              atmosphere: 0.4,
              pad: 0.3,
              breath: 0.2,
              whisper: 0.1
            }
          },
          {
            name: 'GUMP Future Bass Drop',
            influences: 'Virtual Riot blended with Au5; future bass dubstep with complex wobbles, melodic drops, and glitchy synths inspired by Preset Junkies and The Journey',
            key: 'B',
            mode: 'major',
            bpmBase: 145,
            chordProgression: [[0,4,7], [5,9,12], [7,11,14], [2,5,9]],
            ostinatoPattern: [0,4,11,4,0,4,11,4],
            phraseStructure: ['A', 'B', 'C', 'B', 'D', 'D'],
            defaultTheme: 'massive',
            layerBiases: {
              kick: 1.1,
              bass: 1.4,
              hihat: 1.0,
              snare: 1.1,
              wobble: 1.5,
              sub: 1.2,
              growl: 1.1,
              laser: 1.2,
              vocal: 1.0,
              riser: 1.1,
              impact: 1.0,
              glitch: 1.2,
              atmosphere: 0.7,
              pad: 0.8,
              breath: 0.7,
              whisper: 0.6
            }
          }
        ];
        this.currentSongIndex = 0;
        this.songStartTime = 0;
        
        // AUDIO SYSTEM - Enhanced for dubstep heaviness
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.basePositions = {};
        this.layerPositions = {};
        this.layerTargets = {};
        this.layerPanScales = {
          kick: 0.1, bass: 0.2, hihat: 0.8, snare: 0.3,
          wobble: 1.2, sub: 1.5, growl: 2.0, laser: 3.0,
          vocal: 1.8, riser: 1.0, impact: 2.5, glitch: 3.5,
          atmosphere: 2.5, pad: 2.0, breath: 2.5, whisper: 0.5
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.lowBoost = null;
        this.saturator = null;
        this.wobbleIntensity = null;
        
        // DUBSTEP BEAT SYSTEM
        this.drumPattern = {
          kick: [],
          snare: [],
          hihat: [],
          ghost: []
        };
        this.currentDrumPattern = 0;
        this.drumSwing = 0.15;
        this.drumHumanize = 0.03;
        this.drumDynamics = {
          kick: { min: 0.8, max: 1.2 },
          snare: { min: 0.6, max: 1.0 },
          hihat: { min: 0.3, max: 0.7 },
          ghost: { min: 0.2, max: 0.4 }
        };
        
        // Dubstep drum patterns
        this.dubstepPatterns = [
          { // Pattern 0: Basic dubstep
            kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0],
            ghost: [0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]
          },
          { // Pattern 1: Half-time heavy
            kick:  [1,0,0,0, 0,0,1,0, 0,0,0,0, 0,0,0,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,1,1,0, 1,1,1,0, 1,1,1,0, 1,1,1,0],
            ghost: [0,0,0,0.3, 0,0,0,0.3, 0,0,0,0.3, 0,0,0,0.3]
          },
          { // Pattern 2: Riddim style
            kick:  [1,0,0.5,0, 0,0,0,0, 1,0,0.5,0, 0,0,0,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,0,1,0],
            ghost: [0,0.2,0,0, 0,0.2,0,0, 0,0.2,0,0, 0,0.2,0,0]
          },
          { // Pattern 3: Aggressive drop
            kick:  [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
            snare: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
            hihat: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],
            ghost: [0,0,0,0.4, 0,0,0,0.4, 0,0,0,0.4, 0,0,0,0.4]
          },
          { // Pattern 4: Glitchy riddim
            kick:  [1,0,0,0.6, 0,0.5,0,0, 1,0,0,0.6, 0,0.5,0,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,0,1,0, 0,1,0,1, 1,0,1,0, 0,1,0,1],
            ghost: [0,0.3,0,0, 0,0,0.3,0, 0,0.3,0,0, 0,0,0.3,0]
          },
          { // Pattern 5: Melodic half-time
            kick:  [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,1,0,1, 1,0,1,1, 1,1,0,1, 1,0,1,1],
            ghost: [0,0,0.2,0, 0,0.2,0,0, 0,0,0.2,0, 0,0.2,0,0]
          },
          { // Pattern 6: Future bass influenced
            kick:  [1,0,0,0, 0,0,0.5,0, 1,0,0,0, 0,0,0.5,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,0,1,1, 0,1,1,0, 1,0,1,1, 0,1,1,0],
            ghost: [0,0.1,0,0.1, 0,0.1,0,0.1, 0,0.1,0,0.1, 0,0.1,0,0.1]
          },
          { // Pattern 7: Heavy riddim
            kick:  [1,0,0.7,0, 0,0,0,0, 1,0,0.7,0, 0,0,0,0],
            snare: [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
            hihat: [1,1,1,0, 1,1,1,0, 1,1,1,0, 1,1,1,0],
            ghost: [0,0,0,0.5, 0,0,0,0.5, 0,0,0,0.5, 0,0,0,0.5]
          }
        ];
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Techniques
        this.wobbleTones = []; 
        this.ostinatoPattern = [0,7,12,15,12,7,12,15];
        this.ostinatoIndex = 0;
        this.wobbleIntensity = 0;
        this.tensionBuildup = 0;
        this.glitchProbability = 0;
        
        // Voice Pool - Adjusted for dubstep layers
        this.voicePool = {
          kick: { max: 3, active: [] },
          bass: { max: 4, active: [] },
          hihat: { max: 6, active: [] },
          snare: { max: 3, active: [] },
          wobble: { max: 8, active: [] },
          sub: { max: 4, active: [] },
          growl: { max: 6, active: [] },
          laser: { max: 6, active: [] },
          vocal: { max: 8, active: [] },
          riser: { max: 2, active: [] },
          impact: { max: 2, active: [] },
          glitch: { max: 4, active: [] },
          atmosphere: { max: 6, active: [] },
          pad: { max: 10, active: [] },
          breath: { max: 2, active: [] },
          whisper: { max: 4, active: [] }
        };
        
        // Layers
        this.layers = {
          kick: false, bass: false, hihat: false, snare: false,
          wobble: false, sub: false, growl: false, laser: false,
          vocal: false, riser: false, impact: false, glitch: false,
          atmosphere: false, pad: false, breath: false, whisper: false
        };
        
        // Musical Elements
        this.key = 'F';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
        this.mode = 'minor';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          pentatonic: [0, 2, 4, 7, 9],
          blues: [0, 3, 5, 6, 7, 10],
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          wholeTone: [0, 2, 4, 6, 8, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [0,3,7],  // i Fm
          [8,12,15], // VI Db
          [3,7,10],  // iii Ab
          [10,14,17] // VII Eb
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 174.61; // F2 for dubstep bass
        
        this.elements = {};
        this.spectrumBars = [];
        
        // Procedural Noise for Glitch Effects
        this.noiseSource = null;
        this.noiseFilter = null;
        this.noiseGain = null;

        // Easter Eggs
        this.easterEggs = {
          konamiSequence: [],
          goldenRatio: false,
          perfectCircle: false,
          chaosAttractor: false,
          fibonacciSpiral: false,
          wobbleInfinity: false,
          harmonicWave: false
        };
        
        this.specialEvents = {
          glitchStorm: 0,
          timeDilation: 0,
          dimensionalRift: 0,
          harmonicResonance: 0
        };

        // Environment
        this.weather = null;
        this.dayOfWeek = new Date().getDay();
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'shepardBar', 'bpmDisplay',
         'keyDisplay', 'voiceCount', 'cinematicOverlay', 'themeText', 'spectrumViz', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 1.5625}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupInteractionListeners() {
        let touchSequence = [];
        
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.clientX, y: e.clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        setInterval(() => {
          const now = Date.now();
          touchSequence = touchSequence.filter(touch => now - touch.time < 5000);
        }, 2000);

        // Konami Code listener
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;
        
        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              this.triggerKonamiEasterEgg();
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
      }

      analyzeGesture(sequence) {
        if (sequence.length < 3) return;
        
        const recent = sequence.slice(-10);
        const distances = [];
        const angles = [];
        
        for (let i = 1; i < recent.length; i++) {
          const dx = recent[i].x - recent[i-1].x;
          const dy = recent[i].y - recent[i-1].y;
          distances.push(Math.sqrt(dx*dx + dy*dy));
          angles.push(Math.atan2(dy, dx));
        }
        
        // Spiral detection for wobble trigger
        let angleSum = 0;
        for (let i = 1; i < angles.length; i++) {
          let diff = angles[i] - angles[i-1];
          if (diff > Math.PI) diff -= 2 * Math.PI;
          if (diff < -Math.PI) diff += 2 * Math.PI;
          angleSum += diff;
        }
        
        if (Math.abs(angleSum) > Math.PI * 2) {
          this.gestureRecognition.spiral += 0.3;
          if (this.gestureRecognition.spiral > 1 && !this.easterEggs.fibonacciSpiral) {
            this.triggerFibonacciSpiral();
          }
        }
        
        // Decay gestures
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.01);
        });
      }

      triggerKonamiEasterEgg() {
        console.log('🎮 KONAMI CODE ACTIVATED: Infinite Wobble Engaged');
        this.specialEvents.dimensionalRift = 2;
        this.bpm *= 1.1;
        this.layers.glitch = true;
        this.currentTheme = 'chaos';
        this.evolveToMassive();
        this.flashImpact();
      }

      triggerFibonacciSpiral() {
        console.log('🌀 FIBONACCI SPIRAL DETECTED: Golden Wobble Harmony');
        this.easterEggs.fibonacciSpiral = true;
        this.layers.wobble = true;
        this.wobbleIntensity = 1;
        this.playGoldenRatioChord();
      }

      flashImpact() {
        this.elements.impactFlash.classList.add('active');
        setTimeout(() => this.elements.impactFlash.classList.remove('active'), 150);
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          if (e.alpha !== null) {
            this.orientation.alpha = e.alpha;
            this.orientation.beta = e.beta;
            this.orientation.gamma = e.gamma;
            this.updateListenerOrientation();
          }
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        this.listener.forwardX.value = forwardX;
        this.listener.forwardY.value = forwardY;
        this.listener.forwardZ.value = forwardZ;
        this.listener.upX.value = upX;
        this.listener.upY.value = upY;
        this.listener.upZ.value = upZ;
      }

      async start() {
        try {
          let motionGranted = true;
          let orientationGranted = true;

          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              motionGranted = false;
              console.log('Motion permission not granted, falling back to mouse/keyboard input');
            }
          }

          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              orientationGranted = false;
              console.log('Orientation permission not granted, some spatial features limited');
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setLayerPositions();
          this.initializeDubstepBeats();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'BE STILL OR MOVE TO BUILD THE DROP';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.setSong(0);
          this.songStartTime = Date.now();
          this.startSequencer();
          this.animate();
          
          // Get environment data
          this.fetchEnvironmentData();

          if (!motionGranted) {
            // Fallback to simulated motion if no permissions
            this.simulateMotion();
          }
          
        } catch (e) {
          console.error('Failed to start engine:', e);
          alert('Failed to initialize. Please check permissions and try again. Error: ' + e.message);
        }
      }

      simulateMotion() {
        // Simple sine wave motion simulation for fallback
        let time = 0;
        const simulate = () => {
          if (!this.active || this.motion > 0) return;
          time += 0.05;
          const simulatedMotion = Math.sin(time) * 2 + 2;
          this.updateMotion(simulatedMotion);
          requestAnimationFrame(simulate);
        };
        simulate();
      }

      setSong(index) {
        const song = this.songs[index % this.songs.length];
        const fadeTime = 2;

        if (this.masterGain) this.masterGain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + fadeTime);

        setTimeout(() => {
          this.key = song.key;
          this.mode = song.mode;
          this.scale = this.scales[this.mode];
          this.bpm = song.bpmBase;
          this.chordProgression = song.chordProgression;
          this.ostinatoPattern = song.ostinatoPattern;
          this.phraseStructure = song.phraseStructure;
          this.currentTheme = song.defaultTheme;
          this.currentSongIndex = index;

          // Reset states
          this.phraseCount = 0;
          this.phrase = this.phraseStructure[0];
          this.ostinatoIndex = 0;
          this.currentChordIndex = 0;
          this.transposition = 0;
          this.wobbleIntensity = 0;
          this.tensionBuildup = 0;

          // Clear active voices
          Object.keys(this.voicePool).forEach(layer => {
            this.voicePool[layer].active.forEach(voice => {
              if (voice.source) voice.source.stop();
            });
            this.voicePool[layer].active = [];
          });

          // Update UI theme text
          this.elements.themeText.textContent = song.name;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 4000);

          console.log(`Transitioned to song: ${song.name} (Influences: ${song.influences})`);

          if (this.masterGain) this.masterGain.gain.linearRampToValueAtTime(0.65, this.ctx.currentTime + fadeTime);

          this.songStartTime = Date.now();
        }, fadeTime * 1000);
      }

      fetchEnvironmentData() {
        if (!navigator.geolocation) {
          console.error('Geolocation not supported');
          this.weather = { temperature: 20, weathercode: 0, windspeed: 5 };
          this.updateFromEnvironment();
          return;
        }
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            fetch(`https://api.open-meteo.com/v1/forecast?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&current_weather=true`)
              .then(res => res.json())
              .then(data => {
                this.weather = data.current_weather;
                this.updateFromEnvironment();
              })
              .catch(err => {
                console.error('Weather fetch error:', err);
                this.weather = { temperature: 20, weathercode: 0, windspeed: 5 };
                this.updateFromEnvironment();
              });
          },
          (err) => {
            console.error('Geolocation error:', err);
            this.weather = { temperature: 20, weathercode: 0, windspeed: 5 };
            this.updateFromEnvironment();
          },
          { enableHighAccuracy: true }
        );
      }

      updateFromEnvironment() {
        if (this.weather) {
          const temp = this.weather.temperature;
          const weatherCode = this.weather.weathercode;

          // Influence BPM based on temperature
          this.bpm += (temp - 15) * 0.5;
          this.bpm = Math.max(100, Math.min(180, this.bpm));

          // Weather code influence
          if (weatherCode >= 61 && weatherCode <= 67) { // Rain
            this.layers.atmosphere = true;
            this.convolver.buffer = this.createReverbBuffer(4);
            this.currentTheme = 'filth';
          } else if (weatherCode <= 3) { // Clear
            this.currentTheme = 'buildup';
            this.layers.pad = true;
          } else if (weatherCode >= 71 && weatherCode <= 77) { // Snow
            this.layers.vocal = true;
            this.currentTheme = 'breakdown';
          }

          // Adjust intensity based on wind
          this.intensity += this.weather.windspeed / 20;
        }

        // Day of week influence
        const modes = ['minor', 'phrygian', 'minor', 'phrygian', 'minor', 'major', 'minor'];
        this.mode = modes[this.dayOfWeek];
        this.scale = this.scales[this.mode];

        const keys = ['F', 'D', 'G', 'C', 'A', 'E', 'B'];
        this.key = keys[this.dayOfWeek];

        this.elements.keyDisplay.textContent = `${this.key} ${this.mode.toUpperCase()}`;
      }

      createReverbBuffer(time) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 3);
            data[i] = (Math.random() * 2 - 1) * decay * 0.3;
          }
        }
        return buffer;
      }

      makeDistortionCurve(amount) {
        const k = amount;
        const n = 22050;
        const curve = new Float32Array(n);
        const deg = Math.PI / 180;
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 128;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -3;
        this.limiter.knee.value = 1;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.001;
        this.limiter.release.value = 0.01;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.65;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 12;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        
        this.lowBoost = this.ctx.createBiquadFilter();
        this.lowBoost.type = 'lowshelf';
        this.lowBoost.frequency.value = 60;
        this.lowBoost.gain.value = 12; // Heavier low end for dubstep
        
        this.saturator = this.ctx.createWaveShaper();
        this.saturator.curve = this.makeDistortionCurve(8); // More distortion for filth
        this.saturator.oversample = '4x';
        
        this.listener = this.ctx.listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(4); // Shorter reverb for dubstep
        
        this.delay = this.ctx.createDelay(0.8);
        this.delay.delayTime.value = 0.375;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.35;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.25;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // Layer setup with DUBSTEP LEVELS
        const layerNames = ['kick', 'bass', 'hihat', 'snare', 'wobble', 'sub', 'growl', 
                           'laser', 'vocal', 'riser', 'impact', 'glitch', 'atmosphere', 'pad', 'breath', 'whisper'];
        const layerLevels = [1.8, 1.5, 0.3, 0.5, 0.8, 1.2, 0.7, 
                            0.6, 0.4, 0.5, 0.8, 0.6, 0.15, 0.12, 0.1, 0.1];
        
        layerNames.forEach((name, i) => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];

          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';
          this.layerPanners[name].distanceModel = 'inverse';
          this.layerPanners[name].refDistance = 1;
          this.layerPanners[name].maxDistance = 10000;
          this.layerPanners[name].rolloffFactor = 1.0;
          this.layerPanners[name].coneInnerAngle = 360;
          this.layerPanners[name].coneOuterAngle = 0;
          this.layerPanners[name].coneOuterGain = 0;

          this.layerPositions[name] = {x: 0, y: 0, z: 0};
          this.basePositions[name] = {x: 0, y: 0, z: 0};
          this.layerTargets[name] = {x: 0, y: 0, z: 0};

          this.layerPanners[name].connect(this.compressor);

          // Selective reverb sends
          if (['vocal', 'pad', 'atmosphere', 'laser', 'growl', 'whisper'].includes(name)) {
            this.layerGains[name].connect(this.convolver);
          }
          
          // Selective delay sends
          if (['wobble', 'snare', 'laser', 'vocal', 'hihat'].includes(name)) {
            this.layerGains[name].connect(this.delay);
          }
        });
        
        this.wobbleIntensity = this.ctx.createGain();
        this.wobbleIntensity.gain.value = 0.15;
        
        // Audio chain connections
        this.compressor.connect(this.lowBoost);
        this.lowBoost.connect(this.saturator);
        this.saturator.connect(this.limiter);
        this.convolver.connect(this.limiter);
        delayMix.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.setupProceduralNoise();
      }

      initializeDubstepBeats() {
        // Set up the initial drum pattern
        this.drumPattern = this.dubstepPatterns[0];
        this.currentDrumPattern = 0;
      }

      setupProceduralNoise() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        this.noiseSource = this.ctx.createBufferSource();
        this.noiseSource.buffer = buffer;
        this.noiseSource.loop = true;

        this.noiseFilter = this.ctx.createBiquadFilter();
        this.noiseFilter.type = 'bandpass';
        this.noiseFilter.frequency.value = 1000;
        this.noiseFilter.Q.value = 10;

        this.noiseGain = this.ctx.createGain();
        this.noiseGain.gain.value = 0.04;

        this.noiseSource.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseGain);
        this.noiseGain.connect(this.layerPanners.glitch);
        this.noiseSource.start();
      }

      updateProceduralNoise(avgMotion, variance) {
        this.noiseFilter.frequency.value = 500 + avgMotion * 200 + variance * 100;
        this.noiseFilter.Q.value = 8 + variance * 4;
        this.noiseGain.gain.value = 0.08 + (this.wobbleIntensity * 0.15);
      }

      setLayerPositions() {
        const positions = {
          kick: {x: 0, y: 0, z: -2},
          bass: {x: 0, y: -1, z: -3},
          hihat: {x: -2, y: 1, z: -1},
          snare: {x: 2, y: 0, z: -1},
          wobble: {x: -2, y: 0, z: -5},
          sub: {x: 2, y: 0, z: -5},
          growl: {x: 0, y: 2, z: 5},
          laser: {x: 0, y: 3, z: 10},
          vocal: {x: -5, y: 0, z: -6},
          riser: {x: 5, y: 0, z: -6},
          impact: {x: 0, y: 2, z: 8},
          glitch: {x: 0, y: 4, z: -10},
          atmosphere: {x: 0, y: 5, z: 15},
          pad: {x: -8, y: 2, z: -10},
          breath: {x: 0, y: 0, z: 0},
          whisper: {x: 3, y: 1, z: -2}
        };

        Object.keys(positions).forEach(name => {
          const pos = positions[name];
          this.basePositions[name] = {...pos};
          this.layerPositions[name] = {...pos};
          this.layerTargets[name] = {...pos};
          if (this.layerPanners[name]) {
            this.layerPanners[name].positionX.value = pos.x;
            this.layerPanners[name].positionY.value = pos.y;
            this.layerPanners[name].positionZ.value = pos.z;
          }
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.015;
          this.velocity.y += acc.y * 0.015;
          this.updatePosition();
          
          this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
          
          if (newMotion > 4 && Date.now() - this.lastStepTime > 250) {
            this.stepCounter++;
            this.lastStepTime = Date.now();
            this.syncBPMToSteps();
          }
          
          if (newMotion > 4) {
            this.gestureRecognition.shake += 0.3;
            if (this.gestureRecognition.shake > 2) {
              this.triggerShakeEffects();
            }
          }
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 100;
          const velocityY = (newY - lastMouse.y) / dt * 100;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.3;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          this.orientation.alpha = (newX / 100) * 360;
          this.orientation.beta = (newY - 50) * 1.8;
          this.orientation.gamma = 0;
          this.updateListenerOrientation();
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.8 + newMotion * 0.2;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 150) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        // Track last motion for void state
        if (this.motion > 0.3) {
          this.lastMotionTime = Date.now();
          if (this.voidPhase) {
            this.exitVoidState();
          }
        }
        
        if (Date.now() - this.lastMotionTime > 5000 && !this.voidPhase) {
          this.enterVoidState();
        }
        
        if (!this.firstMovement && this.motion > 1.5) {
          this.firstMovement = true;
          this.evolveToIntro();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        const variance = this.intensity;
        const recentHistory = this.motionHistory.slice(-40);
        const isRhythmic = recentHistory.filter(m => m > 2.5).length > 20 && variance < 2;
        const isErratic = variance > 2.5 && avgMotion > 2;
        const isSustained = avgMotion > 2.5 && variance < 1.5;
        const isChaotic = variance > 4 && avgMotion > 4;
        this.motionPattern = isChaotic ? 'chaotic' : isErratic ? 'erratic' : isRhythmic ? 'rhythmic' : isSustained ? 'sustained' : 'calm';
        
        // Update drum pattern based on motion
        this.updateDrumPattern(avgMotion, variance);
        
        this.updateTechniques(avgMotion, variance);
        this.updateEvolution();
        
        // Update procedural noise
        this.updateProceduralNoise(avgMotion, variance);
      }

      updateDrumPattern(avgMotion, variance) {
        // Select drum pattern based on motion characteristics
        if (this.voidPhase) {
          // No drums in void
          return;
        }
        
        let targetPattern = 0;
        
        if (this.motionPattern === 'chaotic' && variance > 4) {
          targetPattern = 6; // Future bass influenced
        } else if (this.motionPattern === 'rhythmic' && avgMotion > 3) {
          targetPattern = 5; // Melodic half-time
        } else if (this.motionPattern === 'erratic') {
          targetPattern = 4; // Glitchy riddim
        } else if (this.buildPhase && avgMotion > 2.5) {
          targetPattern = 3; // Aggressive drop
        } else if (avgMotion > 2) {
          targetPattern = 2; // Riddim style
        } else if (this.stage === 'MASSIVE') {
          targetPattern = 7; // Heavy riddim
        } else if (this.intensity > 2) {
          targetPattern = 1; // Half-time heavy
        }
        
        // Smooth pattern transition
        if (targetPattern !== this.currentDrumPattern) {
          this.currentDrumPattern = targetPattern;
          this.drumPattern = this.dubstepPatterns[targetPattern];
          console.log(`Switched to drum pattern ${targetPattern}: ${['Basic dubstep', 'Half-time heavy', 'Riddim style', 'Aggressive drop', 'Glitchy riddim', 'Melodic half-time', 'Future bass influenced', 'Heavy riddim'][targetPattern]}`);
        }
      }

      enterVoidState() {
        console.log('🌌 ENTERING VOID STATE: Silent Breakdown');
        this.voidPhase = true;
        this.stage = 'VOID';
        this.elements.orb.className = 'orb filth';
        this.currentTheme = 'void';
        
        // Fade out all active layers except pad
        Object.keys(this.layerGains).forEach(layer => {
          if (layer !== 'pad') {
            this.layerGains[layer].gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
          }
        });
        Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
        
        // Play void ambience
        this.playVoidAmbience();
        
        // Show theme text
        this.elements.themeText.textContent = this.themes.void.text;
        this.elements.themeText.classList.add('visible');
        setTimeout(() => this.elements.themeText.classList.remove('visible'), 5000);

        // Show instruction to move
        this.elements.instruction.textContent = 'MOVE TO TRIGGER THE DROP';
        this.elements.instruction.classList.add('show');
        setTimeout(() => this.elements.instruction.classList.remove('show'), 5000);
      }

      exitVoidState() {
        console.log('🌌 EXITING VOID STATE: Returning to Bass');
        this.voidPhase = false;
        this.stage = 'INTRO';
        this.elements.orb.className = 'orb intro';
        this.currentTheme = 'intro';
        
        // Fade out void sounds
        this.voicePool.pad.active.forEach(voice => {
          voice.gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
          setTimeout(() => { if (voice.source) voice.source.stop(); }, 1000);
        });
        this.layerGains.pad.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        
        // Kickstart basic layers to ensure smooth transition
        this.layers.hihat = true;
        this.layers.atmosphere = true;
        this.layers.wobble = true;
        this.layers.sub = true;
        this.layers.kick = true;
        this.layers.vocal = true;
        this.motionHistory = Array(150).fill(3);
        this.totalMotion += 300;
        this.evolveToIntro();
        
        // Switch to next song in order
        this.currentSongIndex = (this.currentSongIndex + 1) % this.songs.length;
        this.setSong(this.currentSongIndex);

        // Hide instruction
        this.elements.instruction.classList.remove('show');
      }

      playVoidAmbience() {
        // Pad for breakdown with subtle binaural
        const duration = 20;
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < 3; i++) {
          const oscLeft = this.ctx.createOscillator();
          const gainLeft = this.ctx.createGain();
          const filterLeft = this.ctx.createBiquadFilter();
          
          oscLeft.type = 'sine';
          oscLeft.frequency.value = 110 * Math.pow(2, i / 4);
          
          filterLeft.type = 'lowpass';
          filterLeft.frequency.value = 300;
          filterLeft.Q.value = 0.5;
          
          gainLeft.gain.setValueAtTime(0, now);
          gainLeft.gain.linearRampToValueAtTime(0.05, now + 5);
          gainLeft.gain.setValueAtTime(0.05, now + duration - 5);
          gainLeft.gain.linearRampToValueAtTime(0, now + duration);
          
          oscLeft.connect(filterLeft).connect(gainLeft).connect(this.convolver);
          gainLeft.connect(this.masterGain);
          this.layerPanners.pad.positionX.value = -1;
          
          oscLeft.start(now);
          oscLeft.stop(now + duration);
          
          const oscRight = this.ctx.createOscillator();
          const gainRight = this.ctx.createGain();
          const filterRight = this.ctx.createBiquadFilter();
          
          oscRight.type = 'sine';
          oscRight.frequency.value = 110 * Math.pow(2, i / 4) + 0.5;
        
          filterRight.type = 'lowpass';
          filterRight.frequency.value = 300;
          filterRight.Q.value = 0.5;
          
          gainRight.gain.setValueAtTime(0, now);
          gainRight.gain.linearRampToValueAtTime(0.05, now + 5);
          gainRight.gain.setValueAtTime(0.05, now + duration - 5);
          gainRight.gain.linearRampToValueAtTime(0, now + duration);
          
          oscRight.connect(filterRight).connect(gainRight).connect(this.convolver);
          gainRight.connect(this.masterGain);
          this.layerPanners.pad.positionX.value = 1;
          
          oscRight.start(now);
          oscRight.stop(now + duration);
        }
        
        // Continue void ambience if still in void state
        if (this.voidPhase && this.active) {
          setTimeout(() => this.playVoidAmbience(), 15000);
        }
      }

      updateTechniques(avgMotion, variance) {
        if (avgMotion > 2 && variance > 1.5) {
          this.wobbleIntensity = Math.min(this.wobbleIntensity + 0.02, 1);
          this.tensionBuildup = Math.min(this.tensionBuildup + 0.01, 1);
          this.currentTechnique = 'wobble-rising';
        } else if (avgMotion < 1) {
          this.wobbleIntensity = Math.max(this.wobbleIntensity - 0.01, 0);
          this.tensionBuildup = Math.max(this.tensionBuildup - 0.005, 0);
          this.currentTechnique = 'sub-calm';
        }
        
        this.buildPhase = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 2;
        this.releasePhase = this.motionPattern === 'calm' && this.totalMotion > 100;
        this.climaxPhase = this.motionPattern === 'chaotic' && variance > 4;
        this.dimensionalPhase = this.specialEvents.dimensionalRift > 0 || this.easterEggs.fibonacciSpiral;
        
        if (this.climaxPhase) this.currentTechnique = 'drop';
        else if (this.buildPhase) this.currentTechnique = 'buildup';
        else if (this.releasePhase) this.currentTechnique = 'breakdown';
        else if (this.dimensionalPhase) this.currentTechnique = 'massive';
        
        this.glitchProbability = Math.min(variance / 10, 0.3);
        if (this.motionPattern === 'chaotic') this.glitchProbability += 0.2;
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
      }

      syncBPMToSteps() {
        if (this.stepCounter < 4) return;
        
        const stepInterval = (Date.now() - this.lastStepTime * (this.stepCounter - 1)) / (this.stepCounter - 1);
        const targetBPM = 60 / (stepInterval / 1000) * 1.5;
        
        this.bpm = this.bpm * 0.6 + targetBPM * 0.4;
        this.bpm = Math.max(100, Math.min(180, this.bpm));
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        if (this.voidPhase) {
          Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
          return;
        }
        
        const song = this.songs[this.currentSongIndex];
        
        // Layer activation based on motion and song biases
        this.layers.kick = (this.motionPattern === 'rhythmic' || this.motionPattern === 'chaotic') && avgMotion > 1.5 * (song.layerBiases.kick || 1.0);
        this.layers.bass = (this.motionPattern === 'sustained' || this.motionPattern === 'rhythmic') && avgMotion > 1.5 * (song.layerBiases.bass || 1.0);
        this.layers.hihat = true;
        this.layers.snare = this.motionPattern === 'erratic' || this.intensity > 2 * (song.layerBiases.snare || 1.0);
        this.layers.wobble = this.motionPattern !== 'calm' && this.stage !== 'SILENCE' && avgMotion > 0.5 * (song.layerBiases.wobble || 1.0);
        this.layers.sub = this.totalMotion > 200 && (this.buildPhase || this.climaxPhase) && avgMotion > 1.0 * (song.layerBiases.sub || 1.0);
        this.layers.growl = this.totalMotion > 100 && avgMotion > 1.0 * (song.layerBiases.growl || 1.0);
        this.layers.laser = this.buildPhase && this.intensity > 2.0 * (song.layerBiases.laser || 1.0);
        this.layers.vocal = this.releasePhase && this.totalMotion > 500 * (song.layerBiases.vocal || 1.0);
        this.layers.riser = this.buildPhase && this.gestureRecognition.sustained > 0.5 * (song.layerBiases.riser || 1.0);
        this.layers.impact = this.gestureRecognition.shake > 0.5 || this.climaxPhase * (song.layerBiases.impact || 1.0);
        this.layers.glitch = this.motionPattern === 'chaotic' && this.intensity > 2 * (song.layerBiases.glitch || 1.0);
        this.layers.atmosphere = true;
        this.layers.pad = this.releasePhase || this.motionPattern === 'sustained' && avgMotion > 1.0 * (song.layerBiases.pad || 1.0);
        this.layers.breath = this.releasePhase || this.phraseCount % 4 === 0 * (song.layerBiases.breath || 1.0);
        this.layers.whisper = this.motionPattern === 'erratic' || Math.random() < 0.05 * (song.layerBiases.whisper || 1.0);
        
        this.evolutionProgress = Math.min(this.totalMotion / 1200, 3);
        this.subStage = Math.floor(this.evolutionProgress);
        
        if (this.stage === 'INTRO' && this.totalMotion > 300) {
          this.evolveToBuildup();
        } else if (this.stage === 'BUILDUP' && this.totalMotion > 700) {
          this.evolveToDrop();
        } else if (this.stage === 'DROP' && this.totalMotion > 1200 && this.dimensionalPhase) {
          this.evolveToMassive();
        }
        
        let baseBPM = 140 + (avgMotion * 2) + (this.intensity * 1);
        baseBPM += (this.subStage * 5);
        if (this.stage === 'INTRO') baseBPM += 0;
        else if (this.stage === 'BUILDUP') baseBPM += 10;
        else if (this.stage === 'DROP') baseBPM += 0;
        else if (this.stage === 'MASSIVE') baseBPM += 10;
        
        if (this.buildPhase) baseBPM *= 1.05;
        if (this.releasePhase) baseBPM *= 0.95;
        if (this.climaxPhase) baseBPM *= 1.1;
        
        this.bpm = this.bpm * 0.85 + baseBPM * 0.15;
        this.bpm = Math.max(100, Math.min(180, this.bpm));
        
        this.updateCinematicTheme(avgMotion, this.intensity);
      }

      updateCinematicTheme(avgMotion, intensity) {
        let newTheme = 'intro';
        
        if (this.voidPhase) newTheme = 'void';
        else if (this.dimensionalPhase) newTheme = 'massive';
        else if (this.motionPattern === 'chaotic' || intensity > 4) newTheme = 'chaos';
        else if (avgMotion > 4 && intensity > 3 && this.buildPhase) newTheme = 'filth';
        else if (avgMotion > 2.5 && intensity > 2) newTheme = 'drop';
        else if (avgMotion > 1.5) newTheme = 'buildup';
        else if (avgMotion < 1.5 && this.totalMotion > 150 && this.releasePhase) newTheme = 'breakdown';
        
        if (this.songs[this.currentSongIndex].name.includes('Glitch')) {
          newTheme = 'glitch';
        }
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.elements.themeText.textContent = this.themes[newTheme].text;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 4000);
        }
      }

      triggerShakeEffects() {
        console.log('🌪️ SHAKE DETECTED: Drop Unleashed');
        this.gestureRecognition.shake = 0;
        this.specialEvents.glitchStorm = 2;
        this.layers.impact = true;
        this.bpm += 5;
        this.flashImpact();
      }

      evolveToIntro() {
        this.voidPhase = false;
        this.stage = 'INTRO';
        this.elements.orb.className = 'orb intro';
        this.createParticles(40, '#ff00ff');
        console.log('🔊 INTRO EVOLUTION: Bass Tease Begins');
      }

      evolveToBuildup() {
        this.stage = 'BUILDUP';
        this.transposition += 7;
        this.elements.orb.className = 'orb buildup';
        this.createParticles(60, '#00ffff');
        console.log('📈 BUILDUP EVOLUTION: Rising Wobble');
      }

      evolveToDrop() {
        this.stage = 'DROP';
        this.transposition += 7;
        this.elements.orb.className = 'orb drop';
        this.createParticles(80, '#ffff00');
        console.log('💥 DROP EVOLUTION: Heavy Bass Assault');
      }

      evolveToMassive() {
        this.stage = 'MASSIVE';
        this.elements.orb.className = 'orb breakdown';
        this.createParticles(100, '#ff00ff');
        this.dimensionalPhase = true;
        console.log('🌌 MASSIVE EVOLUTION: Ultimate Drop');
      }

      createParticles(count, color) {
        const existing = document.querySelector('.particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.background = color;
          particle.style.animationDelay = Math.random() * 12 + 's';
          particle.style.animationDuration = (6 + Math.random() * 8) + 's';
          container.appendChild(particle);
        }
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
            this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
            this.updateHarmony();
            if (this.phraseCount % 4 === 0) {
              this.playBreath();
            }
          }
          
          const interval = (60 / this.bpm) * 250;
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep() {
        // Skip playback during void phase
        if (this.voidPhase) return;
        
        // Calculate swing timing
        const swingOffset = (this.step % 2 === 1) ? this.drumSwing : 0;
        
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
        }
        
        // DUBSTEP BEATS
        const drumStep = this.step % 16;
        
        // Play drums with humanization
        if (this.layers.kick && this.drumPattern.kick[drumStep] > 0) {
          setTimeout(() => this.playDubstepKick(this.drumPattern.kick[drumStep]), swingOffset * 60);
        }
        if (this.layers.snare && this.drumPattern.snare[drumStep] > 0) {
          setTimeout(() => this.playDubstepSnare(this.drumPattern.snare[drumStep]), swingOffset * 60);
        }
        if (this.layers.hihat && this.drumPattern.hihat[drumStep] > 0) {
          setTimeout(() => this.playDubstepHihat(this.drumPattern.hihat[drumStep]), swingOffset * 60);
        }
        if (this.drumPattern.ghost[drumStep] > 0) {
          setTimeout(() => this.playGhostNote(this.drumPattern.ghost[drumStep]), swingOffset * 60);
        }
        
        // Dubstep layers
        if (this.layers.bass && this.step % 4 === 0) this.playBass();
        if (this.layers.wobble && this.step % 1 === 0) this.playWobble();
        if (this.layers.sub && this.step % 4 === 0) this.playSub();
        if (this.layers.growl && this.step % 8 === 0 && this.climaxPhase) this.playGrowl();
        if (this.layers.laser && Math.random() < 0.05 && this.buildPhase) this.playLaser();
        if (this.layers.vocal && this.step % 16 === 0 && this.releasePhase) this.playVocal();
        if (this.layers.riser && this.step % 32 === 0 && this.buildPhase) this.playRiser();
        if (this.layers.impact && Math.random() < 0.3 && this.climaxPhase) this.playImpact();
        if (this.layers.glitch && Math.random() < 0.15) this.playGlitch();
        if (this.layers.atmosphere && Math.random() < 0.03 && this.releasePhase) this.playAtmosphere();
        if (this.layers.pad && this.step % 32 === 0 && this.releasePhase) this.playPad();
        if (this.layers.breath && Math.random() < 0.1) this.playBreath();
        if (this.layers.whisper && Math.random() < 0.05) this.playWhisper();
        
        // Glitch effects in chaotic mode
        if (this.motionPattern === 'chaotic' && Math.random() < this.glitchProbability) {
          this.applyGlitchEffect();
        }
        
        // Update special events
        Object.keys(this.specialEvents).forEach(event => {
          this.specialEvents[event] = Math.max(0, this.specialEvents[event] - 0.01);
        });
      }

      applyGlitchEffect() {
        const layers = Object.keys(this.layers).filter(l => this.layers[l]);
        if (layers.length === 0) return;
        const randomLayer = layers[Math.floor(Math.random() * layers.length)];
        const glitchDuration = 0.1 + Math.random() * 0.2;
        
        this.layerGains[randomLayer].gain.linearRampToValueAtTime(1.2, this.ctx.currentTime + glitchDuration / 2);
        this.layerGains[randomLayer].gain.linearRampToValueAtTime(0.65, this.ctx.currentTime + glitchDuration);
        console.log(`Glitch applied to ${randomLayer}`);
      }

      // DUBSTEP DRUM SOUNDS
      playDubstepKick(velocity = 1) {
        // Heavy dubstep kick with more sub and punch
        const now = this.ctx.currentTime;
        const humanize = (Math.random() - 0.5) * this.drumHumanize;
        
        // Sub layer
        const sub = this.ctx.createOscillator();
        const subEnv = this.ctx.createGain();
        
        sub.type = 'sine';
        sub.frequency.setValueAtTime(60, now + humanize);
        sub.frequency.exponentialRampToValueAtTime(30, now + humanize + 0.15);
        
        // Mid punch
        const mid = this.ctx.createOscillator();
        const midEnv = this.ctx.createGain();
        
        mid.type = 'sine';
        mid.frequency.setValueAtTime(200, now + humanize);
        mid.frequency.exponentialRampToValueAtTime(60, now + humanize + 0.08);
        
        // Click attack
        const click = this.ctx.createBufferSource();
        const clickEnv = this.ctx.createGain();
        const clickFilter = this.ctx.createBiquadFilter();
        
        const clickBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.02, this.ctx.sampleRate);
        const clickData = clickBuffer.getChannelData(0);
        for (let i = 0; i < clickData.length; i++) {
          clickData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / clickData.length, 0.5);
        }
        click.buffer = clickBuffer;
        
        clickFilter.type = 'highpass';
        clickFilter.frequency.value = 1000;
        clickFilter.Q.value = 1.5;
        
        // Velocity
        const dynVelocity = this.drumDynamics.kick.min + (this.drumDynamics.kick.max - this.drumDynamics.kick.min) * velocity;
        
        // Envelopes
        subEnv.gain.setValueAtTime(1.8 * dynVelocity, now + humanize);
        subEnv.gain.exponentialRampToValueAtTime(0.001, now + humanize + 0.4);
        
        midEnv.gain.setValueAtTime(1.0 * dynVelocity, now + humanize);
        midEnv.gain.exponentialRampToValueAtTime(0.001, now + humanize + 0.1);
        
        clickEnv.gain.setValueAtTime(0.4 * dynVelocity, now + humanize);
        clickEnv.gain.exponentialRampToValueAtTime(0.001, now + humanize + 0.02);
        
        // Compression
        const kickComp = this.ctx.createDynamicsCompressor();
        kickComp.threshold.value = -12;
        kickComp.ratio.value = 12;
        kickComp.attack.value = 0.001;
        kickComp.release.value = 0.08;
        
        // Master gain
        const kickGain = this.ctx.createGain();
        kickGain.gain.value = 1.0;
        
        // Routing
        sub.connect(subEnv).connect(kickComp);
        mid.connect(midEnv).connect(kickComp);
        click.connect(clickFilter).connect(clickEnv).connect(kickComp);
        kickComp.connect(kickGain).connect(this.layerGains.kick);
        
        // Allocate
        if (!this.allocateVoice('kick', sub, kickGain, 0.4)) return;
        
        sub.start(now + humanize);
        mid.start(now + humanize);
        click.start(now + humanize);
        
        sub.stop(now + humanize + 0.4);
        mid.stop(now + humanize + 0.4);
        click.stop(now + humanize + 0.1);
      }

      playDubstepSnare(velocity = 1) {
        // Crispy dubstep snare with reverb tail
        const now = this.ctx.currentTime;
        const humanize = (Math.random() - 0.5) * this.drumHumanize;
        
        // Tone
        const tone1 = this.ctx.createOscillator();
        const tone2 = this.ctx.createOscillator();
        const toneEnv = this.ctx.createGain();
        
        tone1.type = 'triangle';
        tone1.frequency.value = 200 + this.intensity * 30;
        tone2.type = 'triangle';
        tone2.frequency.value = 400 + this.intensity * 50;
        
        // Noise
        const noise = this.ctx.createBufferSource();
        const noiseEnv = this.ctx.createGain();
        const noiseFilter = this.ctx.createBiquadFilter();
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 0.4);
        }
        noise.buffer = noiseBuffer;
        
        noiseFilter.type = 'bandpass';
        noiseFilter.frequency.value = 2000;
        noiseFilter.Q.value = 0.8;
        
        // Velocity
        const dynVelocity = this.drumDynamics.snare.min + (this.drumDynamics.snare.max - this.drumDynamics.snare.min) * velocity;
        
        // Envelopes
        toneEnv.gain.setValueAtTime(0.6 * dynVelocity, now + humanize);
        toneEnv.gain.exponentialRampToValueAtTime(0.001, now + humanize + 0.15);
        
        noiseEnv.gain.setValueAtTime(1.0 * dynVelocity, now + humanize);
        noiseEnv.gain.exponentialRampToValueAtTime(0.001, now + humanize + 0.25);
        
        // Distortion
        const snareDistortion = this.ctx.createWaveShaper();
        snareDistortion.curve = this.makeDistortionCurve(12);
        snareDistortion.oversample = '4x';
        
        // Master gain
        const snareGain = this.ctx.createGain();
        snareGain.gain.value = 1.0;
        
        // Routing
        tone1.connect(toneEnv).connect(snareDistortion);
        tone2.connect(toneEnv).connect(snareDistortion);
        noise.connect(noiseFilter).connect(noiseEnv).connect(snareDistortion);
        snareDistortion.connect(snareGain).connect(this.layerGains.snare);
        
        // Allocate
        if (!this.allocateVoice('snare', tone1, snareGain, 0.3)) return;
        
        tone1.start(now + humanize);
        tone2.start(now + humanize);
        noise.start(now + humanize);
        
        tone1.stop(now + humanize + 0.3);
        tone2.stop(now + humanize + 0.3);
        noise.stop(now + humanize + 0.3);
      }

      playDubstepHihat(velocity = 1) {
        // Shimmering hihat with triplet feel
        const now = this.ctx.currentTime;
        const humanize = (Math.random() - 0.5) * this.drumHumanize * 0.5;
        
        const sources = [];
        const gains = [];
        
        for (let i = 0; i < 3; i++) {
          const noise = this.ctx.createBufferSource();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
          const noiseData = noiseBuffer.getChannelData(0);
          for (let j = 0; j < noiseData.length; j++) {
            noiseData[j] = (Math.random() * 2 - 1);
          }
          noise.buffer = noiseBuffer;
          
          filter.type = 'bandpass';
          filter.frequency.value = 6000 + i * 3000;
          filter.Q.value = 3 + i;
          
          noise.connect(filter).connect(gain);
          sources.push(noise);
          gains.push(gain);
        }
        
        // Velocity
        const dynVelocity = this.drumDynamics.hihat.min + (this.drumDynamics.hihat.max - this.drumDynamics.hihat.min) * velocity;
        
        // Env
        const env = this.ctx.createGain();
        const openness = this.motionPattern === 'chaotic' ? 0.4 : 0.15;
        
        env.gain.setValueAtTime(dynVelocity, now + humanize);
        env.gain.exponentialRampToValueAtTime(0.001, now + humanize + openness);
        
        // Brightener
        const brightener = this.ctx.createBiquadFilter();
        brightener.type = 'highshelf';
        brightener.frequency.value = 8000;
        brightener.gain.value = 6;
        
        // Master gain
        const hihatGain = this.ctx.createGain();
        hihatGain.gain.value = 1.0;
        
        gains.forEach(g => g.connect(env));
        env.connect(brightener).connect(hihatGain).connect(this.layerGains.hihat);
        
        if (!this.allocateVoice('hihat', sources[0], hihatGain, openness)) return;
        
        sources.forEach((s, i) => {
          s.start(now + humanize);
          s.stop(now + humanize + openness + 0.1);
        });
      }

      playGhostNote(velocity = 1) {
        // Subtle ghost for dubstep groove
        const now = this.ctx.currentTime;
        const humanize = (Math.random() - 0.5) * this.drumHumanize * 2;
        
        const tone = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        tone.type = 'triangle';
        tone.frequency.value = 300;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.4;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 2500;
        filter.Q.value = 1.5;
        
        const dynVelocity = this.drumDynamics.ghost.min + (this.drumDynamics.ghost.max - this.drumDynamics.ghost.min) * velocity;
        
        env.gain.setValueAtTime(dynVelocity, now + humanize);
        env.gain.exponentialRampToValueAtTime(0.001, now + humanize + 0.05);
        
        tone.connect(filter).connect(env).connect(gain).connect(this.layerGains.snare);
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.snare);
        
        if (!this.allocateVoice('snare', tone, gain, 0.05)) return;
        
        tone.start(now + humanize);
        noise.start(now + humanize);
        tone.stop(now + humanize + 0.05);
        noise.stop(now + humanize + 0.05);
      }

      // Dubstep synth sounds
      playBass() {
        const noteIndex = this.bassNote % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 1);
        
        const osc = this.ctx.createOscillator();
        const subOsc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('bass', osc, gain, 0.8)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        subOsc.type = 'sine';
        subOsc.frequency.value = freq / 2;
        
        filter.type = 'lowpass';
        filter.frequency.value = 100 + this.motion * 30;
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(1.5, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8); 
        
        gain.gain.value = 1.2;
        
        osc.connect(filter);
        subOsc.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.bass);
        osc.start();
        subOsc.start();
        osc.stop(this.ctx.currentTime + 0.8);
        subOsc.stop(this.ctx.currentTime + 0.8);
      }

      playWobble() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(noteIndex, 2);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        if (!this.allocateVoice('wobble', osc, gain, 0.25)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        lfo.type = 'sawtooth';
        lfo.frequency.value = 8 + this.wobbleIntensity * 20; // Wobble speed
        lfo.connect(lfoGain);
        lfoGain.gain.value = 800 + this.wobbleIntensity * 2000; // Wobble depth
        lfoGain.connect(filter.frequency);
        lfo.start();
        lfo.stop(this.ctx.currentTime + 0.25);
        
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        filter.Q.value = 15;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
        
        gain.gain.value = 0.8;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.wobble);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.25);
        
        this.ostinatoIndex++;
      }

      playSub() {
        const freq = this.noteToFreq(this.chordProgression[this.currentChordIndex][0], 1);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('sub', osc, gain, 0.8)) return;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(1.2, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        gain.gain.value = 1.0;
        
        osc.connect(env).connect(gain).connect(this.layerGains.sub);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.8);
      }

      playGrowl() {
        const baseFreq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 2);
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const distortion = this.ctx.createWaveShaper();
        
        if (!this.allocateVoice('growl', osc1, gain, 1)) return;
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = baseFreq;
        osc2.type = 'square';
        osc2.frequency.value = baseFreq * 1.01;
        
        distortion.curve = this.makeDistortionCurve(50);
        distortion.oversample = '4x';
        
        filter.type = 'lowpass';
        filter.frequency.value = 800 + this.intensity * 400;
        filter.Q.value = 20;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.2);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        
        gain.gain.value = 0.6;
        
        osc1.connect(distortion);
        osc2.connect(distortion);
        distortion.connect(filter).connect(env).connect(gain).connect(this.layerGains.growl);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 1);
        osc2.stop(this.ctx.currentTime + 1);
      }

      playLaser() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 5);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('laser', osc, gain, 0.5)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(freq * 2, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq / 4, this.ctx.currentTime + 0.5);
        
        filter.type = 'bandpass';
        filter.frequency.value = 2000;
        filter.Q.value = 10;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.laser);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      playVocal() {
        // Placeholder for vocal chop - use noise for simulation
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('vocal', noise, gain, 0.5)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'formant'; // Approximate vocal formant
        filter.frequency.value = 800 + Math.random() * 800;
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(0.8, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        gain.gain.value = 0.3;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.vocal);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.5);
      }

      playRiser() {
        const duration = 4 + this.intensity * 2;
        const osc = this.ctx.createOscillator();
        const lowSweep = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('riser', osc, gain, duration)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(40, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(4000, this.ctx.currentTime + duration);
        
        lowSweep.type = 'sine';
        lowSweep.frequency.setValueAtTime(20, this.ctx.currentTime);
        lowSweep.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + duration);
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.5;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(80, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(16000, this.ctx.currentTime + duration);
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + duration);
        
        gain.gain.value = 0.5;
        
        osc.connect(filter);
        lowSweep.connect(filter);
        noise.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.riser);
        
        osc.start();
        lowSweep.start();
        noise.start();
        osc.stop(this.ctx.currentTime + duration);
        lowSweep.stop(this.ctx.currentTime + duration);
        noise.stop(this.ctx.currentTime + duration);
      }

      playImpact() {
        const freq = 40 + 20;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('impact', osc, gain, 1.2)) return;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq * 3, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 0.06);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 15, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(freq * 2, this.ctx.currentTime + 0.3);
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(1.2, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.4, this.ctx.currentTime + 0.03);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.2);
        
        gain.gain.value = 1.0;
        
        osc.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.impact);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1.2);
        
        this.flashImpact();
      }

      playGlitch() {
        const grainCount = 3 + Math.floor(this.intensity * 3);
        
        for (let i = 0; i < grainCount; i++) {
          setTimeout(() => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            if (!this.allocateVoice('glitch', osc, gain, 0.15)) return;
            
            osc.type = 'square';
            osc.frequency.value = 400 + Math.random() * 800;
            
            filter.type = 'bandpass';
            filter.frequency.value = 1500 + Math.random() * 2000;
            filter.Q.value = 20;
            
            env.gain.setValueAtTime(0, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.02);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.15);
            
            gain.gain.value = 0.3;
            
            osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.glitch);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.15);
          }, i * 15);
        }
      }

      playAtmosphere() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 4);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('atmosphere', osc, gain, 15)) return;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 200 + 50;
        filter.Q.value = 8;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 4);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 15);
        
        gain.gain.value = 0.12;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.atmosphere);
        osc.start();
        osc.stop(this.ctx.currentTime + 15);
        
        this.noiseGain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 3);
      }

      playPad() {
        this.scale.forEach((note, i) => {
          if (i % 2 !== 0) return;
          
          const freq = this.noteToFreq(note, 3 + i % 3);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('pad', osc, gain, 10)) return;
          
          osc.type = 'triangle';
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 300 + this.motion * 60;
          filter.Q.value = 1.2;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 3);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);
          
          gain.gain.value = 0.15;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.pad);
          osc.start();
          osc.stop(this.ctx.currentTime + 10);
        });
      }

      playGoldenRatioChord() {
        console.log('✨ GOLDEN RATIO CHORD: Divine Wobble');
        const phi = 1.618033988749;
        const baseFreq = 174.61; // F2
        const duration = 10;
        
        const ratios = [1, phi, phi * phi, 1 / phi];
        
        ratios.forEach((ratio, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('wobble', osc, gain, duration)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = baseFreq * ratio;
          
          filter.type = 'bandpass';
          filter.frequency.value = baseFreq * ratio;
          filter.Q.value = 25;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 2.5);
          env.gain.setValueAtTime(0.4, this.ctx.currentTime + duration - 2.5);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          gain.gain.value = 0.2;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.wobble);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        });
        
        this.easterEggs.goldenRatio = true;
      }

      playBreath() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('breath', noise, gain, 1.2)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 1.2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(i / noiseData.length, 0.6);
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 1000;
        filter.Q.value = 1.5;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 0.6);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.2);
        
        gain.gain.value = 0.25;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.breath);
        noise.start();
        noise.stop(this.ctx.currentTime + 1.2);
      }

      playWhisper() {
        const noise = this.ctx.createBufferSource();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const mod = this.ctx.createGain();
        
        if (!this.allocateVoice('whisper', noise, gain, 1.5)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 1.5, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.4;
        }
        noise.buffer = noiseBuffer;
        
        osc.type = 'sine';
        osc.frequency.value = 5;
        osc.connect(mod.gain);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
        
        filter.type = 'bandpass';
        filter.frequency.value = 2500 + 600;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.4);
        env.gain.linearRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        mod.gain.value = 0.6;
        noise.connect(mod).connect(filter).connect(env).connect(gain).connect(this.layerGains.whisper);
        
        gain.gain.value = 0.2;
        
        noise.start();
        noise.stop(this.ctx.currentTime + 1.5);
      }

      allocateVoice(layer, source, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) return false;
        
        pool.active = pool.active.filter(voice => {
          if (voice && voice.source && this.ctx.currentTime > voice.startTime + duration + 0.1) {
            voice.source.stop();
            return false;
          }
          return true;
        });
        
        if (pool.active.length >= pool.max) {
          const oldest = pool.active.shift();
          if (oldest && oldest.source) {
            oldest.gain.gain.setValueAtTime(0, this.ctx.currentTime);
            oldest.source.stop(this.ctx.currentTime + 0.01);
          }
        }
        
        const voice = { source, gain: gainNode, startTime: this.ctx.currentTime };
        pool.active.push(voice);
        
        setTimeout(() => {
          const index = pool.active.indexOf(voice);
          if (index !== -1) pool.active.splice(index, 1);
        }, duration * 1000 + 100);
        
        return true;
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
      }

      noteToFreq(note, octave = 4) {
        const semitones = this.keyOffsets[this.key] + note + this.transposition;
        return 174.61 * Math.pow(2, semitones / 12 + (octave - 3)); // Lower octave for dubstep
      }

      updateUI() {
        this.elements.stageName.textContent = this.voidPhase ? 'VOID STATE' : this.stage;
        this.elements.technique.textContent = this.currentTechnique.toUpperCase();
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = `${this.key} ${this.mode.toUpperCase()}`;
        
        const motionPercent = Math.min((this.motion + this.intensity) * 10, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        const wobblePercent = this.wobbleIntensity * 100;
        this.elements.shepardBar.style.width = wobblePercent + '%';
        
        const totalVoices = Object.values(this.voicePool).reduce((sum, pool) => sum + pool.active.length, 0);
        this.elements.voiceCount.textContent = totalVoices;
        
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.dataArray);
          this.spectrumBars.forEach((bar, i) => {
            const height = (this.dataArray[i] / 255) * 80;
            bar.style.height = height + 'px';
            
            // Dynamic colors based on stage
            let color = 'rgba(0,255,0,0.8)';
            if (this.voidPhase) color = 'rgba(0,0,0,0.4)';
            else if (this.stage === 'INTRO') color = 'rgba(255,0,255,0.8)';
            else if (this.stage === 'BUILDUP') color = 'rgba(0,255,255,0.8)';
            else if (this.stage === 'DROP') color = 'rgba(255,255,0,0.8)';
            else if (this.stage === 'MASSIVE') {
              const hue = (Date.now() / 10 + i * 10) % 360;
              color = `hsla(${hue}, 80%, 50%, 0.8)`;
            }
            
            bar.style.background = `linear-gradient(0deg, ${color}, rgba(0,255,0,0.2))`;
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          const theme = this.themes[this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 4, 1);
          const motionNorm = Math.min(this.motion / 6, 1);
          
          let bg;
          if (this.voidPhase) {
            const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
            bg = `radial-gradient(circle at 50% 50%, rgba(0, 0, 0, ${0.1 + breathe * 0.1}) 5%, rgba(0, 0, 0, ${0.05 + breathe * 0.05}) 20%, #000000 60%)`;
          } else if (this.dimensionalPhase) {
            const hue = (Date.now() / 10 % 360);
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 80%, ${20 + intensityNorm * 30}%) ${5 * motionNorm}%, hsl(${(hue + 120) % 360}, 80%, ${15 + intensityNorm * 20}%) ${20 * intensityNorm}%, #000000 ${60 + 30 * intensityNorm}%)`;
          } else {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
            bg += `${theme.colors[0]} ${5 * motionNorm}%, `;
            if (theme.colors[1]) bg += `${theme.colors[1]} ${20 * intensityNorm}%, `;
            bg += `#000000 ${60 + 30 * intensityNorm}%`;
            bg += ')';
          }
          
          document.body.style.background = bg;
          
          this.elements.cinematicOverlay.classList.toggle('active', this.buildPhase || this.climaxPhase || this.intensity > 2);
          
          // Update dynamic 3D panning
          const targetX = Math.cos(this.direction * Math.PI / 180) * (this.motion + this.intensity) * 3;
          const targetY = Math.sin(this.direction * Math.PI / 180) * (this.motion + this.intensity) * 3;
          const targetZ = (this.orientation.gamma / 90) * (this.motion + this.intensity) * 2;
          
          Object.keys(this.layerPanners).forEach(name => {
            const scale = this.layerPanScales[name] || 1;
            const tx = this.basePositions[name].x + targetX * scale;
            const ty = this.basePositions[name].y + targetY * scale;
            const tz = this.basePositions[name].z + targetZ * scale;
            
            const pos = this.layerPositions[name];
            pos.x += (tx - pos.x) * this.panningLerp;
            pos.y += (ty - pos.y) * this.panningLerp;
            pos.z += (tz - pos.z) * this.panningLerp;
            
            if (this.layerPanners[name]) {
              this.layerPanners[name].positionX.value = pos.x;
              this.layerPanners[name].positionY.value = pos.y;
              this.layerPanners[name].positionZ.value = pos.z;
            }
          });
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    new DubstepEngine();
  </script>
</body>
</html>
