<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GUMP: Grand Unified Music Project</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { 
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(ellipse at 60% 50%, #161826 0%, #0a0c11 80%);
      color: #e5f8ff;
      height: 100vh;
      overflow: hidden;
      transition: background 1s ease;
    }
    
    .intro {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 10;
      transition: opacity 1s ease;
    }
    
    .intro-title {
      font-size: clamp(1.5rem, 5vw, 2.5rem);
      font-weight: 900;
      letter-spacing: 2px;
      text-shadow: 0 0 60px #7fdaff;
      margin-bottom: 2rem;
      animation: glow 3s ease-in-out infinite alternate;
    }
    
    .intro-author {
      font-size: 1.1rem;
      color: #b3e3f9;
      opacity: 0.8;
      margin-bottom: 3rem;
      letter-spacing: 0.5px;
    }
    
    .intro-btn {
      background: linear-gradient(45deg, #00cfff, #ed9fe7);
      color: #111;
      font-weight: 700;
      font-size: 1.2rem;
      padding: 1rem 3rem;
      border-radius: 50px;
      border: none;
      cursor: pointer;
      transition: transform 0.2s ease;
    }
    
    .intro-btn:hover { transform: scale(1.05); }
    .intro-btn:active { transform: scale(0.95); }
    
    @keyframes glow {
      from { text-shadow: 0 0 20px #7fdaff; }
      to { text-shadow: 0 0 40px #7fdaff, 0 0 60px #7fdaff; }
    }
    
    .app {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .orb-container {
      position: relative;
      width: min(80vw, 400px);
      height: min(80vw, 400px);
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .orb {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: radial-gradient(circle at 40% 40%, #4a5568, #1a202c);
      box-shadow: 0 0 50px rgba(116, 200, 255, 0.3);
      transition: all 0.5s ease;
      animation: pulse 4s ease-in-out infinite alternate;
    }
    
    .orb.active {
      background: radial-gradient(circle at 40% 40%, #667eea, #764ba2);
      box-shadow: 0 0 80px rgba(116, 200, 255, 0.6);
    }
    
    .orb.void {
      background: radial-gradient(circle at 40% 40%, #2d1b69, #11051a);
      box-shadow: 0 0 100px rgba(163, 108, 226, 0.8);
    }
    
    @keyframes pulse {
      from { transform: scale(1); opacity: 0.8; }
      to { transform: scale(1.1); opacity: 1; }
    }
    
    .info {
      position: absolute;
      bottom: 20vh;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.7);
      padding: 1rem 2rem;
      border-radius: 30px;
      font-size: 1rem;
      text-align: center;
      opacity: 0;
      transition: opacity 0.5s ease;
      backdrop-filter: blur(10px);
    }
    
    .info.show { opacity: 1; }
  </style>
</head>
<body>
  <div class="intro" id="intro">
    <div class="intro-title">GUMP</div>
    <div class="intro-author">Grand Unified Music Project</div>
    <button class="intro-btn" id="startBtn">Begin Experience</button>
  </div>
  
  <div class="app" id="app">
    <div class="orb-container">
      <div class="orb" id="orb"></div>
    </div>
    <div class="info" id="info"></div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.audio = null;
        this.started = false;
        this.oscillators = [];
        this.gainNodes = [];
        this.beat = 0;
        this.bpm = 120;
        this.tickInterval = null;
        
        // State
        this.motion = { active: false, level: 0 };
        this.time = this.getTimeInfo();
        this.weather = { temp: 20, condition: 'clear', isDay: true };
        this.location = { city: 'Unknown', region: '', country: '' };
        this.mode = 'normal'; // 'normal' or 'void'
        
        // Music DNA
        this.musicDNA = this.generateMusicDNA();
        
        this.initElements();
        this.setupEventListeners();
        this.requestPermissions();
      }
      
      initElements() {
        this.elements = {
          intro: document.getElementById('intro'),
          app: document.getElementById('app'),
          orb: document.getElementById('orb'),
          info: document.getElementById('info'),
          startBtn: document.getElementById('startBtn')
        };
      }
      
      setupEventListeners() {
        this.elements.startBtn.addEventListener('click', () => this.start());
        
        // Motion detection
        if (window.DeviceMotionEvent) {
          window.addEventListener('devicemotion', (e) => this.handleMotion(e));
        }
        
        // Mouse movement as motion fallback
        let mouseTimeout;
        document.addEventListener('mousemove', () => {
          this.motion.active = true;
          clearTimeout(mouseTimeout);
          mouseTimeout = setTimeout(() => {
            this.motion.active = false;
          }, 2000);
        });
      }
      
      async requestPermissions() {
        // Request device motion permission on iOS
        if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
          try {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission === 'granted') {
              console.log('Motion permission granted');
            }
          } catch (error) {
            console.log('Motion permission denied');
          }
        }
        
        // Get location and weather
        this.getLocationAndWeather();
      }
      
      async getLocationAndWeather() {
        try {
          const position = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              enableHighAccuracy: true,
              timeout: 5000,
              maximumAge: 300000
            });
          });
          
          const { latitude: lat, longitude: lon } = position.coords;
          
          // Get weather
          const weatherResponse = await fetch(
            `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current_weather=true`
          );
          const weatherData = await weatherResponse.json();
          
          if (weatherData.current_weather) {
            this.weather = {
              temp: weatherData.current_weather.temperature,
              condition: this.decodeWeatherCode(weatherData.current_weather.weathercode),
              isDay: weatherData.current_weather.is_day === 1
            };
          }
          
          // Get location name
          const locationResponse = await fetch(
            `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lon}&zoom=10`
          );
          const locationData = await locationResponse.json();
          
          if (locationData.address) {
            this.location = {
              city: locationData.address.city || locationData.address.town || 'Unknown',
              region: locationData.address.state || locationData.address.county || '',
              country: locationData.address.country || ''
            };
          }
          
          // Regenerate music DNA with new data
          this.musicDNA = this.generateMusicDNA();
          
        } catch (error) {
          console.log('Location/weather unavailable, using defaults');
        }
      }
      
      decodeWeatherCode(code) {
        if (code < 3) return 'clear';
        if (code < 5) return 'cloudy';
        if (code < 20) return 'fog';
        if (code < 30) return 'rain';
        if (code < 40) return 'snow';
        if (code < 50) return 'storm';
        return 'clear';
      }
      
      getTimeInfo() {
        const now = new Date();
        const hour = now.getHours();
        const seasons = ['winter', 'spring', 'summer', 'fall'];
        const season = seasons[Math.floor((now.getMonth() + 1) / 3) % 4];
        const weekdays = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        const weekday = weekdays[now.getDay()];
        
        return { hour, season, weekday };
      }
      
      generateMusicDNA() {
        const rootFreqs = [220, 247, 262, 294, 330, 349, 392, 440]; // A3 to A4
        const seasonOffsets = { winter: 0, spring: 2, summer: 4, fall: 6 };
        
        const rootIndex = (this.time.hour + seasonOffsets[this.time.season]) % rootFreqs.length;
        const root = rootFreqs[rootIndex];
        
        // Scale based on time of day
        const scale = this.weather.isDay ? 
          [0, 2, 4, 5, 7, 9, 11] : // Major-ish
          [0, 2, 3, 5, 7, 8, 10]; // Minor-ish
        
        // Chord progression
        const progressions = [
          [0, 3, 4, 2], // vi-IV-I-V
          [0, 4, 2, 3], // vi-I-V-IV
          [0, 2, 4, 3]  // vi-V-I-IV
        ];
        const progression = progressions[this.time.hour % progressions.length];
        
        // Tempo based on weather and motion
        let bpm = 120;
        if (this.weather.condition === 'storm') bpm = 140;
        else if (this.weather.condition === 'rain') bpm = 90;
        else if (this.weather.temp > 25) bpm = 130;
        else if (this.weather.temp < 5) bpm = 100;
        
        return {
          root,
          scale,
          progression,
          bpm,
          detune: this.weather.temp > 30 ? 0.02 : 0.01
        };
      }
      
      handleMotion(event) {
        if (!event.accelerationIncludingGravity) return;
        
        const { x, y, z } = event.accelerationIncludingGravity;
        const magnitude = Math.sqrt(x * x + y * y + z * z);
        
        this.motion.level = Math.max(0, Math.min(1, (magnitude - 9) / 5));
        this.motion.active = this.motion.level > 0.1;
      }
      
      async start() {
        if (this.started) return;
        this.started = true;
        
        // Initialize audio context
        this.audio = new (window.AudioContext || window.webkitAudioContext)();
        
        // Fade out intro
        this.elements.intro.style.opacity = '0';
        setTimeout(() => {
          this.elements.intro.style.display = 'none';
          this.elements.app.style.opacity = '1';
        }, 1000);
        
        // Start music loop
        this.bpm = this.musicDNA.bpm;
        this.startMusicLoop();
        
        // Update info
        this.updateInfo();
      }
      
      startMusicLoop() {
        const tickDuration = (60 / this.bpm / 2) * 1000; // 16th notes
        
        this.tickInterval = setInterval(() => {
          this.musicTick();
        }, tickDuration);
      }
      
      musicTick() {
        this.beat++;
        
        // Determine mode based on motion
        const newMode = this.motion.active ? 'normal' : 'void';
        if (newMode !== this.mode) {
          this.mode = newMode;
          this.updateVisuals();
          this.updateInfo();
        }
        
        // Clean up old oscillators
        this.cleanup();
        
        // Generate music based on mode
        if (this.mode === 'normal') {
          this.playNormalMusic();
        } else {
          this.playVoidMusic();
        }
      }
      
      playNormalMusic() {
        const buildLevel = Math.min(4, Math.floor(this.motion.level * 4) + 1);
        
        // Kick drum
        if (this.beat % 4 === 0) {
          this.playKick();
        }
        
        // Hi-hat
        if (buildLevel > 1 && this.beat % 2 === 1) {
          this.playHiHat();
        }
        
        // Snare
        if (buildLevel > 1 && this.beat % 8 === 4) {
          this.playSnare();
        }
        
        // Bass
        if (buildLevel > 2) {
          this.playBass();
        }
        
        // Chords
        if (buildLevel > 3 && this.beat % 8 === 0) {
          this.playChords();
        }
      }
      
      playVoidMusic() {
        // Ambient drone
        if (this.beat % 16 === 0) {
          this.playAmbientDrone();
        }
        
        // Sparse bells
        if (this.beat % 32 === 0) {
          this.playBell();
        }
      }
      
      playKick() {
        const osc = this.audio.createOscillator();
        const gain = this.audio.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.audio.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, this.audio.currentTime + 0.1);
        
        gain.gain.setValueAtTime(0.3, this.audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 0.2);
        
        osc.connect(gain);
        gain.connect(this.audio.destination);
        
        osc.start();
        osc.stop(this.audio.currentTime + 0.2);
        
        this.oscillators.push(osc);
        this.gainNodes.push(gain);
      }
      
      playHiHat() {
        const noise = this.createNoise(0.05);
        const filter = this.audio.createBiquadFilter();
        const gain = this.audio.createGain();
        
        filter.type = 'highpass';
        filter.frequency.value = 8000;
        
        gain.gain.setValueAtTime(0.1, this.audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 0.05);
        
        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.audio.destination);
        
        noise.start();
        noise.stop(this.audio.currentTime + 0.05);
        
        this.oscillators.push(noise);
        this.gainNodes.push(gain);
      }
      
      playSnare() {
        const noise = this.createNoise(0.1);
        const osc = this.audio.createOscillator();
        const noiseGain = this.audio.createGain();
        const oscGain = this.audio.createGain();
        
        // Noise component
        noiseGain.gain.setValueAtTime(0.2, this.audio.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 0.1);
        
        // Tone component
        osc.type = 'triangle';
        osc.frequency.value = 200;
        oscGain.gain.setValueAtTime(0.1, this.audio.currentTime);
        oscGain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 0.08);
        
        noise.connect(noiseGain);
        noiseGain.connect(this.audio.destination);
        
        osc.connect(oscGain);
        oscGain.connect(this.audio.destination);
        
        noise.start();
        noise.stop(this.audio.currentTime + 0.1);
        osc.start();
        osc.stop(this.audio.currentTime + 0.08);
        
        this.oscillators.push(noise, osc);
        this.gainNodes.push(noiseGain, oscGain);
      }
      
      playBass() {
        const osc = this.audio.createOscillator();
        const gain = this.audio.createGain();
        
        osc.type = 'triangle';
        osc.frequency.value = this.musicDNA.root * 0.5;
        
        gain.gain.setValueAtTime(0.15, this.audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 0.3);
        
        osc.connect(gain);
        gain.connect(this.audio.destination);
        
        osc.start();
        osc.stop(this.audio.currentTime + 0.3);
        
        this.oscillators.push(osc);
        this.gainNodes.push(gain);
      }
      
      playChords() {
        const chordIndex = Math.floor(this.beat / 8) % this.musicDNA.progression.length;
        const scaleIndex = this.musicDNA.progression[chordIndex];
        
        // Play triad
        for (let i = 0; i < 3; i++) {
          const noteIndex = (scaleIndex + i * 2) % this.musicDNA.scale.length;
          const semitones = this.musicDNA.scale[noteIndex];
          const frequency = this.musicDNA.root * Math.pow(2, semitones / 12);
          
          const osc = this.audio.createOscillator();
          const gain = this.audio.createGain();
          
          osc.type = 'sawtooth';
          osc.frequency.value = frequency * (1 + (i - 1) * this.musicDNA.detune);
          
          gain.gain.setValueAtTime(0.05, this.audio.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 1);
          
          osc.connect(gain);
          gain.connect(this.audio.destination);
          
          osc.start();
          osc.stop(this.audio.currentTime + 1);
          
          this.oscillators.push(osc);
          this.gainNodes.push(gain);
        }
      }
      
      playAmbientDrone() {
        const osc = this.audio.createOscillator();
        const gain = this.audio.createGain();
        const filter = this.audio.createBiquadFilter();
        
        osc.type = 'triangle';
        osc.frequency.value = this.musicDNA.root * 0.25;
        
        filter.type = 'lowpass';
        filter.frequency.value = 300;
        
        gain.gain.setValueAtTime(0.1, this.audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 4);
        
        osc.connect(filter);
        filter.connect(gain);
        gain.connect(this.audio.destination);
        
        osc.start();
        osc.stop(this.audio.currentTime + 4);
        
        this.oscillators.push(osc);
        this.gainNodes.push(gain);
      }
      
      playBell() {
        const osc = this.audio.createOscillator();
        const gain = this.audio.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = this.musicDNA.root * 2;
        
        gain.gain.setValueAtTime(0.1, this.audio.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.audio.currentTime + 2);
        
        osc.connect(gain);
        gain.connect(this.audio.destination);
        
        osc.start();
        osc.stop(this.audio.currentTime + 2);
        
        this.oscillators.push(osc);
        this.gainNodes.push(gain);
      }
      
      createNoise(duration) {
        const bufferSize = this.audio.sampleRate * duration;
        const buffer = this.audio.createBuffer(1, bufferSize, this.audio.sampleRate);
        const output = buffer.getChannelData(0);
        
        for (let i = 0; i < bufferSize; i++) {
          output[i] = Math.random() * 2 - 1;
        }
        
        const noise = this.audio.createBufferSource();
        noise.buffer = buffer;
        return noise;
      }
      
      cleanup() {
        // Remove finished oscillators
        this.oscillators = this.oscillators.filter(osc => osc.playbackState !== 'finished');
        this.gainNodes = this.gainNodes.filter(gain => gain.context.state === 'running');
      }
      
      updateVisuals() {
        const orb = this.elements.orb;
        orb.className = 'orb';
        
        if (this.mode === 'void') {
          orb.classList.add('void');
          document.body.style.background = 'radial-gradient(ellipse at 60% 50%, #2d1b69 0%, #11051a 80%)';
        } else {
          orb.classList.add('active');
          document.body.style.background = 'radial-gradient(ellipse at 60% 50%, #161826 0%, #0a0c11 80%)';
        }
      }
      
      updateInfo() {
        const timeOfDay = this.weather.isDay ? 
          (this.time.hour < 12 ? 'Morning' : 'Afternoon') : 
          (this.time.hour < 21 ? 'Evening' : 'Night');
        
        const modeText = this.mode === 'void' ? 'Void State' : 'Active';
        const locationText = this.location.city || 'Unknown Location';
        
        const info = `${timeOfDay} · ${this.weather.condition} · ${Math.round(this.weather.temp)}° · ${locationText} · ${modeText}`;
        
        this.elements.info.textContent = info;
        this.elements.info.classList.add('show');
        
        setTimeout(() => {
          this.elements.info.classList.remove('show');
        }, 3000);
      }
    }
    
    // Initialize GUMP when page loads
    document.addEventListener('DOMContentLoaded', () => {
      new GUMP();
    });
  </script>
</body>
</html>
