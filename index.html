<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 2s}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.25);transition:0.5s}
        #enter:hover div{border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.5)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// EMERGENT DELICACY: Silence → One Voice → Layers Build One by One
// "The music must emerge from chaos as the highest probability path to sounding good"

const TAU = Math.PI * 2;

// ============ THE UNIVERSE ============

let ctx, master, verb, dly;
let canvas, vc;
let running = false;

// Field state (cursor position, tilt)
let field = {
    x: 0.5, y: 0.5,      // Normalized position (0-1)
    vx: 0, vy: 0,        // Velocity
    energy: 0,           // Movement energy
    time: 0,
    // PREDICTION: Where we think the user is GOING
    px: 0.5, py: 0.5,    // Predicted position (100ms ahead)
    predictionError: 0,   // How wrong our last prediction was (0-1)
    predictionTension: 0, // Musical tension from wrong predictions
    lastPredictedX: 0.5,  // What we predicted last frame
    lastPredictedY: 0.5,
    // Orb state
    orb: {
        active: false,    // Is an orb currently visible?
        x: 0, y: 0,       // Orb position
        freq: 220,        // Current frequency based on tilt
        predictedFreq: 220, // Where we PREDICT the pitch will be
        startTime: 0,     // When orb spawned
        velocity: 0.3     // How fast orb moves toward center
    }
};

// ============ THE LAYER SYSTEM ============
// Each layer is a recorded loop of pitch + timing
// Layers build ONE BY ONE through user action

const BASE_FREQ = 110; // A2 - foundation frequency
const MAX_LAYERS = 8;  // Maximum concurrent layers

let layers = [];      // Array of recorded layers
let activeVoice = null; // The SINGLE voice that follows tilt (before recording)

// Layer structure:
// {
//   id: number,
//   freq: number,           // The pitch of this layer
//   startTime: number,      // When in the loop it plays
//   loopLength: number,     // How long the loop is (in seconds)
//   osc: OscillatorNode,
//   gain: GainNode,
//   filter: BiquadFilterNode,
//   recorded: boolean,      // Has this been recorded (or still live)?
//   volume: number          // 0-1, decreases with each layer
// }

// ============ MUSIC THEORY: HARMONIC PROBABILITY ============
// New layers should HARMONIZE with existing layers
// The system predicts what will sound GOOD

// Just intonation ratios - these are the "legal" intervals
const CONSONANT_RATIOS = [
    { ratio: 1,     name: 'unison',   consonance: 1.0 },
    { ratio: 2,     name: 'octave',   consonance: 0.95 },
    { ratio: 3/2,   name: 'fifth',    consonance: 0.9 },
    { ratio: 4/3,   name: 'fourth',   consonance: 0.85 },
    { ratio: 5/4,   name: 'maj3',     consonance: 0.8 },
    { ratio: 6/5,   name: 'min3',     consonance: 0.75 },
    { ratio: 5/3,   name: 'maj6',     consonance: 0.7 },
    { ratio: 8/5,   name: 'min6',     consonance: 0.65 },
    { ratio: 9/8,   name: 'maj2',     consonance: 0.5 },
    { ratio: 16/15, name: 'min2',     consonance: 0.3 },
];

// Calculate consonance between two frequencies
function getConsonance(freq1, freq2) {
    let ratio = freq1 > freq2 ? freq1 / freq2 : freq2 / freq1;
    // Normalize to within one octave
    while (ratio > 2) ratio /= 2;

    let bestConsonance = 0.2; // Default dissonance
    for (const interval of CONSONANT_RATIOS) {
        const diff = Math.abs(ratio - interval.ratio);
        if (diff < 0.03) { // Within 3% of a just interval
            bestConsonance = Math.max(bestConsonance, interval.consonance * (1 - diff * 10));
        }
    }
    return bestConsonance;
}

// Calculate how well a new frequency fits with existing layers
function getHarmonicFit(newFreq) {
    if (layers.length === 0) return 1; // First layer always fits

    let totalConsonance = 0;
    for (const layer of layers) {
        totalConsonance += getConsonance(newFreq, layer.freq);
    }
    return totalConsonance / layers.length;
}

// Quantize frequency toward most consonant nearby pitch
function quantizeToHarmony(rawFreq, strength = 0.5) {
    if (layers.length === 0) {
        // No existing layers - quantize to chromatic scale
        const semitone = Math.round(12 * Math.log2(rawFreq / BASE_FREQ));
        const quantizedFreq = BASE_FREQ * Math.pow(2, semitone / 12);
        return rawFreq * (1 - strength) + quantizedFreq * strength;
    }

    // Find the frequency that best fits with existing layers
    let bestFreq = rawFreq;
    let bestFit = getHarmonicFit(rawFreq);

    // Try nearby semitones
    for (let offset = -3; offset <= 3; offset++) {
        const testFreq = rawFreq * Math.pow(2, offset / 12);
        const fit = getHarmonicFit(testFreq);
        if (fit > bestFit) {
            bestFit = fit;
            bestFreq = testFreq;
        }
    }

    // Also try consonant intervals from existing layers
    for (const layer of layers) {
        for (const interval of CONSONANT_RATIOS) {
            // Try above and below
            for (const mult of [interval.ratio, 1 / interval.ratio]) {
                const testFreq = layer.freq * mult;
                // Bring into reasonable range
                while (testFreq < rawFreq * 0.5) testFreq *= 2;
                while (testFreq > rawFreq * 2) testFreq /= 2;

                if (Math.abs(testFreq - rawFreq) < rawFreq * 0.3) {
                    const fit = getHarmonicFit(testFreq);
                    if (fit > bestFit) {
                        bestFit = fit;
                        bestFreq = testFreq;
                    }
                }
            }
        }
    }

    return rawFreq * (1 - strength) + bestFreq * strength;
}

// ============ TILT TO PITCH ============
// Y position (tilt forward/back) controls pitch
// Higher Y = lower pitch (natural: tilt down to go down)

function tiltToFreq(y) {
    // Map Y (0-1) to frequency range
    // Y=0 (top) = high pitch, Y=1 (bottom) = low pitch
    const octaves = 3; // 3 octave range
    const normalizedPitch = 1 - y; // Invert so up = high
    const freq = BASE_FREQ * Math.pow(2, normalizedPitch * octaves);
    return freq;
}

// ============ PREDICTION SYSTEM ============
// The system looks 100ms into the future based on current velocity
// This creates ANTICIPATION - the harmony shifts BEFORE you arrive
// When prediction fails (direction change), it creates musical TENSION

const PREDICTION = {
    LOOKAHEAD_MS: 100,          // How far ahead we predict (ms)
    TENSION_DECAY: 0.92,        // How fast tension decays per frame
    TENSION_THRESHOLD: 0.15,    // Prediction error above this = tension
    ERROR_SMOOTH: 0.3,          // Smoothing for error calculation
    POSITION_SMOOTH: 0.8        // Smoothing for predicted position
};

function updatePrediction(dt) {
    // Calculate how many frames ahead we're predicting
    const framesAhead = (PREDICTION.LOOKAHEAD_MS / 1000) / dt;

    // Raw predicted position based on velocity extrapolation
    const rawPx = field.x + field.vx * framesAhead;
    const rawPy = field.y + field.vy * framesAhead;

    // Clamp to valid range [0, 1]
    const clampedPx = Math.max(0, Math.min(1, rawPx));
    const clampedPy = Math.max(0, Math.min(1, rawPy));

    // Smooth the prediction to avoid jitter
    field.px = field.px * PREDICTION.POSITION_SMOOTH + clampedPx * (1 - PREDICTION.POSITION_SMOOTH);
    field.py = field.py * PREDICTION.POSITION_SMOOTH + clampedPy * (1 - PREDICTION.POSITION_SMOOTH);

    // Calculate prediction error: how wrong was our LAST prediction?
    // Compare where we predicted we'd be vs where we actually are
    const errorX = Math.abs(field.lastPredictedX - field.x);
    const errorY = Math.abs(field.lastPredictedY - field.y);
    const rawError = Math.sqrt(errorX * errorX + errorY * errorY);

    // Smooth the error
    field.predictionError = field.predictionError * (1 - PREDICTION.ERROR_SMOOTH) + rawError * PREDICTION.ERROR_SMOOTH;

    // Build tension when prediction is significantly wrong
    if (field.predictionError > PREDICTION.TENSION_THRESHOLD) {
        const tensionIncrease = (field.predictionError - PREDICTION.TENSION_THRESHOLD) * 0.5;
        field.predictionTension = Math.min(1, field.predictionTension + tensionIncrease);
    }

    // Decay tension over time
    field.predictionTension *= PREDICTION.TENSION_DECAY;

    // Store current prediction for next frame's error calculation
    field.lastPredictedX = field.px;
    field.lastPredictedY = field.py;

    // Update orb's predicted frequency (where we think the note will be)
    field.orb.predictedFreq = tiltToFreq(field.py);
}

// ============ THE SINGLE VOICE ============
// Before recording, there is ONE voice that follows your tilt
// It's delicate, pure, singular

function createActiveVoice() {
    if (activeVoice) return; // Already exists

    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // Pure, delicate sine wave
    osc.type = 'sine';
    osc.frequency.value = BASE_FREQ * 2;

    filter.type = 'lowpass';
    filter.frequency.value = 2000;
    filter.Q.value = 1;

    // Start SILENT - only sound when moving
    gain.gain.value = 0;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    gain.connect(verb.input);

    osc.start();

    activeVoice = { osc, gain, filter, envelope: 0 };
}

function updateActiveVoice() {
    if (!activeVoice || !ctx) return;

    const now = ctx.currentTime;

    // Get frequency from tilt
    const rawFreq = tiltToFreq(field.y);

    // PREDICTION EFFECT: When prediction is confident, quantize more strongly
    // When prediction fails (tension high), allow more raw pitch
    const predictionConfidence = 1 - field.predictionTension;
    const quantizeStrength = Math.min(0.8, layers.length * 0.2) * (0.5 + predictionConfidence * 0.5);
    const freq = quantizeToHarmony(rawFreq, quantizeStrength);

    // Update orb frequency
    field.orb.freq = freq;

    // TENSION EFFECT: Add slight pitch instability when prediction is wrong
    // This makes direction changes sound "surprising" / "tense"
    const tensionWobble = Math.sin(field.time * 30) * field.predictionTension * 0.02;
    const finalFreq = freq * (1 + tensionWobble);

    // Smooth frequency transition
    activeVoice.osc.frequency.linearRampToValueAtTime(finalFreq, now + 0.05);

    // Volume based on movement - stillness = silence, movement = sound
    const targetEnv = Math.min(1, field.energy * 8);
    activeVoice.envelope += (targetEnv - activeVoice.envelope) * 0.1;

    // TENSION EFFECT: Slightly louder when prediction fails (urgency)
    const tensionVolume = 1 + field.predictionTension * 0.3;

    // Delicate volume - QUIET
    const baseVolume = 0.08;
    const volume = baseVolume * activeVoice.envelope * tensionVolume;
    activeVoice.gain.gain.linearRampToValueAtTime(volume, now + 0.03);

    // Filter opens slightly with movement
    // TENSION EFFECT: Filter opens more when prediction fails (brighter, more urgent)
    const tensionFilter = field.predictionTension * 1500;
    const filterFreq = 800 + field.energy * 2000 + tensionFilter;
    activeVoice.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.05);
}

// ============ THE ORB ============
// Visual representation of the sound
// When orb crosses center, that note gets RECORDED as a layer

function updateOrb(dt) {
    if (!field.orb.active) {
        // Spawn orb when there's enough movement
        if (field.energy > 0.02) {
            field.orb.active = true;
            field.orb.x = field.x;
            field.orb.y = field.y;
            field.orb.startTime = field.time;
            field.orb.velocity = 0.2 + field.energy * 0.5;
        }
        return;
    }

    // Orb moves toward center
    const dx = 0.5 - field.orb.x;
    const dy = 0.5 - field.orb.y;
    const dist = Math.sqrt(dx * dx + dy * dy);

    if (dist > 0.01) {
        const moveAmount = field.orb.velocity * dt;
        field.orb.x += (dx / dist) * moveAmount;
        field.orb.y += (dy / dist) * moveAmount;
    }

    // Update orb frequency based on current tilt
    field.orb.freq = tiltToFreq(field.y);

    // Check if orb crossed center
    if (dist < 0.03) {
        recordLayer();
        field.orb.active = false;
    }

    // Orb fades if no movement for too long
    if (field.energy < 0.01 && field.time - field.orb.startTime > 2) {
        field.orb.active = false;
    }
}

// ============ LAYER RECORDING ============
// When orb crosses center, record the current pitch as a new layer

function recordLayer() {
    if (layers.length >= MAX_LAYERS) {
        // Remove oldest layer to make room
        const oldLayer = layers.shift();
        oldLayer.osc.stop();
    }

    // USE PREDICTION: Blend current freq with predicted freq for smarter harmony
    // This means the recorded note anticipates where the user was GOING
    const currentFreq = field.orb.freq;
    const predictedFreq = field.orb.predictedFreq;

    // Blend based on prediction confidence (inverse of tension)
    const predictionConfidence = 1 - field.predictionTension;
    const blendedFreq = currentFreq * (1 - predictionConfidence * 0.3) + predictedFreq * (predictionConfidence * 0.3);

    // Apply stronger harmonic quantization when prediction is confident
    const quantizeStrength = 0.5 + predictionConfidence * 0.3;
    const freq = quantizeToHarmony(blendedFreq, quantizeStrength);

    const now = ctx.currentTime;

    // Calculate loop length based on tempo of orb travel
    // Faster orb = shorter loop
    const travelTime = field.time - field.orb.startTime;
    const loopLength = Math.max(0.5, Math.min(4, travelTime * 2));

    // Create layer audio
    const osc = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    // Vary timbre based on layer number
    const layerNum = layers.length;
    if (layerNum === 0) {
        osc.type = 'sine'; // First layer: pure sine
    } else if (layerNum === 1) {
        osc.type = 'triangle'; // Second: triangle
    } else {
        osc.type = 'sine'; // Rest: sine with slight detune for warmth
    }

    osc.frequency.value = freq;

    filter.type = 'lowpass';
    filter.frequency.value = 1500 + (1 - layerNum / MAX_LAYERS) * 2000;
    filter.Q.value = 0.5;

    // Volume decreases with each layer (prevent clashing)
    const baseVolume = 0.12;
    const volumeScale = Math.pow(0.75, layerNum); // Each layer is 75% of previous
    gain.gain.value = baseVolume * volumeScale;

    osc.connect(filter);
    filter.connect(gain);
    gain.connect(master);
    gain.connect(verb.input);

    osc.start();

    const layer = {
        id: Date.now(),
        freq,
        loopLength,
        osc,
        gain,
        filter,
        volume: baseVolume * volumeScale,
        phase: 0,
        birthTime: field.time
    };

    layers.push(layer);

    // Console feedback for debugging
    console.log(`Layer ${layers.length}: ${freq.toFixed(1)} Hz, loop: ${loopLength.toFixed(2)}s, fit: ${getHarmonicFit(freq).toFixed(2)}`);
}

// ============ LAYER PLAYBACK ============
// Each layer loops with its own timing
// Creates polyrhythmic interweaving

function updateLayers(dt) {
    const now = ctx.currentTime;

    for (const layer of layers) {
        // Update phase (0-1 within loop)
        layer.phase += dt / layer.loopLength;
        if (layer.phase >= 1) layer.phase -= 1;

        // Envelope: note plays at start of loop, then decays
        // Creates rhythmic pulsing
        const envelope = Math.exp(-layer.phase * 4); // Exponential decay
        const sustainedEnvelope = 0.3 + envelope * 0.7; // Never fully silent

        // Apply envelope to volume
        const targetGain = layer.volume * sustainedEnvelope;
        layer.gain.gain.linearRampToValueAtTime(targetGain, now + 0.02);

        // Subtle pitch drift for organic feel
        const drift = Math.sin(field.time * 0.5 + layer.id) * 0.002;
        layer.osc.frequency.linearRampToValueAtTime(layer.freq * (1 + drift), now + 0.1);
    }
}

// ============ REVERB ============

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.25; // Gentle reverb

    const times = [0.03, 0.07, 0.12, 0.19, 0.31, 0.5, 0.81, 1.3, 2.1];
    times.forEach((t, i) => {
        const d = ctx.createDelay(4);
        d.delayTime.value = t + Math.random() * 0.02;
        const g = ctx.createGain();
        g.gain.value = 0.3 * Math.pow(0.75, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 4000 - i * 350;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
        if (i > 4) {
            const fb = ctx.createGain();
            fb.gain.value = 0.15;
            g.connect(fb);
            fb.connect(input);
        }
    });

    return { input, output };
}

// ============ DELAY ============

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.15;

    const delayL = ctx.createDelay(2);
    const delayR = ctx.createDelay(2);
    delayL.delayTime.value = 0.375;
    delayR.delayTime.value = 0.5;

    const fbL = ctx.createGain();
    const fbR = ctx.createGain();
    fbL.gain.value = 0.25;
    fbR.gain.value = 0.2;

    const filterL = ctx.createBiquadFilter();
    const filterR = ctx.createBiquadFilter();
    filterL.type = filterR.type = 'lowpass';
    filterL.frequency.value = filterR.frequency.value = 2000;

    const panL = ctx.createStereoPanner();
    const panR = ctx.createStereoPanner();
    panL.pan.value = -0.7;
    panR.pan.value = 0.7;

    input.connect(delayL);
    delayL.connect(filterL);
    filterL.connect(fbL);
    fbL.connect(delayR);
    delayR.connect(filterR);
    filterR.connect(fbR);
    fbR.connect(delayL);

    filterL.connect(panL);
    filterR.connect(panR);
    panL.connect(output);
    panR.connect(output);

    return { input, output };
}

// ============ INIT ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master = ctx.createGain();
    master.gain.value = 0.8;

    // Light compression for safety
    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -12;
    comp.ratio.value = 4;
    comp.attack.value = 0.003;
    comp.release.value = 0.25;

    verb = createVerb();
    dly = createDelay();

    master.connect(comp);
    comp.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    // Create the single active voice
    createActiveVoice();

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

// ============ INPUT ============

function onMove(nx, ny) {
    nx = Math.max(0, Math.min(1, nx));
    ny = Math.max(0, Math.min(1, ny));

    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = field.x * 0.7 + nx * 0.3;
    field.y = field.y * 0.7 + ny * 0.3;

    const speed = Math.sqrt(field.vx * field.vx + field.vy * field.vy);
    field.energy = field.energy * 0.9 + speed * 0.5;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const rawAx = (a.x || 0) / 8;
    const rawAy = (a.y || 0) / 8;

    field.vx = field.vx * 0.7 + rawAx * 0.3;
    field.vy = field.vy * 0.7 + rawAy * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.1));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.1));

    field.energy = field.energy * 0.9 + Math.sqrt(rawAx * rawAx + rawAy * rawAy) * 0.3;
}

function onOrientation(e) {
    const gx = Math.max(-1, Math.min(1, (e.gamma || 0) / 40));
    const gy = Math.max(-1, Math.min(1, (e.beta || 0) / 40 - 1));
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ VISUALIZATION ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;

    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = w + 'px';
    canvas.style.height = h + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Dark fade
    vc.fillStyle = 'rgba(0, 0, 0, 0.08)';
    vc.fillRect(0, 0, w, h);

    // Center crosshair (subtle target for orb)
    const centerAlpha = 0.1 + (field.orb.active ? 0.15 : 0);
    vc.strokeStyle = `rgba(255, 255, 255, ${centerAlpha})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.moveTo(w / 2 - 20, h / 2);
    vc.lineTo(w / 2 + 20, h / 2);
    vc.moveTo(w / 2, h / 2 - 20);
    vc.lineTo(w / 2, h / 2 + 20);
    vc.stroke();

    // Draw layers as concentric rings at center
    for (let i = 0; i < layers.length; i++) {
        const layer = layers[i];
        const pulse = Math.exp(-layer.phase * 3);
        const radius = 30 + i * 25 + pulse * 15;
        const alpha = 0.15 + pulse * 0.25;

        // Color based on frequency (higher = bluer, lower = warmer)
        const freqRatio = Math.log2(layer.freq / BASE_FREQ);
        const hue = 200 + freqRatio * 30; // Blue-ish range

        vc.beginPath();
        vc.arc(w / 2, h / 2, radius, 0, TAU);
        vc.strokeStyle = `hsla(${hue}, 50%, 60%, ${alpha})`;
        vc.lineWidth = 2 + pulse * 3;
        vc.stroke();
    }

    // Draw the orb (if active)
    if (field.orb.active) {
        const ox = field.orb.x * w;
        const oy = field.orb.y * h;
        const orbRadius = 8 + field.energy * 15;

        // Frequency-based color
        const freqRatio = Math.log2(field.orb.freq / BASE_FREQ);
        const hue = 200 + freqRatio * 30;

        // Orb glow
        const grad = vc.createRadialGradient(ox, oy, 0, ox, oy, orbRadius * 2);
        grad.addColorStop(0, `hsla(${hue}, 70%, 80%, 0.9)`);
        grad.addColorStop(0.5, `hsla(${hue}, 60%, 60%, 0.4)`);
        grad.addColorStop(1, 'transparent');

        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(ox, oy, orbRadius * 2, 0, TAU);
        vc.fill();

        // Core
        vc.fillStyle = `hsla(${hue}, 80%, 90%, 1)`;
        vc.beginPath();
        vc.arc(ox, oy, orbRadius * 0.5, 0, TAU);
        vc.fill();

        // Trail toward center
        vc.strokeStyle = `hsla(${hue}, 50%, 60%, 0.3)`;
        vc.lineWidth = 1;
        vc.beginPath();
        vc.moveTo(ox, oy);
        vc.lineTo(w / 2, h / 2);
        vc.stroke();
    }

    // PREDICTION GHOST: Show where the system thinks you're going
    // Only visible when moving and prediction differs from current position
    const predictionDist = Math.sqrt(
        Math.pow(field.px - field.x, 2) + Math.pow(field.py - field.y, 2)
    );

    if (predictionDist > 0.02 && field.energy > 0.02) {
        const predX = field.px * w;
        const predY = field.py * h;
        const predRadius = 8 + field.energy * 10;

        // Line from current to predicted
        vc.strokeStyle = `rgba(100, 180, 255, ${0.2 + field.energy * 0.3})`;
        vc.lineWidth = 1;
        vc.setLineDash([4, 4]);
        vc.beginPath();
        vc.moveTo(field.x * w, field.y * h);
        vc.lineTo(predX, predY);
        vc.stroke();
        vc.setLineDash([]);

        // Prediction ghost dot
        const ghostGrad = vc.createRadialGradient(predX, predY, 0, predX, predY, predRadius);
        ghostGrad.addColorStop(0, `rgba(100, 180, 255, ${0.3 + field.energy * 0.4})`);
        ghostGrad.addColorStop(0.5, `rgba(100, 180, 255, ${0.1})`);
        ghostGrad.addColorStop(1, 'transparent');

        vc.fillStyle = ghostGrad;
        vc.beginPath();
        vc.arc(predX, predY, predRadius, 0, TAU);
        vc.fill();
    }

    // TENSION RING: Red flash when prediction is wrong (direction change)
    if (field.predictionTension > 0.1) {
        const cx = field.x * w;
        const cy = field.y * h;
        const tensionRadius = 30 + field.predictionTension * 40;
        const tensionAlpha = field.predictionTension * 0.4;

        vc.strokeStyle = `rgba(255, 100, 100, ${tensionAlpha})`;
        vc.lineWidth = 2;
        vc.beginPath();
        vc.arc(cx, cy, tensionRadius, 0, TAU);
        vc.stroke();
    }

    // Cursor (follows tilt)
    const cx = field.x * w;
    const cy = field.y * h;
    const cursorRadius = 5 + field.energy * 20;

    const cursorGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, cursorRadius);
    cursorGrad.addColorStop(0, `rgba(255, 255, 255, ${0.3 + field.energy * 0.5})`);
    cursorGrad.addColorStop(1, 'transparent');

    vc.fillStyle = cursorGrad;
    vc.beginPath();
    vc.arc(cx, cy, cursorRadius, 0, TAU);
    vc.fill();

    // Layer count
    if (layers.length > 0) {
        vc.fillStyle = 'rgba(255, 255, 255, 0.3)';
        vc.font = '10px system-ui';
        vc.textAlign = 'left';
        vc.fillText(`${layers.length} layer${layers.length > 1 ? 's' : ''}`, 20, 25);
    }

    // Current pitch indicator
    const freqRatio = Math.log2(field.orb.freq / BASE_FREQ);
    const noteName = getNoteName(field.orb.freq);
    vc.fillStyle = `rgba(255, 255, 255, ${0.1 + field.energy * 0.3})`;
    vc.font = '12px system-ui';
    vc.textAlign = 'center';
    vc.fillText(noteName, w / 2, h - 30);

    // Harmonic fit indicator (when moving)
    if (field.energy > 0.02 && layers.length > 0) {
        const fit = getHarmonicFit(field.orb.freq);
        const fitColor = fit > 0.7 ? '120, 255, 150' : fit > 0.5 ? '255, 220, 100' : '255, 100, 100';
        vc.fillStyle = `rgba(${fitColor}, ${0.3 + fit * 0.4})`;
        vc.font = '9px system-ui';
        vc.fillText(fit > 0.7 ? 'consonant' : fit > 0.5 ? 'tension' : 'dissonant', w / 2, h - 15);
    }

    // PREDICTION indicator (top right)
    if (field.energy > 0.01) {
        const predictionConfidence = 1 - field.predictionTension;
        const confColor = predictionConfidence > 0.7 ? '100, 180, 255' : predictionConfidence > 0.4 ? '255, 180, 100' : '255, 100, 100';
        vc.fillStyle = `rgba(${confColor}, ${0.3 + field.energy * 0.3})`;
        vc.font = '9px system-ui';
        vc.textAlign = 'right';

        if (field.predictionTension > 0.3) {
            vc.fillText('surprise!', w - 20, 25);
        } else if (predictionConfidence > 0.7 && field.energy > 0.05) {
            vc.fillText('predicting...', w - 20, 25);
        }
        vc.textAlign = 'center'; // Reset
    }
}

// Convert frequency to note name (approximate)
function getNoteName(freq) {
    const noteNames = ['A', 'A#', 'B', 'C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#'];
    const semitones = Math.round(12 * Math.log2(freq / 110)); // A2 = 110Hz
    const noteIndex = ((semitones % 12) + 12) % 12;
    const octave = Math.floor(semitones / 12) + 2;
    return noteNames[noteIndex] + octave;
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    const dt = 0.016; // ~60fps
    field.time += dt;

    // Update PREDICTION first - this informs everything else
    updatePrediction(dt);

    // Update orb physics
    updateOrb(dt);

    // Update active voice (follows tilt, affected by prediction tension)
    updateActiveVoice();

    // Update recorded layers
    updateLayers(dt);

    // Draw
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
