<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 2s}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.25);transition:0.5s}
        #enter:hover div{border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.5)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// Life. Birth. Death. Memory. Time emerging from relationship.

const TAU = Math.PI * 2;
const PHI = 1.618033988749;

// ============ THE UNIVERSE ============

let ctx, master, verb, dly, sub;
let entities = [];
let ghosts = []; // Fading entities
let memory = []; // Pattern memory
let field = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    energy: 0,
    time: 0,
    pulse: 0,        // Emergent rhythm
    stillness: 0,    // Accumulated stillness
    gestureAngle: 0, // For detecting circles
    lastGesture: 0,
    breath: 0,       // Cosmic breath - slow oscillation
    breathPhase: 0,  // Phase of the breath cycle
    depth: 0,        // How deep into stillness we've gone
    constellations: [] // Stable harmonic formations
};
let canvas, vc;
let running = false;

// ============ GESTURE RECOGNITION ============

const GESTURE_BUFFER_MS = 500;
const GESTURE_SAMPLE_RATE = 60; // ~16ms per sample
const GESTURE_BUFFER_SIZE = Math.ceil(GESTURE_BUFFER_MS / (1000 / GESTURE_SAMPLE_RATE));

let gestureBuffer = [];
let lastGestureTime = 0;
let currentGesture = null;

// Gesture thresholds (tuned through experimentation)
const GESTURE_THRESHOLDS = {
    SHAKE_ENERGY: 0.15,      // Minimum energy for shake
    SHAKE_REVERSALS: 3,      // Minimum direction changes for shake
    SWIPE_VELOCITY: 0.08,    // Minimum velocity for swipe
    SWIPE_LINEARITY: 0.7,    // How straight the path must be (0-1)
    TAP_DURATION: 150,       // Max ms for a tap
    HOLD_DURATION: 400,      // Min ms for a hold
    CIRCLE_ROTATION: Math.PI * 1.5, // Min radians for circle
    COOLDOWN: 200            // Min ms between gesture detections
};

function addGestureSample(x, y, vx, vy, ax, ay) {
    const now = performance.now();

    gestureBuffer.push({
        time: now,
        x, y,
        vx, vy,
        ax, ay,
        energy: Math.sqrt(vx*vx + vy*vy),
        angle: Math.atan2(vy, vx)
    });

    // Trim old samples
    while (gestureBuffer.length > 0 &&
           now - gestureBuffer[0].time > GESTURE_BUFFER_MS) {
        gestureBuffer.shift();
    }
}

function detectGesture() {
    if (gestureBuffer.length < 5) return null;

    const now = performance.now();
    if (now - lastGestureTime < GESTURE_THRESHOLDS.COOLDOWN) return null;

    const buffer = gestureBuffer;
    const duration = buffer[buffer.length - 1].time - buffer[0].time;

    // Calculate aggregate metrics
    let totalEnergy = 0;
    let maxEnergy = 0;
    let directionReversals = 0;
    let totalRotation = 0;
    let prevAngle = buffer[0].angle;

    // Track start and end positions for swipe detection
    const startX = buffer[0].x;
    const startY = buffer[0].y;
    const endX = buffer[buffer.length - 1].x;
    const endY = buffer[buffer.length - 1].y;
    const displacement = Math.sqrt((endX - startX)**2 + (endY - startY)**2);

    // Track path length for linearity
    let pathLength = 0;

    for (let i = 1; i < buffer.length; i++) {
        const sample = buffer[i];
        const prev = buffer[i - 1];

        totalEnergy += sample.energy;
        maxEnergy = Math.max(maxEnergy, sample.energy);

        // Path length
        pathLength += Math.sqrt((sample.x - prev.x)**2 + (sample.y - prev.y)**2);

        // Direction reversals (for shake detection)
        const dotProduct = sample.vx * prev.vx + sample.vy * prev.vy;
        if (dotProduct < -0.001 && prev.energy > 0.02 && sample.energy > 0.02) {
            directionReversals++;
        }

        // Total rotation (for circle detection)
        let angleDiff = sample.angle - prevAngle;
        // Normalize to -PI to PI
        while (angleDiff > Math.PI) angleDiff -= 2 * Math.PI;
        while (angleDiff < -Math.PI) angleDiff += 2 * Math.PI;
        totalRotation += angleDiff;
        prevAngle = sample.angle;
    }

    const avgEnergy = totalEnergy / buffer.length;
    const linearity = pathLength > 0.001 ? displacement / pathLength : 0;

    // ============ GESTURE CLASSIFICATION ============

    // SHAKE: High energy with multiple direction reversals
    if (avgEnergy > GESTURE_THRESHOLDS.SHAKE_ENERGY &&
        directionReversals >= GESTURE_THRESHOLDS.SHAKE_REVERSALS) {
        lastGestureTime = now;
        return {
            type: 'SHAKE',
            intensity: Math.min(1, avgEnergy / 0.3),
            reversals: directionReversals
        };
    }

    // CIRCLE: Accumulated rotation exceeds threshold
    if (Math.abs(totalRotation) > GESTURE_THRESHOLDS.CIRCLE_ROTATION &&
        avgEnergy > 0.02) {
        lastGestureTime = now;
        return {
            type: 'CIRCLE',
            direction: totalRotation > 0 ? 'CW' : 'CCW',
            rotations: Math.abs(totalRotation) / (2 * Math.PI)
        };
    }

    // SWIPE: Fast, linear movement
    if (avgEnergy > GESTURE_THRESHOLDS.SWIPE_VELOCITY &&
        linearity > GESTURE_THRESHOLDS.SWIPE_LINEARITY &&
        displacement > 0.1) {
        lastGestureTime = now;
        const angle = Math.atan2(endY - startY, endX - startX);
        let direction;
        if (angle > -Math.PI/4 && angle <= Math.PI/4) direction = 'RIGHT';
        else if (angle > Math.PI/4 && angle <= 3*Math.PI/4) direction = 'DOWN';
        else if (angle > -3*Math.PI/4 && angle <= -Math.PI/4) direction = 'UP';
        else direction = 'LEFT';

        return {
            type: 'SWIPE',
            direction,
            velocity: avgEnergy,
            distance: displacement
        };
    }

    // HOLD: Low energy for extended duration
    if (avgEnergy < 0.01 && duration > GESTURE_THRESHOLDS.HOLD_DURATION) {
        // Only fire hold once per stillness period
        if (!currentGesture || currentGesture.type !== 'HOLD') {
            lastGestureTime = now;
            return {
                type: 'HOLD',
                duration: duration,
                position: { x: endX, y: endY }
            };
        }
    }

    return null;
}

function onGestureDetected(gesture) {
    // Store for external access
    currentGesture = gesture;
    field.lastGesture = field.time;

    // Musical responses will be added here
    // For now, log to help with tuning
    console.log('Gesture:', gesture.type, gesture);

    // Visual feedback - pulse the cursor
    field.energy = Math.max(field.energy, gesture.intensity || 0.3);
}

// All possible harmonic ratios - the DNA pool
const ALL_RATIOS = [
    1, 16/15, 9/8, 6/5, 5/4, 4/3, 45/32, 3/2, 8/5, 5/3, 9/5, 15/8,
    2, 9/4, 12/5, 5/2, 8/3, 3, 16/5, 10/3, 15/4, 4, 9/2, 5, 6, 8
];

const BASE = 55;
const MAX_ENTITIES = 24;
const MIN_ENTITIES = 5;

// Consonance - the gravity of music
function consonance(r1, r2) {
    let ratio = r1 > r2 ? r1/r2 : r2/r1;
    // Normalize to one octave
    while (ratio > 2) ratio /= 2;

    if (Math.abs(ratio - 1) < 0.01) return 1;
    if (Math.abs(ratio - 2) < 0.01) return 0.95;
    if (Math.abs(ratio - 1.5) < 0.01) return 0.9;
    if (Math.abs(ratio - 4/3) < 0.02) return 0.85;
    if (Math.abs(ratio - 5/4) < 0.02) return 0.75;
    if (Math.abs(ratio - 6/5) < 0.02) return 0.7;
    if (Math.abs(ratio - 5/3) < 0.02) return 0.65;
    if (Math.abs(ratio - 8/5) < 0.02) return 0.6;
    return 0.3;
}

// Harmonic regions - different areas favor different modes
function getRegionalMode(x, y) {
    // Center = pure/Ionian, edges = more color
    const distFromCenter = Math.sqrt((x-0.5)**2 + (y-0.5)**2);
    const angle = Math.atan2(y - 0.5, x - 0.5);

    // Different corners = different modes
    // Top-right: Lydian (bright)
    // Bottom-right: Mixolydian (bluesy)
    // Bottom-left: Dorian (dark)
    // Top-left: Phrygian (exotic)

    const modeInfluence = Math.min(1, distFromCenter * 2);
    let ratioBonus = {};

    if (angle > 0 && angle < Math.PI/2) { // Top-right: Lydian
        ratioBonus = { [45/32]: 0.3, [15/8]: 0.2 }; // #4, maj7
    } else if (angle >= Math.PI/2) { // Top-left: Phrygian
        ratioBonus = { [16/15]: 0.3, [8/5]: 0.2 }; // b2, b6
    } else if (angle < -Math.PI/2) { // Bottom-left: Dorian
        ratioBonus = { [6/5]: 0.2, [9/5]: 0.2 }; // min3, min7
    } else { // Bottom-right: Mixolydian
        ratioBonus = { [9/5]: 0.3, [5/4]: 0.2 }; // b7, maj3
    }

    return { influence: modeInfluence, bonus: ratioBonus };
}

// ============ ENTITY - A LIVING HARMONIC ============

let entityId = 0;

class Entity {
    constructor(ratio, x, y) {
        this.id = entityId++;
        this.ratio = ratio;
        this.freq = BASE * ratio;

        this.x = x !== undefined ? x : 0.5 + (Math.random() - 0.5) * 0.4;
        this.y = y !== undefined ? y : 0.5 + (Math.random() - 0.5) * 0.4;
        this.vx = (Math.random() - 0.5) * 0.005;
        this.vy = (Math.random() - 0.5) * 0.005;

        this.mass = 1 / Math.sqrt(ratio);
        this.life = 1;
        this.age = 0;
        this.lastVisit = 0; // When cursor was last near
        this.brightness = 0;

        // Synchronization
        this.phase = Math.random() * TAU;
        this.syncPhase = 0;
        this.neighbors = [];

        // Audio nodes
        this.osc = null;
        this.osc2 = null;
        this.filter = null;
        this.gain = null;
        this.pan = null;
        this.mod = null;
        this.modGain = null;

        // Visual
        this.trail = [];
        this.maxTrail = 40;
        this.hue = (180 - Math.log2(ratio) * 60 + 360) % 360;
        this.birthTime = field.time;
    }

    createAudio() {
        this.osc = ctx.createOscillator();
        this.osc.type = this.ratio < 2 ? 'sine' : (this.ratio < 4 ? 'triangle' : 'sine');
        this.osc.frequency.value = this.freq;

        this.osc2 = ctx.createOscillator();
        this.osc2.type = 'sine';
        this.osc2.frequency.value = this.freq * 1.003;

        this.mod = ctx.createOscillator();
        this.modGain = ctx.createGain();
        this.mod.type = 'sine';
        this.mod.frequency.value = this.freq * PHI;
        this.modGain.gain.value = 0;
        this.mod.connect(this.modGain);
        this.modGain.connect(this.osc.frequency);

        this.filter = ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 200;
        this.filter.Q.value = 1;

        this.gain = ctx.createGain();
        this.gain.gain.value = 0;

        this.pan = ctx.createStereoPanner();

        this.osc.connect(this.filter);
        this.osc2.connect(this.filter);
        this.filter.connect(this.gain);
        this.gain.connect(this.pan);
        this.pan.connect(master);
        this.pan.connect(verb.input);
        this.pan.connect(dly.input);

        this.osc.start();
        this.osc2.start();
        this.mod.start();
    }

    destroy() {
        const now = ctx.currentTime;
        this.gain.gain.linearRampToValueAtTime(0, now + 0.5);
        setTimeout(() => {
            this.osc.stop();
            this.osc2.stop();
            this.mod.stop();
        }, 600);
    }

    update(dt) {
        const now = ctx.currentTime;
        this.age += dt;

        // ============ LIFE AND DEATH ============

        const dx = field.x - this.x;
        const dy = field.y - this.y;
        const distToCursor = Math.sqrt(dx*dx + dy*dy);

        // Being near cursor sustains life
        if (distToCursor < 0.2) {
            this.lastVisit = field.time;
            this.life = Math.min(1, this.life + dt * 0.5);
        }

        // Neglect causes fading
        const timeSinceVisit = field.time - this.lastVisit;
        if (timeSinceVisit > 5) {
            this.life -= dt * 0.05 * (timeSinceVisit - 5);
        }

        // Young entities are fragile
        if (this.age < 2) {
            this.life = Math.min(this.life, this.age / 2);
        }

        // ============ PHYSICS ============

        const cursorForce = 0.0004 / (distToCursor + 0.1);
        this.vx += dx * cursorForce;
        this.vy += dy * cursorForce;

        // Inter-entity forces
        this.neighbors = [];
        for (const other of entities) {
            if (other === this || other.life <= 0) continue;

            const odx = other.x - this.x;
            const ody = other.y - this.y;
            const dist = Math.sqrt(odx*odx + ody*ody);
            if (dist < 0.01 || dist > 0.4) continue;

            const cons = consonance(this.ratio, other.ratio);
            const force = (cons - 0.35) * 0.00004 / (dist + 0.03);

            this.vx += odx * force;
            this.vy += ody * force;

            if (dist < 0.15 && cons > 0.6) {
                this.neighbors.push(other);
            }
        }

        // Center gravity
        this.vx += (0.5 - this.x) * 0.00015;
        this.vy += (0.5 - this.y) * 0.00015;

        // Angular momentum from cursor
        this.vx += -dy * field.vx * 0.015;
        this.vy += dx * field.vy * 0.015;

        // Regional mode influence on movement
        const mode = getRegionalMode(this.x, this.y);
        if (mode.bonus[this.ratio]) {
            // This entity belongs here - slow down, settle
            this.vx *= 0.98;
            this.vy *= 0.98;
        }

        this.vx *= 0.994;
        this.vy *= 0.994;

        this.x += this.vx;
        this.y += this.vy;

        // Soft boundaries
        if (this.x < 0.03) { this.x = 0.03; this.vx *= -0.5; }
        if (this.x > 0.97) { this.x = 0.97; this.vx *= -0.5; }
        if (this.y < 0.03) { this.y = 0.03; this.vy *= -0.5; }
        if (this.y > 0.97) { this.y = 0.97; this.vy *= -0.5; }

        // Trail
        this.trail.unshift({ x: this.x, y: this.y, life: this.life });
        if (this.trail.length > this.maxTrail) this.trail.pop();

        // ============ SYNCHRONIZATION ============

        // Phase advances based on frequency (creates natural rhythm)
        this.phase += dt * (this.freq / BASE) * 0.5;

        // Sync with neighbors
        if (this.neighbors.length > 0) {
            let avgPhase = 0;
            for (const n of this.neighbors) {
                avgPhase += n.phase;
            }
            avgPhase /= this.neighbors.length;

            // Gently pull toward average phase
            const phaseDiff = avgPhase - this.phase;
            this.phase += phaseDiff * 0.02;
        }

        this.syncPhase = (Math.sin(this.phase) + 1) / 2; // 0-1 pulse

        // ============ SOUND ============

        const proximity = 1 - Math.min(1, distToCursor * 2.5);
        const vel = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        this.brightness = this.brightness * 0.92 + vel * 8;

        // Amplitude: proximity + sync pulse + life + breath in deep states
        const syncPulse = this.neighbors.length > 0 ? this.syncPhase * 0.3 : 0;
        const breathBonus = field.depth * field.breath * 0.02;
        const baseAmp = (proximity * 0.08 + syncPulse * 0.04 + breathBonus) * this.mass * this.life;

        this.gain.gain.linearRampToValueAtTime(baseAmp * (0.6 + this.brightness * 0.5), now + 0.06);

        // Filter - opens more in deep states, modulated by breath
        const depthFilter = field.depth * 400 * (0.5 + field.breath * 0.5);
        const filterFreq = 150 + proximity * 2500 + this.brightness * 2000 + this.syncPhase * 500 + depthFilter;
        this.filter.frequency.linearRampToValueAtTime(filterFreq * this.life, now + 0.08);

        // FM from energy
        const fmDepth = field.energy * this.freq * 0.4 + this.syncPhase * this.freq * 0.1;
        this.modGain.gain.linearRampToValueAtTime(fmDepth, now + 0.05);

        // Pan - narrower in deep states for intimacy
        const panWidth = 1.6 - field.depth * 0.8;
        this.pan.pan.linearRampToValueAtTime((this.x - 0.5) * panWidth, now + 0.05);

        // Pitch bend toward cursor - gentler in deep states
        const bendAmount = 0.015 * (1 - field.depth * 0.5);
        const bend = 1 + dx * bendAmount;
        this.osc.frequency.linearRampToValueAtTime(this.freq * bend, now + 0.1);
        this.osc2.frequency.linearRampToValueAtTime(this.freq * bend * 1.003, now + 0.1);
    }

    draw() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const px = this.x * w;
        const py = this.y * h;

        if (this.life <= 0) return;

        const amp = this.gain.gain.value;
        const alpha = this.life;

        // Trail
        if (this.trail.length > 1 && amp > 0.001) {
            vc.beginPath();
            vc.moveTo(this.trail[0].x * w, this.trail[0].y * h);
            for (let i = 1; i < this.trail.length; i++) {
                vc.lineTo(this.trail[i].x * w, this.trail[i].y * h);
            }
            vc.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${amp * alpha * 0.4})`;
            vc.lineWidth = 1 + amp * 2;
            vc.stroke();
        }

        // Sync pulse ring
        if (this.neighbors.length > 0) {
            const pulseR = 10 + this.syncPhase * 30;
            vc.beginPath();
            vc.arc(px, py, pulseR, 0, TAU);
            vc.strokeStyle = `hsla(${this.hue}, 60%, 70%, ${this.syncPhase * amp * alpha * 0.5})`;
            vc.lineWidth = 2;
            vc.stroke();
        }

        // Core
        const r = 3 + amp * 35 + this.brightness * 15;
        const grad = vc.createRadialGradient(px, py, 0, px, py, r);
        grad.addColorStop(0, `hsla(${this.hue}, 85%, ${75 + amp * 20}%, ${(0.9 + amp * 0.1) * alpha})`);
        grad.addColorStop(0.5, `hsla(${this.hue}, 70%, 50%, ${amp * 0.6 * alpha})`);
        grad.addColorStop(1, 'transparent');

        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(px, py, r, 0, TAU);
        vc.fill();

        // Birth glow
        if (this.age < 1) {
            const birthGlow = (1 - this.age) * 0.5;
            const birthR = r + 20 * (1 - this.age);
            vc.beginPath();
            vc.arc(px, py, birthR, 0, TAU);
            vc.strokeStyle = `hsla(${this.hue}, 90%, 80%, ${birthGlow})`;
            vc.lineWidth = 3;
            vc.stroke();
        }

        // Ancestral glow - reborn souls carry a golden shimmer
        if (this.ancestralGlow && this.ancestralGlow > 0.1) {
            const ancestralR = r + 15;
            const shimmer = 0.5 + Math.sin(field.time * 3 + this.id) * 0.5;
            vc.beginPath();
            vc.arc(px, py, ancestralR, 0, TAU);
            vc.strokeStyle = `hsla(45, 80%, 70%, ${this.ancestralGlow * shimmer * alpha * 0.5})`;
            vc.lineWidth = 2;
            vc.stroke();

            // Fade the ancestral connection over time
            this.ancestralGlow *= 0.9995;
        }
    }
}

// ============ ANCESTRAL MEMORY ============

function findAncestor(x, y) {
    // Search recent deaths near this location
    for (let i = memory.length - 1; i >= 0; i--) {
        const m = memory[i];
        if (m.type !== 'death') continue;

        const dx = m.x - x;
        const dy = m.y - y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const age = field.time - m.time;

        // Closer and more recent = stronger connection
        if (dist < 0.15 && age < 30) {
            return {
                ratio: m.ratio,
                strength: (1 - dist / 0.15) * (1 - age / 30),
                x: m.x,
                y: m.y
            };
        }
    }
    return null;
}

// ============ BIRTH ============

function birthEntity() {
    if (entities.length >= MAX_ENTITIES) return;

    // Choose ratio based on existing harmonics and regional mode
    const mode = getRegionalMode(field.x, field.y);

    // Check for ancestral influence
    const ancestor = findAncestor(field.x, field.y);

    // Prefer ratios consonant with existing entities
    let bestRatio = ALL_RATIOS[Math.floor(Math.random() * ALL_RATIOS.length)];
    let bestScore = 0;

    for (const ratio of ALL_RATIOS) {
        let score = Math.random() * 0.3; // Base randomness

        // Bonus for regional mode
        if (mode.bonus[ratio]) {
            score += mode.bonus[ratio] * mode.influence;
        }

        // Bonus for consonance with existing
        for (const e of entities) {
            if (e.life > 0.5) {
                score += consonance(ratio, e.ratio) * 0.1;
            }
        }

        // Ancestral echo - favor harmonics of the departed
        if (ancestor) {
            const ancestralCons = consonance(ratio, ancestor.ratio);
            score += ancestralCons * ancestor.strength * 0.5;
            // Strong pull toward the exact same ratio
            if (Math.abs(ratio - ancestor.ratio) < 0.01) {
                score += ancestor.strength * 0.8;
            }
        }

        // Penalty for duplicates
        for (const e of entities) {
            if (Math.abs(e.ratio - ratio) < 0.01) {
                score -= 0.5;
            }
        }

        if (score > bestScore) {
            bestScore = score;
            bestRatio = ratio;
        }
    }

    const entity = new Entity(bestRatio, field.x + (Math.random()-0.5)*0.1, field.y + (Math.random()-0.5)*0.1);
    entity.createAudio();
    entity.lastVisit = field.time;

    // Mark if this is a reborn soul
    if (ancestor && consonance(bestRatio, ancestor.ratio) > 0.8) {
        entity.ancestralGlow = ancestor.strength;
        entity.ancestorRatio = ancestor.ratio;
    }

    entities.push(entity);

    // Memory: record the birth
    memory.push({
        type: 'birth',
        ratio: bestRatio,
        x: field.x,
        y: field.y,
        time: field.time,
        hadAncestor: ancestor !== null
    });
    if (memory.length > 150) memory.shift();
}

// ============ DEATH ============

function processDeath() {
    for (let i = entities.length - 1; i >= 0; i--) {
        const e = entities[i];
        if (e.life <= 0) {
            e.destroy();

            // Create ghost for visual fade
            ghosts.push({
                x: e.x, y: e.y,
                hue: e.hue,
                alpha: 0.5,
                radius: 20
            });

            // Memory: record the death
            memory.push({
                type: 'death',
                ratio: e.ratio,
                x: e.x,
                y: e.y,
                time: field.time
            });

            entities.splice(i, 1);
        }
    }

    // Fade ghosts
    for (let i = ghosts.length - 1; i >= 0; i--) {
        ghosts[i].alpha -= 0.01;
        ghosts[i].radius += 0.5;
        if (ghosts[i].alpha <= 0) {
            ghosts.splice(i, 1);
        }
    }

    // Ensure minimum population
    if (entities.length < MIN_ENTITIES && field.time > 2) {
        birthEntity();
    }
}

// ============ CONNECTIONS ============

function drawConnections() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    for (let i = 0; i < entities.length; i++) {
        const a = entities[i];
        if (a.life <= 0) continue;

        for (let j = i + 1; j < entities.length; j++) {
            const b = entities[j];
            if (b.life <= 0) continue;

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 0.25) continue;

            const cons = consonance(a.ratio, b.ratio);
            if (cons < 0.65) continue;

            const amp = Math.min(a.gain.gain.value, b.gain.gain.value);
            const life = Math.min(a.life, b.life);
            const alpha = cons * amp * (1 - dist / 0.25) * life * 2;

            if (alpha < 0.02) continue;

            // Pulsing connection
            const pulse = (Math.sin((a.phase + b.phase) / 2) + 1) / 2;

            vc.beginPath();
            vc.moveTo(a.x * w, a.y * h);
            vc.lineTo(b.x * w, b.y * h);
            vc.strokeStyle = `rgba(255, 255, 255, ${alpha * (0.7 + pulse * 0.3)})`;
            vc.lineWidth = 1 + cons * pulse * 3;
            vc.stroke();
        }
    }
}

// ============ SUB BASS ============

function createSub() {
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.value = BASE / 2;
    osc2.type = 'sine';
    osc2.frequency.value = BASE / 2 * 1.002;

    filter.type = 'lowpass';
    filter.frequency.value = 80;
    gain.gain.value = 0;

    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    osc.start();
    osc2.start();

    sub = { osc, osc2, gain, filter };
}

function updateSub() {
    const now = ctx.currentTime;

    // Global pulse from synchronized entities
    let globalPulse = 0;
    let syncCount = 0;

    for (const e of entities) {
        if (e.neighbors.length > 0 && e.life > 0.5) {
            globalPulse += e.syncPhase;
            syncCount++;
        }
    }

    if (syncCount > 0) {
        globalPulse /= syncCount;
        field.pulse = field.pulse * 0.9 + globalPulse * 0.1;
    }

    // Sub amplitude - breathes with the cosmos in deep states
    const baseAmp = 0.12 + field.stillness * 0.08;
    const pulseAmp = field.pulse * 0.1;
    const breathAmp = field.depth * field.breath * 0.08;
    const constellationBonus = field.constellations.length * 0.02;
    sub.gain.gain.linearRampToValueAtTime(
        Math.min(0.35, baseAmp + pulseAmp + breathAmp + constellationBonus),
        now + 0.1
    );

    // Sub frequency follows center of mass
    let cx = 0, cy = 0, total = 0;
    for (const e of entities) {
        if (e.life > 0) {
            cx += e.x * e.mass;
            cy += e.y * e.mass;
            total += e.mass;
        }
    }
    if (total > 0) {
        cy /= total;
        // In deep states, the breath modulates the sub frequency
        const breathBend = 1 + field.depth * field.breath * 0.03;
        const subFreq = (BASE / 2) * (1 - (cy - 0.5) * 0.2) * breathBend;
        sub.osc.frequency.linearRampToValueAtTime(subFreq, now + 0.2);
        sub.osc2.frequency.linearRampToValueAtTime(subFreq * 1.002, now + 0.2);
    }

    // Filter opens in deep states
    const filterFreq = 80 + field.depth * 60 + field.breath * field.depth * 40;
    sub.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.15);
}

// ============ EFFECTS ============

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.35;
    const baseGain = 0.35;

    const times = [0.02, 0.05, 0.08, 0.13, 0.21, 0.34, 0.55, 0.89, 1.2, 1.6, 2.1, 2.8];
    times.forEach((t, i) => {
        const d = ctx.createDelay(4);
        d.delayTime.value = t + Math.random() * 0.015;
        const g = ctx.createGain();
        g.gain.value = 0.28 * Math.pow(0.77, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 5500 - i * 400;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
        if (i > 5) {
            const fb = ctx.createGain();
            fb.gain.value = 0.1;
            g.connect(fb);
            fb.connect(input);
        }
    });

    return { input, output, baseGain };
}

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.22;
    const baseGain = 0.22;

    const delayL = ctx.createDelay(2);
    const delayR = ctx.createDelay(2);
    delayL.delayTime.value = 0.333;
    delayR.delayTime.value = 0.5;

    const fbL = ctx.createGain();
    const fbR = ctx.createGain();
    fbL.gain.value = 0.32;
    fbR.gain.value = 0.28;

    const filterL = ctx.createBiquadFilter();
    const filterR = ctx.createBiquadFilter();
    filterL.type = filterR.type = 'lowpass';
    filterL.frequency.value = filterR.frequency.value = 2200;

    const panL = ctx.createStereoPanner();
    const panR = ctx.createStereoPanner();
    panL.pan.value = -0.8;
    panR.pan.value = 0.8;

    input.connect(delayL);
    delayL.connect(filterL);
    filterL.connect(fbL);
    fbL.connect(delayR);
    delayR.connect(filterR);
    filterR.connect(fbR);
    fbR.connect(delayL);

    filterL.connect(panL);
    filterR.connect(panR);
    panL.connect(output);
    panR.connect(output);

    return { input, output, delayL, delayR, fbL, fbR, baseGain };
}

function updateEffects() {
    const now = ctx.currentTime;

    // Reverb grows in deep states - more spacious, ethereal
    const verbGain = verb.baseGain + field.depth * 0.25 + field.breath * field.depth * 0.1;
    verb.output.gain.linearRampToValueAtTime(Math.min(0.7, verbGain), now + 0.1);

    // Delay grows subtly in deep states
    const dlyGain = dly.baseGain + field.depth * 0.15;
    dly.output.gain.linearRampToValueAtTime(Math.min(0.45, dlyGain), now + 0.1);

    // Feedback increases for longer tails in deep states
    const fbAmount = 0.32 + field.depth * 0.15;
    dly.fbL.gain.linearRampToValueAtTime(Math.min(0.55, fbAmount), now + 0.15);
    dly.fbR.gain.linearRampToValueAtTime(Math.min(0.5, fbAmount * 0.9), now + 0.15);
}

// ============ INIT ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master = ctx.createGain();
    master.gain.value = 0.7;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.ratio.value = 5;
    comp.attack.value = 0.003;
    comp.release.value = 0.2;

    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -2;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.1;

    verb = createVerb();
    dly = createDelay();

    master.connect(comp);
    comp.connect(limiter);
    limiter.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    createSub();

    // Birth initial entities - the primordial soup
    const initialRatios = [1, 5/4, 3/2, 2, 5/2, 3];
    for (const ratio of initialRatios) {
        const e = new Entity(ratio);
        e.createAudio();
        e.lastVisit = 0;
        entities.push(e);
    }

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

// ============ INPUT ============

function onMove(nx, ny) {
    nx = Math.max(0, Math.min(1, nx));
    ny = Math.max(0, Math.min(1, ny));

    const prevX = field.x;
    const prevY = field.y;
    const prevVx = field.vx;
    const prevVy = field.vy;

    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = field.x * 0.75 + nx * 0.25;
    field.y = field.y * 0.75 + ny * 0.25;

    // Calculate acceleration for gesture buffer
    const ax = field.vx - prevVx;
    const ay = field.vy - prevVy;

    // Add sample to gesture buffer
    addGestureSample(field.x, field.y, field.vx, field.vy, ax, ay);

    // Check for gestures
    const gesture = detectGesture();
    if (gesture) {
        onGestureDetected(gesture);
    }

    const speed = Math.sqrt(field.vx*field.vx + field.vy*field.vy);
    field.energy = field.energy * 0.9 + speed * 0.5;

    // Stillness
    if (speed < 0.005) {
        field.stillness = Math.min(3, field.stillness + 0.016);
    } else {
        field.stillness *= 0.95;
    }

    // Birth from energy
    if (field.energy > 0.15 && Math.random() < field.energy * 0.03) {
        birthEntity();
    }
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const rawAx = (a.x || 0) / 8;
    const rawAy = (a.y || 0) / 8;

    const prevVx = field.vx;
    const prevVy = field.vy;

    field.vx = field.vx * 0.7 + rawAx * 0.3;
    field.vy = field.vy * 0.7 + rawAy * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.08));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.08));

    // Calculate acceleration change for gesture buffer
    const ax = field.vx - prevVx;
    const ay = field.vy - prevVy;

    // Add sample to gesture buffer
    addGestureSample(field.x, field.y, field.vx, field.vy, ax, ay);

    // Check for gestures
    const gesture = detectGesture();
    if (gesture) {
        onGestureDetected(gesture);
    }

    field.energy = field.energy * 0.9 + Math.sqrt(rawAx*rawAx + rawAy*rawAy) * 0.3;

    if (field.energy > 0.2 && Math.random() < field.energy * 0.02) {
        birthEntity();
    }
}

function onOrientation(e) {
    const gx = Math.max(-1, Math.min(1, (e.gamma || 0) / 40));
    const gy = Math.max(-1, Math.min(1, (e.beta || 0) / 40 - 1));
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ VISUALIZATION ============

function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade - slower in deep stillness, creating trails
    const fadeAlpha = 0.06 + field.stillness * 0.02 - field.depth * 0.03;
    vc.fillStyle = `rgba(0, 0, 0, ${Math.max(0.02, fadeAlpha)})`;
    vc.fillRect(0, 0, w, h);

    // Deep stillness - the universe breathes with subtle color
    if (field.depth > 0.1) {
        const breathHue = 220 + field.breath * 40;
        const depthGrad = vc.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h)/2);
        depthGrad.addColorStop(0, `hsla(${breathHue}, 30%, 15%, ${field.depth * field.breath * 0.08})`);
        depthGrad.addColorStop(0.5, `hsla(${breathHue + 30}, 25%, 10%, ${field.depth * 0.05})`);
        depthGrad.addColorStop(1, 'transparent');
        vc.fillStyle = depthGrad;
        vc.fillRect(0, 0, w, h);
    }

    // Ghosts (fading dead entities)
    for (const g of ghosts) {
        vc.beginPath();
        vc.arc(g.x * w, g.y * h, g.radius, 0, TAU);
        vc.strokeStyle = `hsla(${g.hue}, 50%, 50%, ${g.alpha})`;
        vc.lineWidth = 1;
        vc.stroke();
    }

    // Regional mode visualization (subtle)
    const gradient = vc.createRadialGradient(w/2, h/2, 0, w/2, h/2, Math.max(w,h)/2);
    gradient.addColorStop(0, 'transparent');
    gradient.addColorStop(1, `rgba(50, 50, 80, ${0.02 + field.stillness * 0.01})`);
    vc.fillStyle = gradient;
    vc.fillRect(0, 0, w, h);

    // Constellations (behind connections)
    drawConstellations();

    // Connections
    drawConnections();

    // Entities
    for (const e of entities) {
        e.draw();
    }

    // Cursor
    const cx = field.x * w;
    const cy = field.y * h;
    const cursorR = 15 + field.energy * 50 + field.depth * 20 * field.breath;
    const cursorGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, cursorR);
    cursorGrad.addColorStop(0, `rgba(255, 255, 255, ${0.35 + field.energy * 0.4})`);
    cursorGrad.addColorStop(0.5, `rgba(200, 220, 255, ${0.1 + field.energy * 0.15 + field.depth * 0.1})`);
    cursorGrad.addColorStop(1, 'transparent');
    vc.fillStyle = cursorGrad;
    vc.beginPath();
    vc.arc(cx, cy, cursorR, 0, TAU);
    vc.fill();

    // Global pulse visualization
    if (field.pulse > 0.1) {
        const pulseR = 100 + field.pulse * 200;
        vc.beginPath();
        vc.arc(w/2, h/2, pulseR, 0, TAU);
        vc.strokeStyle = `rgba(255, 255, 255, ${field.pulse * 0.08})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Cosmic breath ring - visible in deep states
    if (field.depth > 0.3) {
        const breathR = 150 + field.breath * 100;
        vc.beginPath();
        vc.arc(w/2, h/2, breathR, 0, TAU);
        vc.strokeStyle = `hsla(240, 40%, 70%, ${field.depth * field.breath * 0.15})`;
        vc.lineWidth = 1 + field.breath * 3;
        vc.stroke();
    }
}

// ============ BREATH OF THE UNIVERSE ============

function updateBreath(dt) {
    // Slow cosmic oscillation - about 8 breaths per minute
    field.breathPhase += dt * 0.14;

    // The breath itself - a gentle wave
    field.breath = (Math.sin(field.breathPhase) + 1) / 2;

    // Depth accumulates in stillness, fades with movement
    if (field.stillness > 1.5) {
        field.depth = Math.min(1, field.depth + dt * 0.02);
    } else {
        field.depth *= 0.995;
    }
}

// ============ CONSTELLATIONS ============

function findConstellations() {
    // Find stable triads - three entities mutually consonant and close
    const constellations = [];

    for (let i = 0; i < entities.length; i++) {
        const a = entities[i];
        if (a.life < 0.7 || a.age < 3) continue;

        for (let j = i + 1; j < entities.length; j++) {
            const b = entities[j];
            if (b.life < 0.7 || b.age < 3) continue;

            const abCons = consonance(a.ratio, b.ratio);
            if (abCons < 0.7) continue;

            const abDist = Math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2);
            if (abDist > 0.25) continue;

            for (let k = j + 1; k < entities.length; k++) {
                const c = entities[k];
                if (c.life < 0.7 || c.age < 3) continue;

                const acCons = consonance(a.ratio, c.ratio);
                const bcCons = consonance(b.ratio, c.ratio);

                if (acCons < 0.7 || bcCons < 0.7) continue;

                const acDist = Math.sqrt((a.x-c.x)**2 + (a.y-c.y)**2);
                const bcDist = Math.sqrt((b.x-c.x)**2 + (b.y-c.y)**2);

                if (acDist > 0.25 || bcDist > 0.25) continue;

                // This is a constellation!
                const avgCons = (abCons + acCons + bcCons) / 3;
                const avgLife = (a.life + b.life + c.life) / 3;

                constellations.push({
                    entities: [a, b, c],
                    center: {
                        x: (a.x + b.x + c.x) / 3,
                        y: (a.y + b.y + c.y) / 3
                    },
                    consonance: avgCons,
                    strength: avgCons * avgLife
                });
            }
        }
    }

    field.constellations = constellations;
}

function drawConstellations() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    for (const c of field.constellations) {
        const [a, b, e3] = c.entities;
        const alpha = c.strength * 0.4 * (0.7 + field.breath * 0.3);

        // Triangle fill
        vc.beginPath();
        vc.moveTo(a.x * w, a.y * h);
        vc.lineTo(b.x * w, b.y * h);
        vc.lineTo(e3.x * w, e3.y * h);
        vc.closePath();

        // Average hue of the triad
        const avgHue = (a.hue + b.hue + e3.hue) / 3;
        vc.fillStyle = `hsla(${avgHue}, 40%, 50%, ${alpha * 0.15})`;
        vc.fill();

        // Glowing outline
        vc.strokeStyle = `hsla(${avgHue}, 60%, 70%, ${alpha * 0.6})`;
        vc.lineWidth = 1 + c.consonance * 2;
        vc.stroke();

        // Center point - the heart of the constellation
        const cx = c.center.x * w;
        const cy = c.center.y * h;
        const pulseR = 5 + field.breath * 10 * c.strength;

        const grad = vc.createRadialGradient(cx, cy, 0, cx, cy, pulseR);
        grad.addColorStop(0, `hsla(${avgHue}, 70%, 80%, ${alpha})`);
        grad.addColorStop(1, 'transparent');
        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(cx, cy, pulseR, 0, TAU);
        vc.fill();
    }
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    const dt = 0.016;
    field.time += dt;

    updateBreath(dt);

    for (const e of entities) {
        e.update(dt);
    }

    processDeath();
    findConstellations();
    updateSub();
    updateEffects();
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
