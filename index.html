<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gump</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 13px;
            --fib34: 21px;
            --fib55: 34px;
            --fib89: 55px;
            --fib144: 89px;
            --fib233: 144px;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
            cursor: none;
        }

        /* Motion cursor */
        .cursor {
            position: fixed;
            width: var(--fib34);
            height: var(--fib34);
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            pointer-events: none;
            transition: all 0.1s ease;
            z-index: 1000;
            mix-blend-mode: difference;
        }

        .cursor.sampling {
            animation: cursorPulse 0.5s ease-out;
        }

        @keyframes cursorPulse {
            0% { transform: translate(-50%, -50%) scale(1); border-color: rgba(255,255,255,0.2); }
            50% { transform: translate(-50%, -50%) scale(2); border-color: rgba(255,255,255,0.8); }
            100% { transform: translate(-50%, -50%) scale(1); border-color: rgba(255,255,255,0.2); }
        }

        /* Fibonacci spiral */
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }

        #spiral.active {
            opacity: 0.03;
        }

        /* Title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }

        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }

        /* Start */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%, 
                rgba(255,255,255,0.03) 0%, 
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }

        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }

        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }

        /* Interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }

        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }

        @keyframes fadeIn {
            to { opacity: 1; }
        }

        /* Motion field */
        .motion-field {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            line-height: var(--phi);
        }

        .motion-value {
            font-size: var(--fib13);
            opacity: 0.618;
        }

        /* Phase indicator */
        .phase-indicator {
            position: fixed;
            top: var(--fib34);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib5);
            opacity: 0.618;
            text-align: center;
            transition: all 0.618s ease;
        }

        .phase-indicator.building {
            color: #ff8c00;
            opacity: 0.8;
        }

        .phase-indicator.dropping {
            color: #ff0000;
            text-shadow: 0 0 var(--fib21) rgba(255, 0, 0, 0.5);
            animation: phasePulse 0.5s ease-in-out infinite;
        }

        .phase-indicator.void {
            color: #8a2be2;
            text-shadow: 0 0 var(--fib34) rgba(138, 43, 226, 0.5);
        }

        @keyframes phasePulse {
            0%, 100% { opacity: 0.8; }
            50% { opacity: 1; }
        }

        /* Sample slots */
        .sample-grid {
            position: fixed;
            bottom: var(--fib55);
            left: 50%;
            transform: translateX(-50%);
            display: grid;
            grid-template-columns: repeat(8, var(--fib34));
            gap: var(--fib8);
        }

        .sample-slot {
            width: var(--fib34);
            height: var(--fib21);
            background: rgba(255,255,255,0.03);
            border: 1px solid rgba(255,255,255,0.08);
            position: relative;
            overflow: hidden;
            transition: all 0.382s ease;
        }

        .sample-slot.filled {
            background: rgba(255,255,255,0.05);
            border-color: rgba(255,255,255,0.21);
        }

        .sample-slot.playing {
            border-color: rgba(255,255,255,0.55);
            box-shadow: 0 0 var(--fib13) rgba(255,255,255,0.21);
        }

        .sample-waveform {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.618;
        }

        /* Recording hint */
        .recording-hint {
            position: fixed;
            bottom: var(--fib21);
            left: 50%;
            transform: translateX(-50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            transition: opacity 0.382s ease;
        }

        .recording-hint.active {
            opacity: 0.382;
        }

        /* Energy visualization */
        .energy-ring {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--fib233);
            height: var(--fib233);
            border: 1px solid rgba(255,255,255,0.05);
            border-radius: 50%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.618s ease;
        }

        .energy-ring.active {
            opacity: 1;
            animation: energyPulse 2s ease-in-out infinite;
        }

        @keyframes energyPulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.1); opacity: 1; }
        }

        /* BPM */
        .bpm-indicator {
            position: fixed;
            bottom: var(--fib55);
            right: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            text-align: right;
        }

        .bpm-value {
            font-size: var(--fib21);
            opacity: 0.618;
        }

        /* Canvas */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #visualizer { z-index: 2; opacity: 0.21; }
        #particles { z-index: 3; opacity: 0.34; }

        /* Touch surface */
        .touch-surface {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* Sample ripple */
        .sample-ripple {
            position: absolute;
            border: 2px solid rgba(255,255,255,0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            animation: rippleOut 1.618s ease-out;
        }

        @keyframes rippleOut {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: var(--fib144);
                height: var(--fib144);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div class="cursor" id="cursor"></div>
    
    <canvas id="spiral"></canvas>
    <canvas id="visualizer"></canvas>
    <canvas id="particles"></canvas>
    
    <div class="title">Gump by James McCandless</div>
    
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
    
    <div class="interface" id="interface">
        <div class="touch-surface" id="touchSurface"></div>
        
        <div class="phase-indicator" id="phaseIndicator">AWAKENING</div>
        
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
        </div>
        
        <div class="sample-grid" id="sampleGrid"></div>
        
        <div class="recording-hint" id="recordingHint">TAP TO SAMPLE</div>
        
        <div class="energy-ring" id="energyRing"></div>
        
        <div class="bpm-indicator">
            <div>BPM</div>
            <div class="bpm-value" id="bpmValue">89</div>
        </div>
    </div>

    <script>
        // Gump Hybrid Engine
        class GumpHybrid {
            constructor() {
                // Audio Context
                this.ctx = null;
                this.masterGain = null;
                
                // Microphone & Recording
                this.mic = null;
                this.recorder = null;
                this.isRecording = false;
                this.recordBuffer = [];
                
                // Motion System
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: [],
                    velocity: 0,
                    x: 0.5,
                    y: 0.5,
                    lastX: 0.5,
                    lastY: 0.5,
                    lastTime: 0,
                    intensity: 0,
                    pattern: 'still'
                };
                
                // Sample Management
                this.samples = [];
                this.maxSamples = 8;
                
                // Musical State
                this.bpm = 89; // Fibonacci
                this.currentBeat = 0;
                this.nextBeatTime = 0;
                this.barCount = 0;
                this.swing = 0.05;
                
                // Phase Management
                this.phase = 'awakening'; // awakening, gathering, building, dropping, void
                this.phaseStartBar = 0;
                this.buildIntensity = 0;
                this.dropScheduled = false;
                
                // Effects
                this.fx = {
                    reverb: null,
                    delay: null,
                    filter: null,
                    compressor: null,
                    sidechain: null
                };
                
                // Special Elements
                this.atmosphere = null;
                this.subBass = null;
                this.riser = null;
                
                // UI Elements
                this.ui = {};
                this.canvases = {};
                
                this.init();
            }
            
            init() {
                // Cache DOM
                this.ui = {
                    start: document.getElementById('start'),
                    interface: document.getElementById('interface'),
                    cursor: document.getElementById('cursor'),
                    touchSurface: document.getElementById('touchSurface'),
                    phaseIndicator: document.getElementById('phaseIndicator'),
                    motionValue: document.getElementById('motionValue'),
                    sampleGrid: document.getElementById('sampleGrid'),
                    recordingHint: document.getElementById('recordingHint'),
                    energyRing: document.getElementById('energyRing'),
                    bpmValue: document.getElementById('bpmValue')
                };
                
                // Create sample slots
                for (let i = 0; i < this.maxSamples; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'sample-slot';
                    slot.dataset.index = i;
                    const canvas = document.createElement('canvas');
                    canvas.className = 'sample-waveform';
                    canvas.width = 34;
                    canvas.height = 21;
                    slot.appendChild(canvas);
                    this.ui.sampleGrid.appendChild(slot);
                }
                
                // Setup canvases
                ['spiral', 'visualizer', 'particles'].forEach(id => {
                    const canvas = document.getElementById(id);
                    this.canvases[id] = {
                        canvas,
                        ctx: canvas.getContext('2d')
                    };
                    this.resizeCanvas(canvas);
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    Object.values(this.canvases).forEach(({ canvas }) => {
                        this.resizeCanvas(canvas);
                    });
                });
                
                // Start button
                this.ui.start.addEventListener('click', () => this.begin());
                
                // Draw initial spiral
                this.drawFibonacciSpiral();
            }
            
            resizeCanvas(canvas) {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            
            drawFibonacciSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 400;
                
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
                
                let a = 0, b = 1;
                let angle = 0;
                
                for (let i = 0; i < 13; i++) {
                    const radius = b * scale;
                    
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(angle) * a * scale,
                        centerY + Math.sin(angle) * a * scale,
                        radius,
                        angle,
                        angle + Math.PI / 2
                    );
                    ctx.stroke();
                    
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                }
            }
            
            async begin() {
                this.ui.start.style.display = 'none';
                
                try {
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    // Setup audio
                    this.setupAudio(stream);
                    
                    // Setup interactions
                    this.setupMotionTracking();
                    this.setupTouchSampling();
                    
                    // Show interface
                    this.ui.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');
                    
                    // Start engine
                    this.startEngine();
                    
                } catch (err) {
                    console.error('Failed to start:', err);
                    alert('Microphone access required');
                }
            }
            
            setupAudio(stream) {
                // Input
                this.mic = this.ctx.createMediaStreamSource(stream);
                
                // Recording processor
                this.recorder = this.ctx.createScriptProcessor(2048, 1, 1);
                this.recorder.onaudioprocess = (e) => {
                    if (this.isRecording) {
                        const data = e.inputBuffer.getChannelData(0);
                        this.recordBuffer.push(...data);
                    }
                };
                
                // Master chain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;
                
                // Compressor
                this.fx.compressor = this.ctx.createDynamicsCompressor();
                this.fx.compressor.threshold.value = -12;
                this.fx.compressor.knee.value = 3;
                this.fx.compressor.ratio.value = 6;
                this.fx.compressor.attack.value = 0.003;
                this.fx.compressor.release.value = 0.25;
                
                // Sidechain (for drop)
                this.fx.sidechain = this.ctx.createDynamicsCompressor();
                this.fx.sidechain.threshold.value = -20;
                this.fx.sidechain.knee.value = 0;
                this.fx.sidechain.ratio.value = 10;
                this.fx.sidechain.attack.value = 0.001;
                this.fx.sidechain.release.value = 0.1;
                
                // Filter
                this.fx.filter = this.ctx.createBiquadFilter();
                this.fx.filter.type = 'lowpass';
                this.fx.filter.frequency.value = 20000;
                this.fx.filter.Q.value = 1;
                
                // Reverb
                this.fx.reverb = this.ctx.createConvolver();
                this.createProfessionalReverb();
                this.fx.reverbSend = this.ctx.createGain();
                this.fx.reverbSend.gain.value = 0.15;
                
                // Delay
                this.fx.delay = this.ctx.createDelay(1);
                this.fx.delay.delayTime.value = 60 / this.bpm / 8;
                this.fx.delayFeedback = this.ctx.createGain();
                this.fx.delayFeedback.gain.value = 0.4;
                this.fx.delaySend = this.ctx.createGain();
                this.fx.delaySend.gain.value = 0.1;
                
                // Connect delay feedback
                this.fx.delay.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delay);
                
                // Analyser for visualization
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 1024;
                this.analyser.smoothingTimeConstant = 0.85;
                
                // Connect chains
                this.mic.connect(this.recorder);
                this.recorder.connect(this.ctx.destination); // Required
                
                this.masterGain.connect(this.fx.filter);
                this.fx.filter.connect(this.fx.compressor);
                this.fx.compressor.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
                
                // Effect sends
                this.masterGain.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb);
                this.fx.reverb.connect(this.ctx.destination);
                
                this.masterGain.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delay);
                this.fx.delay.connect(this.fx.compressor);
            }
            
            createProfessionalReverb() {
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    
                    // More complex reverb with early reflections
                    for (let i = 0; i < length; i++) {
                        // Decay envelope
                        let decay = Math.pow(1 - i / length, 2.5);
                        
                        // Add early reflections
                        if (i < 1000) {
                            if (i % 73 === 0 || i % 97 === 0) {
                                channelData[i] = (Math.random() * 2 - 1) * 0.5 * decay;
                            }
                        }
                        
                        // Diffuse tail
                        channelData[i] += (Math.random() * 2 - 1) * decay * 0.25;
                    }
                }
                
                this.fx.reverb.buffer = impulse;
            }
            
            setupMotionTracking() {
                // Mouse/touch position tracking
                const updateMotion = (e) => {
                    const x = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const y = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    
                    // Update cursor
                    this.ui.cursor.style.left = x + 'px';
                    this.ui.cursor.style.top = y + 'px';
                    
                    // Calculate motion
                    const now = performance.now();
                    const dt = Math.max(1, now - this.motion.lastTime) / 1000;
                    
                    this.motion.x = x / window.innerWidth;
                    this.motion.y = y / window.innerHeight;
                    
                    const dx = this.motion.x - this.motion.lastX;
                    const dy = this.motion.y - this.motion.lastY;
                    
                    this.motion.velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                    this.motion.current = this.motion.velocity * 50;
                    
                    this.motion.lastX = this.motion.x;
                    this.motion.lastY = this.motion.y;
                    this.motion.lastTime = now;
                    
                    // Smooth the motion
                    this.motion.smoothed = this.motion.smoothed * 0.9 + this.motion.current * 0.1;
                    
                    // Update history
                    this.motion.history.push(this.motion.smoothed);
                    if (this.motion.history.length > 60) {
                        this.motion.history.shift();
                    }
                    
                    // Calculate intensity
                    const avg = this.motion.history.reduce((a, b) => a + b, 0) / this.motion.history.length;
                    this.motion.intensity = Math.min(1, avg / 10);
                    
                    // Update UI
                    this.ui.motionValue.textContent = this.motion.smoothed.toFixed(3);
                    
                    // Motion affects musical parameters
                    this.modulateWithMotion();
                };
                
                document.addEventListener('mousemove', updateMotion);
                document.addEventListener('touchmove', updateMotion);
                
                // Hide system cursor
                document.body.style.cursor = 'none';
            }
            
            modulateWithMotion() {
                // Subtle BPM modulation
                const targetBPM = 89 + Math.floor(this.motion.intensity * 55); // 89-144
                this.bpm = Math.round(this.bpm * 0.95 + targetBPM * 0.05);
                this.ui.bpmValue.textContent = this.bpm;
                
                // Filter modulation during build/drop
                if (this.phase === 'building' || this.phase === 'dropping') {
                    const filterFreq = 200 + this.motion.smoothed * 100 + this.motion.intensity * 5000;
                    this.fx.filter.frequency.exponentialRampToValueAtTime(
                        filterFreq,
                        this.ctx.currentTime + 0.1
                    );
                }
            }
            
            setupTouchSampling() {
                let touchTimer;
                let touchStart = 0;
                
                const startSample = (e) => {
                    e.preventDefault();
                    
                    if (this.samples.length >= this.maxSamples) return;
                    
                    // Position for ripple
                    const x = e.clientX !== undefined ? e.clientX : e.touches[0].clientX;
                    const y = e.clientY !== undefined ? e.clientY : e.touches[0].clientY;
                    
                    // Start recording
                    this.isRecording = true;
                    this.recordBuffer = [];
                    touchStart = Date.now();
                    
                    // Visual feedback
                    this.createRipple(x, y);
                    this.ui.cursor.classList.add('sampling');
                    this.ui.recordingHint.classList.remove('active');
                    
                    // Variable duration based on motion
                    const duration = 500 + (1 - this.motion.intensity) * 3500; // 0.5-4 seconds
                    touchTimer = setTimeout(() => this.stopSample(), duration);
                };
                
                const stopSample = () => {
                    if (!this.isRecording) return;
                    
                    clearTimeout(touchTimer);
                    this.isRecording = false;
                    this.ui.cursor.classList.remove('sampling');
                    
                    // Process if we have enough data
                    const duration = Date.now() - touchStart;
                    if (duration > 100 && this.recordBuffer.length > this.ctx.sampleRate * 0.1) {
                        this.processSample();
                    }
                };
                
                // Touch events
                this.ui.touchSurface.addEventListener('touchstart', startSample);
                this.ui.touchSurface.addEventListener('touchend', stopSample);
                this.ui.touchSurface.addEventListener('mousedown', startSample);
                this.ui.touchSurface.addEventListener('mouseup', stopSample);
                
                // Show hint periodically
                setInterval(() => {
                    if (this.samples.length < 2 && !this.isRecording) {
                        this.ui.recordingHint.classList.add('active');
                        setTimeout(() => this.ui.recordingHint.classList.remove('active'), 2000);
                    }
                }, 5000);
            }
            
            createRipple(x, y) {
                const ripple = document.createElement('div');
                ripple.className = 'sample-ripple';
                ripple.style.left = x + 'px';
                ripple.style.top = y + 'px';
                this.ui.touchSurface.appendChild(ripple);
                
                setTimeout(() => ripple.remove(), 1618);
            }
            
            processSample() {
                const audioData = new Float32Array(this.recordBuffer);
                
                // Normalize
                let maxVal = 0;
                for (let i = 0; i < audioData.length; i++) {
                    maxVal = Math.max(maxVal, Math.abs(audioData[i]));
                }
                
                if (maxVal > 0) {
                    const scale = 0.8 / maxVal;
                    for (let i = 0; i < audioData.length; i++) {
                        audioData[i] *= scale;
                    }
                }
                
                // Create buffer
                const buffer = this.ctx.createBuffer(1, audioData.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(audioData);
                
                // Analyze for intelligent processing
                const analysis = this.analyzeSample(audioData);
                
                // Create sample object
                const sample = {
                    buffer: buffer,
                    analysis: analysis,
                    type: this.categorizeSample(analysis),
                    gain: this.ctx.createGain(),
                    filter: this.ctx.createBiquadFilter(),
                    panner: this.ctx.createStereoPanner(),
                    pattern: null,
                    lastTrigger: 0,
                    variation: 0
                };
                
                // Setup nodes
                sample.gain.gain.value = 0.7;
                sample.filter.type = 'lowpass';
                sample.filter.frequency.value = 10000;
                sample.panner.pan.value = (Math.random() - 0.5) * 0.5; // Slight stereo spread
                
                // Connect
                sample.filter.connect(sample.panner);
                sample.panner.connect(sample.gain);
                sample.gain.connect(this.masterGain);
                
                // Generate pattern based on current samples
                sample.pattern = this.generateIntelligentPattern(sample.type);
                
                // Add to samples
                this.samples.push(sample);
                
                // Update UI
                const slot = this.ui.sampleGrid.children[this.samples.length - 1];
                slot.classList.add('filled');
                this.drawWaveform(slot.querySelector('canvas'), audioData);
                
                // Update phase
                this.updatePhase();
            }
            
            analyzeSample(data) {
                const analysis = {
                    rms: 0,
                    spectralCentroid: 0,
                    zeroCrossings: 0,
                    percussiveness: 0,
                    tonality: 0
                };
                
                // RMS
                let sum = 0;
                for (let i = 0; i < data.length; i++) {
                    sum += data[i] * data[i];
                }
                analysis.rms = Math.sqrt(sum / data.length);
                
                // Zero crossings
                for (let i = 1; i < data.length; i++) {
                    if ((data[i-1] >= 0) !== (data[i] >= 0)) {
                        analysis.zeroCrossings++;
                    }
                }
                
                // Percussiveness (sharp attack)
                const attackWindow = Math.min(1000, data.length / 10);
                let attackEnergy = 0;
                let sustainEnergy = 0;
                
                for (let i = 0; i < attackWindow; i++) {
                    attackEnergy += Math.abs(data[i]);
                }
                for (let i = attackWindow; i < data.length; i++) {
                    sustainEnergy += Math.abs(data[i]);
                }
                
                analysis.percussiveness = attackEnergy / attackWindow / (sustainEnergy / (data.length - attackWindow) + 0.001);
                
                // Tonality vs noise
                analysis.tonality = 1 - Math.min(1, analysis.zeroCrossings / (data.length * 0.5));
                
                return analysis;
            }
            
            categorizeSample(analysis) {
                if (analysis.percussiveness > 5) return 'kick';
                if (analysis.percussiveness > 3) return 'snare';
                if (analysis.percussiveness > 1.5) return 'hat';
                if (analysis.tonality > 0.7 && analysis.rms > 0.3) return 'bass';
                if (analysis.tonality > 0.5) return 'melody';
                return 'texture';
            }
            
            generateIntelligentPattern(type) {
                // Patterns evolve based on existing samples
                const sampleCount = this.samples.length;
                
                const basePatterns = {
                    kick:    [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0],
                    snare:   [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0],
                    hat:     [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
                    bass:    [1,0,0,1, 0,0,1,0, 1,0,0,0, 1,0,1,0],
                    melody:  [1,0,0,0, 0,0,0,0, 0,0,1,0, 0,0,0,0],
                    texture: [1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0]
                };
                
                let pattern = basePatterns[type] || basePatterns.texture;
                
                // Evolve pattern based on sample count
                if (sampleCount > 2) {
                    // Add variations
                    pattern = pattern.map((step, i) => {
                        if (step === 0 && Math.random() < 0.1 * sampleCount) {
                            return Math.random() > 0.5 ? 1 : 0;
                        }
                        return step;
                    });
                }
                
                return pattern;
            }
            
            updatePhase() {
                const oldPhase = this.phase;
                const sampleCount = this.samples.length;
                
                if (sampleCount === 0) {
                    this.phase = 'awakening';
                } else if (sampleCount < 2) {
                    this.phase = 'gathering';
                } else if (sampleCount < 4) {
                    if (this.phase !== 'building') {
                        this.phase = 'building';
                        this.phaseStartBar = this.barCount;
                        this.ui.energyRing.classList.add('active');
                        this.startBuildingPhase();
                    }
                } else if (sampleCount >= 4 && this.buildIntensity >= 1 && !this.dropScheduled) {
                    this.scheduleTheDrop();
                }
                
                // Update UI
                if (oldPhase !== this.phase) {
                    this.ui.phaseIndicator.textContent = this.phase.toUpperCase();
                    this.ui.phaseIndicator.className = 'phase-indicator ' + this.phase;
                }
            }
            
            startBuildingPhase() {
                // Create subtle riser
                const now = this.ctx.currentTime;
                const buildDuration = 16 * (60 / this.bpm); // 16 bars
                
                // Filtered noise riser
                const noise = this.ctx.createBufferSource();
                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * 0.3;
                }
                
                noise.buffer = noiseBuffer;
                noise.loop = true;
                
                const riserFilter = this.ctx.createBiquadFilter();
                riserFilter.type = 'highpass';
                riserFilter.frequency.setValueAtTime(20, now);
                riserFilter.frequency.exponentialRampToValueAtTime(5000, now + buildDuration);
                riserFilter.Q.value = 5;
                
                const riserGain = this.ctx.createGain();
                riserGain.gain.setValueAtTime(0, now);
                riserGain.gain.linearRampToValueAtTime(0.15, now + buildDuration);
                
                noise.connect(riserFilter);
                riserFilter.connect(riserGain);
                riserGain.connect(this.fx.reverbSend);
                
                noise.start(now);
                noise.stop(now + buildDuration);
                
                this.riser = { noise, filter: riserFilter, gain: riserGain };
            }
            
            scheduleTheDrop() {
                this.dropScheduled = true;
                
                // Build tension for 4 more bars
                setTimeout(() => {
                    this.phase = 'dropping';
                    this.ui.phaseIndicator.textContent = 'DROPPING';
                    this.ui.energyRing.classList.remove('active');
                    
                    // Stop riser
                    if (this.riser) {
                        this.riser.gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
                    }
                    
                    // Execute the drop
                    this.executeTheDrop();
                    
                    // Schedule void phase
                    setTimeout(() => {
                        if (this.samples.length >= 6) {
                            this.enterTheVoid();
                        }
                    }, 32 * (60 / this.bpm) * 1000); // 32 bars later
                    
                }, 4 * (60 / this.bpm) * 4 * 1000); // 4 bars
            }
            
            executeTheDrop() {
                const now = this.ctx.currentTime;
                
                // Sub drop impact
                const subDrop = this.ctx.createOscillator();
                const subGain = this.ctx.createGain();
                
                subDrop.type = 'sine';
                subDrop.frequency.setValueAtTime(80, now);
                subDrop.frequency.exponentialRampToValueAtTime(20, now + 2);
                
                subGain.gain.setValueAtTime(1, now);
                subGain.gain.exponentialRampToValueAtTime(0.001, now + 2);
                
                subDrop.connect(subGain);
                subGain.connect(this.masterGain);
                
                subDrop.start(now);
                subDrop.stop(now + 2);
                
                // Enable sidechain compression
                this.masterGain.disconnect();
                this.masterGain.connect(this.fx.sidechain);
                this.fx.sidechain.connect(this.fx.filter);
                
                // Make patterns more intense
                this.samples.forEach(sample => {
                    sample.pattern = sample.pattern.map((step, i) => {
                        if (sample.type === 'kick') return i % 4 === 0 ? 1 : 0;
                        if (sample.type === 'bass') return i % 2 === 0 ? 1 : step;
                        return Math.random() > 0.3 ? 1 : step;
                    });
                    
                    // Increase variation
                    sample.variation = 0.2;
                });
                
                // Create wobble bass
                this.createWobbleBass();
            }
            
            createWobbleBass() {
                const bass1 = this.ctx.createOscillator();
                const bass2 = this.ctx.createOscillator();
                const bassFilter = this.ctx.createBiquadFilter();
                const bassGain = this.ctx.createGain();
                const lfo = this.ctx.createOscillator();
                const lfoGain = this.ctx.createGain();
                
                bass1.type = 'sawtooth';
                bass2.type = 'square';
                bass1.frequency.value = 55; // Low A
                bass2.frequency.value = 55.5; // Slight detune
                
                bassFilter.type = 'lowpass';
                bassFilter.Q.value = 15;
                bassFilter.frequency.value = 200;
                
                lfo.type = 'sine';
                lfo.frequency.value = this.bpm / 60 * 2; // Synced to tempo
                
                lfoGain.gain.value = 800;
                
                bassGain.gain.value = 0.3;
                
                // Connect LFO
                lfo.connect(lfoGain);
                lfoGain.connect(bassFilter.frequency);
                
                // Connect bass
                bass1.connect(bassFilter);
                bass2.connect(bassFilter);
                bassFilter.connect(bassGain);
                bassGain.connect(this.fx.sidechain);
                
                bass1.start();
                bass2.start();
                lfo.start();
                
                this.subBass = { bass1, bass2, filter: bassFilter, gain: bassGain, lfo };
            }
            
            enterTheVoid() {
                this.phase = 'void';
                this.ui.phaseIndicator.textContent = 'THE VOID';
                
                // Fade out wobble bass
                if (this.subBass) {
                    this.subBass.gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
                    setTimeout(() => {
                        this.subBass.bass1.stop();
                        this.subBass.bass2.stop();
                        this.subBass.lfo.stop();
                    }, 4000);
                }
                
                // Dark atmosphere
                this.fx.filter.frequency.exponentialRampToValueAtTime(400, this.ctx.currentTime + 2);
                this.fx.reverbSend.gain.value = 0.5;
                this.fx.delaySend.gain.value = 0.3;
                this.fx.delay.delayTime.value = 60 / this.bpm / 2; // Half note delay
                
                // Sparse patterns
                this.samples.forEach(sample => {
                    sample.pattern = sample.pattern.map(() => Math.random() > 0.85 ? 1 : 0);
                    sample.variation = 0.5; // High variation
                    sample.gain.gain.value = 0.4;
                });
                
                // Deep drone
                const drone = this.ctx.createOscillator();
                const droneGain = this.ctx.createGain();
                
                drone.type = 'triangle';
                drone.frequency.value = 27.5; // Very low A
                droneGain.gain.value = 0.15;
                
                drone.connect(droneGain);
                droneGain.connect(this.fx.reverb);
                
                drone.start();
            }
            
            startEngine() {
                // Create initial atmosphere
                this.createAtmosphere();
                
                // Start scheduler
                this.startScheduler();
                
                // Start animations
                this.animate();
            }
            
            createAtmosphere() {
                // Subtle pad that responds to motion
                const createPad = () => {
                    const osc1 = this.ctx.createOscillator();
                    const osc2 = this.ctx.createOscillator();
                    const padFilter = this.ctx.createBiquadFilter();
                    const padGain = this.ctx.createGain();
                    
                    osc1.type = 'triangle';
                    osc2.type = 'sine';
                    
                    // Fibonacci-based frequencies
                    const baseFreq = 55 * Math.pow(2, Math.floor(this.motion.intensity * 3) / 12);
                    osc1.frequency.value = baseFreq;
                    osc2.frequency.value = baseFreq * 1.618;
                    
                    padFilter.type = 'lowpass';
                    padFilter.frequency.value = 300 + this.motion.smoothed * 200;
                    padFilter.Q.value = 3;
                    
                    const now = this.ctx.currentTime;
                    padGain.gain.setValueAtTime(0, now);
                    padGain.gain.linearRampToValueAtTime(0.05, now + 3);
                    padGain.gain.linearRampToValueAtTime(0, now + 13);
                    
                    osc1.connect(padFilter);
                    osc2.connect(padFilter);
                    padFilter.connect(padGain);
                    padGain.connect(this.fx.reverbSend);
                    
                    osc1.start(now);
                    osc2.start(now);
                    osc1.stop(now + 13);
                    osc2.stop(now + 13);
                    
                    // Schedule next pad
                    if (this.phase !== 'void') {
                        setTimeout(createPad, 8000);
                    }
                };
                
                createPad();
            }
            
            startScheduler() {
                const schedule = () => {
                    const now = this.ctx.currentTime;
                    
                    while (this.nextBeatTime < now + 0.1) {
                        const beatTime = this.nextBeatTime;
                        const step = this.currentBeat % 16;
                        
                        // Trigger samples
                        this.samples.forEach((sample, i) => {
                            if (sample.pattern[step]) {
                                this.triggerSample(sample, beatTime, i);
                            }
                        });
                        
                        // Sidechain pump on kick
                        if (this.phase === 'dropping' && step % 4 === 0) {
                            this.pumpSidechain(beatTime);
                        }
                        
                        // Update build intensity
                        if (this.phase === 'building') {
                            const buildBars = this.barCount - this.phaseStartBar;
                            this.buildIntensity = Math.min(1, buildBars / 16);
                        }
                        
                        // Next beat
                        this.currentBeat++;
                        if (this.currentBeat % 16 === 0) {
                            this.barCount++;
                        }
                        
                        // Apply swing
                        let beatDuration = 60 / this.bpm / 4;
                        if (step % 2 === 1) {
                            beatDuration += beatDuration * this.swing;
                        }
                        
                        this.nextBeatTime += beatDuration;
                    }
                    
                    setTimeout(schedule, 25);
                };
                
                this.nextBeatTime = this.ctx.currentTime;
                schedule();
            }
            
            triggerSample(sample, when, index) {
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
                
                // Apply variation
                const pitchVariation = 1 + (Math.random() - 0.5) * sample.variation;
                source.playbackRate.value = pitchVariation;
                
                // Phase-specific modulation
                if (this.phase === 'void') {
                    source.playbackRate.value *= 0.5 + Math.random() * 0.3;
                    sample.filter.frequency.value = 200 + Math.random() * 300;
                } else if (this.phase === 'dropping') {
                    sample.filter.frequency.value = 1000 + Math.random() * 5000;
                }
                
                source.connect(sample.filter);
                source.start(when);
                
                // Visual feedback
                const slot = this.ui.sampleGrid.children[index];
                setTimeout(() => {
                    slot.classList.add('playing');
                    setTimeout(() => slot.classList.remove('playing'), 100);
                }, (when - this.ctx.currentTime) * 1000);
            }
            
            pumpSidechain(when) {
                // Duck the sidechain compressor
                // This is simplified - in reality you'd trigger with the kick
                const now = when || this.ctx.currentTime;
                this.fx.sidechain.threshold.setValueAtTime(-50, now);
                this.fx.sidechain.threshold.linearRampToValueAtTime(-20, now + 0.05);
            }
            
            drawWaveform(canvas, data) {
                const ctx = canvas.getContext('2d');
                const width = canvas.width;
                const height = canvas.height;
                
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                
                const step = Math.ceil(data.length / width);
                
                ctx.beginPath();
                for (let i = 0; i < width; i++) {
                    const sample = data[i * step] || 0;
                    const y = (1 + sample) * height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(i, y);
                    } else {
                        ctx.lineTo(i, y);
                    }
                }
                ctx.stroke();
            }
            
            animate() {
                const draw = () => {
                    requestAnimationFrame(draw);
                    this.drawVisualizer();
                    this.drawParticles();
                };
                draw();
            }
            
            drawVisualizer() {
                const { ctx, canvas } = this.canvases.visualizer;
                const freqData = new Uint8Array(this.analyser.frequencyBinCount);
                this.analyser.getByteFrequencyData(freqData);
                
                // Slower fade for trails
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const barWidth = canvas.width / freqData.length * 2;
                
                for (let i = 0; i < freqData.length; i++) {
                    const height = freqData[i] / 255 * canvas.height * 0.7;
                    
                    let hue, saturation, lightness;
                    
                    switch (this.phase) {
                        case 'awakening':
                            hue = 200 + Math.sin(Date.now() * 0.001) * 20;
                            saturation = 30;
                            lightness = 40;
                            break;
                        case 'gathering':
                            hue = 180 + (i / freqData.length) * 40;
                            saturation = 50;
                            lightness = 50;
                            break;
                        case 'building':
                            hue = 30 + this.buildIntensity * 30;
                            saturation = 60 + this.buildIntensity * 40;
                            lightness = 50;
                            break;
                        case 'dropping':
                            hue = (Date.now() * 0.1 + i * 2) % 360;
                            saturation = 100;
                            lightness = 50;
                            break;
                        case 'void':
                            hue = 270 + Math.sin(i * 0.1) * 30;
                            saturation = 80;
                            lightness = 20 + (freqData[i] / 255) * 30;
                            break;
                        default:
                            hue = 0;
                            saturation = 0;
                            lightness = 50;
                    }
                    
                    ctx.fillStyle = `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`;
                    ctx.fillRect(i * barWidth, canvas.height - height, barWidth - 1, height);
                }
            }
            
            drawParticles() {
                const { ctx, canvas } = this.canvases.particles;
                
                ctx.fillStyle = 'rgba(0, 0, 0, 0.08)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                const time = Date.now() * 0.001;
                const count = 8 + this.samples.length * 5;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2 + time * 0.05 * (1 + this.motion.intensity);
                    const radius = 50 + Math.sin(time * 0.5 + i) * 30 + this.motion.smoothed * 50;
                    
                    const x = canvas.width / 2 + Math.cos(angle) * radius + (this.motion.x - 0.5) * 100;
                    const y = canvas.height / 2 + Math.sin(angle) * radius + (this.motion.y - 0.5) * 100;
                    
                    const size = 1 + this.motion.intensity * 2 + (this.phase === 'dropping' ? 2 : 0);
                    
                    ctx.beginPath();
                    ctx.arc(x, y, size, 0, Math.PI * 2);
                    
                    let alpha = 0.3 + this.motion.intensity * 0.3;
                    let color;
                    
                    switch (this.phase) {
                        case 'building':
                            color = `rgba(255, ${140 + this.buildIntensity * 115}, 0, ${alpha})`;
                            break;
                        case 'dropping':
                            color = `rgba(255, ${Math.sin(time * 10) * 127 + 128}, 0, ${alpha})`;
                            break;
                        case 'void':
                            color = `rgba(138, 43, 226, ${alpha * 0.8})`;
                            break;
                        default:
                            color = `rgba(255, 255, 255, ${alpha})`;
                    }
                    
                    ctx.fillStyle = color;
                    ctx.fill();
                }
            }
        }
        
        // Initialize
        const gump = new GumpHybrid();
    </script>
</body>
</html>
