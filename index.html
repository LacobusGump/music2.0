<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Weather + Spatial AI Music</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle at 40% 60%, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
    }

    .app { width: 100%; max-width: 400px; padding: 20px; text-align: center; }

    .logo {
      font-size: clamp(3rem, 12vw, 6rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      margin-bottom: 0.5rem;
      animation: pulse 3s ease-in-out infinite;
    }

    @keyframes pulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.05); } }

    .tagline { font-size: 1.2rem; opacity: 0.8; margin-bottom: 2rem; font-weight: 300; }

    .btn {
      padding: 20px 40px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 30px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(0,255,170,0.3);
      margin: 10px;
    }

    .btn:hover { transform: translateY(-3px); box-shadow: 0 15px 40px rgba(0,255,170,0.5); }

    .weather-status {
      font-size: 1rem;
      margin-bottom: 1.5rem;
      padding: 10px 20px;
      background: rgba(0,255,170,0.1);
      border-radius: 20px;
      border: 1px solid rgba(0,255,170,0.2);
    }

    .footstep-indicator {
      position: fixed;
      top: 50%;
      left: 50%;
      width: 80px;
      height: 80px;
      background: radial-gradient(circle, #00ffaa, transparent);
      border-radius: 50%;
      transform: translate(-50%, -50%) scale(0);
      transition: transform 0.3s ease, opacity 0.5s ease;
      opacity: 0;
      z-index: 5;
    }

    .footstep-indicator.active {
      transform: translate(-50%, -50%) scale(1);
      opacity: 0.8;
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 12px;
      margin: 20px 0;
    }

    .stat {
      background: rgba(0,255,170,0.1);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(0,255,170,0.2);
    }

    .stat-value { font-size: 1.3rem; font-weight: 700; color: #00ffaa; }
    .stat-label { font-size: 0.7rem; opacity: 0.7; margin-top: 3px; }

    .status {
      font-size: 0.9rem;
      color: #4ecdc4;
      opacity: 0.8;
      animation: breathe 2s ease-in-out infinite;
    }

    @keyframes breathe { 0%, 100% { opacity: 0.8; } 50% { opacity: 1; } }

    .error {
      color: #ff4444;
      font-size: 0.9rem;
      margin-top: 1rem;
      padding: 10px;
      background: rgba(255,0,0,0.1);
      border-radius: 10px;
      border: 1px solid rgba(255,0,0,0.3);
    }

    .hidden { display: none !important; }

    body.void {
      background: radial-gradient(circle at 60% 40%, #0a0014 0%, #1a0f2e 40%, #2e1a3e 100%);
      color: #ff88cc;
    }

    body.void .logo {
      background: linear-gradient(45deg, #ff88cc, #88aaff, #ccaa88);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    body.rain {
      background: radial-gradient(circle at 40% 60%, #0a0a1a 0%, #1a2a3e 40%, #0f3460 100%);
    }

    body.storm {
      background: radial-gradient(circle at 40% 60%, #2a0a0a 0%, #3a1a1e 40%, #4e2a3e 100%);
      animation: lightning 6s infinite;
    }

    body.snow {
      background: radial-gradient(circle at 40% 60%, #e6f3ff 0%, #b3d9ff 40%, #80bfff 100%);
      color: #333;
    }

    body.snow .logo {
      background: linear-gradient(45deg, #0066cc, #003d7a, #001a33);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    @keyframes lightning {
      0%, 90%, 100% { filter: brightness(1); }
      91%, 92%, 94%, 96% { filter: brightness(2) contrast(1.5); }
    }
  </style>
</head>
<body>
  <div class="app">
    <div class="logo">GUMP</div>
    <div class="tagline">Your Life, Soundtracked by AI</div>
    <div class="weather-status" id="weather">üå§Ô∏è Loading weather...</div>
    <button class="btn" id="start">üéµ Start Journey</button>
    <button class="btn hidden" id="stop">‚èπ Stop</button>
    <div class="error hidden" id="error"></div>
    <div class="footstep-indicator" id="footstep"></div>
    <div class="stats hidden" id="stats">
      <div class="stat">
        <div class="stat-value" id="steps">0</div>
        <div class="stat-label">Steps</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="bpm">120</div>
        <div class="stat-label">BPM</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="chord">I</div>
        <div class="stat-label">Chord</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="weather-mode">CLEAR</div>
        <div class="stat-label">Weather</div>
      </div>
    </div>
    <div class="status hidden" id="status">Sensing your steps...</div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.steps = 0;
        this.lastStepTime = 0;
        this.bpm = 120;
        this.last = { x: 0, y: 0, z: 0 };
        this.stepHistory = [];
        this.void = false;
        this.weather = 'clear';
        this.weatherSources = [];
        this.voidOscs = [];

        // Musical state
        this.key = 'C';
        this.progression = [0, 3, 5, 0]; // I-IV-vi-I
        this.chordIndex = 0;
        this.step = 0;
        this.measure = 0;

        // Musical data
        this.freqs = {
          C: 261.63, D: 293.66, E: 329.63, F: 349.23,
          G: 392.00, A: 440.00, B: 493.88
        };
        this.chordMap = {
          0: [0, 2, 4], // I - C E G
          1: [1, 3, 5], // ii - D F A
          2: [2, 4, 6], // iii - E G B
          3: [3, 5, 0], // IV - F A C
          4: [4, 6, 1], // V - G B D
          5: [5, 0, 2], // vi - A C E
          6: [6, 1, 3]  // vii - B D F
        };
        this.notes = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];

        this.init();
      }

      init() {
        document.getElementById('start').onclick = () => this.start();
        document.getElementById('stop').onclick = () => this.stop();
        this.getWeather();
        this.setupErrorHandling();
      }

      setupErrorHandling() {
        window.addEventListener('error', (e) => {
          this.showError('Error: ' + e.message);
        });
      }

      showError(message) {
        const errorEl = document.getElementById('error');
        errorEl.textContent = message;
        errorEl.classList.remove('hidden');
        setTimeout(() => errorEl.classList.add('hidden'), 5000);
      }

      async getWeather() {
        try {
          document.getElementById('weather').textContent = 'üåç Getting location...';
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, {
              timeout: 10000,
              enableHighAccuracy: false
            });
          });

          document.getElementById('weather').textContent = 'üå§Ô∏è Fetching weather...';
          const API_KEY = 'YOUR_API_KEY_HERE'; // Replace with your OpenWeatherMap API key
          const url = `https://api.openweathermap.org/data/2.5/weather?lat=${pos.coords.latitude}&lon=${pos.coords.longitude}&appid=${API_KEY}&units=metric`;

          const response = await fetch(url);
          if (!response.ok) throw new Error('Weather API unavailable');

          const data = await response.json();
          this.setWeatherFromData(data);
        } catch (error) {
          console.log('Weather fetch failed:', error);
          this.setDefaultWeather();
        }
      }

      setWeatherFromData(data) {
        const condition = data.weather[0].main.toLowerCase();
        const temp = Math.round(data.main.temp);
        const location = data.name || 'Unknown';

        if (condition.includes('storm') || condition.includes('thunderstorm')) {
          this.weather = 'storm';
        } else if (condition.includes('rain') || condition.includes('drizzle')) {
          this.weather = 'rain';
        } else if (condition.includes('snow')) {
          this.weather = 'snow';
        } else {
          this.weather = 'clear';
        }

        this.applyWeatherTheme();
        document.getElementById('weather').textContent = `üå§Ô∏è ${location} ‚Ä¢ ${temp}¬∞C ‚Ä¢ ${this.weather.toUpperCase()}`;
      }

      setDefaultWeather() {
        this.weather = 'clear';
        this.applyWeatherTheme();
        document.getElementById('weather').textContent = 'üå§Ô∏è Clear weather (simulated)';
      }

      applyWeatherTheme() {
        document.body.className = this.weather;
        document.getElementById('weather-mode').textContent = this.weather.toUpperCase();
      }

      async start() {
        if (this.active) return;

        try {
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.value = 0.7;
          this.masterGain.connect(this.ctx.destination);
          this.weatherGain = this.ctx.createGain();
          this.weatherGain.connect(this.masterGain);

          if (this.ctx.state === 'suspended') await this.ctx.resume();

          this.active = true;
          this.show(['stats', 'status', 'stop']);
          this.hide(['start']);

          this.startSensors();
          this.startEngine();
          this.startWeatherAudio();
        } catch (e) {
          this.showError('Failed to start audio: ' + e.message);
          this.startDesktopMode();
        }
      }

      startDesktopMode() {
        this.showError('Device motion not supported. Using simulated steps.');
        setInterval(() => {
          if (!this.active) return;
          if (Math.random() < 0.3) {
            this.steps++;
            this.lastStepTime = Date.now();
            this.showFootstepIndicator();
            this.playStepSound();
            this.updateBPM();
          }
        }, 500);
      }

      stop() {
        this.active = false;
        this.weatherSources.forEach(source => source.stop());
        this.voidOscs.forEach(osc => osc.stop());
        this.weatherSources = [];
        this.voidOscs = [];
        this.steps = 0;
        this.show(['start']);
        this.hide(['stats', 'status', 'stop']);
        document.body.className = '';
      }

      startSensors() {
        if (typeof DeviceMotionEvent?.requestPermission === 'function') {
          DeviceMotionEvent.requestPermission()
            .then(permission => {
              if (permission === 'granted') {
                window.addEventListener('devicemotion', e => this.handleMotion(e), true);
              } else {
                this.startDesktopMode();
              }
            })
            .catch(() => this.startDesktopMode());
        } else if (window.DeviceMotionEvent) {
          window.addEventListener('devicemotion', e => this.handleMotion(e), true);
        } else {
          this.startDesktopMode();
        }
      }

      handleMotion(event) {
        if (!this.active) return;

        const acc = event.accelerationIncludingGravity;
        if (!acc || acc.z === null) return;

        const dz = Math.abs(acc.z - this.last.z);
        this.stepHistory.push(dz);
        if (this.stepHistory.length > 20) this.stepHistory.shift();

        const avg = this.stepHistory.reduce((a, b) => a + b, 0) / this.stepHistory.length;
        const threshold = avg * 1.8; // Adjusted for footstep sensitivity
        const now = Date.now();

        if (dz > threshold && now - this.lastStepTime > 400) {
          this.steps++;
          this.lastStepTime = now;
          this.showFootstepIndicator();
          this.playStepSound();
          this.updateBPM();
        }

        this.last = { x: acc.x, y: acc.y, z: acc.z };
        this.updateState();
      }

      showFootstepIndicator() {
        const indicator = document.getElementById('footstep');
        indicator.classList.add('active');
        setTimeout(() => indicator.classList.remove('active'), 300);
      }

      updateBPM() {
        if (this.stepHistory.length < 10) return;

        const recentSteps = this.stepHistory.slice(-10);
        const stepIntervals = [];
        let lastPeak = 0;

        for (let i = 1; i < recentSteps.length; i++) {
          if (recentSteps[i] > recentSteps[i - 1] && recentSteps[i] > recentSteps[i + 1]) {
            if (lastPeak) stepIntervals.push(i - lastPeak);
            lastPeak = i;
          }
        }

        if (stepIntervals.length > 0) {
          const avgInterval = stepIntervals.reduce((a, b) => a + b, 0) / stepIntervals.length;
          this.bpm = Math.min(160, Math.max(80, 60000 / (avgInterval * 50)));
        }
      }

      updateState() {
        const stillTime = Date.now() - this.lastStepTime;
        const wasVoid = this.void;

        this.void = stillTime > 3000;
        if (this.void !== wasVoid) {
          document.body.classList.toggle('void', this.void);
          if (this.void) {
            this.startVoidAmbient();
            document.getElementById('status').textContent = '‚ú® Floating in the void...';
          } else {
            this.stopVoidAmbient();
            this.applyWeatherTheme();
            document.getElementById('status').textContent = 'üéµ Flowing with your steps...';
          }
        }
      }

      startVoidAmbient() {
        this.stopVoidAmbient();
        const frequencies = [220, 277.18, 329.63];
        frequencies.forEach((freq, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          osc.type = 'sine';
          osc.frequency.value = freq;
          gain.gain.value = 0;
          gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 1 + i * 0.5);
          osc.connect(gain).connect(this.masterGain);
          osc.start();
          this.voidOscs.push(osc);
        });
      }

      stopVoidAmbient() {
        this.voidOscs.forEach(osc => osc.stop());
        this.voidOscs = [];
      }

      startEngine() {
        const tick = () => {
          if (!this.active) return;

          if (this.step % 8 === 0) {
            this.playBeat();
            this.nextChord();
          }

          this.step++;
          setTimeout(tick, 60000 / this.bpm / 4);
        };
        tick();
      }

      nextChord() {
        this.chordIndex = (this.chordIndex + 1) % this.progression.length;
        const chord = this.progression[this.chordIndex];
        document.getElementById('chord').textContent = this.getChordName(chord);
      }

      playBeat() {
        if (this.step % 8 === 0) this.kick();
        if (this.step % 8 === 4) this.snare();
        if (this.step % 2 === 1) this.hat();
        if (this.step % 8 === 0) this.playChord(this.progression[this.chordIndex]);
      }

      playStepSound() {
        this.kick();
        if (Math.random() < 0.4) this.snare();
        this.playChord(this.progression[this.chordIndex]);
      }

      playChord(chordIndex) {
        const chord = this.chordMap[chordIndex];
        chord.forEach((noteIndex, i) => {
          setTimeout(() => {
            this.playNote(noteIndex, 1, 0.5);
          }, i * 50);
        });
      }

      getChordName(index) {
        const names = ['I', 'ii', 'iii', 'IV', 'V', 'vi', 'vii¬∞'];
        return names[index];
      }

      playNote(noteIndex, octave = 1, duration = 0.5) {
        const note = this.notes[noteIndex];
        const freq = this.freqs[note] * octave;

        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        osc.type = this.void ? 'sine' : 'triangle';
        osc.frequency.value = freq;
        panner.pan.value = Math.random() * 0.4 - 0.2;

        gain.gain.setValueAtTime(0.15, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);

        osc.connect(gain).connect(panner).connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
      }

      kick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        osc.frequency.setValueAtTime(this.void ? 35 : 55, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.1);

        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        panner.pan.value = Math.random() * 0.4 - 0.2;

        osc.connect(gain).connect(panner).connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
      }

      snare() {
        const noise = this.ctx.createBufferSource();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        panner.pan.value = Math.random() * 0.4 - 0.2;

        noise.connect(gain).connect(panner).connect(this.masterGain);
        noise.start();
      }

      hat() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const panner = this.ctx.createStereoPanner();

        osc.type = 'square';
        osc.frequency.value = 10000;

        gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.03);
        panner.pan.value = Math.random() * 0.4 - 0.2;

        osc.connect(gain).connect(panner).connect(this.masterGain);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.03);
      }

      startWeatherAudio() {
        this.weatherSources.forEach(source => source.stop());
        this.weatherSources = [];

        switch (this.weather) {
          case 'rain':
            this.playRainSound();
            break;
          case 'storm':
            this.playStormSound();
            break;
          case 'snow':
            this.playSnowSound();
            break;
          default:
            break;
        }
      }

      playRainSound() {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.1;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.3;
        source.connect(gain).connect(this.weatherGain);
        source.start();
        this.weatherSources.push(source);
      }

      playStormSound() {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.2;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.4;
        source.connect(gain).connect(this.weatherGain);
        source.start();
        this.weatherSources.push(source);

        setInterval(() => {
          if (Math.random() < 0.1 && this.active) this.playThunder();
        }, 10000);
      }

      playThunder() {
        const time = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 5;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.2));
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.8, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 5);
        source.connect(gain).connect(this.weatherGain);
        source.start(time);
      }

      playSnowSound() {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.05;
        }

        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.value = 0.2;
        source.connect(gain).connect(this.weatherGain);
        source.start();
        this.weatherSources.push(source);
      }

      show(ids) { ids.forEach(id => document.getElementById(id).classList.remove('hidden')); }
      hide(ids) { ids.forEach(id => document.getElementById(id).classList.add('hidden')); }
    }

    new GUMP();
  </script>
</body>
</html>
