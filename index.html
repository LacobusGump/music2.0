<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Spatial Motion AI Music</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, sans-serif;
      background: radial-gradient(circle, #0a0a0a 0%, #1a1a2e 50%, #16213e 100%);
      color: #00ffaa;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.5s ease;
    }
    
    body.void {
      background: radial-gradient(circle, #000000 0%, #1a0a1a 50%, #2e161e 100%);
      color: #ff00aa;
    }
    
    .app {
      width: 100%;
      max-width: 400px;
      padding: 20px;
      text-align: center;
    }
    
    .logo {
      font-size: clamp(3rem, 12vw, 6rem);
      font-weight: 900;
      background: linear-gradient(45deg, #00ffaa, #ff6b6b, #4ecdc4);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 0.5rem;
      animation: pulse 2s ease-in-out infinite;
      transition: all 0.3s ease;
    }
    
    .logo.void {
      background: linear-gradient(45deg, #ff00aa, #aa00ff, #ff0066);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: voidGlitch 0.5s ease-in-out infinite;
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.05); }
    }
    
    @keyframes voidGlitch {
      0%, 100% { transform: scale(1) skew(0deg); }
      25% { transform: scale(1.1) skew(2deg); }
      50% { transform: scale(0.95) skew(-1deg); }
      75% { transform: scale(1.05) skew(1deg); }
    }
    
    .tagline {
      font-size: clamp(1rem, 4vw, 1.2rem);
      opacity: 0.8;
      margin-bottom: 3rem;
      font-weight: 300;
      transition: all 0.3s ease;
    }
    
    .tagline.void {
      color: #ff00aa;
      opacity: 1;
      animation: flicker 0.3s ease-in-out infinite;
    }
    
    @keyframes flicker {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.6; }
    }
    
    .start-btn {
      padding: 20px 40px;
      background: linear-gradient(45deg, #00ffaa, #4ecdc4);
      color: #000;
      border: none;
      border-radius: 30px;
      font-size: 1.2rem;
      font-weight: 700;
      cursor: pointer;
      transition: all 0.3s ease;
      box-shadow: 0 10px 30px rgba(0,255,170,0.3);
      margin-bottom: 2rem;
    }
    
    .start-btn:hover { transform: translateY(-3px); box-shadow: 0 15px 40px rgba(0,255,170,0.5); }
    .start-btn:active { transform: translateY(0); }
    
    .spatial-viz {
      width: 100%;
      height: 200px;
      border: 2px solid rgba(0,255,170,0.2);
      border-radius: 20px;
      position: relative;
      overflow: hidden;
      background: rgba(0,255,170,0.03);
      margin-bottom: 2rem;
      transition: all 0.5s ease;
    }
    
    .spatial-viz.void {
      border-color: rgba(255,0,170,0.4);
      background: rgba(255,0,170,0.1);
      animation: voidPulse 0.2s ease-in-out infinite;
    }
    
    @keyframes voidPulse {
      0%, 100% { transform: scale(1); }
      50% { transform: scale(1.02); }
    }
    
    .orb {
      position: absolute;
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: radial-gradient(circle, #00ffaa, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease;
      box-shadow: 0 0 30px rgba(0,255,170,0.5);
    }
    
    .orb.void {
      background: radial-gradient(circle, #ff00aa, transparent);
      box-shadow: 0 0 50px rgba(255,0,170,0.8);
      animation: voidChaos 0.1s ease-in-out infinite;
    }
    
    @keyframes voidChaos {
      0% { transform: translate(-50%, -50%) scale(1); }
      25% { transform: translate(-45%, -55%) scale(1.2); }
      50% { transform: translate(-55%, -45%) scale(0.8); }
      75% { transform: translate(-50%, -50%) scale(1.1); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .stats {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
      margin-bottom: 2rem;
    }
    
    .stat {
      background: rgba(0,255,170,0.1);
      padding: 12px;
      border-radius: 12px;
      border: 1px solid rgba(0,255,170,0.2);
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
    }
    
    .stat.void {
      background: rgba(255,0,170,0.2);
      border-color: rgba(255,0,170,0.4);
      animation: statGlitch 0.3s ease-in-out infinite;
    }
    
    @keyframes statGlitch {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-2px); }
      75% { transform: translateX(2px); }
    }
    
    .stat-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: #00ffaa;
      transition: color 0.3s ease;
    }
    
    .stat-value.void {
      color: #ff00aa;
    }
    
    .stat-label {
      font-size: 0.7rem;
      opacity: 0.7;
      margin-top: 3px;
    }
    
    .status {
      font-size: 0.9rem;
      color: #4ecdc4;
      opacity: 0.8;
      animation: breathe 2s ease-in-out infinite;
      transition: all 0.3s ease;
    }
    
    .status.void {
      color: #ff00aa;
      animation: voidBreathe 0.5s ease-in-out infinite;
    }
    
    @keyframes breathe {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
    
    @keyframes voidBreathe {
      0%, 100% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.6; transform: scale(1.05); }
    }
    
    .hidden { display: none !important; }
    
    .error {
      background: rgba(255,107,107,0.1);
      border: 1px solid rgba(255,107,107,0.3);
      border-radius: 15px;
      padding: 20px;
      color: #ff6b6b;
      margin-top: 20px;
    }
    
    .void-particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: -1;
    }
    
    .void-particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: #ff00aa;
      animation: voidParticle 2s linear infinite;
    }
    
    @keyframes voidParticle {
      0% { transform: scale(0) rotate(0deg); opacity: 0; }
      50% { transform: scale(1) rotate(180deg); opacity: 1; }
      100% { transform: scale(0) rotate(360deg); opacity: 0; }
    }

    .weather-status {
      font-size: 0.9rem;
      margin-bottom: 1rem;
      padding: 8px 15px;
      background: rgba(0,255,170,0.1);
      border-radius: 15px;
      border: 1px solid rgba(0,255,170,0.2);
      transition: all 0.3s ease;
    }

    .weather-status.void {
      color: #ff00aa;
      background: rgba(255,0,170,0.2);
      border-color: rgba(255,0,170,0.4);
    }

    body.rain {
      background: radial-gradient(circle, #0a0a1a 0%, #1a2a3e 50%, #0f3460 100%);
    }

    body.storm {
      background: radial-gradient(circle, #2a0a0a 0%, #3a1a1e 50%, #4e2a3e 100%);
      animation: lightning 6s infinite;
    }

    body.snow {
      background: radial-gradient(circle, #e6f3ff 0%, #b3d9ff 50%, #80bfff 100%);
      color: #333;
    }

    body.snow .logo {
      background: linear-gradient(45deg, #0066cc, #003d7a, #001a33);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    body.snow .stat-value {
      color: #0066cc;
    }

    @keyframes lightning {
      0%, 90%, 100% { filter: brightness(1); }
      91%, 92%, 94%, 96% { filter: brightness(2) contrast(1.5); }
    }
  </style>
</head>
<body>
  <div class="void-particles" id="voidParticles"></div>
  
  <div class="app">
    <div class="logo" id="logo">GUMP</div>
    <div class="tagline" id="tagline">Your Life, Soundtracked by AI</div>
    <div class="weather-status hidden" id="weather">üå§Ô∏è Loading weather...</div>
    <button class="start-btn" id="start">üéµ Start Spatial Audio</button>
    <div class="spatial-viz hidden" id="viz">
      <div class="orb" id="orb"></div>
    </div>
    
    <div class="stats hidden" id="stats">
      <div class="stat" id="motionStat">
        <div class="stat-value" id="motion">0</div>
        <div class="stat-label">Motion</div>
      </div>
      <div class="stat" id="bpmStat">
        <div class="stat-value" id="bpm">95</div>
        <div class="stat-label">BPM</div>
      </div>
      <div class="stat" id="grooveStat">
        <div class="stat-value" id="groove">CHILL</div>
        <div class="stat-label">Groove</div>
      </div>
    </div>
    
    <div class="status hidden" id="status">üéµ Flowing with your vibe...</div>
    <div class="error hidden" id="error">Motion sensors unavailable. Please use a mobile device.</div>
  </div>

  <script>
    class SpatialAI {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 95;
        this.pos = { x: 50, y: 50 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.groove = 'CHILL';
        this.weather = 'clear';
        this.weatherSources = [];
        this.void = false;
        this.voidTimer = 0;
        this.voidThreshold = 1000;
        this.lastMotionTime = Date.now();
        this.voidIntensity = 0;
        this.voidStep = 0;
        this.chaosOscillators = [];

        // J Dilla inspired swing timing
        this.swing = [0, 0.1, 0, 0.15, 0, 0.08, 0, 0.12];
        
        // Groove patterns
        this.patterns = {
          kick: [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0],
          snare: [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0],
          hat: [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
        };
        
        // Void chaos patterns
        this.voidPatterns = {
          chaos: [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0],
          reverse: [0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0],
          glitch: [1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1]
        };

        this.init();
      }
      
      init() {
        document.getElementById('start').onclick = () => this.start();
        this.getWeather();
        this.setupErrorHandling();
      }
      
      setupErrorHandling() {
        window.addEventListener('error', (e) => this.showError('Error: ' + e.message));
      }

      showError(message) {
        console.error('GUMP Error:', message);
        const errorEl = document.getElementById('error');
        errorEl.textContent = message;
        errorEl.classList.remove('hidden');
        setTimeout(() => errorEl.classList.add('hidden'), 5000);
      }

      async getWeather() {
        try {
          document.getElementById('weather').classList.remove('hidden');
          document.getElementById('weather').textContent = 'üåç Getting location...';
          const pos = await new Promise((resolve, reject) => {
            navigator.geolocation.getCurrentPosition(resolve, reject, { timeout: 5000 });
          });

          document.getElementById('weather').textContent = 'üå§Ô∏è Fetching weather...';
          const API_KEY = 'YOUR_API_KEY_HERE'; // Replace with your OpenWeatherMap API key
          if (API_KEY === 'YOUR_API_KEY_HERE') {
            throw new Error('Invalid API key. Please provide a valid OpenWeatherMap API key.');
          }
          const url = `https://api.openweathermap.org/data/2.5/weather?lat=${pos.coords.latitude}&lon=${pos.coords.longitude}&appid=${API_KEY}&units=metric`;

          const response = await fetch(url);
          if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Weather API request failed: ${response.status} ${response.statusText} - ${errorText}`);
          }

          const data = await response.json();
          this.setWeatherFromData(data);
        } catch (error) {
          console.error('Weather fetch failed:', error.message);
          this.showError(`Weather fetch failed: ${error.message}`);
          this.setDefaultWeather();
        }
      }

      setWeatherFromData(data) {
        const condition = data.weather[0].main.toLowerCase();
        const temp = Math.round(data.main.temp);
        const location = data.name || 'Unknown';

        if (condition.includes('storm') || condition.includes('thunderstorm')) {
          this.weather = 'storm';
        } else if (condition.includes('rain') || condition.includes('drizzle')) {
          this.weather = 'rain';
        } else if (condition.includes('snow')) {
          this.weather = 'snow';
        } else {
          this.weather = 'clear';
        }

        this.applyWeatherTheme();
        document.getElementById('weather').textContent = `üå§Ô∏è ${location} ‚Ä¢ ${temp}¬∞C ‚Ä¢ ${this.weather.toUpperCase()}`;
        if (this.active) this.startWeatherAudio();
      }

      setDefaultWeather() {
        this.weather = 'clear';
        this.applyWeatherTheme();
        document.getElementById('weather').textContent = 'üå§Ô∏è Clear (simulated)';
        if (this.active) this.startWeatherAudio();
      }

      applyWeatherTheme() {
        document.body.className = this.void ? 'void' : this.weather;
        document.getElementById('weather').classList.toggle('void', this.void);
        document.getElementById('groove').textContent = this.void ? 'VOID' : this.groove;
      }
      
      async start() {
        if (this.active) return;
        
        try {
          console.log('Starting GUMP...');
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            console.log('Requesting motion permission...');
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') throw new Error('Motion permission denied');
          } else if (!window.DeviceMotionEvent) {
            throw new Error('Device motion not supported');
          }
          
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          console.log('AudioContext created, state:', this.ctx.state);

          this.masterGain = this.ctx.createGain();
          this.masterGain.gain.setValueAtTime(0.9, this.ctx.currentTime);
          this.masterGain.connect(this.ctx.destination);
          this.weatherGain = this.ctx.createGain();
          this.weatherGain.gain.setValueAtTime(0.5, this.ctx.currentTime);
          this.weatherGain.connect(this.masterGain);

          if (this.ctx.state === 'suspended') {
            console.log('Attempting to resume AudioContext...');
            await this.ctx.resume();
            if (this.ctx.state === 'suspended') throw new Error('AudioContext failed to resume');
          }
          console.log('AudioContext resumed, state:', this.ctx.state);

          // Play loud test sound
          this.playTestSound();
          
          document.getElementById('start').classList.add('hidden');
          ['viz', 'stats', 'status', 'weather'].forEach(id => 
            document.getElementById(id).classList.remove('hidden')
          );
          
          this.active = true;
          this.startSensors();
          this.startGroove();
          this.startWeatherAudio();
          this.animate();
          this.checkVoidState();
          
        } catch (error) {
          this.showError('Failed to start: ' + error.message);
          console.error('Start failed:', error.message);
        }
      }
      
      playTestSound() {
        console.log('Playing test sound (440Hz, 2s, gain 0.7)...');
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(440, this.ctx.currentTime);
        gain.gain.setValueAtTime(0.7, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        osc.connect(gain).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 2);
      }

      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) {
            this.showError('No motion data available');
            console.warn('No motion data:', acc);
            return;
          }
          
          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);
          
          this.motion = Math.min(100, Math.sqrt(dx*dx + dy*dy + dz*dz) * 20);
          this.last = { x: acc.x, y: acc.y, z: acc.z };
          
          if (this.motion > 5) {
            console.log(`Motion detected: motion=${this.motion.toFixed(2)}`);
            this.lastMotionTime = Date.now();
          }
          
          this.pos.x = Math.max(10, Math.min(90, 50 + acc.x * 4));
          this.pos.y = Math.max(10, Math.min(90, 50 + acc.y * 4));
          
          this.updateGroove();
          
        }, { passive: true });
      }
      
      checkVoidState() {
        const checkVoid = () => {
          if (!this.active) return;
          
          const timeSinceMotion = Date.now() - this.lastMotionTime;
          const shouldBeInVoid = timeSinceMotion > this.voidThreshold;
          
          if (shouldBeInVoid && !this.void) {
            this.enterVoid();
          } else if (!shouldBeInVoid && this.void) {
            this.exitVoid();
          }
          
          if (this.void) {
            this.voidIntensity = Math.min(1, (timeSinceMotion - this.voidThreshold) / 2000);
          }
          
          setTimeout(checkVoid, 100);
        };
        
        checkVoid();
      }
      
      enterVoid() {
        this.void = true;
        this.voidIntensity = 0;
        this.voidStep = 0;
        
        document.body.classList.add('void');
        document.getElementById('logo').classList.add('void');
        document.getElementById('tagline').classList.add('void');
        document.getElementById('viz').classList.add('void');
        document.getElementById('orb').classList.add('void');
        document.getElementById('weather').classList.add('void');
        ['motionStat', 'bpmStat', 'grooveStat'].forEach(id => 
          document.getElementById(id).classList.add('void')
        );
        ['motion', 'bpm', 'groove'].forEach(id => 
          document.getElementById(id).classList.add('void')
        );
        document.getElementById('status').classList.add('void');
        
        this.createVoidParticles();
        console.log('Entering void mode');
      }
      
      exitVoid() {
        this.void = false;
        this.voidIntensity = 0;
        this.cleanupChaos();
        
        document.body.classList.remove('void');
        document.getElementById('logo').classList.remove('void');
        document.getElementById('tagline').classList.remove('void');
        document.getElementById('viz').classList.remove('void');
        document.getElementById('orb').classList.remove('void');
        document.getElementById('weather').classList.remove('void');
        ['motionStat', 'bpmStat', 'grooveStat'].forEach(id => 
          document.getElementById(id).classList.remove('void')
        );
        ['motion', 'bpm', 'groove'].forEach(id => 
          document.getElementById(id).classList.remove('void')
        );
        document.getElementById('status').classList.remove('void');
        
        this.clearVoidParticles();
        this.applyWeatherTheme();
        console.log('Exiting void mode');
      }
      
      createVoidParticles() {
        const container = document.getElementById('voidParticles');
        container.innerHTML = '';
        for (let i = 0; i < 20; i++) {
          const particle = document.createElement('div');
          particle.className = 'void-particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.top = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 2 + 's';
          container.appendChild(particle);
        }
      }
      
      clearVoidParticles() {
        const container = document.getElementById('voidParticles');
        container.innerHTML = '';
      }
      
      updateGroove() {
        if (this.void) {
          this.groove = 'VOID';
          this.bpm = 60 + (this.voidIntensity * 80) + (Math.random() * 40 - 20);
        } else if (this.motion < 20) {
          this.groove = 'CHILL';
          this.bpm = 85 + this.motion * 0.3;
        } else if (this.motion < 50) {
          this.groove = 'POCKET';
          this.bpm = 95 + this.motion * 0.2;
        } else {
          this.groove = 'BOUNCE';
          this.bpm = 105 + this.motion * 0.15;
        }
        document.getElementById('groove').textContent = this.groove;
        document.getElementById('bpm').textContent = Math.round(this.bpm);
        document.getElementById('motion').textContent = Math.round(this.motion);
      }
      
      startGroove() {
        console.log('Starting music engine');
        const tick = () => {
          if (!this.active) return;
          
          if (this.void) {
            this.playVoidChaos();
          } else {
            this.playGroove();
          }
          
          this.step = (this.step + 1) % 16;
          this.voidStep = (this.voidStep + 1) % 16;
          
          const swingDelay = this.void ? 
            (Math.random() * 100 - 50) : 
            this.swing[this.step % 8] * 50;
          
          const baseInterval = this.void ? 
            (60000 / this.bpm / 4) * (0.5 + Math.random()) : 
            (60000 / this.bpm / 4);
          
          setTimeout(tick, baseInterval + swingDelay);
        };
        
        tick();
      }
      
      playVoidChaos() {
        console.log('Playing void chaos, intensity:', this.voidIntensity.toFixed(2));
        if (this.voidIntensity < 0.1 && Math.random() < 0.3) {
          this.voidSuspense();
        }
        
        if (this.voidPatterns.chaos[this.voidStep]) {
          console.log('Playing chaos kick');
          this.chaosKick();
        }
        
        if (this.voidPatterns.reverse[this.voidStep]) {
          console.log('Playing reverse snare');
          this.reverseSnare();
        }
        
        if (this.voidPatterns.glitch[this.voidStep] && Math.random() < this.voidIntensity) {
          console.log('Playing glitch hat');
          this.glitchHat();
        }
        
        if (Math.random() < this.voidIntensity * 0.3) {
          console.log('Playing chaos wave');
          this.chaosWave();
        }
      }
      
      playGroove() {
        console.log('Playing groove, step:', this.step);
        if (this.patterns.kick[this.step]) {
          console.log('Playing kick');
          this.kick();
        }
        if (this.patterns.snare[this.step]) {
          console.log('Playing snare');
          this.snare();
        }
        if (this.patterns.hat[this.step]) {
          console.log('Playing hat');
          this.hat();
        }
      }
      
      voidSuspense() {
        console.log('Playing void suspense');
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(40 + Math.random() * 20, this.ctx.currentTime);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 1);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
        osc.connect(gain).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 3);
      }
      
      chaosKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(80 + Math.random() * 40, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.2);
        gain.gain.setValueAtTime(0.9, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        osc.connect(gain).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 0.4);
      }
      
      reverseSnare() {
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.3, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          const progress = i / data.length;
          data[i] = (Math.random() * 2 - 1) * progress;
        }
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        source.buffer = buffer;
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        source.connect(gain).connect(this.masterGain);
        source.start(this.ctx.currentTime);
      }
      
      glitchHat() {
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.02, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = (Math.random() > 0.5 ? 1 : -1) * Math.random();
        }
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        source.buffer = buffer;
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.02);
        source.connect(gain).connect(this.masterGain);
        source.start(this.ctx.currentTime);
      }
      
      chaosWave() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(200 + Math.random() * 800, this.ctx.currentTime);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 0.05);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        osc.connect(gain).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 0.2);
        this.chaosOscillators.push(osc);
      }
      
      cleanupChaos() {
        console.log('Cleaning up chaos oscillators');
        this.chaosOscillators.forEach(osc => osc.stop());
        this.chaosOscillators = [];
      }
      
      kick() {
        console.log('Playing kick');
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.9, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        osc.connect(gain).connect(this.masterGain);
        osc.start(this.ctx.currentTime);
        osc.stop(this.ctx.currentTime + 0.4);
      }
      
      snare() {
        console.log('Playing snare');
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        source.buffer = buffer;
        gain.gain.setValueAtTime(0.7, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        source.connect(gain).connect(this.masterGain);
        source.start(this.ctx.currentTime);
      }
      
      hat() {
        console.log('Playing hat');
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.02, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        const source = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        source.buffer = buffer;
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.02);
        source.connect(gain).connect(this.masterGain);
        source.start(this.ctx.currentTime);
      }
      
      startWeatherAudio() {
        console.log('Starting weather audio:', this.weather);
        this.weatherSources.forEach(source => {
          console.log('Stopping weather source');
          source.stop();
        });
        this.weatherSources = [];

        switch (this.weather) {
          case 'rain':
            this.playRainSound();
            break;
          case 'storm':
            this.playStormSound();
            break;
          case 'snow':
            this.playSnowSound();
            break;
          default:
            break;
        }
      }

      playRainSound() {
        console.log('Playing rain sound');
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.1;
        }
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        source.connect(gain).connect(this.weatherGain);
        source.start(this.ctx.currentTime);
        this.weatherSources.push(source);
      }

      playStormSound() {
        console.log('Playing storm sound');
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.2;
        }
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        source.connect(gain).connect(this.weatherGain);
        source.start(this.ctx.currentTime);
        this.weatherSources.push(source);

        setInterval(() => {
          if (Math.random() < 0.1 && this.active) this.playThunder();
        }, 8000);
      }

      playThunder() {
        console.log('Playing thunder sound');
        const time = this.ctx.currentTime;
        const bufferSize = this.ctx.sampleRate * 4;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (bufferSize * 0.2));
        }
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.7, time);
        gain.gain.exponentialRampToValueAtTime(0.001, time + 4);
        source.connect(gain).connect(this.weatherGain);
        source.start(time);
        this.weatherSources.push(source);
      }

      playSnowSound() {
        console.log('Playing snow sound');
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = (Math.random() * 2 - 1) * 0.05;
        }
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        const gain = this.ctx.createGain();
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        source.connect(gain).connect(this.weatherGain);
        source.start(this.ctx.currentTime);
        this.weatherSources.push(source);
      }
      
      animate() {
        const orb = document.getElementById('orb');
        orb.style.left = this.pos.x + '%';
        orb.style.top = this.pos.y + '%';
        
        document.getElementById('motion').textContent = Math.round(this.motion);
        document.getElementById('bpm').textContent = Math.round(this.bpm);
        document.getElementById('groove').textContent = this.groove;
        
        if (this.active) {
          requestAnimationFrame(() => this.animate());
        }
      }
      
    }

    new SpatialAI();
  </script>
</body>
</html>
