<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: 12 Seeds of Motion</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 3px;
      backdrop-filter: blur(15px);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
      transform: scale(1.1);
    }
    
    .motion-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
    }
    
    .motion-space.active { opacity: 1; }
    
    .seed-indicator {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      pointer-events: none;
    }
    
    .seed-indicator.active {
      box-shadow: 0 0 40px currentColor;
      animation: seedPulse 2s ease-in-out infinite;
    }
    
    @keyframes seedPulse {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
    
    .pattern-viz {
      position: fixed;
      top: 20px;
      right: 20px;
      width: 200px;
      height: 120px;
      background: rgba(0,0,0,0.5);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 8px;
      padding: 10px;
      backdrop-filter: blur(10px);
    }
    
    .pattern-line {
      height: 2px;
      background: rgba(255,255,255,0.3);
      margin: 4px 0;
      transform-origin: left;
      transition: all 0.3s ease;
    }
    
    .ui-minimal {
      position: fixed;
      bottom: 20px;
      left: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.7);
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 12px 16px;
      border-radius: 6px;
      backdrop-filter: blur(15px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .seed-name {
      font-size: 12px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 6px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 9px;
    }
    
    .hidden { display: none !important; }
    
    .motion-trail {
      position: fixed;
      pointer-events: none;
      opacity: 0.6;
    }
    
    .motion-dot {
      position: absolute;
      width: 4px;
      height: 4px;
      background: rgba(255,255,255,0.5);
      border-radius: 50%;
      animation: fade 2s linear forwards;
    }
    
    @keyframes fade {
      to { opacity: 0; transform: scale(0); }
    }
    
    .agent-thought {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 11px;
      color: rgba(255,255,255,0.6);
      text-align: center;
      letter-spacing: 1px;
      opacity: 0;
      transition: opacity 0.5s ease;
    }
    
    .agent-thought.show { opacity: 1; }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN
    </div>
  </div>
  
  <div class="motion-space" id="motionSpace">
    <div class="motion-trail" id="motionTrail"></div>
    
    <div class="agent-thought" id="agentThought"></div>
    
    <div class="pattern-viz" id="patternViz">
      <div class="pattern-line" id="pattern1"></div>
      <div class="pattern-line" id="pattern2"></div>
      <div class="pattern-line" id="pattern3"></div>
      <div class="pattern-line" id="pattern4"></div>
    </div>
    
    <div class="ui-minimal" id="uiMinimal">
      <div class="seed-name" id="seedName">VOID</div>
      <div class="metric">SEEDS: <span id="activeSeeds">0</span>/12</div>
      <div class="metric">SYNC: <span id="syncLevel">0%</span></div>
      <div class="metric">PATTERN: <span id="patternType">SEARCHING</span></div>
    </div>
  </div>

  <script>
    // Base Agent Classes First
    class MusicAgent {
      constructor() {
        this.state = 'listening';
        this.memory = [];
        this.syncPartners = [];
        this.beatInterval = 1;
      }

      init(ctx, destination) {
        this.ctx = ctx;
        this.output = ctx.createGain();
        this.output.gain.value = 0.5;
        this.output.connect(destination);
      }

      think(motion, syncLevel) {
        // Override in subclasses
      }

      update(motion, ctx) {
        // Override in subclasses
      }

      updateSync(syncLevel, activeSeeds) {
        // Override in subclasses
      }

      syncWith(otherAgent) {
        if (!this.syncPartners.includes(otherAgent)) {
          this.syncPartners.push(otherAgent);
        }
      }

      playTone(freq, duration = 0.5, type = 'sine') {
        if (!this.ctx || !this.output) return;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.05);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
        
        gain.gain.value = 0.3;
        
        osc.connect(env).connect(gain).connect(this.output);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
        
        return { osc, gain, env };
      }
    }

    // Individual Seed Agents
    class PulseAgent extends MusicAgent {
      constructor() {
        super();
        this.beatInterval = 1;
        this.lastBeat = 0;
      }

      think(motion, syncLevel) {
        // Adjust tempo based on motion intensity
        this.beatInterval = 0.5 + (1 - motion.current / 10) * 2;
        
        // Sync with others if sync level is high
        if (syncLevel > 0.5 && this.syncPartners.length > 0) {
          // Average beat intervals
          const partnerIntervals = this.syncPartners.map(p => p.beatInterval || 1);
          const avgInterval = partnerIntervals.reduce((a, b) => a + b, this.beatInterval) / (partnerIntervals.length + 1);
          this.beatInterval = this.beatInterval * 0.7 + avgInterval * 0.3;
        }
      }

      update(motion, ctx) {
        if (!ctx) return;
        const now = ctx.currentTime;
        
        if (now - this.lastBeat > this.beatInterval) {
          this.playTone(60, 0.2, 'sine');
          this.lastBeat = now;
        }
      }
    }

    class BreathAgent extends MusicAgent {
      constructor() {
        super();
        this.phase = 0;
        this.breathRate = 0.1;
      }

      think(motion, syncLevel) {
        // Slower breath with less motion
        this.breathRate = 0.05 + motion.current * 0.02;
      }

      update(motion, ctx) {
        if (!ctx) return;
        this.phase += this.breathRate;
        
        if (Math.random() < 0.05) {
          const freq = 440 + Math.sin(this.phase) * 100;
          this.playTone(freq, 2, 'triangle');
        }
      }
    }

    class SparkAgent extends MusicAgent {
      constructor() {
        super();
        this.energy = 0;
      }

      think(motion, syncLevel) {
        // Build energy from taps
        if (motion.patterns && motion.patterns.tap > 0.5) {
          this.energy = Math.min(this.energy + 0.1, 1);
        } else {
          this.energy *= 0.95;
        }
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.energy > 0.3 && Math.random() < this.energy * 0.2) {
          const freq = 880 + Math.random() * 440;
          this.playTone(freq, 0.1, 'square');
        }
      }
    }

    class FlowAgent extends MusicAgent {
      constructor() {
        super();
        this.flowPhase = 0;
      }

      think(motion, syncLevel) {
        if (motion.patterns && motion.patterns.circular > 0.5) {
          this.flowPhase += 0.1;
        }
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (Math.random() < 0.1) {
          const freq = 220 * (1 + Math.sin(this.flowPhase) * 0.5);
          const duration = 1 + Math.sin(this.flowPhase * 0.5);
          this.playTone(freq, duration, 'sine');
        }
      }
    }

    class CrystalAgent extends MusicAgent {
      constructor() {
        super();
        this.sharpness = 0;
      }

      think(motion, syncLevel) {
        this.sharpness = motion.patterns ? motion.patterns.angular : 0;
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.sharpness > 0.3 && Math.random() < 0.1) {
          const freq = 1320 + Math.random() * 660 * this.sharpness;
          this.playTone(freq, 0.2, 'sawtooth');
        }
      }
    }

    class ShadowAgent extends MusicAgent {
      constructor() {
        super();
        this.echoBuffer = [];
      }

      think(motion, syncLevel) {
        // Record what other agents are doing
        this.state = motion.patterns && motion.patterns.stillness > 0.5 ? 'echoing' : 'listening';
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.state === 'echoing' && this.echoBuffer.length > 0) {
          const echo = this.echoBuffer.shift();
          this.playTone(echo.freq * 0.5, echo.duration * 1.5, 'sine');
        }
      }

      recordEcho(freq, duration) {
        this.echoBuffer.push({ freq, duration });
        if (this.echoBuffer.length > 5) this.echoBuffer.shift();
      }
    }

    class LightAgent extends MusicAgent {
      constructor() {
        super();
        this.brightness = 0;
      }

      think(motion, syncLevel) {
        this.brightness = motion.patterns ? motion.patterns.acceleration : 0;
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.brightness > 0.5 && Math.random() < 0.15) {
          const freq = 660 * (1 + this.brightness);
          this.playTone(freq, 0.3, 'triangle');
        }
      }
    }

    class EarthAgent extends MusicAgent {
      constructor() {
        super();
        this.grounded = false;
      }

      think(motion, syncLevel) {
        this.grounded = motion.patterns && motion.patterns.downward > 0.5;
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.grounded && Math.random() < 0.1) {
          this.playTone(55, 2, 'sine');
        }
      }
    }

    class VoidAgent extends MusicAgent {
      constructor() {
        super();
        this.silence = 0;
      }

      think(motion, syncLevel) {
        // The void responds to pattern breaks
        this.silence = 1 - motion.current / 10;
      }

      update(motion, ctx) {
        if (!ctx) return;
        // Void creates space by dampening other sounds
        this.output.gain.value = 0.1 + this.silence * 0.4;
        
        if (Math.random() < 0.05) {
          this.playTone(27.5, 5, 'sine');
        }
      }
    }

    class StormAgent extends MusicAgent {
      constructor() {
        super();
        this.chaos = 0;
      }

      think(motion, syncLevel) {
        this.chaos = motion.patterns ? motion.patterns.shake : 0;
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.chaos > 0.5) {
          for (let i = 0; i < this.chaos * 3; i++) {
            setTimeout(() => {
              const freq = 100 + Math.random() * 2000;
              this.playTone(freq, 0.1, 'sawtooth');
            }, Math.random() * 200);
          }
        }
      }
    }

    class HarmonyAgent extends MusicAgent {
      constructor() {
        super();
        this.harmonicSeries = [1, 2, 3, 4, 5, 6, 8];
      }

      think(motion, syncLevel) {
        this.state = syncLevel > 0.7 ? 'harmonizing' : 'searching';
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.state === 'harmonizing' && Math.random() < 0.1) {
          const fundamental = 528;
          const harmonic = this.harmonicSeries[Math.floor(Math.random() * this.harmonicSeries.length)];
          this.playTone(fundamental * harmonic, 1.5, 'sine');
        }
      }
    }

    class TranscendAgent extends MusicAgent {
      constructor() {
        super();
        this.transcendence = 0;
      }

      think(motion, syncLevel) {
        // Only active when all seeds are active
        this.transcendence = syncLevel;
      }

      update(motion, ctx) {
        if (!ctx) return;
        if (this.transcendence > 0.9 && Math.random() < 0.05) {
          // Play the universal frequency
          this.playTone(432, 3, 'sine');
          
          // Harmonize with golden ratio
          setTimeout(() => {
            this.playTone(432 * 1.618, 2, 'sine');
          }, 500);
        }
      }
    }

    // Pattern Analyzer
    class PatternAnalyzer {
      analyze(buffer) {
        const patterns = {
          sustained: this.detectSustained(buffer),
          wave: this.detectWave(buffer),
          tap: this.detectTap(buffer),
          circular: this.detectCircular(buffer),
          angular: this.detectAngular(buffer),
          stillness: this.detectStillness(buffer),
          acceleration: this.detectAcceleration(buffer),
          downward: this.detectDownward(buffer),
          shake: this.detectShake(buffer),
          sync: 0
        };
        
        return patterns;
      }

      detectSustained(buffer) {
        if (buffer.length < 10) return 0;
        
        const recent = buffer.slice(-10);
        const avgMag = recent.reduce((sum, d) => sum + d.magnitude, 0) / recent.length;
        const variance = recent.reduce((sum, d) => sum + Math.abs(d.magnitude - avgMag), 0) / recent.length;
        
        return avgMag > 2 && variance < 1 ? Math.min(avgMag / 5, 1) : 0;
      }

      detectWave(buffer) {
        if (buffer.length < 20) return 0;
        
        const magnitudes = buffer.slice(-20).map(d => d.magnitude);
        let waveScore = 0;
        
        // Look for sinusoidal pattern
        for (let i = 1; i < magnitudes.length - 1; i++) {
          const prev = magnitudes[i - 1];
          const curr = magnitudes[i];
          const next = magnitudes[i + 1];
          
          if ((curr > prev && curr > next) || (curr < prev && curr < next)) {
            waveScore += 0.1;
          }
        }
        
        return Math.min(waveScore, 1);
      }

      detectTap(buffer) {
        if (buffer.length < 10) return 0;
        
        const peaks = [];
        const magnitudes = buffer.map(d => d.magnitude);
        
        for (let i = 1; i < magnitudes.length - 1; i++) {
          if (magnitudes[i] > magnitudes[i-1] && magnitudes[i] > magnitudes[i+1] && magnitudes[i] > 3) {
            peaks.push(i);
          }
        }
        
        if (peaks.length < 2) return 0;
        
        // Check for regular intervals
        const intervals = [];
        for (let i = 1; i < peaks.length; i++) {
          intervals.push(peaks[i] - peaks[i-1]);
        }
        
        const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
        const variance = intervals.reduce((sum, int) => sum + Math.abs(int - avgInterval), 0) / intervals.length;
        
        return variance < 2 ? Math.min(peaks.length / 5, 1) : 0;
      }

      detectCircular(buffer) {
        if (buffer.length < 15) return 0;
        
        const vectors = buffer.slice(-15).map(d => d.vector);
        let circularScore = 0;
        
        // Calculate angular momentum
        for (let i = 1; i < vectors.length; i++) {
          const angle1 = Math.atan2(vectors[i-1].y, vectors[i-1].x);
          const angle2 = Math.atan2(vectors[i].y, vectors[i].x);
          let diff = angle2 - angle1;
          
          // Normalize angle difference
          if (diff > Math.PI) diff -= 2 * Math.PI;
          if (diff < -Math.PI) diff += 2 * Math.PI;
          
          // Consistent rotation direction scores higher
          if (Math.abs(diff) > 0.1 && Math.abs(diff) < 1) {
            circularScore += 0.1;
          }
        }
        
        return Math.min(circularScore, 1);
      }

      detectAngular(buffer) {
        if (buffer.length < 10) return 0;
        
        const vectors = buffer.slice(-10).map(d => d.vector);
        let angularScore = 0;
        
        for (let i = 1; i < vectors.length; i++) {
          const angle1 = Math.atan2(vectors[i-1].y, vectors[i-1].x);
          const angle2 = Math.atan2(vectors[i].y, vectors[i].x);
          const diff = Math.abs(angle2 - angle1);
          
          // Sharp angle changes
          if (diff > Math.PI / 3) {
            angularScore += 0.2;
          }
        }
        
        return Math.min(angularScore, 1);
      }

      detectStillness(buffer) {
        if (buffer.length < 20) return 0;
        
        const recent = buffer.slice(-20);
        const avgMag = recent.reduce((sum, d) => sum + d.magnitude, 0) / recent.length;
        
        return avgMag < 0.5 ? 1 - avgMag * 2 : 0;
      }

      detectAcceleration(buffer) {
        if (buffer.length < 5) return 0;
        
        const recent = buffer.slice(-5);
        let accelScore = 0;
        
        for (let i = 1; i < recent.length; i++) {
          const dMag = recent[i].magnitude - recent[i-1].magnitude;
          if (dMag > 1) {
            accelScore += dMag / 10;
          }
        }
        
        return Math.min(accelScore, 1);
      }

      detectDownward(buffer) {
        if (buffer.length < 10) return 0;
        
        const recent = buffer.slice(-10);
        const downwardSum = recent.reduce((sum, d) => {
          return sum + (d.acceleration.y > 0 ? d.acceleration.y : 0);
        }, 0);
        
        return Math.min(downwardSum / 50, 1);
      }

      detectShake(buffer) {
        if (buffer.length < 10) return 0;
        
        const recent = buffer.slice(-10);
        const magnitudes = recent.map(d => d.magnitude);
        
        let shakeScore = 0;
        for (let i = 1; i < magnitudes.length; i++) {
          if (magnitudes[i] > 5 && magnitudes[i-1] > 5) {
            shakeScore += 0.2;
          }
        }
        
        return Math.min(shakeScore, 1);
      }

      detectPatternBreak(buffer) {
        // This would be more sophisticated in reality
        if (buffer.length < 30) return false;
        
        const firstHalf = buffer.slice(0, 15);
        const secondHalf = buffer.slice(15, 30);
        
        const pattern1 = this.getPatternSignature(firstHalf);
        const pattern2 = this.getPatternSignature(secondHalf);
        
        return this.patternsAreDifferent(pattern1, pattern2);
      }

      getPatternSignature(buffer) {
        return {
          avgMag: buffer.reduce((sum, d) => sum + d.magnitude, 0) / buffer.length,
          variance: this.calculateVariance(buffer.map(d => d.magnitude))
        };
      }

      calculateVariance(values) {
        const avg = values.reduce((a, b) => a + b, 0) / values.length;
        return values.reduce((sum, val) => sum + Math.pow(val - avg, 2), 0) / values.length;
      }

      patternsAreDifferent(p1, p2) {
        return Math.abs(p1.avgMag - p2.avgMag) > 2 || 
               Math.abs(p1.variance - p2.variance) > 1;
      }
    }

    // Main Engine
    class AgenticMusicEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        
        // 12 Core Musical Seeds with specific unlock conditions
        this.seeds = {
          pulse: {
            name: 'PULSE',
            active: false,
            color: '#ff3333',
            freq: 60,
            pattern: 'heartbeat',
            unlockCondition: 'sustained_motion',
            agent: new PulseAgent(),
            voices: []
          },
          breath: {
            name: 'BREATH',
            active: false,
            color: '#3366ff',
            freq: 440,
            pattern: 'tidal',
            unlockCondition: 'slow_wave',
            agent: new BreathAgent(),
            voices: []
          },
          spark: {
            name: 'SPARK',
            active: false,
            color: '#ffaa33',
            freq: 880,
            pattern: 'staccato',
            unlockCondition: 'tap_rhythm',
            agent: new SparkAgent(),
            voices: []
          },
          flow: {
            name: 'FLOW',
            active: false,
            color: '#33ff99',
            freq: 220,
            pattern: 'liquid',
            unlockCondition: 'circular_motion',
            agent: new FlowAgent(),
            voices: []
          },
          crystal: {
            name: 'CRYSTAL',
            active: false,
            color: '#ff33ff',
            freq: 1320,
            pattern: 'geometric',
            unlockCondition: 'angular_motion',
            agent: new CrystalAgent(),
            voices: []
          },
          shadow: {
            name: 'SHADOW',
            active: false,
            color: '#666666',
            freq: 110,
            pattern: 'echo',
            unlockCondition: 'stillness_after_motion',
            agent: new ShadowAgent(),
            voices: []
          },
          light: {
            name: 'LIGHT',
            active: false,
            color: '#ffffaa',
            freq: 660,
            pattern: 'radiant',
            unlockCondition: 'acceleration',
            agent: new LightAgent(),
            voices: []
          },
          earth: {
            name: 'EARTH',
            active: false,
            color: '#996633',
            freq: 55,
            pattern: 'grounded',
            unlockCondition: 'downward_motion',
            agent: new EarthAgent(),
            voices: []
          },
          void: {
            name: 'VOID',
            active: false,
            color: '#000033',
            freq: 27.5,
            pattern: 'absence',
            unlockCondition: 'pattern_break',
            agent: new VoidAgent(),
            voices: []
          },
          storm: {
            name: 'STORM',
            active: false,
            color: '#9933ff',
            freq: 440,
            pattern: 'chaotic',
            unlockCondition: 'shake',
            agent: new StormAgent(),
            voices: []
          },
          harmony: {
            name: 'HARMONY',
            active: false,
            color: '#33ffff',
            freq: 528,
            pattern: 'convergent',
            unlockCondition: 'pattern_sync',
            agent: new HarmonyAgent(),
            voices: []
          },
          transcend: {
            name: 'TRANSCEND',
            active: false,
            color: '#ffffff',
            freq: 432,
            pattern: 'infinite',
            unlockCondition: 'all_seeds_active',
            agent: new TranscendAgent(),
            voices: []
          }
        };
        
        // Motion tracking
        this.motion = {
          current: 0,
          history: [],
          patterns: {
            sustained: 0,
            wave: 0,
            tap: 0,
            circular: 0,
            angular: 0,
            stillness: 0,
            acceleration: 0,
            downward: 0,
            shake: 0,
            sync: 0
          }
        };
        
        // Pattern recognition
        this.patternBuffer = [];
        this.patternAnalyzer = new PatternAnalyzer();
        
        // Global musical state
        this.globalTempo = 60;
        this.globalKey = 'C';
        this.globalScale = [0, 2, 4, 5, 7, 9, 11];
        this.syncLevel = 0;
        
        // Audio nodes
        this.masterGain = null;
        this.compressor = null;
        this.analyser = null;
        
        // Visual elements
        this.elements = {};
        this.seedIndicators = {};
        
        this.init();
      }

      init() {
        this.elements = {
          startScreen: document.getElementById('startScreen'),
          startBtn: document.getElementById('startBtn'),
          motionSpace: document.getElementById('motionSpace'),
          motionTrail: document.getElementById('motionTrail'),
          agentThought: document.getElementById('agentThought'),
          seedName: document.getElementById('seedName'),
          activeSeeds: document.getElementById('activeSeeds'),
          syncLevel: document.getElementById('syncLevel'),
          patternType: document.getElementById('patternType'),
          pattern1: document.getElementById('pattern1'),
          pattern2: document.getElementById('pattern2'),
          pattern3: document.getElementById('pattern3'),
          pattern4: document.getElementById('pattern4')
        };
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.createSeedIndicators();
      }

      createSeedIndicators() {
        let angle = 0;
        const radius = 150;
        const centerX = window.innerWidth / 2;
        const centerY = window.innerHeight / 2;
        
        Object.keys(this.seeds).forEach((seedKey, i) => {
          const seed = this.seeds[seedKey];
          const indicator = document.createElement('div');
          indicator.className = 'seed-indicator';
          indicator.style.left = centerX + Math.cos(angle) * radius + 'px';
          indicator.style.top = centerY + Math.sin(angle) * radius + 'px';
          indicator.style.background = `radial-gradient(circle, ${seed.color} 0%, transparent 70%)`;
          indicator.style.opacity = '0.3';
          
          this.elements.motionSpace.appendChild(indicator);
          this.seedIndicators[seedKey] = indicator;
          
          angle += (Math.PI * 2) / 12;
        });
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
            await DeviceMotionEvent.requestPermission();
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudio();

          this.elements.startScreen.classList.add('hidden');
          this.elements.motionSpace.classList.add('active');

          this.active = true;
          this.startAgents();
          this.animate();
          
        } catch (e) {
          console.error('Failed to start:', e);
        }
      }

      setupAudio() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 128;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -12;
        this.compressor.knee.value = 6;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.1;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        
        this.compressor.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      setupMotionDetection() {
        let lastAccel = { x: 0, y: 0, z: 0 };
        let lastTime = Date.now();
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const now = Date.now();
          const dt = (now - lastTime) / 1000;
          lastTime = now;

          const dx = acc.x - lastAccel.x;
          const dy = acc.y - lastAccel.y;
          const dz = acc.z - lastAccel.z;
          
          const magnitude = Math.sqrt(dx*dx + dy*dy + dz*dz);
          
          this.updateMotion({
            magnitude,
            vector: { x: dx, y: dy, z: dz },
            acceleration: acc,
            dt
          });
          
          lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        // Mouse fallback
        let mouseVel = { x: 0, y: 0 };
        let lastMouse = { x: 0, y: 0, time: Date.now() };
        
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(0.001, (now - lastMouse.time) / 1000);
          
          const dx = e.clientX - lastMouse.x;
          const dy = e.clientY - lastMouse.y;
          
          mouseVel.x = dx / dt;
          mouseVel.y = dy / dt;
          
          const magnitude = Math.sqrt(mouseVel.x**2 + mouseVel.y**2) * 0.01;
          
          this.updateMotion({
            magnitude: Math.min(magnitude, 10),
            vector: { x: dx, y: dy, z: 0 },
            acceleration: { x: mouseVel.x * 0.01, y: mouseVel.y * 0.01, z: -9.8 },
            dt
          });
          
          this.addMotionTrail(e.clientX, e.clientY);
          
          lastMouse = { x: e.clientX, y: e.clientY, time: now };
        });
      }

      updateMotion(data) {
        this.motion.current = data.magnitude;
        this.motion.history.push({
          magnitude: data.magnitude,
          vector: data.vector,
          time: Date.now()
        });
        
        // Keep history manageable
        if (this.motion.history.length > 100) {
          this.motion.history.shift();
        }
        
        // Update pattern buffer for analysis
        this.patternBuffer.push(data);
        if (this.patternBuffer.length > 50) {
          this.patternBuffer.shift();
        }
        
        // Analyze patterns
        this.analyzePatterns();
        
        // Check unlock conditions
        this.checkUnlockConditions();
        
        // Update active seed agents
        Object.keys(this.seeds).forEach(seedKey => {
          const seed = this.seeds[seedKey];
          if (seed.active && seed.agent) {
            seed.agent.update(this.motion, this.ctx);
          }
        });
      }

      analyzePatterns() {
        const patterns = this.patternAnalyzer.analyze(this.patternBuffer);
        
        // Update pattern scores
        Object.keys(patterns).forEach(pattern => {
          this.motion.patterns[pattern] = patterns[pattern];
        });
        
        // Find dominant pattern
        let maxScore = 0;
        let dominantPattern = 'SEARCHING';
        
        Object.keys(this.motion.patterns).forEach(pattern => {
          if (this.motion.patterns[pattern] > maxScore) {
            maxScore = this.motion.patterns[pattern];
            dominantPattern = pattern.toUpperCase();
          }
        });
        
        this.elements.patternType.textContent = dominantPattern;
        
        // Update pattern visualization
        const patternBars = [
          this.elements.pattern1,
          this.elements.pattern2,
          this.elements.pattern3,
          this.elements.pattern4
        ];
        
        Object.values(this.motion.patterns).slice(0, 4).forEach((score, i) => {
          if (patternBars[i]) {
            patternBars[i].style.transform = `scaleX(${score})`;
            patternBars[i].style.opacity = 0.3 + score * 0.7;
          }
        });
      }

      checkUnlockConditions() {
        Object.keys(this.seeds).forEach(seedKey => {
          const seed = this.seeds[seedKey];
          
          if (!seed.active) {
            switch (seed.unlockCondition) {
              case 'sustained_motion':
                if (this.motion.patterns.sustained > 0.7) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'slow_wave':
                if (this.motion.patterns.wave > 0.6 && this.motion.current < 3) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'tap_rhythm':
                if (this.motion.patterns.tap > 0.8) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'circular_motion':
                if (this.motion.patterns.circular > 0.7) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'angular_motion':
                if (this.motion.patterns.angular > 0.6) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'stillness_after_motion':
                if (this.motion.patterns.stillness > 0.8 && this.getActiveSeeds().length > 2) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'acceleration':
                if (this.motion.patterns.acceleration > 0.7) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'downward_motion':
                if (this.motion.patterns.downward > 0.6) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'shake':
                if (this.motion.patterns.shake > 0.9) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'pattern_sync':
                if (this.syncLevel > 0.8) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'pattern_break':
                // Detect when established pattern suddenly changes
                if (this.patternAnalyzer.detectPatternBreak(this.patternBuffer)) {
                  this.unlockSeed(seedKey);
                }
                break;
                
              case 'all_seeds_active':
                if (this.getActiveSeeds().length === 11) {
                  this.unlockSeed(seedKey);
                }
                break;
            }
          }
        });
      }

      unlockSeed(seedKey) {
        const seed = this.seeds[seedKey];
        if (seed.active) return;
        
        seed.active = true;
        seed.agent.init(this.ctx, this.compressor);
        
        this.seedIndicators[seedKey].classList.add('active');
        this.seedIndicators[seedKey].style.opacity = '1';
        
        this.showAgentThought(`${seed.name} AWAKENS`);
        
        // Check for harmonic relationships
        this.checkHarmonicSync();
        
        this.updateUI();
      }

      checkHarmonicSync() {
        const activeSeeds = this.getActiveSeeds();
        
        // Calculate sync level based on active seeds finding common patterns
        let syncScore = 0;
        
        activeSeeds.forEach(seed1 => {
          activeSeeds.forEach(seed2 => {
            if (seed1 !== seed2) {
              const harmony = this.calculateHarmony(seed1, seed2);
              syncScore += harmony;
            }
          });
        });
        
        if (activeSeeds.length > 1) {
          this.syncLevel = Math.min(syncScore / (activeSeeds.length * activeSeeds.length), 1);
        } else {
          this.syncLevel = 0;
        }
        
        // Notify agents of sync level
        activeSeeds.forEach(seed => {
          seed.agent.updateSync(this.syncLevel, activeSeeds);
        });
      }

      calculateHarmony(seed1, seed2) {
        // Simple harmonic relationship calculator
        const ratio = seed1.freq / seed2.freq;
        const harmonicRatios = [1, 2, 3/2, 4/3, 5/4, 6/5, 5/3, 8/5];
        
        let minDiff = 1;
        harmonicRatios.forEach(hr => {
          const diff = Math.abs(ratio - hr);
          if (diff < minDiff) minDiff = diff;
        });
        
        return 1 - minDiff;
      }

      getActiveSeeds() {
        return Object.values(this.seeds).filter(seed => seed.active);
      }

      addMotionTrail(x, y) {
        const dot = document.createElement('div');
        dot.className = 'motion-dot';
        dot.style.left = x + 'px';
        dot.style.top = y + 'px';
        
        this.elements.motionTrail.appendChild(dot);
        
        setTimeout(() => {
          if (dot.parentNode) {
            dot.remove();
          }
        }, 2000);
      }

      showAgentThought(thought) {
        this.elements.agentThought.textContent = thought;
        this.elements.agentThought.classList.add('show');
        
        setTimeout(() => {
          this.elements.agentThought.classList.remove('show');
        }, 3000);
      }

      updateUI() {
        const activeCount = this.getActiveSeeds().length;
        this.elements.activeSeeds.textContent = activeCount;
        this.elements.syncLevel.textContent = Math.round(this.syncLevel * 100) + '%';
        
        // Update current seed name to most recently active
        const activeSeeds = this.getActiveSeeds();
        if (activeSeeds.length > 0) {
          this.elements.seedName.textContent = activeSeeds[activeSeeds.length - 1].name;
        }
      }

      startAgents() {
        // Main agent loop
        const agentTick = () => {
          if (!this.active) return;
          
          // Each agent thinks independently
          this.getActiveSeeds().forEach(seed => {
            seed.agent.think(this.motion, this.syncLevel);
          });
          
          // Global conductor agent coordinates
          this.coordinateAgents();
          
          setTimeout(agentTick, 100);
        };
        
        agentTick();
      }

      coordinateAgents() {
        const activeSeeds = this.getActiveSeeds();
        
        if (activeSeeds.length > 1) {
          // Find complementary pairs
          activeSeeds.forEach((seed1, i) => {
            activeSeeds.slice(i + 1).forEach(seed2 => {
              const harmony = this.calculateHarmony(seed1, seed2);
              
              if (harmony > 0.8) {
                // Seeds are in harmony, encourage synchronization
                seed1.agent.syncWith(seed2.agent);
                seed2.agent.syncWith(seed1.agent);
              }
            });
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          // Update background based on active seeds
          const activeSeeds = this.getActiveSeeds();
          if (activeSeeds.length > 0) {
            const colors = activeSeeds.map(s => s.color);
            const gradient = colors.length > 1 
              ? `radial-gradient(circle at 50% 50%, ${colors.join(', ')}, #000000)`
              : `radial-gradient(circle at 50% 50%, ${colors[0]}, #000000)`;
            
            document.body.style.background = gradient;
          }
          
          requestAnimationFrame(loop);
        };
        
        requestAnimationFrame(loop);
      }
    }

    // Start the engine
    new AgenticMusicEngine();
  </script>
</body>
</html>
