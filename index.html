<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Music 2.0: Environmental Soundtrack</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    body { 
      margin: 0; 
      min-height: 100vh; 
      display: flex; 
      flex-direction: column; 
      justify-content: center; 
      align-items: center; 
      background: linear-gradient(45deg, #1a1a2e, #16213e, #0f3460);
      color: white; 
      font-family: 'Arial', sans-serif;
    }
    #ui {
      backdrop-filter: blur(10px);
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      transition: all 0.3s ease;
    }
    #status { 
      font-size: 0.9rem; 
      opacity: 0.8; 
      background: rgba(0, 0, 0, 0.3);
      padding: 0.5rem;
      border-radius: 10px;
      margin-top: 1rem;
    }
    canvas { 
      margin-top: 1rem; 
      width: 100%; 
      max-width: 320px; 
      height: 120px; 
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.2);
    }
    .hidden { display: none !important; }
    .btn {
      transition: all 0.3s ease;
      transform: scale(1);
      box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
    }
    .btn:hover {
      transform: scale(1.05);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.4);
    }
    .btn:active {
      transform: scale(0.95);
    }
    .playing {
      animation: pulse 2s infinite;
    }
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .fade-to-black {
      background: linear-gradient(45deg, #0a0a0a, #1a1a1a);
      transition: background 2s ease;
    }
  </style>
</head>
<body>
  <div id="ui" class="text-center p-6 max-w-md mx-4">
    <h1 class="text-3xl font-bold mb-4 bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">
      Music 2.0
    </h1>
    <p class="mb-4 text-gray-300">Walk to drive the beat, tilt for effects, shake for changes!</p>
    
    <button id="startBtn" class="btn bg-gradient-to-r from-purple-600 to-blue-600 hover:from-purple-700 hover:to-blue-700 text-white font-semibold py-3 px-6 rounded-lg mb-3 w-full">
      Start Music
    </button>
    
    <div id="controls" class="hidden grid grid-cols-2 gap-2 mb-4">
      <button id="testSoundBtn" class="btn bg-green-600 hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-lg">Test Sound</button>
      <button id="retryBtn" class="btn bg-orange-600 hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-lg">Retry</button>
      <button id="fasterBtn" class="btn bg-yellow-600 hover:bg-yellow-700 text-white font-semibold py-2 px-4 rounded-lg">Faster</button>
      <button id="slowerBtn" class="btn bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-4 rounded-lg">Slower</button>
    </div>
    
    <button id="resetBtn" class="btn bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-4 rounded-lg mb-4 w-full hidden">
      Reset
    </button>
    
    <div class="grid grid-cols-2 gap-2 text-sm mb-4">
      <div id="tempoStatus" class="bg-black bg-opacity-30 p-2 rounded">Tempo: 120 BPM</div>
      <div id="sectionStatus" class="bg-black bg-opacity-30 p-2 rounded">Section: Intro</div>
    </div>
    
    <div id="chordStatus" class="bg-black bg-opacity-30 p-2 rounded text-sm mb-4">Chord: None</div>
    
    <canvas id="visualizer"></canvas>
    
    <div id="status">Ready to start...</div>
  </div>

  <script>
    // Global state
    const state = {
      isPlaying: false,
      stepBpm: 120,
      stepCount: 0,
      chordIndex: 0,
      lastStepTime: 0,
      lastShake: 0,
      lastMotionTime: 0,
      section: 'intro',
      lastSectionUpdate: 0,
      location: null,
      weather: { temp: 20, wind: 10, clouds: 50, condition: 0 },
      weatherTime: 0,
      vibe: 'upbeat',
      recentSteps: [],
      motionFailed: false,
      audioInitialized: false,
      permissionGranted: false
    };

    // Chord progressions for different vibes
    const chordSets = {
      dark: [['C4', 'Eb4', 'G4'], ['F4', 'Ab4', 'C5'], ['Ab3', 'C4', 'Eb4'], ['G3', 'Bb3', 'D4']],
      bright: [['C4', 'E4', 'G4'], ['F4', 'A4', 'C5'], ['A3', 'C4', 'E4'], ['G3', 'B3', 'D4']],
      upbeat: [['G4', 'B4', 'D5'], ['C4', 'E4', 'G4'], ['A3', 'C4', 'E4'], ['G3', 'B3', 'D4']],
      mellow: [['A4', 'C5', 'E5'], ['F4', 'A4', 'C5'], ['G4', 'B4', 'D5'], ['A4', 'C5', 'E5']]
    };

    // DOM elements
    const startBtn = document.getElementById('startBtn');
    const testSoundBtn = document.getElementById('testSoundBtn');
    const retryBtn = document.getElementById('retryBtn');
    const resetBtn = document.getElementById('resetBtn');
    const fasterBtn = document.getElementById('fasterBtn');
    const slowerBtn = document.getElementById('slowerBtn');
    const controls = document.getElementById('controls');
    const statusDiv = document.getElementById('status');
    const tempoStatus = document.getElementById('tempoStatus');
    const chordStatus = document.getElementById('chordStatus');
    const sectionStatus = document.getElementById('sectionStatus');
    const ui = document.getElementById('ui');
    const canvas = document.getElementById('visualizer');
    const ctx = canvas.getContext('2d');

    // Audio components
    let audioContext, drums, bass, lead, pad, reverb, filter, analyser, compressor;
    let isAudioSetup = false;

    // Initialize audio system
    async function initAudio() {
      if (isAudioSetup) return;
      
      try {
        await Tone.start();
        console.log('Tone.js started successfully');
        
        // Create synths with better sounds
        drums = new Tone.MembraneSynth({
          pitchDecay: 0.05,
          octaves: 10,
          oscillator: { type: 'sine' },
          envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4 }
        });

        bass = new Tone.MonoSynth({
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.1, decay: 0.3, sustain: 0.1, release: 0.8 },
          filter: { Q: 2, type: 'lowpass', rolloff: -12 }
        });

        lead = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'triangle' },
          envelope: { attack: 0.02, decay: 0.2, sustain: 0.3, release: 0.5 }
        });

        pad = new Tone.PolySynth(Tone.Synth, {
          oscillator: { type: 'sawtooth' },
          envelope: { attack: 0.8, decay: 1.0, sustain: 0.7, release: 2.0 },
          filter: { frequency: 800, type: 'lowpass' }
        });

        // Effects chain
        reverb = new Tone.Reverb({ decay: 3, wet: 0.4 });
        filter = new Tone.Filter({ frequency: 1000, type: 'lowpass' });
        compressor = new Tone.Compressor(-30, 3);
        analyser = new Tone.Analyser('waveform', 256);

        // Connect everything
        drums.chain(compressor, reverb, Tone.Destination);
        bass.chain(filter, compressor, reverb, Tone.Destination);
        lead.chain(compressor, reverb, analyser, Tone.Destination);
        pad.chain(filter, compressor, reverb, Tone.Destination);

        // Set initial volumes
        drums.volume.value = -8;
        bass.volume.value = -12;
        lead.volume.value = -15;
        pad.volume.value = -20;

        isAudioSetup = true;
        console.log('Audio system initialized');
        
      } catch (error) {
        console.error('Audio initialization failed:', error);
        throw error;
      }
    }

    // Get time-based parameters
    function getTimeParams() {
      const hour = new Date().getHours();
      if (hour < 6) return { vibe: 'dark', tempo: 90 };
      if (hour < 12) return { vibe: 'bright', tempo: 110 };
      if (hour < 18) return { vibe: 'upbeat', tempo: 130 };
      return { vibe: 'mellow', tempo: 100 };
    }

    // Get user location
    async function getLocation() {
      if (state.location) return state.location;
      
      return new Promise((resolve, reject) => {
        if (!navigator.geolocation) {
          reject(new Error('Geolocation not supported'));
          return;
        }
        
        navigator.geolocation.getCurrentPosition(
          (position) => {
            state.location = {
              lat: position.coords.latitude,
              lon: position.coords.longitude
            };
            resolve(state.location);
          },
          (error) => {
            console.error('Location error:', error);
            // Use fallback location (NYC)
            state.location = { lat: 40.7128, lon: -74.0060 };
            resolve(state.location);
          },
          { timeout: 10000, maximumAge: 300000 }
        );
      });
    }

    // Fetch weather data
    async function getWeather() {
      if (Date.now() - state.weatherTime < 300000) { // Cache for 5 minutes
        return state.weather;
      }
      
      try {
        const location = await getLocation();
        const url = `https://api.open-meteo.com/v1/forecast?latitude=${location.lat}&longitude=${location.lon}&current=temperature_2m,wind_speed_10m,cloud_cover,weather_code&timezone=auto`;
        
        const response = await fetch(url);
        if (!response.ok) throw new Error('Weather fetch failed');
        
        const data = await response.json();
        state.weather = {
          temp: data.current.temperature_2m || 20,
          wind: data.current.wind_speed_10m || 10,
          clouds: data.current.cloud_cover || 50,
          condition: data.current.weather_code || 0
        };
        state.weatherTime = Date.now();
        
        console.log('Weather updated:', state.weather);
        return state.weather;
        
      } catch (error) {
        console.error('Weather fetch error:', error);
        return state.weather; // Use cached/default values
      }
    }

    // Update chord progression based on weather
    function updateChordProgression() {
      const { vibe } = getTimeParams();
      let chords = [...chordSets[vibe]];
      
      // Apply weather modifications
      if (state.weather.condition >= 45) { // Rainy weather
        // Add tension with 7th chords
        chords = chords.map(chord => [...chord, Tone.Frequency(chord[0]).transpose(10).toNote()]);
      }
      
      // Temperature-based transposition
      const tempOffset = Math.round((state.weather.temp - 20) / 10);
      chords = chords.map(chord => 
        chord.map(note => Tone.Frequency(note).transpose(tempOffset).toNote())
      );
      
      state.chords = chords;
      state.vibe = vibe;
      
      updateUI();
    }

    // Play drum pattern
    function playDrums() {
      const patterns = {
        intro: [1, 0, 0, 1, 0, 0, 1, 0],
        build: [1, 0, 1, 0, 1, 0, 1, 0],
        climax: [1, 1, 0, 1, 1, 0, 1, 1]
      };
      
      const pattern = patterns[state.section] || patterns.intro;
      const interval = 60 / state.stepBpm * 1000 / 2; // 8th notes
      
      pattern.forEach((hit, index) => {
        if (hit) {
          setTimeout(() => {
            drums.triggerAttackRelease('C2', '8n');
          }, index * interval);
        }
      });
    }

    // Play bass line
    function playBass() {
      if (state.section === 'intro') return;
      
      const chord = state.chords[state.chordIndex];
      const bassNote = Tone.Frequency(chord[0]).transpose(-12).toNote();
      
      bass.triggerAttackRelease(bassNote, '4n');
    }

    // Play lead melody
    function playLead() {
      if (state.section !== 'climax') return;
      
      const chord = state.chords[state.chordIndex];
      const melody = [chord[0], chord[1], chord[2], chord[1]];
      
      melody.forEach((note, index) => {
        setTimeout(() => {
          lead.triggerAttackRelease(note, '16n');
        }, index * (60 / state.stepBpm * 1000 / 4));
      });
    }

    // Play pad chords
    function playPad() {
      if (state.section === 'intro') return;
      
      const chord = state.chords[state.chordIndex];
      pad.triggerAttackRelease(chord, '2n');
    }

    // Main music loop
    function playMusic() {
      if (!state.isPlaying) return;
      
      playDrums();
      playBass();
      playLead();
      playPad();
      
      // Schedule next beat
      setTimeout(playMusic, 60 / state.stepBpm * 1000);
    }

    // Handle device motion
    function handleMotion(event) {
      if (!state.isPlaying) return;
      
      const now = Date.now();
      if (now - state.lastMotionTime < 50) return; // Throttle
      
      state.lastMotionTime = now;
      
      const accel = event.accelerationIncludingGravity || {};
      const totalAccel = Math.sqrt(
        Math.pow(accel.x || 0, 2) + 
        Math.pow(accel.y || 0, 2) + 
        Math.pow(accel.z || 0, 2)
      );
      
      // Detect steps (walking)
      if (totalAccel > 12 && now - state.lastStepTime > 300) {
        state.lastStepTime = now;
        state.stepCount++;
        
        // Calculate BPM from steps
        state.recentSteps.push(now);
        if (state.recentSteps.length > 5) {
          state.recentSteps.shift();
        }
        
        if (state.recentSteps.length >= 2) {
          const intervals = [];
          for (let i = 1; i < state.recentSteps.length; i++) {
            intervals.push(state.recentSteps[i] - state.recentSteps[i-1]);
          }
          const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
          state.stepBpm = Math.max(80, Math.min(160, Math.round(60000 / avgInterval)));
        }
        
        updateSection();
        console.log('Step detected, BPM:', state.stepBpm);
      }
      
      // Detect shake (chord change)
      if (totalAccel > 20 && now - state.lastShake > 1000) {
        state.lastShake = now;
        state.chordIndex = (state.chordIndex + 1) % state.chords.length;
        console.log('Shake detected, chord changed to:', state.chordIndex);
      }
      
      // Tilt affects filter
      const tilt = Math.abs(accel.x || 0) / 10;
      filter.frequency.rampTo(500 + tilt * 1000, 0.1);
      
      updateUI();
    }

    // Update section based on activity
    function updateSection() {
      const now = Date.now();
      
      if (state.section === 'intro' && state.stepCount >= 8) {
        state.section = 'build';
        state.lastSectionUpdate = now;
        bass.volume.rampTo(-8, 2);
        pad.volume.rampTo(-15, 2);
      } else if (state.section === 'build' && state.stepCount >= 16) {
        state.section = 'climax';
        state.lastSectionUpdate = now;
        lead.volume.rampTo(-10, 2);
        pad.volume.rampTo(-12, 2);
      }
      
      // Auto-reset after period of inactivity
      if (now - state.lastMotionTime > 10000) {
        fadeOut();
      }
    }

    // Fade out music
    function fadeOut() {
      if (!state.isPlaying) return;
      
      drums.volume.rampTo(-Infinity, 2);
      bass.volume.rampTo(-Infinity, 2);
      lead.volume.rampTo(-Infinity, 2);
      pad.volume.rampTo(-Infinity, 2);
      
      setTimeout(() => {
        state.isPlaying = false;
        state.section = 'intro';
        state.stepCount = 0;
        resetUI();
      }, 2000);
    }

    // Visualizer
    function drawVisualizer() {
      if (!state.isPlaying || !analyser) return;
      
      const width = canvas.width = canvas.clientWidth * window.devicePixelRatio;
      const height = canvas.height = canvas.clientHeight * window.devicePixelRatio;
      ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
      
      const values = analyser.getValue();
      ctx.clearRect(0, 0, width, height);
      
      // Draw waveform
      ctx.beginPath();
      ctx.strokeStyle = `hsl(${state.vibe === 'dark' ? 240 : 180}, 70%, 70%)`;
      ctx.lineWidth = 2;
      
      for (let i = 0; i < values.length; i++) {
        const x = (i / values.length) * canvas.clientWidth;
        const y = ((values[i] + 1) / 2) * canvas.clientHeight;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.stroke();
      
      requestAnimationFrame(drawVisualizer);
    }

    // Update UI elements
    function updateUI() {
      tempoStatus.textContent = `Tempo: ${state.stepBpm} BPM`;
      sectionStatus.textContent = `Section: ${state.section}`;
      
      if (state.chords && state.chords[state.chordIndex]) {
        chordStatus.textContent = `Chord: ${state.chords[state.chordIndex].join(', ')}`;
      }
      
      statusDiv.innerHTML = `
        ${state.weather.temp}Â°C | Wind: ${state.weather.wind}km/h | ${state.vibe} vibe
      `;
    }

    // Reset UI
    function resetUI() {
      startBtn.textContent = 'Start Music';
      startBtn.classList.remove('playing');
      controls.classList.add('hidden');
      resetBtn.classList.add('hidden');
      ui.classList.remove('fade-to-black');
      statusDiv.textContent = 'Ready to start...';
      sectionStatus.textContent = 'Section: Intro';
      tempoStatus.textContent = 'Tempo: 120 BPM';
      chordStatus.textContent = 'Chord: None';
    }

    // Request motion permission
    async function requestMotionPermission() {
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
          const permission = await DeviceMotionEvent.requestPermission();
          if (permission === 'granted') {
            window.addEventListener('devicemotion', handleMotion);
            state.permissionGranted = true;
            console.log('Motion permission granted');
            return true;
          }
        } catch (error) {
          console.error('Motion permission error:', error);
        }
      } else {
        // Non-iOS devices
        window.addEventListener('devicemotion', handleMotion);
        state.permissionGranted = true;
        return true;
      }
      return false;
    }

    // Event listeners
    startBtn.addEventListener('click', async () => {
      if (state.isPlaying) return;
      
      try {
        statusDiv.textContent = 'Initializing...';
        
        // Initialize audio
        await initAudio();
        
        // Get weather data
        await getWeather();
        updateChordProgression();
        
        // Request motion permission
        await requestMotionPermission();
        
        // Start music
        state.isPlaying = true;
        state.stepCount = 0;
        state.section = 'intro';
        state.lastMotionTime = Date.now();
        
        startBtn.textContent = 'Playing...';
        startBtn.classList.add('playing');
        controls.classList.remove('hidden');
        resetBtn.classList.remove('hidden');
        ui.classList.add('fade-to-black');
        
        playMusic();
        drawVisualizer();
        
        statusDiv.textContent = state.permissionGranted ? 
          'Walk to drive the beat!' : 
          'Use buttons to control tempo';
        
      } catch (error) {
        console.error('Start error:', error);
        statusDiv.textContent = `Error: ${error.message}`;
      }
    });

    testSoundBtn.addEventListener('click', async () => {
      try {
        await initAudio();
        const testSynth = new Tone.Synth().toDestination();
        testSynth.triggerAttackRelease('C4', '8n');
        statusDiv.textContent = 'Test sound played';
      } catch (error) {
        statusDiv.textContent = `Test failed: ${error.message}`;
      }
    });

    retryBtn.addEventListener('click', async () => {
      state.location = null;
      state.weatherTime = 0;
      await getWeather();
      await requestMotionPermission();
      updateChordProgression();
      statusDiv.textContent = 'Retried - permissions and weather updated';
    });

    resetBtn.addEventListener('click', () => {
      fadeOut();
      setTimeout(() => {
        resetUI();
      }, 2000);
    });

    fasterBtn.addEventListener('click', () => {
      state.stepBpm = Math.min(160, state.stepBpm + 10);
      state.lastMotionTime = Date.now();
      updateUI();
    });

    slowerBtn.addEventListener('click', () => {
      state.stepBpm = Math.max(80, state.stepBpm - 10);
      state.lastMotionTime = Date.now();
      updateUI();
    });

    // Initialize
    console.log('Music 2.0 initialized');
  </script>
</body>
</html>
