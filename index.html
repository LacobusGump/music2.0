<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-status-bar-style" content="black-translucent">
<title>NEUROMANCER - Environmental Music AI</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-user-select: none;
  user-select: none;
  overscroll-behavior: none;
}
:root {
  --quantum-blue: #00ffff;
  --neural-purple: #ff00ff;
  --plasma-green: #00ff00;
  --void-black: #000000;
  --ghost-white: rgba(255,255,255,0.03);
  --electric-red: #ff0040;
  --gold: #ffd700;
  --safe-area-top: env(safe-area-inset-top);
  --safe-area-bottom: env(safe-area-inset-bottom);
}
body {
  background: var(--void-black);
  color: #fff;
  overflow: hidden;
  height: 100vh;
  height: 100dvh;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  position: fixed;
  width: 100%;
  touch-action: none;
}
/* Quantum Field Background */
#quantumField {
  position: fixed;
  inset: 0;
  pointer-events: none;
  transition: all 3s cubic-bezier(0.4, 0, 0.2, 1);
}
.quantum-layer {
  position: absolute;
  inset: 0;
  opacity: 0.3;
}
.quantum-layer:nth-child(1) {
  background: radial-gradient(ellipse at 25% 25%,
    rgba(0, 255, 255, 0.1) 0%,
    transparent 50%);
  animation: rotate-slow 30s linear infinite;
}
.quantum-layer:nth-child(2) {
  background: radial-gradient(ellipse at 75% 75%,
    rgba(255, 0, 255, 0.08) 0%,
    transparent 50%);
  animation: rotate-slow 40s linear infinite reverse;
}
.quantum-layer:nth-child(3) {
  background: radial-gradient(circle at center,
    transparent 0%,
    rgba(0, 255, 0, 0.03) 40%,
    transparent 70%);
  animation: pulse-slow 8s ease-in-out infinite;
}
@keyframes rotate-slow {
  to { transform: rotate(360deg); }
}
@keyframes pulse-slow {
  0%, 100% { transform: scale(1); opacity: 0.3; }
  50% { transform: scale(1.2); opacity: 0.6; }
}
/* Neural Particle System */
#particleCanvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.8;
}
/* 3D Spatial Visualizer */
#spatialCanvas {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.7;
  mix-blend-mode: screen;
}
/* Waveform Display */
#waveformCanvas {
  position: fixed;
  top: calc(var(--safe-area-top) + 80px);
  left: 10px;
  right: 10px;
  height: 60px;
  pointer-events: none;
  opacity: 0.6;
  filter: drop-shadow(0 0 10px var(--quantum-blue));
}
/* HUD Elements */
.hud-top {
  position: fixed;
  top: var(--safe-area-top);
  left: 0;
  right: 0;
  padding: 15px;
  background: linear-gradient(to bottom,
    rgba(0, 0, 0, 0.8),
    transparent);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  z-index: 100;
}
.state-display {
  display: flex;
  flex-direction: column;
  gap: 5px;
}
.current-state {
  font-size: 18px;
  letter-spacing: 4px;
  font-weight: 100;
  color: var(--quantum-blue);
  text-shadow: 0 0 20px currentColor;
}
.state-subtitle {
  font-size: 9px;
  opacity: 0.5;
  letter-spacing: 2px;
}
.metrics-display {
  display: flex;
  flex-direction: column;
  gap: 3px;
  text-align: right;
  font-size: 9px;
  font-family: monospace;
  opacity: 0.6;
}
.metric {
  display: flex;
  gap: 10px;
  justify-content: flex-end;
}
.metric-value {
  color: var(--plasma-green);
  min-width: 40px;
}
/* Motion & Energy Meters */
.energy-container {
  position: fixed;
  left: 15px;
  top: 50%;
  transform: translateY(-50%);
  width: 4px;
  height: 200px;
  background: rgba(255, 255, 255, 0.05);
  border-radius: 2px;
  overflow: hidden;
}
.energy-bar {
  position: absolute;
  bottom: 0;
  width: 100%;
  background: linear-gradient(to top,
    var(--plasma-green),
    var(--quantum-blue),
    var(--neural-purple));
  transition: height 0.2s ease;
  box-shadow: 0 0 20px currentColor;
}
.motion-orb {
  position: fixed;
  right: 15px;
  top: 50%;
  transform: translateY(-50%);
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center,
    rgba(0, 255, 255, 0.1),
    transparent);
}
.motion-core {
  width: 20px;
  height: 20px;
  border-radius: 50%;
  background: var(--quantum-blue);
  transition: all 0.1s ease;
  box-shadow: 0 0 20px currentColor;
}
/* Sample Matrix */
.sample-matrix {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
  gap: 20px;
  padding: 20px;
}
.sample-node {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.1);
  position: relative;
  transition: all 0.3s ease;
  cursor: pointer;
  background: radial-gradient(circle at 30% 30%,
    rgba(0, 0, 0, 0.5),
    rgba(0, 0, 0, 0.8));
}
.sample-node.recording {
  animation: record-pulse 1s ease-in-out infinite;
  border-color: var(--electric-red);
  background: radial-gradient(circle at center,
    rgba(255, 0, 64, 0.2),
    transparent);
}
.sample-node.loaded {
  border-color: var(--plasma-green);
  background: radial-gradient(circle at center,
    rgba(0, 255, 0, 0.1),
    transparent);
}
.sample-node.playing {
  animation: play-burst 0.3s ease;
  border-color: var(--quantum-blue);
  box-shadow: 0 0 30px var(--quantum-blue),
              inset 0 0 20px var(--quantum-blue);
}
.sample-node.processing {
  animation: process-spin 1s linear infinite;
  border-color: var(--gold);
}
@keyframes record-pulse {
  0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 var(--electric-red); }
  50% { transform: scale(1.1); box-shadow: 0 0 20px 5px var(--electric-red); }
}
@keyframes play-burst {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}
@keyframes process-spin {
  to { transform: rotate(360deg); }
}
.sample-visual {
  position: absolute;
  inset: 5px;
  border-radius: 50%;
  overflow: hidden;
}
.sample-canvas {
  width: 100%;
  height: 100%;
}
.sample-number {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  font-size: 10px;
  opacity: 0.3;
  pointer-events: none;
}
/* Neural Network Visualization */
.neural-network {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 120px);
  left: 50%;
  transform: translateX(-50%);
  width: 250px;
  height: 80px;
  display: flex;
  align-items: center;
  justify-content: center;
  opacity: 0.4;
}
.neural-node {
  width: 8px;
  height: 8px;
  background: var(--quantum-blue);
  border-radius: 50%;
  position: absolute;
  opacity: 0.3;
}
.neural-connection {
  position: absolute;
  height: 1px;
  background: linear-gradient(90deg,
    transparent,
    var(--quantum-blue),
    transparent);
  transform-origin: left center;
  opacity: 0.2;
}
/* Journey Timeline */
.journey-container {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 100px);
  left: 30px;
  right: 30px;
}
.journey-info {
  display: flex;
  justify-content: space-between;
  margin-bottom: 5px;
  font-size: 9px;
  opacity: 0.5;
}
.journey-timeline {
  height: 3px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}
.journey-progress {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg,
    var(--plasma-green),
    var(--quantum-blue),
    var(--neural-purple),
    var(--electric-red));
  transition: width 1s linear;
  box-shadow: 0 0 10px currentColor;
}
.journey-markers {
  position: absolute;
  inset: 0;
  display: flex;
}
.journey-marker {
  flex: 1;
  border-right: 1px solid rgba(255, 255, 255, 0.2);
}
/* Control Panel */
.control-panel {
  position: fixed;
  bottom: var(--safe-area-bottom);
  left: 0;
  right: 0;
  height: 90px;
  background: linear-gradient(to top,
    rgba(0, 0, 0, 0.9),
    rgba(0, 0, 0, 0.5),
    transparent);
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 20px;
  z-index: 100;
}
.control-group {
  display: flex;
  gap: 15px;
}
.control-btn {
  width: 45px;
  height: 45px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.2);
  background: rgba(0, 0, 0, 0.6);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  letter-spacing: 1px;
  transition: all 0.3s ease;
  cursor: pointer;
  position: relative;
}
.control-btn.active {
  border-color: var(--quantum-blue);
  background: rgba(0, 255, 255, 0.1);
  box-shadow: 0 0 20px var(--quantum-blue),
              inset 0 0 10px var(--quantum-blue);
}
.control-btn.main {
  width: 60px;
  height: 60px;
  border-width: 2px;
  font-size: 10px;
}
.control-btn.recording {
  animation: record-glow 1s ease-in-out infinite;
  border-color: var(--electric-red);
  background: rgba(255, 0, 64, 0.2);
}
@keyframes record-glow {
  0%, 100% { box-shadow: 0 0 10px var(--electric-red); }
  50% { box-shadow: 0 0 30px var(--electric-red), 0 0 50px var(--electric-red); }
}
/* Effect Indicators */
.effects-row {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 95px);
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
}
.effect-indicator {
  width: 30px;
  height: 4px;
  background: rgba(255, 255, 255, 0.1);
  border-radius: 2px;
  transition: all 0.3s ease;
}
.effect-indicator.active {
  background: var(--quantum-blue);
  box-shadow: 0 0 10px var(--quantum-blue);
}
/* Permission Overlay */
.permission-overlay {
  position: fixed;
  inset: 0;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center,
    rgba(0, 0, 0, 0.95),
    var(--void-black));
  z-index: 10000;
  gap: 30px;
  padding: 40px;
  text-align: center;
}
.permission-overlay.hidden {
  display: none;
}
.logo-container {
  position: relative;
  width: 150px;
  height: 150px;
}
.logo-ring {
  position: absolute;
  inset: 0;
  border: 1px solid var(--quantum-blue);
  border-radius: 50%;
  opacity: 0.3;
  animation: expand-ring 3s ease-in-out infinite;
}
.logo-ring:nth-child(2) {
  animation-delay: 1s;
}
.logo-ring:nth-child(3) {
  animation-delay: 2s;
}
@keyframes expand-ring {
  0% { transform: scale(0.8); opacity: 0; }
  50% { opacity: 0.5; }
  100% { transform: scale(1.5); opacity: 0; }
}
.logo-core {
  position: absolute;
  inset: 30%;
  background: radial-gradient(circle at center,
    var(--quantum-blue),
    transparent);
  border-radius: 50%;
  animation: pulse-core 2s ease-in-out infinite;
}
@keyframes pulse-core {
  0%, 100% { transform: scale(1); opacity: 0.8; }
  50% { transform: scale(1.1); opacity: 1; }
}
.permission-title {
  font-size: 24px;
  letter-spacing: 8px;
  font-weight: 100;
  color: var(--quantum-blue);
  margin-left: 8px;
}
.permission-subtitle {
  font-size: 10px;
  letter-spacing: 3px;
  opacity: 0.5;
  margin-top: -20px;
}
.permission-text {
  font-size: 12px;
  line-height: 1.8;
  opacity: 0.7;
  max-width: 280px;
}
.permission-btn {
  padding: 15px 40px;
  border: 1px solid var(--quantum-blue);
  background: transparent;
  color: var(--quantum-blue);
  border-radius: 30px;
  font-size: 11px;
  letter-spacing: 3px;
  cursor: pointer;
  transition: all 0.3s ease;
  position: relative;
  overflow: hidden;
}
.permission-btn:before {
  content: '';
  position: absolute;
  inset: 0;
  background: radial-gradient(circle at center,
    var(--quantum-blue),
    transparent);
  opacity: 0;
  transition: opacity 0.3s ease;
}
.permission-btn:hover:before {
  opacity: 0.1;
}
.permission-btn:active {
  transform: scale(0.98);
}
/* Loading State */
.loading-dna {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;
  z-index: 10001;
}
.loading-dna.active {
  display: block;
}
.dna-helix {
  width: 100px;
  height: 200px;
  position: relative;
}
.dna-strand {
  position: absolute;
  width: 100%;
  height: 100%;
}
.dna-dot {
  position: absolute;
  width: 8px;
  height: 8px;
  background: var(--quantum-blue);
  border-radius: 50%;
  box-shadow: 0 0 10px currentColor;
}
/* Notification System */
.notification {
  position: fixed;
  top: calc(var(--safe-area-top) + 150px);
  left: 50%;
  transform: translateX(-50%);
  padding: 10px 20px;
  background: rgba(0, 0, 0, 0.9);
  border: 1px solid var(--quantum-blue);
  border-radius: 20px;
  font-size: 11px;
  letter-spacing: 2px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  z-index: 1000;
  text-align: center;
  backdrop-filter: blur(10px);
}
.notification.visible {
  opacity: 0.9;
}
/* Touch Ripples */
.touch-ripple {
  position: fixed;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 1px solid var(--quantum-blue);
  pointer-events: none;
  animation: ripple-out 0.6s ease-out;
  z-index: 9999;
}
@keyframes ripple-out {
  to {
    width: 100px;
    height: 100px;
    opacity: 0;
    margin-left: -30px;
    margin-top: -30px;
  }
}
/* Responsive adjustments */
@media (max-height: 600px) {
  .sample-matrix { gap: 15px; }
  .sample-node { width: 50px; height: 50px; }
  .control-panel { height: 70px; }
  .control-btn { width: 40px; height: 40px; }
  .control-btn.main { width: 50px; height: 50px; }
}
@media (min-width: 768px) {
  .sample-matrix { gap: 30px; }
  .sample-node { width: 80px; height: 80px; }
}
/* Debug Panel */
.debug-panel {
  position: fixed;
  top: calc(var(--safe-area-top) + 10px);
  right: 10px;
  background: rgba(0, 0, 0, 0.8);
  padding: 10px;
  border-radius: 5px;
  font-family: monospace;
  font-size: 8px;
  display: none;
  z-index: 10000;
}
.debug-panel.visible {
  display: block;
}
</style>
</head>
<body>
<div id="quantumField">
  <div class="quantum-layer"></div>
  <div class="quantum-layer"></div>
  <div class="quantum-layer"></div>
</div>
<canvas id="particleCanvas"></canvas>
<canvas id="spatialCanvas"></canvas>
<canvas id="waveformCanvas"></canvas>
<div class="hud-top">
  <div class="state-display">
    <div class="current-state" id="currentState">VOID</div>
    <div class="state-subtitle" id="stateSubtitle">awaiting motion</div>
  </div>
 
  <div class="metrics-display">
    <div class="metric">
      <span>BPM</span>
      <span class="metric-value" id="bpmValue">120</span>
    </div>
    <div class="metric">
      <span>ENERGY</span>
      <span class="metric-value" id="energyValue">0.00</span>
    </div>
    <div class="metric">
      <span>SAMPLES</span>
      <span class="metric-value" id="samplesValue">0/9</span>
    </div>
  </div>
</div>
<div class="energy-container">
  <div class="energy-bar" id="energyBar"></div>
</div>
<div class="motion-orb">
  <div class="motion-core" id="motionCore"></div>
</div>
<div class="sample-matrix" id="sampleMatrix">
  <div class="sample-node" data-slot="0">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">1</span>
  </div>
  <div class="sample-node" data-slot="1">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">2</span>
  </div>
  <div class="sample-node" data-slot="2">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">3</span>
  </div>
  <div class="sample-node" data-slot="3">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">4</span>
  </div>
  <div class="sample-node" data-slot="4">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">5</span>
  </div>
  <div class="sample-node" data-slot="5">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">6</span>
  </div>
  <div class="sample-node" data-slot="6">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">7</span>
  </div>
  <div class="sample-node" data-slot="7">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">8</span>
  </div>
  <div class="sample-node" data-slot="8">
    <div class="sample-visual"><canvas class="sample-canvas"></canvas></div>
    <span class="sample-number">9</span>
  </div>
</div>
<div class="neural-network" id="neuralNetwork"></div>
<div class="journey-container">
  <div class="journey-info">
    <span id="journeyTime">00:00</span>
    <span id="journeyPhase">INTRODUCTION</span>
    <span>25:00</span>
  </div>
  <div class="journey-timeline">
    <div class="journey-progress" id="journeyProgress"></div>
    <div class="journey-markers">
      <div class="journey-marker"></div>
      <div class="journey-marker"></div>
      <div class="journey-marker"></div>
      <div class="journey-marker"></div>
      <div class="journey-marker"></div>
    </div>
  </div>
</div>
<div class="effects-row">
  <div class="effect-indicator" id="fxReverb"></div>
  <div class="effect-indicator" id="fxDelay"></div>
  <div class="effect-indicator" id="fxFilter"></div>
  <div class="effect-indicator" id="fxDistortion"></div>
  <div class="effect-indicator" id="fxChorus"></div>
</div>
<div class="control-panel">
  <div class="control-group">
    <div class="control-btn" id="btnTap" data-action="tap">TAP</div>
    <div class="control-btn" id="btnLoop" data-action="loop">LOOP</div>
  </div>
 
  <div class="control-btn main" id="btnRecord" data-action="record">REC</div>
 
  <div class="control-group">
    <div class="control-btn" id="btnAI" data-action="ai">AI</div>
    <div class="control-btn" id="btnFX" data-action="fx">FX</div>
  </div>
</div>
<div class="notification" id="notification"></div>
<div class="permission-overlay" id="permissionOverlay">
  <div class="logo-container">
    <div class="logo-ring"></div>
    <div class="logo-ring"></div>
    <div class="logo-ring"></div>
    <div class="logo-core"></div>
  </div>
 
  <div>
    <div class="permission-title">NEUROMANCER</div>
    <div class="permission-subtitle">ENVIRONMENTAL MUSIC AI</div>
  </div>
 
  <div class="permission-text">
    Your movement and environment will shape a unique 25-minute musical journey.
   
    This experience uses your microphone and motion sensors to create real-time adaptive music.
  </div>
 
  <button class="permission-btn" id="startBtn">BEGIN JOURNEY</button>
</div>
<div class="loading-dna" id="loadingDNA">
  <div class="dna-helix">
    <div class="dna-strand"></div>
  </div>
</div>
<div class="debug-panel" id="debugPanel">
  <div>Motion: <span id="debugMotion">0.00</span></div>
  <div>Accel: <span id="debugAccel">0,0,0</span></div>
  <div>Orient: <span id="debugOrient">0,0,0</span></div>
  <div>Touch: <span id="debugTouch">none</span></div>
  <div>Audio: <span id="debugAudio">0</span></div>
  <div>State: <span id="debugState">init</span></div>
</div>
<script>
'use strict';
// NEUROMANCER ENGINE v2.0 - Full Feature Implementation
class NeuromancerEngine {
  constructor() {
    this.config = {
      sampleRate: 48000,
      baseBPM: 120,
      sampleDuration: 4000, // 4 seconds
      maxSamples: 9,
      journeyDuration: 25 * 60 * 1000, // 25 minutes
      autoSampleInterval: 8000,
      fftSize: 2048,
      scheduleAheadTime: 0.1,
      // Motion detection
      motionSmoothingFactor: 0.8,
      motionThreshold: 0.3,
      // Musical parameters
      scaleNotes: [0, 2, 3, 5, 7, 8, 10, 12], // Minor pentatonic
      rootNote: 220, // A3
    };
   
    this.state = {
      // Journey state
      currentState: 'void',
      previousState: null,
      journeyPhase: 0,
      journeyStartTime: null,
      journeyElapsed: 0,
     
      // Motion & sensors
      motionLevel: 0,
      smoothedMotion: 0,
      accelerometer: { x: 0, y: 0, z: 0 },
      orientation: { alpha: 0, beta: 0, gamma: 0 },
      touchPoints: new Map(),
     
      // Musical state
      bpm: 120,
      currentBar: 0,
      currentBeat: 0,
      nextNoteTime: 0,
     
      // Samples
      samples: new Map(),
      nextSampleSlot: 0,
      isRecording: false,
      currentRecordingSlot: null,
     
      // Effects & AI
      activeEffects: new Set(['reverb']),
      aiDjActive: true,
      autoSampleCount: 0,
     
      // Performance
      energy: 0,
      complexity: 0.5,
      chaos: 0,
    };
   
    // Audio components
    this.audioNodes = {};
    this.scheduler = null;
    this.visualizers = {};
   
    // Data tracking
    this.motionHistory = [];
    this.touchHistory = [];
    this.sampleAnalysis = [];
   
    // Particles & visuals
    this.particles = [];
    this.neuralNodes = [];
   
    this.init();
  }
 
  async init() {
    console.log('🌌 Initializing NEUROMANCER Engine...');
   
    this.setupDOM();
    this.setupEventListeners();
    this.setupVisualSystems();
   
    // Add debug toggle
    document.addEventListener('keydown', (e) => {
      if (e.key === 'd') {
        document.getElementById('debugPanel').classList.toggle('visible');
      }
    });
  }
 
  setupDOM() {
    this.ui = {
      // Overlays
      permissionOverlay: document.getElementById('permissionOverlay'),
      loadingDNA: document.getElementById('loadingDNA'),
      notification: document.getElementById('notification'),
     
      // HUD
      currentState: document.getElementById('currentState'),
      stateSubtitle: document.getElementById('stateSubtitle'),
      bpmValue: document.getElementById('bpmValue'),
      energyValue: document.getElementById('energyValue'),
      samplesValue: document.getElementById('samplesValue'),
     
      // Visualizers
      energyBar: document.getElementById('energyBar'),
      motionCore: document.getElementById('motionCore'),
      sampleNodes: document.querySelectorAll('.sample-node'),
     
      // Journey
      journeyProgress: document.getElementById('journeyProgress'),
      journeyTime: document.getElementById('journeyTime'),
      journeyPhase: document.getElementById('journeyPhase'),
     
      // Controls
      btnRecord: document.getElementById('btnRecord'),
      btnTap: document.getElementById('btnTap'),
      btnLoop: document.getElementById('btnLoop'),
      btnAI: document.getElementById('btnAI'),
      btnFX: document.getElementById('btnFX'),
     
      // Effects
      fxIndicators: {
        reverb: document.getElementById('fxReverb'),
        delay: document.getElementById('fxDelay'),
        filter: document.getElementById('fxFilter'),
        distortion: document.getElementById('fxDistortion'),
        chorus: document.getElementById('fxChorus')
      },
     
      // Debug
      debug: {
        motion: document.getElementById('debugMotion'),
        accel: document.getElementById('debugAccel'),
        orient: document.getElementById('debugOrient'),
        touch: document.getElementById('debugTouch'),
        audio: document.getElementById('debugAudio'),
        state: document.getElementById('debugState')
      }
    };
   
    // Setup canvases
    this.canvases = {
      particle: document.getElementById('particleCanvas'),
      spatial: document.getElementById('spatialCanvas'),
      waveform: document.getElementById('waveformCanvas')
    };
   
    this.contexts = {
      particle: this.canvases.particle.getContext('2d'),
      spatial: this.canvases.spatial.getContext('2d'),
      waveform: this.canvases.waveform.getContext('2d')
    };
   
    this.resizeCanvases();
    window.addEventListener('resize', () => this.resizeCanvases());
  }
 
  resizeCanvases() {
    const w = window.innerWidth;
    const h = window.innerHeight;
   
    this.canvases.particle.width = w;
    this.canvases.particle.height = h;
    this.canvases.spatial.width = w;
    this.canvases.spatial.height = h;
    this.canvases.waveform.width = w - 20;
    this.canvases.waveform.height = 60;
  }
 
  setupEventListeners() {
    // Start button
    document.getElementById('startBtn').addEventListener('click', () => {
      this.requestPermissions();
    });
   
    // Control buttons
    this.ui.btnRecord.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.handleRecordButton();
    });
   
    this.ui.btnTap.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.handleTapTempo();
    });
   
    this.ui.btnLoop.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.toggleLoopMode();
    });
   
    this.ui.btnAI.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.toggleAIDJ();
    });
   
    this.ui.btnFX.addEventListener('touchstart', (e) => {
      e.preventDefault();
      this.cycleEffects();
    });
   
    // Sample nodes - manual trigger
    this.ui.sampleNodes.forEach((node, index) => {
      node.addEventListener('touchstart', (e) => {
        e.preventDefault();
        this.handleSampleTouch(index, 'start');
        this.createTouchRipple(e.touches[0]);
      });
     
      node.addEventListener('touchend', (e) => {
        e.preventDefault();
        this.handleSampleTouch(index, 'end');
      });
    });
   
    // Global touch tracking
    document.addEventListener('touchstart', (e) => {
      for (let touch of e.touches) {
        this.state.touchPoints.set(touch.identifier, {
          x: touch.clientX,
          y: touch.clientY,
          time: Date.now()
        });
      }
      this.ui.debug.touch.textContent = e.touches.length;
    });
   
    document.addEventListener('touchmove', (e) => {
      e.preventDefault();
      for (let touch of e.touches) {
        if (this.state.touchPoints.has(touch.identifier)) {
          const point = this.state.touchPoints.get(touch.identifier);
          point.x = touch.clientX;
          point.y = touch.clientY;
        }
      }
    }, { passive: false });
   
    document.addEventListener('touchend', (e) => {
      for (let touch of e.changedTouches) {
        this.state.touchPoints.delete(touch.identifier);
      }
      this.ui.debug.touch.textContent = this.state.touchPoints.size;
    });
  }
 
  async requestPermissions() {
    console.log('📱 Requesting permissions...');
    this.showNotification('Initializing audio system...');
   
    try {
      // Request microphone
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          echoCancellation: false,
          noiseSuppression: false,
          autoGainControl: false,
          sampleRate: { ideal: this.config.sampleRate }
        }
      });
     
      console.log('🎤 Microphone access granted');
     
      // Initialize audio system
      await this.initAudioSystem(stream);
     
      // Setup motion detection (with fallback)
      this.setupMotionDetection();
     
      // Start the journey
      this.startJourney();
     
    } catch (error) {
      console.error('❌ Permission error:', error);
      this.showNotification('Microphone access required for this experience', 5000);
     
      // Still try to start with limited features
      setTimeout(() => {
        this.initWithoutMicrophone();
      }, 2000);
    }
  }
 
  async initAudioSystem(stream) {
    console.log('🔊 Initializing Web Audio...');
   
    // Create audio context
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: this.config.sampleRate,
      latencyHint: 'interactive'
    });
   
    // Create audio graph
    this.setupAudioGraph(stream);
   
    // Initialize effects
    this.setupEffects();
   
    // Setup spatial audio
    this.setupSpatialAudio();
   
    // Resume context
    await this.audioContext.resume();
   
    console.log('✅ Audio system ready');
  }
 
  async initWithoutMicrophone() {
    console.log('🎵 Starting without microphone (limited features)');
   
    // Create audio context
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
   
    // Setup basic audio graph without mic
    this.setupBasicAudioGraph();
    this.setupEffects();
    this.setupSpatialAudio();
   
    await this.audioContext.resume();
   
    // Disable recording features
    this.ui.btnRecord.style.opacity = '0.3';
    this.ui.btnRecord.disabled = true;
    this.state.aiDjActive = false;
   
    this.startJourney();
    this.showNotification('Starting in synthesis mode (no recording)', 3000);
  }
 
  setupAudioGraph(stream) {
    // Input from microphone
    if (stream) {
      this.audioNodes.micInput = this.audioContext.createMediaStreamSource(stream);
    }
   
    // Analyser for visualization
    this.audioNodes.analyser = this.audioContext.createAnalyser();
    this.audioNodes.analyser.fftSize = this.config.fftSize;
    this.audioNodes.analyser.smoothingTimeConstant = 0.8;
   
    // Recording processor
    this.audioNodes.recorder = this.audioContext.createScriptProcessor(4096, 1, 1);
    this.recordBuffer = [];
   
    this.audioNodes.recorder.onaudioprocess = (e) => {
      if (this.state.isRecording) {
        const input = e.inputBuffer.getChannelData(0);
        this.recordBuffer.push(...input);
       
        // Update debug
        const rms = Math.sqrt(input.reduce((sum, x) => sum + x * x, 0) / input.length);
        this.ui.debug.audio.textContent = rms.toFixed(3);
      }
    };
   
    // Master bus
    this.audioNodes.masterGain = this.audioContext.createGain();
    this.audioNodes.masterGain.gain.value = 0.8;
   
    this.audioNodes.masterCompressor = this.audioContext.createDynamicsCompressor();
    this.audioNodes.masterCompressor.threshold.value = -12;
    this.audioNodes.masterCompressor.knee.value = 30;
    this.audioNodes.masterCompressor.ratio.value = 8;
    this.audioNodes.masterCompressor.attack.value = 0.003;
    this.audioNodes.masterCompressor.release.value = 0.25;
   
    this.audioNodes.masterLimiter = this.audioContext.createDynamicsCompressor();
    this.audioNodes.masterLimiter.threshold.value = -3;
    this.audioNodes.masterLimiter.knee.value = 0;
    this.audioNodes.masterLimiter.ratio.value = 20;
    this.audioNodes.masterLimiter.attack.value = 0.001;
    this.audioNodes.masterLimiter.release.value = 0.01;
   
    // Connect main signal path
    if (this.audioNodes.micInput) {
      this.audioNodes.micInput.connect(this.audioNodes.analyser);
      this.audioNodes.micInput.connect(this.audioNodes.recorder);
    }
   
    this.audioNodes.recorder.connect(this.audioContext.destination); // Silent connection
    this.audioNodes.masterGain.connect(this.audioNodes.masterCompressor);
    this.audioNodes.masterCompressor.connect(this.audioNodes.masterLimiter);
    this.audioNodes.masterLimiter.connect(this.audioContext.destination);
  }
 
  setupBasicAudioGraph() {
    // Minimal setup without microphone
    this.audioNodes.analyser = this.audioContext.createAnalyser();
    this.audioNodes.analyser.fftSize = this.config.fftSize;
   
    this.audioNodes.masterGain = this.audioContext.createGain();
    this.audioNodes.masterGain.gain.value = 0.8;
   
    this.audioNodes.masterCompressor = this.audioContext.createDynamicsCompressor();
    this.audioNodes.masterLimiter = this.audioContext.createDynamicsCompressor();
   
    this.audioNodes.masterGain.connect(this.audioNodes.masterCompressor);
    this.audioNodes.masterCompressor.connect(this.audioNodes.masterLimiter);
    this.audioNodes.masterLimiter.connect(this.audioContext.destination);
    this.audioNodes.masterLimiter.connect(this.audioNodes.analyser);
  }
 
  setupEffects() {
    // Reverb (convolution)
    this.audioNodes.reverb = this.audioContext.createConvolver();
    this.audioNodes.reverbGain = this.audioContext.createGain();
    this.audioNodes.reverbGain.gain.value = 0.3;
   
    // Generate hall impulse response
    const length = this.audioContext.sampleRate * 4;
    const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
   
    for (let channel = 0; channel < 2; channel++) {
      const channelData = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        const decay = Math.pow(1 - i / length, 2);
        channelData[i] = (Math.random() * 2 - 1) * decay * 0.5;
      }
    }
   
    this.audioNodes.reverb.buffer = impulse;
    this.audioNodes.reverb.connect(this.audioNodes.reverbGain);
    this.audioNodes.reverbGain.connect(this.audioNodes.masterGain);
   
    // Delay
    this.audioNodes.delay = this.audioContext.createDelay(2);
    this.audioNodes.delayGain = this.audioContext.createGain();
    this.audioNodes.delayFeedback = this.audioContext.createGain();
   
    this.audioNodes.delay.delayTime.value = 60 / this.state.bpm / 8; // Dotted 8th
    this.audioNodes.delayGain.gain.value = 0.3;
    this.audioNodes.delayFeedback.gain.value = 0.4;
   
    this.audioNodes.delay.connect(this.audioNodes.delayFeedback);
    this.audioNodes.delayFeedback.connect(this.audioNodes.delay);
    this.audioNodes.delay.connect(this.audioNodes.delayGain);
    this.audioNodes.delayGain.connect(this.audioNodes.masterGain);
   
    // Filter
    this.audioNodes.filter = this.audioContext.createBiquadFilter();
    this.audioNodes.filter.type = 'lowpass';
    this.audioNodes.filter.frequency.value = 5000;
    this.audioNodes.filter.Q.value = 1;
    this.audioNodes.filter.connect(this.audioNodes.masterGain);
   
    // Distortion
    this.audioNodes.distortion = this.audioContext.createWaveShaper();
    this.audioNodes.distortionGain = this.audioContext.createGain();
    this.audioNodes.distortionGain.gain.value = 0;
   
    const curve = new Float32Array(256);
    for (let i = 0; i < 256; i++) {
      const x = (i - 128) / 128;
      curve[i] = Math.tanh(x * 5) * 0.8;
    }
   
    this.audioNodes.distortion.curve = curve;
    this.audioNodes.distortion.oversample = '4x';
    this.audioNodes.distortion.connect(this.audioNodes.distortionGain);
    this.audioNodes.distortionGain.connect(this.audioNodes.masterGain);
   
    // Chorus (using multiple delays)
    this.audioNodes.chorus = [];
    this.audioNodes.chorusGain = this.audioContext.createGain();
    this.audioNodes.chorusGain.gain.value = 0;
   
    for (let i = 0; i < 3; i++) {
      const delay = this.audioContext.createDelay(0.1);
      const lfo = this.audioContext.createOscillator();
      const lfoGain = this.audioContext.createGain();
     
      delay.delayTime.value = 0.02 + i * 0.005;
      lfo.frequency.value = 0.5 + i * 0.2;
      lfoGain.gain.value = 0.003;
     
      lfo.connect(lfoGain);
      lfoGain.connect(delay.delayTime);
      lfo.start();
     
      delay.connect(this.audioNodes.chorusGain);
      this.audioNodes.chorus.push({ delay, lfo, lfoGain });
    }
   
    this.audioNodes.chorusGain.connect(this.audioNodes.masterGain);
  }
 
  setupSpatialAudio() {
    // Create 8 spatial positions for 3D sound
    this.audioNodes.spatialPanners = [];
   
    for (let i = 0; i < 8; i++) {
      const panner = this.audioContext.createPanner();
      panner.panningModel = 'HRTF';
      panner.distanceModel = 'inverse';
      panner.refDistance = 1;
      panner.maxDistance = 10;
      panner.rolloffFactor = 1;
      panner.coneInnerAngle = 360;
     
      // Position in circle around listener
      const angle = (i / 8) * Math.PI * 2;
      const radius = 3;
      panner.positionX.value = Math.cos(angle) * radius;
      panner.positionY.value = 0;
      panner.positionZ.value = Math.sin(angle) * radius;
     
      panner.connect(this.audioNodes.masterGain);
      this.audioNodes.spatialPanners.push(panner);
    }
   
    // Listener at origin
    const listener = this.audioContext.listener;
    listener.positionX.value = 0;
    listener.positionY.value = 0;
    listener.positionZ.value = 0;
  }
 
  setupMotionDetection() {
    console.log('📲 Setting up motion detection...');
   
    let lastAccel = { x: 0, y: 0, z: 0 };
    let motionSupported = false;
   
    // Try to setup device motion
    const setupDeviceMotion = () => {
      window.addEventListener('devicemotion', (e) => {
        motionSupported = true;
       
        const acc = e.accelerationIncludingGravity || e.acceleration;
        if (!acc) return;
       
        // Calculate motion delta
        const deltaX = Math.abs((acc.x || 0) - lastAccel.x);
        const deltaY = Math.abs((acc.y || 0) - lastAccel.y);
        const deltaZ = Math.abs((acc.z || 0) - lastAccel.z);
       
        const totalMotion = (deltaX + deltaY + deltaZ) / 30;
        const instantMotion = Math.min(1, totalMotion);
       
        // Smooth motion value
        this.state.smoothedMotion = this.state.smoothedMotion * this.config.motionSmoothingFactor +
                                    instantMotion * (1 - this.config.motionSmoothingFactor);
       
        this.state.motionLevel = this.state.smoothedMotion;
       
        // Store for next frame
        lastAccel = {
          x: acc.x || 0,
          y: acc.y || 0,
          z: acc.z || 0
        };
       
        this.state.accelerometer = lastAccel;
       
        // Update debug
        this.ui.debug.motion.textContent = this.state.motionLevel.toFixed(2);
        this.ui.debug.accel.textContent = `${lastAccel.x.toFixed(1)},${lastAccel.y.toFixed(1)},${lastAccel.z.toFixed(1)}`;
       
        // Store history
        this.motionHistory.push({
          level: this.state.motionLevel,
          time: Date.now()
        });
       
        if (this.motionHistory.length > 200) {
          this.motionHistory.shift();
        }
      });
    };
   
    // Try to setup device orientation
    const setupDeviceOrientation = () => {
      window.addEventListener('deviceorientation', (e) => {
        if (e.alpha === null) return;
       
        this.state.orientation = {
          alpha: e.alpha || 0,
          beta: e.beta || 0,
          gamma: e.gamma || 0
        };
       
        // Update listener orientation for 3D audio
        const listener = this.audioContext.listener;
        const rad = Math.PI / 180;
       
        listener.forwardX.value = Math.sin(e.alpha * rad) * Math.cos(e.beta * rad);
        listener.forwardY.value = Math.sin(e.beta * rad);
        listener.forwardZ.value = Math.cos(e.alpha * rad) * Math.cos(e.beta * rad);
       
        // Update debug
        this.ui.debug.orient.textContent = `${e.alpha.toFixed(0)},${e.beta.toFixed(0)},${e.gamma.toFixed(0)}`;
      });
    };
   
    // iOS permission request
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
      DeviceMotionEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
            setupDeviceMotion();
          }
        })
        .catch(err => {
          console.warn('Motion permission denied:', err);
        });
    } else {
      // Non-iOS or no permission needed
      setupDeviceMotion();
    }
   
    // Orientation permission (iOS)
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
      DeviceOrientationEvent.requestPermission()
        .then(response => {
          if (response === 'granted') {
            setupDeviceOrientation();
          }
        })
        .catch(err => {
          console.warn('Orientation permission denied:', err);
        });
    } else {
      setupDeviceOrientation();
    }
   
    // Fallback: Use touch movement as motion
    setTimeout(() => {
      if (!motionSupported) {
        console.log('📱 Using touch-based motion fallback');
        this.setupTouchMotionFallback();
      }
    }, 2000);
  }
 
  setupTouchMotionFallback() {
    let lastTouch = { x: 0, y: 0 };
   
    document.addEventListener('touchmove', (e) => {
      if (e.touches.length > 0) {
        const touch = e.touches[0];
        const deltaX = Math.abs(touch.clientX - lastTouch.x);
        const deltaY = Math.abs(touch.clientY - lastTouch.y);
       
        const motion = Math.min(1, (deltaX + deltaY) / 100);
       
        this.state.smoothedMotion = this.state.smoothedMotion * 0.9 + motion * 0.1;
        this.state.motionLevel = this.state.smoothedMotion;
       
        lastTouch = { x: touch.clientX, y: touch.clientY };
       
        // Update debug
        this.ui.debug.motion.textContent = this.state.motionLevel.toFixed(2);
      }
    });
   
    this.showNotification('Motion sensors unavailable - using touch movement', 3000);
  }
 
  setupVisualSystems() {
    // Initialize particle system
    this.initParticles();
   
    // Initialize neural network visualization
    this.initNeuralNetwork();
   
    // Start animation loop
    this.startVisualization();
  }
 
  initParticles() {
    const particleCount = 50;
   
    for (let i = 0; i < particleCount; i++) {
      this.particles.push({
        x: Math.random() * window.innerWidth,
        y: Math.random() * window.innerHeight,
        vx: (Math.random() - 0.5) * 0.5,
        vy: (Math.random() - 0.5) * 0.5,
        size: Math.random() * 3 + 1,
        life: 1,
        color: Math.random() > 0.5 ? '--quantum-blue' : '--neural-purple'
      });
    }
  }
 
  initNeuralNetwork() {
    const container = document.getElementById('neuralNetwork');
    const nodeCount = 12;
   
    // Create nodes
    for (let i = 0; i < nodeCount; i++) {
      const node = document.createElement('div');
      node.className = 'neural-node';
     
      const angle = (i / nodeCount) * Math.PI * 2;
      const radius = 30;
     
      node.style.left = (125 + Math.cos(angle) * radius) + 'px';
      node.style.top = (40 + Math.sin(angle) * radius) + 'px';
     
      container.appendChild(node);
     
      this.neuralNodes.push({
        element: node,
        x: 125 + Math.cos(angle) * radius,
        y: 40 + Math.sin(angle) * radius,
        activation: 0
      });
    }
   
    // Create connections
    for (let i = 0; i < nodeCount; i++) {
      for (let j = i + 1; j < nodeCount; j++) {
        if (Math.random() > 0.7) {
          const connection = document.createElement('div');
          connection.className = 'neural-connection';
         
          const node1 = this.neuralNodes[i];
          const node2 = this.neuralNodes[j];
         
          const dx = node2.x - node1.x;
          const dy = node2.y - node1.y;
          const distance = Math.sqrt(dx * dx + dy * dy);
          const angle = Math.atan2(dy, dx);
         
          connection.style.width = distance + 'px';
          connection.style.left = node1.x + 'px';
          connection.style.top = node1.y + 'px';
          connection.style.transform = `rotate(${angle}rad)`;
         
          container.appendChild(connection);
        }
      }
    }
  }
 
  startJourney() {
    console.log('🚀 Journey beginning...');
   
    // Hide permission overlay
    this.ui.permissionOverlay.classList.add('hidden');
   
    // Initialize journey state
    this.state.journeyStartTime = Date.now();
   
    // Start scheduler
    this.startScheduler();
   
    // Start AI DJ
    if (this.state.aiDjActive) {
      this.startAIDJ();
    }
   
    // Check initial motion after 2 seconds
    setTimeout(() => {
      this.analyzeInitialState();
    }, 2000);
   
    // Start journey progression
    this.startJourneyProgression();
   
    // Update UI
    this.updateEffectIndicators();
   
    this.showNotification('Journey started - Move to create energy', 3000);
  }
 
  startScheduler() {
    let currentNote = 0;
    this.state.nextNoteTime = this.audioContext.currentTime;
   
    const schedule = () => {
      while (this.state.nextNoteTime < this.audioContext.currentTime + this.config.scheduleAheadTime) {
        this.scheduleNote(currentNote, this.state.nextNoteTime);
       
        // Advance time
        const secondsPerBeat = 60 / this.state.bpm;
        this.state.nextNoteTime += secondsPerBeat / 4; // 16th notes
       
        currentNote++;
        if (currentNote === 16) {
          currentNote = 0;
          this.onBarComplete();
        }
      }
     
      this.schedulerTimer = setTimeout(schedule, 25);
    };
   
    schedule();
  }
 
  scheduleNote(noteNumber, time) {
    const isDownbeat = noteNumber === 0;
    const isQuarter = noteNumber % 4 === 0;
    const isEighth = noteNumber % 2 === 0;
   
    // Play drums based on state
    if (this.state.currentState !== 'void') {
      if (isQuarter) {
        this.playKick(time, this.state.energy);
      }
     
      if (this.state.currentState === 'rhythmic' ||
          this.state.currentState === 'elevated' ||
          this.state.currentState === 'chaos') {
        if (noteNumber === 4 || noteNumber === 12) {
          this.playSnare(time);
        }
       
        if (isEighth) {
          this.playHiHat(time, noteNumber % 4 === 2);
        }
      }
    }
   
    // Trigger samples
    this.triggerSamplePattern(noteNumber, time);
   
    // Play melodic elements
    if (this.state.currentState === 'ambient' ||
        this.state.currentState === 'elevated') {
      this.playMelodicElement(noteNumber, time);
    }
  }
 
  playKick(time, intensity = 1) {
    const osc = this.audioContext.createOscillator();
    const gain = this.audioContext.createGain();
   
    osc.frequency.setValueAtTime(60, time);
    osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
   
    gain.gain.setValueAtTime(0.7 * intensity, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
   
    osc.connect(gain);
    gain.connect(this.audioNodes.masterGain);
   
    osc.start(time);
    osc.stop(time + 0.5);
  }
 
  playSnare(time) {
    // Noise
    const noise = this.audioContext.createBufferSource();
    const noiseBuffer = this.audioContext.createBuffer(1, 0.1 * this.audioContext.sampleRate, this.audioContext.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
   
    for (let i = 0; i < noiseData.length; i++) {
      noiseData[i] = Math.random() * 2 - 1;
    }
   
    noise.buffer = noiseBuffer;
   
    const noiseEnv = this.audioContext.createGain();
    const noiseFilter = this.audioContext.createBiquadFilter();
   
    noiseFilter.type = 'highpass';
    noiseFilter.frequency.value = 1000;
   
    noiseEnv.gain.setValueAtTime(0.2, time);
    noiseEnv.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
   
    // Tone
    const osc = this.audioContext.createOscillator();
    const oscEnv = this.audioContext.createGain();
   
    osc.frequency.value = 200;
    oscEnv.gain.setValueAtTime(0.1, time);
    oscEnv.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
   
    // Connect
    noise.connect(noiseFilter);
    noiseFilter.connect(noiseEnv);
    noiseEnv.connect(this.audioNodes.masterGain);
   
    osc.connect(oscEnv);
    oscEnv.connect(this.audioNodes.masterGain);
   
    noise.start(time);
    osc.start(time);
    osc.stop(time + 0.1);
  }
 
  playHiHat(time, open = false) {
    const noise = this.audioContext.createBufferSource();
    const noiseBuffer = this.audioContext.createBuffer(1, 0.05 * this.audioContext.sampleRate, this.audioContext.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
   
    for (let i = 0; i < noiseData.length; i++) {
      noiseData[i] = Math.random() * 2 - 1;
    }
   
    noise.buffer = noiseBuffer;
   
    const env = this.audioContext.createGain();
    const filter = this.audioContext.createBiquadFilter();
   
    filter.type = 'highpass';
    filter.frequency.value = open ? 5000 : 8000;
   
    env.gain.setValueAtTime(0.05, time);
    env.gain.exponentialRampToValueAtTime(0.01, time + (open ? 0.3 : 0.05));
   
    noise.connect(filter);
    filter.connect(env);
    env.connect(this.audioNodes.masterGain);
   
    noise.start(time);
  }
 
  playMelodicElement(noteNumber, time) {
    if (Math.random() > 0.7 || noteNumber % 4 !== 0) return;
   
    const noteIndex = Math.floor(Math.random() * this.config.scaleNotes.length);
    const octave = Math.floor(Math.random() * 2) + 1;
    const frequency = this.config.rootNote * Math.pow(2, this.config.scaleNotes[noteIndex] / 12) * octave;
   
    const osc = this.audioContext.createOscillator();
    const env = this.audioContext.createGain();
   
    osc.type = 'sine';
    osc.frequency.value = frequency;
   
    env.gain.setValueAtTime(0, time);
    env.gain.linearRampToValueAtTime(0.1 * this.state.energy, time + 0.01);
    env.gain.exponentialRampToValueAtTime(0.01, time + 2);
   
    osc.connect(env);
   
    // Route through spatial panner
    const pannerIndex = Math.floor(Math.random() * this.audioNodes.spatialPanners.length);
    env.connect(this.audioNodes.spatialPanners[pannerIndex]);
   
    // Send to reverb
    const reverbSend = this.audioContext.createGain();
    reverbSend.gain.value = 0.5;
    env.connect(reverbSend);
    reverbSend.connect(this.audioNodes.reverb);
   
    osc.start(time);
    osc.stop(time + 2);
  }
 
  triggerSamplePattern(noteNumber, time) {
    if (this.state.samples.size === 0) return;
   
    const samples = Array.from(this.state.samples.values());
   
    switch(this.state.currentState) {
      case 'ambient':
        if (noteNumber === 0 && samples[0]) {
          this.playSampleAt(0, time, 0.5);
        }
        break;
       
      case 'rhythmic':
        if (noteNumber % 8 === 0 && samples[0]) {
          this.playSampleAt(0, time, 0.7);
        }
        if (noteNumber % 8 === 4 && samples[1]) {
          this.playSampleAt(1, time, 0.7);
        }
        break;
       
      case 'elevated':
        samples.forEach((sample, idx) => {
          if (noteNumber % (4 + idx * 2) === 0) {
            this.playSampleAt(idx, time, 0.8);
          }
        });
        break;
       
      case 'chaos':
        if (Math.random() > 0.85) {
          const idx = Math.floor(Math.random() * samples.length);
          this.playSampleAt(idx, time, Math.random());
        }
        break;
    }
  }
 
  playSampleAt(slotIndex, time, volume = 1) {
    const sample = this.state.samples.get(slotIndex);
    if (!sample || !sample.buffer) return;
   
    const source = this.audioContext.createBufferSource();
    source.buffer = sample.buffer;
   
    // Pitch variation based on motion
    source.playbackRate.value = 1 + (this.state.motionLevel - 0.5) * 0.3;
   
    const gain = this.audioContext.createGain();
    gain.gain.value = volume * 0.5;
   
    source.connect(gain);
   
    // Route through spatial panner
    const pannerIndex = slotIndex % this.audioNodes.spatialPanners.length;
    gain.connect(this.audioNodes.spatialPanners[pannerIndex]);
   
    // Send to effects
    if (this.state.activeEffects.has('reverb')) {
      const send = this.audioContext.createGain();
      send.gain.value = 0.3;
      gain.connect(send);
      send.connect(this.audioNodes.reverb);
    }
   
    if (this.state.activeEffects.has('delay')) {
      const send = this.audioContext.createGain();
      send.gain.value = 0.2;
      gain.connect(send);
      send.connect(this.audioNodes.delay);
    }
   
    source.start(time);
   
    // Visual feedback
    if (time <= this.audioContext.currentTime + 0.05) {
      this.flashSampleNode(slotIndex);
    }
  }
 
  flashSampleNode(index) {
    const node = this.ui.sampleNodes[index];
    if (!node) return;
   
    node.classList.add('playing');
    setTimeout(() => node.classList.remove('playing'), 300);
  }
 
  onBarComplete() {
    this.state.currentBar++;
   
    // Update BPM based on motion
    const targetBPM = 100 + this.state.motionLevel * 60;
    this.state.bpm = this.state.bpm * 0.95 + targetBPM * 0.05;
   
    this.ui.bpmValue.textContent = Math.round(this.state.bpm);
   
    // Update delay time
    this.audioNodes.delay.delayTime.setTargetAtTime(
      60 / this.state.bpm / 8,
      this.audioContext.currentTime,
      0.1
    );
   
    // Update energy
    this.updateEnergy();
  }
 
  updateEnergy() {
    // Calculate energy from motion and samples
    const motionEnergy = this.state.motionLevel;
    const sampleEnergy = this.state.samples.size / this.config.maxSamples;
    const stateEnergy = this.getStateEnergy();
   
    this.state.energy = (motionEnergy * 0.5 + sampleEnergy * 0.3 + stateEnergy * 0.2);
   
    // Update UI
    this.ui.energyValue.textContent = this.state.energy.toFixed(2);
    this.ui.energyBar.style.height = (this.state.energy * 100) + '%';
   
    // Update motion core
    const scale = 1 + this.state.motionLevel;
    this.ui.motionCore.style.transform = `scale(${scale})`;
    this.ui.motionCore.style.opacity = 0.3 + this.state.motionLevel * 0.7;
   
    // Update filter based on energy
    const filterFreq = 200 + this.state.energy * 10000;
    this.audioNodes.filter.frequency.setTargetAtTime(filterFreq, this.audioContext.currentTime, 0.1);
  }
 
  getStateEnergy() {
    switch(this.state.currentState) {
      case 'void': return 0;
      case 'ambient': return 0.2;
      case 'rhythmic': return 0.5;
      case 'elevated': return 0.8;
      case 'chaos': return 1;
      default: return 0;
    }
  }
 
  analyzeInitialState() {
    const avgMotion = this.getAverageMotion();
   
    console.log(`📊 Initial motion level: ${avgMotion.toFixed(2)}`);
   
    if (avgMotion > 0.5) {
      this.transitionToState('elevated');
      this.showNotification('High energy detected - Starting elevated!', 3000);
    } else if (avgMotion > 0.2) {
      this.transitionToState('ambient');
      this.showNotification('Gentle motion - Entering ambient space', 3000);
    } else {
      this.transitionToState('void');
      this.showNotification('Stillness detected - Beginning in the void', 3000);
     
      // Start first auto-sample
      if (this.state.aiDjActive) {
        setTimeout(() => this.autoSample(), 2000);
      }
    }
  }
 
  getAverageMotion() {
    if (this.motionHistory.length === 0) return 0;
   
    const sum = this.motionHistory.reduce((acc, m) => acc + m.level, 0);
    return sum / this.motionHistory.length;
  }
 
  transitionToState(newState) {
    if (this.state.currentState === newState) return;
   
    console.log(`🎭 State transition: ${this.state.currentState} → ${newState}`);
   
    this.state.previousState = this.state.currentState;
    this.state.currentState = newState;
   
    // Update UI
    this.ui.currentState.textContent = newState.toUpperCase();
    this.ui.debug.state.textContent = newState;
   
    // Update subtitle
    const subtitles = {
      void: 'awaiting motion',
      ambient: 'gentle atmosphere',
      rhythmic: 'finding the beat',
      elevated: 'peak energy',
      chaos: 'experimental mode'
    };
   
    this.ui.stateSubtitle.textContent = subtitles[newState];
   
    // Update visual atmosphere
    this.updateVisualState(newState);
   
    // Update audio parameters
    this.updateAudioState(newState);
   
    this.showNotification(`Entering ${newState.toUpperCase()} state`, 2000);
  }
 
  updateVisualState(state) {
    const quantum = document.getElementById('quantumField');
   
    // Remove all state classes
    quantum.className = '';
   
    // Add new state class
    quantum.classList.add(`state-${state}`);
   
    // Update colors
    switch(state) {
      case 'void':
        document.documentElement.style.setProperty('--primary-color', '#00ffff');
        break;
      case 'ambient':
        document.documentElement.style.setProperty('--primary-color', '#00ff00');
        break;
      case 'rhythmic':
        document.documentElement.style.setProperty('--primary-color', '#ff00ff');
        break;
      case 'elevated':
        document.documentElement.style.setProperty('--primary-color', '#ffd700');
        break;
      case 'chaos':
        document.documentElement.style.setProperty('--primary-color', '#ff0040');
        break;
    }
  }
 
  updateAudioState(state) {
    const t = this.audioContext.currentTime;
   
    switch(state) {
      case 'void':
        this.audioNodes.reverbGain.gain.setTargetAtTime(0.8, t, 1);
        this.audioNodes.delayGain.gain.setTargetAtTime(0.6, t, 1);
        this.audioNodes.filter.frequency.setTargetAtTime(500, t, 1);
        break;
       
      case 'ambient':
        this.audioNodes.reverbGain.gain.setTargetAtTime(0.5, t, 1);
        this.audioNodes.delayGain.gain.setTargetAtTime(0.4, t, 1);
        this.audioNodes.filter.frequency.setTargetAtTime(2000, t, 1);
        break;
       
      case 'rhythmic':
        this.audioNodes.reverbGain.gain.setTargetAtTime(0.3, t, 1);
        this.audioNodes.delayGain.gain.setTargetAtTime(0.3, t, 1);
        this.audioNodes.filter.frequency.setTargetAtTime(5000, t, 1);
        break;
       
      case 'elevated':
        this.audioNodes.reverbGain.gain.setTargetAtTime(0.2, t, 1);
        this.audioNodes.delayGain.gain.setTargetAtTime(0.5, t, 1);
        this.audioNodes.filter.frequency.setTargetAtTime(10000, t, 1);
        break;
       
      case 'chaos':
        this.audioNodes.reverbGain.gain.setTargetAtTime(0.4, t, 1);
        this.audioNodes.delayGain.gain.setTargetAtTime(0.7, t, 1);
        this.audioNodes.filter.frequency.setTargetAtTime(15000, t, 1);
        this.audioNodes.distortionGain.gain.setTargetAtTime(0.3, t, 1);
        break;
    }
  }
 
  startAIDJ() {
    console.log('🤖 AI DJ activated');
   
    this.aiDjInterval = setInterval(() => {
      if (this.state.samples.size < this.config.maxSamples && !this.state.isRecording) {
        this.autoSample();
      }
    }, this.config.autoSampleInterval);
  }
 
  autoSample() {
    if (this.state.isRecording || !this.audioNodes.micInput) return;
   
    const slot = this.state.nextSampleSlot;
    this.state.nextSampleSlot = (this.state.nextSampleSlot + 1) % this.config.maxSamples;
   
    console.log(`🎙️ Auto-sampling slot ${slot}`);
   
    this.startRecording(slot);
   
    setTimeout(() => {
      this.stopRecording();
    }, this.config.sampleDuration);
  }
 
  handleRecordButton() {
    if (this.state.isRecording) {
      this.stopRecording();
    } else {
      const slot = this.findEmptySlot();
      if (slot !== -1) {
        this.startRecording(slot);
       
        setTimeout(() => {
          if (this.state.isRecording) {
            this.stopRecording();
          }
        }, this.config.sampleDuration);
      } else {
        this.showNotification('All sample slots full', 2000);
      }
    }
  }
 
  findEmptySlot() {
    for (let i = 0; i < this.config.maxSamples; i++) {
      if (!this.state.samples.has(i)) {
        return i;
      }
    }
    return 0; // Overwrite first slot if all full
  }
 
  startRecording(slot) {
    if (this.state.isRecording || !this.audioNodes.micInput) return;
   
    this.state.isRecording = true;
    this.state.currentRecordingSlot = slot;
    this.recordBuffer = [];
   
    // Update UI
    this.ui.btnRecord.classList.add('recording');
    this.ui.sampleNodes[slot].classList.add('recording');
   
    this.showNotification(`Recording sample ${slot + 1}...`, 1000);
  }
 
  stopRecording() {
    if (!this.state.isRecording) return;
   
    const slot = this.state.currentRecordingSlot;
    this.state.isRecording = false;
   
    // Update UI
    this.ui.btnRecord.classList.remove('recording');
    this.ui.sampleNodes[slot].classList.remove('recording');
   
    // Process sample
    if (this.recordBuffer.length > 0) {
      this.ui.sampleNodes[slot].classList.add('processing');
     
      setTimeout(() => {
        this.processSample(slot, new Float32Array(this.recordBuffer));
        this.ui.sampleNodes[slot].classList.remove('processing');
      }, 100);
    }
  }
 
  processSample(slot, audioData) {
    // Apply processing
    const processed = this.applyProcessing(audioData);
   
    // Create buffer
    const buffer = this.audioContext.createBuffer(1, processed.length, this.audioContext.sampleRate);
    buffer.getChannelData(0).set(processed);
   
    // Analyze
    const analysis = this.analyzeSample(processed);
   
    // Store
    this.state.samples.set(slot, {
      buffer: buffer,
      analysis: analysis,
      timestamp: Date.now()
    });
   
    // Update UI
    this.ui.sampleNodes[slot].classList.add('loaded');
    this.ui.samplesValue.textContent = `${this.state.samples.size}/${this.config.maxSamples}`;
   
    // Draw waveform
    this.drawSampleWaveform(slot, processed);
   
    // Auto-transition from void
    if (this.state.samples.size === 1 && this.state.currentState === 'void') {
      this.transitionToState('ambient');
    }
   
    this.showNotification(`Sample ${slot + 1} processed`, 1500);
  }
 
  applyProcessing(audioData) {
    const processed = new Float32Array(audioData.length);
    const fadeLength = Math.min(1000, audioData.length / 20);
   
    // Find optimal loop points
    const loopStart = this.findZeroCrossing(audioData, fadeLength);
    const loopEnd = this.findZeroCrossing(audioData, audioData.length - fadeLength);
   
    for (let i = 0; i < audioData.length; i++) {
      let sample = audioData[i];
     
      // Fade in
      if (i < fadeLength) {
        sample *= i / fadeLength;
      }
      // Fade out
      else if (i > audioData.length - fadeLength) {
        sample *= (audioData.length - i) / fadeLength;
      }
     
      // Soft compression
      sample = Math.tanh(sample * 2) * 0.5;
     
      // Gate
      if (Math.abs(sample) < 0.01) {
        sample = 0;
      }
     
      processed[i] = sample;
    }
   
    return processed;
  }
 
  findZeroCrossing(audioData, startIndex) {
    for (let i = startIndex; i < audioData.length - 1; i++) {
      if (audioData[i] <= 0 && audioData[i + 1] > 0) {
        return i;
      }
    }
    return startIndex;
  }
 
  analyzeSample(audioData) {
    // RMS
    const rms = Math.sqrt(audioData.reduce((sum, x) => sum + x * x, 0) / audioData.length);
   
    // Peak
    const peak = Math.max(...audioData.map(Math.abs));
   
    // Spectral centroid (simplified)
    const fftSize = 2048;
    const fft = new Float32Array(fftSize);
   
    // Simple onset detection
    const onsets = [];
    const threshold = rms * 1.5;
   
    for (let i = 1; i < audioData.length; i++) {
      if (audioData[i-1] < threshold && audioData[i] >= threshold) {
        onsets.push(i);
      }
    }
   
    return {
      rms: rms,
      peak: peak,
      onsets: onsets.length,
      duration: audioData.length / this.audioContext.sampleRate,
      energy: rms
    };
  }
 
  drawSampleWaveform(slot, audioData) {
    const canvas = this.ui.sampleNodes[slot].querySelector('.sample-canvas');
    const ctx = canvas.getContext('2d');
   
    canvas.width = 50;
    canvas.height = 50;
   
    ctx.clearRect(0, 0, 50, 50);
   
    // Draw circular waveform
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
    ctx.lineWidth = 1.5;
    ctx.beginPath();
   
    const samples = 64;
    const step = Math.floor(audioData.length / samples);
   
    for (let i = 0; i < samples; i++) {
      const angle = (i / samples) * Math.PI * 2 - Math.PI / 2;
      const sample = audioData[i * step] || 0;
      const radius = 15 + sample * 10;
     
      const x = 25 + Math.cos(angle) * radius;
      const y = 25 + Math.sin(angle) * radius;
     
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
   
    ctx.closePath();
    ctx.stroke();
  }
 
  handleSampleTouch(index, action) {
    if (action === 'start') {
      const sample = this.state.samples.get(index);
     
      if (sample) {
        // Play sample
        this.playSampleAt(index, this.audioContext.currentTime, 1);
      } else if (!this.state.isRecording) {
        // Record to empty slot
        this.startRecording(index);
       
        setTimeout(() => {
          if (this.state.isRecording && this.state.currentRecordingSlot === index) {
            this.stopRecording();
          }
        }, this.config.sampleDuration);
      }
    }
  }
 
  handleTapTempo() {
    // Simple tap tempo implementation
    this.ui.btnTap.classList.add('active');
    setTimeout(() => this.ui.btnTap.classList.remove('active'), 100);
   
    if (!this.lastTapTime) {
      this.lastTapTime = Date.now();
      this.tapCount = 1;
    } else {
      const now = Date.now();
      const interval = now - this.lastTapTime;
     
      if (interval < 2000) {
        const bpm = 60000 / interval;
        this.state.bpm = Math.round(Math.max(60, Math.min(200, bpm)));
        this.ui.bpmValue.textContent = this.state.bpm;
       
        this.showNotification(`BPM set to ${this.state.bpm}`, 1500);
      }
     
      this.lastTapTime = now;
    }
  }
 
  toggleLoopMode() {
    this.ui.btnLoop.classList.toggle('active');
    // Loop functionality would go here
    this.showNotification('Loop mode toggled', 1500);
  }
 
  toggleAIDJ() {
    this.state.aiDjActive = !this.state.aiDjActive;
    this.ui.btnAI.classList.toggle('active');
   
    if (this.state.aiDjActive) {
      this.startAIDJ();
      this.showNotification('AI DJ activated', 1500);
    } else {
      clearInterval(this.aiDjInterval);
      this.showNotification('AI DJ deactivated', 1500);
    }
  }
 
  cycleEffects() {
    const effects = ['reverb', 'delay', 'filter', 'distortion', 'chorus'];
   
    // Find next effect
    let found = false;
    for (let fx of effects) {
      if (!this.state.activeEffects.has(fx)) {
        this.state.activeEffects.add(fx);
        found = true;
        this.showNotification(`${fx.toUpperCase()} activated`, 1500);
        break;
      }
    }
   
    if (!found) {
      // All on, turn off first one
      const first = effects.find(fx => this.state.activeEffects.has(fx));
      if (first) {
        this.state.activeEffects.delete(first);
        this.showNotification(`${first.toUpperCase()} deactivated`, 1500);
      }
    }
   
    this.updateEffectIndicators();
    this.updateEffectRouting();
  }
 
  updateEffectIndicators() {
    for (let fx in this.ui.fxIndicators) {
      if (this.state.activeEffects.has(fx)) {
        this.ui.fxIndicators[fx].classList.add('active');
      } else {
        this.ui.fxIndicators[fx].classList.remove('active');
      }
    }
   
    this.ui.btnFX.classList.toggle('active', this.state.activeEffects.size > 1);
  }
 
  updateEffectRouting() {
    const t = this.audioContext.currentTime;
   
    // Update effect levels
    this.audioNodes.reverbGain.gain.setTargetAtTime(
      this.state.activeEffects.has('reverb') ? 0.3 : 0, t, 0.1
    );
   
    this.audioNodes.delayGain.gain.setTargetAtTime(
      this.state.activeEffects.has('delay') ? 0.3 : 0, t, 0.1
    );
   
    this.audioNodes.distortionGain.gain.setTargetAtTime(
      this.state.activeEffects.has('distortion') ? 0.2 : 0, t, 0.1
    );
   
    this.audioNodes.chorusGain.gain.setTargetAtTime(
      this.state.activeEffects.has('chorus') ? 0.2 : 0, t, 0.1
    );
   
    if (this.state.activeEffects.has('filter')) {
      this.audioNodes.filter.Q.value = 5;
    } else {
      this.audioNodes.filter.Q.value = 1;
    }
  }
 
  startJourneyProgression() {
    this.journeyInterval = setInterval(() => {
      const elapsed = Date.now() - this.state.journeyStartTime;
      this.state.journeyElapsed = elapsed;
     
      // Update timeline
      const progress = Math.min(100, (elapsed / this.config.journeyDuration) * 100);
      this.ui.journeyProgress.style.width = progress + '%';
     
      // Update time display
      const minutes = Math.floor(elapsed / 60000);
      const seconds = Math.floor((elapsed % 60000) / 1000);
      this.ui.journeyTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
     
      // Journey phases
      const phase = Math.floor(elapsed / (this.config.journeyDuration / 5));
     
      if (phase !== this.state.journeyPhase) {
        this.state.journeyPhase = phase;
        this.onJourneyPhaseChange(phase);
      }
     
      // Dynamic state transitions
      this.evaluateStateTransition();
     
      // End journey
      if (elapsed >= this.config.journeyDuration) {
        this.endJourney();
      }
     
    }, 1000);
  }
 
  evaluateStateTransition() {
    const avgMotion = this.getAverageMotion();
    const sampleCount = this.state.samples.size;
    const currentPhase = this.state.journeyPhase;
   
    // Motion-based transitions
    if (avgMotion > 0.7 && this.state.currentState !== 'chaos') {
      if (currentPhase >= 2) { // Only in peak or later
        this.transitionToState('chaos');
      } else if (this.state.currentState !== 'elevated') {
        this.transitionToState('elevated');
      }
    } else if (avgMotion > 0.5 && this.state.currentState === 'void') {
      this.transitionToState('ambient');
    } else if (avgMotion > 0.3 && this.state.currentState === 'ambient') {
      this.transitionToState('rhythmic');
    } else if (avgMotion < 0.1 && this.state.currentState === 'rhythmic') {
      this.transitionToState('ambient');
    }
   
    // Sample-based transitions
    if (sampleCount >= 3 && this.state.currentState === 'ambient') {
      this.transitionToState('rhythmic');
    }
  }
 
  onJourneyPhaseChange(phase) {
    const phases = ['INTRODUCTION', 'BUILDING', 'PEAK', 'EXPLORATION', 'RESOLUTION'];
    this.ui.journeyPhase.textContent = phases[phase] || 'COMPLETE';
   
    console.log(`📍 Journey phase: ${phases[phase]}`);
   
    // Phase-specific changes
    switch(phase) {
      case 0: // Introduction
        this.showNotification('Phase 1: Introduction - Find your rhythm', 3000);
        break;
       
      case 1: // Building
        this.showNotification('Phase 2: Building - Energy rising', 3000);
        if (this.state.currentState === 'void') {
          this.transitionToState('ambient');
        }
        break;
       
      case 2: // Peak
        this.showNotification('Phase 3: Peak - Maximum energy', 3000);
        if (this.state.currentState !== 'elevated' && this.state.currentState !== 'chaos') {
          this.transitionToState('rhythmic');
        }
        break;
       
      case 3: // Exploration
        this.showNotification('Phase 4: Exploration - Experimental zone', 3000);
        this.state.activeEffects.add('delay');
        this.state.activeEffects.add('chorus');
        this.updateEffectIndicators();
        this.updateEffectRouting();
        break;
       
      case 4: // Resolution
        this.showNotification('Phase 5: Resolution - Returning to calm', 3000);
        if (this.state.currentState === 'chaos' || this.state.currentState === 'elevated') {
          this.transitionToState('ambient');
        }
        break;
    }
  }

  endJourney() {
    console.log('🏁 Journey complete');
    clearInterval(this.journeyInterval);
    clearTimeout(this.schedulerTimer);
    // Fade out audio
    this.audioNodes.masterGain.gain.linearRampToValueAtTime(0, this.audioContext.currentTime + 5);
    this.showNotification('Journey complete - Thank you for the experience', 5000);
    setTimeout(() => {
      this.transitionToState('void');
      this.ui.permissionOverlay.classList.remove('hidden');
      this.ui.permissionOverlay.querySelector('.permission-title').textContent = 'COMPLETE';
      this.ui.permissionOverlay.querySelector('.permission-text').textContent = 'Your 25-minute journey has ended.';
      const btn = this.ui.permissionOverlay.querySelector('.permission-btn');
      btn.textContent = 'RESTART';
      btn.onclick = () => location.reload();
    }, 5000);
  }

  createTouchRipple(touch) {
    const ripple = document.createElement('div');
    ripple.className = 'touch-ripple';
    ripple.style.left = `${touch.clientX - 20}px`;
    ripple.style.top = `${touch.clientY - 20}px`;
    document.body.appendChild(ripple);
    setTimeout(() => {
      ripple.remove();
    }, 600);
  }

  showNotification(text, duration = 2000) {
    this.ui.notification.textContent = text;
    this.ui.notification.classList.add('visible');
    clearTimeout(this.notificationTimeout);
    this.notificationTimeout = setTimeout(() => {
      this.ui.notification.classList.remove('visible');
    }, duration);
  }

  startVisualization() {
    const animate = () => {
      this.updateParticles();
      this.renderParticles();
      this.renderWaveform();
      this.renderSpatial();
      this.animateNeuralNetwork();
      requestAnimationFrame(animate);
    };
    animate();
  }

  updateParticles() {
    this.particles.forEach(p => {
      p.x += p.vx + (this.state.motionLevel * (Math.random() - 0.5) * 2);
      p.y += p.vy + (this.state.energy * (Math.random() - 0.5) * 2);
      if (p.x < 0 || p.x > window.innerWidth) p.vx *= -1;
      if (p.y < 0 || p.y > window.innerHeight) p.vy *= -1;
      p.life = Math.min(1, p.life + 0.01 * this.state.energy);
    });
  }

  renderParticles() {
    const ctx = this.contexts.particle;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    this.particles.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
      ctx.fillStyle = `var(${p.color})`;
      ctx.globalAlpha = p.life * 0.5;
      ctx.fill();
    });
    ctx.globalAlpha = 1;
  }

  renderWaveform() {
    if (!this.audioNodes.analyser) return;
    const ctx = this.contexts.waveform;
    const width = ctx.canvas.width;
    const height = ctx.canvas.height;
    ctx.clearRect(0, 0, width, height);
    const data = new Uint8Array(this.config.fftSize / 2);
    this.audioNodes.analyser.getByteFrequencyData(data);
    ctx.beginPath();
    ctx.moveTo(0, height);
    for (let i = 0; i < width; i++) {
      const index = Math.floor((i / width) * data.length);
      const value = data[index] / 255 * height;
      ctx.lineTo(i, height - value);
    }
    ctx.lineTo(width, height);
    ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
    ctx.fill();
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
    ctx.stroke();
  }

  renderSpatial() {
    const ctx = this.contexts.spatial;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    // Simple orientation visualization
    const centerX = ctx.canvas.width / 2;
    const centerY = ctx.canvas.height / 2;
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(this.state.orientation.gamma * Math.PI / 180);
    ctx.beginPath();
    ctx.rect(-50, -50, 100, 100);
    ctx.strokeStyle = 'var(--plasma-green)';
    ctx.stroke();
    ctx.restore();
  }

  animateNeuralNetwork() {
    this.neuralNodes.forEach((node, i) => {
      node.activation = Math.sin(Date.now() / 1000 + i) * 0.5 + 0.5;
      node.activation *= this.state.energy;
      node.element.style.opacity = 0.3 + node.activation * 0.7;
      node.element.style.transform = `scale(${1 + node.activation * 0.5})`;
    });
  }
}
const engine = new NeuromancerEngine();
</script>
</body>
</html>
