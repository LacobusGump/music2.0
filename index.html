<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>VIBE Nexus V3 - Quantum Environmental Symphony</title>
  <style>
    :root {
      --quantum-core: #00ff88;
      --nebula-pulse: #ff0088;
      --void-shimmer: #8800ff;
      --abyss-bg: #000011;
      --holo-glass: rgba(255, 255, 255, 0.02);
      --neural-border: rgba(0, 255, 136, 0.1);
      --entropy-glow: rgba(255, 0, 136, 0.2);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: linear-gradient(135deg, var(--abyss-bg), #000022);
      color: #fff;
      font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
      height: 100vh;
      position: relative;
      animation: cosmic-drift 20s ease-in-out infinite alternate;
    }

    @keyframes cosmic-drift {
      0% { background-position: 0% 50%; }
      100% { background-position: 100% 50%; }
    }

    #initNexus {
      position: fixed;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: conic-gradient(from 0deg at 50% 50%, var(--quantum-core), var(--nebula-pulse), var(--void-shimmer), var(--quantum-core));
      background-size: 400% 400%;
      animation: nexus-spin 8s linear infinite;
      z-index: 1000;
      transition: opacity 1.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    @keyframes nexus-spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    .nexus-core {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--holo-glass), transparent);
      border: 2px solid var(--neural-border);
      color: var(--quantum-core);
      font-size: 16px;
      letter-spacing: 4px;
      cursor: pointer;
      position: relative;
      overflow: hidden;
      transition: all 0.6s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .nexus-core:hover {
      transform: scale(1.1) rotate(5deg);
      border-color: var(--quantum-core);
      box-shadow: 0 0 60px var(--entropy-glow);
    }

    .nexus-core::before {
      content: '';
      position: absolute;
      inset: -3px;
      background: conic-gradient(from 0deg, transparent, var(--quantum-core), transparent 50%);
      animation: quantum-orbit 4s linear infinite;
      opacity: 0;
      transition: opacity 0.6s;
    }

    .nexus-core:hover::before {
      opacity: 0.6;
    }

    @keyframes quantum-orbit {
      100% { transform: rotate(360deg); }
    }

    #quantumCanvas {
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: 1;
    }

    .harmonic-orb {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: radial-gradient(circle, var(--quantum-core), transparent 70%);
      filter: blur(2px);
      transform: translate(-50%, -50%);
      transition: all 0.2s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      mix-blend-mode: screen;
      animation: orb-resonance 3s ease-in-out infinite alternate;
    }

    @keyframes orb-resonance {
      0% { opacity: 0.5; transform: scale(1); }
      100% { opacity: 1; transform: scale(1.2); }
    }

    .nexus-panel {
      position: fixed;
      background: var(--holo-glass);
      backdrop-filter: blur(30px) saturate(180%);
      border: 1px solid var(--neural-border);
      border-radius: 16px;
      padding: 24px;
      font-size: 12px;
      letter-spacing: 1.5px;
      z-index: 100;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.5);
    }

    .nexus-panel.top-left { top: 24px; left: 24px; min-width: 280px; }
    .nexus-panel.top-right { top: 24px; right: 24px; min-width: 220px; }
    .nexus-panel.bottom-left { bottom: 24px; left: 24px; min-width: 280px; }
    .nexus-panel.bottom-right { bottom: 24px; right: 24px; min-width: 220px; }

    .panel-header {
      font-size: 11px;
      opacity: 0.6;
      margin-bottom: 16px;
      text-transform: uppercase;
      letter-spacing: 3px;
      color: var(--quantum-core);
    }

    .quantum-metric {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin: 10px 0;
      opacity: 0.9;
    }

    .metric-core {
      color: var(--nebula-pulse);
      font-weight: 700;
    }

    .entropy-bar {
      height: 3px;
      background: rgba(255, 255, 255, 0.08);
      border-radius: 2px;
      overflow: hidden;
      margin: 10px 0;
    }

    .bar-flow {
      height: 100%;
      background: linear-gradient(90deg, var(--quantum-core), var(--nebula-pulse), var(--void-shimmer));
      transition: width 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      animation: flow-pulse 2s ease-in-out infinite;
    }

    @keyframes flow-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }

    .harmonic-spectrum {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      height: 140px;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      gap: 3px;
      padding: 0 24px;
      pointer-events: none;
    }

    .spectrum-wave {
      flex: 1;
      max-width: 8px;
      background: linear-gradient(to top, var(--quantum-core), transparent);
      border-radius: 4px 4px 0 0;
      transition: height 0.08s ease-out;
      opacity: 0.85;
      position: relative;
      overflow: hidden;
    }

    .spectrum-wave::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(to top, var(--nebula-pulse), transparent);
      opacity: 0.3;
      transform: scaleY(0);
      transition: transform 0.08s ease-out;
    }

    .env-resonator {
      position: fixed;
      top: 50%;
      left: 24px;
      transform: translateY(-50%);
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .resonate-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      background: var(--holo-glass);
      border: 1px solid var(--neural-border);
      color: white;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
      backdrop-filter: blur(15px);
      font-size: 20px;
    }

    .resonate-btn:hover {
      border-color: var(--quantum-core);
      transform: scale(1.15) rotate(10deg);
      box-shadow: 0 0 30px var(--entropy-glow);
    }

    .resonate-btn.active {
      background: rgba(0, 255, 136, 0.15);
      border-color: var(--quantum-core);
      animation: quantum-pulse 1.5s ease-in-out infinite;
    }

    @keyframes quantum-pulse {
      0%, 100% { box-shadow: 0 0 20px var(--quantum-core); transform: scale(1); }
      50% { box-shadow: 0 0 50px var(--quantum-core); transform: scale(1.1); }
    }

    .particle-swarm {
      position: absolute;
      width: 6px;
      height: 6px;
      background: var(--quantum-core);
      border-radius: 50%;
      pointer-events: none;
      animation: swarm-drift 4s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
      box-shadow: 0 0 10px var(--quantum-core);
    }

    @keyframes swarm-drift {
      0% {
        transform: translate(0, 0) scale(1);
        opacity: 1;
      }
      100% {
        transform: translate(var(--vx), var(--vy)) scale(0.2);
        opacity: 0;
      }
    }

    .symphony-core {
      position: fixed;
      top: 50%;
      right: 24px;
      transform: translateY(-50%);
      writing-mode: vertical-rl;
      text-orientation: mixed;
      font-size: 12px;
      letter-spacing: 4px;
      opacity: 0.4;
      text-transform: uppercase;
      color: var(--nebula-pulse);
      animation: core-throb 2s ease-in-out infinite;
    }

    @keyframes core-throb {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 0.8; }
    }

    .hidden { display: none !important; }

    /* Future-proof responsive */
    @media (max-width: 768px) {
      .nexus-panel { min-width: auto; padding: 16px; }
      .env-resonator { left: 12px; }
      .symphony-core { right: 12px; }
      .harmonic-spectrum { height: 100px; padding: 0 12px; }
    }
  </style>
</head>
<body>
  <div id="initNexus">
    <button class="nexus-core" id="nexusCore">ACTIVATE NEXUS</button>
    <p style="margin-top: 40px; opacity: 0.6; font-size: 12px; letter-spacing: 3px;">QUANTUM ENVIRONMENTAL SYMPHONY</p>
  </div>

  <canvas id="quantumCanvas"></canvas>

  <div class="nexus-panel top-left hidden" id="audioNexus">
    <div class="panel-header">Audio Quantum Core</div>
    <div class="quantum-metric">
      <span>Core Flux</span>
      <span class="metric-core" id="coreFluxVal">0.00</span>
    </div>
    <div class="entropy-bar">
      <div class="bar-flow" id="coreFluxBar"></div>
    </div>
    <div class="quantum-metric">
      <span>Dynamics</span>
      <span class="metric-core" id="dynamicsVal">0dB</span>
    </div>
    <div class="quantum-metric">
      <span>Resonant Voices</span>
      <span class="metric-core" id="resonantVoices">0</span>
    </div>
    <div class="quantum-metric">
      <span>Neural Load</span>
      <span class="metric-core" id="neuralLoad">0%</span>
    </div>
  </div>

  <div class="nexus-panel top-right hidden" id="envNexus">
    <div class="panel-header">Environmental Entanglement</div>
    <div class="quantum-metric">
      <span>Kinetics</span>
      <span class="metric-core" id="kineticsVal">0.00</span>
    </div>
    <div class="entropy-bar">
      <div class="bar-flow" id="kineticsBar"></div>
    </div>
    <div class="quantum-metric">
      <span>Atmospheric Density</span>
      <span class="metric-core" id="atmoDensityVal">0dB</span>
    </div>
    <div class="quantum-metric">
      <span>Entropic Samples</span>
      <span class="metric-core" id="entropicSamples">0</span>
    </div>
  </div>

  <div class="nexus-panel bottom-left hidden" id="synthNexus">
    <div class="panel-header">Symphonic Architect</div>
    <div class="quantum-metric">
      <span>Resonance Mode</span>
      <span class="metric-core" id="resonanceMode">QUANTUM HYBRID</span>
    </div>
    <div class="quantum-metric">
      <span>Harmonic Key</span>
      <span class="metric-core" id="harmonicKey">C MAJ</span>
    </div>
    <div class="quantum-metric">
      <span>Pulse Rate</span>
      <span class="metric-core" id="pulseRate">120</span>
    </div>
    <div class="quantum-metric">
      <span>Overtonal Layers</span>
      <span class="metric-core" id="overtonalLayers">5</span>
    </div>
  </div>

  <div class="nexus-panel bottom-right hidden" id="mixNexus">
    <div class="panel-header">Multiversal Mix</div>
    <div class="quantum-metric">
      <span>Subspace</span>
      <span class="metric-core" id="subspaceVal">0dB</span>
    </div>
    <div class="quantum-metric">
      <span>Resonant Mid</span>
      <span class="metric-core" id="resMidVal">0dB</span>
    </div>
    <div class="quantum-metric">
      <span>Ether High</span>
      <span class="metric-core" id="etherHighVal">0dB</span>
    </div>
    <div class="quantum-metric">
      <span>Phase Drift</span>
      <span class="metric-core" id="phaseDrift">50%</span>
    </div>
  </div>

  <div class="env-resonator hidden" id="resonator">
    <button class="resonate-btn" id="micResonator" title="Entangle Microphone">üåå</button>
    <button class="resonate-btn" id="captureResonator" title="Capture Entropic Sample">‚öõ</button>
    <button class="resonate-btn" id="granularNexus" title="Activate Granular Vortex">‚àû</button>
    <button class="resonate-btn" id="weatherSync" title="Sync Atmospheric Data">‚òÅ</button>
  </div>

  <div class="harmonic-spectrum" id="harmonicSpectrum"></div>

  <div class="symphony-core hidden" id="symphonyCore">ENTANGLED</div>

  <div class="harmonic-orb" id="resonanceOrb" style="display: none;"></div>

  <script type="module">
    // Future-Proof Imports (ES Modules in Browser)
    // Note: For full modularity, consider bundling with esbuild or similar.

    class QuantumVoicePool {
      #pool = new Map();
      #maxVoices = 64;
      #ctx;

      constructor(ctx) {
        this.#ctx = ctx;
      }

      acquire(id, config = {}) {
        if (this.#pool.size >= this.#maxVoices) {
          // Quantum eviction: release oldest
          const oldest = this.#pool.keys().next().value;
          this.release(oldest);
        }
        const voice = this.#createVoice(config);
        this.#pool.set(id, { voice, config, timestamp: performance.now() });
        return voice;
      }

      release(id) {
        const entry = this.#pool.get(id);
        if (entry) {
          entry.voice.stop();
          this.#pool.delete(id);
        }
      }

      #createVoice({ type = 'subtractive', freq, duration, ...params }) {
        const osc = this.#ctx.createOscillator();
        const gain = this.#ctx.createGain();
        const filter = this.#ctx.createBiquadFilter();

        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.#ctx.currentTime);

        filter.type = 'lowpass';
        filter.frequency.value = freq * 2;
        filter.Q.value = params.q || 3;

        gain.gain.setValueAtTime(0, this.#ctx.currentTime);
        gain.gain.linearRampToValueAtTime(params.amp || 0.2, this.#ctx.currentTime + (params.attack || 0.01));
        gain.gain.exponentialRampToValueAtTime(0.001, this.#ctx.currentTime + duration);

        osc.connect(filter).connect(gain);
        gain.connect(this.#ctx.destination); // Direct for now, route later

        osc.start();
        osc.stop(this.#ctx.currentTime + duration);

        return { osc, gain, filter };
      }

      getActiveCount() {
        return this.#pool.size;
      }
    }

    class HarmonicSequencer {
      #scale;
      #keyOffset;
      #bpm;
      #ctx;
      #voicePool;
      #scheduleAhead = 0.1;

      constructor(ctx, voicePool, key = 'C', mode = 'major', bpm = 120) {
        this.#ctx = ctx;
        this.#voicePool = voicePool;
        this.setKey(key, mode);
        this.setBPM(bpm);
        this.#scale = this.#generateScale();
      }

      setKey(key, mode) {
        this.#keyOffset = ['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'].indexOf(key);
        const intervals = mode === 'major' ? [0,2,4,5,7,9,11] : [0,2,3,5,7,8,10];
        this.#scale = intervals.map(i => i + this.#keyOffset);
      }

      setBPM(bpm) {
        this.#bpm = bpm;
      }

      #generateScale() {
        return this.#scale.map(semitone => 261.63 * Math.pow(2, semitone / 12)); // Base A4-ish
      }

      scheduleChord(time, rootDegree, inversion = 0, voicing = [0,2,4]) {
        voicing.forEach((interval, idx) => {
          const degree = (rootDegree + interval + inversion) % this.#scale.length;
          const freq = this.#scale[degree] * Math.pow(2, Math.floor(Math.random() * 3) + 2); // Octave variation
          const id = `chord-${time}-${idx}`;
          this.#voicePool.acquire(id, { freq, duration: 1 / this.#bpm * 60 * 4, amp: 0.15 / voicing.length });
        });
      }

      scheduleMelody(time, pattern) {
        pattern.forEach((note, idx) => {
          if (note > 0) {
            const freq = this.#scale[note % this.#scale.length] * Math.pow(2, 3);
            const id = `melody-${time}-${idx}`;
            this.#voicePool.acquire(id, { freq, duration: 0.25, amp: 0.1 });
          }
        });
      }

      start() {
        let nextTime = this.#ctx.currentTime;
        const scheduler = () => {
          while (nextTime < this.#ctx.currentTime + this.#scheduleAhead) {
            const beat = (nextTime % (60 / this.#bpm)) / (60 / this.#bpm);
            // Intentional progression: I-IV-V-I cycle modulated by env
            const root = Math.floor(beat * 4) % 4; // Simple cycle
            this.scheduleChord(nextTime, root);
            // Melody layer
            const melodyPattern = [0,0,1,0,2,0,0,0]; // Arpeggio-like
            this.scheduleMelody(nextTime, melodyPattern.map((n,i) => (i%4===0 ? n+root%7 : n)));
            nextTime += 60 / this.#bpm / 4; // 16th notes
          }
          requestAnimationFrame(scheduler);
        };
        scheduler();
      }
    }

    class AtmosphericEntangler {
      #ctx;
      #position = { lat: 0, lon: 0 };
      #weather = { temp: 20, wind: 0, precip: 0, humidity: 50 };
      #updateInterval;

      constructor(ctx) {
        this.#ctx = ctx;
      }

      async entangle() {
        if (!navigator.geolocation) return;
        navigator.geolocation.getCurrentPosition(async (pos) => {
          this.#position.lat = pos.coords.latitude;
          this.#position.lon = pos.coords.longitude;
          await this.#fetchAtmospherics();
          this.#startWeatherPolling();
        }, (err) => console.warn('Geolocation failed:', err));
      }

      async #fetchAtmospherics() {
        try {
          const res = await fetch(`https://api.open-meteo.com/v1/forecast?latitude=${this.#position.lat}&longitude=${this.#position.lon}&current=temperature_2m,wind_speed_10m,precipitation,relative_humidity_2m`);
          const data = await res.json();
          const current = data.current;
          this.#weather = {
            temp: current.temperature_2m,
            wind: current.wind_speed_10m,
            precip: current.precipitation,
            humidity: current.relative_humidity_2m
          };
        } catch (err) {
          console.warn('Weather fetch failed:', err);
          // Fallback to simulated data
          this.#weather = { temp: 20 + Math.sin(Date.now()/10000)*10, wind: Math.random()*20, precip: Math.random()*5, humidity: 50 + Math.random()*20 };
        }
      }

      #startWeatherPolling() {
        this.#updateInterval = setInterval(() => this.#fetchAtmospherics(), 60000); // 1 min
      }

      getInfluence() {
        // Map weather to sound params: temp -> pitch shift, wind -> LFO rate, precip -> reverb, humidity -> filter Q
        return {
          pitchShift: (this.#weather.temp - 20) / 30, // -1 to 1
          lfoRate: this.#weather.wind / 50,
          reverbWet: this.#weather.precip / 10,
          filterQ: 1 + this.#weather.humidity / 100 * 10
        };
      }

      disconnect() {
        if (this.#updateInterval) clearInterval(this.#updateInterval);
      }
    }

    class GranularVortex {
      #ctx;
      #output;
      #samples = [];
      #activeGrains = new Set();
      #input;
      #maxGrains = 32;
      #active = false;

      constructor(ctx, output) {
        this.#ctx = ctx;
        this.#output = output;
        this.#input = ctx.createGain();
      }

      addSample(buffer) {
        this.#samples.push(buffer);
      }

      toggle() {
        this.#active = !this.#active;
        if (this.#active && this.#samples.length > 0) {
          this.#spawnVortex();
        }
      }

      #spawnVortex() {
        const scheduler = () => {
          if (!this.#active || this.#activeGrains.size >= this.#maxGrains) {
            setTimeout(scheduler, 50);
            return;
          }
          const buffer = this.#samples[Math.floor(Math.random() * this.#samples.length)];
          const grain = this.#createGrain(buffer);
          this.#activeGrains.add(grain.id);
          grain.source.onended = () => {
            this.#activeGrains.delete(grain.id);
          };
          setTimeout(scheduler, 20 + Math.random() * 100); // Variable density
        };
        scheduler();
      }

      #createGrain(buffer) {
        const source = this.#ctx.createBufferSource();
        const gain = this.#ctx.createGain();
        const pan = this.#ctx.createStereoPanner();
        const delay = this.#ctx.createDelay(0.1);
        const feedback = this.#ctx.createGain();
        feedback.gain.value = 0.3;

        source.buffer = buffer;
        const grainLen = 0.02 + Math.random() * 0.08;
        const offset = Math.random() * (buffer.duration - grainLen);
        source.playbackRate.value = 0.5 + Math.random() * 2;
        pan.pan.value = (Math.random() - 0.5) * 0.8;

        gain.gain.setValueAtTime(0, this.#ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15, this.#ctx.currentTime + grainLen * 0.2);
        gain.gain.linearRampToValueAtTime(0, this.#ctx.currentTime + grainLen);

        source.connect(pan).connect(gain);
        gain.connect(delay);
        delay.connect(feedback);
        feedback.connect(delay);
        gain.connect(this.#output);

        const id = Symbol();
        source.start(this.#ctx.currentTime, offset, grainLen);
        return { id, source };
      }

      get input() {
        return this.#input;
      }
    }

    class VibeNexus {
      #ctx = null;
      #active = false;
      #voicePool;
      #sequencer;
      #atmEntangler = new AtmosphericEntangler();
      #granularVortex;
      #micStream = null;
      #micSource = null;
      #recorder = null;
      #motion = { x: 0, y: 0, z: 0, magnitude: 0 };
      #position = { x: 50, y: 50 };
      #samples = [];
      #ui = {};
      #visualData = new Uint8Array(512);
      #canvasCtx;
      #weatherInfluence = { pitchShift: 0, lfoRate: 0, reverbWet: 0, filterQ: 1 };

      #scales = {
        major: [0, 2, 4, 5, 7, 9, 11],
        minor: [0, 2, 3, 5, 7, 8, 10]
      };

      async init() {
        this.#bindUI();
        this.#setupCanvas();
        this.#setupSpectrum();
        this.#setupMotion();
        await this.#atmEntangler.entangle();
      }

      #bindUI() {
        this.#ui = {
          nexusCore: document.getElementById('nexusCore'),
          initNexus: document.getElementById('initNexus'),
          quantumCanvas: document.getElementById('quantumCanvas'),
          resonanceOrb: document.getElementById('resonanceOrb'),
          harmonicSpectrum: document.getElementById('harmonicSpectrum'),

          audioNexus: document.getElementById('audioNexus'),
          envNexus: document.getElementById('envNexus'),
          synthNexus: document.getElementById('synthNexus'),
          mixNexus: document.getElementById('mixNexus'),
          resonator: document.getElementById('resonator'),
          symphonyCore: document.getElementById('symphonyCore'),

          coreFluxVal: document.getElementById('coreFluxVal'),
          coreFluxBar: document.getElementById('coreFluxBar'),
          dynamicsVal: document.getElementById('dynamicsVal'),
          resonantVoices: document.getElementById('resonantVoices'),
          neuralLoad: document.getElementById('neuralLoad'),
          kineticsVal: document.getElementById('kineticsVal'),
          kineticsBar: document.getElementById('kineticsBar'),
          atmoDensityVal: document.getElementById('atmoDensityVal'),
          entropicSamples: document.getElementById('entropicSamples'),
          resonanceMode: document.getElementById('resonanceMode'),
          harmonicKey: document.getElementById('harmonicKey'),
          pulseRate: document.getElementById('pulseRate'),
          overtonalLayers: document.getElementById('overtonalLayers'),
          subspaceVal: document.getElementById('subspaceVal'),
          resMidVal: document.getElementById('resMidVal'),
          etherHighVal: document.getElementById('etherHighVal'),
          phaseDrift: document.getElementById('phaseDrift'),

          micResonator: document.getElementById('micResonator'),
          captureResonator: document.getElementById('captureResonator'),
          granularNexus: document.getElementById('granularNexus'),
          weatherSync: document.getElementById('weatherSync')
        };

        this.#ui.nexusCore.addEventListener('click', () => this.#activate());
        this.#ui.micResonator.addEventListener('click', () => this.#toggleMic());
        this.#ui.captureResonator.addEventListener('click', () => this.#toggleCapture());
        this.#ui.granularNexus.addEventListener('click', () => this.#toggleGranular());
        this.#ui.weatherSync.addEventListener('click', () => this.#atmEntangler.entangle());
      }

      #setupCanvas() {
        const canvas = this.#ui.quantumCanvas;
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        this.#canvasCtx = canvas.getContext('2d', { alpha: true });
        window.addEventListener('resize', () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        });
      }

      #setupSpectrum() {
        for (let i = 0; i < 128; i++) {
          const wave = document.createElement('div');
          wave.className = 'spectrum-wave';
          this.#ui.harmonicSpectrum.appendChild(wave);
        }
      }

      #setupMotion() {
        if (typeof DeviceMotionEvent.requestPermission === 'function') {
          DeviceMotionEvent.requestPermission().then(permission => {
            if (permission === 'granted') {
              window.addEventListener('devicemotion', (e) => this.#updateMotion(e));
            }
          });
        } else {
          window.addEventListener('devicemotion', (e) => this.#updateMotion(e));
        }

        window.addEventListener('deviceorientation', (e) => {
          this.#position.x = (e.gamma + 90) / 180 * 100;
          this.#position.y = (e.beta + 90) / 180 * 100;
        });

        window.addEventListener('mousemove', (e) => {
          this.#position.x = (e.clientX / window.innerWidth) * 100;
          this.#position.y = (e.clientY / window.innerHeight) * 100;
        });
      }

      #updateMotion(e) {
        const acc = e.accelerationIncludingGravity;
        if (acc) {
          this.#motion.x = acc.x || 0;
          this.#motion.y = acc.y || 0;
          this.#motion.z = acc.z || 0;
          this.#motion.magnitude = Math.sqrt(this.#motion.x**2 + this.#motion.y**2 + this.#motion.z**2);
          this.#adaptToMotion();
        }
      }

      async #activate() {
        try {
          this.#ctx = new AudioContext({ latencyHint: 'interactive', sampleRate: 48000 });
          await this.#ctx.resume();

          // Advanced chain: Multiband + Convolution + Spatial
          this.#setupQuantumChain();
          this.#voicePool = new QuantumVoicePool(this.#ctx);
          this.#sequencer = new HarmonicSequencer(this.#ctx, this.#voicePool, 'C', 'major', 120);
          this.#sequencer.start();
          this.#granularVortex = new GranularVortex(this.#ctx, this.#ctx.destination);

          this.#ui.initNexus.style.opacity = '0';
          setTimeout(() => {
            this.#ui.initNexus.classList.add('hidden');
            this.#revealNexus();
          }, 1500);

          this.#active = true;
          this.#renderLoop();
        } catch (err) {
          console.error('Nexus activation failed:', err);
          alert('Quantum entanglement failed. Verify permissions.');
        }
      }

      #setupQuantumChain() {
        // Limiter
        const limiter = this.#ctx.createDynamicsCompressor();
        limiter.threshold.value = -2;
        limiter.ratio.value = 12;
        limiter.attack.value = 0.001;
        limiter.release.value = 0.05;

        // Master Gain
        const masterGain = this.#ctx.createGain();
        masterGain.gain.value = 0.75;

        // Multiband Compressor (simplified)
        const lowComp = this.#ctx.createDynamicsCompressor();
        lowComp.threshold.value = -30;
        const midComp = this.#ctx.createDynamicsCompressor();
        midComp.threshold.value = -25;
        const highComp = this.#ctx.createDynamicsCompressor();
        highComp.threshold.value = -20;

        // EQ Cascade
        const lowShelf = this.#ctx.createBiquadFilter();
        lowShelf.type = 'lowshelf';
        lowShelf.frequency.value = 250;
        lowShelf.gain.value = 0;

        const midPeak = this.#ctx.createBiquadFilter();
        midPeak.type = 'peaking';
        midPeak.frequency.value = 1200;
        midPeak.Q.value = 1;
        midPeak.gain.value = 0;

        const highShelf = this.#ctx.createBiquadFilter();
        highShelf.type = 'highshelf';
        highShelf.frequency.value = 6000;
        highShelf.gain.value = 0;

        // Convolution with procedural IR
        const convolver = this.#ctx.createConvolver();
        convolver.buffer = this.#generateIR(4, 2.5, this.#weatherInfluence.reverbWet || 0.3);

        const reverbGain = this.#ctx.createGain();
        reverbGain.gain.value = 0.25;

        // Analyser
        const analyser = this.#ctx.createAnalyser();
        analyser.fftSize = 1024;
        analyser.smoothingTimeConstant = 0.85;

        // Route: EQ -> Compressor -> Master -> Limiter -> Analyser -> Dest
        lowShelf.connect(midPeak).connect(highShelf).connect(masterGain).connect(limiter).connect(analyser).connect(this.#ctx.destination);
        convolver.connect(reverbGain).connect(masterGain);

        // Weather-modulated LFO for filter
        this.#modulateWithWeather(analyser);
      }

      #generateIR(duration, decay, wet) {
        const length = this.#ctx.sampleRate * duration;
        const ir = this.#ctx.createBuffer(2, length, this.#ctx.sampleRate);
        for (let ch = 0; ch < 2; ch++) {
          const data = ir.getChannelData(ch);
          for (let i = 0; i < length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, decay) * wet;
          }
        }
        return ir;
      }

      #modulateWithWeather(analyser) {
        // LFO on mid filter freq
        const lfo = this.#ctx.createOscillator();
        const lfoGain = this.#ctx.createGain();
        lfo.type = 'sine';
        lfo.frequency.value = 0.1; // Base
        lfoGain.gain.value = 500; // Depth
        lfo.connect(lfoGain).connect(this.#ui.midPeak.frequency); // Assume global access or param
        lfo.start();
      }

      #revealNexus() {
        [this.#ui.audioNexus, this.#ui.envNexus, this.#ui.synthNexus, this.#ui.mixNexus, this.#ui.resonator, this.#ui.symphonyCore].forEach(el => el.classList.remove('hidden'));
        this.#ui.resonanceOrb.style.display = 'block';
      }

      async #toggleMic() {
        if (this.#micStream) {
          this.#micStream.getTracks().forEach(t => t.stop());
          this.#micSource?.disconnect();
          this.#micStream = null;
          this.#micSource = null;
          this.#ui.micResonator.classList.remove('active');
        } else {
          try {
            this.#micStream = await navigator.mediaDevices.getUserMedia({
              audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false, sampleRate: 48000 }
            });
            this.#micSource = this.#ctx.createMediaStreamSource(this.#micStream);
            const micGain = this.#ctx.createGain();
            micGain.gain.value = 0.2;
            const micHPF = this.#ctx.createBiquadFilter();
            micHPF.type = 'highpass';
            micHPF.frequency.value = 80;
            this.#micSource.connect(micHPF).connect(micGain);
            micGain.connect(this.#granularVortex.input);
            micGain.connect(this.#ctx.destination); // Ambient mix
            this.#ui.micResonator.classList.add('active');
          } catch (err) {
            console.error('Mic entanglement failed:', err);
          }
        }
      }

      async #toggleCapture() {
        if (!this.#micSource) await this.#toggleMic();
        if (this.#recorder?.state === 'recording') {
          this.#recorder.stop();
          this.#ui.captureResonator.classList.remove('active');
        } else {
          const dest = this.#ctx.createMediaStreamDestination();
          this.#micSource.connect(dest);
          const chunks = [];
          this.#recorder = new MediaRecorder(dest.stream);
          this.#recorder.ondataavailable = e => chunks.push(e.data);
          this.#recorder.onstop = async () => {
            const blob = new Blob(chunks, { type: 'audio/webm' });
            const ab = await blob.arrayBuffer();
            const buffer = await this.#ctx.decodeAudioData(ab);
            this.#samples.push(buffer);
            this.#granularVortex.addSample(buffer);
            this.#ui.entropicSamples.textContent = this.#samples.length;
          };
          this.#recorder.start();
          this.#ui.captureResonator.classList.add('active');
          setTimeout(() => this.#recorder?.stop(), 3000); // 3s capture
        }
      }

      #toggleGranular() {
        this.#granularVortex.toggle();
        this.#ui.granularNexus.classList.toggle('active');
      }

      #adaptToMotion() {
        const norm = Math.min(this.#motion.magnitude / 15, 1);
        this.#sequencer.setBPM(80 + norm * 100);
        this.#weatherInfluence.lfoRate = norm * 5;
        // Trigger percussive layer on high motion
        if (norm > 0.4 && Math.random() < 0.15) {
          this.#triggerKineticBurst(norm);
        }
      }

      #triggerKineticBurst(intensity) {
        const freqs = [40 + intensity * 80, 200 * intensity]; // Low boom + mid whoosh
        freqs.forEach((f, i) => {
          const id = `burst-${Date.now()}-${i}`;
          this.#voicePool.acquire(id, { type: i === 0 ? 'sine' : 'noise', freq: f, duration: 0.3 + intensity * 0.2, amp: intensity * 0.4 });
        });
        this.#spawnParticle(this.#position.x, this.#position.y);
      }

      #spawnParticle(x, y) {
        const particle = document.createElement('div');
        particle.className = 'particle-swarm';
        particle.style.left = `${x}%`;
        particle.style.top = `${y}%`;
        particle.style.setProperty('--vx', `${(Math.random() - 0.5) * 300}px`);
        particle.style.setProperty('--vy', `${(Math.random() - 0.5) * 300}px`);
        document.body.appendChild(particle);
        setTimeout(() => particle.remove(), 4000);
      }

      #updateNexusMetrics() {
        if (!this.#active) return;

        // Audio
        this.#ui.coreFluxVal.textContent = 0.75.toFixed(2); // Static for demo
        this.#ui.coreFluxBar.style.width = '75%';
        this.#ui.dynamicsVal.textContent = '0dB'; // From compressor.reduction if available
        this.#ui.resonantVoices.textContent = this.#voicePool.getActiveCount();
        this.#ui.neuralLoad.textContent = `${Math.min((this.#voicePool.getActiveCount() / 64) * 100, 100).toFixed(0)}%`;

        // Env
        this.#ui.kineticsVal.textContent = this.#motion.magnitude.toFixed(2);
        this.#ui.kineticsBar.style.width = `${Math.min(this.#motion.magnitude * 10, 100)}%`;
        this.#ui.atmoDensityVal.textContent = `${this.#weatherInfluence.reverbWet * 20}dB`;
        this.#ui.entropicSamples.textContent = this.#samples.length;

        // Synth
        this.#ui.pulseRate.textContent = Math.round(this.#sequencer.#bpm); // Private hack for demo
        this.#ui.harmonicKey.textContent = 'C MAJ';

        // Mix (adapt to weather)
        this.#ui.subspaceVal.textContent = `${this.#weatherInfluence.pitchShift * 10}dB`;
        this.#ui.resMidVal.textContent = '0dB';
        this.#ui.etherHighVal.textContent = '0dB';
        this.#ui.phaseDrift.textContent = '50%';

        // Spectrum
        if (this.#ctx) {
          const analyser = this.#ctx.createAnalyser(); // Assume connected
          analyser.getByteFrequencyData(this.#visualData);
          document.querySelectorAll('.spectrum-wave').forEach((wave, i) => {
            const val = this.#visualData[i * 4] / 255;
            wave.style.height = `${val * 120}px`;
            wave.style.setProperty('--wave-height', val);
          });
        }

        // Orb
        this.#ui.resonanceOrb.style.left = `${this.#position.x}%`;
        this.#ui.resonanceOrb.style.top = `${this.#position.y}%`;
        this.#ui.resonanceOrb.style.width = `${50 + this.#motion.magnitude * 3}px`;
        this.#ui.resonanceOrb.style.height = `${50 + this.#motion.magnitude * 3}px`;

        // Update weather influence
        Object.assign(this.#weatherInfluence, this.#atmEntangler.getInfluence());
      }

      #renderQuantum() {
        const ctx = this.#canvasCtx;
        const { width, height } = ctx.canvas;
        ctx.fillStyle = 'rgba(0, 0, 17, 0.05)';
        ctx.fillRect(0, 0, width, height);

        // Waveform render with motion distortion
        if (this.#ctx) {
          const analyser = this.#ctx.createAnalyser();
          const timeData = new Uint8Array(analyser.frequencyBinCount);
          analyser.getByteTimeDomainData(timeData);
          ctx.lineWidth = 3;
          ctx.strokeStyle = `hsl(${this.#motion.magnitude * 360}, 100%, 50%)`;
          ctx.beginPath();
          const sliceW = width / timeData.length;
          let x = 0;
          timeData.forEach((v, i) => {
            const y = (v / 128) * height / 2 + (this.#motion.y * 10 || 0); // Distort
            if (i === 0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
            x += sliceW;
          });
          ctx.stroke();
        }
      }

      #renderLoop() {
        if (!this.#active) return;
        this.#updateNexusMetrics();
        this.#renderQuantum();
        requestAnimationFrame(() => this.#renderLoop());
      }
    }

    // Nexus Activation
    const nexus = new VibeNexus();
    window.addEventListener('load', () => nexus.init());
  </script>
</body>
</html>
