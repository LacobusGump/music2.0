<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>GUMP: Infinite Overture</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    html,body { height:100%; margin:0; background:#06080F; }
    body { font-family: -apple-system,BlinkMacSystemFont,sans-serif; color:#d0eaff;}
    .intro {
      position:fixed; top:0; left:0; width:100vw; height:100vh;
      background:radial-gradient(ellipse at 60% 52%,#202742 0%,#050912 89%);
      display:flex; flex-direction:column; align-items:center; justify-content:center;
      z-index:99; transition:opacity 1.1s;
    }
    .intro-title {
      font-size:2.7rem; font-weight:900; letter-spacing:2px;
      color:#e5f8ff; text-shadow:0 0 60px #a7fffc,0 4px 16px #000b;
      margin-bottom:2.1rem; opacity:.98;
      animation:introFade 2.7s cubic-bezier(.9,0,.1,1) alternate infinite;
    }
    .intro-author {
      font-size:1.08rem; color:#b3e3f9; opacity:.84; margin-bottom:2.6rem; letter-spacing:.7px;
    }
    .intro-btn {
      background:linear-gradient(85deg,#1cf2fe 25%,#9a47e4 90%);
      color:#111; font-weight:700; font-size:1.19rem; padding:21px 54px;
      border-radius:42px; border:none; cursor:pointer; box-shadow:0 0 36px #67d4fd2d;
      letter-spacing:1.2px; transition:transform 0.17s;
    }
    .intro-btn:active { transform:scale(0.97);}
    @keyframes introFade { from { text-shadow:0 0 26px #b2fff7; } to { text-shadow:0 0 78px #fff9,0 4px 20px #b4d7ff88;} }
    .app { position:fixed; top:0; left:0; width:100vw; height:100vh; z-index:1; opacity:0; transition:opacity 1.3s;}
    .orb-viz {
      width:90vw; max-width:420px; height:90vw; max-height:420px;
      margin:0 auto; position:relative; top:5vh;
      border-radius:50%; background:radial-gradient(circle at 40% 50%,#181838 16%,#111426 90%);
      box-shadow:0 0 150px 10px #ba55fd33,0 0 160px #02122e99 inset;
      border:2.8px solid #5e79cf50;
      display:flex; align-items:center; justify-content:center;
      transition:all 2.7s cubic-bezier(0.4,0,0.2,1);
    }
    .orb-viz.void {
      background:radial-gradient(circle at 47% 48%,#40174c 17%,#110d24 90%);
      box-shadow:0 0 220px 30px #9d5caf66,0 0 180px #4a1049cc inset;
      border:2.5px solid #cf9cad90;
    }
    .music-orb {
      position:absolute; width:142px; height:142px; left:50%; top:50%;
      transform:translate(-50%,-50%);
      background:radial-gradient(circle at 56% 41%,#181d39 0%,#b4cfff65 69%,#131f33 100%);
      border-radius:50%;
      box-shadow:0 0 170px #b8a8fa32,0 0 42px #a9fff866;
      z-index:2; 
      transition:all 2.5s cubic-bezier(0.25,0.8,0.25,1);
      animation:orbPulse 5.7s cubic-bezier(.65,0,.35,1) infinite alternate;
      mix-blend-mode:screen;
    }
    .music-orb.void {
      background:radial-gradient(circle at 52% 46%,#ffe8fd 4%,#bfb5fd 33%,#dddaff 90%);
      box-shadow:0 0 300px #e9bcff99,0 0 180px #fff7,0 0 340px #ebdbfe35;
      animation:voidPulse 6.2s cubic-bezier(.4,0,.6,1) infinite alternate;
      transform:translate(-50%,-50%) scale(1.13);
      filter:blur(.5px);
    }
    .orb-glow {
      position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
      width:400px; height:400px; border-radius:50%; z-index:1;
      background:radial-gradient(circle at 52% 48%,#a8bff533 1%,#d2bfff60 60%,#0b0f1800 99%);
      pointer-events:none; mix-blend-mode:lighten; opacity:.79;
      filter:blur(18px); 
      transition:all 2.5s cubic-bezier(0.4,0,0.2,1);
      animation:orbPulse 4.8s cubic-bezier(.65,0,.35,1) infinite alternate;
    }
    .orb-glow.void {
      background:radial-gradient(circle at 52% 48%,#c89aff66 3%,#c4e7ecaa 48%,#1a0f1600 100%);
      width:550px; height:550px; filter:blur(18px);
      animation:voidGlow 7.1s cubic-bezier(.3,0,.7,1) infinite alternate;
    }
    @keyframes orbPulse {from{opacity:.84;}to{opacity:.97;}}
    @keyframes voidPulse {from{opacity:.85;transform:translate(-50%,-50%) scale(1.13);}to{opacity:.99;transform:translate(-50%,-50%) scale(1.18);}}
    @keyframes voidGlow {from{opacity:.6;}to{opacity:.97;}}
    .world-label {
      position:absolute; left:50%; top:94%; transform:translate(-50%,-50%);
      background:rgba(17,24,31,0.89); color:#e5f8ff; padding:13px 32px;
      border-radius:36px; font-size:1.17rem; letter-spacing:.7px;
      font-weight:700; opacity:0; pointer-events:none;
      box-shadow:0 8px 30px #0b0f1b42;
      transition:all 0.8s cubic-bezier(0.4,0,0.2,1);
      z-index:10; text-align:center;
    }
    .world-label.show { opacity:1; transform:translate(-50%,-50%) scale(1.01);}
    .world-label.void {
      background:rgba(42,24,41,0.9); color:#f9e5ff;
      box-shadow:0 8px 40px #3d1b3b99;
    }
    .label-floatin { animation: labelFloatIn 0.9s cubic-bezier(.8,0,.4,1);}
    @keyframes labelFloatIn { from { opacity:0; transform:translate(-50%,20px); } to{ opacity:1; transform:translate(-50%,-50%);} }
    @media (max-width:500px) {
      .intro-title{font-size:1.4rem;}
      .world-label{font-size:.93rem;}
      .orb-viz{top:2vh;}
    }
  </style>
</head>
<body>
  <div class="intro" id="intro">
    <div class="intro-title">GUMP: Infinite Overture</div>
    <div class="intro-author">By James McCandless</div>
    <button class="intro-btn" id="begin">Enter Universe</button>
  </div>
  <div class="app" id="app">
    <div class="orb-viz" id="orbViz">
      <div class="orb-glow" id="orbGlow"></div>
      <div class="music-orb" id="orb"></div>
      <div class="world-label" id="worldLabel"></div>
    </div>
  </div>
  <script>
  // --- UTILS ---
  function lerp(a, b, t) { return a + (b - a) * t; }
  function clamp(x, a, b) { return Math.max(a, Math.min(b, x)); }
  function rand(a, b) { return a + Math.random() * (b - a); }
  function mod(n, m) { return ((n % m) + m) % m; }
  function midi2freq(m) { return 440 * Math.pow(2, (m - 69) / 12); }
  function now() { return performance.now(); }
  function fadeOut(el, ms = 1000) { el.style.transition = `opacity ${ms}ms`; el.style.opacity = 0; }
  function fadeIn(el, ms = 1000) { el.style.transition = `opacity ${ms}ms`; el.style.opacity = 1; }

  // --- GLOBAL STATE ---
  let ctx, audio, allowMotion = false, allowGeo = false, motion = { moving: false, level: 0, steps: 0 }, geo = { lat: 0, lon: 0, city: "Nowhere" }, weather = { main: "Clear", temp: 20 }, timeData = { hour: 12, day: "Monday", season: "Spring" };
  let orbEl, orbVizEl, orbGlowEl, labelEl, introEl;
  let gumpDNA = {}, mainLayers = [], voidLayers = [], crossfade = 0, lastMove = 0, voidMode = false;
  let mainGain, voidGain, masterGain;
  let cornerHistory = [];

  window.onload = () => {
    orbEl = document.getElementById('orb');
    orbVizEl = document.getElementById('orbViz');
    orbGlowEl = document.getElementById('orbGlow');
    labelEl = document.getElementById('worldLabel');
    introEl = document.getElementById('intro');
    document.getElementById('begin').onclick = startGUMP;
  };

  function showLabel(msg, time = 1700) {
    labelEl.textContent = msg;
    labelEl.classList.add('show', 'label-floatin');
    setTimeout(() => labelEl.classList.remove('label-floatin'), 800);
    if (time) setTimeout(() => labelEl.classList.remove('show'), time);
  }

  // --- SETUP & PERMISSIONS ---
  async function startGUMP() {
    fadeOut(introEl, 900);
    setTimeout(() => {
      introEl.style.display = 'none';
      document.getElementById('app').style.opacity = 1;
      beginPermissions();
    }, 900);
  }

  async function beginPermissions() {
    ctx = audio = new (window.AudioContext || window.webkitAudioContext)();
    await ctx.resume();
    if (window.DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === "function") {
      try { let r = await DeviceMotionEvent.requestPermission(); if (r === "granted") allowMotion = true; } catch { }
    } else allowMotion = true;
    getLocationAndWeather();
    runStartupSequence();
  }

  // --- LOCATION & WEATHER ---
  function getLocationAndWeather() {
    if (!navigator.geolocation) return useDefaultLoc();
    navigator.geolocation.getCurrentPosition(async pos => {
      allowGeo = true;
      geo.lat = pos.coords.latitude; geo.lon = pos.coords.longitude;
      fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${geo.lat}&lon=${geo.lon}&zoom=10`)
        .then(r => r.json()).then(data => {
          geo.city = data.address.city || data.address.town || data.address.village || "Nowhere";
        }).catch(() => { });
      fetch(`https://api.open-meteo.com/v1/forecast?latitude=${geo.lat}&longitude=${geo.lon}&current_weather=true`)
        .then(r => r.json()).then(data => {
          if (data.current_weather) {
            weather.temp = data.current_weather.temperature;
            weather.main = decodeWeather(data.current_weather.weathercode);
          }
        }).catch(() => { });
    }, useDefaultLoc, { enableHighAccuracy: true, timeout: 5000 });
  }
  function useDefaultLoc() { geo.city = "Nowhere"; weather.temp = 20; weather.main = "Clear"; }
  function decodeWeather(code) {
    if (code < 3) return "Clear";
    if (code < 5) return "Cloudy";
    if (code < 7) return "Fog";
    if (code < 20) return "Drizzle";
    if (code < 30) return "Rain";
    if (code < 40) return "Snow";
    return "Clear";
  }

  // --- MAKE DNA (THE UNIVERSE'S "SEED") ---
  function makeGumpDNA() {
    let dt = new Date();
    let hour = dt.getHours(), day = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dt.getDay()];
    let season = (dt.getMonth() < 2 || dt.getMonth() === 11) ? "Winter" : (dt.getMonth() < 5) ? "Spring" : (dt.getMonth() < 8) ? "Summer" : "Fall";
    let timeMood = (hour < 6) ? "Night" : (hour < 12) ? "Morning" : (hour < 18) ? "Afternoon" : "Evening";
    // Core root: time+season+geo+weather+random cosmic offset
    let roots = [220, 233, 247, 262, 277, 294, 311, 330, 349, 370, 392, 415, 440];
    let seed = hour + dt.getDate() + (weather.main === "Snow" ? 3 : 0) + (season === "Fall" ? 2 : 0);
    let root = roots[mod(seed, roots.length)];
    let scale = (weather.main === "Clear" || weather.main === "Snow") ? [0, 2, 3, 5, 7, 9, 10, 12] : [0, 3, 5, 7, 10, 12];
    return { root, scale, weather: weather.main, temp: weather.temp, hour, day, timeMood, city: geo.city, season };
  }

  // --- MUSIC BOOTUP: "GATEWAY OPENING" ---
  function runStartupSequence() {
    orbEl.style.opacity = 0.7; orbEl.style.transform = "translate(-50%,-50%) scale(0.9)";
    gumpDNA = makeGumpDNA();
    let steps = [
      { label: "Cranking up the universe…", fn: startupCrank },
      { label: `Weather: ${gumpDNA.weather}`, fn: () => layerPad(gumpDNA, true) },
      { label: `Time: ${gumpDNA.timeMood}`, fn: () => layerBells(gumpDNA, true) },
      { label: `Day: ${gumpDNA.day}`, fn: () => layerBass(gumpDNA, true) },
      { label: `City: ${gumpDNA.city}`, fn: () => layerMotif(gumpDNA, true) }
    ];
    let i = 0;
    function nextLayer() {
      if (i < steps.length) {
        showLabel(steps[i].label, 1250 + 120 * i);
        steps[i].fn();
        orbEl.style.transform = `translate(-50%,-50%) scale(${1 + i * 0.05})`;
        setTimeout(nextLayer, 1100 + 130 * i++);
      } else {
        fadeIn(orbEl, 700);
        orbEl.style.transform = "translate(-50%,-50%) scale(1.06)";
        startMainEngine();
      }
    }
    setTimeout(nextLayer, 800);
  }

  function startupCrank() {
    // Shepard glissando (infinite rise), shimmers, crackle, open the "gate"
    for (let i = 0; i < 8; i++) {
      setTimeout(() => {
        let freq = gumpDNA.root * Math.pow(2, i / 5 + rand(-0.04, 0.06));
        let osc = ctx.createOscillator(), g = ctx.createGain();
        osc.type = "sawtooth";
        osc.frequency.value = freq;
        g.gain.value = 0.09 / (1 + i / 4);
        osc.connect(g).connect(ctx.destination);
        osc.start(); osc.stop(ctx.currentTime + 1.5 + i * 0.17);
        g.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + 1.5 + i * 0.17);
        // Add some "cosmic crackle"
        let buf = ctx.createBuffer(1, 1800, ctx.sampleRate);
        let dat = buf.getChannelData(0);
        for (let j = 0; j < 1800; j++) dat[j] = Math.random() * 2 - 1;
        let n = ctx.createBufferSource();
        n.buffer = buf;
        let nG = ctx.createGain();
        nG.gain.value = 0.05 / (1 + i / 3);
        n.connect(nG).connect(ctx.destination);
        n.start(); n.stop(ctx.currentTime + 0.08 + i * 0.05);
      }, 230 * i);
    }
    // Bell "awakening"
    setTimeout(() => {
      for (let k = 0; k < 4; k++) {
        let bell = ctx.createOscillator(), bellG = ctx.createGain();
        bell.type = "sine";
        bell.frequency.value = gumpDNA.root * (1.77 + k * 0.41);
        bellG.gain.value = 0.14 / (k + 1);
        bell.connect(bellG).connect(ctx.destination);
        bell.start(); bell.stop(ctx.currentTime + 1.2 + k * 0.17);
        bellG.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + 1.2 + k * 0.17);
      }
    }, 700);
  }

  // --- "INFINITE MAIN ENGINE": LIVING MUSIC ---
  function startMainEngine() {
    // Setup main/void/master gain for blending
    mainGain = ctx.createGain();
    voidGain = ctx.createGain();
    masterGain = ctx.createGain();
    mainGain.gain.value = 1;
    voidGain.gain.value = 0;
    masterGain.gain.value = 1;
    mainGain.connect(masterGain);
    voidGain.connect(masterGain);
    masterGain.connect(ctx.destination);

    setupMotion();
    runUniverseLoop();
  }

  // --- MOTION, GEO, CORNER EVENTS ---
  function setupMotion() {
    window.addEventListener('devicemotion', e => {
      if (!allowMotion) return;
      let acc = e.accelerationIncludingGravity;
      let lv = acc ? Math.sqrt(acc.x * acc.x + acc.y * acc.y + acc.z * acc.z) : 0;
      let t = now();
      motion.moving = lv > 13;
      if (motion.moving) lastMove = t;
      motion.level = lerp(motion.level, clamp(lv - 9, 0, 30), 0.08);
      if (t - lastMove > 1800) motion.moving = false;
    });
    // Geo corner events
    setInterval(() => {
      if (!allowGeo) return;
      let gridX = Math.round(geo.lat * 400) / 400, gridY = Math.round(geo.lon * 400) / 400;
      let corner = `${gridX},${gridY}`;
      if (!cornerHistory.includes(corner)) {
        cornerHistory.push(corner);
        if (cornerHistory.length > 5) cornerHistory.shift();
        // Each new "corner" = cosmic event
        setTimeout(() => universeDropEvent(gumpDNA, geo), 240 + rand(50, 700));
      }
    }, 9000);
  }

  // --- UNIVERSE "SONG" LOOP ---
  function runUniverseLoop() {
    setInterval(() => {
      // Crossfade based on motion
      let idle = (!motion.moving && now() - lastMove > 1600);
      crossfade = lerp(crossfade, idle ? 1 : 0, 0.04);
      mainGain.gain.value = (1 - crossfade) * 0.85;
      voidGain.gain.value = crossfade * 0.65;
      orbVizEl.classList.toggle('void', crossfade > 0.49);
      orbEl.classList.toggle('void', crossfade > 0.49);
      orbGlowEl.classList.toggle('void', crossfade > 0.49);
      labelEl.classList.toggle('void', crossfade > 0.49);

      // --- MAIN WORLD ---
      if (!idle) {
        // Song builds up from nothing, stacks complexity with movement
        if (Math.random() > 0.77) layerDrums(gumpDNA);
        if (Math.random() > 0.87) layerPad(gumpDNA);
        if (Math.random() > 0.91) layerBells(gumpDNA);
        if (Math.random() > 0.89) layerMotif(gumpDNA);
        if (Math.random() > 0.88) layerBass(gumpDNA);
      }
      // --- VOID / HEAVEN ---
      else {
        if (voidLayers.length > 22) voidLayers.splice(0, 7);
        if (Math.random() > 0.79) voidPad(gumpDNA);
        if (Math.random() > 0.91) voidBell(gumpDNA);
        if (Math.random() > 0.83) shepardGliss(gumpDNA, true);
      }
      // Clean up old sounds
      mainLayers = mainLayers.filter(l => {
        try { if (l.o.playbackState === 'finished' || l.o.playbackState === 3) return false; return true; } catch { return false; }
      });
      voidLayers = voidLayers.filter(l => {
        try { if (l.o.playbackState === 'finished' || l.o.playbackState === 3) return false; return true; } catch { return false; }
      });
    }, 390);
  }

  // --- MUSICAL LAYERS ---
  function layerDrums(dna) {
    // 4/4 base, triplets, polyrhythms
    let t = ctx.currentTime;
    // KICK
    let o = ctx.createOscillator(), g = ctx.createGain();
    o.type = "sine"; o.frequency.setValueAtTime(58, t); o.frequency.exponentialRampToValueAtTime(33, t + 0.12);
    g.gain.value = 0.29;
    o.connect(g).connect(mainGain); o.start(); o.stop(t + 0.18);
    g.gain.linearRampToValueAtTime(0.0001, t + 0.18);
    mainLayers.push({ o, g });
    // SNARE
    let buf = ctx.createBuffer(1, ctx.sampleRate * .14, ctx.sampleRate), out = buf.getChannelData(0);
    for (let i = 0; i < buf.length; i++) out[i] = Math.random() * 2 - 1;
    let n = ctx.createBufferSource(); n.buffer = buf;
    let nG = ctx.createGain(); nG.gain.value = .20;
    n.connect(nG).connect(mainGain); n.start(); n.stop(t + .09);
    nG.gain.exponentialRampToValueAtTime(.0001, t + .09);
    // HIHAT (always slightly off, “alive”)
    if (Math.random() > 0.54) {
      let h = ctx.createBuffer(1, ctx.sampleRate * .07, ctx.sampleRate), dat = h.getChannelData(0);
      for (let i = 0; i < h.length; i++) dat[i] = Math.random() * 2 - 1;
      let nh = ctx.createBufferSource(); nh.buffer = h;
      let hp = ctx.createBiquadFilter(); hp.type = 'highpass'; hp.frequency.value = 3880 + rand(-300, 250);
      let hg = ctx.createGain(); hg.gain.value = 0.10 + rand(0, 0.05);
      nh.connect(hp).connect(hg).connect(mainGain);
      nh.start(); nh.stop(t + .045 + rand(0, .015));
      hg.gain.linearRampToValueAtTime(.0001, t + .04 + rand(0, .02));
    }
  }

  function layerPad(dna, startup) {
    // Evolving chords, detuned, pan
    let t = ctx.currentTime, c = dna.root * Math.pow(2, dna.scale[mod(rand(0, 6) | 0, dna.scale.length)] / 12);
    let o = ctx.createOscillator(), g = ctx.createGain();
    o.type = (dna.weather === "Clear" ? "triangle" : "sine");
    o.frequency.value = c * (startup ? 1.14 : 1 + rand(-0.013, 0.013));
    g.gain.value = startup ? 0.19 : 0.13 + Math.random() * 0.07;
    o.connect(g).connect(mainGain); o.start(); o.stop(t + (startup ? 3.4 : 2.3 + rand(0, 1.1)));
    g.gain.linearRampToValueAtTime(0.0001, t + (startup ? 3.2 : 2.5 + rand(0, 1)));
    mainLayers.push({ o, g });
  }

  function layerBells(dna, startup) {
    // Binaural beat, ping pong, stereo
    let f1 = dna.root * 2.69 + rand(-5, 8), f2 = dna.root * 2.93 + rand(-7, 6);
    let o1 = ctx.createOscillator(), o2 = ctx.createOscillator();
    let g1 = ctx.createGain(), g2 = ctx.createGain();
    o1.type = o2.type = "sine";
    o1.frequency.value = f1; o2.frequency.value = f2;
    g1.gain.value = g2.gain.value = startup ? 0.09 : 0.13 + Math.random() * 0.08;
    o1.connect(g1).connect(mainGain); o2.connect(g2).connect(mainGain);
    o1.start(); o2.start();
    o1.stop(ctx.currentTime + 0.8 + rand(0, .9)); o2.stop(ctx.currentTime + 0.9 + rand(0, .7));
    g1.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + .81 + rand(0, .8));
    g2.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + .89 + rand(0, .7));
    mainLayers.push({ o: o1, g: g1 }); mainLayers.push({ o: o2, g: g2 });
  }

  function layerMotif(dna, startup) {
    // Polyrhythmic motif, triplets, cosmic arpeggio
    let base = dna.root, sc = dna.scale, motif = [0, 2, 4, 5, 3, 1].map(i => base * Math.pow(2, sc[i % sc.length] / 12));
    motif.forEach((f, idx) => {
      setTimeout(() => {
        let o = ctx.createOscillator(), g = ctx.createGain();
        o.type = idx % 2 == 0 ? "triangle" : "sine"; o.frequency.value = f;
        g.gain.value = 0.07 + 0.01 * idx;
        o.connect(g).connect(mainGain); o.start(); o.stop(ctx.currentTime + 0.22 + 0.03 * idx);
        g.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + 0.21 + 0.04 * idx);
        mainLayers.push({ o, g });
      }, 170 * idx + 120 * Math.random());
    });
  }

  function layerBass(dna, startup) {
    // Sub, slow pulse, pitch glides
    let f = dna.root * 0.51, o = ctx.createOscillator(), g = ctx.createGain();
    o.type = "triangle"; o.frequency.value = f;
    g.gain.value = startup ? 0.19 : 0.16 + Math.random() * 0.06;
    o.connect(g).connect(mainGain); o.start(); o.stop(ctx.currentTime + (startup ? 2.8 : 1.7 + rand(0, 0.9)));
    g.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + (startup ? 2.7 : 1.69 + rand(0, .8)));
    mainLayers.push({ o, g });
  }

  // --- VOID LAYERS ---
  function voidPad(dna) {
    // Deep, dark, reverberant, slowly morphing
    let t = ctx.currentTime, freq = dna.root * (Math.random() > .77 ? 1.41 : 0.71) * (1 + rand(-.07, .09));
    let o = ctx.createOscillator(), g = ctx.createGain();
    o.type = Math.random() > 0.5 ? "triangle" : "sine"; o.frequency.value = freq;
    g.gain.setValueAtTime(0.16 + rand(0, .09), t);
    g.gain.linearRampToValueAtTime(0.0001, t + rand(2.7, 5.6));
    o.connect(g).connect(voidGain); o.start(); o.stop(t + rand(2.9, 5.9));
    voidLayers.push({ o, g });
  }
  function voidBell(dna) {
    // Glassy bells, infinite delay, LFO
    let t = ctx.currentTime, freq = dna.root * 2.53 + rand(-10, 9);
    let o = ctx.createOscillator(), g = ctx.createGain();
    o.type = "sine"; o.frequency.value = freq;
    g.gain.value = 0.13 + rand(0, .07);
    o.connect(g).connect(voidGain); o.start(); o.stop(t + 1.1 + rand(0, 2.2));
    g.gain.linearRampToValueAtTime(0.0001, t + 1.1 + rand(0, 2.1));
    voidLayers.push({ o, g });
  }
  function shepardGliss(dna, up) {
    // Shepard tone, slow rising/falling
    let base = dna.root * (up ? 0.77 : 2.44);
    for (let i = 0; i < 4; i++) {
      let o = ctx.createOscillator(), g = ctx.createGain();
      o.type = "sine"; o.frequency.setValueAtTime(base * Math.pow(2, i / 2), ctx.currentTime);
      g.gain.value = 0.09 / (i + 1);
      o.connect(g).connect(voidGain); o.start(); o.stop(ctx.currentTime + 2.7 + i * 0.19);
      g.gain.linearRampToValueAtTime(0.0001, ctx.currentTime + 2.5 + i * 0.19);
      voidLayers.push({ o, g });
    }
  }

  // --- COSMIC EVENTS ---
  function universeDropEvent(dna, geo) {
    // Triggers a special music change at corners/intersections/city change
    let t = ctx.currentTime;
    for (let i = 0; i < 3 + (Math.random() > 0.6 ? 2 : 0); i++) {
      setTimeout(() => {
        let o = ctx.createOscillator(), g = ctx.createGain();
        o.type = i % 2 ? "triangle" : "sine";
        o.frequency.value = dna.root * Math.pow(2, dna.scale[(i * 2 + 2) % dna.scale.length] / 12) * (1 + rand(-.01, .01));
        g.gain.setValueAtTime(.23 / (i + 1), t);
        g.gain.linearRampToValueAtTime(0.0001, t + 0.67 + rand(0, .17));
        o.connect(g).connect(mainGain); o.start(); o.stop(t + .69 + rand(0, .22));
        mainLayers.push({ o, g });
      }, 160 * i + 100 * Math.random());
    }
    showLabel(`∞ Music Portal · ${geo.city}`, 3200);
  }

  </script>
</body>
</html>
