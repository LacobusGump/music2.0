<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
        }

        .orb {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.5px);
        }

        .orb.pulse {
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
            50% { transform: translate(-50%, -50%) scale(3); box-shadow: 0 0 30px rgba(255,255,255,0.6); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: rec 1s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>

    <script>
        'use strict';

        // Beat Matcher - finds transients and stretches samples to fit
        class BeatMatcher {
            constructor() {
                this.bpm = 75; // Matches Meet the Grahams tempo
            }

            findPeaks(buffer, sr) {
                const data = buffer.getChannelData(0);
                const peaks = [];
                const windowSize = 1024;
                const hop = 512;
                
                // Energy-based peak detection
                for (let i = 0; i < data.length - windowSize; i += hop) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    energy = Math.sqrt(energy / windowSize);
                    
                    if (i > 0 && energy > peaks[peaks.length - 1]?.energy * 1.3 && energy > 0.05) {
                        peaks.push({ time: i / sr, energy, index: i });
                    }
                }
                
                return peaks;
            }

            matchToGrid(peaks, barLength = 4) {
                if (peaks.length < 2) return 1;
                
                // Find average interval between peaks
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i].time - peaks[i - 1].time);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                const beatDuration = 60 / this.bpm;
                
                // Find closest musical division (1/4, 1/8, 1/16, etc.)
                const divisions = [4, 2, 1, 0.5, 0.25];
                let bestDiv = 1;
                let minDiff = Infinity;
                
                for (const div of divisions) {
                    const targetInterval = beatDuration * div;
                    const diff = Math.abs(avgInterval - targetInterval);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestDiv = div;
                    }
                }
                
                // Calculate stretch factor
                const targetDuration = beatDuration * barLength;
                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                
                return targetDuration / actualDuration;
            }

            chopSample(buffer, peaks, chopsPerBar = 4) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration * 4 / chopsPerBar;
                
                // Create chops at peak positions
                for (let i = 0; i < Math.min(peaks.length - 1, chopsPerBar); i++) {
                    const start = peaks[i].time;
                    const end = Math.min(start + chopLength, buffer.duration);
                    chops.push({ start, end, peak: peaks[i].energy });
                }
                
                return chops;
            }
        }

        // Lo-fi processor with enhanced haunting effects for piano
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
            }

            process(source, isPiano = false) {
                // Bitcrusher for grit, lighter on piano
                const bitcrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                const bits = isPiano ? 12 : 8; // Higher bits for cleaner piano
                const normFreq = isPiano ? 0.5 : 0.3;
                
                let phaser = 0;
                bitcrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    for (let i = 0; i < input.length; i++) {
                        phaser += normFreq;
                        if (phaser >= 1) {
                            phaser -= 1;
                            const step = Math.pow(0.5, bits);
                            output[i] = step * Math.floor(input[i] / step + 0.5);
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };
                
                // Dark filter, lower for piano
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = isPiano ? 1200 : 2500;
                filter.Q.value = isPiano ? 0.5 : 1.2; // Smoother for piano
                
                // Saturation for warmth, subtler on piano
                const waveshaper = this.ctx.createWaveShaper();
                const curve = new Float32Array(256);
                for (let i = 0; i < 128; i++) {
                    const x = i / 128;
                    curve[128 + i] = Math.tanh(x * (isPiano ? 1.5 : 2.5));
                    curve[128 - i - 1] = -Math.tanh(x * (isPiano ? 1.5 : 2.5));
                }
                waveshaper.curve = curve;
                
                // Enhanced reverb for haunt, more on piano
                const delay1 = this.ctx.createDelay(0.3);
                delay1.delayTime.value = 0.3;
                const delay2 = this.ctx.createDelay(0.5);
                delay2.delayTime.value = 0.5;
                const feedback = this.ctx.createGain();
                feedback.gain.value = isPiano ? 0.6 : 0.5; // More feedback for piano haunt
                const delayFilter = this.ctx.createBiquadFilter();
                delayFilter.type = 'lowpass';
                delayFilter.frequency.value = isPiano ? 800 : 1000; // Darker reverb on piano
                
                // Chain delays for better reverb
                source.connect(bitcrusher);
                bitcrusher.connect(filter);
                filter.connect(waveshaper);
                waveshaper.connect(delay1);
                delay1.connect(delay2);
                delay2.connect(delayFilter);
                delayFilter.connect(feedback);
                feedback.connect(delay1); // Feedback loop
                
                // Merger dry + wet, lower wet for control
                const merger = this.ctx.createGain();
                waveshaper.connect(merger);
                delayFilter.connect(merger);
                merger.gain.value = isPiano ? 0.4 : 0.6; // Lower overall for piano
                
                return merger;
            }
        }

        // Main Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.05 }; // Minimal swing for ominous feel
                this.orb = document.getElementById('orb');
                this.playingSamples = [];
                this.stage = 0; // 0: beat only, 1: with samples, 2: with piano and advanced bass
                
                // Pitch shifts biased lower
                this.pitchShifts = [0.5, 0.6, 0.7, 0.8, 1]; 
                
                // Basic bass pattern
                this.basicBassPattern = [
                    {step: 0, rate: 1},      
                    {step: 16, rate: 1}   
                ];
                
                // Advanced Kanye-style bass pattern: more melodic, with minor feel
                this.advancedBassPattern = [
                    {step: 0, rate: 1},         // Root
                    {step: 4, rate: 1.189},     // Minor 3rd
                    {step: 8, rate: 1.5},       // 5th
                    {step: 12, rate: 1.189},    // Minor 3rd
                    {step: 16, rate: 1},        // Root
                    {step: 20, rate: 1.189},    // Minor 3rd
                    {step: 24, rate: 1.5},      // 5th
                    {step: 28, rate: 1.682}     // Minor 7th
                ];
                
                this.bassPattern = this.basicBassPattern; // Start with basic
                
                // Pitch multiplier for aggressive tuning (A450 / A440 â‰ˆ 1.0227)
                this.pitchMult = 1.0227;
                
                document.addEventListener('click', () => this.start());
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 44100 });
                    this.lofi = new LoFi(this.ctx);
                    
                    // Master chain - professional audiophile adjustments
                    this.nodes.out = this.ctx.createGain();
                    this.nodes.out.gain.value = 0.8; // Slightly higher master
                    
                    // Vinyl with deeper rumble
                    this.nodes.vinyl = this.ctx.createBiquadFilter();
                    this.nodes.vinyl.type = 'highpass';
                    this.nodes.vinyl.frequency.value = 20;
                    
                    // Boosted warmth with EQ
                    this.nodes.warmth = this.ctx.createBiquadFilter();
                    this.nodes.warmth.type = 'lowshelf';
                    this.nodes.warmth.frequency.value = 150;
                    this.nodes.warmth.gain.value = 3;
                    
                    // Professional compression
                    this.nodes.comp = this.ctx.createDynamicsCompressor();
                    this.nodes.comp.threshold.value = -24;
                    this.nodes.comp.knee.value = 12;
                    this.nodes.comp.ratio.value = 4;
                    this.nodes.comp.attack.value = 0.003;
                    this.nodes.comp.release.value = 0.25;
                    
                    // High-end filter with slight boost
                    this.nodes.dust = this.ctx.createBiquadFilter();
                    this.nodes.dust.type = 'lowpass';
                    this.nodes.dust.frequency.value = 8000; // Higher for clarity
                    this.nodes.dust.Q.value = 0.7;
                    
                    // Add master EQ for audiophile balance
                    this.nodes.masterEQ = this.ctx.createBiquadFilter();
                    this.nodes.masterEQ.type = 'highshelf';
                    this.nodes.masterEQ.frequency.value = 10000;
                    this.nodes.masterEQ.gain.value = 2; // Airy highs
                    
                    // Connect master chain
                    this.nodes.out.connect(this.nodes.vinyl);
                    this.nodes.vinyl.connect(this.nodes.warmth);
                    this.nodes.warmth.connect(this.nodes.comp);
                    this.nodes.comp.connect(this.nodes.masterEQ);
                    this.nodes.masterEQ.connect(this.nodes.dust);
                    this.nodes.dust.connect(this.ctx.destination);
                    
                    // Layers with refined volumes
                    const layers = {
                        kick: 1.0,
                        snare: 0.7,
                        hats: 0.2,
                        sample: 0.8,
                        bass: 0.95,
                        vinyl: 0.15,
                        piano: 0.25 // Significantly lowered for back of mix
                    };
                    
                    Object.entries(layers).forEach(([name, vol]) => {
                        this.nodes[name] = this.ctx.createGain();
                        this.nodes[name].gain.value = vol;
                        this.nodes[name].connect(this.nodes.out);
                        this.samples.set(name, []);
                    });
                    
                    // Drums
                    await this.createDrums();
                    
                    // Haunting piano ostinato
                    await this.createPiano();
                    
                    // Vinyl
                    this.createVinyl();
                    
                    // Mic
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.rec = this.ctx.createScriptProcessor(4096, 1, 1);
                    
                    this.nodes.rec.onaudioprocess = e => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            if (this.buffer.length > this.ctx.sampleRate * 8) this.stopRec();
                        }
                    };
                    
                    // Start
                    this.loop();
                    this.seq.last = this.ctx.currentTime;
                    requestAnimationFrame(() => this.tick());
                    
                    // Keys
                    document.onkeydown = e => {
                        if (e.key === ' ') this.toggle();
                    };
                    
                } catch (e) {
                    console.error(e);
                }
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.rec);
                    this.nodes.rec.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.rec);
                this.nodes.rec.disconnect();
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.5) {
                    const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    buf.getChannelData(0).set(this.buffer);
                    
                    const peaks = this.beatMatcher.findPeaks(buf, this.ctx.sampleRate);
                    const stretch = this.beatMatcher.matchToGrid(peaks);
                    
                    const pitch = this.pitchShifts[Math.floor(Math.random() * this.pitchShifts.length)];
                    
                    const chops = this.beatMatcher.chopSample(buf, peaks);
                    
                    const sample = {
                        buffer: buf,
                        rate: stretch * pitch,
                        chops,
                        pitch
                    };
                    
                    const samples = this.samples.get('sample');
                    samples.push(sample);
                    
                    this.playSample(sample);
                    
                    // Evolve stages
                    if (samples.length >= 1) {
                        this.stage = 1;
                    }
                    if (samples.length >= 2) {
                        this.stage = 2;
                        this.bassPattern = this.advancedBassPattern;
                        if (!this.pianoSource) {
                            this.playPiano();
                        }
                    }
                    
                    console.log(`Sample: ${pitch}x pitch, ${stretch.toFixed(2)}x stretch`);
                }
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // Deeper kick with more sub and punch
                const kick = this.ctx.createBuffer(1, sr * 0.5, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-7 * t);
                    const pitch = 45 * Math.exp(-35 * t);
                    let s = Math.sin(2 * Math.PI * pitch * t) * env;
                    s += 0.2 * Math.sin(2 * Math.PI * (pitch * 2) * t) * env; // Add harmonic
                    s = Math.round(s * 8) / 8;
                    kd[i] = s * 0.95;
                }
                
                // Softer snare with more noise and snap
                const snare = this.ctx.createBuffer(1, sr * 0.25, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-20 * t);
                    const tone = Math.sin(2 * Math.PI * 160 * t) * 0.2;
                    const noise = (Math.random() * 2 - 1) * 0.5;
                    let s = (tone + noise) * env;
                    s = Math.round(s * 6) / 6;
                    sd[i] = s * 0.7;
                }
                
                // Very subtle hat with air
                const hat = this.ctx.createBuffer(1, sr * 0.1, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr;
                    const env = Math.exp(-70 * t);
                    let s = (Math.random() * 2 - 1) * env;
                    if (i > 0) s = s * 0.4 + hd[i-1] * 0.6;
                    hd[i] = s * 0.3;
                }
                
                // Deep sub bass with glide simulation
                const bass = this.ctx.createBuffer(1, sr * 1.5, sr);
                const bd = bass.getChannelData(0);
                for (let i = 0; i < bd.length; i++) {
                    const t = i / sr;
                    const env = t < 0.04 ? t / 0.04 : Math.exp(-1 * (t - 0.04));
                    bd[i] = Math.sin(2 * Math.PI * 35 * t) * env * 0.85;
                }
                
                this.samples.get('kick').push({ buffer: kick, rate: 1 });
                this.samples.get('snare').push({ buffer: snare, rate: 1 });
                this.samples.get('hats').push({ buffer: hat, rate: 1 });
                this.samples.get('bass').push({ buffer: bass, rate: 1 });
            }

            async createPiano() {
                const sr = this.ctx.sampleRate;
                const beatDuration = 60 / this.beatMatcher.bpm;
                const loopDuration = beatDuration * 8; // Longer loop for less repetition
                
                const piano = this.ctx.createBuffer(1, sr * loopDuration, sr);
                const pd = piano.getChannelData(0);
                
                // Piano synth with harmonics and longer decay
                const generateNote = (startTime, duration, freq, amp = 1) => {
                    const start = Math.floor(startTime * sr);
                    const len = Math.floor(duration * sr);
                    for (let i = 0; i < len; i++) {
                        const t = i / sr;
                        const env = Math.exp(-t / 3); // Longer decay for haunt
                        let s = Math.sin(2 * Math.PI * freq * t) * env;
                        s += 0.3 * Math.sin(2 * Math.PI * 2 * freq * t) * env;
                        s += 0.2 * Math.sin(2 * Math.PI * 3 * freq * t) * env;
                        s += 0.1 * Math.sin(2 * Math.PI * 4 * freq * t) * env;
                        pd[start + i] += s * amp * 0.2; // Lower amp
                    }
                };
                
                // Bass G sustained
                const bassFreq = 98 * this.pitchMult; // G2
                generateNote(0, loopDuration, bassFreq, 1.0);
                
                // Sparser ostinato: half notes, fewer notes C# E
                const ostinatoNotes = [277.18, 329.63].map(f => f * this.pitchMult); // C#4 E4
                const noteDuration = beatDuration * 2; // Half notes
                
                for (let i = 0; i < 4; i++) {
                    const note = ostinatoNotes[i % 2];
                    generateNote(i * noteDuration, noteDuration, note, 0.6);
                    // Subtle octave
                    generateNote(i * noteDuration, noteDuration, note * 2, 0.3);
                }
                
                this.samples.get('piano').push({ buffer: piano, rate: 1 });
            }

            playPiano() {
                const samples = this.samples.get('piano');
                if (!samples.length) return;
                
                const sample = samples[0];
                const src = this.ctx.createBufferSource();
                src.buffer = sample.buffer;
                src.loop = true;
                
                const processed = this.lofi.process(src, true);
                processed.connect(this.nodes.piano);
                
                src.start();
                this.pianoSource = src;
            }

            createVinyl() {
                const duration = 10;
                const vinyl = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = vinyl.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    if (Math.random() < 0.0003) {
                        data[i] = (Math.random() - 0.5) * 0.4;
                    } else {
                        data[i] = (Math.random() - 0.5) * 0.03;
                    }
                    data[i] += Math.sin(2 * Math.PI * 0.3 * i / this.ctx.sampleRate) * 0.015;
                }
                
                const playVinyl = () => {
                    const source = this.ctx.createBufferSource();
                    source.buffer = vinyl;
                    source.loop = true;
                    source.connect(this.nodes.vinyl);
                    source.start();
                };
                
                playVinyl();
            }

            tick() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.beatMatcher.bpm / 4;
                
                let swing = this.seq.step % 2 === 1 ? beat * (1 + this.seq.swing) : beat * (1 - this.seq.swing);
                
                if (now >= this.seq.last + swing) {
                    this.seq.last = now;
                    
                    if (this.seq.step % 8 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 300);
                    }
                    
                    // Sparser patterns
                    if (this.seq.step === 0 || this.seq.step === 16) {
                        this.play('kick', 0.95);
                    }
                    
                    if (this.seq.step === 8 || this.seq.step === 24) {
                        this.play('snare', 0.6);
                    }
                    
                    // Rare hats for subtlety
                    if (this.seq.step % 16 === 4) {
                        this.play('hats', 0.15 + Math.random() * 0.05);
                    }
                    
                    // Bass
                    const bassPlay = this.bassPattern.find(p => p.step === this.seq.step);
                    if (bassPlay) {
                        this.play('bass', 0.9, bassPlay.rate);
                    }
                    
                    // Stronger sidechain on kicks
                    if (this.seq.step === 0 || this.seq.step === 16) {
                        this.playingSamples.forEach(ps => {
                            ps.gain.gain.cancelScheduledValues(now);
                            ps.gain.gain.setValueAtTime(0.2, now);
                            ps.gain.gain.linearRampToValueAtTime(0.7, now + 0.2);
                        });
                        
                        if (this.stage >= 2) {
                            this.nodes.piano.gain.cancelScheduledValues(now);
                            this.nodes.piano.gain.setValueAtTime(0.15, now);
                            this.nodes.piano.gain.linearRampToValueAtTime(0.25, now + 0.2);
                        }
                    }
                    
                    this.seq.step = (this.seq.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            play(type, vel, rateMult = 1) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                const sample = samples[Math.floor(Math.random() * samples.length)];
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = (sample.rate || 1) * rateMult;
                gain.gain.value = vel;
                
                const processed = this.lofi.process(src);
                processed.connect(gain);
                gain.connect(this.nodes[type]);
                
                src.start();
            }

            playSample(sample) {
                // Only play if stage >=1
                if (this.stage < 1) return;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                src.loopStart = 0;
                src.loopEnd = Math.min(sample.buffer.duration, 60 / this.beatMatcher.bpm * 4);
                
                filter.type = 'lowpass';
                filter.frequency.value = 1600; // Even darker
                filter.Q.value = 1.5;
                
                const sweepTime = 16; // Slower sweep
                filter.frequency.setValueAtTime(1600, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(3500, this.ctx.currentTime + sweepTime / 2);
                filter.frequency.linearRampToValueAtTime(1600, this.ctx.currentTime + sweepTime);
                
                gain.gain.value = 0.7;
                
                const processed = this.lofi.process(src);
                processed.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample);
                
                src.start();
                
                this.playingSamples.push({src, gain});
                
                if (this.playingSamples.length > 3) {
                    const old = this.playingSamples.shift();
                    old.src.stop();
                }
            }

            loop() {
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                
                setInterval(() => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    let harmonics = 0;
                    for (let i = 10; i < 100; i++) {
                        if (data[i] > 100) harmonics++;
                    }
                    
                    if (harmonics > 20) {
                        this.toggle();
                        setTimeout(() => {
                            if (this.recording) this.toggle();
                        }, 2000 + Math.random() * 2000);
                        cooldown = 200;
                    }
                }, 20);
            }
        }

        new Engine();
    </script>
</body>
</html>
