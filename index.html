<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Grand Unified Music Project</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      letter-spacing: 1px;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      animation: pulse 4s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      transform: scale(1.03);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(255,255,255,0.1); }
      50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(255,255,255,0.3); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 30px rgba(255,255,255,0.4);
      backdrop-filter: blur(3px);
    }
    
    .orb.pulse {
      animation: beat 0.12s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.8); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.buildup {
      background: radial-gradient(circle, #ffcc00 0%, rgba(255,204,0,0.3) 50%, transparent 80%);
      box-shadow: 0 0 50px rgba(255,204,0,0.6);
    }
    
    .orb.drop {
      background: radial-gradient(circle, #ff0000 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
      box-shadow: 0 0 70px rgba(255,0,0,0.7);
    }
    
    .orb.breakdown {
      background: radial-gradient(circle, #00ffcc 0%, rgba(0,255,204,0.3) 50%, transparent 80%);
      box-shadow: 0 0 50px rgba(0,255,204,0.6);
    }
    
    .orb.wobble {
      animation: wobble 0.5s ease-in-out infinite;
    }
    
    @keyframes wobble {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 10px;
      color: rgba(255,255,255,0.7);
      letter-spacing: 1px;
      background: rgba(0,0,0,0.2);
      padding: 5px;
      border-radius: 3px;
      backdrop-filter: blur(5px);
    }
    
    .ui-corner.top-left {
      top: 10px;
      left: 10px;
    }
    
    .ui-corner.bottom-left {
      bottom: 10px;
      left: 10px;
    }
    
    .stage-name {
      font-size: 12px;
      color: rgba(255,255,255,0.8);
      margin-bottom: 5px;
    }
    
    .metric {
      margin: 2px 0;
      font-size: 9px;
    }
    
    .bar {
      width: 60px;
      height: 2px;
      background: rgba(255,255,255,0.1);
      margin: 2px 0;
      border-radius: 1px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff0000, #ffcc00);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 1px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-align: center;
      letter-spacing: 1px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 60px;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 40%, rgba(0,0,0,0.5) 100%);
      opacity: 0;
      transition: opacity 2s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 20px;
      right: 20px;
      font-size: 10px;
      color: rgba(255,255,255,0.5);
      text-transform: uppercase;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 80px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 6px;
      background: linear-gradient(0deg, rgba(255,0,0,0.7), rgba(255,255,255,0.1));
      border-radius: 3px 3px 0 0;
      transition: height 0.08s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,0,0,0.08);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.12s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      ENGAGE
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO DROP THE BASS</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">WOBBLE: <span id="technique">IDLE</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">DROP TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="shepardBar"></div>
      </div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class GUMPEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 140;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 16;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.lastMotionTime = Date.now();
        
        // Gesture Recognition
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        // Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.currentTechnique = 'idle';
        this.transposition = 0;
        
        // Dubstep Themes
        this.currentTheme = 'buildup';
        this.themes = {
          buildup: { mood: 'tension', colors: ['#ffcc00', '#0a0a0a'], text: 'Building Up' },
          drop: { mood: 'aggressive', colors: ['#ff0000', '#0a0a0a'], text: 'Bass Drop' },
          breakdown: { mood: 'melodic', colors: ['#00ffcc', '#0a0a0a'], text: 'Breakdown' },
          wobble: { mood: 'wobbly', colors: ['#ff00ff', '#0a0a0a'], text: 'Wobble Madness' },
          glitch: { mood: 'chaotic', colors: ['#00ffff', '#ff00ff'], text: 'Glitch Out' }
        };
        
        // AUDIO SYSTEM
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.basePositions = {};
        this.layerPositions = {};
        this.layerTargets = {};
        this.layerPanScales = {
          kick: 0.1, subBass: 0.1, hats: 0.8, snare: 0.3,
          wobbleBass: 1.2, leadSynth: 1.5, growl: 2.0, fx: 3.0,
          risers: 1.8, impacts: 0.5
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.lowBoost = null;
        this.saturator = null;
        this.wobbleLFOs = {}; // For wobble modulation
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Techniques
        this.wobbleRate = 1; // LFO rate for wobble
        this.distortionAmount = 0;
        this.glitchProbability = 0;
        
        // Voice Pool
        this.voicePool = {
          kick: { max: 3, active: [] },
          subBass: { max: 4, active: [] },
          hats: { max: 6, active: [] },
          snare: { max: 3, active: [] },
          wobbleBass: { max: 8, active: [] },
          leadSynth: { max: 12, active: [] },
          growl: { max: 10, active: [] },
          fx: { max: 6, active: [] },
          risers: { max: 2, active: [] },
          impacts: { max: 2, active: [] }
        };
        
        // Layers
        this.layers = {
          kick: false, subBass: false, hats: false, snare: false,
          wobbleBass: false, leadSynth: false, growl: false, fx: false,
          risers: false, impacts: false
        };
        
        // Musical Elements
        this.key = 'C';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
        this.mode = 'minor';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          pentatonic: [0, 3, 5, 7, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [0,3,7], // Cm
          [5,8,12], // Gm
          [3,7,10], // Fm
          [0,3,7]  // Cm
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        
        this.elements = {};
        this.spectrumBars = [];
        
        // Procedural Noise
        this.noiseSource = null;
        this.noiseFilter = null;
        this.noiseGain = null;

        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'shepardBar', 'spectrumViz', 'impactFlash',
         'cinematicOverlay', 'themeText']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i = 50; i < 50; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 2}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupInteractionListeners() {
        // Simplified, remove konami and some gestures
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          this.gestureRecognition.tap += 1;
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          this.gestureRecognition.tap += 1;
        });
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          if (e.alpha !== null) {
            this.orientation.alpha = e.alpha;
            this.orientation.beta = e.beta;
            this.orientation.gamma = e.gamma;
            this.updateListenerOrientation();
          }
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        this.listener.forwardX.value = forwardX;
        this.listener.forwardY.value = forwardY;
        this.listener.forwardZ.value = forwardZ;
        this.listener.upX.value = upX;
        this.listener.upY.value = upY;
        this.listener.upZ.value = upZ;
      }

      async start() {
        try {
          // Permission requests
          if (typeof DeviceMotionEvent.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              console.log('Motion permission not granted');
            }
          }

          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              console.log('Orientation permission not granted');
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setLayerPositions();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'MOVE TO WOBBLE';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 3000);
          }, 1000);

          this.active = true;
          this.startSequencer();
          this.animate();
          
        } catch (e) {
          console.error('Failed to start engine:', e);
        }
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 128;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -6;
        this.limiter.knee.value = 2;
        this.limiter.ratio.value = 12;
        this.limiter.attack.value = 0.0005;
        this.limiter.release.value = 0.05;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -18;
        this.compressor.knee.value = 8;
        this.compressor.ratio.value = 6;
        this.compressor.attack.value = 0.002;
        this.compressor.release.value = 0.1;
        
        this.lowBoost = this.ctx.createBiquadFilter();
        this.lowBoost.type = 'lowshelf';
        this.lowBoost.frequency.value = 80;
        this.lowBoost.gain.value = 4;
        
        this.saturator = this.ctx.createWaveShaper();
        this.saturator.curve = this.makeDistortionCurve(5);
        this.saturator.oversample = '4x';
        
        this.listener = this.ctx.listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(4);
        
        this.delay = this.ctx.createDelay(0.5);
        this.delay.delayTime.value = 0.25;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.4;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.3;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // Dubstep layers
        const layerNames = ['kick', 'subBass', 'hats', 'snare', 'wobbleBass', 'leadSynth', 'growl', 'fx', 'risers', 'impacts'];
        const layerLevels = [0.9, 0.8, 0.2, 0.5, 0.7, 0.4, 0.6, 0.3, 0.4, 0.6]; 
        
        layerNames.forEach((name, i) => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];

          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';
          this.layerPanners[name].distanceModel = 'inverse';
          this.layerPanners[name].refDistance = 1;
          this.layerPanners[name].maxDistance = 10000;
          this.layerPanners[name].rolloffFactor = 1.2;
          this.layerPanners[name].coneInnerAngle = 360;
          this.layerPanners[name].coneOuterAngle = 0;
          this.layerPanners[name].coneOuterGain = 0;

          this.layerPositions[name] = {x: 0, y: 0, z: 0};
          this.basePositions[name] = {x: 0, y: 0, z: 0};
          this.layerTargets[name] = {x: 0, y: 0, z: 0};

          this.layerGains[name].connect(this.layerPanners[name]);
          this.layerPanners[name].connect(this.compressor);

          if (['wobbleBass', 'growl', 'leadSynth', 'fx'].includes(name)) {
            this.layerGains[name].connect(this.saturator);
          }
          
          if (['leadSynth', 'fx', 'risers'].includes(name)) {
            this.layerGains[name].connect(this.convolver);
          }
          
          if (['snare', 'growl', 'impacts'].includes(name)) {
            this.layerGains[name].connect(this.delay);
          }

          // Wobble LFO for bass layers
          if (['wobbleBass', 'growl'].includes(name)) {
            const lfo = this.ctx.createOscillator();
            lfo.type = 'triangle';
            lfo.frequency.value = this.wobbleRate;
            const lfoGain = this.ctx.createGain();
            lfoGain.gain.value = 1000; // Modulation depth
            lfo.connect(lfoGain);
            this.wobbleLFOs[name] = {lfo, lfoGain};
            lfo.start();
          }
        });
        
        this.compressor.connect(this.lowBoost);
        this.lowBoost.connect(this.saturator);
        this.saturator.connect(this.limiter);
        this.convolver.connect(this.limiter);
        delayMix.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.setupProceduralNoise();
      }

      createReverbBuffer(time) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 2);
            data[i] = (Math.random() * 2 - 1) * decay * 0.4;
          }
        }
        return buffer;
      }

      makeDistortionCurve(amount) {
        const k = amount;
        const n = 22050;
        const curve = new Float32Array(n);
        const deg = Math.PI / 180;
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      setupProceduralNoise() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        this.noiseSource = this.ctx.createBufferSource();
        this.noiseSource.buffer = buffer;
        this.noiseSource.loop = true;

        this.noiseFilter = this.ctx.createBiquadFilter();
        this.noiseFilter.type = 'bandpass';
        this.noiseFilter.frequency.value = 800;
        this.noiseFilter.Q.value = 8;

        this.noiseGain = this.ctx.createGain();
        this.noiseGain.gain.value = 0.05;

        this.noiseSource.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseGain);
        this.noiseGain.connect(this.layerPanners.fx);
        this.noiseSource.start();
      }

      updateProceduralNoise(avgMotion, variance) {
        this.noiseFilter.frequency.value = 400 + avgMotion * 80 + variance * 40;
        this.noiseFilter.Q.value = 6 + variance * 1.5;
        this.noiseGain.gain.value = 0.06 + (this.intensity * 0.08);
      }

      setLayerPositions() {
        const positions = {
          kick: {x: 0, y: 0, z: -1},
          subBass: {x: 0, y: -0.5, z: -2},
          hats: {x: 0, y: 0.5, z: -3},
          snare: {x: 0, y: 0, z: -0.5},
          wobbleBass: {x: -1, y: 0, z: -4},
          leadSynth: {x: 1, y: 0, z: -4},
          growl: {x: 0, y: 1, z: 4},
          fx: {x: 0, y: 1.5, z: 8},
          risers: {x: -3, y: 0, z: -5},
          impacts: {x: 3, y: 0, z: -5}
        };

        Object.keys(positions).forEach(name => {
          const pos = positions[name];
          this.basePositions[name] = {...pos};
          this.layerPositions[name] = {...pos};
          this.layerTargets[name] = {...pos};
          if (this.layerPanners[name]) {
            this.layerPanners[name].positionX.value = pos.x;
            this.layerPanners[name].positionY.value = pos.y;
            this.layerPanners[name].positionZ.value = pos.z;
          }
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5;
          this.updateMotion(newMotion);
 Now I have the search results.

From Skrillex sound design:

- Uses FM8/Massive for synths, Ohmforce Ohmicide for multiband distortion.

- FM synthesis, wavetables.

- Complex bass design, growl basses.

- Sound design tricks: layering, distortion, formant filters.

- Software synths like Serum for modern recreations.

For Web Audio API implementation:

- Wobble bass: LFO modulating lowpass filter cutoff.

- Use oscillators (sawtooth/square), BiquadFilter lowpass, Gain for LFO.

- Distortion with WaveShaper.

- For dubstep: heavy compression, sidechain, but in web audio.

2025 updates: Web Audio API is mature, best practices on MDN.

To implement:

- Change layers to: subBass, wobbleBass, leadSynth, kick, snare, hats, fx (risers, impacts, etc.)

- Stages: Buildup, Drop, Breakdown.

- Motion controls wobble rate, intensity controls distortion/aggression.

- BPM around 140.

- Title: GUMP: Grand Unified Music Project

- UI: Simplify, remove some metrics, make labels GUMP related.

- Change orb classes to dubstep themes, maybe neon colors, glitch effects.

Now, modify the code.

First, HTML:

- Change title to <title>GUMP: Grand Unified Music Project</title>

- Change start button to "AWAKEN GUMP" or something.

- UI corners: Change labels to GUMP related, e.g. "GUMP STAGE", "WOBBLE INTENSITY"

- Remove some bars if simplifying.

CSS: Keep minimal, perhaps change colors to dubstep typical (purples, blues, greens).

JS:

- Change class to GUMPEngine or keep VoidEngine but rename internals.

- BPM default 140.

- Layers: update to dubstep ones.

- play functions: implement wobble, etc.

For wobble bass:

Create oscillator (saw), connect to lowpass filter, LFO (sine osc) connected to filter.frequency.

For growl: FM synthesis, oscillator modulating another.

Distortion: WaveShaper.

Since no external libs, use built-in nodes.

Evolution: Silence -> Buildup (risers, builds) -> Drop (wobble, heavy bass) -> Breakdown.

Motion: higher motion = faster wobble, more aggression.

Change theme texts to dubstep related.

Finally, output the full modified HTML.<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Grand Unified Music Project</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #000;
      color: #0ff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 150px;
      height: 150px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, transparent 70%);
      border: 2px solid rgba(0,255,255,0.4);
      color: #0ff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 1px;
      backdrop-filter: blur(5px);
      transition: all 0.3s ease;
      animation: pulse 4s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(0,255,255,0.7);
      background: radial-gradient(circle, rgba(0,255,255,0.3) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 20px rgba(0,255,255,0.3); }
      50% { transform: scale(1.05); box-shadow: 0 0 40px rgba(0,255,255,0.5); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 1s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background: radial-gradient(circle, #0ff 0%, rgba(0,255,255,0.4) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
      box-shadow: 0 0 30px rgba(0,255,255,0.6);
      backdrop-filter: blur(3px);
    }
    
    .orb.pulse {
      animation: beat 0.1s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.8); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.buildup {
      background: radial-gradient(circle, #ff0 0%, rgba(255,255,0,0.5) 50%, transparent 80%);
      box-shadow: 0 0 50px rgba(255,255,0,0.7);
    }
    
    .orb.drop {
      background: radial-gradient(circle, #f0f 0%, rgba(255,0,255,0.5) 50%, transparent 80%);
      box-shadow: 0 0 70px rgba(255,0,255,0.8);
      animation: wobble 0.5s ease-in-out infinite;
    }
    
    @keyframes wobble {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.2); }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 10px;
      color: rgba(0,255,255,0.7);
      letter-spacing: 1px;
      background: rgba(0,0,0,0.4);
      padding: 8px;
      border-radius: 3px;
      backdrop-filter: blur(5px);
    }
    
    .ui-corner.top-left {
      top: 10px;
      left: 10px;
    }
    
    .ui-corner.bottom-left {
      bottom: 10px;
      left: 10px;
    }
    
    .stage-name {
      font-size: 12px;
      color: #0ff;
      margin-bottom: 5px;
    }
    
    .metric {
      margin: 2px 0;
      font-size: 9px;
    }
    
    .bar {
      width: 60px;
      height: 2px;
      background: rgba(0,255,255,0.2);
      margin: 2px 0;
      border-radius: 1px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #0ff, #f0f);
      width: 0%;
      transition: width 0.2s ease;
      border-radius: 1px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(0,255,255,0.6);
      text-align: center;
      letter-spacing: 1px;
      opacity: 0;
      transition: opacity 1s ease;
      margin-top: 60px;
    }
    
    .instruction.show { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 50px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 5px;
      background: linear-gradient(0deg, #0ff, rgba(0,255,255,0.3));
      border-radius: 2px 2px 0 0;
      transition: height 0.05s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,255,255,0.2);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.1s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN GUMP
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO WOBBLE THE BASS</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">TECHNIQUE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">WOBBLE INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class GUMPEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 140;
        this.step = 0;
        this.phraseCount = 0;
        this.sectionLength = 16;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.lastMotionTime = Date.now();
        
        // Evolution System
        this.stage = 'SILENCE';
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.dropPhase = false;
        this.currentTechnique = 'waiting';
        
        // Themes
        this.currentTheme = 'silence';
        this.themes = {
          silence: { colors: ['#000', '#111'], text: 'Silent Void' },
          buildup: { colors: ['#ff0', '#000'], text: 'Building Tension' },
          drop: { colors: ['#f0f', '#0ff'], text: 'Heavy Drop' },
          breakdown: { colors: ['#0ff', '#000'], text: 'Bass Breakdown' }
        };
        
        // AUDIO SYSTEM
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.layerPanScales = {
          kick: 0.1, subBass: 0.2, wobbleBass: 0.8, snare: 0.3,
          hats: 1.2, leadSynth: 1.5, risers: 2.0, impacts: 0.5,
          glitch: 1.0
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.distortion = null;
        this.compressor = null;
        
        // Wobble System
        this.wobbleRate = 0;
        this.wobbleDepth = 0;
        this.wobbleLFOs = {};
        
        // Voice Pool
        this.voicePool = {
          kick: { max: 2, active: [] },
          subBass: { max: 4, active: [] },
          wobbleBass: { max: 6, active: [] },
          snare: { max: 3, active: [] },
          hats: { max: 8, active: [] },
          leadSynth: { max: 8, active: [] },
          risers: { max: 2, active: [] },
          impacts: { max: 2, active: [] },
          glitch: { max: 4, active: [] }
        };
        
        // Layers
        this.layers = {
          kick: false, subBass: false, wobbleBass: false, snare: false,
          hats: false, leadSynth: false, risers: false, impacts: false,
          glitch: false
        };
        
        // Musical Elements
        this.scale = [0, 3, 5, 7, 10]; // Pentatonic minor for dubstep
        this.bassNote = 0;
        
        this.elements = {};
        this.spectrumBars = [];
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'spectrumViz', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i = 32; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 3.125}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupInteractionListeners() {
        // Simplified, remove konami etc for minimalism
      }

      async start() {
        try {
          // Permission requests
          this.ctx = new AudioContext();
          await this.ctx.resume();
          this.setupAudioChain();
          
          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'MOVE TO DROP THE BASS';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 3000);
          }, 500);

          this.active = true;
          this.startSequencer();
          this.animate();
        } catch (e) {
          console.error('Failed to start GUMP:', e);
        }
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 64;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -6;
        this.limiter.ratio.value = 12;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -18;
        this.compressor.ratio.value = 8;
        
        this.distortion = this.ctx.createWaveShaper();
        this.distortion.curve = this.makeDistortionCurve(50); // Heavy for dubstep
        
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(2); // Short reverb
        
        // Layer setup
        const layerNames = ['kick', 'subBass', 'wobbleBass', 'snare', 'hats', 'leadSynth', 'risers', 'impacts', 'glitch'];
        layerNames.forEach(name => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = 0.6; // Adjust per layer if needed

          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';

          this.layerGains[name].connect(this.layerPanners[name]);
          this.layerPanners[name].connect(this.compressor);
        });
        
        this.compressor.connect(this.distortion);
        this.distortion.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      makeDistortionCurve(amount) {
        const k = amount;
        const n = 44100;
        const curve = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          const x = i * 2 / n - 1;
          curve[i] = (3 + k) * x * 20 * (Math.PI / 180) / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      createReverbBuffer(time) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 3);
          }
        }
        return buffer;
      }

      setupMotionDetection() {
        // Similar, but adjust for wobble rate
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (!acc) return;

          const newMotion = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2) * 0.5;
          this.updateMotion(newMotion);
          this.lastAccel = acc;
        });

        // Mouse fallback
        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          const now = Date.now();
          const dt = now - lastMouse.time || 1;
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          const mouseMotion = Math.sqrt((newX - lastMouse.x)**2 + (newY - lastMouse.y)**2) / dt * 50;
          this.updateMotion(mouseMotion);
          this.pos.x = newX;
          this.pos.y = newY;
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.85 + newMotion * 0.15;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 100) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        if (this.motion > 0.8) this.lastMotionTime = Date.now();
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        this.wobbleRate = 1 + avgMotion * 4; // LFO rate for wobble
        this.wobbleDepth = 500 + this.intensity * 2000; // Filter cutoff modulation depth
        
        this.updateEvolution();
      }

      updateEvolution() {
        if (!this.firstMovement && this.motion > 1) {
          this.firstMovement = true;
          this.evolveToBuildup();
        }

        this.layers.kick = true; // Always on
        this.layers.snare = true;
        this.layers.hats = this.motion > 0.5;
        this.layers.subBass = this.motion > 1;
        this.layers.wobbleBass = this.intensity > 1;
        this.layers.leadSynth = this.intensity > 2;
        this.layers.risers = this.buildPhase;
        this.layers.impacts = this.dropPhase;
        this.layers.glitch = this.intensity > 3;

        if (this.totalMotion > 200) this.evolveToDrop();
        if (this.totalMotion > 600) this.evolveToBreakdown();

        this.bpm = 140 + this.intensity * 10;
      }

      evolveToBuildup() {
        this.stage = 'BUILDUP';
        this.elements.orb.className = 'orb buildup';
      }

      evolveToDrop() {
        this.stage = 'DROP';
        this.elements.orb.className = 'orb drop';
        this.dropPhase = true;
      }

      evolveToBreakdown() {
        this.stage = 'BREAKDOWN';
        this.dropPhase = false;
        this.buildPhase = false;
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          const interval = (60 / this.bpm) * 1000 / 4; // Quarter notes
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep() {
        if (this.step % 4 === 0) this.playKick();
        if (this.step % 8 === 4) this.playSnare();
        if (this.layers.hats && this.step % 2 === 0) this.playHats();
        if (this.layers.subBass && this.step % 4 === 0) this.playSubBass();
        if (this.layers.wobbleBass && this.step % 1 === 0) this.playWobbleBass();
        if (this.layers.leadSynth && Math.random() < 0.2) this.playLeadSynth();
        if (this.layers.risers && this.step % 16 === 0) this.playRiser();
        if (this.layers.impacts && Math.random() < 0.1) this.playImpact();
        if (this.layers.glitch && Math.random() < 0.05) this.playGlitch();
      }

      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.05);
        gain.gain.setValueAtTime(1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        osc.connect(gain).connect(this.layerGains.kick);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
      }

      playSnare() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        gain.gain.setValueAtTime(0.5, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        noise.connect(gain).connect(this.layerGains.snare);
        noise.start();
      }

      playHats() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.02, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        filter.type = 'highpass';
        filter.frequency.value = 8000;
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.02);
        noise.connect(filter).connect(gain).connect(this.layerGains.hats);
        noise.start();
      }

      playSubBass() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.value = 40 + this.bassNote * 5;
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        osc.connect(gain).connect(this.layerGains.subBass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      playWobbleBass() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        osc.type = 'sawtooth';
        osc.frequency.value = 50 + this.intensity * 10;
        
        filter.type = 'lowpass';
        filter.frequency.value = 100;
        filter.Q.value = 10;
        
        lfo.type = 'square'; // For hard wobble
        lfo.frequency.value = this.wobbleRate / 4; // Sync to rhythm
        lfoGain.gain.value = this.wobbleDepth;
        lfo.connect(lfoGain).connect(filter.frequency);
        lfo.start();
        
        gain.gain.setValueAtTime(0.7, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
        
        osc.connect(filter).connect(gain).connect(this.layerGains.wobbleBass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.25);
        lfo.stop(this.ctx.currentTime + 0.25);
      }

      playLeadSynth() {
        const osc = this.ctx.createOscillator();
        const modOsc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sawtooth';
        osc.frequency.value = 200 + Math.random() * 400;
        
        modOsc.type = 'sine';
        modOsc.frequency.value = 5;
        modOsc.connect(osc.frequency);
        modOsc.start();
        
        filter.type = 'bandpass';
        filter.frequency.value = 1000 + this.intensity * 1000;
        filter.Q.value = 15;
        
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        osc.connect(filter).connect(gain).connect(this.layerGains.leadSynth);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
        modOsc.stop(this.ctx.currentTime + 0.3);
      }

      playRiser() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(5000, this.ctx.currentTime + 4);
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 4);
        osc.connect(gain).connect(this.layerGains.risers);
        osc.start();
        osc.stop(this.ctx.currentTime + 4);
      }

      playImpact() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(80, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.1);
        gain.gain.setValueAtTime(0.8, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        osc.connect(gain).connect(this.layerGains.impacts);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
        this.elements.impactFlash.classList.add('active');
        setTimeout(() => this.elements.impactFlash.classList.remove('active'), 100);
      }

      playGlitch() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < data.length; i++) data[i] = Math.random() * 2 - 1;
        noise.buffer = buffer;
        noise.playbackRate.value = 1 + Math.random() * 2;
        gain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
        noise.connect(gain).connect(this.layerGains.glitch);
        noise.start();
      }

      updateUI() {
        this.elements.stageName.textContent = this.stage;
        this.elements.technique.textContent = this.currentTechnique.toUpperCase();
        
        const motionPercent = Math.min(this.intensity * 20, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.dataArray);
          this.spectrumBars.forEach((bar, i) => {
            bar.style.height = (this.dataArray[i] / 255) * 40 + 'px';
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          this.updateUI();
          
          requestAnimationFrame(loop);
        };
        loop();
      }
    }

    new GUMPEngine();
  </script>
</body>
</html>
