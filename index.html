<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<title>NEUROMANCER MOBILE - Environmental AI DJ</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-tap-highlight-color: transparent;
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  user-select: none;
  touch-action: none;
}

:root {
  --phi: 1.618033988749;
  --quantum-blue: #00ffff;
  --neural-purple: #ff00ff;
  --plasma-green: #00ff00;
  --void-black: #000000;
  --ghost-white: rgba(255,255,255,0.03);
  --electric-red: #ff0040;
  --synaptic-gold: #ffd700;
  --safe-area-top: env(safe-area-inset-top);
  --safe-area-bottom: env(safe-area-inset-bottom);
}

body {
  background: var(--void-black);
  color: #fff;
  overflow: hidden;
  height: 100vh;
  height: 100dvh;
  font-family: -apple-system, BlinkMacSystemFont, 'SF Pro', 'Segoe UI', sans-serif;
  position: relative;
  overscroll-behavior: none;
}

/* Quantum Field Background */
#quantumField {
  position: fixed;
  inset: 0;
  background: radial-gradient(ellipse at center,
    transparent 0%,
    rgba(0, 255, 255, 0.03) 40%,
    rgba(255, 0, 255, 0.02) 70%,
    transparent 100%);
  pointer-events: none;
  animation: quantum-pulse 8s ease-in-out infinite;
}

@keyframes quantum-pulse {
  0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
  50% { opacity: 0.6; transform: scale(1.1) rotate(90deg); }
}

/* Environmental Waveform Visualizer */
#environmentalCanvas {
  position: fixed;
  top: var(--safe-area-top);
  left: 0;
  width: 100%;
  height: 150px;
  pointer-events: none;
  opacity: 0.8;
  filter: drop-shadow(0 0 20px var(--quantum-blue));
}

/* Live Sample Orbs */
.sample-orb-container {
  position: fixed;
  top: calc(var(--safe-area-top) + 170px);
  left: 0;
  right: 0;
  height: 120px;
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 20px;
}

.sample-orb {
  width: 70px;
  height: 70px;
  border-radius: 50%;
  border: 2px solid var(--ghost-white);
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
  background: radial-gradient(circle at 30% 30%,
    rgba(0, 255, 255, 0.1),
    transparent 70%);
}

.sample-orb.recording {
  animation: orb-record 1s ease-in-out infinite;
  border-color: var(--electric-red);
  box-shadow: 0 0 30px var(--electric-red);
}

.sample-orb.loaded {
  border-color: var(--plasma-green);
  background: radial-gradient(circle at center,
    rgba(0, 255, 0, 0.2),
    transparent 70%);
}

.sample-orb.playing {
  animation: orb-play 0.5s ease-in-out infinite;
  border-color: var(--quantum-blue);
  box-shadow: 0 0 40px var(--quantum-blue);
}

@keyframes orb-record {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.15); }
}

@keyframes orb-play {
  0% { transform: scale(1) rotate(0deg); }
  100% { transform: scale(1.05) rotate(360deg); }
}

.orb-waveform {
  position: absolute;
  inset: 10px;
  border-radius: 50%;
  overflow: hidden;
}

.orb-canvas {
  width: 100%;
  height: 100%;
}

.orb-number {
  position: absolute;
  font-size: 20px;
  font-weight: 300;
  opacity: 0.5;
  z-index: 2;
}

/* Neural Touch Matrix */
.neural-touch-matrix {
  position: fixed;
  top: 310px;
  left: 20px;
  right: 20px;
  height: 200px;
  display: grid;
  grid-template-columns: repeat(8, 1fr);
  grid-template-rows: repeat(4, 1fr);
  gap: 3px;
  padding: 10px;
  background: rgba(0, 0, 0, 0.5);
  border: 1px solid var(--ghost-white);
  border-radius: 15px;
}

.neural-pad {
  background: var(--ghost-white);
  border-radius: 8px;
  position: relative;
  overflow: hidden;
  transition: all 0.15s ease;
}

.neural-pad.touched {
  background: linear-gradient(135deg,
    var(--quantum-blue),
    var(--neural-purple));
  transform: scale(0.95);
  box-shadow: 0 0 20px var(--quantum-blue);
}

.neural-pad.active {
  animation: pad-pulse 0.3s ease;
  background: var(--plasma-green);
}

@keyframes pad-pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.2); }
  100% { transform: scale(1); }
}

/* Gesture Control Zone */
.gesture-zone {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 240px);
  left: 20px;
  right: 20px;
  height: 140px;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 20px;
  background: radial-gradient(ellipse at center,
    rgba(0, 255, 255, 0.05),
    transparent);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.gesture-indicator {
  position: absolute;
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: radial-gradient(circle,
    var(--quantum-blue),
    transparent);
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
}

.gesture-indicator.active {
  opacity: 0.6;
}

.gesture-trail {
  position: absolute;
  width: 100%;
  height: 100%;
  pointer-events: none;
}

/* Environmental Analysis Display */
.env-analysis {
  position: fixed;
  top: calc(var(--safe-area-top) + 10px);
  right: 10px;
  width: 100px;
  background: rgba(0, 0, 0, 0.7);
  border: 1px solid var(--ghost-white);
  border-radius: 10px;
  padding: 8px;
  font-size: 9px;
  letter-spacing: 1px;
}

.env-metric {
  display: flex;
  justify-content: space-between;
  margin: 4px 0;
  opacity: 0.7;
}

.env-value {
  color: var(--quantum-blue);
  font-weight: bold;
}

/* Consciousness Meter */
.consciousness-meter {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 390px);
  left: 50%;
  transform: translateX(-50%);
  width: 200px;
  height: 6px;
  background: var(--ghost-white);
  border-radius: 3px;
  overflow: hidden;
}

.consciousness-level {
  height: 100%;
  width: 0%;
  background: linear-gradient(90deg,
    var(--plasma-green),
    var(--quantum-blue),
    var(--neural-purple));
  transition: width 0.5s cubic-bezier(0.23, 1, 0.320, 1);
  box-shadow: 0 0 10px currentColor;
}

/* Mix Control Sphere */
.mix-sphere {
  position: fixed;
  bottom: calc(var(--safe-area-bottom) + 100px);
  left: 50%;
  transform: translateX(-50%);
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.2);
  background: radial-gradient(circle at 30% 30%,
    rgba(0, 255, 255, 0.1),
    rgba(255, 0, 255, 0.05),
    transparent);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
}

.sphere-core {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: radial-gradient(circle,
    var(--quantum-blue),
    var(--neural-purple));
  position: absolute;
  transition: all 0.2s ease;
  box-shadow: 0 0 20px var(--quantum-blue);
}

.sphere-rings {
  position: absolute;
  inset: -20px;
  border: 1px solid rgba(0, 255, 255, 0.2);
  border-radius: 50%;
  animation: ring-pulse 3s ease-in-out infinite;
}

.sphere-rings::before {
  content: '';
  position: absolute;
  inset: 10px;
  border: 1px solid rgba(255, 0, 255, 0.15);
  border-radius: 50%;
  animation: ring-pulse 3s ease-in-out infinite reverse;
}

@keyframes ring-pulse {
  0%, 100% { transform: scale(1) rotate(0deg); opacity: 0.5; }
  50% { transform: scale(1.1) rotate(180deg); opacity: 1; }
}

/* Bottom Control Bar */
.control-bar {
  position: fixed;
  bottom: var(--safe-area-bottom);
  left: 0;
  right: 0;
  height: 80px;
  background: linear-gradient(to top,
    rgba(0, 0, 0, 0.9),
    transparent);
  display: flex;
  justify-content: space-around;
  align-items: center;
  padding: 0 20px;
}

.control-btn {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: 1px solid var(--ghost-white);
  background: rgba(0, 0, 0, 0.5);
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  position: relative;
  font-size: 10px;
  font-weight: 300;
  letter-spacing: 1px;
}

.control-btn.active {
  border-color: var(--quantum-blue);
  background: rgba(0, 255, 255, 0.1);
  box-shadow: 0 0 20px var(--quantum-blue);
}

.control-btn.record {
  width: 60px;
  height: 60px;
  border-color: var(--electric-red);
}

.control-btn.record.recording {
  animation: record-pulse 1s ease-in-out infinite;
  background: rgba(255, 0, 64, 0.2);
}

@keyframes record-pulse {
  0%, 100% { box-shadow: 0 0 0 0 var(--electric-red); }
  50% { box-shadow: 0 0 30px 10px var(--electric-red); }
}

/* Neural Decision Overlay */
.neural-decision-overlay {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  padding: 15px 30px;
  background: rgba(0, 0, 0, 0.8);
  border: 1px solid var(--quantum-blue);
  border-radius: 20px;
  font-size: 12px;
  letter-spacing: 3px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.3s ease;
  text-align: center;
  backdrop-filter: blur(10px);
}

.neural-decision-overlay.visible {
  opacity: 0.9;
  animation: decision-glow 0.5s ease;
}

@keyframes decision-glow {
  0% { box-shadow: 0 0 0 var(--quantum-blue); }
  50% { box-shadow: 0 0 40px var(--quantum-blue); }
  100% { box-shadow: 0 0 15px var(--quantum-blue); }
}

/* Particle System */
.particle-system {
  position: fixed;
  inset: 0;
  pointer-events: none;
  z-index: 1;
}

/* Performance Metrics */
.metrics-mini {
  position: fixed;
  top: calc(var(--safe-area-top) + 10px);
  left: 10px;
  font-size: 8px;
  opacity: 0.3;
  font-family: monospace;
  letter-spacing: 1px;
}

/* Start Portal */
.start-portal {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center,
    rgba(0, 0, 0, 0.9),
    var(--void-black));
  z-index: 10000;
  transition: opacity 2s cubic-bezier(0.23, 1, 0.320, 1);
}

.start-portal.hidden {
  opacity: 0;
  pointer-events: none;
}

.portal-sphere {
  width: 200px;
  height: 200px;
  border-radius: 50%;
  border: 1px solid rgba(255, 255, 255, 0.1);
  display: flex;
  align-items: center;
  justify-content: center;
  position: relative;
  background: radial-gradient(circle at center,
    transparent 0%,
    rgba(0, 255, 255, 0.05) 50%,
    transparent 100%);
  animation: portal-breathe 3s ease-in-out infinite;
}

@keyframes portal-breathe {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
}

.portal-text {
  font-size: 14px;
  letter-spacing: 8px;
  opacity: 0.618;
  font-weight: 100;
  margin-left: 8px;
}

/* Touch Ripples */
.touch-ripple {
  position: fixed;
  width: 40px;
  height: 40px;
  border-radius: 50%;
  border: 2px solid var(--quantum-blue);
  pointer-events: none;
  animation: ripple-expand 0.6s ease-out;
  z-index: 9999;
}

@keyframes ripple-expand {
  0% {
    transform: translate(-50%, -50%) scale(0);
    opacity: 1;
  }
  100% {
    transform: translate(-50%, -50%) scale(3);
    opacity: 0;
  }
}

/* Adaptive UI for different screen sizes */
@media (max-height: 700px) {
  .sample-orb-container { height: 100px; }
  .sample-orb { width: 60px; height: 60px; }
  .neural-touch-matrix { height: 160px; }
  .gesture-zone { height: 120px; }
  .mix-sphere { width: 100px; height: 100px; }
}

@media (max-height: 600px) {
  .neural-touch-matrix { grid-template-rows: repeat(3, 1fr); }
  .gesture-zone { height: 100px; }
}

/* Haptic Feedback Indicator */
.haptic-indicator {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 100px;
  height: 100px;
  border-radius: 50%;
  border: 3px solid var(--quantum-blue);
  opacity: 0;
  pointer-events: none;
  animation: haptic-pulse 0.3s ease-out;
}

@keyframes haptic-pulse {
  0% { opacity: 1; transform: translate(-50%, -50%) scale(0.8); }
  100% { opacity: 0; transform: translate(-50%, -50%) scale(1.5); }
}

/* Loading DNA */
.loading-dna {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  display: none;
  z-index: 10001;
}

.loading-dna.active {
  display: block;
}

.dna-strand {
  width: 100px;
  height: 100px;
  position: relative;
  animation: dna-rotate 2s linear infinite;
}

@keyframes dna-rotate {
  to { transform: rotate(360deg); }
}

.dna-dot {
  position: absolute;
  width: 8px;
  height: 8px;
  background: var(--quantum-blue);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--quantum-blue);
}
</style>
</head>
<body>
<div id="quantumField"></div>
<canvas id="environmentalCanvas"></canvas>
<div class="particle-system" id="particleSystem"></div>

<div class="metrics-mini" id="metrics">
  <div>FPS: <span id="fps">0</span></div>
  <div>CPU: <span id="cpu">0</span>%</div>
  <div>SAMPLES: <span id="sampleCount">0</span></div>
</div>

<div class="env-analysis" id="envAnalysis">
  <div class="env-metric">
    <span>NOISE</span>
    <span class="env-value" id="noiseLevel">0</span>
  </div>
  <div class="env-metric">
    <span>RHYTHM</span>
    <span class="env-value" id="rhythmScore">0</span>
  </div>
  <div class="env-metric">
    <span>TONE</span>
    <span class="env-value" id="toneQuality">0</span>
  </div>
  <div class="env-metric">
    <span>ENERGY</span>
    <span class="env-value" id="energyLevel">0</span>
  </div>
</div>

<div class="sample-orb-container" id="sampleOrbs">
  <div class="sample-orb" data-slot="0">
    <canvas class="orb-canvas"></canvas>
    <span class="orb-number">1</span>
  </div>
  <div class="sample-orb" data-slot="1">
    <canvas class="orb-canvas"></canvas>
    <span class="orb-number">2</span>
  </div>
  <div class="sample-orb" data-slot="2">
    <canvas class="orb-canvas"></canvas>
    <span class="orb-number">3</span>
  </div>
  <div class="sample-orb" data-slot="3">
    <canvas class="orb-canvas"></canvas>
    <span class="orb-number">4</span>
  </div>
</div>

<div class="neural-touch-matrix" id="neuralMatrix"></div>

<div class="consciousness-meter">
  <div class="consciousness-level" id="consciousnessLevel"></div>
</div>

<div class="gesture-zone" id="gestureZone">
  <canvas class="gesture-trail" id="gestureCanvas"></canvas>
  <div class="gesture-indicator" id="gestureIndicator"></div>
</div>

<div class="mix-sphere" id="mixSphere">
  <div class="sphere-rings"></div>
  <div class="sphere-core" id="sphereCore"></div>
</div>

<div class="control-bar">
  <div class="control-btn" id="btnLoop">LOOP</div>
  <div class="control-btn" id="btnEffect">FX</div>
  <div class="control-btn record" id="btnRecord">REC</div>
  <div class="control-btn" id="btnAI">AI</div>
  <div class="control-btn" id="btnMix">MIX</div>
</div>

<div class="neural-decision-overlay" id="neuralDecision">
  <div id="decisionText">PROCESSING...</div>
</div>

<div class="loading-dna" id="loadingDNA">
  <div class="dna-strand">
    <div class="dna-dot" style="top: 10%; left: 50%;"></div>
    <div class="dna-dot" style="top: 30%; left: 70%;"></div>
    <div class="dna-dot" style="top: 50%; left: 50%;"></div>
    <div class="dna-dot" style="top: 70%; left: 30%;"></div>
    <div class="dna-dot" style="top: 90%; left: 50%;"></div>
  </div>
</div>

<div class="start-portal" id="startPortal">
  <div class="portal-sphere" id="portalSphere">
    <div class="portal-text">AWAKEN</div>
  </div>
</div>

<script>
'use strict';

// NEUROMANCER MOBILE - Environmental AI DJ System
class NeuromancerMobile {
  constructor() {
    this.config = {
      sampleRate: 48000,
      fftSize: 4096,
      maxSamples: 16,
      recordingDuration: 3000, // 3 seconds max per sample
      touchSensitivity: 0.001,
      gestureThreshold: 50,
      neuralNetworkSize: 64,
      environmentalAnalysisRate: 100,
      mixAutomationSpeed: 0.02,
      consciousnessGrowthRate: 0.001
    };
    
    this.state = {
      isAwake: false,
      isRecording: false,
      currentRecordingSlot: 0,
      consciousness: 0,
      energy: 0.5,
      complexity: 0.5,
      activeEffects: new Set(),
      aiMode: 'adaptive',
      mixPosition: { x: 0, y: 0 },
      environmentalProfile: null
    };
    
    this.samples = new Map();
    this.touchPoints = new Map();
    this.gestureHistory = [];
    this.neuralMemory = [];
    
    this.init();
  }
  
  init() {
    this.setupUI();
    this.setupTouchHandlers();
    this.setupStartPortal();
    
    // Prevent default mobile behaviors
    document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    document.addEventListener('gesturestart', e => e.preventDefault());
    document.addEventListener('gesturechange', e => e.preventDefault());
    
    console.log('🧠 NEUROMANCER MOBILE INITIALIZED');
  }
  
  setupUI() {
    this.ui = {
      startPortal: document.getElementById('startPortal'),
      portalSphere: document.getElementById('portalSphere'),
      loadingDNA: document.getElementById('loadingDNA'),
      
      environmentalCanvas: document.getElementById('environmentalCanvas'),
      sampleOrbs: document.querySelectorAll('.sample-orb'),
      neuralMatrix: document.getElementById('neuralMatrix'),
      gestureZone: document.getElementById('gestureZone'),
      gestureCanvas: document.getElementById('gestureCanvas'),
      mixSphere: document.getElementById('mixSphere'),
      sphereCore: document.getElementById('sphereCore'),
      
      btnRecord: document.getElementById('btnRecord'),
      btnLoop: document.getElementById('btnLoop'),
      btnEffect: document.getElementById('btnEffect'),
      btnAI: document.getElementById('btnAI'),
      btnMix: document.getElementById('btnMix'),
      
      consciousnessLevel: document.getElementById('consciousnessLevel'),
      neuralDecision: document.getElementById('neuralDecision'),
      decisionText: document.getElementById('decisionText'),
      
      metrics: {
        fps: document.getElementById('fps'),
        cpu: document.getElementById('cpu'),
        sampleCount: document.getElementById('sampleCount')
      },
      
      envAnalysis: {
        noise: document.getElementById('noiseLevel'),
        rhythm: document.getElementById('rhythmScore'),
        tone: document.getElementById('toneQuality'),
        energy: document.getElementById('energyLevel')
      }
    };
    
    // Initialize neural matrix
    this.initializeNeuralMatrix();
    
    // Setup canvases
    this.setupCanvases();
  }
  
  initializeNeuralMatrix() {
    const matrix = this.ui.neuralMatrix;
    matrix.innerHTML = '';
    
    for (let i = 0; i < 32; i++) {
      const pad = document.createElement('div');
      pad.className = 'neural-pad';
      pad.dataset.index = i;
      matrix.appendChild(pad);
    }
  }
  
  setupCanvases() {
    // Environmental waveform canvas
    this.envCanvas = this.ui.environmentalCanvas.getContext('2d');
    this.ui.environmentalCanvas.width = window.innerWidth;
    this.ui.environmentalCanvas.height = 150;
    
    // Gesture trail canvas
    this.gestureCtx = this.ui.gestureCanvas.getContext('2d');
    this.ui.gestureCanvas.width = this.ui.gestureZone.offsetWidth;
    this.ui.gestureCanvas.height = this.ui.gestureZone.offsetHeight;
    
    // Sample orb canvases
    this.ui.sampleOrbs.forEach(orb => {
      const canvas = orb.querySelector('.orb-canvas');
      canvas.width = 50;
      canvas.height = 50;
    });
  }
  
  setupTouchHandlers() {
    // Sample orbs - tap to play, hold to record
    this.ui.sampleOrbs.forEach((orb, index) => {
      let touchTimer;
      
      orb.addEventListener('touchstart', e => {
        e.preventDefault();
        this.createTouchRipple(e.touches[0]);
        
        touchTimer = setTimeout(() => {
          this.startRecording(index);
          this.hapticFeedback('heavy');
        }, 300);
      });
      
      orb.addEventListener('touchend', e => {
        e.preventDefault();
        clearTimeout(touchTimer);
        
        if (!this.state.isRecording) {
          this.playSample(index);
          this.hapticFeedback('light');
        } else {
          this.stopRecording(index);
        }
      });
    });
    
    // Neural matrix touch handling
    const pads = this.ui.neuralMatrix.querySelectorAll('.neural-pad');
    pads.forEach(pad => {
      pad.addEventListener('touchstart', e => {
        e.preventDefault();
        pad.classList.add('touched');
        this.triggerNeuralPad(parseInt(pad.dataset.index));
        this.hapticFeedback('selection');
      });
      
      pad.addEventListener('touchend', e => {
        e.preventDefault();
        pad.classList.remove('touched');
      });
    });
    
    // Gesture zone for effects and transitions
    this.setupGestureZone();
    
    // Mix sphere for 2D mixing control
    this.setupMixSphere();
    
    // Control buttons
    this.setupControlButtons();
  }
  
  setupGestureZone() {
    const zone = this.ui.gestureZone;
    let isGesturing = false;
    let gesturePoints = [];
    
    zone.addEventListener('touchstart', e => {
      e.preventDefault();
      isGesturing = true;
      gesturePoints = [];
      
      const touch = e.touches[0];
      const rect = zone.getBoundingClientRect();
      gesturePoints.push({
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top,
        time: Date.now()
      });
      
      this.ui.gestureIndicator.classList.add('active');
      this.ui.gestureIndicator.style.left = gesturePoints[0].x + 'px';
      this.ui.gestureIndicator.style.top = gesturePoints[0].y + 'px';
    });
    
    zone.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!isGesturing) return;
      
      const touch = e.touches[0];
      const rect = zone.getBoundingClientRect();
      const point = {
        x: touch.clientX - rect.left,
        y: touch.clientY - rect.top,
        time: Date.now()
      };
      
      gesturePoints.push(point);
      
      // Draw gesture trail
      this.drawGestureTrail(gesturePoints);
      
      // Update indicator position
      this.ui.gestureIndicator.style.left = point.x + 'px';
      this.ui.gestureIndicator.style.top = point.y + 'px';
      
      // Real-time gesture recognition
      if (gesturePoints.length > 10) {
        this.recognizeGesture(gesturePoints);
      }
    });
    
    zone.addEventListener('touchend', e => {
      e.preventDefault();
      isGesturing = false;
      
      this.ui.gestureIndicator.classList.remove('active');
      
      if (gesturePoints.length > 5) {
        const gesture = this.classifyGesture(gesturePoints);
        this.applyGestureEffect(gesture);
      }
      
      // Clear trail after a moment
      setTimeout(() => {
        this.gestureCtx.clearRect(0, 0, this.ui.gestureCanvas.width, this.ui.gestureCanvas.height);
      }, 500);
    });
  }
  
  setupMixSphere() {
    const sphere = this.ui.mixSphere;
    const core = this.ui.sphereCore;
    let isDragging = false;
    
    sphere.addEventListener('touchstart', e => {
      e.preventDefault();
      isDragging = true;
      this.hapticFeedback('light');
    });
    
    sphere.addEventListener('touchmove', e => {
      e.preventDefault();
      if (!isDragging) return;
      
      const touch = e.touches[0];
      const rect = sphere.getBoundingClientRect();
      const centerX = rect.width / 2;
      const centerY = rect.height / 2;
      
      let x = touch.clientX - rect.left - centerX;
      let y = touch.clientY - rect.top - centerY;
      
      // Constrain to circle
      const distance = Math.sqrt(x * x + y * y);
      const maxDistance = rect.width / 2 - 20;
      
      if (distance > maxDistance) {
        const angle = Math.atan2(y, x);
        x = Math.cos(angle) * maxDistance;
        y = Math.sin(angle) * maxDistance;
      }
      
      // Update core position
      core.style.left = (centerX + x) + 'px';
      core.style.top = (centerY + y) + 'px';
      
      // Update mix position
      this.state.mixPosition = {
        x: x / maxDistance,
        y: y / maxDistance
      };
      
      // Apply mix changes
      this.updateMixParameters();
    });
    
    sphere.addEventListener('touchend', e => {
      e.preventDefault();
      isDragging = false;
      
      // Animate back to center
      core.style.left = '50%';
      core.style.top = '50%';
      core.style.transform = 'translate(-50%, -50%)';
      
      this.state.mixPosition = { x: 0, y: 0 };
    });
  }
  
  setupControlButtons() {
    // Record button
    this.ui.btnRecord.addEventListener('touchstart', e => {
      e.preventDefault();
      
      if (!this.state.isRecording) {
        this.startEnvironmentalRecording();
      } else {
        this.stopEnvironmentalRecording();
      }
    });
    
    // Loop button
    this.ui.btnLoop.addEventListener('touchstart', e => {
      e.preventDefault();
      this.ui.btnLoop.classList.toggle('active');
      this.toggleLoopMode();
      this.hapticFeedback('light');
    });
    
    // Effect button
    this.ui.btnEffect.addEventListener('touchstart', e => {
      e.preventDefault();
      this.ui.btnEffect.classList.toggle('active');
      this.cycleEffects();
      this.hapticFeedback('light');
    });
    
    // AI button
    this.ui.btnAI.addEventListener('touchstart', e => {
      e.preventDefault();
      this.ui.btnAI.classList.toggle('active');
      this.toggleAIMode();
      this.hapticFeedback('medium');
    });
    
    // Mix button
    this.ui.btnMix.addEventListener('touchstart', e => {
      e.preventDefault();
      this.ui.btnMix.classList.toggle('active');
      this.autoMix();
      this.hapticFeedback('light');
    });
  }
  
  setupStartPortal() {
    this.ui.portalSphere.addEventListener('touchstart', e => {
      e.preventDefault();
      this.awaken();
    });
  }
  
  async awaken() {
    console.log('🌌 AWAKENING NEUROMANCER MOBILE...');
    
    this.ui.loadingDNA.classList.add('active');
    
    try {
      // Initialize audio context
      await this.initializeAudio();
      
      // Start environmental analysis
      this.startEnvironmentalAnalysis();
      
      // Initialize neural network
      this.initializeNeuralNetwork();
      
      // Start visualization
      this.startVisualization();
      
      // Start consciousness evolution
      this.startConsciousnessEvolution();
      
      // Hide portal
      this.ui.startPortal.classList.add('hidden');
      this.ui.loadingDNA.classList.remove('active');
      
      this.state.isAwake = true;
      
      console.log('⚡ NEUROMANCER MOBILE ONLINE');
      
      // Initial haptic pulse
      this.hapticFeedback('heavy');
      
    } catch (error) {
      console.error('Awakening failed:', error);
      this.ui.loadingDNA.classList.remove('active');
    }
  }
  
  async initializeAudio() {
    // Create audio context
    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: this.config.sampleRate,
      latencyHint: 'interactive'
    });
    
    // Get microphone access
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: this.config.sampleRate
      }
    });
    
    // Setup audio nodes
    this.setupAudioGraph(stream);
    
    // Resume context
    await this.audioContext.resume();
  }
  
  setupAudioGraph(stream) {
    // Microphone input
    this.micInput = this.audioContext.createMediaStreamSource(stream);
    
    // Analyser for visualization
    this.analyser = this.audioContext.createAnalyser();
    this.analyser.fftSize = this.config.fftSize;
    this.analyser.smoothingTimeConstant = 0.7;
    
    // Recorder
    this.recorder = this.audioContext.createScriptProcessor(4096, 1, 1);
    this.recordBuffer = [];
    
    this.recorder.onaudioprocess = e => {
      if (this.state.isRecording) {
        const input = e.inputBuffer.getChannelData(0);
        this.recordBuffer.push(...input);
        
        // Auto-stop if buffer gets too large
        if (this.recordBuffer.length > this.config.sampleRate * 3) {
          this.stopRecording(this.state.currentRecordingSlot);
        }
      }
    };
    
    // Effects chain
    this.setupEffectsChain();
    
    // Master gain
    this.masterGain = this.audioContext.createGain();
    this.masterGain.gain.value = 0.8;
    
    // Connect graph
    this.micInput.connect(this.analyser);
    this.micInput.connect(this.recorder);
    this.recorder.connect(this.audioContext.destination);
    this.masterGain.connect(this.audioContext.destination);
  }
  
  setupEffectsChain() {
    // Create mobile-optimized effects
    this.effects = {
      delay: this.createDelay(),
      reverb: this.createReverb(),
      filter: this.createFilter(),
      distortion: this.createDistortion()
    };
  }
  
  createDelay() {
    const delay = this.audioContext.createDelay(2);
    const feedback = this.audioContext.createGain();
    const wetGain = this.audioContext.createGain();
    
    delay.delayTime.value = 0.25;
    feedback.gain.value = 0.4;
    wetGain.gain.value = 0;
    
    delay.connect(feedback);
    feedback.connect(delay);
    delay.connect(wetGain);
    
    return { input: delay, output: wetGain, feedback, wet: wetGain };
  }
  
  createReverb() {
    const convolver = this.audioContext.createConvolver();
    const wetGain = this.audioContext.createGain();
    
    // Generate simple impulse response
    const length = this.audioContext.sampleRate * 2;
    const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const channelData = impulse.getChannelData(channel);
      for (let i = 0; i < length; i++) {
        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2) * 0.3;
      }
    }
    
    convolver.buffer = impulse;
    wetGain.gain.value = 0;
    
    convolver.connect(wetGain);
    
    return { input: convolver, output: wetGain, wet: wetGain };
  }
  
  createFilter() {
    const filter = this.audioContext.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 20000;
    filter.Q.value = 1;
    
    return filter;
  }
  
  createDistortion() {
    const waveshaper = this.audioContext.createWaveShaper();
    const curve = new Float32Array(256);
    
    for (let i = 0; i < 256; i++) {
      const x = (i - 128) / 128;
      curve[i] = Math.tanh(x * 3) * 0.8;
    }
    
    waveshaper.curve = curve;
    waveshaper.oversample = '2x';
    
    return waveshaper;
  }
  
  startRecording(slot) {
    if (this.state.isRecording) return;
    
    console.log(`🎙️ Recording to slot ${slot + 1}`);
    
    this.state.isRecording = true;
    this.state.currentRecordingSlot = slot;
    this.recordBuffer = [];
    
    // Visual feedback
    this.ui.sampleOrbs[slot].classList.add('recording');
    
    // Auto-stop after max duration
    setTimeout(() => {
      if (this.state.isRecording && this.state.currentRecordingSlot === slot) {
        this.stopRecording(slot);
      }
    }, this.config.recordingDuration);
  }
  
  stopRecording(slot) {
    if (!this.state.isRecording || this.state.currentRecordingSlot !== slot) return;
    
    console.log(`⏹️ Stopped recording slot ${slot + 1}`);
    
    this.state.isRecording = false;
    
    // Process and store sample
    if (this.recordBuffer.length > this.audioContext.sampleRate * 0.1) {
      this.processSample(slot, new Float32Array(this.recordBuffer));
    }
    
    // Update UI
    this.ui.sampleOrbs[slot].classList.remove('recording');
    this.ui.sampleOrbs[slot].classList.add('loaded');
  }
  
  processSample(slot, audioData) {
    // Create audio buffer
    const buffer = this.audioContext.createBuffer(1, audioData.length, this.audioContext.sampleRate);
    buffer.getChannelData(0).set(audioData);
    
    // Analyze sample
    const analysis = this.analyzeSample(audioData);
    
    // Store sample
    this.samples.set(slot, {
      buffer,
      analysis,
      timestamp: Date.now(),
      source: null
    });
    
    // Draw waveform in orb
    this.drawOrbWaveform(slot, audioData);
    
    // Update sample count
    this.ui.metrics.sampleCount.textContent = this.samples.size;
    
    // Neural network learns from new sample
    this.learnFromSample(analysis);
  }
  
  analyzeSample(audioData) {
    // Calculate audio features
    const rms = Math.sqrt(audioData.reduce((sum, x) => sum + x * x, 0) / audioData.length);
    const peak = Math.max(...audioData.map(Math.abs));
    
    // Detect tempo (simplified)
    const threshold = rms * 0.7;
    const onsets = [];
    
    for (let i = 1; i < audioData.length; i++) {
      if (audioData[i-1] < threshold && audioData[i] >= threshold) {
        onsets.push(i);
      }
    }
    
    let tempo = 0;
    if (onsets.length > 1) {
      const intervals = [];
      for (let i = 1; i < onsets.length; i++) {
        intervals.push((onsets[i] - onsets[i-1]) / this.audioContext.sampleRate);
      }
      const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
      tempo = 60 / avgInterval;
    }
    
    // Spectral analysis
    const fft = new Float32Array(this.config.fftSize);
    // Simplified spectral centroid
    const centroid = audioData.length / 2;
    
    return {
      duration: audioData.length / this.audioContext.sampleRate,
      rms,
      peak,
      tempo: Math.min(200, Math.max(60, tempo)),
      centroid,
      energy: rms,
      complexity: onsets.length / (audioData.length / this.audioContext.sampleRate)
    };
  }
  
  drawOrbWaveform(slot, audioData) {
    const orb = this.ui.sampleOrbs[slot];
    const canvas = orb.querySelector('.orb-canvas');
    const ctx = canvas.getContext('2d');
    
    ctx.clearRect(0, 0, 50, 50);
    
    // Draw circular waveform
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    const samples = 64;
    const step = Math.floor(audioData.length / samples);
    
    for (let i = 0; i < samples; i++) {
      const angle = (i / samples) * Math.PI * 2 - Math.PI / 2;
      const sample = audioData[i * step] || 0;
      const radius = 15 + sample * 10;
      
      const x = 25 + Math.cos(angle) * radius;
      const y = 25 + Math.sin(angle) * radius;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.closePath();
    ctx.stroke();
  }
  
  playSample(slot) {
    const sample = this.samples.get(slot);
    if (!sample) return;
    
    console.log(`▶️ Playing sample ${slot + 1}`);
    
    // Stop previous playback
    if (sample.source) {
      sample.source.stop();
    }
    
    // Create new source
    const source = this.audioContext.createBufferSource();
    source.buffer = sample.buffer;
    
    // Apply current effects
    let node = source;
    
    if (this.state.activeEffects.has('delay')) {
      node.connect(this.effects.delay.input);
      node = this.effects.delay.output;
    }
    
    if (this.state.activeEffects.has('reverb')) {
      node.connect(this.effects.reverb.input);
      node = this.effects.reverb.output;
    }
    
    if (this.state.activeEffects.has('filter')) {
      node.connect(this.effects.filter);
      node = this.effects.filter;
    }
    
    node.connect(this.masterGain);
    
    // Store reference
    sample.source = source;
    
    // Visual feedback
    this.ui.sampleOrbs[slot].classList.add('playing');
    
    source.onended = () => {
      this.ui.sampleOrbs[slot].classList.remove('playing');
      sample.source = null;
    };
    
    // Start playback
    source.start();
    
    // Update neural state
    this.updateNeuralState('sample_played', { slot, analysis: sample.analysis });
  }
  
  startEnvironmentalRecording() {
    if (this.state.isRecording) return;
    
    console.log('🌍 Recording environment...');
    
    this.state.isRecording = true;
    this.recordBuffer = [];
    
    this.ui.btnRecord.classList.add('recording');
    
    // Find next empty slot
    let slot = -1;
    for (let i = 0; i < 4; i++) {
      if (!this.samples.has(i)) {
        slot = i;
        break;
      }
    }
    
    if (slot === -1) {
      // Overwrite oldest
      slot = 0;
    }
    
    this.state.currentRecordingSlot = slot;
    this.ui.sampleOrbs[slot].classList.add('recording');
    
    // Auto-stop
    setTimeout(() => {
      if (this.state.isRecording) {
        this.stopEnvironmentalRecording();
      }
    }, this.config.recordingDuration);
  }
  
  stopEnvironmentalRecording() {
    if (!this.state.isRecording) return;
    
    console.log('⏹️ Environmental recording stopped');
    
    const slot = this.state.currentRecordingSlot;
    
    this.state.isRecording = false;
    this.ui.btnRecord.classList.remove('recording');
    
    if (this.recordBuffer.length > this.audioContext.sampleRate * 0.1) {
      this.processSample(slot, new Float32Array(this.recordBuffer));
    }
    
    this.ui.sampleOrbs[slot].classList.remove('recording');
  }
  
  drawGestureTrail(points) {
    const ctx = this.gestureCtx;
    
    ctx.clearRect(0, 0, this.ui.gestureCanvas.width, this.ui.gestureCanvas.height);
    
    if (points.length < 2) return;
    
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    
    for (let i = 1; i < points.length; i++) {
      ctx.lineTo(points[i].x, points[i].y);
    }
    
    ctx.stroke();
    
    // Add glow effect
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00ffff';
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  
  recognizeGesture(points) {
    // Real-time gesture recognition
    // This is called during gesture movement
  }
  
  classifyGesture(points) {
    if (points.length < 2) return 'tap';
    
    const startPoint = points[0];
    const endPoint = points[points.length - 1];
    
    const deltaX = endPoint.x - startPoint.x;
    const deltaY = endPoint.y - startPoint.y;
    const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
    
    // Classify based on movement pattern
    if (distance < 30) {
      return 'tap';
    }
    
    // Check for circular motion
    let totalAngleChange = 0;
    for (let i = 2; i < points.length; i++) {
      const angle1 = Math.atan2(points[i-1].y - points[i-2].y, points[i-1].x - points[i-2].x);
      const angle2 = Math.atan2(points[i].y - points[i-1].y, points[i].x - points[i-1].x);
      totalAngleChange += angle2 - angle1;
    }
    
    if (Math.abs(totalAngleChange) > Math.PI * 1.5) {
      return totalAngleChange > 0 ? 'circle_cw' : 'circle_ccw';
    }
    
    // Linear gestures
    const angle = Math.atan2(deltaY, deltaX);
    
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      return deltaX > 0 ? 'swipe_right' : 'swipe_left';
    } else {
      return deltaY > 0 ? 'swipe_down' : 'swipe_up';
    }
  }
  
  applyGestureEffect(gesture) {
    console.log(`✨ Gesture: ${gesture}`);
    
    switch(gesture) {
      case 'swipe_up':
        this.increaseEnergy();
        break;
      case 'swipe_down':
        this.decreaseEnergy();
        break;
      case 'swipe_left':
        this.previousEffect();
        break;
      case 'swipe_right':
        this.nextEffect();
        break;
      case 'circle_cw':
        this.applyFilter('highpass');
        break;
      case 'circle_ccw':
        this.applyFilter('lowpass');
        break;
      case 'tap':
        this.triggerBeat();
        break;
    }
    
    this.hapticFeedback('light');
    this.showNeuralDecision(gesture.toUpperCase().replace('_', ' '));
  }
  
  triggerNeuralPad(index) {
    const pad = this.ui.neuralMatrix.children[index];
    pad.classList.add('active');
    
    // Trigger sound based on pad position
    const row = Math.floor(index / 8);
    const col = index % 8;
    
    // Create synthetic sound
    const osc = this.audioContext.createOscillator();
    const env = this.audioContext.createGain();
    
    const frequency = 110 * Math.pow(2, col / 12) * (row + 1);
    osc.frequency.value = frequency;
    osc.type = ['sine', 'square', 'sawtooth', 'triangle'][row];
    
    env.gain.setValueAtTime(0.3, this.audioContext.currentTime);
    env.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
    
    osc.connect(env);
    env.connect(this.masterGain);
    
    osc.start();
    osc.stop(this.audioContext.currentTime + 0.5);
    
    setTimeout(() => {
      pad.classList.remove('active');
    }, 300);
    
    // Update neural memory
    this.neuralMemory.push({ type: 'pad', index, frequency, time: Date.now() });
  }
  
  updateMixParameters() {
    const { x, y } = this.state.mixPosition;
    
    // X-axis controls filter cutoff
    const filterFreq = 200 + (x + 1) * 4900;
    this.effects.filter.frequency.setTargetAtTime(filterFreq, this.audioContext.currentTime, 0.01);
    
    // Y-axis controls effect mix
    const wetAmount = Math.max(0, -y);
    this.effects.delay.wet.gain.setTargetAtTime(wetAmount * 0.5, this.audioContext.currentTime, 0.01);
    this.effects.reverb.wet.gain.setTargetAtTime(wetAmount * 0.3, this.audioContext.currentTime, 0.01);
    
    // Update energy based on position
    this.state.energy = Math.sqrt(x * x + y * y);
    
    // Neural feedback
    this.updateNeuralState('mix_change', { x, y, energy: this.state.energy });
  }
  
  toggleLoopMode() {
    // Implement loop functionality
    console.log('🔁 Loop mode toggled');
  }
  
  cycleEffects() {
    const effects = ['delay', 'reverb', 'filter', 'distortion'];
    const currentIndex = Array.from(this.state.activeEffects).findIndex(e => effects.includes(e));
    
    this.state.activeEffects.clear();
    
    if (currentIndex < effects.length - 1) {
      this.state.activeEffects.add(effects[currentIndex + 1]);
    } else {
      this.state.activeEffects.add(effects[0]);
    }
    
    console.log('🎛️ Active effect:', Array.from(this.state.activeEffects)[0]);
    this.showNeuralDecision(`FX: ${Array.from(this.state.activeEffects)[0]?.toUpperCase() || 'NONE'}`);
  }
  
  toggleAIMode() {
    const modes = ['adaptive', 'aggressive', 'ambient', 'experimental'];
    const currentIndex = modes.indexOf(this.state.aiMode);
    
    this.state.aiMode = modes[(currentIndex + 1) % modes.length];
    
    console.log(`🤖 AI Mode: ${this.state.aiMode}`);
    this.showNeuralDecision(`AI: ${this.state.aiMode.toUpperCase()}`);
  }
  
  autoMix() {
    console.log('🎚️ Auto-mixing...');
    
    // Analyze all samples
    const analyses = Array.from(this.samples.values()).map(s => s.analysis);
    
    if (analyses.length < 2) return;
    
    // Find compatible samples based on tempo and key
    const compatible = this.findCompatibleSamples(analyses);
    
    // Create automatic mix sequence
    this.createMixSequence(compatible);
    
    this.showNeuralDecision('AUTO MIX ENGAGED');
  }
  
  findCompatibleSamples(analyses) {
    // Group by similar tempo
    const tempoGroups = {};
    
    analyses.forEach((analysis, index) => {
      const tempoRange = Math.round(analysis.tempo / 10) * 10;
      if (!tempoGroups[tempoRange]) {
        tempoGroups[tempoRange] = [];
      }
      tempoGroups[tempoRange].push(index);
    });
    
    return tempoGroups;
  }
  
  createMixSequence(compatible) {
    // Create automated playback sequence
    let delay = 0;
    
    for (let tempoRange in compatible) {
      const samples = compatible[tempoRange];
      
      samples.forEach((sampleIndex, i) => {
        setTimeout(() => {
          this.playSample(sampleIndex);
        }, delay);
        
        delay += 2000; // 2 second intervals
      });
    }
  }
  
  startEnvironmentalAnalysis() {
    setInterval(() => {
      if (!this.analyser) return;
      
      const freqData = new Uint8Array(this.analyser.frequencyBinCount);
      this.analyser.getByteFrequencyData(freqData);
      
      // Calculate environmental metrics
      const noise = this.calculateNoiseLevel(freqData);
      const rhythm = this.detectRhythm(freqData);
      const tone = this.analyzeTone(freqData);
      const energy = this.calculateEnergy(freqData);
      
      // Update display
      this.ui.envAnalysis.noise.textContent = Math.round(noise * 100);
      this.ui.envAnalysis.rhythm.textContent = Math.round(rhythm * 100);
      this.ui.envAnalysis.tone.textContent = Math.round(tone * 100);
      this.ui.envAnalysis.energy.textContent = Math.round(energy * 100);
      
      // Store profile
      this.state.environmentalProfile = { noise, rhythm, tone, energy };
      
      // Neural adaptation
      this.adaptToEnvironment();
      
    }, this.config.environmentalAnalysisRate);
  }
  
  calculateNoiseLevel(freqData) {
    const highFreq = freqData.slice(freqData.length * 0.7);
    return highFreq.reduce((a, b) => a + b, 0) / (highFreq.length * 255);
  }
  
  detectRhythm(freqData) {
    const lowFreq = freqData.slice(0, 10);
    const variance = this.calculateVariance(lowFreq);
    return Math.min(1, variance / 50);
  }
  
  analyzeTone(freqData) {
    // Find spectral centroid
    let centroid = 0;
    let totalMag = 0;
    
    for (let i = 0; i < freqData.length; i++) {
      centroid += i * freqData[i];
      totalMag += freqData[i];
    }
    
    if (totalMag > 0) {
      centroid /= totalMag;
    }
    
    return centroid / freqData.length;
  }
  
  calculateEnergy(freqData) {
    return freqData.reduce((a, b) => a + b, 0) / (freqData.length * 255);
  }
  
  calculateVariance(data) {
    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    const variance = data.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / data.length;
    return Math.sqrt(variance);
  }
  
  adaptToEnvironment() {
    if (!this.state.environmentalProfile) return;
    
    const { noise, rhythm, tone, energy } = this.state.environmentalProfile;
    
    // Adapt AI behavior based on environment
    if (noise > 0.7) {
      // Noisy environment - use more aggressive filtering
      this.effects.filter.frequency.setTargetAtTime(1000, this.audioContext.currentTime, 0.1);
    }
    
    if (rhythm > 0.5) {
      // Rhythmic environment - sync to beat
      this.state.aiMode = 'adaptive';
    }
    
    if (energy < 0.2) {
      // Quiet environment - increase sensitivity
      this.masterGain.gain.setTargetAtTime(1, this.audioContext.currentTime, 0.1);
    }
  }
  
  initializeNeuralNetwork() {
    this.neuralNetwork = {
      weights: new Float32Array(this.config.neuralNetworkSize * this.config.neuralNetworkSize),
      biases: new Float32Array(this.config.neuralNetworkSize),
      activations: new Float32Array(this.config.neuralNetworkSize),
      memory: []
    };
    
    // Initialize with random weights
    for (let i = 0; i < this.neuralNetwork.weights.length; i++) {
      this.neuralNetwork.weights[i] = (Math.random() - 0.5) * 0.1;
    }
  }
  
  updateNeuralState(event, data) {
    // Update neural network based on events
    this.neuralNetwork.memory.push({ event, data, timestamp: Date.now() });
    
    // Keep memory limited
    if (this.neuralNetwork.memory.length > 100) {
      this.neuralNetwork.memory.shift();
    }
    
    // Process through network
    this.processNeuralNetwork();
  }
  
  processNeuralNetwork() {
    // Simplified neural processing
    const input = new Float32Array(this.config.neuralNetworkSize);
    
    // Encode current state
    input[0] = this.state.consciousness;
    input[1] = this.state.energy;
    input[2] = this.state.complexity;
    input[3] = this.samples.size / this.config.maxSamples;
    
    // Add environmental factors
    if (this.state.environmentalProfile) {
      input[4] = this.state.environmentalProfile.noise;
      input[5] = this.state.environmentalProfile.rhythm;
      input[6] = this.state.environmentalProfile.tone;
      input[7] = this.state.environmentalProfile.energy;
    }
    
    // Forward pass
    for (let i = 0; i < this.neuralNetwork.activations.length; i++) {
      let sum = this.neuralNetwork.biases[i];
      for (let j = 0; j < input.length; j++) {
        sum += input[j] * this.neuralNetwork.weights[i * input.length + j];
      }
      this.neuralNetwork.activations[i] = Math.tanh(sum);
    }
    
    // Make decisions based on activations
    this.makeNeuralDecisions();
  }
  
  makeNeuralDecisions() {
    const activations = this.neuralNetwork.activations;
    
    // Threshold for decision making
    const threshold = 0.7;
    
    if (activations[0] > threshold) {
      // Trigger automatic sample playback
      const randomSlot = Math.floor(Math.random() * this.samples.size);
      if (this.samples.has(randomSlot)) {
        this.playSample(randomSlot);
      }
    }
    
    if (activations[1] > threshold) {
      // Apply effect
      this.cycleEffects();
    }
    
    if (activations[2] > threshold) {
      // Change mix position
      const x = (activations[3] - 0.5) * 2;
      const y = (activations[4] - 0.5) * 2;
      this.state.mixPosition = { x, y };
      this.updateMixParameters();
    }
  }
  
  learnFromSample(analysis) {
    // Update neural network based on new sample
    const learningRate = 0.01;
    
    // Adjust weights based on sample characteristics
    for (let i = 0; i < this.neuralNetwork.weights.length; i++) {
      const adjustment = (Math.random() - 0.5) * learningRate * analysis.energy;
      this.neuralNetwork.weights[i] += adjustment;
      
      // Keep weights bounded
      this.neuralNetwork.weights[i] = Math.max(-1, Math.min(1, this.neuralNetwork.weights[i]));
    }
  }
  
  startVisualization() {
    const visualize = () => {
      if (!this.state.isAwake) return;
      
      this.drawEnvironmentalWaveform();
      this.updateConsciousnessDisplay();
      this.animateNeuralMatrix();
      
      requestAnimationFrame(visualize);
    };
    
    requestAnimationFrame(visualize);
    
    // Performance monitoring
    this.startPerformanceMonitor();
  }
  
  drawEnvironmentalWaveform() {
    if (!this.analyser) return;
    
    const ctx = this.envCanvas;
    const width = this.ui.environmentalCanvas.width;
    const height = this.ui.environmentalCanvas.height;
    
    const timeData = new Uint8Array(this.analyser.frequencyBinCount);
    this.analyser.getByteTimeDomainData(timeData);
    
    // Clear with fade
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw waveform
    ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + this.state.consciousness * 0.7})`;
    ctx.lineWidth = 2;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00ffff';
    
    ctx.beginPath();
    const sliceWidth = width / timeData.length * 2;
    let x = 0;
    
    for (let i = 0; i < timeData.length; i++) {
      const v = timeData[i] / 128.0;
      const y = v * height / 2;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
      if (x > width) break;
    }
    
    ctx.stroke();
    ctx.shadowBlur = 0;
  }
  
  updateConsciousnessDisplay() {
    const level = this.state.consciousness * 100;
    this.ui.consciousnessLevel.style.width = level + '%';
  }
  
  animateNeuralMatrix() {
    const pads = this.ui.neuralMatrix.querySelectorAll('.neural-pad');
    
    // Create wave pattern based on consciousness
    const time = Date.now() * 0.001;
    
    pads.forEach((pad, i) => {
      const row = Math.floor(i / 8);
      const col = i % 8;
      
      const wave = Math.sin(col * 0.5 + time) * Math.cos(row * 0.5 + time);
      const activate = Math.random() < this.state.consciousness * 0.1 * Math.abs(wave);
      
      if (activate && !pad.classList.contains('touched')) {
        pad.classList.add('active');
        setTimeout(() => pad.classList.remove('active'), 200);
      }
    });
  }
  
  startConsciousnessEvolution() {
    setInterval(() => {
      if (!this.state.isAwake) return;
      
      // Evolve consciousness based on activity
      const activityLevel = this.samples.size / this.config.maxSamples;
      const interactionLevel = this.neuralMemory.length / 100;
      
      const growth = (activityLevel + interactionLevel) * this.config.consciousnessGrowthRate;
      
      this.state.consciousness = Math.min(1, this.state.consciousness + growth);
      
      // Evolve complexity
      this.state.complexity = this.state.complexity * 0.99 + Math.random() * 0.01;
      
    }, 1000);
  }
  
  startPerformanceMonitor() {
    let lastTime = performance.now();
    let frames = 0;
    
    const monitor = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      frames++;
      
      if (delta >= 1000) {
        const fps = frames * 1000 / delta;
        const cpu = Math.min(100, (1000 / fps) * 6);
        
        this.ui.metrics.fps.textContent = Math.round(fps);
        this.ui.metrics.cpu.textContent = Math.round(cpu);
        
        frames = 0;
        lastTime = now;
      }
      
      requestAnimationFrame(monitor);
    };
    
    requestAnimationFrame(monitor);
  }
  
  // Effect methods
  increaseEnergy() {
    this.state.energy = Math.min(1, this.state.energy + 0.2);
    this.masterGain.gain.setTargetAtTime(0.8 + this.state.energy * 0.2, this.audioContext.currentTime, 0.1);
  }
  
  decreaseEnergy() {
    this.state.energy = Math.max(0, this.state.energy - 0.2);
    this.masterGain.gain.setTargetAtTime(0.8 + this.state.energy * 0.2, this.audioContext.currentTime, 0.1);
  }
  
  previousEffect() {
    this.cycleEffects();
  }
  
  nextEffect() {
    this.cycleEffects();
  }
  
  applyFilter(type) {
    this.effects.filter.type = type;
    this.showNeuralDecision(`FILTER: ${type.toUpperCase()}`);
  }
  
  triggerBeat() {
    // Create kick drum sound
    const osc = this.audioContext.createOscillator();
    const gain = this.audioContext.createGain();
    
    osc.frequency.setValueAtTime(150, this.audioContext.currentTime);
    osc.frequency.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
    
    gain.gain.setValueAtTime(1, this.audioContext.currentTime);
    gain.gain.exponentialRampToValueAtTime(0.01, this.audioContext.currentTime + 0.5);
    
    osc.connect(gain);
    gain.connect(this.masterGain);
    
    osc.start();
    osc.stop(this.audioContext.currentTime + 0.5);
  }
  
  // UI Helper methods
  showNeuralDecision(text) {
    this.ui.decisionText.textContent = text;
    this.ui.neuralDecision.classList.add('visible');
    
    setTimeout(() => {
      this.ui.neuralDecision.classList.remove('visible');
    }, 2000);
  }
  
  createTouchRipple(touch) {
    const ripple = document.createElement('div');
    ripple.className = 'touch-ripple';
    ripple.style.left = touch.clientX + 'px';
    ripple.style.top = touch.clientY + 'px';
    
    document.body.appendChild(ripple);
    
    setTimeout(() => {
      ripple.remove();
    }, 600);
  }
  
  hapticFeedback(type = 'light') {
    if (!window.navigator.vibrate) return;
    
    switch(type) {
      case 'light':
        navigator.vibrate(10);
        break;
      case 'medium':
        navigator.vibrate(20);
        break;
      case 'heavy':
        navigator.vibrate([30, 10, 30]);
        break;
      case 'selection':
        navigator.vibrate(5);
        break;
    }
  }
}

// Initialize the mobile AI DJ system
const neuromancer = new NeuromancerMobile();

console.log('🌌 NEUROMANCER MOBILE READY');
console.log('📱 Touch AWAKEN to begin');
console.log('🎙️ Hold sample orbs to record from environment');
console.log('👆 Tap to play samples');
console.log('👐 Use gestures in the control zone for effects');
console.log('🌀 Drag the mix sphere for real-time control');
</script>
</body>
</html>
