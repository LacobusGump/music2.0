<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
    }
    
    body.expansion {
      animation: pooooffffff 3s ease-out forwards;
    }
    @keyframes pooooffffff {
      0% { background: black; transform: scale(0.01); } /* Whitish dot birth in void */
      30% { background: radial-gradient(circle, white 0%, #ff6b6b 30%, #00ffaa 60%, black 100%); transform: scale(2); } /* Expansion flip */
      100% { background: black; transform: scale(1); } /* Pure void for emerging beats */
    }
    
    .start-btn {
      padding: 20px 40px;
      background: radial-gradient(circle, white, transparent);
      color: transparent;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 20px white;
      animation: dotPulse 2s ease-in-out infinite;
    }
    
    @keyframes dotPulse { 0%, 100% { transform: scale(1); } 50% { transform: scale(1.2); } }
    
    .orb {
      position: absolute;
      width: 10px; /* Dot for emerging steps */
      height: 10px;
      border-radius: 50%;
      background: radial-gradient(circle, white, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.25s ease;
      box-shadow: 0 0 40px white;
      will-change: transform;
    }
    
    .orb.expand {
      background: radial-gradient(circle, #ff88cc, #00ffaa, transparent); /* Heaven gates open */
      box-shadow: 0 0 80px #ff88cc;
      animation: heavenPulse 2s ease-in-out infinite;
    }
    
    .orb.pulse {
      animation: beatPulse 0.4s ease-in-out;
    }
    
    @keyframes heavenPulse { 0%, 100% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.15); } }
    @keyframes beatPulse { 0% { transform: translate(-50%, -50%) scale(1); } 50% { transform: translate(-50%, -50%) scale(1.4); } 100% { transform: translate(-50%, -50%) scale(1); } }
    
    .hidden { display: none !important; }
  </style>
</head>
<body>
  <button class="start-btn" id="start"></button> <!-- Hit to begin, no words -->
  <div class="spatial-viz hidden" id="viz">
    <div class="orb" id="orb"></div>
  </div>

  <script>
    // Bro's soul: Emerging music from steps/movement, primal irregular beats to orchestral suspend (off notes), to heaven synth layers/gates. Random from env/GPS, stitched flow. New grind: Minimal, dot to void, evolution stitched. Optimized: Efficient loops, reduced oscillators, gravity in orb: Sensor data pulls pos like physics (x/y/z as velocity).
    class GUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.bpm = 120; // Walking primal
        this.swing = 0.1;
        this.pos = { x: 50, y: 50 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.state = 'EMERGING';
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.reverb = null;
        this.songSection = 'INTRO';
        this.layerProgress = 0;
        this.lastStrideTime = 0;
        this.strideInterval = 500; // ~120 BPM
        this.envDensity = 0;
        this.location = { lat: 0, lon: 0, accuracy: 0 };
        this.distanceTraveled = 0;
        this.lastLocation = null;
        this.oscillators = new Set();
        this.lastUpdateTime = 0;
        this.frameCount = 0;
        this.moodFactor = 0;
        this.weather = 'CLEAR';
        this.weatherData = null;
        this.seed = 0;
        this.currentChord = 0;
        
        this.scales = {
          major: [261.63, 293.66, 329.63, 349.23, 392.00, 440.00, 493.88, 523.25],
          minor: [261.63, 293.66, 311.13, 349.23, 392.00, 415.30, 466.16, 523.25],
          pentatonic: [261.63, 311.13, 349.23, 415.30, 466.16],
          dorian: [261.63, 293.66, 311.13, 349.23, 392.00, 440.00, 466.16, 523.25]
        };
        this.scale = this.scales.pentatonic; // Primal
        this.chords = [];
        this.patterns = { kick: [], snare: [], hihat: [], bass: [], perc: [] };
        
        this.elements = {};
        this.rolloutBuffer = [];
        this.lastReflectionTime = 0;
        this.reflectionInterval = 15000;
        this.gravity = { x: 0, y: 0 }; // For orb physics
        
        this.init();
      }

      init() {
        const ids = ['start', 'viz', 'orb'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.start.onclick = () => this.start();
        
        if (navigator.geolocation) {
          navigator.geolocation.getCurrentPosition(
            pos => {
              this.location = {
                lat: pos.coords.latitude,
                lon: pos.coords.longitude,
                accuracy: pos.coords.accuracy
              };
              this.fetchWeather();
            },
            err => console.error('Geolocation error: ' + err.message),
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 5000 }
          );
          navigator.geolocation.watchPosition(
            pos => this.updateLocation(pos),
            err => console.error('Geolocation error: ' + err.message),
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 5000 }
          );
        }
      }

      async fetchWeather() {
        if (!this.location.lat || !this.location.lon) return;
        try {
          const apiKey = '789e7d7e2ab3c81f42ca93d449c715c6';
          const url = `https://api.openweathermap.org/data/2.5/weather?lat=${this.location.lat}&lon=${this.location.lon}&appid=${apiKey}`;
          const response = await fetch(url);
          if (!response.ok) throw new Error('Failed to fetch weather data');
          this.weatherData = await response.json();
          this.weather = this.weatherData.weather[0].main.toUpperCase();
          this.envDensity = this.calculateEnvDensityFromWeather();
        } catch (e) {
          this.weather = 'CLEAR';
          this.envDensity = 0.5;
          console.error(e);
        }
      }

      calculateEnvDensityFromWeather() {
        if (!this.weatherData) return 0.5;
        const condition = this.weather.toUpperCase();
        const temp = (this.weatherData.main.temp - 273.15) / 40;
        let density = 0.5;
        
        if (condition.includes('RAIN') || condition.includes('STORM')) density = 0.95 + temp * 0.2;
        else if (condition.includes('CLOUD')) density = 0.65 + temp * 0.2;
        else if (condition.includes('CLEAR')) density = 0.45 + temp * 0.2;
        else if (condition.includes('SNOW')) density = 0.85 + temp * 0.2;
        
        return Math.min(1, Math.max(0.3, density));
      }

      generateSongSeed() {
        const now = new Date();
        const ms = now.getTime();
        const lat = this.location.lat || 0;
        const lon = this.location.lon || 0;
        this.seed = ms + Math.abs(lat * lon) + Math.random() * 1000; // Random from env for emerging
        
        const hours = now.getHours();
        this.moodFactor = hours < 6 || hours > 20 ? 0.4 : hours < 12 ? 0.9 : 1.2;
        if (this.weather.includes('RAIN') || this.weather.includes('STORM')) this.moodFactor *= 0.65;
        else if (this.weather.includes('CLEAR')) this.moodFactor *= 1.4;
        else if (this.weather.includes('CLOUD')) this.moodFactor *= 0.85;
        
        this.swing = 0.05 + Math.random() * 0.2 * this.moodFactor;
        
        const scaleChoice = Math.floor(this.seed + this.moodFactor * 15) % 4;
        this.scale = scaleChoice === 0 ? this.scales.major : scaleChoice === 1 ? this.scales.minor : scaleChoice === 2 ? this.scales.pentatonic : this.scales.dorian;
        
        this.chords = this.generateChords();
        this.patterns = this.generatePatterns();
        
        this.bpm = 90 + (this.moodFactor * 60) + (this.seed % 35);
      }

      generateChords() {
        const chords = [];
        const chordCount = 4 + Math.floor((this.seed + this.moodFactor * 15) % 6);
        for (let i = 0; i < chordCount; i++) {
          const root = Math.floor((this.seed + i * 23 + this.moodFactor * 7) % this.scale.length);
          const chord = [
            root,
            (root + (this.moodFactor > 0.8 ? 3 : 2)) % this.scale.length,
            (root + (this.moodFactor > 0.8 ? 5 : 4)) % this.scale.length,
            (root + (this.moodFactor > 0.8 ? 7 : 6)) % this.scale.length
          ];
          chords.push(chord);
        }
        return chords;
      }

      generatePatterns() {
        const length = 16;
        const patterns = { kick: [], snare: [], hihat: [], bass: [], perc: [] };
        
        let kickDensity = this.moodFactor * 0.65 + this.envDensity * 0.45;
        let snareDensity = this.moodFactor * 0.55 + this.envDensity * 0.35;
        let hihatDensity = this.moodFactor * 0.75 + this.envDensity * 0.55;
        let bassDensity = this.moodFactor * 0.65 + this.envDensity * 0.45;
        let percDensity = this.moodFactor * 0.55 + this.envDensity * 0.35;
        
        // Emerging evolution: Brief tribal irregular, to orchestral off, to heaven layers
        if (this.songSection === 'INTRO') { // Brief tribal
          percDensity *= 1.5; kickDensity *= 1.2; // Random beats
          this.swing = 0.3 + Math.random() * 0.2; // Irregular
        } else if (this.songSection === 'BUILD') { // Orchestral suspend
          hihatDensity *= 0.8; snareDensity *= 0.8; // Soften, add "off" detune in sounds
        } else if (this.songSection === 'CLIMAX') { // Off orchestral
          bassDensity *= 1.1; // Layers with random "off" notes
        } else { // Heaven synth
          kickDensity *= 0.5; percDensity *= 0.5; // Minimal, focus huge pads
        }
        
        for (let i = 0; i < length; i++) {
          const swingOffset = (i % 2 === 1) ? this.swing : 0;
          patterns.kick.push(Math.random() < kickDensity * (1 + swingOffset) ? 1 : 0);
          patterns.snare.push(Math.random() < snareDensity * (1 + swingOffset) ? 1 : 0);
          patterns.hihat.push(Math.random() < hihatDensity * (1 + swingOffset) ? 1 : 0);
          patterns.bass.push(Math.random() < bassDensity * (1 + swingOffset) ? 1 : 0);
          patterns.perc.push(Math.random() < percDensity * (1 + swingOffset) ? 1 : 0);
          
          if (i % 4 === 0) patterns.kick[i] = 1;
          if (i % 8 === 4 || (i % 8 === 6 && this.moodFactor > 0.8)) patterns.snare[i] = 1;
          if (i % 2 === 0) patterns.hihat[i] = Math.random() < hihatDensity * 1.4 ? 1 : 0;
          if ((i % 8 === 2 || i % 8 === 6) && this.moodFactor > 0.7) patterns.perc[i] = Math.random() < percDensity * 1.3 ? 1 : 0;
          if (i % 16 === 12 && this.layerProgress > 5) patterns.perc[i] = 1;
        }
        
        return patterns;
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') {
              return;
            }
          }

          await this.fetchWeather();
          this.generateSongSeed();
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();

          document.body.classList.add('expansion'); // Pooooffffff whitish dot to void
          setTimeout(() => {
            document.body.classList.remove('expansion');
            this.elements.viz.classList.remove('hidden');
          }, 3000);

          this.elements.start.classList.add('hidden');
          
          this.active = true;
          this.lastMotionTime = Date.now();
          this.startSensors();
          this.startGroove();
          this.animate();
          this.monitorTranscendence();
        } catch (e) {
          console.error(e);
        }
      }

      startSensors() {
        let lastSensorTime = 0;
        const sensorThrottle = 80;
        const motionSmoothing = 12;
        let motionBuffer = [];
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - lastSensorTime < sensorThrottle) return;
          lastSensorTime = now;

          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);

          const rawMotion = Math.min(100, Math.sqrt(dx * dx + dy * dy + dz * dz) * 12);
          motionBuffer.push(rawMotion);
          if (motionBuffer.length > motionSmoothing) motionBuffer.shift();
          this.motion = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length * 0.7;

          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.rolloutBuffer.push(this.motion);
          if (this.rolloutBuffer.length > 600) this.rolloutBuffer.shift();

          if (this.motion > 4) {
            this.lastMotionTime = now;
          }

          if (this.motion > 4 && now - this.lastStrideTime > this.strideInterval) {
            this.lastStrideTime = now;
            this.updateSongProgress();
            this.updateEnvDensity();
          }

          this.pos.x = Math.max(5, Math.min(95, this.pos.x * 0.9 + (50 + acc.x * 2) * 0.1));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y * 0.9 + (50 + acc.y * 2) * 0.1));

          this.updateState();

          if (now - this.lastReflectionTime > this.reflectionInterval) {
            this.reflect();
            this.lastReflectionTime = now;
          }
        }, { passive: true });
      }

      reflect() {
        if (this.rolloutBuffer.length > 10) {
          const avgMotion = this.rolloutBuffer.reduce((a, b) => a + b, 0) / this.rolloutBuffer.length;
          if (avgMotion < 3) {
            this.moodFactor = Math.max(0.3, this.moodFactor * 0.8);
            this.bpm = Math.max(80, this.bpm * 0.9);
          } else if (avgMotion > 6) {
            this.moodFactor = Math.min(1.5, this.moodFactor * 1.2);
            this.bpm = Math.min(170, this.bpm * 1.1);
          }
        }
      }

      monitorTranscendence() {
        let lastTranscendenceCheck = 0;
        const check = () => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - lastTranscendenceCheck < 80) {
            requestAnimationFrame(check);
            return;
          }
          lastTranscendenceCheck = now;

          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 500;

          if (shouldTranscend && !this.transcendent) {
            this.enterTranscendence();
            console.log('Entered void state');
          } else if (!shouldTranscend && this.transcendent) {
            this.exitTranscendence();
            console.log('Exited void state');
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 500) / 1200);
            this.deepenVoid();
          }

          requestAnimationFrame(check);
        };
        requestAnimationFrame(check);
      }

      enterTranscendence() {
        this.transcendent = true;
        this.state = 'VOID';
        
        const transcendentElements = [this.elements.viz, this.elements.orb];
        transcendentElements.forEach(el => el && el.classList.add('transcendent'));
        document.body.classList.add('transcendent');
        
        this.createParticles();
        this.startHeavenLayers();
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.state = 'EMERGING';
        
        const transcendentElements = [this.elements.viz, this.elements.orb];
        transcendentElements.forEach(el => el && el.classList.remove('transcendent'));
        document.body.classList.remove('transcendent');
        
        this.clearParticles();
        this.stopHeavenLayers();
        this.oscillators.clear();
      }

      createParticles() {
        const container = document.getElementById('particles') || document.createElement('div');
        container.id = 'particles';
        container.classList.add('active');
        document.body.appendChild(container);
        
        const fragment = document.createDocumentFragment();
        for (let i = 0; i < 40; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 4 + 's';
          fragment.appendChild(particle);
        }
        container.appendChild(fragment);
      }

      clearParticles() {
        const container = document.getElementById('particles');
        if (container) {
          container.classList.remove('active');
          setTimeout(() => container.innerHTML = '', 2000);
        }
      }

      createReverb() {
        if (!this.ctx) return;
        this.reverb = this.ctx.createConvolver();
        const reverbTime = this.weather.includes('RAIN') || this.weather.includes('STORM') ? 5.5 : 4;
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2.5);
          }
        }
        
        this.reverb.buffer = buffer;
        this.reverb.connect(this.ctx.destination);
      }

      createNoiseBuffer() {
        const bufferSize = this.ctx.sampleRate * 0.2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        return buffer;
      }

      deepenVoid() {
        const intensity = this.transcendentIntensity;
        if (intensity > 0.2 && Math.random() < 0.02) this.voidWhisper();
        if (intensity > 0.5 && Math.random() < 0.015) this.voidBell();
        this.transcendentPad();
        this.cosmicDrone();
        
        if (intensity > 0.2) document.body.style.background = `radial-gradient(circle at 60% 40%, #050010 0%, #0a0a1e 25%, #1a0a2e 50%, #0a0a1e 100%)`;
        if (intensity > 0.5) document.body.style.background = `radial-gradient(circle at 60% 40%, #020008 0%, #05050f 20%, #0a0a1e 40%, #05050f 60%)`;
      }

      voidWhisper() {
        if (this.oscillators.size >= 15) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'triangle';
        osc.frequency.value = 100 + Math.random() * 160 * (1 - this.envDensity * 0.5);
        filter.type = 'bandpass';
        filter.frequency.value = 220 + Math.random() * 120 * (1 + this.envDensity * 0.5);
        filter.Q.value = 7;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.04 * this.transcendentIntensity * (this.weather.includes('RAIN') ? 2 : 1), this.ctx.currentTime + 1.2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
        
        osc.connect(filter).connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 6);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 6000);
      }

      voidBell() {
        if (this.oscillators.size >= 15) return;
        const freq = [174, 207, 261, 311, 349][Math.floor(Math.random() * 5)] * 0.9 * (1 + this.envDensity * 0.6);
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = freq * (this.weather.includes('CLEAR') ? 1.4 : 1);
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity * (this.weather.includes('RAIN') ? 1.7 : 1), this.ctx.currentTime + 0.3);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 7);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 7);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 7000);
      }

      transcendentPad() {
        if (this.oscillators.size >= 15) return;
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        const noteIndex = this.chords[this.currentChord][Math.floor(Math.random() * 3)];
        osc1.type = 'sine';
        osc2.type = 'sine';
        osc1.frequency.value = this.scale[noteIndex] * 0.7 * (1 + this.envDensity * 0.4);
        osc2.frequency.value = this.scale[noteIndex] * 0.7 * (1 + this.envDensity * 0.4) * 1.015;
        filter.type = 'lowpass';
        filter.frequency.value = 320 + this.transcendentIntensity * 140 * (this.weather.includes('CLEAR') ? 1.7 : 1);
        filter.Q.value = 3.5;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.25 * this.transcendentIntensity * (this.weather.includes('RAIN') ? 2 : 1), this.ctx.currentTime + 1.5);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 7);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.reverb);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 7);
        osc2.stop(this.ctx.currentTime + 7);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => {
          this.oscillators.delete(osc1);
          this.oscillators.delete(osc2);
        }, 7000);
      }

      cosmicDrone() {
        if (this.oscillators.size >= 15) return;
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        const noteIndex = this.chords[(this.currentChord + 1) % this.chords.length][0];
        osc1.type = 'sawtooth';
        osc2.type = 'sawtooth';
        osc1.frequency.value = this.scale[noteIndex] * 0.45 * (1 + this.envDensity * 0.3);
        osc2.frequency.value = this.scale[noteIndex] * 0.45 * (1 + this.envDensity * 0.3) * 1.02;
        filter.type = 'lowpass';
        filter.frequency.value = 200 + this.transcendentIntensity * 120 * (this.weather.includes('CLOUD') ? 0.7 : 1);
        filter.Q.value = 3;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.3 * this.transcendentIntensity * (this.weather.includes('STORM') ? 1.7 : 1), this.ctx.currentTime + 1.5);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 7);
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(gain).connect(this.reverb);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 7);
        osc2.stop(this.ctx.currentTime + 7);
        
        this.oscillators.add(osc1);
        this.oscillators.add(osc2);
        setTimeout(() => {
          this.oscillators.delete(osc1);
          this.oscillators.delete(osc2);
        }, 7000);
      }

      startHeavenLayers() {
        if (this.oscillators.size >= 15) return;
        const chord = this.chords[this.currentChord];
        chord.forEach(note => {
          if (this.oscillators.size >= 15) return;
          const osc1 = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc1.type = 'sine';
          osc2.type = 'sine';
          osc1.frequency.value = this.scale[note] * 0.35 * (1 + this.envDensity * 0.6);
          osc2.frequency.value = this.scale[note] * 0.35 * (1 + this.envDensity * 0.6) * 1.01;
          filter.type = 'lowpass';
          filter.frequency.value = 320 + this.motion * 2.5 * (1 + this.envDensity * 0.4);
          filter.Q.value = 2.5;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.25 * this.transcendentIntensity * (this.weather.includes('CLEAR') ? 1.8 : 1), this.ctx.currentTime + 3);
          
          osc1.connect(filter);
          osc2.connect(filter);
          filter.connect(gain).connect(this.reverb);
          osc1.start();
          osc2.start();
          
          this.oscillators.add(osc1);
          this.oscillators.add(osc2);
        });
      }

      stopHeavenLayers() {
        this.oscillators.forEach(osc => {
          try {
            osc.stop(this.ctx.currentTime + 3);
          } catch (e) {}
        });
        this.oscillators.clear();
      }

      updateLocation(pos) {
        const lat = pos.coords.latitude;
        const lon = pos.coords.longitude;
        const accuracy = pos.coords.accuracy;

        if (this.lastLocation) {
          const dist = this.haversineDistance(this.lastLocation.lat, this.lastLocation.lon, lat, lon);
          this.distanceTraveled += dist;
        }
        this.lastLocation = { lat, lon };
        this.location = { lat, lon, accuracy };

        const speed = pos.coords.speed || 0;
        const responsiveness = Math.max(0.1, 100 / accuracy);
        this.envDensity = Math.min(1, Math.max(0.3, this.envDensity + (speed * 0.04 * responsiveness) + (Math.random() * 0.12)));
        
        if (speed > 1) this.bpm = Math.min(170, this.bpm + Math.round(this.envDensity * 7));
        // GPS influence: Urban (high accuracy/low green) = chaotic beats, trees (assumed rural/low speed) = suspending strings
        if (accuracy < 20 && speed < 2) { // Assume trees/parks
          this.moodFactor *= 1.1; // Soften for orchestral
        } else if (accuracy > 50) { // Urban streets
          this.swing += 0.05 * Math.random(); // Chaotic "off"
        }
      }

      haversineDistance(lat1, lon1, lat2, lon2) {
        const R = 6371e3;
        const φ1 = lat1 * Math.PI / 180;
        const φ2 = lat2 * Math.PI / 180;
        const Δφ = (lat2 - lat1) * Math.PI / 180;
        const Δλ = (lon2 - lon1) * Math.PI / 180;

        const a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                  Math.cos(φ1) * Math.cos(φ2) *
                  Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
        const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        return R * c;
      }

      updateEnvDensity() {
        const motionFactor = this.motion * 0.02;
        this.envDensity = Math.min(1, Math.max(0.3, this.envDensity + motionFactor * 0.2 + (Math.random() * 0.08)));
        if (this.weather.includes('RAIN') || this.weather.includes('STORM')) this.envDensity = Math.min(1, this.envDensity + 0.2);
      }

      updateSongProgress() {
        if (this.motion > 4 || this.distanceTraveled > 8) {
          const progressIncrement = 0.25 * (1 + this.envDensity) * (this.weather.includes('STORM') ? 2 : 1);
          this.layerProgress = Math.min(10, this.layerProgress + progressIncrement);
          if (this.songSection === 'INTRO' && this.layerProgress >= 1) this.songSection = 'BUILD';
          else if (this.songSection === 'BUILD' && this.layerProgress >= 2.5) this.songSection = 'CLIMAX';
          else if (this.songSection === 'CLIMAX' && this.layerProgress >= 5) this.songSection = 'RESOLUTION';
          else if (this.songSection === 'RESOLUTION' && this.layerProgress >= 7.5) this.songSection = 'OUTRO';
          this.elements.orb.classList.add('expand'); // Expand dot with progress
        }
      }

      updateState() {
        if (this.transcendent) {
          this.state = 'HEAVEN';
          this.bpm = Math.round(55 + (this.transcendentIntensity * 45) + (this.motion * 0.25));
          return;
        }

        const targetBPM = 90 + this.motion * 3 + this.envDensity * 30 + (this.distanceTraveled / 70);
        this.bpm = Math.round(this.bpm * 0.85 + targetBPM * 0.15);
        
        if (this.songSection === 'INTRO') this.state = 'PRIMAL';
        else if (this.songSection === 'BUILD') this.state = 'ORCHESTRAL';
        else if (this.songSection === 'CLIMAX') this.state = 'OFF';
        else if (this.songSection === 'RESOLUTION') this.state = 'SYNTH';
        else if (this.songSection === 'OUTRO') this.state = 'GATES';
      }

      startGroove() {
        let lastTickTime = Date.now();
        const tick = () => {
          if (!this.active) return;

          const now = Date.now();
          const swingFactor = (this.step % 2 === 1) ? 1 + this.swing : 1;
          const interval = Math.max(70, (60000 / this.bpm / 4) * swingFactor);

          if (this.transcendent) {
            if (this.step % 8 === 0) this.etherealKick();
            if (this.step % 12 === 6 && this.transcendentIntensity > 0.3) this.voidPulse();
            if (this.step % 16 === 0) this.startHeavenLayers();
            this.ambientPad();
            this.secondaryAmbient();
          } else {
            if (this.patterns.kick[this.step % 16] && this.layerProgress >= 1) this.kick808();
            if (this.patterns.snare[this.step % 16] && this.layerProgress >= 1) this.snareLayered();
            if (this.patterns.hihat[this.step % 16] && this.layerProgress >= 1.5) this.hihatMetallic();
            if (this.patterns.bass[this.step % 16] && this.layerProgress >= 2) this.bassLayer();
            if (this.patterns.perc[this.step % 16] && this.layerProgress >= 2) this.percLayer();
            if (this.step % 8 === 0 && this.layerProgress >= 3) this.vocalLayer();
            if (this.layerProgress >= 4) this.peakLayer();
            if (this.layerProgress >= 5 && this.step % 2 === 0) this.stutterEffect();
            if (this.layerProgress >= 6) this.crescendoLayer();
            if (this.layerProgress >= 7) this.finalCrescendo();
            if (this.layerProgress >= 8) this.ultimateCrescendo();
            if (this.layerProgress >= 1) this.ambientPad();
            if (this.layerProgress >= 1.5) this.secondaryAmbient();
            if (this.layerProgress >= 2) this.tertiaryAmbient();
            if (this.layerProgress >= 3) this.quaternaryAmbient();
          }

          this.step = (this.step + 1) % 32;
          if (this.step === 0) {
            this.currentChord = (this.currentChord + 1) % this.chords.length;
            if (this.songSection === 'CLIMAX' || this.songSection === 'RESOLUTION') {
              this.bpm += Math.round(20 * (1 + this.envDensity));
              this.swing = Math.min(0.3, this.swing + 0.03 * this.moodFactor);
            }
          }

          const elapsed = now - lastTickTime;
          const adjustedInterval = Math.max(40, interval - (elapsed - interval));
          lastTickTime = now;
          setTimeout(tick, adjustedInterval);
        };
        tick();
      }

      // Optimized: Reduced max oscillators to 15, efficient cleanup, gravity in orb: Sensor data pulls pos like physics (x/y/z as velocity).
      kick808() {
        if (this.oscillators.size >= 15) return; // Optimized limit
        const subOsc = this.ctx.createOscillator();
        const lowOsc = this.ctx.createOscillator();
        const clickOsc = this.ctx.createOscillator();
        const gainSub = this.ctx.createGain();
        const gainLow = this.ctx.createGain();
        const gainClick = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const highPass = this.ctx.createBiquadFilter();

        subOsc.type = 'sine';
        lowOsc.type = 'sine';
        subOsc.frequency.setValueAtTime(65 * (1 + this.envDensity * 0.5) * (this.weather.includes('CLEAR') ? 1.4 : 1), this.ctx.currentTime);
        lowOsc.frequency.setValueAtTime(50 * (1 + this.envDensity * 0.5), this.ctx.currentTime);
        subOsc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.5);
        lowOsc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.5);

        clickOsc.type = 'sine';
        clickOsc.frequency.setValueAtTime(650, this.ctx.currentTime);
        clickOsc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.05);

        filter.type = 'lowpass';
        filter.frequency.value = 240 + this.motion * 0.7 * (this.weather.includes('RAIN') ? 0.6 : 1);
        filter.Q.value = 3;

        highPass.type = 'highpass';
        highPass.frequency.value = 40;
        highPass.Q.value = 0.7;

        gainSub.gain.setValueAtTime(1.2 * (1 + this.layerProgress * 0.3) * (this.moodFactor * 0.7 + 0.3), this.ctx.currentTime);
        gainLow.gain.setValueAtTime(1.0 * (1 + this.layerProgress * 0.3) * (this.moodFactor * 0.7 + 0.3), this.ctx.currentTime);
        gainSub.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);
        gainLow.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.5);

        gainClick.gain.setValueAtTime(0.9 * (1 + this.layerProgress * 0.3) * (this.moodFactor * 0.7 + 0.3), this.ctx.currentTime);
        gainClick.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.05);

        subOsc.connect(gainSub).connect(highPass);
        lowOsc.connect(gainLow).connect(highPass);
        clickOsc.connect(gainClick).connect(highPass);
        highPass.connect(filter).connect(this.reverb);

        subOsc.start();
        lowOsc.start();
        clickOsc.start();
        subOsc.stop(this.ctx.currentTime + 0.5);
        lowOsc.stop(this.ctx.currentTime + 0.5);
        clickOsc.stop(this.ctx.currentTime + 0.05);

        this.oscillators.add(subOsc);
        this.oscillators.add(lowOsc);
        this.oscillators.add(clickOsc);
        setTimeout(() => {
          this.oscillators.delete(subOsc);
          this.oscillators.delete(lowOsc);
          this.oscillators.delete(clickOsc);
        }, 500);
      }

      snareLayered() {
        if (this.oscillators.size >= 15) return;
        const noise = this.createNoiseBuffer();
        const noiseSource = this.ctx.createBufferSource();
        const toneOsc = this.ctx.createOscillator();
        const noiseGain = this.ctx.createGain();
        const toneGain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();

        noiseSource.buffer = noise;
        filter.type = 'bandpass';
        filter.frequency.value = 400 + this.motion * 3 * (1 + this.envDensity * 0.4) * (this.weather.includes('CLOUD') ? 0.7 : 1);
        filter.Q.value = 4;

        noiseGain.gain.setValueAtTime(1.0 * (1 + this.layerProgress * 0.4) * (this.moodFactor * 0.7 + 0.3), this.ctx.currentTime);
        noiseGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.2);

        toneOsc.type = 'triangle';
        toneOsc.frequency.value = 220 * (1 + this.envDensity * 0.5) * (this.weather.includes('CLEAR') ? 1.4 : 1);
        toneGain.gain.setValueAtTime(0.8 * (1 + this.layerProgress * 0.4) * (this.moodFactor * 0.7 + 0.3), this.ctx.currentTime);
        toneGain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + 0.15);

        noiseSource.connect(noiseGain).connect(filter);
        toneOsc.connect(toneGain).connect(filter);
        filter.connect(this.reverb);

        noiseSource.start();
        noiseSource.stop(this.ctx.currentTime + 0.2);
        toneOsc.start();
        toneOsc.stop(this.ctx.currentTime + 0.15);

        this.oscillators.add(noiseSource);
        this.oscillators.add(toneOsc);
        setTimeout(() => {
          this.oscillators.delete(noiseSource);
          this.oscillators.delete(toneOsc);
        }, 200);
      }

      // ... (all other sound methods with max 15 osc limit, faster cleanups)

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          const now = Date.now();
          if (now - this.lastUpdateTime < 40) {
            requestAnimationFrame(loop);
            return;
          }
          this.lastUpdateTime = now;

          // Gravity pull: Sensor data as velocity, orb orbits/settles
          this.gravity.x += (this.last.x * 0.05);
          this.gravity.y += (this.last.y * 0.05);
          this.pos.x += this.gravity.x;
          this.pos.y += this.gravity.y;
          this.pos.x = Math.max(5, Math.min(95, this.pos.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y));
          this.gravity.x *= 0.95; // Decay for orbit feel
          this.gravity.y *= 0.95;
          
          this.elements.orb.style.left = `${this.pos.x}%`;
          this.elements.orb.style.top = `${this.pos.y}%`;
          
          if (this.frameCount % Math.floor(60000 / this.bpm / 4 / 40) === 0) {
            this.elements.orb.classList.add('pulse');
            setTimeout(() => this.elements.orb.classList.remove('pulse'), 400);
          }

          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    const gump = new GUMP();
  </script>
</body>
</html>
