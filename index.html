<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP - The Emergence</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Georgia', serif;
        }
        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; gap: 30px;
            z-index: 100; cursor: pointer;
            background: #000;
        }
        #enter.off { display: none; }
        #enter h1 {
            font-size: 14px;
            font-weight: 300;
            letter-spacing: 8px;
            color: rgba(255,255,255,0.3);
        }
        #enter .circle {
            width: 100px; height: 100px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.08);
            display: flex; align-items: center; justify-content: center;
            transition: all 0.5s;
        }
        #enter:hover .circle { border-color: rgba(255,255,255,0.2); }
        #world {
            position: fixed; inset: 0;
            display: none;
            background: #000;
        }
        #world.on { display: block; }
        canvas { position: fixed; inset: 0; }

        #evolution-bar {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 3px;
            background: rgba(255,255,255,0.05);
            z-index: 50;
        }
        #evolution-fill {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg,
                rgba(255,255,255,0.1) 0%,
                rgba(255,255,255,0.4) 100%);
            transition: width 0.3s ease-out;
        }

        #era-name {
            position: fixed;
            bottom: 30px; left: 0; right: 0;
            text-align: center;
            font-size: 11px;
            letter-spacing: 6px;
            color: rgba(255,255,255,0.2);
            text-transform: uppercase;
            transition: all 1s;
            z-index: 50;
        }

        #status {
            position: fixed; top: 20px; left: 20px;
            font-size: 9px;
            color: rgba(255,255,255,0.15);
            letter-spacing: 1px;
            line-height: 1.8;
            font-family: monospace;
        }
    </style>
</head>
<body>

<div id="enter">
    <h1>THE EMERGENCE</h1>
    <div class="circle"></div>
</div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="evolution-bar"><div id="evolution-fill"></div></div>
    <div id="era-name">void</div>
    <div id="status"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// GUMP - THE EMERGENCE
// A journey through the history of music
// ═══════════════════════════════════════════════════════════════════════════
//
// ERAS:
//   0. VOID      - Silence, breath, the before
//   1. EMERGENCE - First tones emerge from nothing, ethereal drones
//   2. SYNTH     - 808, sub bass, a god rising from the ether
//   3. ORCHESTRA - Strings swell, brass arrives, full classical power
//   4. BLUES     - The soul emerges, 12-bar truth
//   5. JAZZ      - Complexity and freedom
//   6. ROCK      - Raw power and drive
//   7. MODERN    - Everything converges
//
// ═══════════════════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ═══════════════════════════════════════════════════════════════════════════
// ERAS - Each era is a complete musical world
// ═══════════════════════════════════════════════════════════════════════════

const ERAS = [
    {
        name: 'void',
        threshold: 0,           // Movement needed to unlock
        bpm: 0,
        description: 'Before sound'
    },
    {
        name: 'emergence',
        threshold: 30,          // Quick first transition
        bpm: 0,                 // No tempo, free time
        key: 0,
        scale: [0, 7, 12],      // Just octaves and fifths
        description: 'First light'
    },
    {
        name: 'synth',
        threshold: 120,
        bpm: 70,
        key: 0,
        scale: [0, 3, 5, 7, 10], // Minor pentatonic
        description: 'A god emerges'
    },
    {
        name: 'orchestra',
        threshold: 300,
        bpm: 60,
        key: 0,
        scale: [0, 2, 4, 5, 7, 9, 11], // Major scale
        description: 'The heavens open'
    },
    {
        name: 'blues',
        threshold: 550,
        bpm: 85,
        key: 5,                 // F
        scale: [0, 3, 5, 6, 7, 10], // Blues scale
        description: 'Soul speaks'
    },
    {
        name: 'jazz',
        threshold: 850,
        bpm: 120,
        key: 2,                 // D
        scale: [0, 2, 3, 5, 7, 9, 10, 11], // Bebop dominant
        description: 'Freedom and complexity'
    },
    {
        name: 'rock',
        threshold: 1200,
        bpm: 130,
        key: 7,                 // G
        scale: [0, 2, 4, 5, 7, 9, 11],
        description: 'Raw power'
    },
    {
        name: 'modern',
        threshold: 1600,
        bpm: 110,
        key: 0,
        scale: [0, 2, 3, 5, 7, 8, 10], // Harmonic minor
        description: 'All converges'
    }
];

// ═══════════════════════════════════════════════════════════════════════════
// GLOBAL STATE
// ═══════════════════════════════════════════════════════════════════════════

const world = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    tilt: { x: 0, y: 0 },     // Phone tilt for filter/key control
    energy: 0,
    totalMovement: 0,          // Cumulative - fills evolution bar
    breath: 0,
};

const music = {
    era: 0,
    eraProgress: 0,            // 0-1 progress to next era
    tick: 0,
    bar: 0,
    beat: 0,
    lastTransition: 0,
};

let ctx, masterGain, masterFilter, reverbGain, compressor;
let canvas, vc;
let audioReady = false;

// ═══════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════════════════

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master filter - controlled by tilt
    masterFilter = ctx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 2000;
    masterFilter.Q.value = 1;

    // Reverb
    const reverbBuffer = createReverb(4.0);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.5;

    // Compressor
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -12;
    compressor.ratio.value = 4;
    compressor.attack.value = 0.003;
    compressor.release.value = 0.15;

    // Master
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.8;

    // Routing
    masterFilter.connect(compressor);
    masterFilter.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);
    compressor.connect(masterGain);
    masterGain.connect(ctx.destination);

    // Initialize all era instruments
    initVoidEra();
    initEmergenceEra();
    initSynthEra();
    initOrchestraEra();
    initBluesEra();
    initJazzEra();
    initRockEra();
    initModernEra();

    audioReady = true;
    console.log('Audio ready');
}

function createReverb(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / ctx.sampleRate;
            data[i] = (Math.random() * 2 - 1) * Math.exp(-t / (duration * 0.4)) * 0.4;
        }
    }
    return buffer;
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 0: VOID - Deep presence, breathing darkness
// ═══════════════════════════════════════════════════════════════════════════

let voidDrone, voidDrone2, voidGain, voidFilter;

function initVoidEra() {
    // Deep sine drone - the primordial tone
    voidDrone = ctx.createOscillator();
    voidDrone.type = 'sine';
    voidDrone.frequency.value = 36; // Very low D

    // Second drone for thickness
    voidDrone2 = ctx.createOscillator();
    voidDrone2.type = 'sine';
    voidDrone2.frequency.value = 54; // A, a fifth above

    // Slow LFO to make it breathe
    const lfo = ctx.createOscillator();
    lfo.type = 'sine';
    lfo.frequency.value = 0.08; // Very slow
    const lfoGain = ctx.createGain();
    lfoGain.gain.value = 8;
    lfo.connect(lfoGain);
    lfoGain.connect(voidDrone.frequency);
    lfo.start();

    // Second LFO slightly different
    const lfo2 = ctx.createOscillator();
    lfo2.type = 'sine';
    lfo2.frequency.value = 0.05;
    const lfo2Gain = ctx.createGain();
    lfo2Gain.gain.value = 5;
    lfo2.connect(lfo2Gain);
    lfo2Gain.connect(voidDrone2.frequency);
    lfo2.start();

    voidFilter = ctx.createBiquadFilter();
    voidFilter.type = 'lowpass';
    voidFilter.frequency.value = 150;
    voidFilter.Q.value = 1;

    voidGain = ctx.createGain();
    voidGain.gain.value = 0;

    const drone2Gain = ctx.createGain();
    drone2Gain.gain.value = 0.4;

    voidDrone.connect(voidFilter);
    voidDrone2.connect(drone2Gain);
    drone2Gain.connect(voidFilter);
    voidFilter.connect(voidGain);
    voidGain.connect(masterFilter);

    voidDrone.start();
    voidDrone2.start();
}

function updateVoid() {
    if (!voidGain) return;
    const active = music.era === 0;
    const approaching = music.era === 1;

    let target = 0;
    if (active) {
        // Breathe with movement influence
        const breath = Math.sin(world.breath * 0.3) * 0.15;
        target = 0.35 + breath + world.energy * 0.2;
    } else if (approaching) {
        // Fade out slowly when we leave
        target = 0.2 * (1 - music.eraProgress);
    }

    voidGain.gain.setTargetAtTime(target, ctx.currentTime, 0.3);

    // Filter opens slightly with movement
    if (voidFilter && active) {
        voidFilter.frequency.setTargetAtTime(100 + world.energy * 150, ctx.currentTime, 0.2);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 1: EMERGENCE - First tones, ethereal drones
// ═══════════════════════════════════════════════════════════════════════════

let emergenceDrones = [], emergenceGain;

function initEmergenceEra() {
    emergenceGain = ctx.createGain();
    emergenceGain.gain.value = 0;

    // Create ethereal drone oscillators
    const frequencies = [55, 82.5, 110, 165]; // A1, E2, A2, E3

    frequencies.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;

        // Slow LFO for movement
        const lfo = ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.05 + i * 0.02;

        const lfoGain = ctx.createGain();
        lfoGain.gain.value = freq * 0.008; // Subtle pitch drift

        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);

        const gain = ctx.createGain();
        gain.gain.value = 0.15 - i * 0.02;

        osc.connect(gain);
        gain.connect(emergenceGain);

        osc.start();
        lfo.start();

        emergenceDrones.push({ osc, gain, lfo });
    });

    emergenceGain.connect(masterFilter);
}

function updateEmergence() {
    if (!emergenceGain) return;
    const active = music.era === 1;
    const fadingIn = music.era === 0 && music.eraProgress > 0.3; // Start earlier

    let target = 0;
    if (active) {
        target = 0.4 + world.energy * 0.3;
    } else if (fadingIn) {
        // Emergence tones creep in during void
        target = (music.eraProgress - 0.3) * 0.5;
    }

    emergenceGain.gain.setTargetAtTime(target, ctx.currentTime, 0.6);

    // Modulate drone volumes with movement
    if (active || fadingIn) {
        emergenceDrones.forEach((d, i) => {
            const mod = Math.sin(world.breath + i * 0.7) * 0.5 + 0.5;
            const baseVol = active ? 0.1 : 0.05;
            d.gain.gain.setTargetAtTime(baseVol + mod * 0.08 + world.energy * 0.08, ctx.currentTime, 0.3);
        });
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 2: SYNTH - 808, sub bass, a god rising
// ═══════════════════════════════════════════════════════════════════════════

let synthBass, synthBassGain, synthBassFilter;
let synthPad = [], synthPadGain;
let synthKick, synthKickGain;

function initSynthEra() {
    // Massive sub bass
    synthBass = ctx.createOscillator();
    synthBass.type = 'sine';
    synthBass.frequency.value = 32.7; // C1

    const subOsc = ctx.createOscillator();
    subOsc.type = 'sine';
    subOsc.frequency.value = 16.35; // Sub-sub

    synthBassFilter = ctx.createBiquadFilter();
    synthBassFilter.type = 'lowpass';
    synthBassFilter.frequency.value = 100;
    synthBassFilter.Q.value = 4;

    // Saturation for warmth
    const saturation = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        curve[i] = Math.tanh(x * 3) * 0.7;
    }
    saturation.curve = curve;

    synthBassGain = ctx.createGain();
    synthBassGain.gain.value = 0;

    const subGain = ctx.createGain();
    subGain.gain.value = 0.6;

    synthBass.connect(synthBassFilter);
    subOsc.connect(subGain);
    subGain.connect(synthBassFilter);
    synthBassFilter.connect(saturation);
    saturation.connect(synthBassGain);
    synthBassGain.connect(masterFilter);

    synthBass.start();
    subOsc.start();

    // Ethereal pad
    synthPadGain = ctx.createGain();
    synthPadGain.gain.value = 0;

    for (let i = 0; i < 4; i++) {
        const osc = ctx.createOscillator();
        osc.type = i < 2 ? 'sine' : 'triangle';
        osc.frequency.value = 130.8 * Math.pow(2, i * 0.5); // Spread octaves
        osc.detune.value = (Math.random() - 0.5) * 15;

        const g = ctx.createGain();
        g.gain.value = 0.08;

        osc.connect(g);
        g.connect(synthPadGain);
        osc.start();

        synthPad.push({ osc, gain: g });
    }

    const padFilter = ctx.createBiquadFilter();
    padFilter.type = 'lowpass';
    padFilter.frequency.value = 800;

    synthPadGain.connect(padFilter);
    padFilter.connect(masterFilter);
}

function playSynth808Kick() {
    if (music.era !== 2) return;

    const now = ctx.currentTime;

    // 808 kick synthesis
    const osc = ctx.createOscillator();
    osc.type = 'sine';
    osc.frequency.setValueAtTime(150, now);
    osc.frequency.exponentialRampToValueAtTime(35, now + 0.08);
    osc.frequency.exponentialRampToValueAtTime(28, now + 0.5);

    // Click
    const click = ctx.createOscillator();
    click.type = 'square';
    click.frequency.value = 800;
    const clickGain = ctx.createGain();
    clickGain.gain.setValueAtTime(0.3, now);
    clickGain.gain.exponentialRampToValueAtTime(0.001, now + 0.015);
    click.connect(clickGain);

    const env = ctx.createGain();
    env.gain.setValueAtTime(0.9, now);
    env.gain.exponentialRampToValueAtTime(0.001, now + 0.8);

    // Saturation
    const sat = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        curve[i] = Math.tanh(x * 2);
    }
    sat.curve = curve;

    osc.connect(env);
    clickGain.connect(env);
    env.connect(sat);
    sat.connect(masterFilter);

    osc.start(now);
    click.start(now);
    osc.stop(now + 0.9);
    click.stop(now + 0.02);
}

function updateSynth() {
    if (!synthBassGain) return;
    const active = music.era === 2;
    const approaching = music.era === 1 && music.eraProgress > 0.7;

    let bassTarget = 0;
    let padTarget = 0;

    if (active) {
        bassTarget = 0.5 + world.energy * 0.3;
        padTarget = 0.25;

        // Modulate bass with tilt
        const freq = 28 + world.tilt.y * 20;
        synthBass.frequency.setTargetAtTime(freq, ctx.currentTime, 0.1);
        synthBassFilter.frequency.setTargetAtTime(60 + world.tilt.x * 100, ctx.currentTime, 0.1);
    } else if (approaching) {
        bassTarget = (music.eraProgress - 0.7) * 0.3;
    }

    synthBassGain.gain.setTargetAtTime(bassTarget, ctx.currentTime, 0.3);
    synthPadGain.gain.setTargetAtTime(padTarget, ctx.currentTime, 0.5);
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 3: ORCHESTRA - Strings, brass, full classical power
// ═══════════════════════════════════════════════════════════════════════════

let strings = [], stringsGain;
let brass = [], brassGain;
let orchestraFilter;

function initOrchestraEra() {
    stringsGain = ctx.createGain();
    stringsGain.gain.value = 0;

    brassGain = ctx.createGain();
    brassGain.gain.value = 0;

    orchestraFilter = ctx.createBiquadFilter();
    orchestraFilter.type = 'lowpass';
    orchestraFilter.frequency.value = 3000;

    // Strings - multiple oscillators with detuning for richness
    const stringNotes = [220, 277.2, 329.6, 440]; // A3, C#4, E4, A4

    stringNotes.forEach((freq, i) => {
        // Each "string" is multiple detuned oscillators
        const group = [];
        for (let j = 0; j < 3; j++) {
            const osc = ctx.createOscillator();
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            osc.detune.value = (j - 1) * 8 + (Math.random() - 0.5) * 4;

            // Vibrato
            const vib = ctx.createOscillator();
            vib.type = 'sine';
            vib.frequency.value = 4.5 + Math.random() * 1;
            const vibGain = ctx.createGain();
            vibGain.gain.value = 3;
            vib.connect(vibGain);
            vibGain.connect(osc.frequency);
            vib.start();

            const g = ctx.createGain();
            g.gain.value = 0.04;

            osc.connect(g);
            g.connect(stringsGain);
            osc.start();

            group.push({ osc, gain: g, vib });
        }
        strings.push(group);
    });

    // Filter for strings warmth
    const stringFilter = ctx.createBiquadFilter();
    stringFilter.type = 'lowpass';
    stringFilter.frequency.value = 4000;
    stringFilter.Q.value = 0.5;

    stringsGain.connect(stringFilter);
    stringFilter.connect(orchestraFilter);

    // Brass - filtered sawtooth with envelope shaping
    const brassNotes = [110, 138.6, 165, 220]; // Low brass: A2, C#3, E3, A3

    brassNotes.forEach((freq, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = freq;

        const filter = ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 600;
        filter.Q.value = 2;

        const g = ctx.createGain();
        g.gain.value = 0.06;

        osc.connect(filter);
        filter.connect(g);
        g.connect(brassGain);
        osc.start();

        brass.push({ osc, filter, gain: g });
    });

    brassGain.connect(orchestraFilter);
    orchestraFilter.connect(masterFilter);
}

function updateOrchestra() {
    if (!stringsGain) return;
    const active = music.era === 3;
    const approaching = music.era === 2 && music.eraProgress > 0.6;

    let strTarget = 0;
    let brassTarget = 0;

    if (active) {
        // Strings always present
        strTarget = 0.35 + world.energy * 0.2;
        // Brass swells with energy
        brassTarget = world.energy * 0.4;

        // Tilt controls orchestral filter
        orchestraFilter.frequency.setTargetAtTime(
            1500 + world.tilt.x * 3000,
            ctx.currentTime, 0.1
        );
    } else if (approaching) {
        // Strings fade in first
        strTarget = (music.eraProgress - 0.6) * 0.4;
    }

    stringsGain.gain.setTargetAtTime(strTarget, ctx.currentTime, 0.8);
    brassGain.gain.setTargetAtTime(brassTarget, ctx.currentTime, 0.5);
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 4: BLUES - The soul speaks
// ═══════════════════════════════════════════════════════════════════════════

let bluesBass, bluesBassGain;
let bluesGuitar, bluesGuitarGain, bluesGuitarFilter;
let bluesDrums = {};

function initBluesEra() {
    // Blues bass - warm and round
    bluesBass = ctx.createOscillator();
    bluesBass.type = 'triangle';
    bluesBass.frequency.value = 87.3; // F2

    bluesBassGain = ctx.createGain();
    bluesBassGain.gain.value = 0;

    const bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 400;

    bluesBass.connect(bassFilter);
    bassFilter.connect(bluesBassGain);
    bluesBassGain.connect(masterFilter);
    bluesBass.start();

    // Blues guitar - overdriven
    bluesGuitar = ctx.createOscillator();
    bluesGuitar.type = 'sawtooth';
    bluesGuitar.frequency.value = 349.2; // F4

    bluesGuitarFilter = ctx.createBiquadFilter();
    bluesGuitarFilter.type = 'lowpass';
    bluesGuitarFilter.frequency.value = 2000;
    bluesGuitarFilter.Q.value = 3;

    const distortion = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        curve[i] = Math.tanh(x * 4) * 0.6;
    }
    distortion.curve = curve;

    bluesGuitarGain = ctx.createGain();
    bluesGuitarGain.gain.value = 0;

    bluesGuitar.connect(bluesGuitarFilter);
    bluesGuitarFilter.connect(distortion);
    distortion.connect(bluesGuitarGain);
    bluesGuitarGain.connect(masterFilter);
    bluesGuitar.start();
}

function playBluesDrum(type) {
    if (music.era !== 4) return;
    const now = ctx.currentTime;

    if (type === 'kick') {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);

        const env = ctx.createGain();
        env.gain.setValueAtTime(0.7, now);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

        osc.connect(env);
        env.connect(masterFilter);
        osc.start(now);
        osc.stop(now + 0.35);
    }

    if (type === 'snare') {
        const noise = ctx.createBufferSource();
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.2, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.08));
        }
        noise.buffer = buf;

        const body = ctx.createOscillator();
        body.type = 'triangle';
        body.frequency.value = 180;

        const bodyGain = ctx.createGain();
        bodyGain.gain.setValueAtTime(0.4, now);
        bodyGain.gain.exponentialRampToValueAtTime(0.001, now + 0.1);

        const noiseGain = ctx.createGain();
        noiseGain.gain.value = 0.5;

        const hp = ctx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 200;

        body.connect(bodyGain);
        bodyGain.connect(hp);
        noise.connect(noiseGain);
        noiseGain.connect(hp);
        hp.connect(masterFilter);

        body.start(now);
        noise.start(now);
        body.stop(now + 0.15);
    }

    if (type === 'hat') {
        const noise = ctx.createBufferSource();
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.05, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (ctx.sampleRate * 0.02));
        }
        noise.buffer = buf;

        const hp = ctx.createBiquadFilter();
        hp.type = 'highpass';
        hp.frequency.value = 7000;

        const g = ctx.createGain();
        g.gain.value = 0.25;

        noise.connect(hp);
        hp.connect(g);
        g.connect(masterFilter);
        noise.start(now);
    }
}

function updateBlues() {
    if (!bluesBassGain) return;
    const active = music.era === 4;

    let bassTarget = 0;
    let guitarTarget = 0;

    if (active) {
        bassTarget = 0.5;
        guitarTarget = 0.15 + world.energy * 0.2;

        // Tilt affects guitar wah
        bluesGuitarFilter.frequency.setTargetAtTime(
            800 + world.tilt.x * 2500,
            ctx.currentTime, 0.05
        );
    }

    bluesBassGain.gain.setTargetAtTime(bassTarget, ctx.currentTime, 0.3);
    bluesGuitarGain.gain.setTargetAtTime(guitarTarget, ctx.currentTime, 0.3);
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 5: JAZZ - Complexity and freedom
// ═══════════════════════════════════════════════════════════════════════════

let jazzPiano = [], jazzPianoGain;
let jazzBass, jazzBassGain;
let jazzRide;

function initJazzEra() {
    jazzPianoGain = ctx.createGain();
    jazzPianoGain.gain.value = 0;

    // Piano - Rhodes-like tines
    for (let i = 0; i < 4; i++) {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 261.6 * Math.pow(2, i * 0.4);

        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.value = osc.frequency.value * 7; // Bell partial

        const g = ctx.createGain();
        g.gain.value = 0.08;

        const g2 = ctx.createGain();
        g2.gain.value = 0.02;

        osc.connect(g);
        osc2.connect(g2);
        g.connect(jazzPianoGain);
        g2.connect(jazzPianoGain);

        osc.start();
        osc2.start();

        jazzPiano.push({ osc, osc2, gain: g, gain2: g2 });
    }

    jazzPianoGain.connect(masterFilter);

    // Upright bass
    jazzBass = ctx.createOscillator();
    jazzBass.type = 'triangle';
    jazzBass.frequency.value = 73.4; // D2

    jazzBassGain = ctx.createGain();
    jazzBassGain.gain.value = 0;

    const bassBody = ctx.createBiquadFilter();
    bassBody.type = 'peaking';
    bassBody.frequency.value = 150;
    bassBody.Q.value = 2;
    bassBody.gain.value = 4;

    jazzBass.connect(bassBody);
    bassBody.connect(jazzBassGain);
    jazzBassGain.connect(masterFilter);
    jazzBass.start();
}

function playJazzDrum(type) {
    if (music.era !== 5) return;
    const now = ctx.currentTime;

    if (type === 'ride') {
        const osc = ctx.createOscillator();
        osc.type = 'triangle';
        osc.frequency.value = 5500;

        const osc2 = ctx.createOscillator();
        osc2.type = 'sine';
        osc2.frequency.value = 8200;

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.08, now);
        g.gain.exponentialRampToValueAtTime(0.02, now + 0.1);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.5);

        const g2 = ctx.createGain();
        g2.gain.value = 0.03;

        osc.connect(g);
        osc2.connect(g2);
        g.connect(masterFilter);
        g2.connect(g);

        osc.start(now);
        osc2.start(now);
        osc.stop(now + 0.6);
        osc2.stop(now + 0.6);
    }

    if (type === 'kick') {
        const osc = ctx.createOscillator();
        osc.frequency.setValueAtTime(80, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.05);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.4, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.2);

        osc.connect(g);
        g.connect(masterFilter);
        osc.start(now);
        osc.stop(now + 0.25);
    }
}

function updateJazz() {
    if (!jazzPianoGain) return;
    const active = music.era === 5;

    if (active) {
        jazzPianoGain.gain.setTargetAtTime(0.25, ctx.currentTime, 0.3);
        jazzBassGain.gain.setTargetAtTime(0.4, ctx.currentTime, 0.3);
    } else {
        jazzPianoGain.gain.setTargetAtTime(0, ctx.currentTime, 0.5);
        jazzBassGain.gain.setTargetAtTime(0, ctx.currentTime, 0.5);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 6: ROCK - Raw power
// ═══════════════════════════════════════════════════════════════════════════

let rockGuitar, rockGuitarGain, rockGuitarFilter;
let rockBass, rockBassGain;

function initRockEra() {
    // Distorted guitar
    rockGuitar = ctx.createOscillator();
    rockGuitar.type = 'sawtooth';
    rockGuitar.frequency.value = 196; // G3

    const dist = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768) - 1;
        curve[i] = Math.sign(x) * Math.pow(Math.abs(x), 0.3) * 0.8;
    }
    dist.curve = curve;

    rockGuitarFilter = ctx.createBiquadFilter();
    rockGuitarFilter.type = 'lowpass';
    rockGuitarFilter.frequency.value = 3000;
    rockGuitarFilter.Q.value = 2;

    rockGuitarGain = ctx.createGain();
    rockGuitarGain.gain.value = 0;

    rockGuitar.connect(dist);
    dist.connect(rockGuitarFilter);
    rockGuitarFilter.connect(rockGuitarGain);
    rockGuitarGain.connect(masterFilter);
    rockGuitar.start();

    // Rock bass
    rockBass = ctx.createOscillator();
    rockBass.type = 'square';
    rockBass.frequency.value = 98; // G2

    const bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 800;

    rockBassGain = ctx.createGain();
    rockBassGain.gain.value = 0;

    rockBass.connect(bassFilter);
    bassFilter.connect(rockBassGain);
    rockBassGain.connect(masterFilter);
    rockBass.start();
}

function playRockDrum(type) {
    if (music.era !== 6) return;
    const now = ctx.currentTime;

    if (type === 'kick') {
        const osc = ctx.createOscillator();
        osc.frequency.setValueAtTime(120, now);
        osc.frequency.exponentialRampToValueAtTime(40, now + 0.05);

        const click = ctx.createOscillator();
        click.type = 'square';
        click.frequency.value = 1500;

        const clickG = ctx.createGain();
        clickG.gain.setValueAtTime(0.3, now);
        clickG.gain.exponentialRampToValueAtTime(0.001, now + 0.01);

        const g = ctx.createGain();
        g.gain.setValueAtTime(0.8, now);
        g.gain.exponentialRampToValueAtTime(0.001, now + 0.3);

        osc.connect(g);
        click.connect(clickG);
        clickG.connect(g);
        g.connect(masterFilter);

        osc.start(now);
        click.start(now);
        osc.stop(now + 0.35);
        click.stop(now + 0.02);
    }

    if (type === 'snare') {
        const noise = ctx.createBufferSource();
        const buf = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1);
        }
        noise.buffer = buf;

        const body = ctx.createOscillator();
        body.type = 'triangle';
        body.frequency.value = 200;

        const bodyG = ctx.createGain();
        bodyG.gain.setValueAtTime(0.5, now);
        bodyG.gain.exponentialRampToValueAtTime(0.001, now + 0.08);

        const noiseG = ctx.createGain();
        noiseG.gain.setValueAtTime(0.6, now);
        noiseG.gain.exponentialRampToValueAtTime(0.001, now + 0.12);

        body.connect(bodyG);
        noise.connect(noiseG);
        bodyG.connect(masterFilter);
        noiseG.connect(masterFilter);

        body.start(now);
        noise.start(now);
        body.stop(now + 0.1);
    }
}

function updateRock() {
    if (!rockGuitarGain) return;
    const active = music.era === 6;

    if (active) {
        rockGuitarGain.gain.setTargetAtTime(0.3, ctx.currentTime, 0.2);
        rockBassGain.gain.setTargetAtTime(0.4, ctx.currentTime, 0.2);

        // Power chord follows tilt
        const rootFreq = 98 * Math.pow(2, world.tilt.y * 0.5);
        rockGuitar.frequency.setTargetAtTime(rootFreq * 2, ctx.currentTime, 0.05);
        rockBass.frequency.setTargetAtTime(rootFreq, ctx.currentTime, 0.05);
    } else {
        rockGuitarGain.gain.setTargetAtTime(0, ctx.currentTime, 0.3);
        rockBassGain.gain.setTargetAtTime(0, ctx.currentTime, 0.3);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// ERA 7: MODERN - Everything converges
// ═══════════════════════════════════════════════════════════════════════════

let modernSynth = [], modernSynthGain;
let modernBass, modernBassGain;

function initModernEra() {
    modernSynthGain = ctx.createGain();
    modernSynthGain.gain.value = 0;

    // Layered synths
    for (let i = 0; i < 6; i++) {
        const osc = ctx.createOscillator();
        osc.type = ['sine', 'triangle', 'sawtooth'][i % 3];
        osc.frequency.value = 220 * Math.pow(2, i * 0.3);
        osc.detune.value = (Math.random() - 0.5) * 20;

        const g = ctx.createGain();
        g.gain.value = 0.06;

        osc.connect(g);
        g.connect(modernSynthGain);
        osc.start();

        modernSynth.push({ osc, gain: g });
    }

    const filter = ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 2000;

    modernSynthGain.connect(filter);
    filter.connect(masterFilter);

    // Modern bass
    modernBass = ctx.createOscillator();
    modernBass.type = 'sawtooth';
    modernBass.frequency.value = 55;

    const bassFilter = ctx.createBiquadFilter();
    bassFilter.type = 'lowpass';
    bassFilter.frequency.value = 300;
    bassFilter.Q.value = 5;

    modernBassGain = ctx.createGain();
    modernBassGain.gain.value = 0;

    modernBass.connect(bassFilter);
    bassFilter.connect(modernBassGain);
    modernBassGain.connect(masterFilter);
    modernBass.start();
}

function updateModern() {
    if (!modernSynthGain) return;
    const active = music.era === 7;

    if (active) {
        modernSynthGain.gain.setTargetAtTime(0.3, ctx.currentTime, 0.3);
        modernBassGain.gain.setTargetAtTime(0.5, ctx.currentTime, 0.3);
    } else {
        modernSynthGain.gain.setTargetAtTime(0, ctx.currentTime, 0.5);
        modernBassGain.gain.setTargetAtTime(0, ctx.currentTime, 0.5);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// RHYTHM ENGINE
// ═══════════════════════════════════════════════════════════════════════════

let lastTickTime = -1;

function onTick() {
    const era = ERAS[music.era];
    if (!era || !era.bpm) return;

    const tickInBar = music.tick % 16;
    const beatInBar = Math.floor(tickInBar / 4);

    // Era-specific drum patterns
    if (music.era === 2) { // Synth - slow 808
        if (tickInBar === 0 || tickInBar === 8) {
            playSynth808Kick();
        }
    }

    if (music.era === 4) { // Blues - shuffle
        if (tickInBar === 0 || tickInBar === 8) playBluesDrum('kick');
        if (tickInBar === 4 || tickInBar === 12) playBluesDrum('snare');
        if (tickInBar % 2 === 0) playBluesDrum('hat');
    }

    if (music.era === 5) { // Jazz - swing
        if (tickInBar === 0) playJazzDrum('kick');
        if (tickInBar % 3 === 0) playJazzDrum('ride');
    }

    if (music.era === 6) { // Rock - driving
        if (tickInBar === 0 || tickInBar === 8) playRockDrum('kick');
        if (tickInBar === 4 || tickInBar === 12) playRockDrum('snare');
    }

    music.tick++;
    if (tickInBar === 15) {
        music.bar++;
        music.beat = 0;
    }
}

function updateRhythm() {
    const era = ERAS[music.era];
    if (!era || !era.bpm || !audioReady) return;

    const tickDur = 60 / era.bpm / 4;
    const now = ctx.currentTime;

    if (lastTickTime < 0) {
        lastTickTime = now;
        return;
    }

    if (now - lastTickTime >= tickDur) {
        lastTickTime = now;
        onTick();
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// EVOLUTION SYSTEM
// ═══════════════════════════════════════════════════════════════════════════

function updateEvolution() {
    const currentEra = ERAS[music.era];
    const nextEra = ERAS[music.era + 1];

    // Calculate progress to next era
    if (nextEra) {
        const progressRange = nextEra.threshold - currentEra.threshold;
        const currentProgress = world.totalMovement - currentEra.threshold;
        music.eraProgress = Math.min(1, currentProgress / progressRange);

        // Transition to next era
        if (world.totalMovement >= nextEra.threshold) {
            music.era++;
            music.eraProgress = 0;
            music.lastTransition = Date.now();
            lastTickTime = -1;
            music.tick = 0;
            music.bar = 0;
            console.log(`Entering era: ${ERAS[music.era].name}`);
        }
    } else {
        music.eraProgress = 1;
    }

    // Update evolution bar
    const fill = document.getElementById('evolution-fill');
    if (fill) fill.style.width = (music.eraProgress * 100) + '%';

    // Update era name
    const eraName = document.getElementById('era-name');
    if (eraName) eraName.textContent = ERAS[music.era].name;
}

// ═══════════════════════════════════════════════════════════════════════════
// INPUT
// ═══════════════════════════════════════════════════════════════════════════

function onMove(nx, ny) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.vx = world.vx * 0.7 + dx * 0.3;
    world.vy = world.vy * 0.7 + dy * 0.3;
    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.85 + movement * 8);
    world.totalMovement += movement * 100;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    world.x = Math.max(0, Math.min(1, world.x + ax * 0.05));
    world.y = Math.max(0, Math.min(1, world.y - ay * 0.05));

    // Update tilt for filter/key control
    world.tilt.x = Math.max(-1, Math.min(1, ax * 2));
    world.tilt.y = Math.max(-1, Math.min(1, ay * 2));

    const movement = Math.sqrt(ax*ax + ay*ay);
    world.energy = Math.min(1, world.energy * 0.8 + movement * 0.4);
    world.totalMovement += movement * 8;
}

// ═══════════════════════════════════════════════════════════════════════════
// VISUALS
// ═══════════════════════════════════════════════════════════════════════════

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    // Era-specific background
    const eraColors = [
        [0, 0, 0],        // void - pure black
        [5, 5, 10],       // emergence - deep blue-black
        [8, 5, 12],       // synth - purple tint
        [10, 8, 6],       // orchestra - warm dark
        [8, 6, 4],        // blues - amber tint
        [6, 8, 10],       // jazz - cool blue
        [10, 6, 6],       // rock - red tint
        [8, 8, 10],       // modern - neutral
    ];

    const [r, g, b] = eraColors[music.era] || [0, 0, 0];
    vc.fillStyle = `rgba(${r},${g},${b},0.15)`;
    vc.fillRect(0, 0, w, h);

    // Central presence
    const breath = Math.sin(world.breath * 0.5) * 0.5 + 0.5;
    const size = 30 + breath * 20 + world.energy * 50 + music.era * 15;

    // Era glow color
    const glowColors = [
        'rgba(255,255,255,0.02)',  // void
        'rgba(200,220,255,0.06)',  // emergence
        'rgba(180,100,255,0.08)',  // synth
        'rgba(255,200,150,0.1)',   // orchestra
        'rgba(255,180,100,0.1)',   // blues
        'rgba(100,180,255,0.1)',   // jazz
        'rgba(255,100,80,0.12)',   // rock
        'rgba(200,150,255,0.12)', // modern
    ];

    // Rings
    for (let i = 0; i < 3; i++) {
        const ringSize = size + i * 40 + breath * 20;
        vc.strokeStyle = glowColors[music.era];
        vc.lineWidth = 1;
        vc.beginPath();
        vc.arc(w/2, h/2, ringSize, 0, TAU);
        vc.stroke();
    }

    // Position indicator
    const px = world.x * w;
    const py = world.y * h;
    const ps = 4 + world.energy * 15;

    vc.fillStyle = `rgba(255,255,255,${0.2 + world.energy * 0.5})`;
    vc.beginPath();
    vc.arc(px, py, ps, 0, TAU);
    vc.fill();
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════

function frame() {
    world.breath += 0.02;
    world.energy *= 0.99;

    // Update evolution
    updateEvolution();

    // Update era-specific audio
    updateVoid();
    updateEmergence();
    updateSynth();
    updateOrchestra();
    updateBlues();
    updateJazz();
    updateRock();
    updateModern();

    // Update rhythm
    updateRhythm();

    // Update master filter with tilt
    if (masterFilter && audioReady) {
        const baseFreq = 1000 + music.era * 500;
        const tiltMod = world.tilt.x * 2000;
        masterFilter.frequency.setTargetAtTime(
            Math.max(200, baseFreq + tiltMod),
            ctx.currentTime, 0.1
        );
    }

    // Draw
    draw();

    // Status
    const status = `era ${music.era}: ${ERAS[music.era].name}
movement: ${Math.round(world.totalMovement)}
next: ${ERAS[music.era + 1]?.threshold || '∞'}`;
    document.getElementById('status').innerHTML = status.replace(/\n/g, '<br>');

    requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════════

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    await initAudio();
    initVisuals();

    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();
    frame();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
