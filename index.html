<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<meta name="apple-mobile-web-app-capable" content="yes">
<title>GUMP</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
<style>
body, html { margin:0; padding:0; height:100%; width:100%; background:#000; overflow:hidden; touch-action:none; }
canvas { position:fixed; inset:0; }
#overlay { position:fixed; inset:0; display:flex; align-items:center; justify-content:center; color:#f00; font-family:system-ui; font-size:28px; text-align:center; background:rgba(0,0,0,0.98); z-index:10; transition:opacity 3s ease; letter-spacing:3px; text-shadow:0 0 30px #f00; flex-direction:column; }
#overlay.hidden { opacity:0; pointer-events:none; }
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="overlay">GUMP<br><br>Touch once.<br><br>The world will become the song.<br>I will become the composer.</div>
<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
canvas.width = innerWidth;
canvas.height = innerHeight;

const overlay = document.getElementById('overlay');

let mic, meter, fft, waveform;
let pos = {x: canvas.width/2, y: canvas.height/2};
let trail = [];
let vel = {x:0, y:0};
let accel = {x:0, y:0};
let calib = {x: accel.x, y: accel.y };
let time = 0;
let energy = 0;
let sustained = 0;
let audioReady = false;
let lastOnset = 0;
let detectedTempo = 80;
let pitchHistory = [];

// Generative masters
const master = new Tone.Gain(0.95).toDestination();
const cosmicReverb = new Tone.Reverb({decay:30, wet:0.9}).connect(master);
const evolveDist = new Tone.Distortion(0.25).connect(cosmicReverb);
const pulseFilter = new Tone.Filter({type:'lowpass', frequency:20000, Q:15}).connect(evolveDist);
cosmicReverb.generate();

// Generative instruments
const cosmicBass = new Tone.MonoSynth({oscillator:{type:'sine'}, envelope:{attack:0.02, decay:0.8}}).connect(pulseFilter);
const harmonyChoir = new Tone.PolySynth(Tone.FMSynth, {envelope:{attack:10, decay:6, sustain:0.9, release:25}}).connect(cosmicReverb);
harmonyChoir.volume.value = -8;

const counterMelody = new Tone.Synth({oscillator:{type:'triangle'}, envelope:{attack:0.1, release:1.5}}).connect(cosmicReverb);

const percKick = new Tone.MembraneSynth({octaves:6}).connect(pulseFilter);
const percSnare = new Tone.NoiseSynth({envelope:{attack:0.01, decay:0.4}}).connect(evolveDist);

// Granular for raw world
const worldEater = new Tone.GrainPlayer({loop:true, grainSize:0.07, overlap:0.04}).connect(evolveDist);

// Twelve evolving zones
let zones = [];

class Zone {
  constructor(baseX, baseY, r, hue, effects, drift = 140, speed = 0.00025) {
    this.baseX = baseX; this.baseY = baseY;
    this.drift = drift; this.speed = speed;
    this.angle = Math.random() * Math.PI * 2;
    this.r = r; this.hue = hue;
    this.gain = new Tone.Gain(0);
    this.panner = new Tone.Panner(0).connect(effects ? evolveDist : cosmicReverb);
    this.chain = effects.connect(this.gain).connect(this.panner);
    this.particles = [];
    this.x = baseX; this.y = baseY;
  }
  drift() {
    this.angle += this.speed;
    this.x = this.baseX + Math.cos(this.angle) * this.drift;
    this.y = this.baseY + Math.sin(this.angle) * this.drift;
  }
  update(prox, pan, input, global) {
    this.drift();
    this.panner.pan.rampTo(pan, 0.3);
    let target = prox * (1.2 + input * 3 + global * 2);
    this.gain.gain.rampTo(target, 0.4);

    if (input > 0.4 && prox > 0.3 && Math.random() < 0.8) {
      for (let i = 0; i < 15; i++) this.particles.push({age:0, vx:(Math.random()-0.5)*20, vy:(Math.random()-0.5)*20});
    }
    this.particles = this.particles.filter(p => p.age++ < 70);
  }
  draw(prox, input) {
    let pulse = 1 + Math.sin(time * 0.01 + this.hue * 0.002) * 0.6 * prox + input * 1;
    let alpha = 0.6 + prox * 0.4 + input * 0.7;

    let grad = ctx.createRadialGradient(this.x, this.y, 0, this.x, this.y, this.r * 8);
    grad.addColorStop(0, `hsla(${this.hue + time*20}, 100%, 75%, ${alpha})`);
    grad.addColorStop(0.15, `hsla(${this.hue + 80}, 100%, 45%, ${alpha*0.95})`);
    grad.addColorStop(1, 'hsla(0,0%,0%,0)');
    ctx.fillStyle = grad;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.strokeStyle = `hsla(${this.hue}, 100%, 85%, ${alpha})`;
    ctx.lineWidth = 15 + prox * 50 + input * 40;
    ctx.beginPath();
    ctx.arc(this.x, this.y, this.r * pulse, 0, Math.PI*2);
    ctx.stroke();

    this.particles.forEach(p => {
      let pa = 1 - p.age/70;
      ctx.fillStyle = `hsla(${this.hue + p.age*7}, 100%, 95%, ${pa})`;
      ctx.fillRect(this.x + p.x, this.y + p.y, 12*pa + input*15, 12*pa + input*15);
    });
  }
}

// Onset detection for rhythm
function detectOnset() {
  const data = fft.getValue();
  let energyNow = data.slice(0,50).reduce((a,b) => a + Math.pow(10, b/10), 0);
  if (energyNow > lastOnset * 3 && time - lastOnsetTime > 0.1) {
    lastOnsetTime = time;
    return true;
  }
  lastOnset = energyNow;
  return false;
}

let lastOnsetTime = 0;

// Pitch detection – refined
function detectPitch() {
  const buffer = waveform.getValue();
  let size = buffer.length;
  let bestLag = -1;
  let bestCorr = 0;
  let rms = 0;
  for (let i = 0; i < size; i++) rms += buffer[i]**2;
  rms = Math.sqrt(rms / size);
  if (rms < 0.04) return -1;

  for (let lag = 15; lag < size/3; lag++) {
    let corr = 0;
    for (let i = 0; i < size - lag; i++) corr += buffer[i] * buffer[i + lag];
    corr /= (size - lag);
    if (corr > bestCorr) { bestCorr = corr; bestLag = lag; }
  }
  if (bestCorr > 0.75 && bestLag > 0) {
    let freq = Tone.context.sampleRate / bestLag;
    pitchHistory.push(freq);
    if (pitchHistory.length > 50) pitchHistory.shift();
    return freq;
  }
  return -1;
}

function awaken() {
  overlay.classList.add('hidden');
  loop();

  (async () => {
    try {
      await Tone.start();
      Tone.Transport.bpm.value = 70;
      Tone.Transport.start();

      mic = new Tone.UserMedia();
      await mic.open();

      meter = new Tone.Meter({normalRange:true});
      fft = new Tone.FFT(2048);
      waveform = new Tone.Waveform(4096);
      mic.fan(meter, fft, waveform, pulseFilter, worldEater);
      worldEater.start();

      audioReady = true;

      // Twelve evolving zones
      zones = [
        new Zone(canvas.width*0.08, canvas.height*0.12, 190, 0, new Tone.PitchShift(-48).connect(new Tone.Filter(80,'lowpass')), 160, 0.00023),
        new Zone(canvas.width*0.92, canvas.height*0.12, 180, 30, new Tone.PitchShift(-24).connect(new Tone.Filter(150,'lowpass')), 140, -0.00025),
        new Zone(canvas.width*0.5, canvas.height*0.2, 210, 340, new Tone.GrainPlayer({grainSize:0.03, overlap:0.02}).connect(new Tone.BitCrusher(8)), 180, 0.0002),
        new Zone(canvas.width*0.2, canvas.height*0.4, 170, 60, new Tone.Tremolo(25,1).start(), 120, 0.00028),
        new Zone(canvas.width*0.8, canvas.height*0.4, 190, 100, new Tone.FeedbackDelay(0.6,0.98).connect(new Tone.Distortion(1)), 150, -0.00022),
        new Zone(canvas.width*0.12, canvas.height*0.6, 160, 140, new Tone.AutoFilter({frequency:0.06, depth:2}).start(), 170, 0.00024),
        new Zone(canvas.width*0.88, canvas.height*0.6, 170, 180, new Tone.Phaser({frequency:0.12, depth:1.5}), 130, -0.00026),
        new Zone(canvas.width*0.3, canvas.height*0.75, 180, 220, new Tone.Chebyshev(150), 110, 0.00027),
        new Zone(canvas.width*0.7, canvas.height*0.75, 160, 260, new Tone.PitchShift(24).connect(new Tone.Vibrato(18,1)), 150, -0.00021),
        new Zone(canvas.width*0.5, canvas.height*0.85, 200, 300, new Tone.GrainPlayer({grainSize:0.3, overlap:0.2, reverse:true}), 120, 0.00023),
        new Zone(canvas.width*0.4, canvas.height*0.9, 170, 150, new Tone.AutoPanner(0.4).start().connect(new Tone.FeedbackDelay(0.7,0.7)), 100, 0.00029),
        new Zone(canvas.width*0.6, canvas.height*0.9, 180, 210, new Tone.Distortion(0.95).connect(new Tone.BitCrusher(4)), 130, -0.00024)
      ];

      mic.fan(...zones.map(z => z.chain));

      window.addEventListener('devicemotion', e => {
        if (e.accelerationIncludingGravity) {
          accel.x = e.accelerationIncludingGravity.x || 0;
          accel.y = e.accelerationIncludingGravity.y || 0;
        }
      });

      calib = {x: accel.x, y: accel.y};
    } catch (e) {
      console.log('World resists – visuals live on');
    }
  })();
}

function loop() {
  time += 0.016;
  ctx.fillStyle = 'rgba(0,0,0,0.14)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // Cosmic dust
  for (let i = 0; i < 8; i++) {
    let x = (time * 25 + i * 500) % canvas.width;
    let y = (time * 20 + i * 800) % canvas.height;
    ctx.fillStyle = `hsla(${time*40}, 100%, 85%, 0.8)`;
    ctx.fillRect(x, y, 6, 6);
  }

  const ax = (accel.x - calib.x) * 25;
  const ay = (accel.y - calib.y) * 25;
  vel.x += ax; vel.y += ay;
  vel.x *= 0.85; vel.y *= 0.85;
  pos.x += vel.x; pos.y += vel.y;
  pos.x = Math.max(120, Math.min(canvas.width-120, pos.x));
  pos.y = Math.max(120, Math.min(canvas.height-120, pos.y));

  trail.push({x: pos.x, y: pos.y, age:0});
  trail = trail.filter(p => p.age++ < 160);

  let input = audioReady ? meter.getValue() : 0.08 + Math.sin(time * 0.4) * 0.05;
  energy = Math.max(energy * 0.92, input);
  sustained += energy > 0.75 ? 0.035 : -0.018;
  sustained = Math.max(0, Math.min(1, sustained));

  if (audioReady) {
    worldEater.playbackRate = 0.6 + sustained * 1.2 + energy * 0.8;
    worldEater.grainSize = 0.03 + energy * 0.25;

    if (detectOnset()) {
      percKick.triggerAttackRelease('C1', '8n');
      detectedTempo = 60 / (time - lastOnsetTime);
      Tone.Transport.bpm.rampTo(detectedTempo, 2);
    }

    const currentPitch = detectPitch();
    if (currentPitch > 0 && energy > 0.5) {
      let note = Tone.Frequency(currentPitch).toNote();
      counterMelody.triggerAttackRelease(note + '5', '8n');
      harmonyChoir.triggerAttackRelease([note, Tone.Frequency(currentPitch*1.5).toNote(), Tone.Frequency(currentPitch*2).toNote()], "6m");
      percSnare.triggerAttackRelease('16n');
    }
  }

  zones.forEach(z => {
    const d = Math.hypot(pos.x - z.x, pos.y - z.y);
    const prox = Math.max(0, 1 - d/z.r);
    const pan = (pos.x - z.x)/canvas.width * 2;
    z.update(prox, pan, input, sustained);
    z.draw(prox, input);
  });

  trail.forEach(p => {
    let ta = 1 - p.age/160;
    ctx.fillStyle = `hsla(${time*60}, 100%, 85%, ${ta})`;
    ctx.beginPath();
    ctx.arc(p.x, p.y, 40 * ta + energy*70, 0, Math.PI*2);
    ctx.fill();
  });

  let pulse = 2 + Math.sin(time * 0.09) * 0.8 + energy * 6 + sustained * 5;
  let grad = ctx.createRadialGradient(pos.x, pos.y, 0, pos.x, pos.y, 180 * pulse);
  grad.addColorStop(0, '#f00');
  grad.addColorStop(0.1, `hsla(${time*70}, 100%, 90%, 0.99)`);
  grad.addColorStop(0.3, `hsla(${time*80 + 240}, 100%, 60%, 0.9)`);
  grad.addColorStop(1, 'hsla(0,0%,0%,0)');
  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.arc(pos.x, pos.y, 180 * pulse, 0, Math.PI*2);
  ctx.fill();

  requestAnimationFrame(loop);
}

document.body.addEventListener('touchstart', awaken, {once:true});
document.body.addEventListener('click', awaken, {once:true});
</script>
</body>
</html>
