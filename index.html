<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Life Soundtrack: Adaptive Music</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
  <style>
    body {
      font-family: 'Courier New', monospace;
      background: #000;
      color: #0f0;
      margin: 0;
      padding: 20px;
      min-height: 100vh;
    }
    
    .container {
      max-width: 600px;
      margin: 0 auto;
      text-align: center;
    }
    
    .title {
      font-size: 2rem;
      margin-bottom: 1rem;
      text-shadow: 0 0 10px #0f0;
    }
    
    .start-btn {
      padding: 10px 20px;
      background: #0f0;
      color: #000;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      font-size: 1rem;
      margin-bottom: 20px;
    }
    
    .controls {
      display: flex;
      gap: 10px;
      justify-content: center;
      margin: 20px 0;
      flex-wrap: wrap;
    }
    
    .control-btn {
      padding: 8px 16px;
      background: rgba(0,255,0,0.1);
      color: #0f0;
      border: 1px solid #0f0;
      border-radius: 3px;
      cursor: pointer;
      font-size: 0.9rem;
    }
    
    .control-btn:hover {
      background: rgba(0,255,0,0.2);
    }
    
    .control-btn.active {
      background: rgba(0,255,0,0.3);
    }
    
    .status {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin: 20px 0;
      font-size: 0.9rem;
    }
    
    .status-item {
      background: rgba(0,255,0,0.1);
      padding: 10px;
      border-radius: 3px;
      border: 1px solid rgba(0,255,0,0.3);
    }
    
    .layers {
      margin: 20px 0;
    }
    
    .layer-dot {
      display: inline-block;
      width: 10px;
      height: 10px;
      border-radius: 50%;
      margin: 0 5px;
      background: rgba(0,255,0,0.3);
      transition: all 0.3s;
    }
    
    .layer-dot.active {
      background: #0f0;
      box-shadow: 0 0 10px #0f0;
    }
    
    .evolution-bar {
      width: 100%;
      height: 20px;
      background: rgba(0,255,0,0.1);
      border: 1px solid rgba(0,255,0,0.3);
      border-radius: 10px;
      overflow: hidden;
      margin: 10px 0;
    }
    
    .evolution-progress {
      height: 100%;
      background: linear-gradient(90deg, #0f0, #0a0);
      transition: width 0.5s ease;
      box-shadow: 0 0 10px rgba(0,255,0,0.5);
    }
    
    .hidden {
      display: none;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1 class="title">LIFE SOUNDTRACK</h1>
    <button class="start-btn" id="startBtn">Start Music</button>
    
    <div class="controls hidden" id="controls">
      <button class="control-btn" id="btnMotionPermission">Enable Motion Detection</button>
      <div style="margin-top: 10px; font-size: 0.8rem; color: #0a0;">
        <div id="motionStatus">Motion detection inactive</div>
        <div id="motionDebug">Move your phone to see changes</div>
      </div>
    </div>
    
    <div class="status hidden" id="status">
      <div class="status-item">
        <div>Motion: <span id="motionLevel">0</span></div>
        <div>State: <span id="currentState">Still</span></div>
      </div>
      <div class="status-item">
        <div>Tempo: <span id="currentTempo">72</span> BPM</div>
        <div>Key: <span id="currentKey">A Minor</span></div>
      </div>
      <div class="status-item">
        <div>Stage: <span id="evolutionStage">Dormant</span></div>
        <div>Layers: <span id="layerCount">1</span></div>
      </div>
      <div class="status-item">
        <div>Evolution: <span id="evolutionLevel">0</span></div>
        <div>Complexity: <span id="complexity">Basic</span></div>
      </div>
    </div>
    
    <div class="layers hidden" id="layers">
      <div>Evolution Progress:</div>
      <div class="evolution-bar">
        <div class="evolution-progress" id="evolutionProgress"></div>
      </div>
      <div>Active Layers:</div>
      <div style="margin-top: 10px;">
        <span class="layer-dot active" id="layerAmbient" title="Ambient"></span>
        <span class="layer-dot" id="layerBass" title="Bass"></span>
        <span class="layer-dot" id="layerDrums" title="Drums"></span>
        <span class="layer-dot" id="layerHarmony" title="Harmony"></span>
        <span class="layer-dot" id="layerMelody" title="Melody"></span>
        <span class="layer-dot" id="layerTexture" title="Texture"></span>
      </div>
    </div>
  </div>

  <script>
    // Musical system
    const KEYS = {
      A_MINOR: {
        name: 'A Minor',
        chords: {
          i: ['A3', 'C4', 'E4'],
          ii: ['B3', 'D4', 'F4'],
          III: ['C4', 'E4', 'G4'],
          iv: ['D4', 'F4', 'A4'],
          v: ['E4', 'G4', 'B4'],
          VI: ['F4', 'A4', 'C5'],
          VII: ['G4', 'B4', 'D5']
        }
      }
    };
    
    const PROGRESSIONS = {
      dormant: ['i'],
      awakening: ['i', 'VI'],
      building: ['i', 'VI', 'III', 'VII'],
      active: ['i', 'iv', 'VI', 'v'],
      dynamic: ['i', 'VII', 'VI', 'III'],
      evolved: ['i', 'ii', 'VI', 'iv', 'v', 'VII']
    };
    
    // State
    let state = {
      active: false,
      currentKey: KEYS.A_MINOR,
      motionIntensity: 0,
      activityState: 'still',
      tempo: 72,
      evolutionStage: 'dormant',
      evolutionLevel: 0, // 0-100, persists and builds over time
      activeLayers: new Set(['ambient']),
      complexity: 0,
      chordIndex: 0,
      beatCount: 0,
      motionHistory: [],
      lastMotionTime: 0,
      motionPermissionGranted: false,
      totalMotionTime: 0, // Accumulates motion time for evolution
      lastUpdateTime: Date.now()
    };
    
    // Audio
    let instruments = {};
    let effects = {};
    let audioInitialized = false;
    
    // Initialize audio with more complex sounds
    async function initAudio() {
      if (audioInitialized) return;
      
      await Tone.start();
      
      // Create effects
      effects.reverb = new Tone.Reverb(3);
      effects.delay = new Tone.PingPongDelay("8n", 0.2);
      effects.chorus = new Tone.Chorus(4, 2.5, 0.5);
      effects.distortion = new Tone.Distortion(0.4);
      effects.filter = new Tone.Filter(800, "lowpass");
      
      await effects.reverb.generate();
      
      // Create more complex instruments
      instruments.ambient = new Tone.PolySynth(Tone.AMSynth, {
        harmonicity: 2,
        detune: 0,
        oscillator: {
          type: "sine"
        },
        envelope: {
          attack: 3,
          decay: 2,
          sustain: 0.8,
          release: 4
        },
        modulation: {
          type: "triangle"
        },
        modulationEnvelope: {
          attack: 0.5,
          decay: 0.5,
          sustain: 1,
          release: 0.5
        }
      }).chain(effects.reverb, effects.chorus, Tone.Destination);
      
      instruments.bass = new Tone.MonoSynth({
        oscillator: {
          type: "fatsawtooth"
        },
        envelope: {
          attack: 0.1,
          decay: 0.3,
          sustain: 0.6,
          release: 0.8
        },
        filter: {
          Q: 2,
          type: "lowpass",
          rolloff: -24
        },
        filterEnvelope: {
          attack: 0.05,
          decay: 0.2,
          sustain: 0.4,
          release: 0.3,
          baseFrequency: 80,
          octaves: 4
        }
      }).chain(effects.distortion, Tone.Destination);
      
      instruments.drums = new Tone.MembraneSynth({
        pitchDecay: 0.08,
        octaves: 2,
        envelope: {
          attack: 0.001,
          decay: 0.3,
          sustain: 0.01,
          release: 1.2
        }
      }).chain(effects.reverb, Tone.Destination);
      
      instruments.harmony = new Tone.PolySynth(Tone.FMSynth, {
        harmonicity: 1.5,
        modulationIndex: 10,
        oscillator: {
          type: "triangle"
        },
        envelope: {
          attack: 0.8,
          decay: 1.2,
          sustain: 0.7,
          release: 2.5
        },
        modulation: {
          type: "sine"
        },
        modulationEnvelope: {
          attack: 0.2,
          decay: 0.5,
          sustain: 0.8,
          release: 1.5
        }
      }).chain(effects.filter, effects.delay, Tone.Destination);
      
      instruments.melody = new Tone.DuoSynth({
        vibratoAmount: 0.2,
        vibratoRate: 5,
        voice0: {
          oscillator: {
            type: "square"
          },
          envelope: {
            attack: 0.02,
            decay: 0.1,
            sustain: 0.4,
            release: 0.6
          }
        },
        voice1: {
          oscillator: {
            type: "triangle"
          },
          envelope: {
            attack: 0.01,
            decay: 0.05,
            sustain: 0.3,
            release: 0.4
          }
        }
      }).chain(effects.delay, Tone.Destination);
      
      instruments.texture = new Tone.NoiseSynth({
        noise: {
          type: "pink"
        },
        envelope: {
          attack: 0.2,
          decay: 0.5,
          sustain: 0.2,
          release: 1.0
        }
      }).chain(effects.filter, effects.reverb, Tone.Destination);
      
      // Set volumes
      instruments.ambient.volume.value = -18;
      instruments.bass.volume.value = -12;
      instruments.drums.volume.value = -15;
      instruments.harmony.volume.value = -20;
      instruments.melody.volume.value = -16;
      instruments.texture.volume.value = -22;
      
      Tone.Transport.bpm.value = state.tempo;
      Tone.Transport.start();
      
      audioInitialized = true;
      startSequence();
    }
    
    // Start musical sequence
    function startSequence() {
      Tone.Transport.scheduleRepeat((time) => {
        state.beatCount++;
        
        // Play chord every measure
        if (state.beatCount % 4 === 0) {
          playChord(time);
        }
        
        // Play bass on beats 1 and 3
        if (state.beatCount % 2 === 0 && state.activeLayers.has('bass')) {
          playBass(time);
        }
        
        // Play drums
        if (state.activeLayers.has('drums')) {
          playDrums(time);
        }
        
        // Play harmony
        if (state.activeLayers.has('harmony') && state.beatCount % 6 === 0) {
          playHarmony(time);
        }
        
        // Play melody
        if (state.activeLayers.has('melody') && state.beatCount % 8 === 0) {
          playMelody(time);
        }
        
        // Play texture
        if (state.activeLayers.has('texture') && Math.random() < 0.3) {
          playTexture(time);
        }
        
        // Evolve music
        evolveMusic();
        updateUI();
        
      }, '4n');
    }
    
    // Play chord with evolution-based complexity
    function playChord(time) {
      const progression = PROGRESSIONS[state.evolutionStage];
      const chordName = progression[state.chordIndex % progression.length];
      let chord = state.currentKey.chords[chordName];
      
      if (chord && state.activeLayers.has('ambient')) {
        // Add complexity based on evolution level - faster thresholds
        if (state.evolutionLevel > 20) {
          // Add seventh
          const seventh = chord.map(note => {
            const noteNum = parseInt(note.slice(-1));
            const noteName = note.slice(0, -1);
            return noteName + (noteNum + 1);
          });
          chord = [...chord, seventh[0]];
        }
        
        if (state.evolutionLevel > 40) {
          // Add extended harmony
          const ninth = chord[0].replace(/\d/, '6');
          chord = [...chord, ninth];
        }
        
        instruments.ambient.triggerAttackRelease(chord, '2n', time);
      }
      
      state.chordIndex++;
    }
    
    // Play bass with evolution-based patterns
    function playBass(time) {
      const progression = PROGRESSIONS[state.evolutionStage];
      const chordName = progression[state.chordIndex % progression.length];
      const chord = state.currentKey.chords[chordName];
      
      if (chord) {
        let bassNote = chord[0].replace('3', '2');
        
        // Add walking bass patterns at higher evolution levels - faster threshold
        if (state.evolutionLevel > 25 && state.beatCount % 4 === 2) {
          const walkingNotes = ['A2', 'B2', 'C3', 'D3', 'E3', 'F3', 'G3'];
          bassNote = walkingNotes[Math.floor(Math.random() * walkingNotes.length)];
        }
        
        instruments.bass.triggerAttackRelease(bassNote, '8n', time);
      }
    }
    
    // Play drums with evolution-based complexity
    function playDrums(time) {
      const patterns = {
        still: [1, 0, 0, 0],
        walking: [1, 0, 1, 0],
        running: [1, 1, 0, 1],
        dancing: [1, 1, 1, 1]
      };
      
      let pattern = patterns[state.activityState];
      
      // Add complexity based on evolution - faster threshold
      if (state.evolutionLevel > 35) {
        pattern = pattern.map(beat => beat || (Math.random() < 0.3 ? 1 : 0));
      }
      
      const beat = state.beatCount % 4;
      
      if (pattern[beat]) {
        const pitch = state.evolutionLevel > 50 ? 
          ['C2', 'D2', 'E2'][Math.floor(Math.random() * 3)] : 'C2';
        instruments.drums.triggerAttackRelease(pitch, '16n', time);
      }
    }
    
    // Play harmony
    function playHarmony(time) {
      const progression = PROGRESSIONS[state.evolutionStage];
      const chordName = progression[(state.chordIndex + 1) % progression.length];
      const chord = state.currentKey.chords[chordName];
      
      if (chord) {
        const harmonyChord = chord.map(note => note.replace('4', '5'));
        instruments.harmony.triggerAttackRelease(harmonyChord, '4n', time);
      }
    }
    
    // Play melody
    function playMelody(time) {
      const melodyNotes = ['A4', 'C5', 'E5', 'G5', 'F5', 'D5', 'B4'];
      const note = melodyNotes[Math.floor(Math.random() * melodyNotes.length)];
      
      if (state.evolutionLevel > 45) {
        // Play more complex melodies - faster threshold
        const duration = Math.random() < 0.5 ? '8n' : '4n';
        instruments.melody.triggerAttackRelease(note, duration, time);
      } else {
        instruments.melody.triggerAttackRelease(note, '4n', time);
      }
    }
    
    // Play texture
    function playTexture(time) {
      const duration = '32n';
      instruments.texture.triggerAttackRelease(duration, time);
    }
    
    // Evolve music with perpetual motion tracking
    function evolveMusic() {
      const now = Date.now();
      const timeDelta = now - state.lastUpdateTime;
      
      // If motion is active, increase evolution level
      if (state.motionIntensity > 0.5) {
        state.totalMotionTime += timeDelta;
        const evolutionRate = state.motionIntensity * 0.08; // Much faster evolution with more motion
        state.evolutionLevel = Math.min(100, state.evolutionLevel + evolutionRate);
      } else {
        // Slow decay when still, but preserve most progress
        state.evolutionLevel = Math.max(0, state.evolutionLevel - 0.02);
      }
      
      // Determine evolution stage based on level - adjusted for faster progression
      if (state.evolutionLevel < 8) {
        state.evolutionStage = 'dormant';
        state.activeLayers = new Set(['ambient']);
      } else if (state.evolutionLevel < 20) {
        state.evolutionStage = 'awakening';
        state.activeLayers = new Set(['ambient', 'harmony']);
      } else if (state.evolutionLevel < 35) {
        state.evolutionStage = 'building';
        state.activeLayers = new Set(['ambient', 'harmony', 'bass']);
      } else if (state.evolutionLevel < 50) {
        state.evolutionStage = 'active';
        state.activeLayers = new Set(['ambient', 'harmony', 'bass', 'drums']);
      } else if (state.evolutionLevel < 70) {
        state.evolutionStage = 'dynamic';
        state.activeLayers = new Set(['ambient', 'harmony', 'bass', 'drums', 'melody']);
      } else {
        state.evolutionStage = 'evolved';
        state.activeLayers = new Set(['ambient', 'harmony', 'bass', 'drums', 'melody', 'texture']);
      }
      
      // Update tempo based on both motion and evolution
      const baseTempo = 60 + (state.motionIntensity * 15);
      const evolutionBonus = (state.evolutionLevel / 100) * 20;
      const targetTempo = baseTempo + evolutionBonus;
      
      Tone.Transport.bpm.rampTo(targetTempo, 2);
      state.tempo = Math.round(targetTempo);
      
      // Update complexity
      state.complexity = Math.min(5, Math.floor((state.evolutionLevel / 100) * 5));
      
      // Update effects based on evolution
      updateEffects();
      
      state.lastUpdateTime = now;
    }
    
    // Update effects based on evolution level
    function updateEffects() {
      const evolutionRatio = state.evolutionLevel / 100;
      
      // Adjust reverb
      if (effects.reverb) {
        effects.reverb.wet.value = 0.2 + (evolutionRatio * 0.3);
      }
      
      // Adjust delay
      if (effects.delay) {
        effects.delay.wet.value = evolutionRatio * 0.4;
      }
      
      // Adjust filter
      if (effects.filter) {
        effects.filter.frequency.value = 400 + (evolutionRatio * 2000);
      }
    }
    
    // Update UI
    function updateUI() {
      document.getElementById('motionLevel').textContent = state.motionIntensity.toFixed(1);
      document.getElementById('currentState').textContent = state.activityState;
      document.getElementById('currentTempo').textContent = state.tempo;
      document.getElementById('currentKey').textContent = state.currentKey.name;
      document.getElementById('evolutionStage').textContent = state.evolutionStage;
      document.getElementById('evolutionLevel').textContent = Math.round(state.evolutionLevel);
      document.getElementById('layerCount').textContent = state.activeLayers.size;
      document.getElementById('complexity').textContent = ['None', 'Basic', 'Simple', 'Moderate', 'Complex', 'Rich'][state.complexity];
      
      // Update evolution progress bar
      document.getElementById('evolutionProgress').style.width = `${state.evolutionLevel}%`;
      
      // Update layer indicators
      const layers = ['ambient', 'bass', 'drums', 'harmony', 'melody', 'texture'];
      layers.forEach(layer => {
        const dot = document.getElementById(`layer${layer.charAt(0).toUpperCase() + layer.slice(1)}`);
        if (dot) {
          dot.classList.toggle('active', state.activeLayers.has(layer));
        }
      });
    }
    
    // Motion detection (same as before)
    function requestMotionPermission() {
      if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
          .then(response => {
            if (response === 'granted') {
              startMotionDetection();
            } else {
              document.getElementById('motionStatus').textContent = 'Motion permission denied';
            }
          })
          .catch(error => {
            document.getElementById('motionStatus').textContent = 'Motion permission error';
            console.error('Motion permission error:', error);
          });
      } else {
        startMotionDetection();
      }
    }
    
    function startMotionDetection() {
      state.motionPermissionGranted = true;
      document.getElementById('motionStatus').textContent = 'Motion detection active';
      document.getElementById('btnMotionPermission').classList.add('active');
      
      if (window.DeviceMotionEvent) {
        window.addEventListener('devicemotion', handleMotion);
      } else {
        document.getElementById('motionStatus').textContent = 'Device motion not supported';
      }
    }
    
    function handleMotion(event) {
      if (!state.active || !state.motionPermissionGranted) return;
      
      const acceleration = event.accelerationIncludingGravity;
      const rotation = event.rotationRate;
      
      if (!acceleration) return;
      
      const now = Date.now();
      
      const accelMagnitude = Math.sqrt(
        (acceleration.x || 0) ** 2 + 
        (acceleration.y || 0) ** 2 + 
        (acceleration.z || 0) ** 2
      );
      
      const rotationMagnitude = rotation ? Math.sqrt(
        (rotation.alpha || 0) ** 2 + 
        (rotation.beta || 0) ** 2 + 
        (rotation.gamma || 0) ** 2
      ) : 0;
      
      const totalMotion = (accelMagnitude / 10) + (rotationMagnitude / 100);
      
      state.motionHistory.push({
        intensity: totalMotion,
        timestamp: now
      });
      
      state.motionHistory = state.motionHistory.filter(m => now - m.timestamp < 2000);
      
      const recentMotion = state.motionHistory.slice(-10);
      const avgMotion = recentMotion.reduce((sum, m) => sum + m.intensity, 0) / recentMotion.length;
      
      state.motionIntensity = Math.min(5, Math.max(0, avgMotion * 2));
      
      determineActivityState();
      
      document.getElementById('motionDebug').textContent = 
        `Accel: ${accelMagnitude.toFixed(1)} | Rot: ${rotationMagnitude.toFixed(1)} | Evolution: ${state.evolutionLevel.toFixed(1)}`;
      
      state.lastMotionTime = now;
    }
    
    function determineActivityState() {
      const intensity = state.motionIntensity;
      const recentMotion = state.motionHistory.slice(-5);
      
      const motionValues = recentMotion.map(m => m.intensity);
      const variance = calculateVariance(motionValues);
      
      if (intensity < 0.3) {
        state.activityState = 'still';
      } else if (intensity < 1.0) {
        state.activityState = 'walking';
      } else if (intensity < 2.5) {
        if (variance > 0.5) {
          state.activityState = 'dancing';
        } else {
          state.activityState = 'running';
        }
      } else {
        state.activityState = 'dancing';
      }
    }
    
    function calculateVariance(values) {
      if (values.length < 2) return 0;
      const mean = values.reduce((sum, val) => sum + val, 0) / values.length;
      const squareDiffs = values.map(val => (val - mean) ** 2);
      return squareDiffs.reduce((sum, diff) => sum + diff, 0) / values.length;
    }
    
    // Event listeners
    document.getElementById('startBtn').addEventListener('click', async () => {
      await initAudio();
      state.active = true;
      
      document.getElementById('startBtn').classList.add('hidden');
      document.getElementById('controls').classList.remove('hidden');
      document.getElementById('status').classList.remove('hidden');
      document.getElementById('layers').classList.remove('hidden');
      
      updateUI();
    });
    
    document.getElementById('btnMotionPermission').addEventListener('click', requestMotionPermission);
    
    // Check for motion inactivity
    setInterval(() => {
      if (state.active && state.motionPermissionGranted) {
        const now = Date.now();
        if (now - state.lastMotionTime > 3000) {
          state.motionIntensity = Math.max(0, state.motionIntensity - 0.1);
          if (state.motionIntensity < 0.3) {
            state.activityState = 'still';
          }
        }
      }
    }, 500);
  </script>
</body>
</html>
