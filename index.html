<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Interstellar Docking Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,107,53,0.7);
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #4a90e2 0%, rgba(74,144,226,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(74,144,226,0.7);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(155,89,182,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    .orb.dimensional {
      background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, #ffff00 50%, #00ff00 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(0,255,255,1);
      filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
    }
    
    .orb.void {
      background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(147,112,219,0.4);
      filter: drop-shadow(0 0 20px rgba(147,112,219,0.2));
      animation: voidBreathe 3s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes voidBreathe {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">TECHNIQUE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">SHEPARD TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="shepardBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">60</span></div>
      <div class="metric">KEY: <span id="keyDisplay">D MIN</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class VoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 96;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.lastMotionTime = Date.now();
        
        // Gesture Recognition
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        // Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.voidPhase = false;
        this.currentTechnique = 'waiting';
        this.transposition = 0;
        
        // Cinematic Themes (Adapted to Interstellar)
        this.currentTheme = 'awakening';
        this.themes = {
          awakening: { mood: 'mysterious', colors: ['#1a1a1a', '#2a2a2a'], text: 'Into the Void' },
          adventure: { mood: 'heroic', colors: ['#ff6b35', '#1a1a1a'], text: 'Ticking Begins' },
          tension: { mood: 'suspenseful', colors: ['#4a90e2', '#1a1a1a'], text: 'Rising Tension' },
          triumph: { mood: 'epic', colors: ['#9b59b6', '#e74c3c'], text: 'Docking Climax' },
          reflection: { mood: 'serene', colors: ['#f39c12', '#1a1a1a'], text: 'Eternal Space' },
          chaos: { mood: 'chaotic', colors: ['#ff0000', '#000000'], text: 'Reality Fractures' },
          dimensional: { mood: 'transcendent', colors: ['#00ffff', '#ff00ff'], text: 'No Time for Caution' },
          void: { mood: 'healing', colors: ['#9370db', '#0a0a0a'], text: 'Vacuum Silence' }
        };
        
        // AUDIO SYSTEM - Enhanced for cinematic depth
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.basePositions = {};
        this.layerPositions = {};
        this.layerTargets = {};
        this.layerPanScales = {
          kick: 0.1, bass: 0.2, hihat: 0.8, snare: 0.3,
          ostinato: 1.2, harmony: 1.5, pad: 2.0, atmosphere: 3.0,
          strings: 1.8, brass: 1.0, choir: 2.5, shepard: 3.5,
          healing: 2.5, granular: 2.0, risers: 2.5, impacts: 0.5,
          breath: 1.0, whisper: 1.5
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.lowBoost = null;
        this.saturator = null;
        this.shepardGain = null;
        this.ostinatoGain = null;
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Techniques
        this.shepardTones = []; 
        this.ostinatoPattern = [0,7,12,15,12,7,12,15]; // Adapted to Interstellar organ ostinato (Am arpeggio)
        this.ostinatoIndex = 0;
        this.shepardIntensity = 0;
        this.tensionBuildup = 0;
        this.glitchProbability = 0;
        
        // Voice Pool - Adjusted for new layers
        this.voicePool = {
          kick: { max: 3, active: [] },
          bass: { max: 4, active: [] },
          hihat: { max: 6, active: [] }, // Used for ticking
          snare: { max: 3, active: [] },
          ostinato: { max: 8, active: [] },
          harmony: { max: 12, active: [] },
          pad: { max: 10, active: [] },
          atmosphere: { max: 6, active: [] },
          strings: { max: 16, active: [] }, 
          brass: { max: 8, active: [] },
          choir: { max: 12, active: [] },
          shepard: { max: 6, active: [] },
          healing: { max: 4, active: [] },
          granular: { max: 8, active: [] },
          risers: { max: 2, active: [] },
          impacts: { max: 2, active: [] },
          breath: { max: 2, active: [] },
          whisper: { max: 4, active: [] }
        };
        
        // Layers - Adapted for Interstellar (hihat as ticking)
        this.layers = {
          kick: false, bass: false, hihat: false, snare: false,
          ostinato: false, harmony: false, pad: false, atmosphere: false,
          strings: false, brass: false, choir: false, shepard: false,
          healing: false, granular: false, risers: false, impacts: false,
          breath: false, whisper: false
        };
        
        // Musical Elements - Adapted progressions
        this.key = 'Ab';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11, 'Ab':8};
        this.mode = 'major';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          pentatonic: [0, 2, 4, 7, 9],
          blues: [0, 3, 5, 6, 7, 10],
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          wholeTone: [0, 2, 4, 6, 8, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [5,9,0,2,7],  // IV D♭6/9
          [7,11,2,4], // V E Good, examples:

- Time After Time by Cyndi Lauper: uses IV V iii vi? Wait, Time After Time is in C: F G Em Am — IV V iii vi

Yes, F=IV, G=V, Em=iii, Am=vi

Wait, that's IV V iii vi

User wants IV V vi iii, which is F G Am Em in C.

Swapped.

But close.

Other: Robo's Theme from Chrono Trigger: F-G-Em-Am which is IV V iii vi in C.

Too Much Heaven Bee Gees.

Beautiful Day by Ballyhoo!

Milla by Netinho.

Stairway To Heaven after solo Am-Am-F-G ? Wait, Am F G, but that's i VI VII in A min.

Not the same.

The Trooper Em C Em D Em — i VI i VII i in E min.

Not.

So mainly IV V iii vi examples.

But since almost same as user's, just order of last two swapped.

Now, for inspiration: these songs use it in chorus often, looping.

For the engine, since it's interactive, perhaps the progression cycles with motion.

To make music completely different, perhaps change the layers or patterns.

But user says "the music to be completely different" but locked to this.

Perhaps change the ostinato to arpeggio based on the new chords.

Original ostinato [0,7,12,15,12,7,12,15] — root,5,root', min3', etc.

To make different, perhaps change to something like in Dilemma or Time After Time rhythm.

But since code is synth, not real songs.

Also, bpm=96 originally, perhaps change.

But main is change key, mode, chords.

For ostinato, perhaps make it arpeggio of the progression or something.

User says "pull inspiration on how the engine will use the other options if these are not enough"

Perhaps meaning if the 4 chords not enough, use variations from inspirations.

But I think to implement, I need to modify the JS code.

To output the new HTML with changed code.

First, add 'Ab':8 to keyOffsets.

Set this.key = 'Ab';

this.mode = 'major';

this.scale = this.scales.major;

Then, chordProgression = [

  [5,9,0,2,7], // IV Db6/9

  [7,11,2,4], // V Eb6 with optional Bb, I include 2=Bb

  [9,0,4,7,11], // vi Fm11

  [0,4,7,11] // iii/I Cm/Ab = Ab maj7 no5? Ab C Eb G

]

For V, user said [E♭, G, C] optionally Bb, but to make it chord, include Bb.

Perhaps [7,11,4] without, but add 2.

Let's follow user: for V [E♭, G, C] so [7,11,4]

But C=4+12.

In code, intervals can be >11, but original are mod12.

Original has 0,3,7 all <12.

But in playHarmony, noteToFreq(interval, 3 + i%2), so interval can be high.

But to match, perhaps keep mod12.

For higher notes, they use higher octave in voicing.

But since 4 <11, but for C in Ab, C is 4, but if voicing is Eb=7 (low), G=11, C=16=4+12

So in array [7,11,4], and in playHarmony, freq = noteToFreq(4, 3 + 2%2=3+0=3), but to have higher, perhaps order the array from low to high.

In original, [8,0,3] for VI, 8=F,0=A(+12),3=C(+12), and in play [interval, 3 + i%2] so first interval8 octave3 or4, etc.

It works as is.

So for IV: user [Db, F, Ab, Bb, Eb] =5,9,0(+12),2(+12),7(+12)

So array [5,9,0,2,7]

For V: let's include optional Bb, [Eb, G, Bb, C] =7,11,2(+12),4(+12) [7,11,2,4]

For vi: [F, Ab, C, Eb, G] =9,0(+12),4(+12),7(+12),11(+12) [9,0,4,7,11]

For iii: [Ab, C, Eb, G] =0,4,7,11 [0,4,7,11]

Yes.

For ostinato, to make different, perhaps change to a different pattern.

Inspired by Interstellar, but to make different, perhaps inspired by one of these songs.

But since Interstellar is already, and user wants different, perhaps change bpm, or layers.

But I think main change is key and progression.

Also, original keyDisplay "D MIN", change to Ab maj.

Original key='A', but display "D MIN"? No, "D MIN" is default, but code sets key='A'

In HTML: <span id="keyDisplay">D MIN</span> but in code this.key = 'A'; this.mode = 'minor';

Perhaps placeholder.

In init, it sets keyDisplay to `${this.key} ${this.mode.toUpperCase()}` later? In updateFromEnvironment, but initially D MIN.

Anyway.

To lock, perhaps remove the phraseStructure or something, but since progression is 4 chords, and currentChordIndex ++ % length each 32 steps? No, each sectionLength=32, but phraseCount++, chordIndex ++ %length when step==0, but phraseCount %4 ? No.

this.step ++ % sectionLength=32

if step==0: phraseCount++, phrase=phraseStructure[phraseCount%length], currentChordIndex ++ %length

So cycles through the 4 chords every 32 steps.

phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F']; but not used for chords.

Chords cycle independently.

To lock, perhaps it's already locked to the progression.

To make completely different, perhaps change the ostinato to something else.

Original ostinato inspired by Interstellar in Am: A C E or something? Wait, [0,7,12,15] 0=root A,7=E P5,12=A,15=C min3 above.

So arpeggio A E A C

To change, perhaps make it arpeggio of the first chord or something.

Inspired from Dilemma, which has a harp arpeggio or something.

Dilemma in G major? Wait, actually Dilemma is in Bb major I think, but progression Gm Eb F Dm — wait no.

Dilemma key is G minor? Wait, let's think.

To confirm, use tool to search "chord progression of Dilemma by Nelly"

Use web_search "what is the chord progression in Dilemma by Nelly"

To get inspiration.<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Interstellar Docking Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.tribal {
      background: radial-gradient(circle, #ff6b35 0%, rgba(255,107,53,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,107,53,0.7);
    }
    
    .orb.orchestral {
      background: radial-gradient(circle, #4a90e2 0%, rgba(74,144,226,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(74,144,226,0.7);
    }
    
    .orb.transcendent {
      background: radial-gradient(circle, #9b59b6 0%, #e74c3c 40%, #f39c12 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(155,89,182,0.8);
      animation: transcend 3s ease-in-out infinite;
    }
    
    .orb.dimensional {
      background: radial-gradient(circle, #00ffff 0%, #ff00ff 25%, #ffff00 50%, #00ff00 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(0,255,255,1);
      filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
    }
    
    .orb.void {
      background: radial-gradient(circle, #9370db 0%, rgba(147,112,219,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(147,112,219,0.4);
      filter: drop-shadow(0 0 20px rgba(147,112,219,0.2));
      animation: voidBreathe 3s ease-in-out infinite;
    }
    
    @keyframes transcend {
      0%, 100% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(1.4); }
    }
    
    @keyframes voidBreathe {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #4a90e2, #9b59b6);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,255,255,0.8), rgba(255,255,255,0.2));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">TECHNIQUE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">SHEPARD TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="shepardBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">60</span></div>
      <div class="metric">KEY: <span id="keyDisplay">Ab MAJ</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class VoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Musical Structure
        this.bpm = 96;
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D', 'E', 'F'];
        this.sectionLength = 32;
        
        // Motion & Position
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'calm';
        this.stepCounter = 0;
        this.lastStepTime = 0;
        this.lastMotionTime = Date.now();
        
        // Gesture Recognition
        this.gestureRecognition = {
          shake: 0,
          spiral: 0,
          tap: 0,
          sustained: 0,
          chaos: 0,
          wave: 0
        };
        
        // Evolution System
        this.stage = 'SILENCE';
        this.subStage = 0;
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.buildPhase = false;
        this.releasePhase = false;
        this.climaxPhase = false;
        this.dimensionalPhase = false;
        this.voidPhase = false;
        this.currentTechnique = 'waiting';
        this.transposition = 0;
        
        // Cinematic Themes (Adapted to Interstellar)
        this.currentTheme = 'awakening';
        this.themes = {
          awakening: { mood: 'mysterious', colors: ['#1a1a1a', '#2a2a2a'], text: 'Into the Void' },
          adventure: { mood: 'heroic', colors: ['#ff6b35', '#1a1a1a'], text: 'Ticking Begins' },
          tension: { mood: 'suspenseful', colors: ['#4a90e2', '#1a1a1a'], text: 'Rising Tension' },
          triumph: { mood: 'epic', colors: ['#9b59b6', '#e74c3c'], text: 'Docking Climax' },
          reflection: { mood: 'serene', colors: ['#f39c12', '#1a1a1a'], text: 'Eternal Space' },
          chaos: { mood: 'chaotic', colors: ['#ff0000', '#000000'], text: 'Reality Fractures' },
          dimensional: { mood: 'transcendent', colors: ['#00ffff', '#ff00ff'], text: 'No Time for Caution' },
          void: { mood: 'healing', colors: ['#9370db', '#0a0a0a'], text: 'Vacuum Silence' }
        };
        
        // AUDIO SYSTEM - Enhanced for cinematic depth
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerPanners = {};
        this.basePositions = {};
        this.layerPositions = {};
        this.layerTargets = {};
        this.layerPanScales = {
          kick: 0.1, bass: 0.2, hihat: 0.8, snare: 0.3,
          ostinato: 1.2, harmony: 1.5, pad: 2.0, atmosphere: 3.0,
          strings: 1.8, brass: 1.0, choir: 2.5, shepard: 3.5,
          healing: 2.5, granular: 2.0, risers: 2.5, impacts: 0.5,
          breath: 1.0, whisper: 1.5
        };
        this.panningLerp = 0.02;
        this.listener = null;
        this.convolver = null;
        this.delay = null;
        this.compressor = null;
        this.lowBoost = null;
        this.saturator = null;
        this.shepardGain = null;
        this.ostinatoGain = null;
        
        // Spatial Orientation
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        // Techniques
        this.shepardTones = []; 
        this.ostinatoPattern = [0,7,12,15,12,7,12,15]; // Adapted to Interstellar organ ostinato (Am arpeggio)
        this.ostinatoIndex = 0;
        this.shepardIntensity = 0;
        this.tensionBuildup = 0;
        this.glitchProbability = 0;
        
        // Voice Pool - Adjusted for new layers
        this.voicePool = {
          kick: { max: 3, active: [] },
          bass: { max: 4, active: [] },
          hihat: { max: 6, active: [] }, // Used for ticking
          snare: { max: 3, active: [] },
          ostinato: { max: 8, active: [] },
          harmony: { max: 12, active: [] },
          pad: { max: 10, active: [] },
          atmosphere: { max: 6, active: [] },
          strings: { max: 16, active: [] }, 
          brass: { max: 8, active: [] },
          choir: { max: 12, active: [] },
          shepard: { max: 6, active: [] },
          healing: { max: 4, active: [] },
          granular: { max: 8, active: [] },
          risers: { max: 2, active: [] },
          impacts: { max: 2, active: [] },
          breath: { max: 2, active: [] },
          whisper: { max: 4, active: [] }
        };
        
        // Layers - Adapted for Interstellar (hihat as ticking)
        this.layers = {
          kick: false, bass: false, hihat: false, snare: false,
          ostinato: false, harmony: false, pad: false, atmosphere: false,
          strings: false, brass: false, choir: false, shepard: false,
          healing: false, granular: false, risers: false, impacts: false,
          breath: false, whisper: false
        };
        
        // Musical Elements - Adapted progressions
        this.key = 'Ab';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11, 'Ab':8};
        this.mode = 'major';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          dorian: [0, 2, 3, 5, 7, 9, 10],
          phrygian: [0, 1, 3, 5, 7, 8, 10],
          lydian: [0, 2, 4, 6, 7, 9, 11],
          mixolydian: [0, 2, 4, 5, 7, 9, 10],
          locrian: [0, 1, 3, 5, 6, 8, 10],
          pentatonic: [0, 2, 4, 7, 9],
          blues: [0, 3, 5, 6, 7, 10],
          chromatic: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],
          wholeTone: [0, 2, 4, 6, 8, 10]
        };
        this.scale = this.scales[this.mode];
        this.chordProgression = [
          [5,9,0,2,7],  // IV D♭6/9
          [7,11,2,4], // V E♭6 with B♭
          [9,0,4,7,11],  // vi Fmin11
          [0,4,7,11]  // iii Cmin over A♭
        ];
        this.currentChordIndex = 0;
        this.bassNote = 0;
        this.lastLeadFreq = 293.66; 
        
        this.elements = {};
        this.spectrumBars = [];
        
        // Procedural Noise for Fractal Echo Veil
        this.noiseSource = null;
        this.noiseFilter = null;
        this.noiseGain = null;

        // Easter Eggs
        this.easterEggs = {
          konamiSequence: [],
          goldenRatio: false,
          perfectCircle: false,
          chaosAttractor: false,
          fibonacciSpiral: false,
          shepardInfinity: false,
          harmonicWave: false
        };
        
        this.specialEvents = {
          glitchStorm: 0,
          timeDilation: 0,
          dimensionalRift: 0,
          harmonicResonance: 0
        };

        // Environment
        this.weather = null;
        this.dayOfWeek = new Date().getDay();
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'shepardBar', 'bpmDisplay',
         'keyDisplay', 'voiceCount', 'cinematicOverlay', 'themeText', 'spectrumViz', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
      }

      setupSpectrumVisualizer() {
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 1.5625}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
      }

      setupInteractionListeners() {
        let touchSequence = [];
        
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.touches[0].clientX, y: e.touches[0].clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          touchSequence.push({ x: e.clientX, y: e.clientY, time: Date.now() });
          this.analyzeGesture(touchSequence);
        });

        setInterval(() => {
          const now = Date.now();
          touchSequence = touchSequence.filter(touch => now - touch.time < 5000);
        }, 2000);

        // Konami Code listener
        let konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight', 'KeyB', 'KeyA'];
        let konamiIndex = 0;
        
        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === konamiCode[konamiIndex]) {
            konamiIndex++;
            if (konamiIndex === konamiCode.length) {
              this.triggerKonamiEasterEgg();
              konamiIndex = 0;
            }
          } else {
            konamiIndex = 0;
          }
        });
      }

      analyzeGesture(sequence) {
        if (sequence.length < 3) return;
        
        const recent = sequence.slice(-10);
        const distances = [];
        const angles = [];
        
        for (let i = 1; i < recent.length; i++) {
          const dx = recent[i].x - recent[i-1].x;
          const dy = recent[i].y - recent[i-1].y;
          distances.push(Math.sqrt(dx*dx + dy*dy));
          angles.push(Math.atan2(dy, dx));
        }
        
        // Spiral detection
        let angleSum = 0;
        for (let i = 1; i < angles.length; i++) {
          let diff = angles[i] - angles[i-1];
          if (diff > Math.PI) diff -= 2 * Math.PI;
          if (diff < -Math.PI) diff += 2 * Math.PI;
          angleSum += diff;
        }
        
        if (Math.abs(angleSum) > Math.PI * 2) {
          this.gestureRecognition.spiral += 0.3;
          if (this.gestureRecognition.spiral > 1 && !this.easterEggs.fibonacciSpiral) {
            this.triggerFibonacciSpiral();
          }
        }
        
        // Decay gestures
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.01);
        });
      }

      triggerKonamiEasterEgg() {
        console.log('🎮 KONAMI CODE ACTIVATED: God Mode Engaged');
        this.specialEvents.dimensionalRift = 2;
        this.bpm *= 1.5;
        this.layers.granular = true;
        this.currentTheme = 'chaos';
        this.evolveToDimensional();
        this.flashImpact();
      }

      triggerFibonacciSpiral() {
        console.log('🌀 FIBONACCI SPIRAL DETECTED: Golden Ratio Harmony');
        this.easterEggs.fibonacciSpiral = true;
        this.layers.shepard = true;
        this.shepardIntensity = 1;
        this.playGoldenRatioChord();
      }

      flashImpact() {
        this.elements.impactFlash.classList.add('active');
        setTimeout(() => this.elements.impactFlash.classList.remove('active'), 150);
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          if (e.alpha !== null) {
            this.orientation.alpha = e.alpha;
            this.orientation.beta = e.beta;
            this.orientation.gamma = e.gamma;
            this.updateListenerOrientation();
          }
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;

        const alphaRad = this.orientation.alpha * Math.PI / 180;
        const betaRad = this.orientation.beta * Math.PI / 180;
        const gammaRad = this.orientation.gamma * Math.PI / 180;

        const forwardX = Math.cos(alphaRad) * Math.cos(betaRad);
        const forwardY = Math.sin(alphaRad) * Math.cos(betaRad);
        const forwardZ = Math.sin(betaRad);

        const upX = -Math.cos(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) - Math.sin(alphaRad) * Math.cos(gammaRad);
        const upY = -Math.sin(alphaRad) * Math.sin(betaRad) * Math.sin(gammaRad) + Math.cos(alphaRad) * Math.cos(gammaRad);
        const upZ = Math.cos(betaRad) * Math.sin(gammaRad);

        this.listener.forwardX.value = forwardX;
        this.listener.forwardY.value = forwardY;
        this.listener.forwardZ.value = forwardZ;
        this.listener.upX.value = upX;
        this.listener.upY.value = upY;
        this.listener.upZ.value = upZ;
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const motionPermission = await DeviceMotionEvent.requestPermission();
            if (motionPermission !== 'granted') {
              console.log('Motion permission not granted, continuing with mouse input');
            }
          }

          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            const orientationPermission = await DeviceOrientationEvent.requestPermission();
            if (orientationPermission !== 'granted') {
              console.log('Orientation permission not granted');
            }
          }

          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setLayerPositions();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'BE STILL OR MOVE TO AWAKEN';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.startSequencer();
          this.animate();
          
          // Get environment data
          this.fetchEnvironmentData();
          
        } catch (e) {
          console.error('Failed to start engine:', e);
          alert('Failed to initialize. Please try again.');
        }
      }

      fetchEnvironmentData() {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            fetch(`https://api.open-meteo.com/v1/forecast?latitude=${pos.coords.latitude}&longitude=${pos.coords.longitude}&current_weather=true`)
              .then(res => res.json())
              .then(data => {
                this.weather = data.current_weather;
                this.updateFromEnvironment();
              })
              .catch(err => console.error('Weather fetch error:', err));
          },
          (err) => console.error('Geolocation error:', err),
          { enableHighAccuracy: true }
        );
      }

      updateFromEnvironment() {
        if (this.weather) {
          const temp = this.weather.temperature;
          const weatherCode = this.weather.weathercode;

          // Influence BPM based on temperature
          this.bpm += (temp - 15) * 0.5;
          this.bpm = Math.max(40, Math.min(180, this.bpm));

          // Weather code influence
          if (weatherCode >= 61 && weatherCode <= 67) { // Rain
            this.layers.atmosphere = true;
            this.convolver.buffer = this.createReverbBuffer(8);
            this.currentTheme = 'tension';
          } else if (weatherCode <= 3) { // Clear
            this.currentTheme = 'adventure';
            this.layers.pad = true;
          } else if (weatherCode >= 71 && weatherCode <= 77) { // Snow
            this.layers.choir = true;
            this.currentTheme = 'reflection';
          }

          // Adjust intensity based on wind
          this.intensity += this.weather.windspeed / 20;
        }

        // Day of week influence
        const days = ['minor', 'major', 'dorian', 'phrygian', 'lydian', 'mixolydian', 'locrian'];
        this.mode = days[this.dayOfWeek];
        this.scale = this.scales[this.mode];

        const keys = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
        this.key = keys[this.dayOfWeek];

        this.elements.keyDisplay.textContent = `${this.key} ${this.mode.toUpperCase()}`;
      }

      createReverbBuffer(time) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 3);
            data[i] = (Math.random() * 2 - 1) * decay * 0.3;
          }
        }
        return buffer;
      }

      makeDistortionCurve(amount) {
        const k = amount;
        const n = 22050;
        const curve = new Float32Array(n);
        const deg = Math.PI / 180;
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
        return curve;
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 128;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -3;
        this.limiter.knee.value = 1;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.001;
        this.limiter.release.value = 0.01;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.65;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 12;
        this.compressor.ratio.value = 4;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        
        this.lowBoost = this.ctx.createBiquadFilter();
        this.lowBoost.type = 'lowshelf';
        this.lowBoost.frequency.value = 120;
        this.lowBoost.gain.value = 3;
        
        this.saturator = this.ctx.createWaveShaper();
        this.saturator.curve = this.makeDistortionCurve(3);
        this.saturator.oversample = '4x';
        
        this.listener = this.ctx.listener;
        this.listener.positionX.value = 0;
        this.listener.positionY.value = 0;
        this.listener.positionZ.value = 0;
        
        this.convolver = this.ctx.createConvolver();
        this.convolver.buffer = this.createReverbBuffer(6);
        
        this.delay = this.ctx.createDelay(0.8);
        this.delay.delayTime.value = 0.375;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.35;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.25;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // Layer setup with updated levels and new layers
        const layerNames = ['kick', 'bass', 'hihat', 'snare', 'ostinato', 'harmony', 'pad', 
                           'atmosphere', 'strings', 'brass', 'choir', 'shepard', 'healing',
                           'granular', 'risers', 'impacts', 'breath', 'whisper'];
        const layerLevels = [0.8, 0.7, 0.15, 0.4, 0.25, 0.2, 0.18, 
                            0.12, 0.3, 0.25, 0.2, 0.15, 0.08,
                            0.2, 0.3, 0.5, 0.1, 0.1]; 
        
        layerNames.forEach((name, i) => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];

          this.layerPanners[name] = this.ctx.createPanner();
          this.layerPanners[name].panningModel = 'HRTF';
          this.layerPanners[name].distanceModel = 'inverse';
          this.layerPanners[name].refDistance = 1;
          this.layerPanners[name].maxDistance = 10000;
          this.layerPanners[name].rolloffFactor = 1.0;
          this.layerPanners[name].coneInnerAngle = 360;
          this.layerPanners[name].coneOuterAngle = 0;
          this.layerPanners[name].coneOuterGain = 0;

          this.layerPositions[name] = {x: 0, y: 0, z: 0};
          this.basePositions[name] = {x: 0, y: 0, z: 0};
          this.layerTargets[name] = {x: 0, y: 0, z: 0};

          this.layerGains[name].connect(this.layerPanners[name]);
          this.layerPanners[name].connect(this.compressor);

          // Selective reverb sends - added breath and whisper
          if (['strings', 'brass', 'choir', 'harmony', 'pad', 'atmosphere', 'kick', 'snare', 'healing', 'breath', 'whisper'].includes(name)) {
            this.layerGains[name].connect(this.convolver);
          }
          
          // Selective delay sends
          if (['ostinato', 'strings', 'snare', 'brass', 'whisper'].includes(name)) {
            this.layerGains[name].connect(this.delay);
          }
        });
        
        this.shepardGain = this.ctx.createGain();
        this.shepardGain.gain.value = 0.15;
        this.ostinatoGain = this.ctx.createGain();
        this.ostinatoGain.gain.value = 0.25;
        
        // Audio chain connections
        this.compressor.connect(this.lowBoost);
        this.lowBoost.connect(this.saturator);
        this.saturator.connect(this.limiter);
        this.convolver.connect(this.limiter);
        delayMix.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
        
        this.setupProceduralNoise();
      }

      setupProceduralNoise() {
        const bufferSize = 2 * this.ctx.sampleRate;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }

        this.noiseSource = this.ctx.createBufferSource();
        this.noiseSource.buffer = buffer;
        this.noiseSource.loop = true;

        this.noiseFilter = this.ctx.createBiquadFilter();
        this.noiseFilter.type = 'bandpass';
        this.noiseFilter.frequency.value = 1000;
        this.noiseFilter.Q.value = 10;

        this.noiseGain = this.ctx.createGain();
        this.noiseGain.gain.value = 0.04;

        this.noiseSource.connect(this.noiseFilter);
        this.noiseFilter.connect(this.noiseGain);
        this.noiseGain.connect(this.layerPanners.atmosphere);
        this.noiseSource.start();
      }

      updateProceduralNoise(avgMotion, variance) {
        this.noiseFilter.frequency.value = 300 + avgMotion * 100 + variance * 50;
        this.noiseFilter.Q.value = 5 + variance * 2;
        this.noiseGain.gain.value = 0.05 + (this.shepardIntensity * 0.1);
      }

      setLayerPositions() {
        const positions = {
          kick: {x: 0, y: 0, z: -2},
          bass: {x: 0, y: -1, z: -3},
          hihat: {x: 0, y: 1, z: -4},
          snare: {x: 0, y: 0, z: -1},
          ostinato: {x: -2, y: 0, z: -5},
          harmony: {x: 2, y: 0, z: -5},
          pad: {x: 0, y: 2, z: 5},
          atmosphere: {x: 0, y: 3, z: 10},
          strings: {x: -5, y: 0, z: -6},
          brass: {x: 5, y: 0, z: -6},
          choir: {x: 0, y: 2, z: 8},
          shepard: {x: 0, y: 4, z: -10},
          healing: {x: 0, y: 5, z: 15},
          granular: {x: -8, y: 2, z: -10},
          risers: {x: 0, y: 6, z: -20},
          impacts: {x: 0, y: -3, z: -1},
          breath: {x: 0, y: 0, z: 0},
          whisper: {x: 3, y: 1, z: -2}
        };

        Object.keys(positions).forEach(name => {
          const pos = positions[name];
          this.basePositions[name] = {...pos};
          this.layerPositions[name] = {...pos};
          this.layerTargets[name] = {...pos};
          if (this.layerPanners[name]) {
            this.layerPanners[name].positionX.value = pos.x;
            this.layerPanners[name].positionY.value = pos.y;
            this.layerPanners[name].positionZ.value = pos.z;
          }
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.6;
          this.updateMotion(newMotion);
          
          this.velocity.x += acc.x * 0.015;
          this.velocity.y += acc.y * 0.015;
          this.updatePosition();
          
          this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
          
          if (newMotion > 4 && Date.now() - this.lastStepTime > 250) {
            this.stepCounter++;
            this.lastStepTime = Date.now();
            this.syncBPMToSteps();
          }
          
          // Enhanced gesture detection
          if (newMotion > 8) {
            this.gestureRecognition.shake += 0.3;
            if (this.gestureRecognition.shake > 2) {
              this.triggerShakeEffects();
            }
          }
          
          this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
        });

        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 100;
          const velocityY = (newY - lastMouse.y) / dt * 100;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.15;
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          this.orientation.alpha = (newX / 100) * 360;
          this.orientation.beta = (newY - 50) * 1.8;
          this.orientation.gamma = 0;
          this.updateListenerOrientation();
          
          lastMouse = { x: newX, y: newY, time: now };
        });
      }

      updateMotion(newMotion) {
        this.motion = this.motion * 0.8 + newMotion * 0.2;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 150) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        // Track last motion for void state
        if (this.motion > 0.5) {
          this.lastMotionTime = Date.now();
          if (this.voidPhase) {
            this.exitVoidState();
          }
        }
        
        // Enter void state after 5 seconds of no motion
        if (Date.now() - this.lastMotionTime > 5000 && !this.voidPhase) {
          this.enterVoidState();
        }
        
        if (!this.firstMovement && this.motion > 1.5) {
          this.firstMovement = true;
          this.evolveToTribal();
        }
        
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        this.intensity = this.motionHistory.reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / this.motionHistory.length;
        
        const variance = this.intensity;
        const recentHistory = this.motionHistory.slice(-40);
        const isRhythmic = recentHistory.filter(m => m > 2.5).length > 20 && variance < 2;
        const isErratic = variance > 2.5 && avgMotion > 2;
        const isSustained = avgMotion > 2.5 && variance < 1.5;
        const isChaotic = variance > 4 && avgMotion > 4;
        this.motionPattern = isChaotic ? 'chaotic' : isErratic ? 'erratic' : isRhythmic ? 'rhythmic' : isSustained ? 'sustained' : 'calm';
        
        this.updateTechniques(avgMotion, variance);
        this.updateEvolution();
        
        // Update procedural noise
        this.updateProceduralNoise(avgMotion, variance);
      }

      enterVoidState() {
        console.log('🌌 ENTERING VOID STATE: Healing Frequencies Activated');
        this.voidPhase = true;
        this.stage = 'VOID';
        this.elements.orb.className = 'orb void';
        this.currentTheme = 'void';
        
        // Fade out all active layers
        Object.keys(this.layerGains).forEach(layer => {
          this.layerGains[layer].gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        });
        Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
        
        // Play void ambience
        this.playVoidAmbience();
        
        // Show theme text
        this.elements.themeText.textContent = this.themes.void.text;
        this.elements.themeText.classList.add('visible');
        setTimeout(() => this.elements.themeText.classList.remove('visible'), 5000);
      }

      exitVoidState() {
        console.log('🌌 EXITING VOID STATE: Returning to Motion');
        this.voidPhase = false;
        this.stage = this.stage === 'VOID' ? 'SILENCE' : this.stage; // Reset to silence or previous
        this.elements.orb.className = 'orb'; // Reset orb class
        this.currentTheme = 'awakening';
        
        // Fade out void sounds
        this.layerGains.healing.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        
        // Re-enable layers based on motion
        this.updateEvolution();
      }

      playVoidAmbience() {
        // Healing pad with binaural beats for depth
        const duration = 20;
        const now = this.ctx.currentTime;
        
        for (let i = 0; i < 3; i++) {
          const oscLeft = this.ctx.createOscillator();
          const gainLeft = this.ctx.createGain();
          const filterLeft = this.ctx.createBiquadFilter();
          
          oscLeft.type = 'sine';
          oscLeft.frequency.value = 110 * Math.pow(2, i / 4);
          
          filterLeft.type = 'lowpass';
          filterLeft.frequency.value = 400;
          filterLeft.Q.value = 0.5;
          
          gainLeft.gain.setValueAtTime(0, now);
          gainLeft.gain.linearRampToValueAtTime(0.05, now + 5);
          gainLeft.gain.setValueAtTime(0.05, now + duration - 5);
          gainLeft.gain.linearRampToValueAtTime(0, now + duration);
          
          oscLeft.connect(filterLeft).connect(gainLeft).connect(this.convolver);
          gainLeft.connect(this.masterGain);
          this.layerPanners.healing.positionX.value = -1;
          
          oscLeft.start(now);
          oscLeft.stop(now + duration);
          
          const oscRight = this.ctx.createOscillator();
          const gainRight = this.ctx.createGain();
          const filterRight = this.ctx.createBiquadFilter();
          
          oscRight.type = 'sine';
          oscRight.frequency.value = 110 * Math.pow(2, i / 4) + 0.5; // Slight detune for binaural
        
          filterRight.type = 'lowpass';
          filterRight.frequency.value = 400;
          filterRight.Q.value = 0.5;
          
          gainRight.gain.setValueAtTime(0, now);
          gainRight.gain.linearRampToValueAtTime(0.05, now + 5);
          gainRight.gain.setValueAtTime(0.05, now + duration - 5);
          gainRight.gain.linearRampToValueAtTime(0, now + duration);
          
          oscRight.connect(filterRight).connect(gainRight).connect(this.convolver);
          gainRight.connect(this.masterGain);
          this.layerPanners.healing.positionX.value = 1;
          
          oscRight.start(now);
          oscRight.stop(now + duration);
        }
        
        // Continue void ambience if still in void state
        if (this.voidPhase && this.active) {
          setTimeout(() => this.playVoidAmbience(), 15000);
        }
      }

      playKick() {
        // Cleaner 808-style kick: Single sine with harmonic decay, no click/sub for less overlay, tighter envelope
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const comp = this.ctx.createDynamicsCompressor();
        
        if (!this.allocateVoice('kick', osc, gain, 0.3)) return;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(55 + this.intensity * 5, this.ctx.currentTime); // Reduced intensity impact for clarity
        osc.frequency.exponentialRampToValueAtTime(28, this.ctx.currentTime + 0.3); 
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3); // Tighter tail
        
        comp.threshold.value = -20;
        comp.ratio.value = 8;
        
        gain.gain.value = 1.0;
        
        osc.connect(env).connect(comp).connect(gain).connect(this.layerGains.kick);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
      }

      playBass() {
        const noteIndex = this.bassNote % this.scale.length;
        const freq = this.noteToFreq(this.scale[noteIndex], 1);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('bass', osc, gain, 0.5)) return;
        
        osc.type = 'triangle'; // Changed to triangle for cleaner harmonic content
        osc.frequency.value = freq;
        // Removed subOsc and LFO for less chaos
        
        filter.type = 'lowpass';
        filter.frequency.value = 120 + this.motion * 20; // Reduced modulation for stability
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5); // Shorter decay
        
        gain.gain.value = 0.8;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.bass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      playHihat() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('hihat', noise, gain, 0.05)) return; // Short duration for tick
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.05, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 5000;
        filter.Q.value = 1;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.05);
        
        gain.gain.value = 0.3;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.hihat);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.05);
      }

      playSnare() {
        const osc1 = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('snare', osc1, gain, 0.2)) return;
        
        osc1.type = 'triangle';
        osc1.frequency.setValueAtTime(160 + this.intensity * 10, this.ctx.currentTime); // Reduced intensity
        osc1.frequency.exponentialRampToValueAtTime(80, this.ctx.currentTime + 0.05); // Shorter
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 2000;
        filter.Q.value = 1.5;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2); // Tighter
        
        gain.gain.value = 0.7;
        
        osc1.connect(filter).connect(env).connect(gain).connect(this.layerGains.snare);
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.snare);
        osc1.start();
        noise.start();
        osc1.stop(this.ctx.currentTime + 0.2);
        noise.stop(this.ctx.currentTime + 0.2);
      }

      playOstinato() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(noteIndex, 4);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('ostinato', osc, gain, 0.25)) return; // Shorter for fast 16th
        
        osc.type = 'sawtooth'; // Organ-like
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 800 + this.motion * 50;
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
        
        gain.gain.value = 0.6;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.ostinato);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.25);
        
        this.ostinatoIndex++;
      }

      playHarmony() {
        const chord = this.chordProgression[this.currentChordIndex];
        const duration = 4;
        const baseGain = 0.2 / chord.length;

        chord.forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 3 + i % 2);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('harmony', osc, gain, duration)) return;
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          // Removed detune and LFO for clean harmonics
          
          filter.type = 'lowpass';
          filter.frequency.value = 500 + this.motion * 100; // Reduced
          filter.Q.value = 2;
          
          env.gain.setValueAtTime(0.1, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.8);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          gain.gain.value = baseGain;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.harmony);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        });
      }

      playStrings() {
        const noteIndex = this.ostinatoPattern[this.ostinatoIndex % this.ostinatoPattern.length];
        const freq = this.noteToFreq(noteIndex, 3);
        
        for (let i = 0; i < 3; i++) { // Reduced voices for less overlay
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('strings', osc, gain, 3)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq * (1 + i * 0.001);
          // Removed detune and LFO
          
          filter.type = 'lowpass';
          filter.frequency.value = 600 + this.motion * 100; // Reduced
          filter.Q.value = 4;
          
          env.gain.setValueAtTime(this.buildPhase ? 0.1 : 0.8, this.ctx.currentTime);
          if (this.buildPhase) env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 1.5);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
          
          gain.gain.value = 0.18;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.strings);
          osc.start();
          osc.stop(this.ctx.currentTime + 3);
        }
      }

      playBrass() {
        const note = this.scale[Math.floor(this.scale.length / 2)];
        const freq = this.noteToFreq(note, 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const vibrato = this.ctx.createOscillator();
        
        if (!this.allocateVoice('brass', osc, gain, 3)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        // Removed osc2 for simplicity
        
        vibrato.type = 'sine';
        vibrato.frequency.value = 5;
        vibrato.connect(osc.detune);
        vibrato.start();
        vibrato.stop(this.ctx.currentTime + 3);
        
        filter.type = 'lowpass';
        filter.frequency.value = 600 + this.intensity * 200; // Reduced
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(0.1, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 1.5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.brass);
        osc.start();
        osc.stop(this.ctx.currentTime + 3);
      }

      playChoir() {
        this.chordProgression[this.currentChordIndex].forEach((interval, i) => {
          const freq = this.noteToFreq(interval, 4 + i % 2);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('choir', osc, gain, 15)) return;
          
          osc.type = 'triangle';
          osc.frequency.value = freq;
          // Removed random and LFO
          
          filter.type = 'lowpass';
          filter.frequency.value = 1000 + this.motion * 100; // Reduced
          filter.Q.value = 0.8;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 6);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 15);
          
          gain.gain.value = 0.15;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.choir);
          osc.start();
          osc.stop(this.ctx.currentTime + 15);
        });
      }

      playPad() {
        this.scale.forEach((note, i) => {
          if (i % 2 !== 0) return;
          
          const freq = this.noteToFreq(note, 2 + i % 3);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('pad', osc, gain, 12)) return;
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          // Removed osc2
          
          filter.type = 'lowpass';
          filter.frequency.value = 200 + this.motion * 50; // Reduced
          filter.Q.value = 1.0;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 4);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 12);
          
          gain.gain.value = 0.12;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.pad);
          osc.start();
          osc.stop(this.ctx.currentTime + 12);
        });
      }

      playAtmosphere() {
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 5);
        // Removed random octave for consistency
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('atmosphere', osc, gain, 20)) return;
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        filter.type = 'lowpass';
        filter.frequency.value = 100 + 100; // Fixed range
        filter.Q.value = 12;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 20);
        
        gain.gain.value = 0.1;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.atmosphere);
        osc.start();
        osc.stop(this.ctx.currentTime + 20);
        
        this.noiseGain.gain.linearRampToValueAtTime(0.12, this.ctx.currentTime + 4); // Removed random
      }

      playShepardTone() {
        const baseFreq = 200;
        const shepardLayers = 6; // Reduced layers for less chaos
        
        for (let i = 0; i < shepardLayers; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          
          if (!this.allocateVoice('shepard', osc, gain, 4)) return;
          
          const freq = baseFreq * Math.pow(2, i / 2);
          osc.type = 'sine';
          osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
          osc.frequency.exponentialRampToValueAtTime(freq * 1.2, this.ctx.currentTime + 4); // Slower rise for depth
          
          const amplitude = Math.sin((i / shepardLayers) * Math.PI) * this.shepardIntensity;
          
          env.gain.setValueAtTime(amplitude, this.ctx.currentTime);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          gain.gain.value = 0.35;
          
          osc.connect(env).connect(gain).connect(this.layerGains.shepard);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
        }
      }

      playHealingWaves() {
        const baseFreq = 136;
        const duration = 30;
        const leftFreq = baseFreq;
        const rightFreq = baseFreq + 4;

        const oscLeft = this.ctx.createOscillator();
        const gainLeft = this.ctx.createGain();
        const envLeft = this.ctx.createGain();
        
        if (!this.allocateVoice('healing', oscLeft, gainLeft, duration)) return;
        
        oscLeft.type = 'sine';
        oscLeft.frequency.value = leftFreq;
        
        envLeft.gain.setValueAtTime(0, this.ctx.currentTime);
        envLeft.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 5);
        envLeft.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);
        
        gainLeft.gain.value = 0.08;
        
        oscLeft.connect(envLeft).connect(gainLeft).connect(this.layerGains.healing);
        this.layerPanners.healing.positionX.value = -5;
        
        oscLeft.start();
        oscLeft.stop(this.ctx.currentTime + duration);

        const oscRight = this.ctx.createOscillator();
        const gainRight = this.ctx.createGain();
        const envRight = this.ctx.createGain();
        
        if (!this.allocateVoice('healing', oscRight, gainRight, duration)) return;
        
        oscRight.type = 'sine';
        oscRight.frequency.value = rightFreq;
        
        envRight.gain.setValueAtTime(0, this.ctx.currentTime);
        envRight.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 5);
        envRight.gain.linearRampToValueAtTime(0, this.ctx.currentTime + duration);
        
        gainRight.gain.value = 0.08;
        
        oscRight.connect(envRight).connect(gainRight).connect(this.layerGains.healing);
        this.layerPanners.healing.positionX.value = 5;
        
        oscRight.start();
        oscRight.stop(this.ctx.currentTime + duration);
      }

      playGranular() {
        const grainCount = 4 + Math.floor(this.intensity * 2); // Reduced count
        
        for (let i = 0; i < grainCount; i++) {
          setTimeout(() => {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const env = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            if (!this.allocateVoice('granular', osc, gain, 0.25)) return;
            
            osc.type = 'sine';
            osc.frequency.value = 250 + 500 + this.intensity * 100; // Reduced random
            
            filter.type = 'bandpass';
            filter.frequency.value = 1200 + 1500; // Reduced random
            filter.Q.value = 12;
            
            env.gain.setValueAtTime(0, this.ctx.currentTime);
            env.gain.linearRampToValueAtTime(0.35, this.ctx.currentTime + 0.03);
            env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
            
            gain.gain.value = 0.25;
            
            osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.granular);
            osc.start();
            osc.stop(this.ctx.currentTime + 0.25);
          }, i * 25);
        }
      }

      playRiser() {
        const duration = 5 + this.intensity * 3;
        const osc = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('risers', osc, gain, duration)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(2500, this.ctx.currentTime + duration);
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.4;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(120, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(12000, this.ctx.currentTime + duration);
        filter.Q.value = 6;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + duration);
        
        gain.gain.value = 0.4;
        
        osc.connect(filter);
        noise.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.risers);
        
        osc.start();
        noise.start();
        osc.stop(this.ctx.currentTime + duration);
        noise.stop(this.ctx.currentTime + duration);
      }

      playImpact() {
        const freq = 50 + 30; // Reduced random
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('impacts', osc, gain, 1.5)) return;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq * 2.5, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq, this.ctx.currentTime + 0.08);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(freq * 12, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(freq * 3, this.ctx.currentTime + 0.4);
        filter.Q.value = 3;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.3, this.ctx.currentTime + 0.04);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        gain.gain.value = 0.8;
        
        osc.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.impacts);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 1.5);
        
        this.flashImpact();
      }

      playGoldenRatioChord() {
        console.log('✨ GOLDEN RATIO CHORD: Divine Harmony');
        const phi = 1.618033988749;
        const baseFreq = 220;
        const duration = 12;
        
        const ratios = [1, phi, phi * phi, 1 / phi];
        
        ratios.forEach((ratio, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('shepard', osc, gain, duration)) return;
          
          osc.type = 'sine';
          osc.frequency.value = baseFreq * ratio;
          
          filter.type = 'bandpass';
          filter.frequency.value = baseFreq * ratio;
          filter.Q.value = 20;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 3);
          env.gain.setValueAtTime(0.3, this.ctx.currentTime + duration - 3);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + duration);
          
          gain.gain.value = 0.15;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.shepard);
          osc.start();
          osc.stop(this.ctx.currentTime + duration);
        });
        
        this.easterEggs.goldenRatio = true;
      }

      // New human elements

      playBreath() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('breath', noise, gain, 1.5)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 1.5, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(i / noiseData.length, 0.5); // Inhale shape
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 1.2;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.8);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
        
        gain.gain.value = 0.2;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.breath);
        noise.start();
        noise.stop(this.ctx.currentTime + 1.5);
      }

      playWhisper() {
        const noise = this.ctx.createBufferSource();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const mod = this.ctx.createGain();
        
        if (!this.allocateVoice('whisper', noise, gain, 2)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.3;
        }
        noise.buffer = noiseBuffer;
        
        osc.type = 'sine';
        osc.frequency.value = 4; // Fixed for consistency
        osc.connect(mod.gain);
        osc.start();
        osc.stop(this.ctx.currentTime + 2);
        
        filter.type = 'bandpass';
        filter.frequency.value = 2000 + 500; // Reduced random
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.5);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        mod.gain.value = 0.5;
        noise.connect(mod).connect(filter).connect(env).connect(gain).connect(this.layerGains.whisper);
        
        gain.gain.value = 0.15;
        
        noise.start();
        noise.stop(this.ctx.currentTime + 2);
      }

      allocateVoice(layer, source, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) return false;
        
        pool.active = pool.active.filter(voice => {
          if (voice && voice.source && this.ctx.currentTime > voice.startTime + duration + 0.1) {
            voice.source.stop();
            return false;
          }
          return true;
        });
        
        if (pool.active.length >= pool.max) {
          const oldest = pool.active.shift();
          if (oldest && oldest.source) {
            oldest.gain.gain.setValueAtTime(0, this.ctx.currentTime);
            oldest.source.stop(this.ctx.currentTime + 0.01);
          }
        }
        
        const voice = { source, gain: gainNode, startTime: this.ctx.currentTime };
        pool.active.push(voice);
        
        setTimeout(() => {
          const index = pool.active.indexOf(voice);
          if (index !== -1) pool.active.splice(index, 1);
        }, duration * 1000 + 100);
        
        return true;
      }

      updateHarmony() {
        this.bassNote = this.chordProgression[this.currentChordIndex][0];
      }

      noteToFreq(note, octave = 4) {
        const semitones = this.keyOffsets[this.key] + note + this.transposition;
        return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
      }

      updateUI() {
        this.elements.stageName.textContent = this.voidPhase ? 'VOID STATE' : this.stage;
        this.elements.technique.textContent = this.currentTechnique.toUpperCase();
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.keyDisplay.textContent = `${this.key} ${this.mode.toUpperCase()}`;
        
        const motionPercent = Math.min((this.motion + this.intensity) * 10, 100);
        this.elements.motionBar.style.width = motionPercent + '%';
        
        const shepardPercent = this.shepardIntensity * 100;
        this.elements.shepardBar.style.width = shepardPercent + '%';
        
        const totalVoices = Object.values(this.voicePool).reduce((sum, pool) => sum + pool.active.length, 0);
        this.elements.voiceCount.textContent = totalVoices;
        
        if (this.analyser) {
          this.analyser.getByteFrequencyData(this.dataArray);
          this.spectrumBars.forEach((bar, i) => {
            const height = (this.dataArray[i] / 255) * 80;
            bar.style.height = height + 'px';
            
            // Dynamic colors based on stage
            let color = 'rgba(255,255,255,0.8)';
            if (this.voidPhase) color = 'rgba(147,112,219,0.4)';
            else if (this.stage === 'TRIBAL') color = 'rgba(255,107,53,0.8)';
            else if (this.stage === 'ORCHESTRAL') color = 'rgba(74,144,226,0.8)';
            else if (this.stage === 'TRANSCENDENT') color = 'rgba(155,89,182,0.8)';
            else if (this.stage === 'DIMENSIONAL') {
              const hue = (Date.now() / 10 + i * 10) % 360;
              color = `hsla(${hue}, 70%, 50%, 0.8)`;
            }
            
            bar.style.background = `linear-gradient(0deg, ${color}, rgba(255,255,255,0.2))`;
          });
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.elements.orb.style.left = this.pos.x + '%';
          this.elements.orb.style.top = this.pos.y + '%';
          
          if (this.step % 4 === 0) {
            this.updateUI();
          }
          
          const theme = this.themes[this.currentTheme];
          const intensityNorm = Math.min(this.intensity / 4, 1);
          const motionNorm = Math.min(this.motion / 6, 1);
          
          let bg;
          if (this.voidPhase) {
            const breathe = Math.sin(Date.now() / 3000) * 0.5 + 0.5;
            bg = `radial-gradient(circle at 50% 50%, rgba(147, 112, 219, ${0.1 + breathe * 0.1}) 5%, rgba(75, 0, 130, ${0.05 + breathe * 0.05}) 20%, #000000 60%)`;
          } else if (this.dimensionalPhase) {
            const hue = (Date.now() / 20 % 360);
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 70%, ${20 + intensityNorm * 30}%) ${5 * motionNorm}%, hsl(${(hue + 120) % 360}, 70%, ${15 + intensityNorm * 20}%) ${20 * intensityNorm}%, #0a0a0a ${60 + 30 * intensityNorm}%)`;
          } else {
            bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
            bg += `${theme.colors[0]} ${5 * motionNorm}%, `;
            if (theme.colors[1]) bg += `${theme.colors[1]} ${20 * intensityNorm}%, `;
            bg += `#0a0a0a ${60 + 30 * intensityNorm}%`;
            bg += ')';
          }
          
          document.body.style.background = bg;
          
          this.elements.cinematicOverlay.classList.toggle('active', this.buildPhase || this.climaxPhase || this.intensity > 2);
          
          // Update dynamic 3D panning
          const targetX = Math.cos(this.direction * Math.PI / 180) * (this.motion + this.intensity) * 3;
          const targetY = Math.sin(this.direction * Math.PI / 180) * (this.motion + this.intensity) * 3;
          const targetZ = (this.orientation.gamma / 90) * (this.motion + this.intensity) * 2;
          
          Object.keys(this.layerPanners).forEach(name => {
            const scale = this.layerPanScales[name] || 1;
            const tx = this.basePositions[name].x + targetX * scale;
            const ty = this.basePositions[name].y + targetY * scale;
            const tz = this.basePositions[name].z + targetZ * scale;
            
            const pos = this.layerPositions[name];
            pos.x += (tx - pos.x) * this.panningLerp;
            pos.y += (ty - pos.y) * this.panningLerp;
            pos.z += (tz - pos.z) * this.panningLerp;
            
            if (this.layerPanners[name]) {
              this.layerPanners[name].positionX.value = pos.x;
              this.layerPanners[name].positionY.value = pos.y;
              this.layerPanners[name].positionZ.value = pos.z;
            }
          });
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    new VoidEngine();
  </script>
</body>
</html>
