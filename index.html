<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Sonic Unveiling</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 2s ease;
      font-family: 'Courier New', monospace;
      color: rgba(255,255,255,0.3);
    }
    
    body.expansion {
      animation: subtleBirth 6s ease-out forwards;
    }
    @keyframes subtleBirth {
      0% { 
        background: black; 
        transform: scale(0.01); 
        filter: brightness(0);
      }
      20% { 
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, rgba(108,92,231,0.05) 50%, black 100%); 
        transform: scale(0.1); 
        filter: brightness(1.5);
      }
      50% { 
        background: radial-gradient(circle, rgba(108,92,231,0.1) 0%, rgba(253,121,168,0.05) 40%, black 100%); 
        transform: scale(1.2); 
        filter: brightness(1.2);
      }
      100% { 
        background: black; 
        transform: scale(1); 
        filter: brightness(1);
      }
    }
    
    .start-btn {
      padding: 20px 40px;
      background: transparent;
      color: rgba(255,255,255,0.5);
      border: 1px solid rgba(255,255,255,0.2);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 0 0 20px rgba(255,255,255,0.1);
      animation: subtlePulse 3s ease-in-out infinite;
      font-size: 14px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 2px;
      backdrop-filter: blur(5px);
    }
    
    @keyframes subtlePulse { 
      0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 0 20px rgba(255,255,255,0.1);
      } 
      50% { 
        transform: scale(1.1); 
        box-shadow: 0 0 40px rgba(108,92,231,0.2);
      } 
    }
    
    .orb {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.3), transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s ease;
      box-shadow: 0 0 10px rgba(255,255,255,0.2);
    }
    
    .orb.tribal { 
      background: radial-gradient(circle, rgba(255,107,107,0.4) 0%, transparent);
      box-shadow: 0 0 20px rgba(255,107,107,0.3);
      width: 10px; height: 10px;
    }
    
    .orb.orchestral { 
      background: radial-gradient(circle, rgba(78,205,196,0.4) 0%, transparent);
      box-shadow: 0 0 30px rgba(78,205,196,0.3);
      width: 12px; height: 12px;
    }
    
    .orb.heaven { 
      background: radial-gradient(circle, rgba(108,92,231,0.5) 0%, rgba(253,121,168,0.3) 50%, transparent);
      box-shadow: 0 0 40px rgba(108,92,231,0.4);
      width: 14px; height: 14px;
      animation: subtleCosmicPulse 2s ease-in-out infinite;
    }
    
    .orb.pulse {
      animation: subtleBeatPulse 0.3s ease-out;
    }
    
    @keyframes subtleCosmicPulse { 
      0%, 100% { transform: translate(-50%, -50%) scale(1); } 
      50% { transform: translate(-50%, -50%) scale(1.3); } 
    }
    @keyframes subtleBeatPulse { 
      0% { transform: translate(-50%, -50%) scale(1); } 
      50% { transform: translate(-50%, -50%) scale(1.5); } 
      100% { transform: translate(-50%, -50%) scale(1); } 
    }
    
    .message {
      position: absolute;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: rgba(255,255,255,0.3);
      font-size: 16px;
      text-align: center;
      opacity: 0;
      transition: opacity 2s ease;
      text-shadow: 0 0 10px rgba(255,255,255,0.2);
      letter-spacing: 1px;
    }
    
    .message.show { opacity: 1; }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
      opacity: 0.3;
    }
    
    .particle {
      position: absolute;
      border-radius: 50%;
      animation: subtleFloat 10s infinite ease-in-out;
      background: radial-gradient(circle, rgba(255,255,255,0.2), transparent);
      box-shadow: 0 0 5px rgba(255,255,255,0.1);
    }
    
    .particle.tribal { width: 3px; height: 3px; box-shadow: 0 0 8px rgba(255,107,107,0.2); }
    .particle.orchestral { width: 4px; height: 4px; box-shadow: 0 0 10px rgba(78,205,196,0.2); }
    .particle.heaven { width: 5px; height: 5px; box-shadow: 0 0 12px rgba(108,92,231,0.2); }
    
    @keyframes subtleFloat {
      0% { transform: translateY(50vh) scale(0.5); opacity: 0; }
      20% { opacity: 0.5; }
      80% { opacity: 0.5; }
      100% { transform: translateY(-50vh) scale(1.5); opacity: 0; }
    }
    
    .progress-indicator {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.3);
      font-size: 12px;
      text-align: center;
      padding: 5px 10px;
      border-radius: 5px;
      background: rgba(0,0,0,0.2);
      backdrop-filter: blur(3px);
    }
    
    .hidden-ui { opacity: 0; transition: opacity 1s ease; }
  </style>
</head>
<body>
  <button class="start-btn" id="start">UNVEIL</button>
  
  <div class="spatial-viz hidden" id="viz">
    <div class="orb" id="orb"></div>
    <div class="message" id="message">MOVE TO UNCOVER</div>
    
    <div class="progress-indicator hidden-ui" id="progress">
      <div id="stage">PRIMORDIAL</div>
    </div>
  </div>

  <script>
    class SonicUnveiling {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.altitude = 0;
        this.orientation = 0;
        this.weather = { temp: 20, condition: 'clear' }; // Default
        this.bpm = 60;
        this.swing = 0.1;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.section = 'A'; // AABA structure
        this.bar = 0;
        this.beat = 0;
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        this.frameCount = 0;
        
        // Audio chain simplified
        this.masterGain = null;
        this.reverb = null;
        this.delay = null;
        this.compressor = null;
        
        // Evolution stages
        this.evolutionStage = 'PRIMORDIAL';
        this.totalSteps = 0;
        this.firstMovement = false;
        
        // Musical theory
        this.circleOfFifths = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5];
        this.currentFifthPosition = 0;
        this.seventhChords = {
          major7: [0, 4, 7, 11],
          minor7: [0, 3, 7, 10],
          dominant7: [0, 4, 7, 10],
          minor7b5: [0, 3, 6, 10],
          major9: [0, 4, 7, 11, 2],
          minor11: [0, 3, 7, 10, 2, 5],
          dominant13: [0, 4, 7, 10, 2, 6, 9]
        };
        
        this.noteFreqs = {
          0: 65.41, 1: 69.30, 2: 73.42, 3: 77.78, 4: 82.41, 5: 87.31,
          6: 92.50, 7: 98.00, 8: 103.83, 9: 110.00, 10: 116.54, 11: 123.47
        };
        
        this.oscillators = new Set();
        
        // Simplified layers
        this.layerGains = {};
        this.layerStates = {
          subBass: false,
          pulseKick: false,
          harmonics: false,
          fifths: false,
          extensions: false,
          strings: false,
          brass: false,
          choir: false,
          pads: false
        };
        
        this.elements = {};
        this.motionHistory = [];
        
        this.init();
      }

      init() {
        const ids = ['start', 'viz', 'orb', 'message', 'progress', 'stage'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.start.onclick = () => this.start();
        this.setupSensorMonitoring();
      }

      setupSensorMonitoring() {
        if (navigator.geolocation) {
          navigator.geolocation.watchPosition(
            pos => {
              if (pos.coords.altitude !== null) {
                this.altitude = pos.coords.altitude;
                this.fetchWeather(pos.coords.latitude, pos.coords.longitude);
              }
              this.updateSensorDisplay();
            },
            err => console.warn('Geolocation error:', err),
            { enableHighAccuracy: true, maximumAge: 30000 }
          );
        }
      }

      async fetchWeather(lat, lon) {
        // Placeholder for weather API - user to replace with real key
        // Example using OpenWeatherMap: const apiKey = 'YOUR_API_KEY_HERE';
        // const url = `https://api.openweathermap.org/data/2.5/weather?lat=${lat}&lon=${lon}&appid=${apiKey}&units=metric`;
        // try {
        //   const res = await fetch(url);
        //   const data = await res.json();
        //   this.weather = { temp: data.main.temp, condition: data.weather[0].main.toLowerCase() };
        // } catch (e) { console.warn('Weather fetch failed', e); }
        
        // For demo, randomize based on date/time
        this.weather = { 
          temp: 15 + Math.random() * 15, 
          condition: ['clear', 'clouds', 'rain', 'thunderstorm'][Math.floor(Math.random() * 4)] 
        };
        this.adjustForWeather();
      }

      adjustForWeather() {
        // Influence sound based on weather
        let bpmMod = 0;
        let reverbMod = 1;
        switch (this.weather.condition) {
          case 'clear': bpmMod = 10; reverbMod = 0.8; break;
          case 'clouds': bpmMod = -5; reverbMod = 1.2; break;
          case 'rain': bpmMod = -10; reverbMod = 1.5; break;
          case 'thunderstorm': bpmMod = 15; reverbMod = 2; break;
        }
        this.bpm += bpmMod;
        if (this.reverb) this.reverb.buffer = this.createReverbBuffer(reverbMod * 4);
        const tempFactor = (this.weather.temp - 20) / 10;
        this.swing = Math.max(0, 0.1 + tempFactor * 0.05);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            if (await DeviceMotionEvent.requestPermission() !== 'granted') return alert('Motion permission needed');
          }
          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }

          this.ctx = new (AudioContext || webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioChain();

          document.body.classList.add('expansion');
          
          setTimeout(() => {
            document.body.classList.remove('expansion');
            this.elements.start.classList.add('hidden');
            this.elements.viz.classList.remove('hidden');
            
            setTimeout(() => {
              this.elements.message.classList.add('show');
              setTimeout(() => this.elements.message.classList.remove('show'), 3000);
            }, 1000);
            
            this.active = true;
            this.lastMotionTime = Date.now();
            this.startSensors();
            this.startEvolutionLoop();
            this.animate();
            this.monitorTranscendence();
          }, 6000);
          
        } catch (e) {
          console.error(e);
          alert('Failed to start. Try again.');
        }
      }

      setupAudioChain() {
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.7;
        this.masterGain.connect(this.ctx.destination);
        
        this.reverb = this.ctx.createConvolver();
        this.reverb.buffer = this.createReverbBuffer(4);
        
        this.delay = this.ctx.createDelay(0.5);
        this.delay.delayTime.value = 0.25;
        const feedback = this.ctx.createGain();
        feedback.gain.value = 0.3;
        this.delay.connect(feedback);
        feedback.connect(this.delay);
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.ratio.value = 12;
        this.compressor.attack.value = 0.003;
        this.compressor.release.value = 0.25;
        
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.2;
        this.delay.connect(delayMix);
        delayMix.connect(this.compressor);
        this.reverb.connect(this.compressor);
        this.compressor.connect(this.masterGain);
        
        Object.keys(this.layerStates).forEach(layer => {
          this.layerGains[layer] = this.ctx.createGain();
          this.layerGains[layer].gain.value = 0;
          this.layerGains[layer].connect(this.compressor);
        });
      }

      createReverbBuffer(length) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * length, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 2);
          }
        }
        return buffer;
      }

      startSensors() {
        let motionBuffer = [];
        const bufferSize = 20;
        
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity || {};
          const dx = Math.abs((acc.x || 0) - this.last.x);
          const dy = Math.abs((acc.y || 0) - this.last.y);
          const dz = Math.abs((acc.z || 0) - this.last.z);
          
          const rawMotion = Math.sqrt(dx*dx + dy*dy + dz*dz);
          motionBuffer.push(rawMotion);
          if (motionBuffer.length > bufferSize) motionBuffer.shift();
          this.motion = motionBuffer.reduce((a,b) => a+b, 0) / motionBuffer.length;
          this.motionHistory.push(this.motion);
          if (this.motionHistory.length > 120) this.motionHistory.shift();
          
          if (!this.firstMovement && this.motion > 1) {
            this.firstMovement = true;
            this.evolveToTribal();
          }
          if (this.motion > 1) {
            this.lastMotionTime = Date.now();
            this.totalSteps++;
          }
          
          this.velocity.x += (acc.x || 0) * 0.01;
          this.velocity.y += (acc.y || 0) * 0.01;
          this.pos.x = Math.max(10, Math.min(90, this.pos.x + this.velocity.x));
          this.pos.y = Math.max(10, Math.min(90, this.pos.y + this.velocity.y));
          this.velocity.x *= 0.95;
          this.velocity.y *= 0.95;

          this.last = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
          this.updateEvolution();
        });

        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          this.orientation = e.alpha || 0;
          this.currentFifthPosition = Math.floor((this.orientation / 360) * this.circleOfFifths.length);
        });

        this.setupDesktopFallback();
      }

      setupDesktopFallback() {
        let lastMouse = { x: 0, y: 0, time: 0 };
        
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          const now = Date.now();
          const dt = now - lastMouse.time || 1;
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          this.motion = Math.sqrt(((newX - lastMouse.x)/dt * 100)**2 + ((newY - lastMouse.y)/dt * 100)**2) * 0.2;
          this.pos.x = newX;
          this.pos.y = newY;
          this.orientation = (newX / 100) * 360;
          this.currentFifthPosition = Math.floor((newX / 100) * this.circleOfFifths.length);
          
          if (!this.firstMovement && this.motion > 0.5) {
            this.firstMovement = true;
            this.evolveToTribal();
          }
          if (this.motion > 0.5) {
            this.lastMotionTime = now;
            this.totalSteps++;
          }
          
          lastMouse = { x: newX, y: newY, time: now };
          this.updateEvolution();
        });

        window.addEventListener('wheel', e => {
          if (!this.active) return;
          this.altitude += e.deltaY * -0.05;
          this.altitude = Math.max(0, this.altitude);
        });
      }

      updateSensorDisplay() {
        // Simplified, no sensor data UI
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a,b) => a+b, 0) / this.motionHistory.length || 0;
        
        this.updateLayerActivation();
        
        if (this.evolutionStage === 'TRIBAL' && this.totalSteps > 40 && avgMotion > 1.5) {
          this.evolveToOrchestral();
        } else if (this.evolutionStage === 'ORCHESTRAL' && this.totalSteps > 120 && avgMotion > 3) {
          this.evolveToHeaven();
        }
        
        let targetBPM = 60;
        const motionFactor = Math.min(avgMotion * 6, 40);
        const altitudeFactor = Math.min(this.altitude * 0.005, 10);
        switch(this.evolutionStage) {
          case 'TRIBAL': targetBPM = 80 + motionFactor + altitudeFactor; break;
          case 'ORCHESTRAL': targetBPM = 110 + motionFactor * 0.7 + altitudeFactor; break;
          case 'HEAVEN': targetBPM = 140 + motionFactor * 0.5 + altitudeFactor; break;
        }
        this.bpm = this.bpm * 0.9 + targetBPM * 0.1;
        this.updateUI();
      }

      updateLayerActivation() {
        const motion = this.motion;
        const steps = this.totalSteps;
        const altitude = this.altitude;
        
        this.layerStates.subBass = motion > 0.5;
        this.layerStates.pulseKick = this.evolutionStage !== 'PRIMORDIAL' && motion > 1;
        this.layerStates.harmonics = steps > 20 && motion > 1.5;
        this.layerStates.fifths = this.evolutionStage === 'ORCHESTRAL' || this.evolutionStage === 'HEAVEN';
        this.layerStates.extensions = this.evolutionStage === 'HEAVEN' && motion > 2.5;
        this.layerStates.strings = this.evolutionStage === 'ORCHESTRAL' && steps > 60;
        this.layerStates.brass = motion > 4 && (this.evolutionStage === 'ORCHESTRAL' || this.evolutionStage === 'HEAVEN');
        this.layerStates.choir = this.evolutionStage === 'HEAVEN' && altitude > 5;
        this.layerStates.pads = this.transcendent || (this.evolutionStage === 'HEAVEN' && motion < 1.5);
        
        Object.keys(this.layerStates).forEach(layer => {
          const targetGain = this.layerStates[layer] ? this.calculateLayerGain(layer) : 0;
          this.layerGains[layer].gain.linearRampToValueAtTime(targetGain, this.ctx.currentTime + 0.2);
        });
      }

      calculateLayerGain(layer) {
        const intensity = Math.min(this.motion / 8, 1);
        const weatherFactor = this.weather.temp / 20; // Warmer = louder highs
        switch(layer) {
          case 'subBass': return 0.7 + intensity * 0.3;
          case 'pulseKick': return 0.6 + intensity * 0.2;
          case 'harmonics': return 0.4 * weatherFactor + intensity * 0.2;
          case 'fifths': return 0.5 + intensity * 0.1;
          case 'extensions': return 0.3 + intensity * 0.3;
          case 'strings': return 0.4 + intensity * 0.2;
          case 'brass': return 0.5 + intensity * 0.4;
          case 'choir': return 0.2 + (this.altitude * 0.0005);
          case 'pads': return 0.6 + this.transcendentIntensity * 0.4;
          default: return 0.4;
        }
      }

      evolveToTribal() {
        this.evolutionStage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.createParticles('tribal', 15);
        this.elements.stage.textContent = 'TRIBAL';
      }

      evolveToOrchestral() {
        this.evolutionStage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.createParticles('orchestral', 25);
        this.elements.stage.textContent = 'ORCHESTRAL';
      }

      evolveToHeaven() {
        this.evolutionStage = 'HEAVEN';
        this.elements.orb.className = 'orb heaven';
        this.createParticles('heaven', 40);
        this.elements.stage.textContent = 'HEAVEN';
      }

      createParticles(type, count) {
        const existing = document.getElementById('particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.id = 'particles';
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = `particle ${type}`;
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 10 + 's';
          particle.style.animationDuration = (8 + Math.random() * 4) + 's';
          container.appendChild(particle);
        }
      }

      startEvolutionLoop() {
        const tick = () => {
          if (!this.active) return;

          const interval = 60000 / this.bpm;
          const swingFactor = (this.beat % 2 === 1) ? 1 + this.swing : 1;

          this.playStructuredLayers();
          
          this.beat = (this.beat + 1) % 4;
          if (this.beat === 0) {
            this.bar = (this.bar + 1) % 32; // 8 bars A, 8 A, 8 B, 8 A
            this.section = this.bar < 8 ? 'A' : this.bar < 16 ? 'A' : this.bar < 24 ? 'B' : 'A';
            if (this.bar % 8 === 0) this.advanceHarmony();
          }

          setTimeout(tick, (interval / 4) * swingFactor);
        };
        tick();
      }

      playStructuredLayers() {
        if (this.beat === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 300);
        }

        // Base pulse always for groove
        if (this.layerStates.pulseKick && this.beat % 2 === 0) this.playPulseKick();
        if (this.layerStates.subBass) this.playSubBass();

        // Section-based variations for AABA
        if (this.section === 'A') {
          if (this.layerStates.harmonics && this.beat % 2 === 1) this.playHarmonics();
          if (this.layerStates.fifths && this.beat === 0) this.playFifths();
          if (this.layerStates.strings && this.beat === 2) this.playStrings();
          if (this.layerStates.pads && this.beat === 1) this.playPads();
        } else if (this.section === 'B') { // Bridge: more intense/contrasting
          if (this.layerStates.extensions && this.beat === 0) this.playExtensions();
          if (this.layerStates.brass && this.beat % 2 === 0) this.playBrass();
          if (this.layerStates.choir && this.beat === 2) this.playChoir();
        }
      }

      playSubBass() {
        const root = this.circleOfFifths[this.currentFifthPosition];
        const freq = this.noteFreqs[root] * 0.5;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.8, this.ctx.currentTime + 0.6);
        
        gain.gain.setValueAtTime(this.calculateLayerGain('subBass'), this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        osc.connect(gain).connect(this.layerGains.subBass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.8);
        
        this.trackOsc(osc, 800);
      }

      playPulseKick() {
        const layers = [
          { freq: 60, type: 'sine', decay: 0.4 },
          { freq: 90, type: 'triangle', decay: 0.3 },
          { freq: 1500, type: 'square', decay: 0.03 }
        ];
        
        layers.forEach(layer => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = layer.type;
          osc.frequency.setValueAtTime(layer.freq, this.ctx.currentTime);
          if (layer.freq < 100) osc.frequency.exponentialRampToValueAtTime(layer.freq * 0.6, this.ctx.currentTime + layer.decay);
          
          gain.gain.setValueAtTime(this.calculateLayerGain('pulseKick') * (layer.freq < 100 ? 1 : 0.5), this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + layer.decay);
          
          osc.connect(gain).connect(this.layerGains.pulseKick);
          osc.start();
          osc.stop(this.ctx.currentTime + layer.decay);
          
          this.trackOsc(osc, layer.decay * 1000);
        });
      }

      playHarmonics() {
        const root = this.circleOfFifths[this.currentFifthPosition];
        const fundamental = this.noteFreqs[root] * 2;
        const harmonics = [1, 2, 3.01, 5];
        
        harmonics.forEach(h => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = fundamental * h;
          
          gain.gain.setValueAtTime(this.calculateLayerGain('harmonics') / h, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
          
          osc.connect(gain).connect(this.layerGains.harmonics);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
          
          this.trackOsc(osc, 1500);
        });
      }

      playFifths() {
        const current = this.circleOfFifths[this.currentFifthPosition];
        const fifth = this.circleOfFifths[(this.currentFifthPosition + 1) % 12];
        
        [current, fifth].forEach((note, i) => {
          const freq = this.noteFreqs[note] * (3 + i);
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(this.calculateLayerGain('fifths') * (1 - i*0.3), this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
          
          osc.connect(gain).connect(this.layerGains.fifths);
          osc.start();
          osc.stop(this.ctx.currentTime + 1);
          
          this.trackOsc(osc, 1000);
        });
      }

      playExtensions() {
        let chordType = this.section === 'B' ? 'dominant13' : 'major9';
        const chord = this.seventhChords[chordType];
        const root = this.circleOfFifths[this.currentFifthPosition];
        
        chord.forEach(interval => {
          const note = (root + interval) % 12;
          const freq = this.noteFreqs[note] * 1.5;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'triangle';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(this.calculateLayerGain('extensions') / chord.length, this.ctx.currentTime + 0.4);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
          
          osc.connect(gain).connect(this.layerGains.extensions);
          osc.start();
          osc.stop(this.ctx.currentTime + 3);
          
          this.trackOsc(osc, 3000);
        });
      }

      playStrings() {
        const root = this.circleOfFifths[this.currentFifthPosition];
        const chord = [root, (root + 4) % 12, (root + 7) % 12];
        
        chord.forEach(note => {
          const freq = this.noteFreqs[note] * 4;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(this.calculateLayerGain('strings') / 3, this.ctx.currentTime + 0.2);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(gain).connect(this.layerGains.strings);
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
          
          this.trackOsc(osc, 2000);
        });
      }

      playBrass() {
        const root = this.circleOfFifths[this.currentFifthPosition];
        const freq = this.noteFreqs[root] * 2.5;
        const intervals = [0, 5, 7];
        
        intervals.forEach(interval => {
          const noteFreq = freq * Math.pow(2, interval / 12);
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'square';
          osc.frequency.value = noteFreq;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(this.calculateLayerGain('brass') / 3, this.ctx.currentTime + 0.1);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
          
          osc.connect(gain).connect(this.layerGains.brass);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
          
          this.trackOsc(osc, 1500);
        });
      }

      playChoir() {
        const root = this.circleOfFifths[this.currentFifthPosition];
        const chord = this.seventhChords.minor7;
        
        chord.forEach(interval => {
          const note = (root + interval) % 12;
          const freq = this.noteFreqs[note] * 6;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(this.calculateLayerGain('choir') / chord.length, this.ctx.currentTime + 0.8);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
          
          osc.connect(gain).connect(this.layerGains.choir);
          osc.start();
          osc.stop(this.ctx.currentTime + 6);
          
          this.trackOsc(osc, 6000);
        });
      }

      playPads() {
        const root = this.circleOfFifths[this.currentFifthPosition];
        const extensions = this.seventhChords.major7;
        
        extensions.forEach(interval => {
          const note = (root + interval) % 12;
          const freq = this.noteFreqs[note] * 0.3;
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(this.calculateLayerGain('pads') / extensions.length, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
          
          osc.connect(gain).connect(this.layerGains.pads);
          osc.start();
          osc.stop(this.ctx.currentTime + 8);
          
          this.trackOsc(osc, 8000);
        });
      }

      trackOsc(osc, duration) {
        if (this.oscillators.size > 40) return;
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), duration);
      }

      advanceHarmony() {
        const influence = Math.floor(this.motion + this.altitude / 20) % this.circleOfFifths.length;
        this.currentFifthPosition = (this.currentFifthPosition + influence + 1) % this.circleOfFifths.length;
        
        this.delay.delayTime.linearRampToValueAtTime(60 / this.bpm / 4 / 1000, this.ctx.currentTime + 0.2);
      }

      monitorTranscendence() {
        const check = () => {
          if (!this.active) return;
          
          const stillTime = Date.now() - this.lastMotionTime;
          const shouldTranscend = stillTime > 2000;

          if (shouldTranscend !== this.transcendent) {
            this.transcendent = shouldTranscend;
            if (this.transcendent) {
              this.bpm *= 0.7;
              this.swing = 0.3;
              this.elements.progress.classList.add('hidden-ui');
            } else {
              this.elements.progress.classList.remove('hidden-ui');
            }
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 2000) / 4000);
            if (Math.random() < 0.01 * this.transcendentIntensity) this.playDrone();
          }

          setTimeout(check, 200);
        };
        check();
      }

      playDrone() {
        const freq = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 0.1;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        gain.gain.setValueAtTime(0, this.ctx.currentTime);
        gain.gain.linearRampToValueAtTime(0.1 * this.transcendentIntensity, this.ctx.currentTime + 2);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);
        
        osc.connect(gain).connect(this.reverb);
        osc.start();
        osc.stop(this.ctx.currentTime + 10);
        
        this.trackOsc(osc, 10000);
      }

      updateUI() {
        this.elements.stage.textContent = this.evolutionStage;
        
        const intensity = Object.values(this.layerStates).filter(Boolean).length / 9;
        let bg = 'black';
        if (this.evolutionStage === 'TRIBAL') {
          bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,107,107,${0.05 * intensity}) 0%, black 80%)`;
        } else if (this.evolutionStage === 'ORCHESTRAL') {
          bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(78,205,196,${0.05 * intensity}) 0%, black 80%)`;
        } else if (this.evolutionStage === 'HEAVEN') {
          bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(108,92,231,${0.08 * intensity}) 0%, black 100%)`;
        }
        if (this.transcendent) {
          bg = `radial-gradient(circle, rgba(0,0,0,1) 0%, rgba(10,10,10,1) 100%)`;
        }
        document.body.style.background = bg;
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.frameCount++;
          
          this.elements.orb.style.left = `${this.pos.x}%`;
          this.elements.orb.style.top = `${this.pos.y}%`;
          
          if (this.frameCount % 60 === 0) this.updateUI();
          
          requestAnimationFrame(loop);
        };
        loop();
      }
    }

    const unveiling = new SonicUnveiling();
  </script>
</body>
</html>
