<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP DJ - Reality to Professional Mix</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        /* Fibonacci-based layout */
        .container {
            width: 89vw;
            height: 89vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        /* Init button */
        .init {
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: #fff;
            padding: 21px 34px;
            font-size: 13px;
            letter-spacing: 3px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .init:hover {
            border-color: rgba(255, 255, 255, 0.5);
            background: rgba(255, 255, 255, 0.05);
        }
        /* Main interface */
        .interface {
            display: none;
            width: 100%;
            height: 100%;
            position: relative;
        }
        /* Status display */
        .status {
            position: absolute;
            top: 0;
            left: 0;
            font-size: 11px;
            letter-spacing: 2px;
            opacity: 0.5;
        }
        .phase-indicator {
            position: absolute;
            top: 20px;
            left: 0;
            font-size: 16px;
            font-weight: 300;
            letter-spacing: 3px;
            color: #00ffff;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        /* BPM and Key display */
        .metrics {
            position: absolute;
            top: 0;
            right: 0;
            text-align: right;
        }
        .bpm {
            font-size: 34px;
            font-weight: 100;
            opacity: 0.8;
        }
        .key-display {
            font-size: 18px;
            color: #00ff00;
            margin-top: 5px;
            opacity: 0.6;
        }
        .bpm-label {
            font-size: 11px;
            opacity: 0.5;
        }
        /* Waveform visualization */
        .visualizer {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 60%;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .waveform {
            width: 100%;
            height: 40%;
            opacity: 0.8;
        }
        .spectrum {
            width: 100%;
            height: 30%;
            opacity: 0.6;
        }
        /* Track lanes for stem visualization */
        .track-lanes {
            position: absolute;
            bottom: 120px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            height: 100px;
            display: flex;
            flex-direction: column;
            gap: 2px;
        }
        .track-lane {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            position: relative;
            overflow: hidden;
        }
        .track-lane::before {
            content: attr(data-label);
            position: absolute;
            left: 5px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 9px;
            opacity: 0.5;
        }
        .lane-content {
            position: absolute;
            right: 0;
            height: 100%;
            background: linear-gradient(90deg, transparent, var(--lane-color));
            transition: width 0.3s;
        }
        /* Energy and tension meters */
        .meters {
            position: absolute;
            bottom: 34px;
            left: 50%;
            transform: translateX(-50%);
            width: 610px;
            display: flex;
            gap: 13px;
        }
        .meter {
            flex: 1;
            height: 8px;
            background: rgba(255, 255, 255, 0.1);
            overflow: hidden;
            position: relative;
        }
        .meter-fill {
            height: 100%;
            width: 0%;
            transition: width 0.3s;
        }
        .energy-fill {
            background: linear-gradient(90deg, #00ff00, #ffff00, #ff0000);
        }
        .tension-fill {
            background: linear-gradient(90deg, #0066ff, #ff00ff);
        }
        .meter-label {
            position: absolute;
            top: -15px;
            left: 0;
            font-size: 9px;
            opacity: 0.5;
        }
        /* DJ Controls */
        .dj-controls {
            position: absolute;
            bottom: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
        }
        .dj-button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: #fff;
            padding: 5px 10px;
            font-size: 10px;
            cursor: pointer;
            transition: all 0.2s;
            letter-spacing: 1px;
        }
        .dj-button:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.5);
        }
        .dj-button.active {
            background: rgba(0, 255, 255, 0.3);
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
        }
        /* Sample bank grid */
        .sample-bank {
            position: absolute;
            left: 20px;
            top: 80px;
            width: 180px;
        }
        .bank-title {
            font-size: 11px;
            opacity: 0.5;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }
        .sample-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 5px;
        }
        .sample-pad {
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            transition: all 0.2s;
            cursor: pointer;
        }
        .sample-pad.loaded {
            background: rgba(0, 255, 0, 0.1);
            border-color: rgba(0, 255, 0, 0.5);
        }
        .sample-pad.playing {
            background: rgba(0, 255, 255, 0.4);
            border-color: #00ffff;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.8);
            animation: pulse 0.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.05); }
        }
        /* Performance stats */
        .stats {
            position: absolute;
            right: 20px;
            top: 80px;
            width: 180px;
            font-size: 10px;
            font-family: monospace;
        }
        .stat-line {
            margin: 5px 0;
            display: flex;
            justify-content: space-between;
            opacity: 0.6;
        }
        .stat-label {
            color: #00ffff;
        }
        .stat-value {
            color: #fff;
        }
        /* FX rack */
        .fx-rack {
            position: absolute;
            right: 20px;
            bottom: 100px;
            width: 180px;
        }
        .fx-control {
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .fx-label {
            font-size: 10px;
            width: 60px;
            opacity: 0.6;
        }
        .fx-slider {
            flex: 1;
            height: 4px;
            appearance: none;
            background: rgba(255, 255, 255, 0.1);
            outline: none;
        }
        .fx-slider::-webkit-slider-thumb {
            appearance: none;
            width: 12px;
            height: 12px;
            background: #00ffff;
            cursor: pointer;
            border-radius: 50%;
        }
        /* Build-up indicator */
        .buildup-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 60px;
            font-weight: 100;
            opacity: 0;
            pointer-events: none;
            text-shadow: 0 0 30px rgba(255, 255, 255, 0.8);
            animation: buildup-pulse 1s infinite;
        }
        .buildup-indicator.active {
            opacity: 1;
        }
        @keyframes buildup-pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
        }
        /* Debug panel */
        .debug {
            position: absolute;
            bottom: 0;
            left: 0;
            font-size: 9px;
            font-family: monospace;
            opacity: 0.3;
            max-width: 300px;
        }
        /* Help overlay */
        .help {
            position: absolute;
            top: 50px;
            left: 20px;
            font-size: 10px;
            opacity: 0.3;
            line-height: 1.6;
            display: none;
        }
        /* Pitch indicator for auto-tune */
        .pitch-indicator {
            position: absolute;
            left: 20px;
            bottom: 150px;
            width: 180px;
            height: 60px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 5px;
        }
        .pitch-line {
            height: 2px;
            background: #00ff00;
            margin: 5px 0;
            position: relative;
        }
        .pitch-marker {
            position: absolute;
            width: 10px;
            height: 10px;
            background: #ff0000;
            border-radius: 50%;
            top: -4px;
            transition: left 0.1s;
        }
        .pitch-label {
            font-size: 9px;
            opacity: 0.5;
            text-align: center;
        }
        /* Transition effects */
        .transition-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent, rgba(0, 255, 255, 0.2));
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }
        .transition-overlay.active {
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <button class="init" id="initBtn">INITIALIZE GUMP DJ</button>
       
        <div class="interface" id="interface">
            <div class="status" id="status">WAITING FOR REALITY...</div>
            <div class="phase-indicator" id="phaseIndicator">INTRO</div>
           
            <div class="metrics">
                <div class="bpm-label">BPM</div>
                <div class="bpm" id="bpmValue">128</div>
                <div class="key-display" id="keyDisplay">C MAJ</div>
            </div>
           
            <!-- Sample Bank -->
            <div class="sample-bank">
                <div class="bank-title">SAMPLE BANK</div>
                <div class="sample-grid" id="sampleGrid"></div>
            </div>
           
            <!-- Performance Stats -->
            <div class="stats">
                <div class="stat-line">
                    <span class="stat-label">CAPTURES:</span>
                    <span class="stat-value" id="captureCount">0</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">HARMONIC:</span>
                    <span class="stat-value" id="harmonicMatch">100%</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">PHRASE:</span>
                    <span class="stat-value" id="phraseCount">1/16</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">NEXT DROP:</span>
                    <span class="stat-value" id="nextDrop">32 BARS</span>
                </div>
            </div>
           
            <!-- FX Rack -->
            <div class="fx-rack">
                <div class="fx-control">
                    <span class="fx-label">FILTER</span>
                    <input type="range" class="fx-slider" id="filterSlider" min="0" max="100" value="100">
                </div>
                <div class="fx-control">
                    <span class="fx-label">REVERB</span>
                    <input type="range" class="fx-slider" id="reverbSlider" min="0" max="100" value="30">
                </div>
                <div class="fx-control">
                    <span class="fx-label">DELAY</span>
                    <input type="range" class="fx-slider" id="delaySlider" min="0" max="100" value="20">
                </div>
                <div class="fx-control">
                    <span class="fx-label">CRUSH</span>
                    <input type="range" class="fx-slider" id="crushSlider" min="0" max="100" value="0">
                </div>
            </div>
           
            <!-- Pitch Indicator -->
            <div class="pitch-indicator">
                <div class="pitch-label">AUTO-TUNE</div>
                <div class="pitch-line">
                    <div class="pitch-marker" id="pitchMarker"></div>
                </div>
                <div class="pitch-label" id="detectedNote">--</div>
            </div>
           
            <!-- Visualizers -->
            <div class="visualizer">
                <canvas class="waveform" id="waveform"></canvas>
                <canvas class="spectrum" id="spectrum"></canvas>
            </div>
           
            <!-- Track Lanes -->
            <div class="track-lanes">
                <div class="track-lane" data-label="BASS">
                    <div class="lane-content" style="--lane-color: #ff0000"></div>
                </div>
                <div class="track-lane" data-label="MID">
                    <div class="lane-content" style="--lane-color: #00ff00"></div>
                </div>
                <div class="track-lane" data-label="HIGH">
                    <div class="lane-content" style="--lane-color: #0066ff"></div>
                </div>
                <div class="track-lane" data-label="VOX">
                    <div class="lane-content" style="--lane-color: #ff00ff"></div>
                </div>
            </div>
           
            <!-- Energy/Tension Meters -->
            <div class="meters">
                <div class="meter">
                    <div class="meter-label">ENERGY</div>
                    <div class="meter-fill energy-fill" id="energyFill"></div>
                </div>
                <div class="meter">
                    <div class="meter-label">TENSION</div>
                    <div class="meter-fill tension-fill" id="tensionFill"></div>
                </div>
            </div>
           
            <!-- DJ Controls -->
            <div class="dj-controls">
                <button class="dj-button" id="dropBtn">DROP</button>
                <button class="dj-button" id="buildBtn">BUILD</button>
                <button class="dj-button" id="loopBtn">LOOP</button>
                <button class="dj-button" id="filterBtn">FILTER</button>
                <button class="dj-button" id="stutterBtn">STUTTER</button>
                <button class="dj-button" id="spinBtn">SPINBACK</button>
            </div>
           
            <!-- Build-up Indicator -->
            <div class="buildup-indicator" id="buildupIndicator"></div>
           
            <!-- Transition Overlay -->
            <div class="transition-overlay" id="transitionOverlay"></div>
           
            <div class="help" id="help">
                SPACE: Force capture<br>
                1-9: Trigger samples<br>
                Q: Build-up<br>
                W: Drop<br>
                E: Filter sweep<br>
                R: Spinback<br>
                T: Tap tempo
            </div>
           
            <div class="debug" id="debug"></div>
        </div>
    </div>
    <script>
        class GumpDJBreakthrough {
            constructor() {
                // Core audio
                this.ctx = null;
                this.input = null;
                this.analyser = null;
               
                // Master chain
                this.master = null;
                this.limiter = null;
               
                // Recording
                this.bufferSize = 0;
                this.recordBuffer = null;
                this.writePos = 0;
               
                // DJ Engine
                this.bpm = 128;
                this.globalKey = 'C';
                this.globalScale = 'major';
                this.barCount = 0;
                this.beatCount = 0;
                this.phraseCount = 0;
                this.nextKickTime = 0;
               
                // Advanced sample management
                this.sampleBank = {
                    bass: [],
                    mid: [],
                    high: [],
                    vocal: [],
                    texture: [],
                    percussion: []
                };
               
                // Stem separation (frequency-based simulation)
                this.stems = {
                    bass: { low: 20, high: 250 },
                    mid: { low: 250, high: 2000 },
                    high: { low: 2000, high: 20000 },
                    vocal: { low: 150, high: 5000 }
                };
               
                // DJ Set Structure
                this.setStructure = {
                    phase: 'intro',
                    energy: 0.2,
                    tension: 0.1,
                    phraseLength: 16, // bars
                    currentPhrase: 0,
                    dropCountdown: 32,
                    buildupActive: false,
                    lastDropTime: 0
                };
               
                // Harmonic mixing
                this.camelotWheel = {
                    '1A': 'Ab minor', '1B': 'B major',
                    '2A': 'Eb minor', '2B': 'Gb major',
                    '3A': 'Bb minor', '3B': 'Db major',
                    '4A': 'F minor', '4B': 'Ab major',
                    '5A': 'C minor', '5B': 'Eb major',
                    '6A': 'G minor', '6B': 'Bb major',
                    '7A': 'D minor', '7B': 'F major',
                    '8A': 'A minor', '8B': 'C major',
                    '9A': 'E minor', '9B': 'G major',
                    '10A': 'B minor', '10B': 'D major',
                    '11A': 'F# minor', '11B': 'A major',
                    '12A': 'C# minor', '12B': 'E major'
                };
               
                // Auto-tune engine
                this.pitchDetection = {
                    enabled: true,
                    currentPitch: 0,
                    targetPitch: 0,
                    correctionAmount: 0.8,
                    referencePitch: 440
                };
               
                // FX parameters
                this.fx = {};
               
                // Transition engine
                this.transitions = {
                    active: false,
                    type: null,
                    progress: 0,
                    startTime: 0
                };
               
                // Performance metrics
                this.metrics = {
                    captureCount: 0,
                    harmonicAccuracy: 100,
                    beatGridLocked: false,
                    loopActive: false,
                    currentLoop: null
                };
               
                // Analysis
                this.fftData = null;
                this.spectralCentroid = 0;
                this.spectralFlux = 0;
                this.previousSpectrum = null;
                this.zeroCrossings = 0;
               
                // UI elements
                this.initUI();
               
                // Create sample pads
                this.createSamplePads();
            }
           
            initUI() {
                this.ui = {
                    init: document.getElementById('initBtn'),
                    interface: document.getElementById('interface'),
                    status: document.getElementById('status'),
                    phaseIndicator: document.getElementById('phaseIndicator'),
                    bpmValue: document.getElementById('bpmValue'),
                    keyDisplay: document.getElementById('keyDisplay'),
                    waveform: document.getElementById('waveform'),
                    spectrum: document.getElementById('spectrum'),
                    energyFill: document.getElementById('energyFill'),
                    tensionFill: document.getElementById('tensionFill'),
                    debug: document.getElementById('debug'),
                    buildupIndicator: document.getElementById('buildupIndicator'),
                    transitionOverlay: document.getElementById('transitionOverlay'),
                    captureCount: document.getElementById('captureCount'),
                    harmonicMatch: document.getElementById('harmonicMatch'),
                    phraseCount: document.getElementById('phraseCount'),
                    nextDrop: document.getElementById('nextDrop'),
                    pitchMarker: document.getElementById('pitchMarker'),
                    detectedNote: document.getElementById('detectedNote'),
                    help: document.getElementById('help'),
                   
                    // FX sliders
                    filterSlider: document.getElementById('filterSlider'),
                    reverbSlider: document.getElementById('reverbSlider'),
                    delaySlider: document.getElementById('delaySlider'),
                    crushSlider: document.getElementById('crushSlider'),
                   
                    // DJ buttons
                    dropBtn: document.getElementById('dropBtn'),
                    buildBtn: document.getElementById('buildBtn'),
                    loopBtn: document.getElementById('loopBtn'),
                    filterBtn: document.getElementById('filterBtn'),
                    stutterBtn: document.getElementById('stutterBtn'),
                    spinBtn: document.getElementById('spinBtn')
                };
               
                this.ui.init.addEventListener('click', () => this.initialize());
            }
           
            createSamplePads() {
                const grid = document.getElementById('sampleGrid');
                for (let i = 0; i < 16; i++) {
                    const pad = document.createElement('div');
                    pad.className = 'sample-pad';
                    pad.textContent = String(i + 1);
                    pad.dataset.index = i;
                    grid.appendChild(pad);
                   
                    pad.addEventListener('click', () => this.triggerSamplePad(i));
                }
            }
           
            async initialize() {
                try {
                    // Create audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'playback',
                        sampleRate: 48000
                    });
                   
                    if (this.ctx.state === 'suspended') {
                        await this.ctx.resume();
                    }
                   
                    // Get microphone
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: 48000
                        }
                    });
                   
                    // Setup audio chain
                    this.setupAudioChain(stream);
                   
                    // Show interface
                    this.ui.init.style.display = 'none';
                    this.ui.interface.style.display = 'block';
                    this.ui.help.style.display = 'block';
                   
                    // Start the DJ engine
                    this.startDJEngine();
                   
                } catch (err) {
                    console.error('Init failed:', err);
                    alert('Error: ' + err.message);
                }
            }
           
            setupAudioChain(stream) {
                // Input from mic
                this.input = this.ctx.createMediaStreamSource(stream);
               
                // Main analyser
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 4096;
                this.analyser.smoothingTimeConstant = 0.7;
                this.fftData = new Uint8Array(this.analyser.frequencyBinCount);
                this.previousSpectrum = new Float32Array(this.analyser.frequencyBinCount);
               
                // Recording buffer (60 seconds)
                this.bufferSize = this.ctx.sampleRate * 60;
                this.recordBuffer = new Float32Array(this.bufferSize);
               
                // Create recorder worklet fallback
                this.recorder = this.ctx.createScriptProcessor(2048, 1, 1);
                this.recorder.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    this.processAudioInput(input);
                };
               
                // Master bus
                this.master = this.ctx.createGain();
                this.master.gain.value = 0.9;
               
                // Limiter
                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -3;
                this.limiter.knee.value = 0;
                this.limiter.ratio.value = 20;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.05;
               
                // Setup professional FX chain
                this.setupProfessionalFX();
               
                // Connect input chain
                this.input.connect(this.analyser);
                this.input.connect(this.recorder);
               
                // Silent monitoring path for recorder
                const silentGain = this.ctx.createGain();
                silentGain.gain.value = 0;
                this.recorder.connect(silentGain);
                silentGain.connect(this.ctx.destination);
               
                // Connect output chain
                this.master.connect(this.limiter);
                this.limiter.connect(this.ctx.destination);
            }
           
            setupProfessionalFX() {
                // EQ Three-band
                this.fx.eqLow = this.ctx.createBiquadFilter();
                this.fx.eqLow.type = 'lowshelf';
                this.fx.eqLow.frequency.value = 320;
                this.fx.eqLow.gain.value = 0;
               
                this.fx.eqMid = this.ctx.createBiquadFilter();
                this.fx.eqMid.type = 'peaking';
                this.fx.eqMid.frequency.value = 1000;
                this.fx.eqMid.Q.value = 0.5;
                this.fx.eqMid.gain.value = 0;
               
                this.fx.eqHigh = this.ctx.createBiquadFilter();
                this.fx.eqHigh.type = 'highshelf';
                this.fx.eqHigh.frequency.value = 3200;
                this.fx.eqHigh.gain.value = 0;
               
                // DJ Filter (HP/LP sweep)
                this.fx.djFilter = this.ctx.createBiquadFilter();
                this.fx.djFilter.type = 'lowpass';
                this.fx.djFilter.frequency.value = 20000;
                this.fx.djFilter.Q.value = 1;
               
                // Sidechain compression simulation
                this.fx.sidechain = this.ctx.createGain();
                this.fx.sidechain.gain.value = 1;
               
                // Professional reverb
                this.fx.reverb = this.createProfessionalReverb();
                this.fx.reverbSend = this.ctx.createGain();
                this.fx.reverbSend.gain.value = 0.3;
               
                // Beat repeat / delay
                this.fx.delay = this.ctx.createDelay(2);
                this.fx.delay.delayTime.value = 60 / this.bpm / 4;
                this.fx.delayFeedback = this.ctx.createGain();
                this.fx.delayFeedback.gain.value = 0.5;
                this.fx.delaySend = this.ctx.createGain();
                this.fx.delaySend.gain.value = 0.2;
               
                // Bit crusher
                this.fx.bitCrusher = this.createBitCrusher();
                this.fx.bitDry = this.ctx.createGain();
                this.fx.bitDry.gain.value = 1;
                this.fx.bitWet = this.ctx.createGain();
                this.fx.bitWet.gain.value = 0;
               
                // Connect FX chain
                this.fx.sidechain.connect(this.fx.eqLow);
                this.fx.eqLow.connect(this.fx.eqMid);
                this.fx.eqMid.connect(this.fx.eqHigh);
                this.fx.eqHigh.connect(this.fx.djFilter);
                this.fx.djFilter.connect(this.fx.bitDry);
                this.fx.djFilter.connect(this.fx.bitCrusher);
                this.fx.bitCrusher.connect(this.fx.bitWet);
                this.fx.bitDry.connect(this.master);
                this.fx.bitWet.connect(this.master);
               
                // Reverb send
                this.fx.djFilter.connect(this.fx.reverbSend);
                this.fx.reverbSend.connect(this.fx.reverb.input);
                this.fx.reverb.output.connect(this.master);
               
                // Delay send
                this.fx.djFilter.connect(this.fx.delaySend);
                this.fx.delaySend.connect(this.fx.delay);
                this.fx.delay.connect(this.fx.delayFeedback);
                this.fx.delayFeedback.connect(this.fx.delay);
                this.fx.delay.connect(this.master);
               
                // Setup FX control bindings
                this.setupFXControls();
            }
           
            createProfessionalReverb() {
                const convolver = this.ctx.createConvolver();
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
               
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
               
                convolver.buffer = impulse;
               
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
                const wetGain = this.ctx.createGain();
                const dryGain = this.ctx.createGain();
               
                wetGain.gain.value = 0.5;
                dryGain.gain.value = 0.5;
               
                input.connect(convolver);
                convolver.connect(wetGain);
                input.connect(dryGain);
                wetGain.connect(output);
                dryGain.connect(output);
               
                return { input, output };
            }
           
            createBitCrusher() {
                const waveshaper = this.ctx.createWaveShaper();
                const bits = 8;
                const steps = Math.pow(2, bits);
                const curve = new Float32Array(steps);
               
                for (let i = 0; i < steps; i++) {
                    const x = (i * 2) / steps - 1;
                    curve[i] = Math.round(x * (steps / 2)) / (steps / 2);
                }
               
                waveshaper.curve = curve;
                waveshaper.oversample = 'none';
               
                return waveshaper;
            }
           
            setupFXControls() {
                // Filter control
                this.ui.filterSlider.addEventListener('input', (e) => {
                    const value = e.target.value / 100;
                    const freq = 20 + (value * value * 19980);
                    this.fx.djFilter.frequency.exponentialRampToValueAtTime(
                        freq, this.ctx.currentTime + 0.05
                    );
                });
               
                // Reverb control
                this.ui.reverbSlider.addEventListener('input', (e) => {
                    this.fx.reverbSend.gain.value = e.target.value / 100 * 0.8;
                });
               
                // Delay control
                this.ui.delaySlider.addEventListener('input', (e) => {
                    this.fx.delaySend.gain.value = e.target.value / 100 * 0.6;
                });
               
                // Bit crusher control
                this.ui.crushSlider.addEventListener('input', (e) => {
                    const value = e.target.value / 100;
                    this.fx.bitWet.gain.value = value;
                    this.fx.bitDry.gain.value = 1 - value;
                });
               
                // DJ button controls
                this.ui.dropBtn.addEventListener('click', () => this.triggerDrop());
                this.ui.buildBtn.addEventListener('click', () => this.triggerBuildUp());
                this.ui.loopBtn.addEventListener('click', () => this.toggleLoop());
                this.ui.filterBtn.addEventListener('click', () => this.performFilterSweep());
                this.ui.stutterBtn.addEventListener('click', () => this.performStutter());
                this.ui.spinBtn.addEventListener('click', () => this.performSpinback());
            }
           
            processAudioInput(input) {
                // Record to buffer
                for (let i = 0; i < input.length; i++) {
                    this.recordBuffer[this.writePos] = input[i];
                    this.writePos = (this.writePos + 1) % this.bufferSize;
                }
               
                // Analyze
                this.analyser.getByteFrequencyData(this.fftData);
                this.performSpectralAnalysis();
                this.detectPitch();
               
                // Auto-capture interesting moments
                if (this.detectInterestingMoment()) {
                    this.captureAndProcess();
                }
               
                // Update visualization
                this.updateVisualization();
            }
           
            performSpectralAnalysis() {
                // Spectral centroid
                let weightedSum = 0;
                let magnitudeSum = 0;
               
                for (let i = 0; i < this.fftData.length; i++) {
                    const magnitude = this.fftData[i] / 255;
                    const frequency = i * this.ctx.sampleRate / (2 * this.fftData.length);
                    weightedSum += frequency * magnitude;
                    magnitudeSum += magnitude;
                }
               
                this.spectralCentroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
               
                // Spectral flux
                let flux = 0;
                for (let i = 0; i < this.fftData.length; i++) {
                    const current = this.fftData[i] / 255;
                    const previous = this.previousSpectrum[i] || 0;
                    const diff = current - previous;
                    if (diff > 0) flux += diff;
                    this.previousSpectrum[i] = current;
                }
                this.spectralFlux = flux;
               
                // Zero crossing rate (for percussion detection)
                const timeData = new Float32Array(this.analyser.frequencyBinCount);
                this.analyser.getFloatTimeDomainData(timeData);
               
                let crossings = 0;
                for (let i = 1; i < timeData.length; i++) {
                    if ((timeData[i] >= 0) !== (timeData[i-1] >= 0)) {
                        crossings++;
                    }
                }
                this.zeroCrossings = crossings;
            }
           
            detectPitch() {
                // Simple autocorrelation-based pitch detection
                const timeData = new Float32Array(this.analyser.frequencyBinCount);
                this.analyser.getFloatTimeDomainData(timeData);
               
                // Find the peak in autocorrelation
                let maxCorr = 0;
                let bestPeriod = 0;
               
                for (let period = 40; period < 500; period++) {
                    let correlation = 0;
                    for (let i = 0; i < timeData.length - period; i++) {
                        correlation += timeData[i] * timeData[i + period];
                    }
                    if (correlation > maxCorr) {
                        maxCorr = correlation;
                        bestPeriod = period;
                    }
                }
               
                if (bestPeriod > 0 && maxCorr > 0.3) {
                    this.pitchDetection.currentPitch = this.ctx.sampleRate / bestPeriod;
                   
                    // Find nearest note
                    const noteFrequencies = {
                        'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
                        'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
                        'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
                    };
                   
                    let closestNote = 'C';
                    let minDiff = Infinity;
                   
                    for (const [note, freq] of Object.entries(noteFrequencies)) {
                        // Check multiple octaves
                        for (let octave = -2; octave <= 2; octave++) {
                            const targetFreq = freq * Math.pow(2, octave);
                            const diff = Math.abs(this.pitchDetection.currentPitch - targetFreq);
                            if (diff < minDiff) {
                                minDiff = diff;
                                closestNote = note;
                                this.pitchDetection.targetPitch = targetFreq;
                            }
                        }
                    }
                   
                    // Update UI
                    this.ui.detectedNote.textContent = closestNote;
                    const offset = (this.pitchDetection.currentPitch - this.pitchDetection.targetPitch) / 50;
                    this.ui.pitchMarker.style.left = `${50 + offset * 50}%`;
                }
            }
           
            detectInterestingMoment() {
                // Dynamic threshold based on current phase
                const thresholds = {
                    intro: 0.3,
                    buildup: 0.25,
                    peak: 0.2,
                    breakdown: 0.25,
                    outro: 0.3
                };
               
                const threshold = thresholds[this.setStructure.phase];
               
                // Multiple detection criteria
                const fluxTriggered = this.spectralFlux > threshold;
                const hasEnergy = this.fftData.reduce((a, b) => a + b, 0) / this.fftData.length > 10;
                const isPercussive = this.zeroCrossings > 100;
                const isTonal = this.spectralCentroid > 200 && this.spectralCentroid < 4000;
               
                // Intelligent triggering based on phase needs
                if (this.setStructure.phase === 'buildup' && this.setStructure.tension < 0.8) {
                    // Need more tension - capture more aggressively
                    return fluxTriggered && hasEnergy;
                } else if (this.setStructure.phase === 'peak') {
                    // At peak - be selective
                    return fluxTriggered && hasEnergy && (isPercussive || isTonal);
                }
               
                return fluxTriggered && hasEnergy;
            }
           
            captureAndProcess() {
                // Prevent too frequent captures
                const now = Date.now();
                if (this.lastCaptureTime && (now - this.lastCaptureTime) < 250) {
                    return;
                }
                this.lastCaptureTime = now;
               
                // Intelligent capture length based on content
                let captureLength = 0.5;
               
                if (this.zeroCrossings > 200) {
                    // Percussive - shorter
                    captureLength = 0.1 + Math.random() * 0.2;
                } else if (this.spectralCentroid < 500) {
                    // Bass - longer
                    captureLength = 0.5 + Math.random() * 0.5;
                } else if (this.pitchDetection.currentPitch > 0) {
                    // Tonal - medium
                    captureLength = 0.3 + Math.random() * 0.4;
                }
               
                const samples = Math.floor(this.ctx.sampleRate * captureLength);
                const buffer = this.ctx.createBuffer(1, samples, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
               
                // Copy from circular buffer
                const start = (this.writePos - samples + this.bufferSize) % this.bufferSize;
                for (let i = 0; i < samples; i++) {
                    const pos = (start + i) % this.bufferSize;
                    data[i] = this.recordBuffer[pos];
                }

                // Breakthrough: Perform stem separation using offline rendering and band-pass filtering
                Object.entries(this.stems).forEach(([category, range]) => {
                    const offlineCtx = new OfflineAudioContext(1, buffer.length, this.ctx.sampleRate);
                    const offlineSource = offlineCtx.createBufferSource();
                    offlineSource.buffer = buffer;

                    const highpass = offlineCtx.createBiquadFilter();
                    highpass.type = 'highpass';
                    highpass.frequency.value = range.low;

                    const lowpass = offlineCtx.createBiquadFilter();
                    lowpass.type = 'lowpass';
                    lowpass.frequency.value = range.high;

                    offlineSource.connect(highpass);
                    highpass.connect(lowpass);
                    lowpass.connect(offlineCtx.destination);

                    offlineSource.start(0);
                    offlineCtx.startRendering().then((rendered) => {
                        const renderedData = rendered.getChannelData(0);
                        let rms = 0;
                        for (let i = 0; i < renderedData.length; i++) {
                            rms += renderedData[i] * renderedData[i];
                        }
                        rms = Math.sqrt(rms / renderedData.length);

                        if (rms > 0.01) {
                            const stemBuffer = this.ctx.createBuffer(1, rendered.length, this.ctx.sampleRate);
                            stemBuffer.getChannelData(0).set(renderedData);

                            // Apply auto-tune if vocal
                            if (category === 'vocal' && this.pitchDetection.currentPitch > 0 && this.pitchDetection.enabled) {
                                this.applyAutoTune(stemBuffer.getChannelData(0));
                            }

                            this.quantizeToBeat(stemBuffer);
                            this.normalizeBuffer(stemBuffer.getChannelData(0));

                            // Store the stem
                            this.storeSample(stemBuffer, category);

                            // Update metrics and UI
                            this.metrics.captureCount++;
                            this.ui.captureCount.textContent = this.metrics.captureCount;
                            this.updateSamplePads();
                        }
                    }).catch(console.error);
                });
            }
           
            applyAutoTune(data) {
                if (!this.pitchDetection.targetPitch) return;
               
                const pitchRatio = this.pitchDetection.targetPitch / this.pitchDetection.currentPitch;
                const correctionRatio = 1 + (pitchRatio - 1) * this.pitchDetection.correctionAmount;
               
                // Simple pitch shift via resampling
                const newLength = Math.floor(data.length / correctionRatio);
                const corrected = new Float32Array(data.length);
               
                for (let i = 0; i < data.length; i++) {
                    const sourceIndex = i * correctionRatio;
                    const index0 = Math.floor(sourceIndex);
                    const index1 = Math.min(index0 + 1, data.length - 1);
                    const fraction = sourceIndex - index0;
                   
                    if (index0 < data.length) {
                        corrected[i] = data[index0] * (1 - fraction) + data[index1] * fraction;
                    }
                }
               
                // Copy back
                for (let i = 0; i < data.length; i++) {
                    data[i] = corrected[i];
                }
            }
           
            quantizeToBeat(buffer) {
                // Snap to nearest 16th note
                const beatTime = 60 / this.bpm;
                const sixteenthTime = beatTime / 4;
                const samples = buffer.length;
                const duration = samples / this.ctx.sampleRate;
               
                // Round to nearest 16th
                const sixteenths = Math.round(duration / sixteenthTime);
                const quantizedDuration = sixteenths * sixteenthTime;
               
                // Store quantization info
                buffer.quantizedBeats = sixteenths / 4;
            }
           
            normalizeBuffer(data) {
                let maxAmp = 0;
                for (let i = 0; i < data.length; i++) {
                    maxAmp = Math.max(maxAmp, Math.abs(data[i]));
                }
               
                if (maxAmp > 0 && maxAmp < 0.9) {
                    const gain = 0.8 / maxAmp;
                    for (let i = 0; i < data.length; i++) {
                        data[i] *= gain;
                    }
                }
            }
           
            storeSample(buffer, category) {
                const sample = {
                    buffer: buffer,
                    category: category,
                    key: this.detectKey(),
                    energy: this.spectralFlux,
                    timestamp: Date.now(),
                    bpm: this.bpm,
                    quantizedBeats: buffer.quantizedBeats || 1
                };
               
                this.sampleBank[category].push(sample);
               
                // Limit samples per category
                if (this.sampleBank[category].length > 16) {
                    this.sampleBank[category].shift();
                }
            }
           
            detectKey() {
                // Simplified key detection based on pitch
                if (!this.pitchDetection.currentPitch) return this.globalKey;
               
                const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
                const a4 = 440;
                const c0 = a4 * Math.pow(2, -4.75);
               
                const halfSteps = 12 * Math.log2(this.pitchDetection.currentPitch / c0);
                const noteIndex = Math.round(halfSteps) % 12;
               
                return noteNames[noteIndex];
            }
           
            updateSamplePads() {
                const pads = document.querySelectorAll('.sample-pad');
                let sampleIndex = 0;
               
                for (const category of Object.keys(this.sampleBank)) {
                    for (const sample of this.sampleBank[category]) {
                        if (sampleIndex < pads.length) {
                            pads[sampleIndex].classList.add('loaded');
                            pads[sampleIndex].dataset.category = category;
                            sampleIndex++;
                        }
                    }
                }
            }
           
            playInContext(buffer, category) {
                const now = this.ctx.currentTime;
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
               
                // Create processing chain based on category and phase
                const chain = this.createProcessingChain(category);
               
                // Apply phase-specific processing
                this.applyPhaseProcessing(source, chain, category);
               
                // Connect and play
                source.connect(chain.input);
                chain.output.connect(this.fx.sidechain);
               
                // Sync to beat grid
                const nextBeat = this.getNextBeatTime();
                source.start(nextBeat);
               
                if (buffer.quantizedBeats) {
                    const duration = buffer.quantizedBeats * (60 / this.bpm);
                    source.stop(nextBeat + duration);
                } else {
                    source.stop(nextBeat + buffer.duration);
                }
               
                // Visual feedback
                this.flashLane(category);
            }
           
            createProcessingChain(category) {
                const input = this.ctx.createGain();
                const output = this.ctx.createGain();
               
                // Category-specific processing
                switch(category) {
                    case 'bass':
                        const bassBoost = this.ctx.createBiquadFilter();
                        bassBoost.type = 'lowshelf';
                        bassBoost.frequency.value = 200;
                        bassBoost.gain.value = 6;
                       
                        input.connect(bassBoost);
                        bassBoost.connect(output);
                        break;
                       
                    case 'vocal':
                        const vocalEQ = this.ctx.createBiquadFilter();
                        vocalEQ.type = 'peaking';
                        vocalEQ.frequency.value = 3000;
                        vocalEQ.Q.value = 0.5;
                        vocalEQ.gain.value = 3;
                       
                        input.connect(vocalEQ);
                        vocalEQ.connect(output);
                        break;
                       
                    case 'percussion':
                        const transientShaper = this.ctx.createDynamicsCompressor();
                        transientShaper.threshold.value = -20;
                        transientShaper.ratio.value = 4;
                        transientShaper.attack.value = 0.001;
                        transientShaper.release.value = 0.01;
                       
                        input.connect(transientShaper);
                        transientShaper.connect(output);
                        break;
                       
                    default:
                        input.connect(output);
                }
               
                return { input, output };
            }
           
            applyPhaseProcessing(source, chain, category) {
                const phase = this.setStructure.phase;
               
                switch(phase) {
                    case 'intro':
                        // Subtle, filtered
                        chain.output.gain.value = 0.4;
                        break;
                       
                    case 'buildup':
                        // Increasing pitch and energy
                        source.playbackRate.value = 1 + (this.setStructure.tension * 0.2);
                        chain.output.gain.value = 0.5 + (this.setStructure.tension * 0.3);
                        break;
                       
                    case 'peak':
                        // Full energy
                        chain.output.gain.value = 0.8;
                        if (category === 'bass') {
                            source.playbackRate.value = 1;
                        }
                        break;
                       
                    case 'breakdown':
                        // Filtered, spacey
                        chain.output.gain.value = 0.5;
                        this.fx.reverbSend.gain.value = 0.6;
                        break;
                       
                    case 'outro':
                        // Fading
                        chain.output.gain.value = 0.3;
                        break;
                }
            }
           
            getNextBeatTime() {
                const now = this.ctx.currentTime;
                const beatTime = 60 / this.bpm;
                const currentBeat = Math.floor(now / beatTime);
                return (currentBeat + 1) * beatTime;
            }
           
            flashLane(category) {
                const lanes = {
                    'bass': 0,
                    'mid': 1,
                    'high': 2,
                    'vocal': 3,
                    'percussion': 1,
                    'texture': 2
                };
               
                const laneIndex = lanes[category] || 0;
                const laneContents = document.querySelectorAll('.lane-content');
                if (laneContents[laneIndex]) {
                    laneContents[laneIndex].style.width = '100%';
                    setTimeout(() => {
                        laneContents[laneIndex].style.width = '0%';
                    }, 200);
                }
            }
           
            startDJEngine() {
                // Start master clock
                this.startMasterClock();
               
                // Start visualization
                this.startVisualization();
               
                // Start AI DJ brain
                this.startAIDJ();
               
                // Setup keyboard controls
                this.setupKeyboardControls();
               
                // Initial status
                this.ui.status.textContent = 'CAPTURING REALITY...';
            }
           
            startMasterClock() {
                const beatTime = 60 / this.bpm;
               
                const tick = () => {
                    const now = this.ctx.currentTime;
                   
                    // Update beat count
                    this.beatCount = Math.floor(now / beatTime) % 4;
                    this.barCount = Math.floor(now / beatTime / 4) % this.setStructure.phraseLength;
                    this.phraseCount = Math.floor(now / beatTime / 4 / this.setStructure.phraseLength);
                   
                    // Kick drum on beat
                    if (now >= this.nextKickTime) {
                        this.playKick();
                        this.nextKickTime = now + beatTime;
                       
                        // Sidechain pump
                        this.triggerSidechain();
                    }
                   
                    // Update UI
                    this.ui.phraseCount.textContent = `${this.barCount + 1}/${this.setStructure.phraseLength}`;
                   
                    // Calculate next drop
                    const barsUntilDrop = this.setStructure.dropCountdown - this.barCount;
                    this.ui.nextDrop.textContent = `${barsUntilDrop} BARS`;
                   
                    // Check for automatic transitions
                    if (this.barCount === 0 && this.phraseCount > 0) {
                        this.checkPhaseTransition();
                    }
                   
                    setTimeout(tick, 50);
                };
               
                tick();
            }
           
            playKick() {
                const now = this.ctx.currentTime;
               
                // Synthesized kick
                const osc = this.ctx.createOscillator();
                const oscGain = this.ctx.createGain();
               
                osc.frequency.setValueAtTime(150, now);
                osc.frequency.exponentialRampToValueAtTime(30, now + 0.1);
               
                oscGain.gain.setValueAtTime(0.7, now);
                oscGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
               
                // Add click for punch
                const click = this.ctx.createOscillator();
                const clickGain = this.ctx.createGain();
               
                click.frequency.value = 1000;
                clickGain.gain.setValueAtTime(0.3, now);
                clickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.02);
               
                osc.connect(oscGain);
                click.connect(clickGain);
                oscGain.connect(this.limiter);
                clickGain.connect(this.limiter);
               
                osc.start(now);
                osc.stop(now + 0.5);
                click.start(now);
                click.stop(now + 0.02);
            }
           
            triggerSidechain() {
                const now = this.ctx.currentTime;
                this.fx.sidechain.gain.cancelScheduledValues(now);
                this.fx.sidechain.gain.setValueAtTime(0.3, now);
                this.fx.sidechain.gain.exponentialRampToValueAtTime(1, now + 0.15);
            }
           
            checkPhaseTransition() {
                const totalSamples = this.metrics.captureCount;
               
                // Intelligent phase progression
                if (this.setStructure.phase === 'intro' && totalSamples >= 8) {
                    this.transitionToPhase('buildup');
                } else if (this.setStructure.phase === 'buildup' && this.barCount === 12) {
                    this.transitionToPhase('peak');
                } else if (this.setStructure.phase === 'peak' && totalSamples >= 32) {
                    if (Math.random() < 0.3) {
                        this.transitionToPhase('breakdown');
                    }
                } else if (this.setStructure.phase === 'breakdown' && this.barCount === 8) {
                    this.transitionToPhase('peak'); // Second peak
                } else if (totalSamples >= 48) {
                    this.transitionToPhase('outro');
                }
            }
           
            transitionToPhase(newPhase) {
                this.setStructure.phase = newPhase;
                this.ui.phaseIndicator.textContent = newPhase.toUpperCase();
               
                // Phase-specific adjustments
                switch(newPhase) {
                    case 'buildup':
                        this.startBuildUp();
                        break;
                    case 'peak':
                        this.triggerDrop();
                        break;
                    case 'breakdown':
                        this.startBreakdown();
                        break;
                    case 'outro':
                        this.startOutro();
                       break;
                }
            }
           
            startBuildUp() {
                const buildDuration = 8; // bars
                const buildTime = buildDuration * 4 * (60 / this.bpm);
               
                this.ui.buildupIndicator.classList.add('active');
                this.ui.buildupIndicator.textContent = 'BUILDING...';
               
                // Automate filter sweep up
                this.fx.djFilter.frequency.cancelScheduledValues(this.ctx.currentTime);
                this.fx.djFilter.frequency.setValueAtTime(500, this.ctx.currentTime);
                this.fx.djFilter.frequency.exponentialRampToValueAtTime(
                    15000,
                    this.ctx.currentTime + buildTime
                );
               
                // Increase tension
                const tensionRamp = setInterval(() => {
                    this.setStructure.tension = Math.min(1, this.setStructure.tension + 0.05);
                    this.ui.tensionFill.style.width = (this.setStructure.tension * 100) + '%';
                   
                    if (this.setStructure.tension >= 1) {
                        clearInterval(tensionRamp);
                    }
                }, 500);
               
                // Add riser
                this.playRiser(buildTime);
            }
           
            playRiser(duration) {
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
               
                filter.type = 'highpass';
                filter.frequency.setValueAtTime(100, now);
                filter.frequency.exponentialRampToValueAtTime(5000, now + duration);
               
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(50, now);
                osc.frequency.exponentialRampToValueAtTime(1000, now + duration);
               
                gain.gain.setValueAtTime(0, now);
                gain.gain.linearRampToValueAtTime(0.3, now + duration);
               
                osc.connect(filter);
                filter.connect(gain);
                gain.connect(this.fx.reverbSend);
                gain.connect(this.master);
               
                osc.start(now);
                osc.stop(now + duration);
            }
           
            triggerDrop() {
                const now = this.ctx.currentTime;
               
                this.ui.buildupIndicator.textContent = 'DROP!';
                this.ui.transitionOverlay.classList.add('active');
               
                // Filter slam
                this.fx.djFilter.frequency.cancelScheduledValues(now);
                this.fx.djFilter.frequency.setValueAtTime(20000, now);
               
                // Energy burst
                this.setStructure.energy = 1;
                this.setStructure.tension = 0.5;
                this.ui.energyFill.style.width = '100%';
                this.ui.tensionFill.style.width = '50%';
               
                // Play all loaded samples
                this.triggerMassiveDrop();
               
                // Visual reset
                setTimeout(() => {
                    this.ui.buildupIndicator.classList.remove('active');
                    this.ui.transitionOverlay.classList.remove('active');
                }, 1000);
               
                this.setStructure.dropCountdown = 32; // Reset countdown
            }
           
            triggerMassiveDrop() {
                // Play bass hit
                const categories = ['bass', 'mid', 'percussion'];
               
                categories.forEach((category, index) => {
                    if (this.sampleBank[category].length > 0) {
                        setTimeout(() => {
                            const sample = this.sampleBank[category][this.sampleBank[category].length - 1];
                            this.playSampleWithEffects(sample, category, 0.8);
                        }, index * 50);
                    }
                });
               
                // Sub bass boom
                this.playSubBass();
            }
           
            playSubBass() {
                const now = this.ctx.currentTime;
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
               
                osc.frequency.value = 40;
                osc.type = 'sine';
               
                gain.gain.setValueAtTime(0.5, now);
                gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
               
                osc.connect(gain);
                gain.connect(this.limiter);
               
                osc.start(now);
                osc.stop(now + 1);
            }
           
            playSampleWithEffects(sample, category, volume = 0.5) {
                const now = this.ctx.currentTime;
                const source = this.ctx.createBufferSource();
                source.buffer = sample.buffer;
               
                const gain = this.ctx.createGain();
                gain.gain.value = volume;
               
                source.connect(gain);
                gain.connect(this.fx.sidechain);
               
                source.start(now);
            }
           
            startBreakdown() {
                // Low-pass filter
                this.fx.djFilter.frequency.exponentialRampToValueAtTime(
                    1000,
                    this.ctx.currentTime + 2
                );
               
                // Reduce energy
                this.setStructure.energy = 0.4;
                this.ui.energyFill.style.width = '40%';
            }
           
            startOutro() {
                // Fade out over 16 bars
                const fadeTime = 16 * 4 * (60 / this.bpm);
               
                this.master.gain.exponentialRampToValueAtTime(
                    0.1,
                    this.ctx.currentTime + fadeTime
                );
               
                this.setStructure.energy = 0.2;
                this.ui.energyFill.style.width = '20%';
            }
           
            startAIDJ() {
                const think = () => {
                    // Update energy and tension based on samples
                    this.updateDynamics();
                   
                    // Decide on sample playback
                    if (this.shouldPlaySample()) {
                        this.playNextSample();
                    }
                   
                    // Check for special FX moments
                    if (Math.random() < 0.02 && this.setStructure.phase === 'peak') {
                        this.performRandomFX();
                    }
                   
                    // Harmonic mixing check
                    this.updateHarmonicAccuracy();
                   
                    setTimeout(think, 250 + Math.random() * 250);
                };
               
                setTimeout(think, 2000);
            }
           
            updateDynamics() {
                // Natural energy decay
                this.setStructure.energy *= 0.995;
               
                // Tension based on phase position
                if (this.setStructure.phase === 'buildup') {
                    this.setStructure.tension = Math.min(1, this.setStructure.tension + 0.01);
                } else {
                    this.setStructure.tension *= 0.99;
                }
               
                // Update UI
                this.ui.energyFill.style.width = (this.setStructure.energy * 100) + '%';
                this.ui.tensionFill.style.width = (this.setStructure.tension * 100) + '%';
            }
           
            shouldPlaySample() {
                // Probability based on energy deficit
                const energyDeficit = 1 - this.setStructure.energy;
                const probability = energyDeficit * 0.3;
               
                return Math.random() < probability && this.metrics.captureCount > 4;
            }
           
            playNextSample() {
                // Choose category based on what's needed
                const categories = Object.keys(this.sampleBank);
                const weights = this.getCategoryWeights();
               
                let category = this.weightedRandom(categories, weights);
               
                if (this.sampleBank[category].length > 0) {
                    const sample = this.sampleBank[category][Math.floor(Math.random() * this.sampleBank[category].length)];
                    this.playSampleWithEffects(sample, category);
                   
                    // Boost energy
                    this.setStructure.energy = Math.min(1, this.setStructure.energy + 0.1);
                }
            }
           
            getCategoryWeights() {
                const phase = this.setStructure.phase;
                const weights = {
                    intro: [0.3, 0.3, 0.1, 0.1, 0.2, 0],
                    buildup: [0.2, 0.3, 0.2, 0.1, 0.1, 0.1],
                    peak: [0.3, 0.2, 0.2, 0.1, 0.1, 0.1],
                    breakdown: [0.1, 0.2, 0.1, 0.3, 0.3, 0],
                    outro: [0.2, 0.2, 0.1, 0.2, 0.3, 0]
                };
               
                return weights[phase] || [0.2, 0.2, 0.2, 0.2, 0.2, 0];
            }
           
            weightedRandom(items, weights) {
                const total = weights.reduce((a, b) => a + b, 0);
                let random = Math.random() * total;
               
                for (let i = 0; i < items.length; i++) {
                    random -= weights[i];
                    if (random < 0) {
                        return items[i];
                    }
                }
               
                return items[items.length - 1];
            }
           
            performRandomFX() {
                const effects = ['filter', 'stutter', 'delay'];
                const effect = effects[Math.floor(Math.random() * effects.length)];
               
                switch(effect) {
                    case 'filter':
                        this.performFilterSweep();
                        break;
                    case 'stutter':
                        this.performStutter();
                        break;
                    case 'delay':
                        this.fx.delayFeedback.gain.value = 0.8;
                        setTimeout(() => {
                            this.fx.delayFeedback.gain.value = 0.5;
                        }, 1000);
                        break;
                }
            }
           
            updateHarmonicAccuracy() {
                // Simplified harmonic check
                const currentKey = this.globalKey;
                let matchCount = 0;
                let totalCount = 0;
               
                for (const category of Object.keys(this.sampleBank)) {
                    for (const sample of this.sampleBank[category]) {
                        if (sample.key === currentKey) matchCount++;
                        totalCount++;
                    }
                }
               
                if (totalCount > 0) {
                    this.metrics.harmonicAccuracy = Math.round((matchCount / totalCount) * 100);
                    this.ui.harmonicMatch.textContent = this.metrics.harmonicAccuracy + '%';
                }
            }
           
            performFilterSweep() {
                const now = this.ctx.currentTime;
                const sweepTime = (60 / this.bpm) * 4; // 1 bar
               
                this.fx.djFilter.frequency.cancelScheduledValues(now);
                this.fx.djFilter.frequency.setValueAtTime(this.fx.djFilter.frequency.value, now);
                this.fx.djFilter.frequency.exponentialRampToValueAtTime(100, now + sweepTime / 2);
                this.fx.djFilter.frequency.exponentialRampToValueAtTime(20000, now + sweepTime);
            }
           
            performStutter() {
                // Beat repeat effect
                if (this.metrics.captureCount > 0) {
                    const lastSample = this.getLastSample();
                    if (lastSample) {
                        const stutterCount = 8;
                        const stutterTime = (60 / this.bpm) / 4; // 16th notes
                       
                        for (let i = 0; i < stutterCount; i++) {
                            setTimeout(() => {
                                this.playSampleWithEffects(lastSample, lastSample.category, 0.6);
                            }, i * stutterTime * 1000);
                        }
                    }
                }
            }
           
            performSpinback() {
                // Spinback effect on last sample
                const lastSample = this.getLastSample();
                if (lastSample) {
                    const now = this.ctx.currentTime;
                    const source = this.ctx.createBufferSource();
                    source.buffer = lastSample.buffer;
                   
                    source.playbackRate.setValueAtTime(1, now);
                    source.playbackRate.exponentialRampToValueAtTime(0.1, now + 1);
                   
                    const gain = this.ctx.createGain();
                    gain.gain.setValueAtTime(0.5, now);
                    gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
                   
                    source.connect(gain);
                    gain.connect(this.fx.sidechain);
                   
                    source.start(now);
                    source.stop(now + 1);
                }
            }
           
            getLastSample() {
                for (const category of Object.keys(this.sampleBank)) {
                    if (this.sampleBank[category].length > 0) {
                        return this.sampleBank[category][this.sampleBank[category].length - 1];
                    }
                }
                return null;
            }
           
            toggleLoop() {
                this.metrics.loopActive = !this.metrics.loopActive;
                this.ui.loopBtn.classList.toggle('active');
               
                if (this.metrics.loopActive) {
                    // Start 4-bar loop of current samples
                    this.startLoop();
                } else {
                    this.stopLoop();
                }
            }
           
            startLoop() {
                const loopTime = (60 / this.bpm) * 4 * 4; // 4 bars
               
                this.currentLoop = setInterval(() => {
                    // Play random sample from bank
                    if (this.metrics.captureCount > 0) {
                        this.playNextSample();
                    }
                }, loopTime * 1000 / 8); // Play 8 times per loop
            }
           
            stopLoop() {
                if (this.currentLoop) {
                    clearInterval(this.currentLoop);
                    this.currentLoop = null;
                }
            }
           
            triggerSamplePad(index) {
                let currentIndex = 0;
               
                for (const category of Object.keys(this.sampleBank)) {
                    for (const sample of this.sampleBank[category]) {
                        if (currentIndex === index) {
                            this.playSampleWithEffects(sample, category, 0.7);
                           
                            // Visual feedback
                            const pad = document.querySelector(`[data-index="${index}"]`);
                            pad.classList.add('playing');
                            setTimeout(() => pad.classList.remove('playing'), 500);
                           
                            return;
                        }
                        currentIndex++;
                    }
                }
            }
           
            setupKeyboardControls() {
                document.addEventListener('keydown', (e) => {
                    switch(e.key) {
                        case ' ':
                            e.preventDefault();
                            this.forceCapture();
                            break;
                        case 'q':
                        case 'Q':
                            this.triggerBuildUp();
                            break;
                        case 'w':
                        case 'W':
                            this.triggerDrop();
                            break;
                        case 'e':
                        case 'E':
                            this.performFilterSweep();
                            break;
                        case 'r':
                        case 'R':
                            this.performSpinback();
                            break;
                        case 't':
                        case 'T':
                            this.tapTempo();
                            break;
                        case '1':
                        case '2':
                        case '3':
                        case '4':
                        case '5':
                        case '6':
                        case '7':
                        case '8':
                        case '9':
                            this.triggerSamplePad(parseInt(e.key) - 1);
                            break;
                    }
                });
            }
           
            forceCapture() {
                // Generate test sample
                const duration = 0.5;
                const samples = Math.floor(this.ctx.sampleRate * duration);
                const buffer = this.ctx.createBuffer(1, samples, this.ctx.sampleRate);
                const data = buffer.getChannelData(0);
               
                // Create interesting sound
                const frequency = 200 + Math.random() * 800;
                for (let i = 0; i < samples; i++) {
                    data[i] = Math.sin(2 * Math.PI * frequency * i / this.ctx.sampleRate) *
                             Math.sin(2 * Math.PI * 2 * i / this.ctx.sampleRate) * 0.5;
                }
               
                // Process
                this.normalizeBuffer(data);
                const category = ['bass', 'mid', 'high', 'percussion'][Math.floor(Math.random() * 4)];
                this.storeSample(buffer, category);
                this.playInContext(buffer, category);
               
                // Update
                this.metrics.captureCount++;
                this.ui.captureCount.textContent = this.metrics.captureCount;
                this.updateSamplePads();
            }
           
            tapTempo() {
                // Simple tap tempo (would need array of tap times for accuracy)
                const now = Date.now();
                if (this.lastTap) {
                    const interval = now - this.lastTap;
                    const newBpm = Math.round(60000 / interval);
                   
                    if (newBpm > 60 && newBpm < 200) {
                        this.bpm = newBpm;
                        this.ui.bpmValue.textContent = this.bpm;
                       
                        // Update delay time
                        this.fx.delay.delayTime.value = 60 / this.bpm / 4;
                    }
                }
                this.lastTap = now;
            }
           
            startVisualization() {
                const waveformCtx = this.ui.waveform.getContext('2d');
                const spectrumCtx = this.ui.spectrum.getContext('2d');
               
                this.ui.waveform.width = this.ui.waveform.offsetWidth;
                this.ui.waveform.height = this.ui.waveform.offsetHeight;
                this.ui.spectrum.width = this.ui.spectrum.offsetWidth;
                this.ui.spectrum.height = this.ui.spectrum.offsetHeight;
               
                const draw = () => {
                    requestAnimationFrame(draw);
                   
                    // Waveform
                    const timeData = new Uint8Array(this.analyser.frequencyBinCount);
                    this.analyser.getByteTimeDomainData(timeData);
                   
                    waveformCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                    waveformCtx.fillRect(0, 0, this.ui.waveform.width, this.ui.waveform.height);
                   
                    waveformCtx.lineWidth = 2;
                    waveformCtx.strokeStyle = `rgba(0, 255, 255, ${0.5 + this.setStructure.energy * 0.5})`;
                    waveformCtx.beginPath();
                   
                    const sliceWidth = this.ui.waveform.width / timeData.length;
                    let x = 0;
                   
                    for (let i = 0; i < timeData.length; i++) {
                        const v = timeData[i] / 128.0;
                        const y = v * this.ui.waveform.height / 2;
                       
                        if (i === 0) {
                            waveformCtx.moveTo(x, y);
                        } else {
                            waveformCtx.lineTo(x, y);
                        }
                       
                        x += sliceWidth;
                    }
                   
                    waveformCtx.stroke();
                   
                    // Spectrum
                    spectrumCtx.fillStyle = 'rgba(0, 0, 0, 0.2)';
                    spectrumCtx.fillRect(0, 0, this.ui.spectrum.width, this.ui.spectrum.height);
                   
                    const barWidth = this.ui.spectrum.width / 128;
                    for (let i = 0; i < 128; i++) {
                        const value = this.fftData[i] / 255;
                        const barHeight = value * this.ui.spectrum.height;
                       
                        // Color based on frequency
                        let hue;
                        if (i < 16) hue = 0; // Red for bass
                        else if (i < 64) hue = 120; // Green for mid
                        else hue = 240; // Blue for high
                       
                        spectrumCtx.fillStyle = `hsla(${hue}, 100%, 50%, ${value})`;
                        spectrumCtx.fillRect(i * barWidth, this.ui.spectrum.height - barHeight, barWidth - 1, barHeight);
                    }
                };
               
                draw();
            }
           
            updateVisualization() {
                // Additional real-time updates can go here
            }
           
            triggerBuildUp() {
                if (this.setStructure.phase !== 'buildup') {
                    this.transitionToPhase('buildup');
                }
            }
        }
       
        // Initialize GUMP DJ Breakthrough
        const gumpDJ = new GumpDJBreakthrough();
    </script>
</body>
</html>
