<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI DJ Live Sampler</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        :root {
            --phi: 1.618033988749;
            --fib1: 1px;
            --fib2: 1px;
            --fib3: 2px;
            --fib5: 3px;
            --fib8: 5px;
            --fib13: 8px;
            --fib21: 21px;
            --fib34: 34px;
            --fib55: 55px;
            --fib89: 89px;
            --fib144: 144px;
            --fib233: 144px;
        }
        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, system-ui, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            font-weight: 100;
        }
        /* Fibonacci spiral visualization */
        #spiral {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0;
            transition: opacity 3s ease;
        }
        #spiral.active {
            opacity: 0.03;
        }
        /* Ghost title */
        .title {
            position: absolute;
            font-size: var(--fib21);
            letter-spacing: var(--fib8);
            opacity: 0;
            animation: ghost 3s ease-out;
            pointer-events: none;
            white-space: nowrap;
        }
        @keyframes ghost {
            0% { opacity: 0; transform: translateY(var(--fib34)); }
            50% { opacity: 0.08; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(calc(var(--fib34) * -1)); }
        }
        /* Start circle - golden ratio proportions */
        .start {
            width: var(--fib233);
            height: var(--fib233);
            border-radius: 50%;
            background: radial-gradient(circle at 38.2% 38.2%,
                rgba(255,255,255,0.03) 0%,
                transparent 61.8%);
            border: 1px solid rgba(255,255,255,0.08);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.618s ease;
            position: relative;
        }
        .start:hover {
            transform: scale(1.0618);
            border-color: rgba(255,255,255,0.13);
        }
        .start-text {
            font-size: var(--fib13);
            letter-spacing: var(--fib5);
            opacity: 0.618;
        }
        /* Main interface */
        .interface {
            position: fixed;
            width: 100%;
            height: 100%;
            display: none;
            opacity: 0;
        }
        .interface.active {
            display: block;
            animation: fadeIn 1.618s ease forwards;
        }
        @keyframes fadeIn {
            to { opacity: 1; }
        }
        /* Record indicator - Fibonacci positioned */
        .record-indicator {
            position: fixed;
            bottom: var(--fib89);
            left: 50%;
            transform: translateX(-50%);
            width: var(--fib89);
            height: var(--fib89);
            border-radius: 50%;
            background: rgba(255,255,255,0.05);
            border: 1px solid rgba(255,255,255,0.13);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.382s ease;
        }
        .record-indicator.recording {
            background: rgba(255,0,0,0.21);
            border-color: rgba(255,0,0,0.34);
            animation: recordPulse 1.618s ease-in-out infinite;
        }
        @keyframes recordPulse {
            0%, 100% { transform: translateX(-50%) scale(1); }
            50% { transform: translateX(-50%) scale(1.13); }
        }
        .record-dot {
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: rgba(255,255,255,0.21);
            transition: all 0.382s ease;
        }
        .record-indicator.recording .record-dot {
            background: rgba(255,0,0,0.618);
        }
        /* Motion indicator */
        .motion-field {
            position: fixed;
            top: var(--fib55);
            left: var(--fib55);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0.382;
            line-height: var(--phi);
        }
        .motion-value {
            font-size: var(--fib13);
            opacity: 0.618;
        }
        /* Outfit selector - minimal Fibonacci grid */
        .outfits {
            position: fixed;
            top: var(--fib55);
            right: var(--fib55);
            display: grid;
            gap: var(--fib8);
            grid-template-columns: repeat(2, var(--fib55));
        }
        .outfit {
            width: var(--fib55);
            height: var(--fib55);
            border: 1px solid rgba(255,255,255,0.08);
            background: rgba(255,255,255,0.03);
            cursor: pointer;
            transition: all 0.382s ease;
            position: relative;
            overflow: hidden;
        }
        .outfit:hover {
            border-color: rgba(255,255,255,0.21);
            background: rgba(255,255,255,0.05);
        }
        .outfit.active {
            border-color: rgba(255,255,255,0.34);
            background: rgba(255,255,255,0.08);
        }
        .outfit::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: var(--fib21);
            height: var(--fib21);
            border-radius: 50%;
            background: var(--outfit-color, rgba(255,255,255,0.21));
            transition: all 0.382s ease;
        }
        .outfit.cosmic::after { --outfit-color: rgba(138,43,226,0.618); }
        .outfit.urban::after { --outfit-color: rgba(255,140,0,0.618); }
        .outfit.nature::after { --outfit-color: rgba(34,139,34,0.618); }
        .outfit.minimal::after { --outfit-color: rgba(255,255,255,0.382); }
        /* Waveform visualizer */
        #waveform {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: var(--fib144);
            pointer-events: none;
            opacity: 0.21;
        }
        /* Sample bank indicators */
        .sample-bank {
            position: fixed;
            bottom: var(--fib55);
            right: var(--fib55);
            display: flex;
            gap: var(--fib5);
            opacity: 0.382;
        }
        .sample-slot {
            width: var(--fib13);
            height: var(--fib13);
            border-radius: 50%;
            background: rgba(255,255,255,0.08);
            transition: all 0.382s ease;
        }
        .sample-slot.filled {
            background: rgba(255,255,255,0.34);
            animation: samplePulse 2.618s ease-in-out infinite;
        }
        @keyframes samplePulse {
            0%, 100% { transform: scale(1); opacity: 0.34; }
            50% { transform: scale(1.382); opacity: 0.618; }
        }
        /* Canvas for dynamic visuals */
        #canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            opacity: 0.13;
        }
        /* Loading state */
        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: var(--fib8);
            letter-spacing: var(--fib3);
            opacity: 0;
            animation: loading 1.618s ease-in-out infinite;
        }
        @keyframes loading {
            0%, 100% { opacity: 0; }
            50% { opacity: 0.382; }
        }
    </style>
</head>
<body>
    <canvas id="spiral"></canvas>
    <canvas id="canvas"></canvas>
    <canvas id="waveform"></canvas>
   
    <div class="title">AI DJ Live Sampler</div>
   
    <div class="start" id="start">
        <span class="start-text">BEGIN</span>
    </div>
   
    <div class="interface" id="interface">
        <div class="motion-field">
            <div>MOTION</div>
            <div class="motion-value" id="motionValue">0.000</div>
        </div>
       
        <div class="outfits">
            <div class="outfit cosmic active" data-outfit="cosmic"></div>
            <div class="outfit urban" data-outfit="urban"></div>
            <div class="outfit nature" data-outfit="nature"></div>
            <div class="outfit minimal" data-outfit="minimal"></div>
        </div>
       
        <div class="record-indicator" id="recordIndicator">
            <div class="record-dot"></div>
        </div>
       
        <div class="sample-bank" id="sampleBank"></div>
    </div>
   
    <div class="loading" id="loading">AWAKENING...</div>
    <script>
        // AI DJ Live Sound Sampler
        class AIDJEngine {
            constructor() {
                // Core audio
                this.ctx = null;
                this.masterGain = null;
                this.compressor = null;
                this.reverb = null;
                this.analyser = null;
               
                // Sampler system
                this.sampler = {
                    banks: new Array(8).fill(null),
                    currentBank: 0,
                    isBuilding: false,
                    isRecordingClip: false,
                    stream: null,
                    processor: null,
                    clipData: []
                };
               
                // Motion & Environment
                this.motion = {
                    current: 0,
                    smoothed: 0,
                    history: [],
                    pattern: 'still',
                    intensity: 0,
                    lastAccel: { x: 0, y: 0, z: 0 }
                };
               
                // Musical state
                this.outfit = 'cosmic';
                this.phi = 1.618033988749;
                this.fibSequence = [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144];
                this.bpm = 120; // Default BPM, will update from samples
               
                // Visual elements
                this.elements = {};
                this.canvases = {};
                this.animationId = null;
               
                // Initialize
                this.init();
            }
           
            init() {
                // Cache DOM elements
                ['start', 'interface', 'loading', 'motionValue', 'recordIndicator', 'sampleBank']
                    .forEach(id => this.elements[id] = document.getElementById(id));
               
                // Cache canvases
                ['spiral', 'canvas', 'waveform']
                    .forEach(id => {
                        const canvas = document.getElementById(id);
                        this.canvases[id] = {
                            canvas,
                            ctx: canvas.getContext('2d')
                        };
                    });
               
                // Setup event listeners
                this.elements.start.addEventListener('click', () => this.begin());
               
                // Outfit selection
                document.querySelectorAll('.outfit').forEach(el => {
                    el.addEventListener('click', (e) => {
                        document.querySelectorAll('.outfit').forEach(o => o.classList.remove('active'));
                        e.target.classList.add('active');
                        this.outfit = e.target.dataset.outfit;
                        this.updateSoundscape();
                    });
                });
               
                // Record control (now toggles building mode)
                this.elements.recordIndicator.addEventListener('click', () => this.toggleBuilding());
               
                // Create sample bank indicators
                for (let i = 0; i < 8; i++) {
                    const slot = document.createElement('div');
                    slot.className = 'sample-slot';
                    slot.dataset.index = i;
                    this.elements.sampleBank.appendChild(slot);
                }
               
                // Resize canvases
                this.resizeCanvases();
                window.addEventListener('resize', () => this.resizeCanvases());
               
                // Draw Fibonacci spiral (kept for visual theme)
                this.drawFibonacciSpiral();
            }
           
            resizeCanvases() {
                Object.values(this.canvases).forEach(({ canvas }) => {
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                });
            }
           
            drawFibonacciSpiral() {
                const { ctx, canvas } = this.canvases.spiral;
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const scale = Math.min(canvas.width, canvas.height) / 400;
               
                ctx.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx.lineWidth = 1;
               
                let a = 0, b = 1;
                let angle = 0;
               
                for (let i = 0; i < 13; i++) {
                    const radius = b * scale;
                   
                    ctx.beginPath();
                    ctx.arc(
                        centerX + Math.cos(angle) * a * scale,
                        centerY + Math.sin(angle) * a * scale,
                        radius,
                        angle,
                        angle + Math.PI / 2
                    );
                    ctx.stroke();
                   
                    angle += Math.PI / 2;
                    [a, b] = [b, a + b];
                }
            }
           
            async begin() {
                this.elements.loading.style.display = 'block';
                this.elements.start.style.display = 'none';
               
                try {
                    // Request permissions
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }
                   
                    // Get microphone access
                    this.sampler.stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                   
                    // Initialize audio context
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                   
                    // Setup audio chain
                    this.setupAudioChain();
                   
                    // Setup motion detection
                    this.setupMotionDetection();
                   
                    // Setup sampler processor
                    this.setupSampler();
                   
                    // Start engine
                    this.elements.loading.style.display = 'none';
                    this.elements.interface.classList.add('active');
                    document.getElementById('spiral').classList.add('active');
                   
                    // Begin the AI DJ
                    this.startEngine();
                   
                } catch (error) {
                    console.error('Failed to initialize:', error);
                    this.elements.loading.textContent = 'PERMISSION NEEDED';
                }
            }
           
            setupAudioChain() {
                // Master limiter
                this.compressor = this.ctx.createDynamicsCompressor();
                this.compressor.threshold.value = -3;
                this.compressor.knee.value = 3;
                this.compressor.ratio.value = 20;
                this.compressor.attack.value = 0.003;
                this.compressor.release.value = 0.1;
               
                // Master gain
                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 0.8;
               
                // Reverb
                this.reverb = this.ctx.createConvolver();
                this.createReverbImpulse();
               
                // Analyser for visualization
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 2048;
                this.analyser.smoothingTimeConstant = 0.8;
               
                // Connect chain
                this.masterGain.connect(this.compressor);
                this.compressor.connect(this.analyser);
                this.analyser.connect(this.ctx.destination);
               
                // Reverb send
                this.reverbSend = this.ctx.createGain();
                this.reverbSend.gain.value = 0.3;
                this.masterGain.connect(this.reverbSend);
                this.reverbSend.connect(this.reverb);
                this.reverb.connect(this.compressor);
            }
           
            createReverbImpulse() {
                const length = this.ctx.sampleRate * 3;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
               
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        const decay = Math.pow(1 - i / length, 2);
                        channelData[i] = (Math.random() * 2 - 1) * decay * 0.3;
                    }
                }
               
                this.reverb.buffer = impulse;
            }
           
            setupMotionDetection() {
                // Device motion
                window.addEventListener('devicemotion', (e) => {
                    if (!e.accelerationIncludingGravity) return;
                   
                    const { x, y, z } = e.accelerationIncludingGravity;
                    const dx = Math.abs(x - this.motion.lastAccel.x);
                    const dy = Math.abs(y - this.motion.lastAccel.y);
                    const dz = Math.abs(z - this.motion.lastAccel.z);
                   
                    const magnitude = Math.sqrt(dx * dx + dy * dy + dz * dz);
                    this.updateMotion(magnitude);
                   
                    this.motion.lastAccel = { x, y, z };
                });
               
                // Mouse fallback
                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', (e) => {
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMouse.time);
                   
                    const dx = e.clientX - lastMouse.x;
                    const dy = e.clientY - lastMouse.y;
                    const velocity = Math.sqrt(dx * dx + dy * dy) / dt;
                   
                    this.updateMotion(velocity * 10);
                   
                    lastMouse = { x: e.clientX, y: e.clientY, time: now };
                });
            }
           
            updateMotion(value) {
                this.motion.current = value;
                this.motion.smoothed = this.motion.smoothed * 0.8 + value * 0.2;
               
                this.motion.history.push(this.motion.smoothed);
                if (this.motion.history.length > 89) {
                    this.motion.history.shift();
                }
               
                // Analyze motion pattern
                const avg = this.motion.history.reduce((a, b) => a + b, 0) / this.motion.history.length;
                const variance = this.motion.history.reduce((sum, m) => sum + Math.abs(m - avg), 0) / this.motion.history.length;
               
                this.motion.intensity = Math.min(1, variance / 5);
               
                if (avg < 0.5) this.motion.pattern = 'still';
                else if (variance < 1) this.motion.pattern = 'steady';
                else if (variance < 3) this.motion.pattern = 'flowing';
                else this.motion.pattern = 'chaotic';
               
                // Update UI
                this.elements.motionValue.textContent = this.motion.smoothed.toFixed(3);
               
                // Modulate BPM slightly with motion
                const targetBPM = this.bpm + (this.motion.smoothed * 20 - 10);
                this.bpm = Math.max(80, Math.min(160, this.bpm * 0.95 + targetBPM * 0.05));
            }
           
            setupSampler() {
                // Create audio processor for recording
                this.sampler.processor = this.ctx.createScriptProcessor(4096, 1, 1);
                this.sampler.processor.onaudioprocess = (e) => {
                    if (this.sampler.isRecordingClip) {
                        const inputData = e.inputBuffer.getChannelData(0);
                        this.sampler.clipData.push(...inputData);
                    }
                };
               
                // Connect microphone to processor
                const source = this.ctx.createMediaStreamSource(this.sampler.stream);
                source.connect(this.sampler.processor);
                this.sampler.processor.connect(this.ctx.destination); // Required
            }
           
            toggleBuilding() {
                if (this.sampler.isBuilding) {
                    this.stopBuilding();
                } else {
                    this.startBuilding();
                }
            }
           
            startBuilding() {
                this.sampler.isBuilding = true;
                this.elements.recordIndicator.classList.add('recording');
                this.buildNextLayer();
            }
           
            stopBuilding() {
                this.sampler.isBuilding = false;
                this.elements.recordIndicator.classList.remove('recording');
                // Enter DJ mode automatically if not already
                this.startDJMode();
            }
           
            buildNextLayer() {
                if (!this.sampler.isBuilding) return;
               
                // Find next empty bank
                const emptyIndex = this.sampler.banks.findIndex(bank => bank === null);
                if (emptyIndex === -1) {
                    // Banks full, stop building and enter DJ mode
                    this.stopBuilding();
                    return;
                }
               
                this.sampler.currentBank = emptyIndex;
                this.startClipRecording();
            }
           
            startClipRecording() {
                this.sampler.clipData = [];
                this.sampler.isRecordingClip = true;
               
                // Random duration 1-4 seconds
                const duration = (Math.random() * 3 + 1) * 1000;
                setTimeout(() => this.stopClipRecording(), duration);
            }
           
            stopClipRecording() {
                this.sampler.isRecordingClip = false;
               
                // Process the recorded clip
                if (this.sampler.clipData.length > 0) {
                    const bank = {
                        data: this.sampler.clipData,
                        peaks: [],
                        rhythm: null,
                        pitch: null,
                        timestamp: Date.now()
                    };
                    this.sampler.banks[this.sampler.currentBank] = bank;
                    this.analyzeSample(bank);
                   
                    // Update UI
                    const slot = this.elements.sampleBank.children[this.sampler.currentBank];
                    slot.classList.add('filled');
                   
                    // Integrate as layer
                    this.integrateLayer(this.sampler.currentBank);
                   
                    // Update global BPM from this sample if possible
                    if (bank.rhythm && bank.rhythm.bpm) {
                        this.bpm = (this.bpm + bank.rhythm.bpm) / 2;
                    }
                }
               
                // Continue building
                setTimeout(() => this.buildNextLayer(), 500); // Short pause between clips
            }
           
            analyzeSample(bank) {
                // Normalize data
                let maxAmp = 0;
                for (let i = 0; i < bank.data.length; i++) {
                    maxAmp = Math.max(maxAmp, Math.abs(bank.data[i]));
                }
                if (maxAmp > 0) {
                    for (let i = 0; i < bank.data.length; i++) {
                        bank.data[i] /= maxAmp;
                    }
                }
               
                // Find peaks for rhythm
                const threshold = 0.3;
                for (let i = 1; i < bank.data.length - 1; i++) {
                    if (bank.data[i] > threshold &&
                        bank.data[i] > bank.data[i-1] &&
                        bank.data[i] > bank.data[i+1]) {
                        bank.peaks.push({
                            index: i,
                            value: bank.data[i]
                        });
                    }
                }
               
                // Analyze rhythm
                if (bank.peaks.length > 2) {
                    const intervals = [];
                    for (let i = 1; i < bank.peaks.length; i++) {
                        intervals.push(bank.peaks[i].index - bank.peaks[i-1].index);
                    }
                   
                    const avgInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
                    bank.rhythm = {
                        bpm: (60 * this.ctx.sampleRate) / avgInterval,
                        pattern: intervals.map(i => i / avgInterval)
                    };
                } else {
                    bank.rhythm = { bpm: this.bpm };
                }
               
                // Analyze pitch
                bank.pitch = this.detectPitch(bank.data);
               
                // Create audio buffer
                const buffer = this.ctx.createBuffer(1, bank.data.length, this.ctx.sampleRate);
                buffer.getChannelData(0).set(bank.data);
                bank.buffer = buffer;
            }
           
            detectPitch(data) {
                const sampleRate = this.ctx.sampleRate;
                const minFreq = 80;
                const maxFreq = 800;
                const minPeriod = Math.floor(sampleRate / maxFreq);
                const maxPeriod = Math.floor(sampleRate / minFreq);
               
                let maxCorrelation = 0;
                let bestPeriod = 0;
               
                for (let period = minPeriod; period < maxPeriod; period++) {
                    let correlation = 0;
                    for (let i = 0; i < data.length - period; i++) {
                        correlation += data[i] * data[i + period];
                    }
                   
                    if (correlation > maxCorrelation) {
                        maxCorrelation = correlation;
                        bestPeriod = period;
                    }
                }
               
                return bestPeriod > 0 ? sampleRate / bestPeriod : 0;
            }
           
            integrateLayer(bankIndex) {
                const bank = this.sampler.banks[bankIndex];
                if (!bank || !bank.buffer) return;
               
                // Create looping source for the layer
                const source = this.ctx.createBufferSource();
                source.buffer = bank.buffer;
                source.loop = true;
               
                // Adjust playback rate to match global BPM
                const targetDuration = 60 / this.bpm * 4; // Assume 4 beats loop
                const originalDuration = bank.buffer.duration;
                source.playbackRate.value = originalDuration / targetDuration;
               
                // Layer-specific effects based on bank index (e.g., bass for low, highs for upper)
                const gain = this.ctx.createGain();
                gain.gain.value = 0.5 / (bankIndex + 1); // Quieter for higher layers
               
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'bandpass';
                filter.frequency.value = 100 + bankIndex * 200; // Layered frequencies
                filter.Q.value = 2;
               
                // Connect
                source.connect(filter);
                filter.connect(gain);
                gain.connect(this.masterGain);
               
                source.start();
               
                // Store for manipulation
                bank.layer = {
                    source,
                    gain,
                    filter,
                    baseRate: source.playbackRate.value,
                    baseFreq: filter.frequency.value
                };
            }
           
            updateSoundscape() {
                // Update all layers based on outfit
                this.sampler.banks.forEach((bank) => {
                    if (bank && bank.layer) {
                        const { filter, gain } = bank.layer;
                        const mod = this.getOutfitModulation();
                       
                        filter.frequency.value = bank.layer.baseFreq * mod.freqMult;
                        gain.gain.value = 0.5 * mod.gainMult;
                    }
                });
            }
           
            getOutfitModulation() {
                const mods = {
                    cosmic: { freqMult: this.phi, gainMult: 0.8 },
                    urban: { freqMult: 1.5, gainMult: 1.2 },
                    nature: { freqMult: 0.8, gainMult: 0.9 },
                    minimal: { freqMult: 1, gainMult: 0.6 }
                };
                return mods[this.outfit] || { freqMult: 1, gainMult: 1 };
            }
           
            startEngine() {
                // Start visualizations and manipulation loop
                this.animate();
            }
           
            startDJMode() {
                // Already manipulating in animate, but can add more here if needed
            }
           
            animate() {
                const draw = () => {
                    this.animationId = requestAnimationFrame(draw);
                   
                    // Update waveform
                    this.drawWaveform();
                   
                    // Update main canvas
                    this.drawMotionField();
                   
                    // DJ manipulation based on motion
                    this.manipulateLayers();
                };
               
                draw();
            }
           
            manipulateLayers() {
                const intensity = this.motion.intensity;
                const current = this.motion.current;
               
                this.sampler.banks.forEach((bank, index) => {
                    if (bank && bank.layer) {
                        const { source, filter, gain } = bank.layer;
                       
                        // Scratch effect if high motion
                        if (current > 5 && Math.random() < 0.1) {
                            source.playbackRate.value = bank.layer.baseRate * (1 + (Math.random() - 0.5) * intensity * 2);
                            setTimeout(() => {
                                source.playbackRate.value = bank.layer.baseRate;
                            }, 100 + Math.random() * 200);
                        } else {
                            source.playbackRate.value = bank.layer.baseRate * (1 + intensity * 0.1);
                        }
                       
                        // Filter sweep
                        filter.frequency.value = bank.layer.baseFreq * (1 + intensity * 0.5);
                       
                        // Volume modulation
                        gain.gain.value = 0.5 / (index + 1) * (1 - intensity * 0.3 + Math.sin(Date.now() / 1000) * 0.1);
                    }
                });
            }
           
            drawWaveform() {
                const { ctx, canvas } = this.canvases.waveform;
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
               
                this.analyser.getByteTimeDomainData(dataArray);
               
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
               
                ctx.lineWidth = 1;
                ctx.strokeStyle = `rgba(255, 255, 255, ${0.13 + this.motion.intensity * 0.21})`;
                ctx.beginPath();
               
                const sliceWidth = canvas.width / bufferLength;
                let x = 0;
               
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0;
                    const y = v * canvas.height / 2;
                   
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                   
                    x += sliceWidth;
                }
               
                ctx.stroke();
            }
           
            drawMotionField() {
                const { ctx, canvas } = this.canvases.canvas;
               
                ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
               
                // Draw motion-reactive particles
                const particleCount = Math.floor(this.motion.intensity * 89) + 1;
               
                for (let i = 0; i < particleCount; i++) {
                    const angle = (i / particleCount) * Math.PI * 2;
                    const radius = 50 + this.motion.smoothed * 100;
                   
                    const x = canvas.width / 2 + Math.cos(angle + Date.now() * 0.001) * radius;
                    const y = canvas.height / 2 + Math.sin(angle + Date.now() * 0.001) * radius;
                   
                    ctx.beginPath();
                    ctx.arc(x, y, 1 + this.motion.intensity * 2, 0, Math.PI * 2);
                    ctx.fillStyle = `rgba(255, 255, 255, ${0.13 * (1 - this.motion.intensity)})`;
                    ctx.fill();
                }
            }
        }
       
        // Initialize the engine
        const aiDj = new AIDJEngine();
    </script>
</body>
</html>
