<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP: Breakthrough EDM Spatial Engine 2025</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Courier New', monospace;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 2s ease;
        }

        .start-screen {
            text-align: center;
            z-index: 100;
        }

        .start-btn {
            width: 200px;
            height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(0,255,255,0.1) 0%, transparent 70%);
            border: 2px solid rgba(0,255,255,0.3);
            color: #00ffff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 2px;
            backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            animation: pulse 3s ease-in-out infinite;
        }

        .start-btn:hover {
            border-color: rgba(0,255,255,0.6);
            background: radial-gradient(circle, rgba(0,255,255,0.2) 0%, transparent 70%);
            transform: scale(1.05);
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow: 0 0 30px rgba(0,255,255,0.2);
            }
            50% {
                transform: scale(1.08);
                box-shadow: 0 0 60px rgba(0,255,255,0.4);
            }
        }

        .evolution-space {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 2s ease;
        }

        .evolution-space.active {
            opacity: 1;
        }

        .orb {
            position: absolute;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: radial-gradient(circle, #00ffff 0%, rgba(0,255,255,0.3) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 40px rgba(0,255,255,0.5);
            backdrop-filter: blur(5px);
            will-change: transform;
        }

        .orb.pulse {
            animation: beat 0.15s ease-out;
        }

        @keyframes beat {
            0% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(2.2); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }

        .orb.buildup {
            background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
            box-shadow: 0 0 60px rgba(255,0,255,0.7);
        }

        .orb.drop {
            background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
            box-shadow: 0 0 80px rgba(0,255,0,0.7);
        }

        .orb.breakdown {
            background: radial-gradient(circle, #ff9900 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
            box-shadow: 0 0 120px rgba(255,153,0,0.8);
            animation: transcend 3s ease-in-out infinite;
        }

        .orb.riddim {
            background: radial-gradient(circle, #ffff00 0%, #ff0000 25%, #00ffff 50%, #ff00ff 75%, transparent 95%);
            box-shadow: 0 0 200px rgba(255,255,0,1);
            filter: drop-shadow(0 0 80px rgba(255,0,0,0.8));
        }

        .orb.void {
            background: radial-gradient(circle, #4b0082 0%, rgba(75,0,130,0.3) 40%, transparent 80%);
            box-shadow: 0 0 40px rgba(75,0,130,0.4);
            filter: drop-shadow(0 0 20px rgba(75,0,130,0.2));
            animation: voidBreathe 3s ease-in-out infinite;
        }

        @keyframes transcend {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.4); }
        }

        @keyframes voidBreathe {
            0%, 100% {
                transform: translate(-50%, -50%) scale(1);
                opacity: 0.7;
            }
            50% {
                transform: translate(-50%, -50%) scale(1.1);
                opacity: 1;
            }
        }

        .hidden {
            display: none !important;
        }

        .particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .particle {
            position: absolute;
            width: 3px;
            height: 3px;
            border-radius: 50%;
            background: rgba(0,255,255,0.3);
            animation: float 12s linear infinite;
        }

        @keyframes float {
            0% {
                transform: translateY(100vh) scale(0) rotate(0deg);
                opacity: 0;
            }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% {
                transform: translateY(-20vh) scale(1.5) rotate(360deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="startScreen" class="start-screen">
        <div id="startBtn" class="start-btn">
            Enter the Void
        </div>
    </div>

    <div id="evolutionSpace" class="evolution-space">
        <div id="orb" class="orb"></div>
    </div>

    <script>
        class GUMPEngine2025 {
            constructor() {
                this.ctx = null;
                this.listener = null;
                this.active = false;
                this.analyser = null;
                this.dataArray = null;

                // Motion System with Orientation
                this.motion = 0;
                this.intensity = 0;
                this.direction = 0;
                this.pos = { x: 50, y: 50 };
                this.velocity = { x: 0, y: 0 };
                this.lastAccel = { x: 0, y: 0, z: 0 };
                this.motionHistory = [];
                this.motionPattern = 'calm';
                this.totalMotion = 0;
                this.lastMotionTime = Date.now();
                this.motionSmoothingFactor = 0.85;
                this.motionThreshold = 0.1;
                this.orientation = { alpha: 0, beta: 0, gamma: 0 };

                // Evolution System
                this.stage = 'SILENCE';
                this.evolutionProgress = 0;
                this.firstMovement = false;
                this.voidPhase = false;
                this.currentTheme = 'buildup';

                // Musical Structure - Slower for Deeper Feel
                this.bpm = 70; // Base slower BPM for 2025 melodic dubstep trends
                this.step = 0;
                this.phrase = 'A';
                this.phraseCount = 0;
                this.phraseStructure = ['A', 'A', 'B', 'A', 'C', 'D'];
                this.sectionLength = 32;

                // Audio System
                this.masterGain = null;
                this.limiter = null;
                this.layerGains = {};
                this.layerPanners = {};
                this.layerReverbs = {};
                this.layerCompressors = {};
                this.basePositions = {};
                this.layerPositions = {};
                this.panningLerp = 0.05; // Smoother panning

                // Voice Pool
                this.voicePool = {
                    kick: { max: 2, active: [] },
                    sub: { max: 3, active: [] },
                    hats: { max: 4, active: [] },
                    clap: { max: 2, active: [] },
                    wobble: { max: 6, active: [] },
                    fx: { max: 4, active: [] },
                    riser: { max: 3, active: [] },
                    pad: { max: 4, active: [] }, // New for void
                    drone: { max: 2, active: [] } // New for healing
                };

                // Layers
                this.layers = {
                    kick: false,
                    sub: false,
                    hats: false,
                    clap: false,
                    wobble: false,
                    fx: false,
                    riser: false,
                    pad: false,
                    drone: false
                };

                // Musical Elements - 432Hz Tuning
                this.tuning = 432; // A4 = 432Hz
                this.key = 'D';
                this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
                this.mode = 'phrygian';
                this.scales = {
                    minor: [0, 2, 3, 5, 7, 8, 10],
                    phrygian: [0, 1, 3, 5, 7, 8, 10],
                    dorian: [0, 2, 3, 5, 7, 9, 10]
                };
                this.scale = this.scales[this.mode];
                this.chordProgression = [[0,1,7], [8,12,15], [3,7,10], [10,14,17]];
                this.currentChordIndex = 0;
                this.bassNote = 0;

                // Solfeggio Frequencies for Void
                this.solfeggio = [396, 417, 528, 639, 741, 852, 963];

                // Gesture Recognition
                this.gestureRecognition = {
                    shake: 0,
                    sustained: 0
                };

                // Wobble System - Procedural
                this.wobblePattern = [];
                this.wobbleIndex = 0;
                this.wobbleIntensity = 0;

                // Breakthrough: Chaos-based Procedural Generation
                this.chaosR = 3.7; // Logistic map parameter
                this.chaosX = 0.5; // Initial value

                this.elements = {};
                this.init();
            }

            init() {
                ['startScreen', 'startBtn', 'evolutionSpace', 'orb']
                    .forEach(id => this.elements[id] = document.getElementById(id));
                
                this.elements.startBtn.onclick = () => this.start();
                this.setupMotionDetection();
                this.setupOrientationDetection();
                this.setupInteractionListeners();
            }

            setupOrientationDetection() {
                if (typeof DeviceOrientationEvent.requestPermission === 'function') {
                    DeviceOrientationEvent.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            window.addEventListener('deviceorientation', e => {
                                this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
                                this.updateListenerOrientation();
                            });
                        }
                    });
                } else {
                    window.addEventListener('deviceorientation', e => {
                        this.orientation = { alpha: e.alpha, beta: e.beta, gamma: e.gamma };
                        this.updateListenerOrientation();
                    });
                }
            }

            updateListenerOrientation() {
                if (!this.listener) return;
                const rad = Math.PI / 180;
                const forwardX = Math.sin(this.orientation.gamma * rad);
                const forwardY = Math.sin(this.orientation.beta * rad);
                const forwardZ = -Math.cos(this.orientation.alpha * rad);
                const upZ = Math.cos(this.orientation.beta * rad);

                this.listener.forwardX.value = forwardX;
                this.listener.forwardY.value = forwardY;
                this.listener.forwardZ.value = forwardZ;
                this.listener.upX.value = 0;
                this.listener.upY.value = 0;
                this.listener.upZ.value = upZ;
            }

            setupInteractionListeners() {
                window.addEventListener('click', (e) => {
                    if (!this.active) return;
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });

                window.addEventListener('touchstart', (e) => {
                    if (!this.active) return;
                    e.preventDefault();
                    this.gestureRecognition.shake += 0.5;
                    this.triggerDropImpact();
                });
            }

            async start() {
                try {
                    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
                        await DeviceMotionEvent.requestPermission();
                    }

                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    
                    this.listener = this.ctx.listener;
                    this.setupAudioChain();
                    this.setLayerPositions();
                    
                    this.elements.startScreen.classList.add('hidden');
                    this.elements.evolutionSpace.classList.add('active');
                    
                    this.active = true;
                    this.motionHistory = Array(100).fill(2);
                    this.motion = 2;
                    this.intensity = 1;
                    this.totalMotion = 200;
                    this.firstMovement = true;
                    
                    this.evolveToBuildup();
                    this.startSequencer();
                    this.animate();

                } catch (e) {
                    console.error('Failed to start engine:', e);
                }
            }

            setupAudioChain() {
                this.analyser = this.ctx.createAnalyser();
                this.analyser.fftSize = 64;
                this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);

                this.limiter = this.ctx.createDynamicsCompressor();
                this.limiter.threshold.value = -6;
                this.limiter.ratio.value = 12;
                this.limiter.attack.value = 0.001;
                this.limiter.release.value = 0.01;

                this.masterGain = this.ctx.createGain();
                this.masterGain.gain.value = 1.0;

                const layerNames = ['kick', 'sub', 'hats', 'clap', 'wobble', 'fx', 'riser', 'pad', 'drone'];
                const layerLevels = [1.2, 1.0, 0.6, 0.7, 0.8, 0.4, 0.5, 0.3, 0.4];

                layerNames.forEach((name, i) => {
                    this.layerGains[name] = this.ctx.createGain();
                    this.layerGains[name].gain.value = layerLevels[i];
                    
                    this.layerPanners[name] = this.ctx.createPanner();
                    this.layerPanners[name].panningModel = 'HRTF';
                    this.layerPanners[name].distanceModel = 'inverse';
                    this.layerPanners[name].refDistance = 1;
                    this.layerPanners[name].maxDistance = 100;
                    this.layerPanners[name].rolloffFactor = 2;
                    this.layerPanners[name].coneInnerAngle = 60;
                    this.layerPanners[name].coneOuterAngle = 90;
                    this.layerPanners[name].coneOuterGain = 0.3;

                    // Add reverb and compressor for professional sound
                    this.layerReverbs[name] = this.ctx.createConvolver();
                    // Simulate simple impulse for reverb (short burst)
                    const impulse = this.ctx.createBuffer(2, this.ctx.sampleRate * 2, this.ctx.sampleRate);
                    for (let channel = 0; channel < 2; channel++) {
                        const data = impulse.getChannelData(channel);
                        for (let i = 0; i < data.length; i++) {
                            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 3);
                        }
                    }
                    this.layerReverbs[name].buffer = impulse;

                    this.layerCompressors[name] = this.ctx.createDynamicsCompressor();
                    this.layerCompressors[name].threshold.value = -24;
                    this.layerCompressors[name].ratio.value = 4;

                    this.layerPositions[name] = {x: 0, y: 0, z: 0};
                    this.basePositions[name] = {x: 0, y: 0, z: 0};

                    // Chain: gain -> compressor -> reverb (wet/dry mix) -> panner
                    const reverbSend = this.ctx.createGain();
                    reverbSend.gain.value = 0.3; // Wet mix
                    const dryGain = this.ctx.createGain();
                    dryGain.gain.value = 0.7; // Dry mix

                    this.layerGains[name].connect(this.layerCompressors[name]);
                    this.layerCompressors[name].connect(reverbSend);
                    this.layerCompressors[name].connect(dryGain);
                    reverbSend.connect(this.layerReverbs[name]);
                    this.layerReverbs[name].connect(this.layerPanners[name]);
                    dryGain.connect(this.layerPanners[name]);
                    this.layerPanners[name].connect(this.limiter);
                });

                this.limiter.connect(this.analyser);
                this.analyser.connect(this.masterGain);
                this.masterGain.connect(this.ctx.destination);
            }

            setLayerPositions() {
                const positions = {
                    kick: {x: 0, y: 0, z: -2},
                    sub: {x: 0, y: -1, z: -3},
                    hats: {x: 1, y: 1, z: -4},
                    clap: {x: -1, y: 0, z: -1},
                    wobble: {x: -2, y: 0, z: -5},
                    fx: {x: 0, y: 3, z: 10},
                    riser: {x: 0, y: 4, z: -10},
                    pad: {x: 2, y: 2, z: -6},
                    drone: {x: 0, y: -2, z: -8}
                };

                Object.keys(positions).forEach(name => {
                    const pos = positions[name];
                    this.basePositions[name] = {...pos};
                    this.layerPositions[name] = {...pos};
                    
                    if (this.layerPanners[name]) {
                        this.layerPanners[name].positionX.value = pos.x;
                        this.layerPanners[name].positionY.value = pos.y;
                        this.layerPanners[name].positionZ.value = pos.z;
                    }
                });
            }

            setupMotionDetection() {
                let lastAccelTime = 0;
                
                window.addEventListener('devicemotion', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    if (now - lastAccelTime < 16) return;
                    lastAccelTime = now;

                    const acc = e.accelerationIncludingGravity;
                    if (!acc || acc.x === null) return;

                    const dx = Math.abs(acc.x - this.lastAccel.x);
                    const dy = Math.abs(acc.y - this.lastAccel.y);
                    const dz = Math.abs(acc.z - this.lastAccel.z);
                    
                    let newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.7;
                    
                    if (newMotion < this.motionThreshold) newMotion = 0;
                    
                    this.updateMotion(newMotion);

                    this.velocity.x += acc.x * 0.01;
                    this.velocity.y += acc.y * 0.01;
                    this.updatePosition();

                    this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);

                    if (newMotion > 3) {
                        this.gestureRecognition.shake += 0.3;
                        if (this.gestureRecognition.shake > 1) {
                            this.triggerShakeEffects();
                        }
                    }

                    this.lastAccel = { x: acc.x, y: acc.y, z: acc.z };
                });

                let lastMouse = { x: 0, y: 0, time: 0 };
                window.addEventListener('mousemove', e => {
                    if (!this.active) return;
                    
                    const now = Date.now();
                    const dt = Math.max(1, now - lastMouse.time);
                    
                    const newX = (e.clientX / window.innerWidth) * 100;
                    const newY = (e.clientY / window.innerHeight) * 100;
                    
                    const velocityX = (newX - lastMouse.x) / dt * 100;
                    const velocityY = (newY - lastMouse.y) / dt * 100;
                    
                    const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY) * 0.2;
                    this.updateMotion(mouseMotion);
                    
                    this.pos.x = newX;
                    this.pos.y = newY;
                    this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
                    
                    lastMouse = { x: newX, y: newY, time: now };
                });
            }

            updateMotion(newMotion) {
                this.motion = this.motion * this.motionSmoothingFactor + newMotion * (1 - this.motionSmoothingFactor);
                
                this.motionHistory.push(this.motion);
                if (this.motionHistory.length > 100) this.motionHistory.shift();
                
                this.totalMotion += this.motion;

                if (this.motion > 0.2) {
                    this.lastMotionTime = Date.now();
                    if (this.voidPhase) {
                        this.exitVoidState();
                    }
                }

                if (Date.now() - this.lastMotionTime > 5000 && !this.voidPhase) { // Shorter timeout for demo
                    this.enterVoidState();
                }

                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
                this.intensity = Math.sqrt(this.motionHistory.reduce((sum, m) => sum + Math.pow(m - avgMotion, 2), 0) / this.motionHistory.length);

                const recentHistory = this.motionHistory.slice(-30);
                const isRhythmic = recentHistory.filter(m => m > 1.5).length > 15;
                const isErratic = this.intensity > 2.0 && avgMotion > 1.5;
                const isSustained = avgMotion > 2.0 && this.intensity < 1.0;
                const isChaotic = this.intensity > 3.0 && avgMotion > 3.0;

                this.motionPattern = isChaotic ? 'chaotic' : 
                                 isErratic ? 'erratic' : 
                                 isRhythmic ? 'rhythmic' : 
                                 isSustained ? 'sustained' : 'calm';

                this.updateEvolution();
                this.updateChaos(); // Breakthrough procedural
            }

            updateChaos() {
                // Logistic map for procedural patterns
                this.chaosR = 3.5 + (this.intensity * 0.2); // Adjust chaos based on intensity
                this.chaosX = this.chaosR * this.chaosX * (1 - this.chaosX);
                
                // Generate wobble pattern procedurally
                this.wobblePattern = [];
                let x = this.chaosX;
                for (let i = 0; i < 8; i++) {
                    x = this.chaosR * x * (1 - x);
                    this.wobblePattern.push(Math.floor(x * 12)); // Scale to semitones
                }
            }

            updateEvolution() {
                const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;

                if (this.voidPhase) {
                    Object.keys(this.layers).forEach(layer => this.layers[layer] = false);
                    this.layers.pad = true;
                    this.layers.drone = true;
                    return;
                }

                this.layers.kick = this.motionPattern === 'rhythmic' || this.motionPattern === 'chaotic';
                this.layers.sub = avgMotion > 1.0;
                this.layers.hats = avgMotion > 0.5;
                this.layers.clap = this.motionPattern === 'erratic' || this.intensity > 1.5;
                this.layers.wobble = this.motionPattern !== 'calm' && avgMotion > 0.8;
                this.layers.fx = avgMotion > 0.3;
                this.layers.riser = this.intensity > 1.5 || this.motionPattern === 'chaotic';
                this.layers.pad = this.motionPattern === 'sustained';

                this.evolutionProgress = Math.min(this.totalMotion / 800, 3);

                if (this.stage === 'BUILDUP' && this.totalMotion > 200) {
                    this.evolveToDrop();
                } else if (this.stage === 'DROP' && this.totalMotion > 500) {
                    this.evolveToBreakdown();
                } else if (this.stage === 'BREAKDOWN' && this.totalMotion > 800) {
                    this.evolveToRiddim();
                }

                let baseBPM = 70 + (avgMotion * 3) + (this.intensity * 2);
                if (this.stage === 'DROP') baseBPM += 10;
                else if (this.stage === 'BREAKDOWN') baseBPM -= 5;

                this.bpm = this.bpm * 0.9 + baseBPM * 0.1;
                this.bpm = Math.max(60, Math.min(100, this.bpm));

                this.updateTheme(avgMotion, this.intensity);
            }

            updateTheme(avgMotion, intensity) {
                let newTheme = 'buildup';
                
                if (this.voidPhase) newTheme = 'void';
                else if (this.motionPattern === 'chaotic' || intensity > 3) newTheme = 'riddim';
                else if (avgMotion > 3 && intensity > 2) newTheme = 'drop';
                else if (avgMotion > 1.5) newTheme = 'buildup';
                else if (avgMotion < 1 && this.totalMotion > 100) newTheme = 'breakdown';

                if (newTheme !== this.currentTheme) {
                    this.currentTheme = newTheme;
                }
            }

            enterVoidState() {
                console.log('🌌 ENTERING HEAVENLY VOID');
                this.voidPhase = true;
                this.stage = 'VOID';
                this.elements.orb.className = 'orb void';
                this.currentTheme = 'void';
                this.playHealingDrone();
            }

            exitVoidState() {
                console.log('🌌 EXITING VOID STATE');
                this.voidPhase = false;
                this.stage = 'BUILDUP';
                this.elements.orb.className = 'orb buildup';
                this.currentTheme = 'buildup';
                this.motionHistory = Array(100).fill(2);
                this.totalMotion += 200;
                this.evolveToBuildup();
            }

            playHealingDrone() {
                // Additive synthesis for heaven-like pads with solfeggio
                const baseFreq = this.solfeggio[Math.floor(Math.random() * this.solfeggio.length)];
                for (let i = 0; i < 5; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const env = this.ctx.createGain();

                    if (!this.allocateVoice('drone', osc, gain, 10)) continue;

                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * (1 + i * 0.01); // Slight detune for binaural

                    env.gain.setValueAtTime(0, this.ctx.currentTime);
                    env.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 2);
                    env.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 8);
                    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 10);

                    gain.gain.value = 0.2 / (i + 1);

                    osc.connect(env).connect(gain).connect(this.layerGains.drone);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 10);
                }
            }

            triggerShakeEffects() {
                this.gestureRecognition.shake = 0;
                this.layers.clap = true;
                this.bpm += 3; // Slower adjustment
            }

            triggerDropImpact() {
                this.playDropImpact();
            }

            evolveToBuildup() {
                this.voidPhase = false;
                this.stage = 'BUILDUP';
                this.elements.orb.className = 'orb buildup';
                this.createParticles(20, '#ff00ff');
                console.log('🔥 BUILDUP EVOLUTION');
            }

            evolveToDrop() {
                this.stage = 'DROP';
                this.elements.orb.className = 'orb drop';
                this.createParticles(30, '#00ff00');
                console.log('🌊 DROP EVOLUTION');
            }

            evolveToBreakdown() {
                this.stage = 'BREAKDOWN';
                this.elements.orb.className = 'orb breakdown';
                this.createParticles(40, '#ff9900');
                console.log('✨ BREAKDOWN EVOLUTION');
            }

            evolveToRiddim() {
                this.stage = 'RIDDIM';
                this.elements.orb.className = 'orb riddim';
                this.createParticles(50, '#ffff00');
                console.log('🌌 RIDDIM EVOLUTION');
            }

            createParticles(count, color) {
                const existing = document.querySelector('.particles');
                if (existing) existing.remove();

                const container = document.createElement('div');
                container.className = 'particles';
                document.body.appendChild(container);

                for (let i = 0; i < count; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'particle';
                    particle.style.left = Math.random() * 100 + '%';
                    particle.style.background = color;
                    particle.style.animationDelay = Math.random() * 8 + 's';
                    particle.style.animationDuration = (4 + Math.random() * 6) + 's';
                    container.appendChild(particle);
                }
            }

            updatePosition() {
                this.pos.x += this.velocity.x;
                this.pos.y += this.velocity.y;

                if (this.pos.x < 10 || this.pos.x > 90) this.velocity.x *= -0.6;
                if (this.pos.y < 10 || this.pos.y > 90) this.velocity.y *= -0.6;

                this.pos.x = Math.max(10, Math.min(90, this.pos.x));
                this.pos.y = Math.max(10, Math.min(90, this.pos.y));

                this.velocity.x *= 0.95;
                this.velocity.y *= 0.95;
            }

            startSequencer() {
                const tick = () => {
                    if (!this.active) return;
                    
                    this.playStep();
                    this.step = (this.step + 1) % this.sectionLength;
                    
                    if (this.step === 0) {
                        this.phraseCount++;
                        this.phrase = this.phraseStructure[this.phraseCount % this.phraseStructure.length];
                        this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
                    }
                    
                    const interval = (60 / this.bpm) * 500; // Half-time feel
                    setTimeout(tick, interval);
                };
                tick();
            }

            playStep() {
                if (this.voidPhase) {
                    if (Math.random() < 0.1) this.playHealingDrone();
                    if (Math.random() < 0.05) this.playPad();
                    return;
                }

                if (this.step % 4 === 0) {
                    this.elements.orb.classList.add('pulse');
                    setTimeout(() => this.elements.orb.classList.remove('pulse'), 150);
                }

                // Two-step dubstep pattern
                if (this.layers.kick && (this.step % 8 === 0 || this.step % 8 === 4)) this.playKick();
                if (this.layers.sub && this.step % 4 === 0) this.playSub();
                if (this.layers.hats && this.step % 2 === 0) this.playHats();
                if (this.layers.clap && this.step % 8 === 4) this.playClap();
                if (this.layers.wobble && this.step % 1 === 0) this.playWobble();
                if (this.layers.fx && Math.random() < 0.05) this.playFx();
                if (this.layers.riser && this.step % 16 === 0) this.playRiser();
                if (this.layers.pad && this.step % 8 === 0) this.playPad();

                Object.keys(this.gestureRecognition).forEach(key => {
                    this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.02);
                });
            }

            // Professional Sound Generation - Advanced Synthesis

            playKick() {
                // Layered kick with punch and sub
                const osc1 = this.ctx.createOscillator();
                const osc2 = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('kick', osc1, gain, 0.5)) return;

                osc1.type = 'sine';
                osc1.frequency.setValueAtTime(100, this.ctx.currentTime);
                osc1.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.1);

                osc2.type = 'triangle';
                osc2.frequency.setValueAtTime(60, this.ctx.currentTime);
                osc2.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.05);

                env.gain.setValueAtTime(1.2, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);

                gain.gain.value = 1.2;

                osc1.connect(env);
                osc2.connect(env);
                env.connect(gain).connect(this.layerGains.kick);
                osc1.start();
                osc2.start();
                osc1.stop(this.ctx.currentTime + 0.5);
                osc2.stop(this.ctx.currentTime + 0.5);
            }

            playSub() {
                // FM Sub Bass for deeper 2025 dubstep
                const carrier = this.ctx.createOscillator();
                const modulator = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                const freq = this.noteToFreq(this.bassNote, 1);

                if (!this.allocateVoice('sub', carrier, gain, 0.6)) return;

                carrier.type = 'sine';
                carrier.frequency.value = freq;

                modulator.type = 'sine';
                modulator.frequency.value = freq * 0.5; // Sub harmonic FM
                modGain.gain.value = freq * (1 + this.intensity * 0.5); // Mod index

                modulator.connect(modGain);
                modGain.connect(carrier.frequency);

                filter.type = 'lowpass';
                filter.frequency.value = 200 + this.motion * 50;
                filter.Q.value = 2;

                env.gain.setValueAtTime(1.0, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);

                gain.gain.value = 1.0;

                carrier.connect(filter).connect(env).connect(gain).connect(this.layerGains.sub);
                modulator.start();
                carrier.start();
                modulator.stop(this.ctx.currentTime + 0.6);
                carrier.stop(this.ctx.currentTime + 0.6);
            }

            playHats() {
                // Layered noise with shuffle
                const noise = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                if (!this.allocateVoice('hats', noise, gain, 0.1)) return;

                const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
                const noiseData = noiseBuffer.getChannelData(0);
                for (let i = 0; i < noiseData.length; i++) {
                    noiseData[i] = (Math.random() * 2 - 1) * (1 - i / noiseData.length);
                }
                noise.buffer = noiseBuffer;

                filter.type = 'highpass';
                filter.frequency.value = 6000 + this.chaosX * 2000; // Procedural variation

                env.gain.setValueAtTime(0.5, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);

                gain.gain.value = 0.4;

                noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.hats);
                noise.start();
                noise.stop(this.ctx.currentTime + 0.1);
            }

            playClap() {
                // Layered clap with reverb tail
                const noise1 = this.ctx.createBufferSource();
                const noise2 = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();

                if (!this.allocateVoice('clap', noise1, gain, 0.3)) return;

                const createClapBuffer = (length, decay) => {
                    const buffer = this.ctx.createBuffer(1, this.ctx.sampleRate * length, this.ctx.sampleRate);
                    const data = buffer.getChannelData(0);
                    for (let i = 0; i < data.length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, decay);
                    }
                    return buffer;
                };

                noise1.buffer = createClapBuffer(0.3, 1.5);
                noise2.buffer = createClapBuffer(0.2, 2.0);
                noise2.detune.value = 100; // Slight pitch up for layer

                filter.type = 'bandpass';
                filter.frequency.value = 1500;
                filter.Q.value = 3;

                env.gain.setValueAtTime(0.8, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                gain.gain.value = 0.7;

                noise1.connect(filter).connect(env);
                noise2.connect(filter).connect(env);
                env.connect(gain).connect(this.layerGains.clap);
                noise1.start();
                noise2.start(this.ctx.currentTime + 0.01); // Delay for slap
                noise1.stop(this.ctx.currentTime + 0.3);
                noise2.stop(this.ctx.currentTime + 0.3);
            }

            playWobble() {
                // Advanced FM Wobble with chaos modulation
                const noteIndex = this.wobblePattern[this.wobbleIndex % this.wobblePattern.length];
                const freq = this.noteToFreq(noteIndex, 2);
                const carrier = this.ctx.createOscillator();
                const modulator = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                const lfo = this.ctx.createOscillator();

                if (!this.allocateVoice('wobble', carrier, gain, 0.3)) return;

                carrier.type = 'sawtooth';
                carrier.frequency.value = freq;

                modulator.type = 'sine';
                modulator.frequency.value = freq * 2; // FM ratio
                modGain.gain.value = freq * this.chaosX * 2; // Chaos mod index

                modulator.connect(modGain);
                modGain.connect(carrier.frequency);

                lfo.type = 'triangle';
                lfo.frequency.value = 6 + this.intensity * 10;
                lfo.connect(filter.frequency);

                filter.type = 'lowpass';
                filter.frequency.value = 400 + this.motion * 300;
                filter.Q.value = 12 + this.chaosX * 5;

                env.gain.setValueAtTime(0.7, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);

                gain.gain.value = 0.8;

                carrier.connect(filter).connect(env).connect(gain).connect(this.layerGains.wobble);
                
                lfo.start();
                modulator.start();
                carrier.start();
                lfo.stop(this.ctx.currentTime + 0.3);
                modulator.stop(this.ctx.currentTime + 0.3);
                carrier.stop(this.ctx.currentTime + 0.3);

                this.wobbleIndex++;
            }

            playFx() {
                // Glitchy FX with granular-like bursts
                const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 4);
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const delay = this.ctx.createDelay(0.1);
                const feedback = this.ctx.createGain();
                feedback.gain.value = 0.3;

                if (!this.allocateVoice('fx', osc, gain, 2)) return;

                osc.type = 'square';
                osc.frequency.value = freq;

                env.gain.setValueAtTime(0, this.ctx.currentTime);
                env.gain.linearRampToValueAtTime(0.4, this.ctx.currentTime + 0.5);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);

                gain.gain.value = 0.3;

                osc.connect(delay).connect(feedback).connect(delay);
                delay.connect(env).connect(gain).connect(this.layerGains.fx);
                osc.connect(env);
                osc.start();
                osc.stop(this.ctx.currentTime + 2);
            }

            playRiser() {
                // Sweeping riser with FM
                const carrier = this.ctx.createOscillator();
                const modulator = this.ctx.createOscillator();
                const modGain = this.ctx.createGain();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();

                if (!this.allocateVoice('riser', carrier, gain, 3)) return;

                carrier.type = 'sawtooth';
                carrier.frequency.setValueAtTime(100, this.ctx.currentTime);
                carrier.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 3);

                modulator.type = 'sine';
                modulator.frequency.value = 5;
                modGain.gain.value = 50;

                modulator.connect(modGain);
                modGain.connect(carrier.frequency);

                env.gain.setValueAtTime(0, this.ctx.currentTime);
                env.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 3);

                gain.gain.value = 0.5;

                carrier.connect(env).connect(gain).connect(this.layerGains.riser);
                modulator.start();
                carrier.start();
                modulator.stop(this.ctx.currentTime + 3);
                carrier.stop(this.ctx.currentTime + 3);
            }

            playPad() {
                // Additive pad for atmosphere
                const baseFreq = this.noteToFreq(this.chordProgression[this.currentChordIndex][0], 3);
                for (let i = 0; i < 4; i++) {
                    const osc = this.ctx.createOscillator();
                    const gain = this.ctx.createGain();
                    const env = this.ctx.createGain();

                    if (!this.allocateVoice('pad', osc, gain, 4)) continue;

                    osc.type = 'sine';
                    osc.frequency.value = baseFreq * Math.pow(2, i / 12); // Detuned harmonics

                    env.gain.setValueAtTime(0, this.ctx.currentTime);
                    env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 1);
                    env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 3);
                    env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);

                    gain.gain.value = 0.2 / (i + 1);

                    osc.connect(env).connect(gain).connect(this.layerGains.pad);
                    osc.start();
                    osc.stop(this.ctx.currentTime + 4);
                }
            }

            playDropImpact() {
                // Heavy impact with distortion
                const osc = this.ctx.createOscillator();
                const gain = this.ctx.createGain();
                const env = this.ctx.createGain();
                const distortion = this.ctx.createWaveShaper();
                distortion.curve = new Float32Array([0, 0.5, 1, 0.5, 0]); // Simple clip

                if (!this.allocateVoice('kick', osc, gain, 1)) return;

                osc.type = 'sine';
                osc.frequency.setValueAtTime(120, this.ctx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(40, this.ctx.currentTime + 0.2);

                env.gain.setValueAtTime(1.5, this.ctx.currentTime);
                env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);

                gain.gain.value = 1.5;

                osc.connect(distortion).connect(env).connect(gain).connect(this.layerGains.kick);
                osc.start();
                osc.stop(this.ctx.currentTime + 1);
            }

            allocateVoice(layer, source, gainNode, duration) {
                const pool = this.voicePool[layer];
                if (!pool) return false;

                pool.active = pool.active.filter(voice => {
                    if (this.ctx.currentTime > voice.startTime + voice.duration + 0.1) {
                        if (voice.source && voice.source.stop) {
                            try { voice.source.stop(); } catch(e) {}
                        }
                        return false;
                    }
                    return true;
                });

                if (pool.active.length >= pool.max) {
                    const oldest = pool.active.shift();
                    if (oldest && oldest.source && oldest.source.stop) {
                        try { oldest.source.stop(); } catch(e) {}
                    }
                }

                const voice = { 
                    source, 
                    gain: gainNode, 
                    startTime: this.ctx.currentTime,
                    duration 
                };
                pool.active.push(voice);

                return true;
            }

            noteToFreq(note, octave = 4) {
                // 432Hz tuning system
                const a4 = this.tuning;
                const semitonesFromA4 = this.keyOffsets[this.key] + note + (octave - 4) * 12 - 9; // A4 reference
                return a4 * Math.pow(2, semitonesFromA4 / 12);
            }

            animate() {
                const loop = () => {
                    if (!this.active) return;

                    this.elements.orb.style.left = this.pos.x + '%';
                    this.elements.orb.style.top = this.pos.y + '%';

                    const intensityNorm = Math.min(this.intensity / 3, 1);
                    const motionNorm = Math.min(this.motion / 4, 1);

                    let bg;
                    if (this.voidPhase) {
                        const breathe = Math.sin(Date.now() / 3000) * 0.3 + 0.7;
                        bg = `radial-gradient(circle at 50% 50%, rgba(75, 0, 130, ${0.15 * breathe}) 10%, #000000 60%)`;
                    } else {
                        const colors = {
                            buildup: ['#ff00ff', '#000000'],
                            drop: ['#00ff00', '#000000'],
                            breakdown: ['#ff9900', '#ff00ff'],
                            riddim: ['#ffff00', '#ff0000']
                        };
                        
                        const themeColors = colors[this.currentTheme] || colors.buildup;
                        bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, `;
                        bg += `${themeColors[0]} ${5 * motionNorm}%, `;
                        bg += `${themeColors[1]} ${30 * intensityNorm}%, `;
                        bg += `#000000 ${70 + 20 * intensityNorm}%)`;
                    }

                    document.body.style.background = bg;

                    // Dynamic 3D panning based on movement and chaos
                    const panMultiplier = 3 + this.chaosX;
                    const targetX = Math.cos(this.direction * Math.PI / 180) * this.motion * panMultiplier;
                    const targetY = Math.sin(this.direction * Math.PI / 180) * this.motion * panMultiplier;
                    const targetZ = this.intensity * 2;

                    Object.keys(this.layerPanners).forEach(name => {
                        const basePos = this.basePositions[name];
                        const currentPos = this.layerPositions[name];
                        
                        const newX = basePos.x + targetX * (0.3 + this.chaosX * 0.2);
                        const newY = basePos.y + targetY * (0.3 + this.chaosX * 0.2);
                        const newZ = basePos.z + targetZ * (0.2 + this.chaosX * 0.1);
                        
                        currentPos.x += (newX - currentPos.x) * this.panningLerp;
                        currentPos.y += (newY - currentPos.y) * this.panningLerp;
                        currentPos.z += (newZ - currentPos.z) * this.panningLerp;

                        if (this.layerPanners[name]) {
                            this.layerPanners[name].positionX.value = currentPos.x;
                            this.layerPanners[name].positionY.value = currentPos.y;
                            this.layerPanners[name].positionZ.value = currentPos.z;
                        }
                    });

                    requestAnimationFrame(loop);
                };
                requestAnimationFrame(loop);
            }
        }

        // Initialize the breakthrough engine
        new GUMPEngine2025();
    </script>
</body>
</html>
