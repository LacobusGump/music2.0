<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Massive Sonic Evolution</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      background: black;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 1s ease;
      font-family: 'Courier New', monospace;
    }
    
    body.expansion {
      animation: cosmicBirth 5s ease-out forwards;
    }
    @keyframes cosmicBirth {
      0% { 
        background: black; 
        transform: scale(0.0001); 
        filter: brightness(0);
      }
      15% { 
        background: radial-gradient(circle, white 0%, #ff3838 10%, #ff6b6b 25%, #4ecdc4 45%, #45b7d1 65%, black 100%); 
        transform: scale(0.05); 
        filter: brightness(3);
      }
      35% { 
        background: radial-gradient(circle, #fff 0%, #ff9f43 8%, #ee5a24 18%, #0984e3 28%, #6c5ce7 38%, #fd79a8 48%, black 100%); 
        transform: scale(1.5); 
        filter: brightness(2);
      }
      65% { 
        background: radial-gradient(circle, #a29bfe 0%, #6c5ce7 15%, #fd79a8 30%, #fdcb6e 45%, black 100%); 
        transform: scale(4); 
        filter: brightness(1.5);
      }
      100% { 
        background: black; 
        transform: scale(1); 
        filter: brightness(1);
      }
    }
    
    .start-btn {
      padding: 40px 80px;
      background: radial-gradient(circle, white 0%, rgba(255,255,255,0.4) 40%, rgba(108,92,231,0.3) 70%, transparent 100%);
      color: white;
      border: 3px solid rgba(255,255,255,0.6);
      border-radius: 50%;
      cursor: pointer;
      box-shadow: 
        0 0 40px white, 
        0 0 80px rgba(108,92,231,0.5),
        inset 0 0 30px rgba(255,255,255,0.3);
      animation: massivePulse 4s ease-in-out infinite;
      font-size: 16px;
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 3px;
      backdrop-filter: blur(10px);
    }
    
    @keyframes massivePulse { 
      0%, 100% { 
        transform: scale(1); 
        box-shadow: 0 0 40px white, 0 0 80px rgba(108,92,231,0.5);
      } 
      50% { 
        transform: scale(1.4); 
        box-shadow: 
          0 0 100px #ff6b6b, 
          0 0 200px #4ecdc4, 
          0 0 300px rgba(108,92,231,0.8);
      } 
    }
    
    .orb {
      position: absolute;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: radial-gradient(circle, white, transparent);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.2s ease;
      box-shadow: 0 0 15px white;
      will-change: transform;
    }
    
    .orb.tribal { 
      background: radial-gradient(circle, #ff6b6b 0%, #ff9f43 50%, transparent);
      box-shadow: 
        0 0 30px #ff6b6b,
        0 0 60px rgba(255,107,107,0.5);
      width: 10px; height: 10px;
    }
    
    .orb.orchestral { 
      background: radial-gradient(circle, #4ecdc4 0%, #45b7d1 30%, #74b9ff 60%, transparent);
      box-shadow: 
        0 0 50px #4ecdc4,
        0 0 100px rgba(78,205,196,0.6),
        0 0 150px rgba(69,183,209,0.4);
      width: 14px; height: 14px;
    }
    
    .orb.heaven { 
      background: radial-gradient(circle, #6c5ce7 0%, #a29bfe 25%, #fd79a8 50%, #fdcb6e 75%, transparent);
      box-shadow: 
        0 0 80px #6c5ce7,
        0 0 160px #fd79a8,
        0 0 240px rgba(108,92,231,0.7),
        0 0 320px rgba(253,121,168,0.5);
      width: 20px; height: 20px;
      animation: cosmicPulse 1.5s ease-in-out infinite;
    }
    
    .orb.pulse {
      animation: massiveBeatPulse 0.25s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    @keyframes cosmicPulse { 
      0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); } 
      50% { transform: translate(-50%, -50%) scale(1.6) rotate(180deg); } 
    }
    @keyframes massiveBeatPulse { 
      0% { transform: translate(-50%, -50%) scale(1); } 
      40% { transform: translate(-50%, -50%) scale(2.2); } 
      100% { transform: translate(-50%, -50%) scale(1); } 
    }
    
    .message {
      position: absolute;
      top: 25%;
      left: 50%;
      transform: translateX(-50%);
      color: white;
      font-size: 24px;
      font-weight: bold;
      text-align: center;
      opacity: 0;
      transition: all 1.5s ease;
      text-shadow: 
        0 0 20px rgba(255,255,255,0.9),
        0 0 40px rgba(108,92,231,0.6);
      letter-spacing: 2px;
    }
    
    .message.show { 
      opacity: 1; 
      transform: translateX(-50%) scale(1.1);
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      border-radius: 50%;
      animation: harmonicFloat 8s infinite ease-in-out;
    }
    
    .particle.tribal {
      width: 4px; height: 4px;
      background: radial-gradient(circle, #ff6b6b, transparent);
      box-shadow: 0 0 10px #ff6b6b;
    }
    
    .particle.orchestral {
      width: 5px; height: 5px;
      background: radial-gradient(circle, #4ecdc4, transparent);
      box-shadow: 0 0 15px #4ecdc4;
    }
    
    .particle.heaven {
      width: 8px; height: 8px;
      background: radial-gradient(circle, #6c5ce7 0%, #fd79a8 50%, transparent);
      box-shadow: 
        0 0 20px #6c5ce7, 
        0 0 40px #fd79a8;
    }
    
    @keyframes harmonicFloat {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      15% { opacity: 1; }
      85% { opacity: 1; }
      100% { 
        transform: translateY(-30vh) scale(2) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .progress-indicator {
      position: absolute;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      color: rgba(255,255,255,0.8);
      font-size: 14px;
      text-align: center;
      backdrop-filter: blur(5px);
      padding: 10px 20px;
      border-radius: 10px;
      background: rgba(0,0,0,0.3);
    }
    
    .evolution-stage {
      font-weight: bold;
      margin-bottom: 8px;
      font-size: 16px;
    }
    
    .sensor-data {
      position: absolute;
      top: 20px;
      right: 20px;
      color: rgba(255,255,255,0.6);
      font-size: 10px;
      text-align: right;
      backdrop-filter: blur(5px);
      padding: 10px;
      border-radius: 5px;
      background: rgba(0,0,0,0.2);
    }
    
    .layer-indicator {
      position: absolute;
      left: 20px;
      top: 50%;
      transform: translateY(-50%);
      color: rgba(255,255,255,0.7);
      font-size: 12px;
    }
    
    .layer {
      margin: 5px 0;
      padding: 3px 8px;
      border-radius: 3px;
      background: rgba(255,255,255,0.1);
      opacity: 0.3;
      transition: all 0.3s ease;
    }
    
    .layer.active {
      opacity: 1;
      background: rgba(108,92,231,0.3);
      box-shadow: 0 0 10px rgba(108,92,231,0.5);
    }
  </style>
</head>
<body>
  <button class="start-btn" id="start">IGNITE<br/>SONIC<br/>EVOLUTION</button>
  
  <div class="spatial-viz hidden" id="viz">
    <div class="orb" id="orb"></div>
    <div class="message" id="message">NOW MOVE<br/>CREATE SOUND</div>
    
    <div class="progress-indicator" id="progress">
      <div class="evolution-stage" id="stage">PRIMORDIAL SILENCE</div>
      <div id="substage">Sensors calibrating...</div>
    </div>
    
    <div class="sensor-data" id="sensorData">
      <div>Motion: <span id="motionVal">0</span></div>
      <div>Altitude: <span id="altVal">0</span>m</div>
      <div>Pressure: <span id="pressureVal">0</span>hPa</div>
      <div>Orientation: <span id="orientVal">0Â°</span></div>
    </div>
    
    <div class="layer-indicator" id="layers">
      <div class="layer" id="layer808">808 Sub Bass</div>
      <div class="layer" id="layerKick">Massive Kick</div>
      <div class="layer" id="layerSines">Sine Harmonics</div>
      <div class="layer" id="layerFifths">Circle of 5ths</div>
      <div class="layer" id="layerSevenths">7th Extensions</div>
      <div class="layer" id="layerStrings">Orchestral Strings</div>
      <div class="layer" id="layerBrass">Epic Brass</div>
      <div class="layer" id="layerChoir">Cosmic Choir</div>
      <div class="layer" id="layerPads">Heaven Pads</div>
    </div>
  </div>

  <script>
    class MassiveGUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.altitude = 0;
        this.pressure = 1013.25; // Sea level
        this.orientation = 0;
        this.bpm = 45; // Start ultra slow
        this.swing = 0.02;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.last = { x: 0, y: 0, z: 0 };
        this.active = false;
        this.step = 0;
        this.transcendent = false;
        this.transcendentIntensity = 0;
        this.lastMotionTime = Date.now();
        
        // MASSIVE AUDIO CHAIN
        this.masterGain = null;
        this.reverb = null;
        this.delay = null;
        this.compressor = null;
        this.filter = null;
        this.distortion = null;
        this.subBassGain = null;
        this.midGain = null;
        this.highGain = null;
        
        // Evolution & Layering
        this.evolutionStage = 'PRIMORDIAL';
        this.stageProgress = 0;
        this.totalSteps = 0;
        this.firstMovement = false;
        this.activeLayers = new Set();
        
        // EPIC MUSICAL THEORY
        this.circleOfFifths = [0, 7, 2, 9, 4, 11, 6, 1, 8, 3, 10, 5]; // Perfect mathematical harmony
        this.currentFifthPosition = 0;
        this.seventhChords = {
          // Rich 7th and extended harmonies
          major7: [0, 4, 7, 11],
          minor7: [0, 3, 7, 10],
          dominant7: [0, 4, 7, 10],
          minor7b5: [0, 3, 6, 10],
          major9: [0, 4, 7, 11, 2],
          minor11: [0, 3, 7, 10, 2, 5],
          dominant13: [0, 4, 7, 10, 2, 6, 9]
        };
        
        // Frequency mappings optimized for massive bass
        this.noteFreqs = {
          0: 65.41,   // C2 - Sub bass territory
          1: 69.30,   // C#2
          2: 73.42,   // D2  
          3: 77.78,   // Eb2
          4: 82.41,   // E2
          5: 87.31,   // F2
          6: 92.50,   // F#2
          7: 98.00,   // G2
          8: 103.83,  // G#2
          9: 110.00,  // A2
          10: 116.54, // Bb2
          11: 123.47  // B2
        };
        
        this.oscillators = new Set();
        this.scheduledEvents = [];
        
        // Sensor data
        this.sensorHistory = {
          motion: [],
          altitude: [],
          pressure: [],
          orientation: []
        };
        
        // Layer management
        this.layerGains = {};
        this.layerStates = {
          sub808: false,
          massiveKick: false,
          sineHarmonics: false,
          circleOfFifths: false,
          seventhExtensions: false,
          orchestralStrings: false,
          epicBrass: false,
          cosmicChoir: false,
          heavenPads: false
        };
        
        this.elements = {};
        this.motionHistory = [];
        
        this.init();
      }

      init() {
        const ids = ['start', 'viz', 'orb', 'message', 'progress', 'stage', 'substage', 
                    'sensorData', 'motionVal', 'altVal', 'pressureVal', 'orientVal', 'layers'];
        ids.forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.start.onclick = () => this.start();
        this.setupSensorMonitoring();
      }

      setupSensorMonitoring() {
        // Watch for pressure/altitude changes
        if ('AmbientLightSensor' in window) {
          // Use as proxy for environmental changes
        }
        
        // Geolocation for altitude
        if (navigator.geolocation) {
          navigator.geolocation.watchPosition(
            pos => {
              if (pos.coords.altitude) {
                this.altitude = pos.coords.altitude;
                this.updateSensorDisplay();
              }
            },
            null,
            { enableHighAccuracy: true, maximumAge: 10000 }
          );
        }
      }

      async start() {
        try {
          // Request ALL permissions
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') {
              alert('Motion permission required for massive sonic experience');
              return;
            }
          }

          if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }

          // MASSIVE AUDIO CONTEXT SETUP
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupMassiveAudioChain();

          // COSMIC BIRTH ANIMATION
          document.body.classList.add('expansion');
          
          setTimeout(() => {
            document.body.classList.remove('expansion');
            this.elements.start.classList.add('hidden');
            this.elements.viz.classList.remove('hidden');
            
            // Epic "NOW MOVE" reveal
            setTimeout(() => {
              this.elements.message.classList.add('show');
              setTimeout(() => this.elements.message.classList.remove('show'), 4000);
            }, 1000);
            
            this.active = true;
            this.lastMotionTime = Date.now();
            this.startMassiveSensors();
            this.startLayeredEvolution();
            this.animate();
            this.monitorTranscendence();
          }, 5000);
          
        } catch (e) {
          console.error('Sonic evolution failed:', e);
          alert('Failed to ignite sonic evolution. Try again.');
        }
      }

      setupMassiveAudioChain() {
        // MASTER GAIN - The god knob
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.85;
        this.masterGain.connect(this.ctx.destination);
        
        // FREQUENCY SPLITTING for massive control
        this.subBassGain = this.ctx.createGain();
        this.midGain = this.ctx.createGain();
        this.highGain = this.ctx.createGain();
        
        const subFilter = this.ctx.createBiquadFilter();
        subFilter.type = 'lowpass';
        subFilter.frequency.value = 120;
        subFilter.Q.value = 0.7;
        
        const midFilter = this.ctx.createBiquadFilter();
        midFilter.type = 'bandpass';
        midFilter.frequency.value = 1000;
        midFilter.Q.value = 0.7;
        
        const highFilter = this.ctx.createBiquadFilter();
        highFilter.type = 'highpass';
        highFilter.frequency.value = 4000;
        highFilter.Q.value = 0.7;
        
        this.subBassGain.connect(subFilter);
        this.midGain.connect(midFilter);
        this.highGain.connect(highFilter);
        
        // CATHEDRAL REVERB
        this.reverb = this.ctx.createConvolver();
        const reverbTime = 6; // Epic cathedral size
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * reverbTime, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 1.2);
            data[i] = (Math.random() * 2 - 1) * decay;
          }
        }
        this.reverb.buffer = buffer;
        
        // PING PONG DELAY
        this.delay = this.ctx.createDelay(0.75);
        this.delay.delayTime.value = 0.375; // Dotted 8th
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.4;
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.25;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        this.delay.connect(delayMix);
        
        // MASSIVE COMPRESSOR
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -18;
        this.compressor.knee.value = 40;
        this.compressor.ratio.value = 16;
        this.compressor.attack.value = 0.001;
        this.compressor.release.value = 0.2;
        
        // HARMONIC DISTORTION for warmth
        this.distortion = this.ctx.createWaveShaper();
        const curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          const x = (i - 128) / 128;
          curve[i] = Math.sign(x) * (1 - Math.exp(-Math.abs(x * 2)));
        }
        this.distortion.curve = curve;
        this.distortion.oversample = '4x';
        
        // Connect the chain
        subFilter.connect(this.compressor);
        midFilter.connect(this.distortion);
        this.distortion.connect(this.compressor);
        highFilter.connect(this.reverb);
        
        this.reverb.connect(this.masterGain);
        this.compressor.connect(this.masterGain);
        delayMix.connect(this.masterGain);
        
        // Initialize layer gains
        Object.keys(this.layerStates).forEach(layer => {
          this.layerGains[layer] = this.ctx.createGain();
          this.layerGains[layer].gain.value = 0;
          this.layerGains[layer].connect(this.subBassGain);
        });
      }

      startMassiveSensors() {
        let motionBuffer = [];
        const bufferSize = 15;
        
        // DEVICE MOTION - The heart of the experience
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const dx = Math.abs(acc.x - this.last.x);
          const dy = Math.abs(acc.y - this.last.y);
          const dz = Math.abs(acc.z - this.last.z);
          
          const rawMotion = Math.sqrt(dx * dx + dy * dy + dz * dz);
          motionBuffer.push(rawMotion);
          if (motionBuffer.length > bufferSize) motionBuffer.shift();
          
          this.motion = motionBuffer.reduce((a, b) => a + b, 0) / motionBuffer.length;
          this.updateSensorHistory('motion', this.motion);

          // First movement awakening
          if (!this.firstMovement && this.motion > 1.5) {
            this.firstMovement = true;
            this.evolveToTribal();
          }

          if (this.motion > 1.5) {
            this.lastMotionTime = Date.now();
            this.totalSteps++;
          }

          // Physics for orb with momentum
          this.velocity.x += acc.x * 0.008;
          this.velocity.y += acc.y * 0.008;
          this.pos.x += this.velocity.x;
          this.pos.y += this.velocity.y;
          
          // Elastic boundaries
          if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
          if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
          
          this.pos.x = Math.max(5, Math.min(95, this.pos.x));
          this.pos.y = Math.max(5, Math.min(95, this.pos.y));
          
          // Air resistance
          this.velocity.x *= 0.96;
          this.velocity.y *= 0.96;

          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.updateEvolution();
          this.updateSensorDisplay();
        }, { passive: true });

        // DEVICE ORIENTATION for harmonic control
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          
          this.orientation = e.alpha || 0;
          this.updateSensorHistory('orientation', this.orientation);
          
          // Use orientation to modulate harmony
          const normalizedOrientation = this.orientation / 360;
          this.currentFifthPosition = Math.floor(normalizedOrientation * this.circleOfFifths.length);
          
          this.updateSensorDisplay();
        }, { passive: true });

        // Desktop fallback with epic mouse control
        this.setupDesktopFallback();
      }

      setupDesktopFallback() {
        let mouseVel = { x: 0, y: 0 };
        let lastMouse = { x: 0, y: 0, time: 0 };
        
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(1, now - lastMouse.time);
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          mouseVel.x = (newX - lastMouse.x) / dt * 100;
          mouseVel.y = (newY - lastMouse.y) / dt * 100;
          
          this.motion = Math.sqrt(mouseVel.x * mouseVel.x + mouseVel.y * mouseVel.y) * 0.3;
          this.pos.x = newX;
          this.pos.y = newY;
          
          // Simulate orientation from mouse position
          this.orientation = (newX / 100) * 360;
          this.currentFifthPosition = Math.floor((newX / 100) * this.circleOfFifths.length);
          
          if (!this.firstMovement && this.motion > 1) {
            this.firstMovement = true;
            this.evolveToTribal();
          }
          
          if (this.motion > 1) {
            this.lastMotionTime = now;
            this.totalSteps++;
          }
          
          lastMouse = { x: newX, y: newY, time: now };
          this.updateEvolution();
          this.updateSensorDisplay();
        });

        // Scroll wheel for altitude simulation
        window.addEventListener('wheel', e => {
          if (!this.active) return;
          this.altitude += e.deltaY * -0.1;
          this.altitude = Math.max(0, this.altitude);
          this.updateSensorDisplay();
        }, { passive: false });
      }

      updateSensorHistory(sensor, value) {
        this.sensorHistory[sensor].push(value);
        if (this.sensorHistory[sensor].length > 100) {
          this.sensorHistory[sensor].shift();
        }
      }

      updateSensorDisplay() {
        this.elements.motionVal.textContent = this.motion.toFixed(1);
        this.elements.altVal.textContent = Math.round(this.altitude);
        this.elements.pressureVal.textContent = this.pressure.toFixed(1);
        this.elements.orientVal.textContent = Math.round(this.orientation);
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.length > 0 ? 
          this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length : 0;
        
        // LAYER ACTIVATION based on multiple factors
        this.updateLayerActivation();
        
        // Evolution triggers with more sophisticated logic
        if (this.evolutionStage === 'TRIBAL' && this.totalSteps > 30 && avgMotion > 2) {
          this.evolveToOrchestral();
        } else if (this.evolutionStage === 'ORCHESTRAL' && this.totalSteps > 100 && avgMotion > 4) {
          this.evolveToHeaven();
        }
        
        // MASSIVE BPM calculation
        let targetBPM = 45;
        const motionFactor = Math.min(avgMotion * 8, 60);
        const altitudeFactor = Math.min(this.altitude * 0.01, 15);
        
        switch(this.evolutionStage) {
          case 'TRIBAL': 
            targetBPM = 70 + motionFactor + altitudeFactor; 
            break;
          case 'ORCHESTRAL': 
            targetBPM = 100 + motionFactor * 0.8 + altitudeFactor; 
            break;
          case 'HEAVEN': 
            targetBPM = 128 + motionFactor * 0.6 + altitudeFactor; 
            break;
        }
        
        this.bpm = this.bpm * 0.92 + targetBPM * 0.08;
        this.updateUI();
      }

      updateLayerActivation() {
        const motion = this.motion;
        const steps = this.totalSteps;
        const altitude = this.altitude;
        const orientation = this.orientation;
        
        // MASSIVE LAYER SYSTEM - Each layer activates based on different criteria
        
        // 808 Sub Bass - Always active when moving, intensity varies
        this.layerStates.sub808 = motion > 1;
        
        // Massive Kick - Tribal onwards
        this.layerStates.massiveKick = this.evolutionStage !== 'PRIMORDIAL' && motion > 1.5;
        
        // Sine Harmonics - Builds with movement
        this.layerStates.sineHarmonics = steps > 10 && motion > 2;
        
        // Circle of Fifths - Orchestral onwards
        this.layerStates.circleOfFifths = this.evolutionStage === 'ORCHESTRAL' || this.evolutionStage === 'HEAVEN';
        
        // 7th Extensions - Heaven stage
        this.layerStates.seventhExtensions = this.evolutionStage === 'HEAVEN' && motion > 3;
        
        // Orchestral Strings - Mid-tier activation
        this.layerStates.orchestralStrings = this.evolutionStage === 'ORCHESTRAL' && steps > 50;
        
        // Epic Brass - High energy moments
        this.layerStates.epicBrass = motion > 5 && (this.evolutionStage === 'ORCHESTRAL' || this.evolutionStage === 'HEAVEN');
        
        // Cosmic Choir - Altitude and heaven stage
        this.layerStates.cosmicChoir = this.evolutionStage === 'HEAVEN' && altitude > 10;
        
        // Heaven Pads - Transcendent state
        this.layerStates.heavenPads = this.transcendent || (this.evolutionStage === 'HEAVEN' && motion < 2);
        
        // Update visual indicators and gain levels
        Object.keys(this.layerStates).forEach(layer => {
          const isActive = this.layerStates[layer];
          const element = document.getElementById(`layer${layer.charAt(0).toUpperCase() + layer.slice(1).replace(/([A-Z])/g, ' $1').trim().replace(/ /g, '')}`);
          
          if (element) {
            if (isActive) {
              element.classList.add('active');
            } else {
              element.classList.remove('active');
            }
          }
          
          // Smooth gain transitions
          if (this.layerGains[layer]) {
            const targetGain = isActive ? this.calculateLayerGain(layer) : 0;
            this.layerGains[layer].gain.linearRampToValueAtTime(targetGain, this.ctx.currentTime + 0.1);
          }
        });
      }

      calculateLayerGain(layer) {
        const motion = this.motion;
        const altitude = this.altitude;
        const intensity = Math.min(motion / 10, 1);
        
        switch(layer) {
          case 'sub808': return 0.8 + (intensity * 0.4);
          case 'massiveKick': return 0.7 + (intensity * 0.3);
          case 'sineHarmonics': return 0.5 + (intensity * 0.3);
          case 'circleOfFifths': return 0.6 + (intensity * 0.2);
          case 'seventhExtensions': return 0.4 + (intensity * 0.4);
          case 'orchestralStrings': return 0.5 + (intensity * 0.3);
          case 'epicBrass': return 0.6 + (intensity * 0.5);
          case 'cosmicChoir': return 0.3 + (altitude * 0.001);
          case 'heavenPads': return 0.7 + (this.transcendentIntensity * 0.5);
          default: return 0.5;
        }
      }

      evolveToTribal() {
        this.evolutionStage = 'TRIBAL';
        this.elements.orb.className = 'orb tribal';
        this.createParticles('tribal');
        this.elements.stage.textContent = 'TRIBAL AWAKENING';
        this.elements.substage.textContent = 'Primal rhythms emerging from movement...';
        console.log('ðŸ”¥ MASSIVE TRIBAL EVOLUTION');
      }

      evolveToOrchestral() {
        this.evolutionStage = 'ORCHESTRAL';
        this.elements.orb.className = 'orb orchestral';
        this.createParticles('orchestral');
        this.elements.stage.textContent = 'ORCHESTRAL SYNTHESIS';
        this.elements.substage.textContent = 'Complex harmonies and structured rhythms...';
        console.log('ðŸŽ¼ EPIC ORCHESTRAL EVOLUTION');
      }

      evolveToHeaven() {
        this.evolutionStage = 'HEAVEN';
        this.elements.orb.className = 'orb heaven';
        this.createParticles('heaven');
        this.elements.stage.textContent = 'COSMIC TRANSCENDENCE';
        this.elements.substage.textContent = 'Massive synthesis and harmonic perfection...';
        console.log('âœ¨ TRANSCENDENTAL HEAVEN EVOLUTION');
      }

      createParticles(type) {
        const existing = document.getElementById('particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.id = 'particles';
        container.className = 'particles';
        document.body.appendChild(container);
        
        const count = type === 'heaven' ? 60 : type === 'orchestral' ? 35 : 20;
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = `particle ${type}`;
          particle.style.left = Math.random() * 100 + '%';
          particle.style.animationDelay = Math.random() * 8 + 's';
          particle.style.animationDuration = (6 + Math.random() * 6) + 's';
          container.appendChild(particle);
        }
      }

      startLayeredEvolution() {
        const tick = () => {
          if (!this.active) return;

          const interval = 60000 / this.bpm / 4; // 16th notes
          const swingFactor = (this.step % 2 === 1) ? 1 + this.swing : 1;

          this.playMassiveLayers();
          
          this.step = (this.step + 1) % 32; // Longer phrases for complexity
          
          // Harmonic progression every 8 steps
          if (this.step % 8 === 0) {
            this.advanceHarmony();
          }

          setTimeout(tick, interval * swingFactor);
        };
        tick();
      }

      playMassiveLayers() {
        // Visual beat pulse
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 250);
        }

        // Play active layers
        if (this.layerStates.sub808) this.play808SubBass();
        if (this.layerStates.massiveKick && this.step % 4 === 0) this.playMassiveKick();
        if (this.layerStates.sineHarmonics) this.playSineHarmonics();
        if (this.layerStates.circleOfFifths && this.step % 2 === 0) this.playCircleOfFifths();
        if (this.layerStates.seventhExtensions && this.step % 8 === 0) this.playSeventhExtensions();
        if (this.layerStates.orchestralStrings && this.step % 4 === 2) this.playOrchestralStrings();
        if (this.layerStates.epicBrass && this.step % 16 === 0) this.playEpicBrass();
        if (this.layerStates.cosmicChoir && this.step % 32 === 0) this.playCosmicChoir();
        if (this.layerStates.heavenPads) this.playHeavenPads();
      }

      // =============== MASSIVE SOUND LAYERS ===============

      play808SubBass() {
        if (this.oscillators.size > 50) return;
        
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const freq = this.noteFreqs[rootNote] * 0.5; // Sub-bass territory
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(freq * 0.7, this.ctx.currentTime + 0.8);
        
        filter.type = 'lowpass';
        filter.frequency.value = 80 + this.motion * 10;
        filter.Q.value = 3;
        
        const intensity = this.calculateLayerGain('sub808');
        gain.gain.setValueAtTime(intensity, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.2);
        
        osc.connect(filter).connect(gain).connect(this.layerGains.sub808);
        osc.start();
        osc.stop(this.ctx.currentTime + 1.2);
        
        this.oscillators.add(osc);
        setTimeout(() => this.oscillators.delete(osc), 1200);
      }

      playMassiveKick() {
        if (this.oscillators.size > 50) return;
        
        // Multi-layer kick for massive impact
        const layers = [
          { freq: 50, type: 'sine', decay: 0.6 },      // Sub thump
          { freq: 80, type: 'triangle', decay: 0.4 },  // Body
          { freq: 2000, type: 'square', decay: 0.05 }  // Click
        ];
        
        layers.forEach((layer, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = layer.type;
          osc.frequency.setValueAtTime(layer.freq, this.ctx.currentTime);
          if (i < 2) { // Pitch bend for low layers
            osc.frequency.exponentialRampToValueAtTime(layer.freq * 0.5, this.ctx.currentTime + layer.decay);
          }
          
          filter.type = i === 2 ? 'highpass' : 'lowpass';
          filter.frequency.value = 150 + this.transcendentIntensity * 200;
          filter.Q.value = 15;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.15 * this.transcendentIntensity, this.ctx.currentTime + 3);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 15);
          
          osc.connect(filter).connect(gain).connect(this.reverb);
          osc.start();
          osc.stop(this.ctx.currentTime + 15);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 15000);
        }
      }

      updateUI() {
        let stageText = this.evolutionStage;
        let substageText = '';
        
        const motionIndicator = 'â—'.repeat(Math.min(Math.floor(this.motion), 10));
        const altitudeIndicator = Math.round(this.altitude);
        
        switch(this.evolutionStage) {
          case 'PRIMORDIAL':
            substageText = 'Waiting for movement to spark creation...';
            break;
          case 'TRIBAL':
            substageText = `Motion: ${motionIndicator} â€¢ BPM: ${Math.round(this.bpm)} â€¢ Steps: ${this.totalSteps}`;
            break;
          case 'ORCHESTRAL':
            substageText = `Harmonics Active â€¢ Alt: ${altitudeIndicator}m â€¢ BPM: ${Math.round(this.bpm)}`;
            break;
          case 'HEAVEN':
            substageText = `Cosmic Synthesis â€¢ ${Object.values(this.layerStates).filter(Boolean).length}/9 Layers`;
            break;
        }
        
        if (this.transcendent) {
          substageText += ` â€¢ VOID STATE (${Math.round(this.transcendentIntensity * 100)}%)`;
        }
        
        this.elements.stage.textContent = stageText;
        this.elements.substage.textContent = substageText;
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          this.frameCount++;
          
          // Update orb position with physics
          this.elements.orb.style.left = `${this.pos.x}%`;
          this.elements.orb.style.top = `${this.pos.y}%`;
          
          // Update UI every 30 frames (0.5 seconds at 60fps)
          if (this.frameCount % 30 === 0) {
            this.updateUI();
          }
          
          // Dynamic background based on evolution and layers
          if (this.frameCount % 60 === 0 && !this.transcendent) {
            const activeLayerCount = Object.values(this.layerStates).filter(Boolean).length;
            const intensity = Math.min(activeLayerCount / 9, 1);
            
            let bgColor = 'black';
            if (this.evolutionStage === 'TRIBAL') {
              bgColor = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                rgba(255, 107, 107, ${0.1 * intensity}) 0%, 
                rgba(255, 159, 67, ${0.05 * intensity}) 30%, 
                black 70%)`;
            } else if (this.evolutionStage === 'ORCHESTRAL') {
              bgColor = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                rgba(78, 205, 196, ${0.1 * intensity}) 0%, 
                rgba(69, 183, 209, ${0.05 * intensity}) 40%, 
                black 80%)`;
            } else if (this.evolutionStage === 'HEAVEN') {
              bgColor = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, 
                rgba(108, 92, 231, ${0.15 * intensity}) 0%, 
                rgba(253, 121, 168, ${0.1 * intensity}) 25%, 
                rgba(162, 155, 254, ${0.05 * intensity}) 50%, 
                black 100%)`;
            }
            document.body.style.background = bgColor;
          }
          
          // Particle system responsiveness
          if (this.frameCount % 120 === 0 && this.motion > 3) {
            this.createParticles(this.evolutionStage.toLowerCase());
          }

          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }

      // Cleanup for performance
      cleanup() {
        this.oscillators.forEach(osc => {
          try {
            osc.stop();
          } catch (e) {}
        });
        this.oscillators.clear();
        
        Object.values(this.layerGains).forEach(gain => {
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        });
      }

      // Debug info for development
      getSystemInfo() {
        return {
          oscillatorCount: this.oscillators.size,
          activeLayers: Object.entries(this.layerStates).filter(([k, v]) => v).map(([k]) => k),
          evolutionStage: this.evolutionStage,
          bpm: Math.round(this.bpm),
          motion: this.motion.toFixed(2),
          altitude: Math.round(this.altitude),
          transcendent: this.transcendent,
          transcendentIntensity: this.transcendentIntensity.toFixed(2)
        };
      }
    }

    // Initialize the massive evolution
    const gump = new MassiveGUMP();
    
    // Global access for debugging
    window.gump = gump;
    
    // Performance monitoring
    setInterval(() => {
      if (gump.active && gump.oscillators.size > 60) {
        console.warn('High oscillator count:', gump.oscillators.size);
        gump.cleanup();
      }
    }, 5000);
    
    // Easter egg: Konami code for instant heaven mode
    let konamiCode = [];
    const konamiSequence = [38, 38, 40, 40, 37, 39, 37, 39, 66, 65]; // â†‘â†‘â†“â†“â†â†’â†â†’BA
    
    document.addEventListener('keydown', (e) => {
      konamiCode.push(e.keyCode);
      if (konamiCode.length > 10) konamiCode.shift();
      
      if (konamiCode.length === 10 && konamiCode.every((code, i) => code === konamiSequence[i])) {
        if (gump.active) {
          gump.evolveToHeaven();
          gump.totalSteps = 200;
          gump.motion = 10;
          console.log('ðŸš€ KONAMI CODE ACTIVATED - INSTANT HEAVEN MODE!');
        }
      }
    });
  </script>
</body>
</html>.value = i === 2 ? 1000 : 150 + this.motion * 20;
          filter.Q.value = 2;
          
          const intensity = this.calculateLayerGain('massiveKick') * (i === 0 ? 1.2 : i === 1 ? 0.8 : 0.6);
          gain.gain.setValueAtTime(intensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + layer.decay);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.massiveKick);
          osc.start();
          osc.stop(this.ctx.currentTime + layer.decay);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), layer.decay * 1000);
        });
      }

      playSineHarmonics() {
        if (this.oscillators.size > 50) return;
        
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const fundamental = this.noteFreqs[rootNote] * 2;
        
        // Create harmonic series
        const harmonics = [1, 2, 3, 4, 5, 7, 9]; // Skip some for musicality
        
        harmonics.forEach((harmonic, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const lfo = this.ctx.createOscillator();
          const lfoGain = this.ctx.createGain();
          
          osc.type = 'sine';
          osc.frequency.value = fundamental * harmonic;
          
          // LFO for subtle movement
          lfo.type = 'sine';
          lfo.frequency.value = 0.1 + (harmonic * 0.05);
          lfoGain.gain.value = fundamental * harmonic * 0.001;
          lfo.connect(lfoGain);
          lfoGain.connect(osc.frequency);
          
          const intensity = this.calculateLayerGain('sineHarmonics') / (harmonic * 2);
          gain.gain.setValueAtTime(intensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(gain).connect(this.layerGains.sineHarmonics);
          lfo.start();
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
          lfo.stop(this.ctx.currentTime + 2);
          
          this.oscillators.add(osc);
          this.oscillators.add(lfo);
          setTimeout(() => {
            this.oscillators.delete(osc);
            this.oscillators.delete(lfo);
          }, 2000);
        });
      }

      playCircleOfFifths() {
        if (this.oscillators.size > 50) return;
        
        // Play the current fifth and its perfect fifth
        const currentNote = this.circleOfFifths[this.currentFifthPosition];
        const fifthNote = this.circleOfFifths[(this.currentFifthPosition + 1) % this.circleOfFifths.length];
        
        [currentNote, fifthNote].forEach((note, i) => {
          const freq = this.noteFreqs[note] * (2 + i);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 800 + this.motion * 100 + this.altitude * 2;
          filter.Q.value = 4;
          
          const intensity = this.calculateLayerGain('circleOfFifths') * (i === 0 ? 1 : 0.7);
          gain.gain.setValueAtTime(intensity, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1.5);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.circleOfFifths);
          osc.start();
          osc.stop(this.ctx.currentTime + 1.5);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 1500);
        });
      }

      playSeventhExtensions() {
        if (this.oscillators.size > 50) return;
        
        // Choose chord type based on motion and altitude
        let chordType = 'major7';
        if (this.motion > 5) chordType = 'dominant13';
        else if (this.altitude > 50) chordType = 'major9';
        else if (this.transcendent) chordType = 'minor11';
        
        const chord = this.seventhChords[chordType];
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        
        chord.forEach((interval, i) => {
          const note = (rootNote + interval) % 12;
          const freq = this.noteFreqs[note] * (1 + Math.floor(i / 4));
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = i < 4 ? 'sine' : 'triangle';
          osc.frequency.value = freq;
          
          filter.type = 'bandpass';
          filter.frequency.value = freq * 2 + this.motion * 50;
          filter.Q.value = 6;
          
          const intensity = this.calculateLayerGain('seventhExtensions') / chord.length;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(intensity, this.ctx.currentTime + 0.5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          osc.connect(filter).connect(gain).connect(this.layerGains.seventhExtensions);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 4000);
        });
      }

      playOrchestralStrings() {
        if (this.oscillators.size > 50) return;
        
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const chord = [rootNote, (rootNote + 4) % 12, (rootNote + 7) % 12, (rootNote + 11) % 12];
        
        chord.forEach((note, i) => {
          // Multiple oscillators per note for thickness
          for (let j = 0; j < 3; j++) {
            const freq = this.noteFreqs[note] * (1 + i * 0.5) * (1 + j * 0.002); // Slight detune
            
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            
            osc.type = 'sawtooth';
            osc.frequency.value = freq;
            
            filter.type = 'lowpass';
            filter.frequency.value = 1200 + this.motion * 200;
            filter.Q.value = 2;
            
            const intensity = this.calculateLayerGain('orchestralStrings') / (chord.length * 3);
            gain.gain.setValueAtTime(0, this.ctx.currentTime);
            gain.gain.linearRampToValueAtTime(intensity, this.ctx.currentTime + 0.3);
            gain.gain.linearRampToValueAtTime(intensity * 0.8, this.ctx.currentTime + 2);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 3);
            
            osc.connect(filter).connect(gain).connect(this.layerGains.orchestralStrings);
            osc.start();
            osc.stop(this.ctx.currentTime + 3);
            
            this.oscillators.add(osc);
            setTimeout(() => this.oscillators.delete(osc), 3000);
          }
        });
      }

      playEpicBrass() {
        if (this.oscillators.size > 50) return;
        
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const freq = this.noteFreqs[rootNote] * 3;
        
        // Massive brass chord
        const intervals = [0, 4, 7, 10, 14]; // Major 7th with extensions
        
        intervals.forEach((interval, i) => {
          const noteFreq = freq * Math.pow(2, interval / 12);
          
          const osc1 = this.ctx.createOscillator();
          const osc2 = this.ctx.createOscillator();
          const osc3 = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc1.type = 'sawtooth';
          osc2.type = 'square';
          osc3.type = 'triangle';
          
          osc1.frequency.value = noteFreq;
          osc2.frequency.value = noteFreq * 1.002; // Slight detune
          osc3.frequency.value = noteFreq * 0.998;
          
          filter.type = 'bandpass';
          filter.frequency.value = noteFreq + this.motion * 100;
          filter.Q.value = 8;
          
          const intensity = this.calculateLayerGain('epicBrass') / intervals.length;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(intensity, this.ctx.currentTime + 0.1);
          gain.gain.linearRampToValueAtTime(intensity * 0.9, this.ctx.currentTime + 1);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2.5);
          
          osc1.connect(filter);
          osc2.connect(filter);
          osc3.connect(filter);
          filter.connect(gain).connect(this.layerGains.epicBrass);
          
          osc1.start();
          osc2.start();
          osc3.start();
          osc1.stop(this.ctx.currentTime + 2.5);
          osc2.stop(this.ctx.currentTime + 2.5);
          osc3.stop(this.ctx.currentTime + 2.5);
          
          [osc1, osc2, osc3].forEach(osc => {
            this.oscillators.add(osc);
            setTimeout(() => this.oscillators.delete(osc), 2500);
          });
        });
      }

      playCosmicChoir() {
        if (this.oscillators.size > 50) return;
        
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const chord = this.seventhChords.major9;
        
        chord.forEach((interval, i) => {
          const note = (rootNote + interval) % 12;
          const freq = this.noteFreqs[note] * 8; // High register
          
          // Formant synthesis for vocal quality
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          // Vocal formant filters
          const formant1 = this.ctx.createBiquadFilter();
          const formant2 = this.ctx.createBiquadFilter();
          const formant3 = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          // "Ahh" vowel formants modified by altitude
          formant1.type = 'bandpass';
          formant1.frequency.value = 730 + this.altitude * 0.5;
          formant1.Q.value = 10;
          
          formant2.type = 'bandpass';
          formant2.frequency.value = 1090 + this.altitude * 0.3;
          formant2.Q.value = 8;
          
          formant3.type = 'bandpass';
          formant3.frequency.value = 2440 + this.altitude * 0.2;
          formant3.Q.value = 6;
          
          const intensity = this.calculateLayerGain('cosmicChoir') / chord.length;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(intensity, this.ctx.currentTime + 1);
          gain.gain.linearRampToValueAtTime(intensity * 0.8, this.ctx.currentTime + 5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
          
          osc.connect(formant1);
          formant1.connect(formant2);
          formant2.connect(formant3);
          formant3.connect(gain);
          gain.connect(this.layerGains.cosmicChoir);
          
          osc.start();
          osc.stop(this.ctx.currentTime + 8);
          
          this.oscillators.add(osc);
          setTimeout(() => this.oscillators.delete(osc), 8000);
        });
      }

      playHeavenPads() {
        if (this.oscillators.size > 50) return;
        
        const rootNote = this.circleOfFifths[this.currentFifthPosition];
        const extensions = this.seventhChords.dominant13;
        
        extensions.forEach((interval, i) => {
          const note = (rootNote + interval) % 12;
          const freq = this.noteFreqs[note] * 0.25; // Sub-harmonic territory
          
          // Multiple detuned oscillators for massive pad
          for (let j = 0; j < 4; j++) {
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            const filter = this.ctx.createBiquadFilter();
            const lfo = this.ctx.createOscillator();
            const lfoGain = this.ctx.createGain();
            
            osc.type = j % 2 === 0 ? 'sine' : 'triangle';
            osc.frequency.value = freq * (1 + j * 0.003); // Gentle detune
            
            // Filter LFO for movement
            lfo.type = 'sine';
            lfo.frequency.value = 0.05 + (j * 0.02);
            lfoGain.gain.value = 300 + this.transcendentIntensity * 500;
            lfo.connect(lfoGain);
            lfoGain.connect(filter.frequency);
            
            filter.type = 'lowpass';
            filter.frequency.value = 200 + this.transcendentIntensity * 600;
            filter.Q.value = 12;
            
            const intensity = this.calculateLayerGain('heavenPads') / (extensions.length * 4);
            gain.gain.setValueAtTime(intensity, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 12);
            
            osc.connect(filter).connect(gain).connect(this.layerGains.heavenPads);
            lfo.start();
            osc.start();
            osc.stop(this.ctx.currentTime + 12);
            lfo.stop(this.ctx.currentTime + 12);
            
            this.oscillators.add(osc);
            this.oscillators.add(lfo);
            setTimeout(() => {
              this.oscillators.delete(osc);
              this.oscillators.delete(lfo);
            }, 12000);
          }
        });
      }

      advanceHarmony() {
        // Sophisticated harmonic movement
        if (this.evolutionStage === 'HEAVEN') {
          // Complex modulation based on sensor data
          const motionInfluence = Math.floor(this.motion) % this.circleOfFifths.length;
          const altitudeInfluence = Math.floor(this.altitude / 10) % this.circleOfFifths.length;
          this.currentFifthPosition = (motionInfluence + altitudeInfluence) % this.circleOfFifths.length;
        } else {
          // Standard progression
          this.currentFifthPosition = (this.currentFifthPosition + 1) % this.circleOfFifths.length;
        }
        
        // Update delay time based on new harmony
        if (this.delay) {
          const newDelay = 60000 / this.bpm / 8; // 32nd note delay
          this.delay.delayTime.setValueAtTime(newDelay / 1000, this.ctx.currentTime + 0.1);
        }
      }

      monitorTranscendence() {
        const check = () => {
          if (!this.active) return;
          
          const now = Date.now();
          const stillTime = now - this.lastMotionTime;
          const shouldTranscend = stillTime > 1500;

          if (shouldTranscend && !this.transcendent) {
            this.enterTranscendence();
          } else if (!shouldTranscend && this.transcendent) {
            this.exitTranscendence();
          }

          if (this.transcendent) {
            this.transcendentIntensity = Math.min(1, (stillTime - 1500) / 3000);
            this.deepenTranscendence();
          }

          setTimeout(check, 100);
        };
        check();
      }

      enterTranscendence() {
        this.transcendent = true;
        this.elements.substage.textContent = 'Entering transcendent void...';
        document.body.style.background = 'radial-gradient(circle, #0a0a0a 0%, #000 100%)';
        
        // Slow down and add space
        this.bpm *= 0.6;
        this.swing = 0.4;
      }

      exitTranscendence() {
        this.transcendent = false;
        this.transcendentIntensity = 0;
        document.body.style.background = 'black';
        this.updateUI();
      }

      deepenTranscendence() {
        // Add cosmic textures during stillness
        if (Math.random() < 0.015 * this.transcendentIntensity) {
          this.playCosmicDrone();
        }
      }

      playCosmicDrone() {
        if (this.oscillators.size > 55) return;
        
        const freq = this.noteFreqs[this.circleOfFifths[this.currentFifthPosition]] * 0.125;
        
        // Multiple drone layers
        for (let i = 0; i < 3; i++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sine';
          osc.frequency.value = freq * (1 + i * 0.001); // Beating
          
          filter.type = 'lowpass';
          filter.frequency
