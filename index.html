<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh}
        canvas{position:fixed;inset:0}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 2s}
        #enter div{width:120px;height:120px;border-radius:50%;border:1px solid rgba(255,255,255,0.1);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:4px;color:rgba(255,255,255,0.25);transition:0.5s}
        #enter:hover div{border-color:rgba(255,255,255,0.3);color:rgba(255,255,255,0.5)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// Sound as life. Harmonics as creatures. Chaos into form.

const TAU = Math.PI * 2;
const PHI = 1.618033988749;

// ============ THE UNIVERSE ============

let ctx, master, verb, dly, sub;
let entities = [];
let field = { x: 0.5, y: 0.5, vx: 0, vy: 0, energy: 0, time: 0 };
let canvas, vc;
let running = false;

// The harmonic ratios - intervals that want to exist
const RATIOS = [
    1,      // unison
    9/8,    // major second
    5/4,    // major third
    4/3,    // perfect fourth
    3/2,    // perfect fifth
    5/3,    // major sixth
    15/8,   // major seventh
    2,      // octave
    9/4,    // ninth
    5/2,    // tenth
    3,      // twelfth (octave + fifth)
    4,      // double octave
];

const BASE = 55; // A1

// Consonance map - how much ratios attract each other
function consonance(r1, r2) {
    const ratio = r1 > r2 ? r1/r2 : r2/r1;
    // Perfect consonances
    if (Math.abs(ratio - 1) < 0.01) return 1;      // unison
    if (Math.abs(ratio - 2) < 0.01) return 0.95;   // octave
    if (Math.abs(ratio - 1.5) < 0.01) return 0.9;  // fifth
    if (Math.abs(ratio - 4/3) < 0.02) return 0.85; // fourth
    // Imperfect consonances
    if (Math.abs(ratio - 5/4) < 0.02) return 0.7;  // major third
    if (Math.abs(ratio - 6/5) < 0.02) return 0.65; // minor third
    if (Math.abs(ratio - 5/3) < 0.02) return 0.6;  // major sixth
    // Mild dissonance creates interest
    return 0.3;
}

// ============ ENTITY - A LIVING HARMONIC ============

class Entity {
    constructor(ratio, index) {
        this.ratio = ratio;
        this.freq = BASE * ratio;
        this.index = index;

        // Position in space (0-1)
        this.x = 0.5 + (Math.random() - 0.5) * 0.3;
        this.y = 0.5 + (Math.random() - 0.5) * 0.3;

        // Velocity
        this.vx = (Math.random() - 0.5) * 0.01;
        this.vy = (Math.random() - 0.5) * 0.01;

        // Properties
        this.mass = 1 / ratio; // Lower = heavier
        this.brightness = 0;
        this.life = 1;

        // Audio
        this.osc = null;
        this.osc2 = null;
        this.filter = null;
        this.gain = null;
        this.pan = null;
        this.mod = null;
        this.modGain = null;

        // Visual
        this.trail = [];
        this.maxTrail = 30;
        this.hue = 220 - (Math.log2(ratio) * 40);
    }

    createAudio() {
        // Main oscillator
        this.osc = ctx.createOscillator();
        this.osc.type = this.ratio < 2 ? 'sine' : 'triangle';
        this.osc.frequency.value = this.freq;

        // Detuned oscillator for warmth
        this.osc2 = ctx.createOscillator();
        this.osc2.type = 'sine';
        this.osc2.frequency.value = this.freq * 1.002;

        // FM modulator
        this.mod = ctx.createOscillator();
        this.modGain = ctx.createGain();
        this.mod.type = 'sine';
        this.mod.frequency.value = this.freq * PHI; // Golden ratio modulation
        this.modGain.gain.value = 0;
        this.mod.connect(this.modGain);
        this.modGain.connect(this.osc.frequency);

        // Filter
        this.filter = ctx.createBiquadFilter();
        this.filter.type = 'lowpass';
        this.filter.frequency.value = 200;
        this.filter.Q.value = 1;

        // Gain
        this.gain = ctx.createGain();
        this.gain.gain.value = 0;

        // Pan
        this.pan = ctx.createStereoPanner();
        this.pan.pan.value = 0;

        // Connect
        this.osc.connect(this.filter);
        this.osc2.connect(this.filter);
        this.filter.connect(this.gain);
        this.gain.connect(this.pan);
        this.pan.connect(master);
        this.pan.connect(verb.input);
        this.pan.connect(dly.input);

        this.osc.start();
        this.osc2.start();
        this.mod.start();
    }

    update(dt) {
        const now = ctx.currentTime;

        // ============ PHYSICS ============

        // Attraction to cursor
        const dx = field.x - this.x;
        const dy = field.y - this.y;
        const distToCursor = Math.sqrt(dx*dx + dy*dy);
        const cursorForce = 0.0003 / (distToCursor + 0.1);

        this.vx += dx * cursorForce;
        this.vy += dy * cursorForce;

        // Attraction/repulsion to other entities based on consonance
        for (const other of entities) {
            if (other === this) continue;

            const odx = other.x - this.x;
            const ody = other.y - this.y;
            const dist = Math.sqrt(odx*odx + ody*ody);
            if (dist < 0.01) continue;

            const cons = consonance(this.ratio, other.ratio);

            // Consonant = attract, dissonant = slight repel
            const force = (cons - 0.4) * 0.00005 / (dist + 0.05);

            this.vx += odx * force;
            this.vy += ody * force;
        }

        // Gentle pull toward center (prevents escape)
        this.vx += (0.5 - this.x) * 0.0001;
        this.vy += (0.5 - this.y) * 0.0001;

        // Angular momentum from cursor movement (creates spirals)
        const perpX = -dy;
        const perpY = dx;
        this.vx += perpX * field.vx * 0.01;
        this.vy += perpY * field.vx * 0.01;

        // Damping
        this.vx *= 0.995;
        this.vy *= 0.995;

        // Update position
        this.x += this.vx;
        this.y += this.vy;

        // Soft boundaries
        if (this.x < 0.05) { this.x = 0.05; this.vx *= -0.5; }
        if (this.x > 0.95) { this.x = 0.95; this.vx *= -0.5; }
        if (this.y < 0.05) { this.y = 0.05; this.vy *= -0.5; }
        if (this.y > 0.95) { this.y = 0.95; this.vy *= -0.5; }

        // Trail
        this.trail.unshift({ x: this.x, y: this.y });
        if (this.trail.length > this.maxTrail) this.trail.pop();

        // ============ SOUND ============

        // Amplitude based on distance to cursor
        const proximity = 1 - Math.min(1, distToCursor * 2);
        const baseAmp = proximity * 0.08 * this.mass;

        // Brightness from velocity
        const vel = Math.sqrt(this.vx*this.vx + this.vy*this.vy);
        this.brightness = this.brightness * 0.9 + vel * 10;

        // Set gain
        this.gain.gain.linearRampToValueAtTime(baseAmp * (0.5 + this.brightness), now + 0.05);

        // Filter follows proximity and brightness
        const filterFreq = 200 + proximity * 3000 + this.brightness * 2000;
        this.filter.frequency.linearRampToValueAtTime(filterFreq, now + 0.08);

        // FM depth from field energy
        const fmDepth = field.energy * this.freq * 0.3;
        this.modGain.gain.linearRampToValueAtTime(fmDepth, now + 0.05);

        // Pan from position
        this.pan.pan.linearRampToValueAtTime((this.x - 0.5) * 1.8, now + 0.05);

        // Subtle pitch bend toward cursor (entities "reach" for you)
        const pitchBend = 1 + dx * 0.02;
        this.osc.frequency.linearRampToValueAtTime(this.freq * pitchBend, now + 0.1);
        this.osc2.frequency.linearRampToValueAtTime(this.freq * pitchBend * 1.002, now + 0.1);
    }

    draw() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        const px = this.x * w;
        const py = this.y * h;

        const amp = this.gain.gain.value;
        if (amp < 0.001) return;

        // Trail
        if (this.trail.length > 1) {
            vc.beginPath();
            vc.moveTo(this.trail[0].x * w, this.trail[0].y * h);
            for (let i = 1; i < this.trail.length; i++) {
                vc.lineTo(this.trail[i].x * w, this.trail[i].y * h);
            }
            const trailAlpha = amp * 0.5;
            vc.strokeStyle = `hsla(${this.hue}, 70%, 60%, ${trailAlpha})`;
            vc.lineWidth = 1;
            vc.stroke();
        }

        // Core
        const r = 3 + amp * 40 + this.brightness * 20;
        const grad = vc.createRadialGradient(px, py, 0, px, py, r);
        grad.addColorStop(0, `hsla(${this.hue}, 80%, ${70 + amp * 30}%, ${0.8 + amp})`);
        grad.addColorStop(0.5, `hsla(${this.hue}, 70%, 50%, ${amp * 0.5})`);
        grad.addColorStop(1, 'transparent');

        vc.fillStyle = grad;
        vc.beginPath();
        vc.arc(px, py, r, 0, TAU);
        vc.fill();
    }
}

// ============ CONNECTIONS - THE HARMONY BETWEEN ============

function drawConnections() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    for (let i = 0; i < entities.length; i++) {
        for (let j = i + 1; j < entities.length; j++) {
            const a = entities[i];
            const b = entities[j];

            const dx = b.x - a.x;
            const dy = b.y - a.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            if (dist > 0.3) continue;

            const cons = consonance(a.ratio, b.ratio);
            if (cons < 0.6) continue;

            const amp = Math.min(a.gain.gain.value, b.gain.gain.value);
            const alpha = cons * amp * (1 - dist / 0.3) * 2;

            if (alpha < 0.02) continue;

            vc.beginPath();
            vc.moveTo(a.x * w, a.y * h);
            vc.lineTo(b.x * w, b.y * h);
            vc.strokeStyle = `rgba(255, 255, 255, ${alpha})`;
            vc.lineWidth = 1 + cons * 2;
            vc.stroke();
        }
    }
}

// ============ THE SUB - THE GRAVITY WELL ============

function createSub() {
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const gain = ctx.createGain();
    const filter = ctx.createBiquadFilter();

    osc.type = 'sine';
    osc.frequency.value = BASE / 2;
    osc2.type = 'sine';
    osc2.frequency.value = BASE / 2 * 1.001;

    filter.type = 'lowpass';
    filter.frequency.value = 80;
    gain.gain.value = 0;

    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(master);

    osc.start();
    osc2.start();

    sub = { osc, osc2, gain, filter };
}

function updateSub() {
    const now = ctx.currentTime;

    // Sub responds to the system's total energy and clustering
    let totalEnergy = 0;
    let centerMass = { x: 0, y: 0, total: 0 };

    for (const e of entities) {
        const vel = Math.sqrt(e.vx*e.vx + e.vy*e.vy);
        totalEnergy += vel;
        centerMass.x += e.x * e.mass;
        centerMass.y += e.y * e.mass;
        centerMass.total += e.mass;
    }

    if (centerMass.total > 0) {
        centerMass.x /= centerMass.total;
        centerMass.y /= centerMass.total;
    }

    // Distance from cursor to center of mass
    const dx = field.x - centerMass.x;
    const dy = field.y - centerMass.y;
    const distToCenter = Math.sqrt(dx*dx + dy*dy);

    // Sub is louder when cursor is near the center of mass
    const subAmp = 0.15 + (1 - distToCenter) * 0.15 - totalEnergy * 2;
    sub.gain.gain.linearRampToValueAtTime(Math.max(0.05, subAmp), now + 0.2);
}

// ============ EFFECTS ============

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.35;

    const times = [0.02, 0.05, 0.08, 0.13, 0.21, 0.34, 0.55, 0.89, 1.2, 1.6, 2.1];
    times.forEach((t, i) => {
        const d = ctx.createDelay(3);
        d.delayTime.value = t + Math.random() * 0.02;
        const g = ctx.createGain();
        g.gain.value = 0.3 * Math.pow(0.78, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 5000 - i * 400;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
        if (i > 4) {
            const fb = ctx.createGain();
            fb.gain.value = 0.12;
            g.connect(fb);
            fb.connect(input);
        }
    });

    return { input, output };
}

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.25;

    const delayL = ctx.createDelay(2);
    const delayR = ctx.createDelay(2);
    delayL.delayTime.value = 0.333;
    delayR.delayTime.value = 0.5;

    const fbL = ctx.createGain();
    const fbR = ctx.createGain();
    fbL.gain.value = 0.35;
    fbR.gain.value = 0.3;

    const filterL = ctx.createBiquadFilter();
    const filterR = ctx.createBiquadFilter();
    filterL.type = filterR.type = 'lowpass';
    filterL.frequency.value = filterR.frequency.value = 2000;

    const panL = ctx.createStereoPanner();
    const panR = ctx.createStereoPanner();
    panL.pan.value = -0.8;
    panR.pan.value = 0.8;

    input.connect(delayL);
    delayL.connect(filterL);
    filterL.connect(fbL);
    fbL.connect(delayR);
    delayR.connect(filterR);
    filterR.connect(fbR);
    fbR.connect(delayL);

    filterL.connect(panL);
    filterR.connect(panR);
    panL.connect(output);
    panR.connect(output);

    return { input, output, delayL, delayR, fbL, fbR };
}

// ============ INITIALIZATION ============

function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    master = ctx.createGain();
    master.gain.value = 0.7;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.ratio.value = 6;
    comp.attack.value = 0.003;
    comp.release.value = 0.2;

    const limiter = ctx.createDynamicsCompressor();
    limiter.threshold.value = -2;
    limiter.ratio.value = 20;
    limiter.attack.value = 0.001;
    limiter.release.value = 0.1;

    verb = createVerb();
    dly = createDelay();

    master.connect(comp);
    comp.connect(limiter);
    limiter.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    // Create the sub
    createSub();

    // Birth the entities
    RATIOS.forEach((ratio, i) => {
        const entity = new Entity(ratio, i);
        entity.createAudio();
        entities.push(entity);
    });

    // Canvas
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

// ============ INPUT ============

function onMove(nx, ny) {
    nx = Math.max(0, Math.min(1, nx));
    ny = Math.max(0, Math.min(1, ny));

    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = field.x * 0.8 + nx * 0.2;
    field.y = field.y * 0.8 + ny * 0.2;

    field.energy = field.energy * 0.9 + Math.sqrt(field.vx*field.vx + field.vy*field.vy) * 0.5;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 8;
    const ay = (a.y || 0) / 8;

    field.vx = field.vx * 0.7 + ax * 0.3;
    field.vy = field.vy * 0.7 + ay * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.08));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.08));

    field.energy = field.energy * 0.9 + Math.sqrt(ax*ax + ay*ay) * 0.3;
}

function onOrientation(e) {
    const gx = Math.max(-1, Math.min(1, (e.gamma || 0) / 40));
    const gy = Math.max(-1, Math.min(1, (e.beta || 0) / 40 - 1));
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ VISUALIZATION ============

function resize() {
    canvas.width = window.innerWidth * devicePixelRatio;
    canvas.height = window.innerHeight * devicePixelRatio;
    vc.scale(devicePixelRatio, devicePixelRatio);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade
    vc.fillStyle = 'rgba(0, 0, 0, 0.08)';
    vc.fillRect(0, 0, w, h);

    // Connections between consonant entities
    drawConnections();

    // Entities
    for (const e of entities) {
        e.draw();
    }

    // Cursor presence
    const cx = field.x * w;
    const cy = field.y * h;
    const cursorR = 20 + field.energy * 60;
    const cursorGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, cursorR);
    cursorGrad.addColorStop(0, `rgba(255, 255, 255, ${0.3 + field.energy * 0.5})`);
    cursorGrad.addColorStop(0.5, `rgba(200, 220, 255, ${0.1 + field.energy * 0.2})`);
    cursorGrad.addColorStop(1, 'transparent');
    vc.fillStyle = cursorGrad;
    vc.beginPath();
    vc.arc(cx, cy, cursorR, 0, TAU);
    vc.fill();
}

// ============ LOOP ============

function tick() {
    if (!running) return;

    field.time += 0.016;

    // Update all entities
    for (const e of entities) {
        e.update(0.016);
    }

    // Update sub
    updateSub();

    // Draw
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    init();

    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
