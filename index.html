<!DOCTYPE html>

<html lang="en">

<head>

    <meta charset="UTF-8">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">

    <title>GUMP: Meta Engine</title>

    <style>

        :root {

            --phi: 1.618033988749895;

            --bg: #000;

            --glow: #ff00ff;

        }

     

        * {

            margin: 0;

            padding: 0;

            box-sizing: border-box;

            -webkit-tap-highlight-color: transparent;

        }

     

        body {

            background: var(--bg);

            overflow: hidden;

            height: 100vh;

            font-family: -apple-system, sans-serif;

            font-weight: 100;

            cursor: none;

        }

     

        /* Custom Cursor */

        .cursor {

            position: fixed;

            width: 20px;

            height: 20px;

            border: 1px solid var(--glow);

            border-radius: 50%;

            pointer-events: none;

            z-index: 10000;

            mix-blend-mode: screen;

            transition: transform 0.1s ease;

        }

     

        .cursor-trail {

            position: fixed;

            width: 40px;

            height: 40px;

            background: radial-gradient(circle, var(--glow) 0%, transparent 70%);

            border-radius: 50%;

            pointer-events: none;

            opacity: 0.2;

            z-index: 9999;

        }

     

        /* Fibonacci Spiral Layout */

        .fibonacci-container {

            position: fixed;

            inset: 0;

            display: flex;

            align-items: center;

            justify-content: center;

        }

     

        .golden-rect {

            position: absolute;

            border: 1px solid rgba(255,0,255,0.1);

            pointer-events: none;

        }

     

        /* Core Orb - Center of Spiral */

        .core-orb {

            width: 233px;

            height: 233px;

            position: absolute;

            top: 50%;

            left: 38.2%;

            transform: translate(-50%, -50%);

            cursor: pointer;

            z-index: 100;

        }

     

        .orb-inner {

            width: 100%;

            height: 100%;

            border-radius: 50%;

            background: radial-gradient(circle at 38.2% 38.2%,

                rgba(255,255,255,0.2) 0%,

                var(--glow) 23.6%,

                rgba(255,0,255,0.5) 38.2%,

                rgba(138,0,255,0.3) 61.8%,

                transparent 100%);

            box-shadow: 0 0 100px var(--glow),

                       inset 0 0 50px rgba(255,255,255,0.2);

            animation: breathe 4s ease-in-out infinite;

        }

     

        @keyframes breathe {

            0%, 100% { transform: scale(1) rotate(0deg); filter: brightness(1); }

            50% { transform: scale(1.05) rotate(180deg); filter: brightness(1.3); }

        }

     

        .orb-ring {

            position: absolute;

            inset: -20px;

            border-radius: 50%;

            background: conic-gradient(from 0deg,

                transparent,

                var(--glow),

                transparent,

                var(--glow),

                transparent);

            animation: spin 10s linear infinite;

            opacity: 0.5;

        }

     

        @keyframes spin {

            100% { transform: rotate(360deg); }

        }

     

        /* Sample Nodes - Fibonacci Positions */

        .sample-node {

            position: absolute;

            width: 55px;

            height: 55px;

            border-radius: 50%;

            background: radial-gradient(circle at center,

                rgba(255,0,255,0.2) 0%,

                transparent 61.8%);

            border: 1px solid rgba(255,0,255,0.3);

            cursor: pointer;

            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);

            display: flex;

            align-items: center;

            justify-content: center;

            font-size: 8px;

            color: var(--glow);

            opacity: 0.5;

        }

     

        .sample-node.loaded {

            background: radial-gradient(circle at center,

                var(--glow) 0%,

                rgba(255,0,255,0.5) 38.2%,

                transparent 100%);

            opacity: 1;

            animation: pulse 2s ease-in-out infinite;

        }

     

        @keyframes pulse {

            0%, 100% { transform: scale(1); }

            50% { transform: scale(1.1); }

        }

     

        .sample-node.playing {

            box-shadow: 0 0 30px var(--glow);

            transform: scale(0.9);

        }

     

        /* Spectrum Visualizer - Full Screen */

        .spectrum-canvas {

            position: fixed;

            inset: 0;

            opacity: 0.5;

            pointer-events: none;

            mix-blend-mode: screen;

        }

     

        /* Waveform Scope */

        .waveform-scope {

            position: fixed;

            bottom: 34px;

            left: 50%;

            transform: translateX(-50%);

            width: 377px;

            height: 89px;

            border: 1px solid rgba(255,0,255,0.2);

            background: rgba(0,0,0,0.5);

            opacity: 0.7;

        }

     

        /* Info Overlay */

        .info-overlay {

            position: fixed;

            top: 21px;

            left: 21px;

            font-size: 13px;

            color: rgba(255,255,255,0.5);

            letter-spacing: 2px;

            text-transform: uppercase;

            line-height: 1.618;

        }

     

        .info-value {

            color: var(--glow);

            font-weight: 300;

        }

     

        /* Control Gestures */

        .gesture-indicator {

            position: fixed;

            bottom: 21px;

            right: 21px;

            font-size: 11px;

            color: rgba(255,255,255,0.3);

            text-align: right;

            line-height: 1.618;

        }

     

        /* Particle System */

        .particle {

            position: fixed;

            width: 2px;

            height: 2px;

            background: var(--glow);

            pointer-events: none;

            border-radius: 50%;

        }

     

        /* Start Screen */

        .start-screen {

            position: fixed;

            inset: 0;

            background: var(--bg);

            display: flex;

            align-items: center;

            justify-content: center;

            z-index: 1000;

            cursor: pointer;

        }

     

        .start-text {

            font-size: 144px;

            font-weight: 100;

            color: var(--glow);

            opacity: 0;

            animation: fadeIn 2s ease forwards;

            text-shadow: 0 0 50px var(--glow);

        }

     

        @keyframes fadeIn {

            to { opacity: 1; }

        }

     

        /* Atmospheric Layers */

        .atmosphere-layer {

            position: fixed;

            inset: 0;

            pointer-events: none;

            opacity: 0.03;

        }

     

        .atmosphere-1 {

            background: radial-gradient(circle at 61.8% 38.2%, var(--glow) 0%, transparent 50%);

            animation: drift1 34s ease-in-out infinite;

        }

     

        .atmosphere-2 {

            background: radial-gradient(circle at 38.2% 61.8%, rgba(138,0,255,1) 0%, transparent 50%);

            animation: drift2 55s ease-in-out infinite;

        }

     

        @keyframes drift1 {

            0%, 100% { transform: translate(0, 0) scale(1); }

            50% { transform: translate(-34px, 21px) scale(1.2); }

        }

     

        @keyframes drift2 {

            0%, 100% { transform: translate(0, 0) scale(1); }

            50% { transform: translate(21px, -34px) scale(0.8); }

        }

     

        /* Mobile Optimization */

        @media (max-width: 768px) {

            .start-text { font-size: 89px; }

            .waveform-scope { width: 233px; }

            .info-overlay { font-size: 11px; }

            .cursor, .cursor-trail { display: none; }

        }

        /* Mic Warning */

        .mic-warning {

            position: fixed;

            bottom: 50px;

            left: 50%;

            transform: translateX(-50%);

            font-size: 14px;

            color: red;

            background: rgba(0,0,0,0.7);

            padding: 10px 20px;

            border-radius: 5px;

            z-index: 1000;

        }

    </style>

</head>

<body>

    <!-- Cursor -->

    <div class="cursor" id="cursor"></div>

    <div class="cursor-trail" id="cursorTrail"></div>

 

    <!-- Start -->

    <div class="start-screen" id="startScreen">

        <div class="start-text">GUMP</div>

    </div>

 

    <!-- Atmosphere -->

    <div class="atmosphere-layer atmosphere-1"></div>

    <div class="atmosphere-layer atmosphere-2"></div>

 

    <!-- Main -->

    <div class="fibonacci-container" id="mainContainer" style="display: none;">

        <!-- Golden Rectangles -->

        <div class="golden-rect" style="width: 610px; height: 377px; top: 50%; left: 50%; transform: translate(-50%, -50%);"></div>

        <div class="golden-rect" style="width: 377px; height: 233px; top: 50%; left: 50%; transform: translate(-31%, -50%);"></div>

        <div class="golden-rect" style="width: 233px; height: 144px; top: 50%; left: 50%; transform: translate(-19%, -31%);"></div>

     

        <!-- Core Orb -->

        <div class="core-orb" id="coreOrb">

            <div class="orb-ring"></div>

            <div class="orb-inner"></div>

        </div>

     

        <!-- Sample Nodes -->

        <div id="sampleNodes"></div>

    </div>

 

    <!-- Visualizers -->

    <canvas class="spectrum-canvas" id="spectrumCanvas"></canvas>

    <canvas class="waveform-scope" id="waveformScope"></canvas>

 

    <!-- Info -->

    <div class="info-overlay" id="info">

        <div><span class="info-value" id="bpm">120</span> BPM</div>

        <div><span class="info-value" id="key">A</span> MINOR</div>

        <div>COMPLEXITY <span class="info-value" id="complexity">0</span>%</div>

        <div>SAMPLES <span class="info-value" id="samples">0</span></div>

    </div>

 

    <!-- Gestures -->

    <div class="gesture-indicator">

        CLICK: CAPTURE<br>

        MOVE: MODULATE<br>

        SPACE: CLEAR

    </div>

    <script>

        'use strict';

        class GUMPMeta {

            constructor() {

                this.ctx = null;

                this.isRunning = false;

             

                // Buses & Effects

                this.master = null;

                this.layers = {};

                this.effects = {};

             

                // Samples & Synthesis

                this.samples = new Map();

                this.nodes = [];

                this.currentNodeIndex = 0;

             

                // Musical State

                this.bpm = 120;

                this.key = 'A';

                this.scale = [0, 2, 3, 5, 7, 8, 10]; // Natural minor

                this.currentBar = 0;

                this.nextEventTime = 0;

                this.patternLength = 16;

             

                // AI State

                this.complexity = 0;

                this.energy = 0.5;

                this.mood = 'mellow';

                this.pattern = null;

             

                // Ambient Capture

                this.micStream = null;

                this.isListening = false;

                this.captureBuffer = [];

                this.hasMic = false;

             

                // UI

                this.ui = {};

                this.mouseX = 0;

                this.mouseY = 0;

             

                // Visualization

                this.analyser = null;

                this.scopeAnalyser = null;

             

                this.init();

            }

         

            init() {

                // Cache elements

                ['startScreen', 'mainContainer', 'coreOrb', 'sampleNodes',

                 'spectrumCanvas', 'waveformScope', 'cursor', 'cursorTrail',

                 'bpm', 'key', 'complexity', 'samples', 'info'].forEach(id => {

                    this.ui[id] = document.getElementById(id);

                });

             

                // Create sample nodes in Fibonacci positions

                this.createFibonacciNodes();

             

                // Events

                this.ui.startScreen.addEventListener('click', () => this.start());

                this.ui.coreOrb.addEventListener('click', () => this.captureNow());

                document.addEventListener('keydown', e => this.handleKey(e));

                document.addEventListener('mousemove', e => this.handleMouse(e));

                document.addEventListener('touchmove', e => this.handleTouch(e));

             

                // Setup visualizers

                this.setupVisualizers();

            }

         

            async start() {

                // Create audio context

                this.ctx = new (window.AudioContext || window.webkitAudioContext)({

                    latencyHint: 'playback',

                    sampleRate: 48000

                });

             

                await this.ctx.resume();

             

                // Initialize audio system

                await this.initAudio();

             

                // Setup microphone

                await this.setupMic();

             

                // Start engines

                this.startSequencer();

                this.startAmbientCapture();

             

                // UI transition

                this.ui.startScreen.style.display = 'none';

                this.ui.mainContainer.style.display = 'block';

             

                // Start visuals

                this.animate();

             

                // Immediate bass drone

                this.startDrone();

             

                // Start with high complexity for chaotic beginning

                this.complexity = 100;

                this.ui.complexity.textContent = Math.floor(this.complexity);

             

                this.isRunning = true;

             

                // Show mic warning if no access

                if (!this.hasMic) {

                    const warning = document.createElement('div');

                    warning.className = 'mic-warning';

                    warning.textContent = 'Microphone access denied or unavailable. Using generated samples instead. For real ambient sampling, serve this file over HTTP/HTTPS (not file://) and grant permission.';

                    document.body.appendChild(warning);

                }

            }

         

            async initAudio() {

                // Master chain

                this.master = this.ctx.createGain();

                this.master.gain.value = 0.9;

             

                // Analyzers

                this.analyser = this.ctx.createAnalyser();

                this.analyser.fftSize = 4096;

             

                this.scopeAnalyser = this.ctx.createAnalyser();

                this.scopeAnalyser.fftSize = 2048;

             

                // Layers

                const layerNames = ['kick', 'bass', 'snare', 'perc', 'hats', 'mid', 'high', 'air'];

                layerNames.forEach(name => {

                    const gain = this.ctx.createGain();

                    gain.gain.value = name === 'kick' ? 1.0 : name === 'bass' ? 0.9 : name === 'snare' ? 0.8 : 0.7;

                    this.layers[name] = gain;

                });

             

                // Create high-end effects chain

                await this.createEffects();

             

                // Routing

                Object.values(this.layers).forEach(layer => {

                    layer.connect(this.effects.eq.input);

                });

             

                this.effects.eq.connect(this.effects.multiband);

                this.effects.multiband.connect(this.effects.space.input);

                this.effects.space.connect(this.effects.comp);

                this.effects.comp.connect(this.effects.saturator);

                this.effects.saturator.connect(this.effects.limiter);

                this.effects.limiter.connect(this.master);

             

                this.master.connect(this.analyser);

                this.master.connect(this.scopeAnalyser);

                this.master.connect(this.ctx.destination);

            }

         

            async createEffects() {

                // Parametric EQ

                this.effects.eq = {

                    input: this.ctx.createGain(),

                    low: this.ctx.createBiquadFilter(),

                    lowMid: this.ctx.createBiquadFilter(),

                    highMid: this.ctx.createBiquadFilter(),

                    high: this.ctx.createBiquadFilter(),

                    output: this.ctx.createGain()

                };

             

                this.effects.eq.low.type = 'lowshelf';

                this.effects.eq.low.frequency.value = 100;

                this.effects.eq.low.gain.value = 3;

             

                this.effects.eq.lowMid.type = 'peaking';

                this.effects.eq.lowMid.frequency.value = 250;

                this.effects.eq.lowMid.Q.value = 0.5;

                this.effects.eq.lowMid.gain.value = -2;

             

                this.effects.eq.highMid.type = 'peaking';

                this.effects.eq.highMid.frequency.value = 3000;

                this.effects.eq.highMid.Q.value = 0.7;

                this.effects.eq.highMid.gain.value = 2;

             

                this.effects.eq.high.type = 'highshelf';

                this.effects.eq.high.frequency.value = 10000;

                this.effects.eq.high.gain.value = 4;

             

                this.effects.eq.input.connect(this.effects.eq.low);

                this.effects.eq.low.connect(this.effects.eq.lowMid);

                this.effects.eq.lowMid.connect(this.effects.eq.highMid);

                this.effects.eq.highMid.connect(this.effects.eq.high);

                this.effects.eq.high.connect(this.effects.eq.output);

             

                this.effects.eq.connect = (dest) => this.effects.eq.output.connect(dest);

             

                // Multiband Dynamics

                this.effects.multiband = this.ctx.createDynamicsCompressor();

                this.effects.multiband.threshold.value = -24;

                this.effects.multiband.knee.value = 12;

                this.effects.multiband.ratio.value = 3;

                this.effects.multiband.attack.value = 0.003;

                this.effects.multiband.release.value = 0.1;

             

                // Bus Compressor

                this.effects.comp = this.ctx.createDynamicsCompressor();

                this.effects.comp.threshold.value = -12;

                this.effects.comp.knee.value = 6;

                this.effects.comp.ratio.value = 4;

                this.effects.comp.attack.value = 0.01;

                this.effects.comp.release.value = 0.05;

             

                // Spatial Processor

                this.effects.space = await this.createSpace();

             

                // Tape Saturator

                this.effects.saturator = this.ctx.createWaveShaper();

                this.effects.saturator.curve = this.makeSaturationCurve(10);

                this.effects.saturator.oversample = '4x';

             

                // Brickwall Limiter

                this.effects.limiter = this.ctx.createDynamicsCompressor();

                this.effects.limiter.threshold.value = -0.5;

                this.effects.limiter.knee.value = 0;

                this.effects.limiter.ratio.value = 20;

                this.effects.limiter.attack.value = 0.001;

                this.effects.limiter.release.value = 0.01;

            }

         

            async createSpace() {

                const convolver = this.ctx.createConvolver();

             

                // Create dark hall reverb

                const length = this.ctx.sampleRate * 6;

                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);

             

                for (let ch = 0; ch < 2; ch++) {

                    const data = impulse.getChannelData(ch);

                 

                    for (let i = 0; i < length; i++) {

                        const decay = Math.pow(1 - i / length, 1.5);

                     

                        // Early reflections

                        if (i < this.ctx.sampleRate * 0.1) {

                            if (i % Math.floor(this.ctx.sampleRate * 0.013) === 0) {

                                data[i] = (Math.random() - 0.5) * 0.5 * decay;

                            }

                        }

                     

                        // Diffuse field

                        data[i] += (Math.random() - 0.5) * decay * 0.3;

                     

                        // Low-pass decay

                        if (i > 0) {

                            const cutoff = 0.99 - (i / length) * 0.7;

                            data[i] = data[i] * (1 - cutoff) + data[i-1] * cutoff;

                        }

                    }

                }

             

                convolver.buffer = impulse;

             

                // Wet/dry mix

                const input = this.ctx.createGain();

                const dry = this.ctx.createGain();

                const wet = this.ctx.createGain();

                const output = this.ctx.createGain();

             

                dry.gain.value = 0.7;

                wet.gain.value = 0.3;

             

                input.connect(dry);

                input.connect(convolver);

                convolver.connect(wet);

             

                const merger = this.ctx.createGain();

                dry.connect(merger);

                wet.connect(merger);

                merger.connect(output);

             

                return {

                    input,

                    connect: (dest) => output.connect(dest)

                };

            }

         

            async setupMic() {

                try {

                    const stream = await navigator.mediaDevices.getUserMedia({

                        audio: {

                            echoCancellation: false,

                            noiseSuppression: false,

                            autoGainControl: false

                        }

                    });

                 

                    this.micStream = this.ctx.createMediaStreamSource(stream);

                    const micGain = this.ctx.createGain();

                    micGain.gain.value = 1;

                 

                    const processor = this.ctx.createScriptProcessor(4096, 1, 1);

                    processor.onaudioprocess = (e) => {

                        if (this.isListening) {

                            const data = e.inputBuffer.getChannelData(0);

                            this.processAmbientAudio(data);

                        }

                    };

                 

                    const mute = this.ctx.createGain();

                    mute.gain.value = 0;

                 

                    this.micStream.connect(micGain);

                    micGain.connect(processor);

                    processor.connect(mute);

                    mute.connect(this.ctx.destination);

                 

                    this.hasMic = true;

                } catch (e) {

                    console.error('Mic access failed:', e);

                    this.hasMic = false;

                }

            }

         

            startDrone() {

                // Deep sub bass drone

                const osc = this.ctx.createOscillator();

                osc.type = 'sine';

                osc.frequency.value = 55; // A1

             

                const osc2 = this.ctx.createOscillator();

                osc2.type = 'sine';

                osc2.frequency.value = 55;

             

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(0, this.ctx.currentTime);

                gain.gain.linearRampToValueAtTime(0.15, this.ctx.currentTime + 2);

             

                osc.connect(gain);

                osc2.connect(gain);

                gain.connect(this.layers.bass);

             

                osc.start();

                osc2.start();

            }

         

            startSequencer() {

                const schedule = () => {

                    while (this.nextEventTime < this.ctx.currentTime + 0.1) {

                        const bar = Math.floor(this.currentBar / 16);

                        const step = this.currentBar % 16;

                     

                        // Generate pattern if needed

                        if (step === 0 && bar % 4 === 0) {

                            this.generatePattern();

                        }

                     

                        // Play pattern

                        if (this.pattern) {

                            this.playStep(step, this.nextEventTime);

                        }

                     

                        // Advance

                        this.nextEventTime += 60 / this.bpm / 4;

                        this.currentBar++;

                     

                        // Evolve complexity every bar

                        if (this.currentBar % 16 === 0) {

                            this.complexity = Math.max(0, this.complexity - 1);

                            this.ui.complexity.textContent = Math.floor(this.complexity);

                        }

                    }

                 

                    setTimeout(schedule, 25);

                };

             

                this.nextEventTime = this.ctx.currentTime;

                schedule();

            }

         

            generatePattern() {

                const moodPatterns = {

                    'chaotic': {

                        kick: [0, 5, 16, 21],

                        snare: [8, 15, 24, 31],

                        hats: [1, 3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23, 25, 27, 29, 31],

                        bass: [0, 4, 8, 12, 16, 20, 24, 28],

                        mid: [2, 6, 10, 14, 18, 22, 26, 30],

                        high: [1, 5, 9, 13, 17, 21, 25, 29]

                    },

                    'aggressive': {

                        kick: [0, 6, 16, 22],

                        snare: [8, 24],

                        hats: [0, 4, 8, 12, 16, 20, 24, 28],

                        bass: [0, 16],

                        mid: [8, 24],

                        high: [4, 12, 20, 28]

                    },

                    'rhythmic': {

                        kick: [0, 16],

                        snare: [8, 24],

                        hats: [2, 6, 10, 14, 18, 22, 26, 30],

                        bass: [0, 8, 16, 24],

                        mid: [4, 12, 20, 28],

                        high: [2, 10, 18, 26]

                    },

                    'mellow': {

                        kick: [0, 16],

                        snare: [8, 24],

                        hats: [4, 12, 20, 28],

                        bass: [0, 16],

                        mid: [8, 24],

                        high: [4, 20]

                    }

                };

               

                const basePattern = moodPatterns[this.mood];

               

                const pattern = {};

                Object.keys(basePattern).forEach(layer => {

                    pattern[layer] = new Array(this.patternLength).fill(false);

                    basePattern[layer].forEach(step => {

                        if (step < this.patternLength) {

                            pattern[layer][step % this.patternLength] = true;

                        }

                    });

                });

             

                // Add fractal complexity

                Object.keys(pattern).forEach(layer => {

                    for (let i = 0; i < this.patternLength; i++) {

                        const fractalValue = this.fractalNoise(i, layer.length);

                        const threshold = 0.7 - (this.complexity / 100 * 0.4);

                        if (fractalValue > threshold) {

                            pattern[layer][i] = true;

                        }

                    }

                });

             

                this.pattern = pattern;

            }

         

            fractalNoise(x, seed) {

                const scale1 = Math.sin(x * 0.1 + seed) * 0.5 + 0.5;

                const scale2 = Math.sin(x * 0.3 + seed * 2) * 0.3 + 0.5;

                const scale3 = Math.sin(x * 0.7 + seed * 3) * 0.2 + 0.5;

                return (scale1 + scale2 + scale3) / 3;

            }

         

            playStep(step, time) {

                // Visual pulse

                if (step % 4 === 0) {

                    setTimeout(() => {

                        this.ui.coreOrb.style.filter = 'brightness(1.5)';

                        setTimeout(() => {

                            this.ui.coreOrb.style.filter = 'brightness(1)';

                        }, 50);

                    }, (time - this.ctx.currentTime) * 1000);

                }

             

                // Play layers

                Object.keys(this.pattern).forEach(layer => {

                    if (this.pattern[layer][step]) {

                        this.triggerLayer(layer, time);

                    }

                });

             

                // Samples

                this.nodes.forEach((node, idx) => {

                    const sample = this.samples.get(idx);

                    if (sample && sample.pattern && sample.pattern[step]) {

                        this.playSample(idx, time);

                    }

                });

            }

         

            triggerLayer(layer, time) {

                const samples = this.samples.values();

                let sampleList = [];

                for (let sample of samples) {

                    if (sample.layer === layer) {

                        sampleList.push(sample);

                    }

                }

                if (sampleList.length === 0) return;

             

                const idx = Math.floor(Math.random() * sampleList.length);

                const sample = sampleList[idx];

                const source = this.ctx.createBufferSource();

                source.buffer = sample.buffer;

                source.playbackRate.value = sample.pitch || 1;

             

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(0.5, time);

                gain.gain.exponentialRampToValueAtTime(0.01, time + sample.buffer.duration);

             

                source.connect(gain);

                gain.connect(this.layers[layer]);

             

                source.start(time);

            }

         

            playKick(time) {

                const osc = this.ctx.createOscillator();

                osc.type = 'sine';

                osc.frequency.setValueAtTime(150, time);

                osc.frequency.exponentialRampToValueAtTime(30, time + 0.5);

             

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(1, time);

                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);

             

                const dist = this.ctx.createWaveShaper();

                dist.curve = this.makeSaturationCurve(20);

             

                osc.connect(gain);

                gain.connect(dist);

                dist.connect(this.layers.kick);

             

                osc.start(time);

                osc.stop(time + 0.5);

            }

         

            playSnare(time) {

                const buffer = this.ctx.createBuffer(1, 0.2 * this.ctx.sampleRate, this.ctx.sampleRate);

                const data = buffer.getChannelData(0);

             

                for (let i = 0; i < data.length; i++) {

                    data[i] = (Math.random() - 0.5) * Math.exp(-i / data.length * 8);

                }

             

                const source = this.ctx.createBufferSource();

                source.buffer = buffer;

             

                const filter = this.ctx.createBiquadFilter();

                filter.type = 'highpass';

                filter.frequency.value = 1000;

             

                const gain = this.ctx.createGain();

                gain.gain.value = 0.7;

             

                source.connect(filter);

                filter.connect(gain);

                gain.connect(this.layers.snare);

             

                source.start(time);

            }

         

            playHat(time) {

                const buffer = this.ctx.createBuffer(1, 0.05 * this.ctx.sampleRate, this.ctx.sampleRate);

                const data = buffer.getChannelData(0);

             

                for (let i = 0; i < data.length; i++) {

                    data[i] = (Math.random() - 0.5) * Math.exp(-i / data.length * 30);

                }

             

                const source = this.ctx.createBufferSource();

                source.buffer = buffer;

             

                const filter = this.ctx.createBiquadFilter();

                filter.type = 'highpass';

                filter.frequency.value = 8000;

             

                const gain = this.ctx.createGain();

                gain.gain.value = 0.3;

             

                source.connect(filter);

                filter.connect(gain);

                gain.connect(this.layers.hats);

             

                source.start(time);

            }

         

            playSample(idx, time) {

                const sample = this.samples.get(idx);

                if (!sample) return;

             

                const source = this.ctx.createBufferSource();

                source.buffer = sample.buffer;

                source.playbackRate.value = sample.pitch || 1;

             

                const gain = this.ctx.createGain();

                gain.gain.setValueAtTime(0, time);

                gain.gain.linearRampToValueAtTime(sample.gain || 0.5, time + 0.01);

                gain.gain.exponentialRampToValueAtTime(0.01, time + sample.buffer.duration);

             

                source.connect(gain);

                gain.connect(this.layers[sample.layer]);

             

                source.start(time);

                source.stop(time + sample.buffer.duration);

             

                // Visual feedback

                const node = this.nodes[idx];

                node.classList.add('playing');

                setTimeout(() => node.classList.remove('playing'), 100);

            }

         

            startAmbientCapture() {

                if (this.hasMic) {

                    this.isListening = true;

                    setInterval(() => {

                        if (this.captureBuffer.length > this.ctx.sampleRate * 0.5) {

                            this.processCapturedAudio();

                        }

                    }, 2000);

                } else {

                    setInterval(() => this.generateFakeSample(), 3000);

                }

            }

         

            processAmbientAudio(data) {

                // Simple energy detection

                let energy = 0;

                for (let i = 0; i < data.length; i++) {

                    energy += data[i] * data[i];

                }

                energy = Math.sqrt(energy / data.length);

             

                if (energy > 0.001) {

                    this.captureBuffer.push(...data);

                }

             

                // Limit buffer

                if (this.captureBuffer.length > this.ctx.sampleRate * 4) {

                    this.captureBuffer = this.captureBuffer.slice(-this.ctx.sampleRate * 4);

                }

            }

         

            processCapturedAudio() {

                if (this.captureBuffer.length < this.ctx.sampleRate * 0.1) {

                    return;

                }

             

                // Trim to last 1 second for shorter samples

                const trimLength = Math.min(this.captureBuffer.length, this.ctx.sampleRate * 1);

                const startIdx = this.captureBuffer.length - trimLength;

                const trimmedBuffer = this.captureBuffer.slice(startIdx);

             

                const buffer = this.ctx.createBuffer(1, trimmedBuffer.length, this.ctx.sampleRate);

                buffer.getChannelData(0).set(trimmedBuffer);

             

                this.createSampleFromBuffer(buffer);

             

                this.captureBuffer = [];

            }

         

            generateFakeSample() {

                const length = this.ctx.sampleRate * (0.2 + Math.random() * 0.5);

                const buffer = this.ctx.createBuffer(1, length, this.ctx.sampleRate);

                const data = buffer.getChannelData(0);

                const freq = 100 + Math.random() * 400;

                for (let i = 0; i < length; i++) {

                    data[i] = Math.sin(i / this.ctx.sampleRate * freq * 2 * Math.PI) * Math.exp(-i / length * 3);

                }

             

                this.createSampleFromBuffer(buffer);

            }

         

            createSampleFromBuffer(buffer) {

                const idx = this.currentNodeIndex % 16;

             

                const analysis = this.analyzeSample(buffer);

                const layer = this.categorizeSample(analysis);

                const pitch = analysis.pitch;

                let playbackRate = 1;

                if (pitch > 0) {

                    const target = this.quantizePitch(pitch);

                    playbackRate = target / pitch;

                }

             

                const pattern = new Array(16).fill(false);

                for (let i = 0; i < 16; i++) {

                    pattern[i] = Math.random() < (0.1 + this.complexity / 200);

                }

             

                this.samples.set(idx, {

                    buffer: buffer,

                    pitch: playbackRate,

                    gain: 0.5,

                    pattern: pattern,

                    layer: layer

                });

             

                this.nodes[idx].classList.add('loaded');

                this.nodes[idx].textContent = '●';

                this.ui.samples.textContent = this.samples.size;

             

                this.currentNodeIndex++;

            }

         

            analyzeSample(buffer) {

                const data = buffer.getChannelData(0);

                const len = data.length;

               

                // RMS Energy

                let rms = 0;

                for (let i = 0; i < len; i++) {

                    rms += data[i] * data[i];

                }

                rms = Math.sqrt(rms / len);

               

                // Zero crossing rate

                let zeroCrossings = 0;

                for (let i = 1; i < len; i++) {

                    if ((data[i] >= 0) !== (data[i-1] >= 0)) {

                        zeroCrossings++;

                    }

                }

                const zcr = zeroCrossings / buffer.duration;

               

                // Pitch detection

                let pitch = 0;

                if (len > 1024) {

                    const maxDelay = Math.min(len >> 1, 2000);

                    const minDelay = 40;

                    let maxCorrelation = 0;

                    let bestDelay = -1;

                   

                    for (let delay = minDelay; delay < maxDelay; delay++) {

                        let correlation = 0;

                        for (let i = 0; i < len - delay; i++) {

                            correlation += data[i] * data[i + delay];

                        }

                        if (correlation > maxCorrelation) {

                            maxCorrelation = correlation;

                            bestDelay = delay;

                        }

                    }

                   

                    if (maxCorrelation > rms * rms * len * 0.3 && bestDelay > 0) {

                        pitch = this.ctx.sampleRate / bestDelay;

                    }

                }

               

                return {

                    rms,

                    zcr,

                    pitch,

                    duration: buffer.duration

                };

            }

         

            categorizeSample(analysis) {

                const { rms, zcr, pitch, duration } = analysis;

               

                if (rms > 0.1 && zcr < 3000 && duration < 0.8) return 'kick';

                if (rms > 0.03 && rms <= 0.1 && zcr > 1500 && zcr < 6000 && duration < 1) return 'snare';

                if (zcr > 6000 && duration < 0.2) return 'hats';

                if (pitch && pitch < 150 && duration > 0.3) return 'bass';

                if (pitch && pitch >= 150 && pitch < 1000) return 'mid';

                return 'high';

            }

         

            quantizePitch(frequency) {

                const scales = {

                    'chaotic': [0, 1, 3, 6, 8, 10],

                    'aggressive': [0, 2, 3, 5, 7, 8, 10],

                    'rhythmic': [0, 2, 4, 7, 9],

                    'mellow': [0, 3, 5, 7, 10]

                };

               

                const scale = scales[this.mood] || scales['mellow'];

                const rootFreq = 55; // A1

               

                const semitones = 12 * Math.log2(frequency / rootFreq);

                const octave = Math.floor(semitones / 12);

                const note = semitones % 12;

               

                let closest = scale[0];

                let minDistance = Math.abs(note - closest);

               

                for (const scaleNote of scale) {

                    const distance = Math.abs(note - scaleNote);

                    if (distance < minDistance) {

                        minDistance = distance;

                        closest = scaleNote;

                    }

                }

               

                return rootFreq * Math.pow(2, (octave * 12 + closest) / 12);

            }

         

            captureNow() {

                if (this.captureBuffer.length > 0) {

                    this.processCapturedAudio();

                }

            }

         

            createFibonacciNodes() {

                const positions = [];

                const phi = 1.618033988749895;

             

                // Generate Fibonacci spiral positions

                for (let i = 0; i < 16; i++) {

                    const angle = i * 137.5 * Math.PI / 180; // Golden angle

                    const radius = 50 + i * 15;

                 

                    const x = 50 + radius * Math.cos(angle) * 0.3;

                    const y = 50 + radius * Math.sin(angle) * 0.3;

                 

                    positions.push({ x, y });

                }

             

                // Create nodes

                positions.forEach((pos, idx) => {

                    const node = document.createElement('div');

                    node.className = 'sample-node';

                    node.style.left = pos.x + '%';

                    node.style.top = pos.y + '%';

                    node.style.transform = 'translate(-50%, -50%)';

                 

                    node.addEventListener('click', () => {

                        if (this.samples.has(idx)) {

                            this.playSample(idx);

                        }

                    });

                 

                    this.ui.sampleNodes.appendChild(node);

                    this.nodes.push(node);

                });

            }

         

            setupVisualizers() {

                // Spectrum

                const spectrum = this.ui.spectrumCanvas;

                spectrum.width = window.innerWidth;

                spectrum.height = window.innerHeight;

             

                // Waveform

                const scope = this.ui.waveformScope;

                scope.width = 377;

                scope.height = 89;

            }

         

            handleKey(e) {

                if (e.key === ' ') {

                    e.preventDefault();

                    this.clearAll();

                }

            }

         

            handleMouse(e) {

                this.mouseX = e.clientX;

                this.mouseY = e.clientY;

             

                // Update cursor

                this.ui.cursor.style.left = e.clientX + 'px';

                this.ui.cursor.style.top = e.clientY + 'px';

             

                this.ui.cursorTrail.style.left = e.clientX + 'px';

                this.ui.cursorTrail.style.top = e.clientY + 'px';

             

                // Modulate based on position

                if (this.isRunning) {

                    const x = e.clientX / window.innerWidth;

                    const y = e.clientY / window.innerHeight;

                 

                    // Modulate filter

                    this.effects.eq.highMid.frequency.value = 1000 + x * 4000;

                    this.effects.eq.highMid.gain.value = -5 + y * 10;

                 

                    // Modulate energy

                    this.energy = Math.sqrt(x * x + y * y) / Math.sqrt(2);

                    this.updateMood();

                }

            }

         

            updateMood() {

                if (this.energy > 0.8) {

                    this.mood = 'chaotic';

                } else if (this.energy > 0.6) {

                    this.mood = 'aggressive';

                } else if (this.energy > 0.4) {

                    this.mood = 'rhythmic';

                } else {

                    this.mood = 'mellow';

                }

            }

         

            handleTouch(e) {

                if (e.touches[0]) {

                    this.handleMouse(e.touches[0]);

                }

            }

         

            clearAll() {

                this.samples.clear();

                this.nodes.forEach(node => {

                    node.classList.remove('loaded');

                    node.textContent = '';

                });

                this.ui.samples.textContent = '0';

                this.complexity = 100; // Reset to chaotic

                this.ui.complexity.textContent = '100';

             

                // Create particles for effect

                for (let i = 0; i < 50; i++) {

                    this.createParticle();

                }

            }

         

            createParticle() {

                const particle = document.createElement('div');

                particle.className = 'particle';

                particle.style.left = '50%';

                particle.style.top = '50%';

                document.body.appendChild(particle);

             

                const angle = Math.random() * Math.PI * 2;

                const velocity = 100 + Math.random() * 200;

                const lifetime = 1000 + Math.random() * 1000;

             

                let x = 0, y = 0;

                const start = Date.now();

             

                const update = () => {

                    const elapsed = Date.now() - start;

                    const progress = elapsed / lifetime;

                 

                    if (progress >= 1) {

                        particle.remove();

                        return;

                    }

                 

                    x += Math.cos(angle) * velocity * 0.016;

                    y += Math.sin(angle) * velocity * 0.016;

                 

                    particle.style.transform = `translate(${x}px, ${y}px)`;

                    particle.style.opacity = 1 - progress;

                 

                    requestAnimationFrame(update);

                };

             

                update();

            }

         

            animate() {

                requestAnimationFrame(() => this.animate());

             

                // Spectrum visualization

                if (this.analyser) {

                    const canvas = this.ui.spectrumCanvas;

                    const ctx = canvas.getContext('2d');

                    const data = new Uint8Array(this.analyser.frequencyBinCount);

                    this.analyser.getByteFrequencyData(data);

                 

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';

                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                 

                    const barWidth = canvas.width / data.length * 3;

                 

                    for (let i = 0; i < data.length; i++) {

                        const height = (data[i] / 255) * canvas.height;

                        const x = i * barWidth;

                     

                        const gradient = ctx.createLinearGradient(0, canvas.height - height, 0, canvas.height);

                        gradient.addColorStop(0, `rgba(255, 0, 255, ${data[i] / 255})`);

                        gradient.addColorStop(1, 'rgba(138, 0, 255, 0.1)');

                     

                        ctx.fillStyle = gradient;

                        ctx.fillRect(x, canvas.height - height, barWidth - 1, height);

                    }

                }

             

                // Waveform scope

                if (this.scopeAnalyser) {

                    const scope = this.ui.waveformScope;

                    const ctx = scope.getContext('2d');

                    const data = new Uint8Array(this.scopeAnalyser.fftSize);

                    this.scopeAnalyser.getByteTimeDomainData(data);

                 

                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)';

                    ctx.fillRect(0, 0, scope.width, scope.height);

                 

                    ctx.beginPath();

                    ctx.strokeStyle = '#ff00ff';

                    ctx.lineWidth = 1;

                 

                    const sliceWidth = scope.width / data.length;

                    let x = 0;

                 

                    for (let i = 0; i < data.length; i++) {

                        const v = data[i] / 128;

                        const y = v * scope.height / 2;

                     

                        if (i === 0) {

                            ctx.moveTo(x, y);

                        } else {

                            ctx.lineTo(x, y);

                        }

                     

                        x += sliceWidth;

                    }

                 

                    ctx.stroke();

                }

            }

         

            makeSaturationCurve(amount) {

                const samples = 44100;

                const curve = new Float32Array(samples);

             

                for (let i = 0; i < samples; i++) {

                    const x = (i * 2 / samples) - 1;

                    curve[i] = Math.tanh(x * amount) / Math.tanh(amount);

                }

             

                return curve;

            }

        }

     

        // Start

        window.addEventListener('DOMContentLoaded', () => {

            window.gump = new GUMPMeta();

        });

    </script>

</body>

</html>
