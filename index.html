<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP ∴ Grand Unified Music Project ∴ Music 2.0</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000; color: #fff; overflow: hidden; height: 100vh;
            display: flex; flex-direction: column; align-items: center; justify-content: space-between;
            font-family: 'Courier New', monospace; touch-action: none; cursor: none;
        }
        #void-touch {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            font-size: 2em; text-align: center; opacity: 0.8; z-index: 1;
            transition: opacity 1s;
        }
        #void-touch.awake { opacity: 0; }
        #ui {
            width: 100%; padding: 20px; text-align: center; opacity: 0;
            transition: opacity 2s;
        }
        #ui.awake { opacity: 1; }
        .metric { font-size: 1.2em; margin: 5px 0; }
        .stage { font-size: 1.5em; color: #ff6b6b; }
        .resonance { color: #4ecdc4; font-weight: bold; }
        #orb {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 16px; height: 16px; border-radius: 50%;
            background: radial-gradient(circle, #fff 0%, #ccc 50%, transparent 80%);
            box-shadow: 0 0 30px rgba(255,255,255,0.5); pointer-events: none; z-index: 10;
            transition: all 0.5s ease;
        }
        #orb.void-pulse {
            animation: voidPulse 1s ease-out infinite alternate;
            background: radial-gradient(circle, #ff6b6b 0%, #ff4757 50%, transparent 80%);
            box-shadow: 0 0 50px rgba(255,107,107,0.8);
        }
        @keyframes voidPulse {
            0% { transform: translate(-50%, -50%) scale(1); }
            100% { transform: translate(-50%, -50%) scale(6); }
        }
        #orb.res-locked { background: radial-gradient(circle, #4ecdc4 0%, #45b7d1 50%); }
    </style>
</head>
<body>
    <div id="void-touch">
        TOUCH<br>
        THE<br>
        VOID
    </div>
    <div id="orb"></div>
    <div id="ui">
        <div class="metric">GUMP ∴ AWAITING RESONANCE</div>
        <div class="metric">BPM — <span id="bpm">75</span> ∴ KEY <span id="key">C</span></div>
        <div class="stage">STAGE <span id="stage">0</span> /7 ∴ VOICES <span id="voices">0</span></div>
        <div class="metric">ENERGY <span id="energy">0</span></div>
        <div class="metric">ENTROPY <span id="entropy">0</span></div>
        <div class="metric">GESTURE <span id="gesture">—</span></div>
        <div class="metric resonance" id="resonance">RESONANCE</div>
    </div>
    <script>
        'use strict';

        // Fibonacci/Golden Ratio Constants
        const PHI = (1 + Math.sqrt(5)) / 2; // ~1.618
        const FIB_STAGES = [0, 1, 1, 2, 3, 5, 8, 13]; // Stages map to Fib voices/unlocks

        // Resonance Engine - Real-time env sampling + motion weaving
        class ResonanceEngine {
            constructor(ctx, onUpdate) {
                this.ctx = ctx;
                this.onUpdate = onUpdate;
                this.stage = 0;
                this.voices = 0;
                this.bpm = 75;
                this.key = 'C';
                this.energy = 0;
                this.entropy = 0;
                this.gesture = 0;
                this.resLocked = false;
                this.analyser = ctx.createAnalyser(); this.analyser.fftSize = 2048;
                this.data = new Uint8Array(this.analyser.frequencyBinCount);
                this.source = null; this.gain = ctx.createGain(); this.gain.gain.value = 0;
                this.filter = ctx.createBiquadFilter(); this.filter.type = 'lowpass'; this.filter.frequency.value = 1000;
                this.envBuffer = []; this.motionIntensity = 0;
                this.uiElements = {
                    bpm: document.getElementById('bpm'), key: document.getElementById('key'),
                    stage: document.getElementById('stage'), voices: document.getElementById('voices'),
                    energy: document.getElementById('energy'), entropy: document.getElementById('entropy'),
                    gesture: document.getElementById('gesture'), resonance: document.getElementById('resonance')
                };
                this.orb = document.getElementById('orb');
                this.seq = new Sequencer(ctx, this);
            }

            async init() {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false } });
                this.source = this.ctx.createMediaStreamSource(stream);
                this.source.connect(this.analyser); this.analyser.connect(this.gain); this.gain.connect(this.filter); this.filter.connect(this.ctx.destination);
                this.motion = new MotionWeaver((intensity, rotation) => {
                    this.motionIntensity = intensity; this.updateGesture(rotation);
                    this.evolveStage();
                });
                this.motion.init();
                this.loop();
            }

            loop() {
                this.analyser.getByteFrequencyData(this.data);
                let sum = 0; for (let i = 0; i < this.data.length; i++) sum += this.data[i];
                this.energy = sum / (this.data.length * 255); // 0-1 normalized

                // Entropy: spectral flux (change detection)
                const flux = Math.abs(this.energy - (this.lastEnergy || 0));
                this.entropy = Math.min(flux * 10, 1); this.lastEnergy = this.energy;

                // Thread env into buffer for sampling
                if (this.energy > 0.05) {
                    this.envBuffer.push(this.energy * Math.sin(Date.now() / 1000)); // Simple weave
                    if (this.envBuffer.length > 1024) this.envBuffer.shift();
                    this.gain.gain.value = this.energy * 0.4 * (this.stage / 7);
                    this.filter.frequency.value = 500 + (this.energy * 5000 * PHI);
                } else {
                    this.gain.gain.value *= 0.98;
                }

                this.onUpdate(this);
                requestAnimationFrame(() => this.loop());
            }

            updateGesture(rotation) {
                this.gesture = Math.abs(rotation) / 180; // 0-1
                this.orb.style.transform = `translate(-50%, -50%) rotate(${rotation * 360}deg)`;
            }

            evolveStage() {
                const totalDrive = this.energy + this.entropy + this.motionIntensity + this.gesture;
                const targetStage = Math.min(Math.floor(totalDrive * 7), 6);
                if (targetStage > this.stage) {
                    this.stage = targetStage;
                    this.voices = FIB_STAGES[this.stage + 1];
                    this.bpm = 75 + (this.stage * 15 * PHI); // Golden escalation
                    this.key = ['C', 'G', 'D', 'A', 'E', 'B', 'F#'][this.stage % 7];
                    if (this.stage === 6) this.resLocked = true;
                    this.orb.classList.add('void-pulse');
                    setTimeout(() => this.orb.classList.remove('void-pulse'), 1000);
                }
            }

            updateUI() {
                Object.entries(this.uiElements).forEach(([k, el]) => {
                    if (k === 'resonance') el.textContent = this.resLocked ? '∴ FIBONACCI RESONANCE LOCKED ∴' : 'RESONANCE';
                    else el.textContent = this[k];
                });
                this.orb.classList.toggle('res-locked', this.resLocked);
            }
        }

        // Motion Weaver - Gyro/accel to gesture/entropy
        class MotionWeaver {
            constructor(onWeave) { this.onWeave = onWeave; this.intensity = 0; this.rotation = 0; }
            init() {
                if (DeviceMotionEvent && typeof DeviceMotionEvent.requestPermission === 'function') {
                    DeviceMotionEvent.requestPermission().then(permission => permission === 'granted' && this.startMotion());
                } else this.startMotion();
                window.addEventListener('deviceorientation', e => {
                    this.rotation = (e.gamma || 0) / 2; this.onWeave(this.intensity, this.rotation);
                });
            }
            startMotion() {
                window.addEventListener('devicemotion', e => {
                    const accel = e.accelerationIncludingGravity;
                    this.intensity = Math.sqrt((accel.x**2 + accel.y**2 + accel.z**2) || 0) / 9.8;
                    this.onWeave(this.intensity, this.rotation);
                });
            }
        }

        // Adaptive Sequencer - Stage-driven beats with env chops
        class Sequencer {
            constructor(ctx, res) {
                this.ctx = ctx; this.res = res; this.step = 0; this.lastTime = 0;
                this.interval = 60 / this.res.bpm / 4; // 16th notes
                this.drumGen = new DrumGen(ctx, this.res);
                this.tick();
            }
            tick() {
                const now = this.ctx.currentTime;
                this.interval = 60 / this.res.bpm / 4;
                if (now >= this.lastTime + this.interval) {
                    this.lastTime = now; this.step = (this.step + 1) % 16;
                    const voicesActive = Math.min(this.res.voices, 4);
                    if (this.step % 4 === 0 && voicesActive > 0) this.drumGen.play('kick', this.res.energy);
                    if (this.step % 8 === 4 && voicesActive > 1) this.drumGen.play('snare', this.res.entropy);
                    if ((this.step % 2 === 1) && voicesActive > 2) this.drumGen.play('hat', this.res.gesture, 1 + this.res.motionIntensity);
                    if (this.res.stage > 3 && this.step % 16 === 0) this.drumGen.play('bass', 0.7, PHI);
                    // Weave env chops
                    if (this.res.envBuffer.length > 0 && Math.random() < this.res.entropy) {
                        this.drumGen.weaveEnv(this.res.envBuffer.slice(-256));
                    }
                }
                requestAnimationFrame(() => this.tick());
            }
        }

        // Drum/Env Generator - Lo-fi with golden tuning
        class DrumGen {
            constructor(ctx, res) {
                this.ctx = ctx; this.res = res; this.buffers = {};
                this.generateBuffers();
            }
            generateBuffers() {
                const sr = this.ctx.sampleRate;
                // Kick (phi-modulated decay)
                const kick = this.ctx.createBuffer(1, sr * 0.3, sr);
                const kd = kick.getChannelData(0);
                for (let i = 0; i < kd.length; i++) {
                    const t = i / sr; kd[i] = Math.sin(2 * Math.PI * 50 * t) * Math.exp(-PHI * t * 10) * 0.8;
                }
                this.buffers.kick = kick;
                // Similar for snare, hat, bass...
                const snare = this.ctx.createBuffer(1, sr * 0.15, sr);
                const sd = snare.getChannelData(0);
                for (let i = 0; i < sd.length; i++) {
                    const t = i / sr; const noise = Math.random() * 2 - 1;
                    sd[i] = (Math.sin(2 * Math.PI * 200 * t) * 0.3 + noise * 0.7) * Math.exp(-20 * t);
                }
                this.buffers.snare = snare;
                const hat = this.ctx.createBuffer(1, sr * 0.05, sr);
                const hd = hat.getChannelData(0);
                for (let i = 0; i < hd.length; i++) {
                    const t = i / sr; hd[i] = (Math.random() * 2 - 1) * Math.exp(-50 * t) * 0.5;
                }
                this.buffers.hat = hat;
                const bass = this.ctx.createBuffer(1, sr * 1, sr);
                const bd = bass.getChannelData(0);
                for (let i = 0; i < bd.length; i++) {
                    const t = i / sr; bd[i] = Math.sin(2 * Math.PI * 40 * t) * (t < 0.05 ? 1 : Math.exp(-PHI * t));
                }
                this.buffers.bass = bass;
            }
            play(type, vel, rate = 1) {
                const src = this.ctx.createBufferSource();
                src.buffer = this.buffers[type]; src.playbackRate.value = rate * PHI ** (this.res.stage / 7 - 0.5);
                const gain = this.ctx.createGain(); gain.gain.value = vel;
                src.connect(gain); gain.connect(this.ctx.destination);
                src.start(); 
                src.onended = () => src.disconnect(); gain.disconnect();
            }
            weaveEnv(bufferSlice) {
                if (bufferSlice.length < 100) return;
                const buf = this.ctx.createBuffer(1, bufferSlice.length, this.ctx.sampleRate);
                buf.getChannelData(0).set(bufferSlice.map(v => v * 0.3));
                const src = this.ctx.createBufferSource(); src.buffer = buf; src.playbackRate.value = this.res.bpm / 60 * PHI;
                const gain = this.ctx.createGain(); gain.gain.value = this.res.energy * 0.5;
                src.connect(gain); gain.connect(this.ctx.destination); src.start();
            }
        }

        // Void Touch Init
        class VoidTouch {
            constructor() {
                this.touchDiv = document.getElementById('void-touch');
                this.ui = document.getElementById('ui');
                this.orb = document.getElementById('orb');
                this.initCtx();
            }
            async initCtx() {
                if (!this.ctx) {
                    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
                    await this.ctx.resume();
                    this.resEngine = new ResonanceEngine(this.ctx, (state) => {
                        state.updateUI();
                        if (state.stage > 0) {
                            this.touchDiv.classList.add('awake');
                            this.ui.classList.add('awake');
                            this.orb.classList.add('void-pulse');
                        }
                    });
                    await this.resEngine.init();
                }
            }
        }

        // Bootstrap
        const voidTouch = new VoidTouch();
        document.addEventListener('touchstart', () => voidTouch.initCtx(), { passive: true });
        document.addEventListener('click', () => voidTouch.initCtx());
    </script>
</body>
</html>
