<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Dubstep Motion Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 2s ease;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
      border: 2px solid rgba(255,255,255,0.3);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: bold;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      animation: pulse 6s ease-in-out infinite;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.6);
      background: radial-gradient(circle, rgba(255,255,255,0.2) 0%, transparent 70%);
      transform: scale(1.05);
    }
    
    @keyframes pulse {
      0%, 100% { transform: scale(1); box-shadow: 0 0 30px rgba(255,255,255,0.2); }
      50% { transform: scale(1.08); box-shadow: 0 0 60px rgba(255,255,255,0.4); }
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 2s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.3) 50%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 40px rgba(255,255,255,0.5);
      backdrop-filter: blur(5px);
    }
    
    .orb.pulse {
      animation: beat 0.15s ease-out;
    }
    
    @keyframes beat {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.2); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .orb.buildup {
      background: radial-gradient(circle, #ff00ff 0%, rgba(255,0,255,0.4) 50%, transparent 80%);
      box-shadow: 0 0 60px rgba(255,0,255,0.7);
    }
    
    .orb.drop {
      background: radial-gradient(circle, #00ff00 0%, rgba(0,255,0,0.4) 50%, transparent 80%);
      box-shadow: 0 0 80px rgba(0,255,0,0.7);
      animation: wobble 0.2s ease-in-out infinite;
    }
    
    .orb.chaos {
      background: radial-gradient(circle, #ff0000 0%, #ff00ff 40%, #00ff00 70%, transparent 90%);
      box-shadow: 0 0 120px rgba(255,0,0,0.8);
      animation: chaosWobble 0.1s ease-in-out infinite;
    }
    
    .orb.breakdown {
      background: radial-gradient(circle, #ffff00 0%, #ff8800 25%, #ff0000 50%, #8800ff 75%, transparent 95%);
      box-shadow: 0 0 200px rgba(255,255,0,1);
      filter: drop-shadow(0 0 80px rgba(255,0,255,0.8));
      animation: breakdown 0.05s ease-in-out infinite;
    }
    
    .orb.chill {
      background: radial-gradient(circle, #4488ff 0%, rgba(68,136,255,0.3) 40%, transparent 80%);
      box-shadow: 0 0 40px rgba(68,136,255,0.4);
      animation: chill 3s ease-in-out infinite;
    }
    
    @keyframes wobble {
      0%, 100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
      25% { transform: translate(-50%, -50%) scale(1.2) rotate(5deg); }
      75% { transform: translate(-50%, -50%) scale(0.8) rotate(-5deg); }
    }
    
    @keyframes chaosWobble {
      0% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
      25% { transform: translate(-50%, -50%) scale(1.4) rotate(10deg); }
      50% { transform: translate(-50%, -50%) scale(0.6) rotate(-10deg); }
      75% { transform: translate(-50%, -50%) scale(1.2) rotate(15deg); }
      100% { transform: translate(-50%, -50%) scale(1) rotate(0deg); }
    }
    
    @keyframes breakdown {
      0% { transform: translate(-50%, -50%) scale(1) skew(0deg); }
      20% { transform: translate(-50%, -50%) scale(1.5) skew(5deg); }
      40% { transform: translate(-50%, -50%) scale(0.5) skew(-5deg); }
      60% { transform: translate(-50%, -50%) scale(1.3) skew(8deg); }
      80% { transform: translate(-50%, -50%) scale(0.7) skew(-8deg); }
      100% { transform: translate(-50%, -50%) scale(1) skew(0deg); }
    }
    
    @keyframes chill {
      0%, 100% { 
        transform: translate(-50%, -50%) scale(1); 
        opacity: 0.7; 
      }
      50% { 
        transform: translate(-50%, -50%) scale(1.1); 
        opacity: 1; 
      }
    }
    
    .ui-corner {
      position: fixed;
      font-size: 11px;
      color: rgba(255,255,255,0.8);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.3);
      padding: 10px;
      border-radius: 5px;
      backdrop-filter: blur(10px);
    }
    
    .ui-corner.top-left {
      top: 20px;
      left: 20px;
    }
    
    .ui-corner.bottom-left {
      bottom: 20px;
      left: 20px;
    }
    
    .ui-corner.top-right {
      top: 20px;
      right: 20px;
    }
    
    .stage-name {
      font-size: 14px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 8px;
      font-weight: bold;
    }
    
    .metric {
      margin: 3px 0;
      font-size: 10px;
    }
    
    .bar {
      width: 80px;
      height: 3px;
      background: rgba(255,255,255,0.2);
      margin: 3px 0;
      border-radius: 2px;
      overflow: hidden;
    }
    
    .bar-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff00ff, #00ff00);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 2px;
    }
    
    .hidden { display: none !important; }
    
    .particles {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 3px;
      height: 3px;
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      animation: float 12s linear infinite;
    }
    
    @keyframes float {
      0% { 
        transform: translateY(100vh) scale(0) rotate(0deg); 
        opacity: 0; 
      }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-20vh) scale(1.5) rotate(360deg); 
        opacity: 0; 
      }
    }
    
    .instruction {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 2s ease;
      margin-top: 80px;
      font-weight: bold;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 30%, rgba(0,0,0,0.6) 100%);
      opacity: 0;
      transition: opacity 3s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .theme-text {
      position: fixed;
      bottom: 30px;
      right: 30px;
      font-size: 12px;
      color: rgba(255,255,255,0.6);
      text-transform: uppercase;
      letter-spacing: 3px;
      opacity: 0;
      transition: opacity 2s ease;
      font-weight: bold;
    }
    
    .theme-text.visible { opacity: 1; }

    .spectrum-viz {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 100px;
      pointer-events: none;
      z-index: 3;
    }
    
    .spectrum-bar {
      position: absolute;
      bottom: 0;
      width: 8px;
      background: linear-gradient(0deg, rgba(255,0,255,0.8), rgba(0,255,0,0.8));
      border-radius: 4px 4px 0 0;
      transition: height 0.1s ease;
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.3);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.05s ease-out;
    }

    .drop-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,255,0,0.4);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .drop-flash.active {
      opacity: 1;
      transition: opacity 0.1s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
LET'S GO
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO BUILD THE DROP</div>
    
    <div class="ui-corner top-left">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">MODE: <span id="technique">WAITING</span></div>
    </div>
    
    <div class="ui-corner bottom-left">
      <div class="metric">MOTION INTENSITY</div>
      <div class="bar">
        <div class="bar-fill" id="motionBar"></div>
      </div>
      <div class="metric">WOBBLE TENSION</div>
      <div class="bar">
        <div class="bar-fill" id="wobbleBar"></div>
      </div>
    </div>
    
    <div class="ui-corner top-right">
      <div class="metric">BPM: <span id="bpmDisplay">140</span></div>
      <div class="metric">KEY: <span id="keyDisplay">E MIN</span></div>
      <div class="metric">VOICES: <span id="voiceCount">0</span></div>
    </div>
    
    <div class="spectrum-viz" id="spectrumViz"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="theme-text" id="themeText"></div>
  <div class="impact-flash" id="impactFlash"></div>
  <div class="drop-flash" id="dropFlash"></div>

  <script>
    class DubstepEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        // Dubstep Musical Structure - Enhanced for 2025 production
        this.bpm = 140; // Standard dubstep BPM
        this.step = 0;
        this.phrase = 'A';
        this.phraseCount = 0;
        this.sectionLength = 32;
        this.dropCountdown = 0;
        this.isDropping = false;
        this.buildupIntensity = 0;
        this.halfTimeMode = false; // New: 6/8 half-time mode
        this.halfTimeStep = 0;
        
        // Enhanced Motion & Position with ethereal detection
        this.motion = 0;
        this.intensity = 0;
        this.direction = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.motionPattern = 'chill';
        this.lastMotionTime = Date.now();
        
        // Enhanced Gesture Recognition with ethereal modes
        this.gestureRecognition = {
          shake: 0,
          drop: 0,
          wobble: 0,
          breakdown: 0,
          buildup: 0,
          halftime: 0,
          ethereal: 0, // New: smooth, flowing movements
          digital: 0,  // New: precise, angular movements
          hybrid: 0    // New: mix of organic and digital
        };
        
        // Enhanced Evolution System
        this.stage = 'SILENCE';
        this.evolutionProgress = 0;
        this.totalMotion = 0;
        this.firstMovement = false;
        this.currentTechnique = 'waiting';
        
        // Enhanced Dubstep Themes - 2025 styles with ethereal computer vibes
        this.currentTheme = 'silence';
        this.themes = {
          silence: { mood: 'waiting', colors: ['#1a1a1a', '#2a2a2a'], text: 'Digital Void' },
          buildup: { mood: 'tension', colors: ['#ff00ff', '#aa00aa'], text: 'Data Ascending' },
          drop: { mood: 'explosive', colors: ['#00ff00', '#008800'], text: 'NEURAL OVERLOAD!' },
          halftime: { mood: 'nasty', colors: ['#ff4400', '#990000'], text: 'SYSTEM BREAKDOWN' },
          breakdown: { mood: 'chaotic', colors: ['#ff0000', '#ffff00'], text: 'Code Fragmentation' },
          wobble: { mood: 'groovy', colors: ['#0088ff', '#ff8800'], text: 'Digital Consciousness' },
          chill: { mood: 'relaxed', colors: ['#4488ff', '#88ccff'], text: 'Floating Data' },
          ethereal: { mood: 'dreamy', colors: ['#bb88ff', '#66ccff'], text: 'Cybernetic Dreams' },
          hybrid: { mood: 'fusion', colors: ['#ff88bb', '#88ffbb'], text: 'Human-Machine Interface' }
        };
        
        // Professional Dubstep Presets - 2025 production with ethereal elements
        this.dubstepStyles = [
          {
            name: 'Ethereal Deep Step',
            key: 'E',
            mode: 'minor',
            bpmBase: 140,
            wobbleFreq: 1.5,
            dropStyle: 'ethereal',
            bassline: [0, 7, 3, 10],
            leadPattern: [0, 12, 7, 15],
            subFreq: 55,
            layering: 'ambient',
            digitalElements: true,
            etherealIntensity: 0.8
          },
          {
            name: 'Cyber Riddim',
            key: 'F',
            mode: 'minor',
            bpmBase: 145,
            wobbleFreq: 8,
            dropStyle: 'cyber',
            bassline: [0, 5, 8, 3],
            leadPattern: [12, 19, 15, 22],
            subFreq: 44,
            layering: 'digital',
            digitalElements: true,
            etherealIntensity: 0.6
          },
          {
            name: 'Ambient Future Bass',
            key: 'G',
            mode: 'major',
            bpmBase: 135,
            wobbleFreq: 0.5,
            dropStyle: 'ambient',
            bassline: [0, 4, 7, 11],
            leadPattern: [12, 16, 19, 23],
            subFreq: 49,
            layering: 'lush',
            digitalElements: true,
            etherealIntensity: 1.0
          },
          {
            name: 'Neural Trap Step',
            key: 'D',
            mode: 'minor',
            bpmBase: 150,
            wobbleFreq: 12,
            dropStyle: 'neural',
            bassline: [0, 8, 3, 11],
            leadPattern: [0, 15, 7, 22],
            subFreq: 37,
            layering: 'complex',
            digitalElements: true,
            etherealIntensity: 0.7
          }
        ];
        this.currentStyleIndex = 0;
        
        // AUDIO SYSTEM
        this.masterGain = null;
        this.limiter = null;
        this.layerGains = {};
        this.layerFilters = {};
        this.compressor = null;
        this.distortion = null;
        
        // Professional dubstep-specific audio elements with ethereal additions
        this.wobbleLFO = null;
        this.wobbleGain = null;
        this.wobbleIntensity = 0;
        this.bassFilter = null;
        this.leadFilter = null;
        this.noiseGate = null;
        this.subBassOsc = null; // Dedicated sub oscillator
        this.midBassFilter = null;
        this.fmModulator = null; // FM synthesis for growls
        this.sidechainCompressor = null;
        this.multiband = null; // Multiband compression
        this.stereoImager = null;
        
        // Ethereal computer elements
        this.etherealLFO = null; // Slow modulation for dreamy effects
        this.digitalFilter = null; // Precise digital filtering
        this.ambientReverb = null; // Spacious reverb for ethereal feel
        this.chorusEffect = null; // Chorus for width and shimmer
        this.etherealIntensity = 0;
        this.digitalMode = false;
        
        // Professional bass layering system with ethereal layer
        this.bassLayers = {
          sub: { freq: 55, gain: 0.9, phase: 0 },
          midBass: { freq: 110, gain: 0.7, phase: 0 },
          growl: { freq: 220, gain: 0.6, phase: 0 },
          highs: { freq: 440, gain: 0.4, phase: 0 },
          ethereal: { freq: 880, gain: 0.3, phase: 0 } // New ethereal layer
        };
        
        // Voice Pool for professional dubstep + ethereal elements
        this.voicePool = {
          kick: { max: 2, active: [] },
          snare: { max: 2, active: [] },
          hihat: { max: 6, active: [] },
          subbass: { max: 4, active: [] },
          wobble: { max: 8, active: [] },
          midbass: { max: 6, active: [] },
          growl: { max: 8, active: [] },
          lead: { max: 12, active: [] },
          pad: { max: 10, active: [] }, // Increased for ethereal pads
          noise: { max: 6, active: [] },
          riser: { max: 2, active: [] },
          impact: { max: 3, active: [] },
          vocal: { max: 2, active: [] },
          fx: { max: 10, active: [] },
          halftime: { max: 4, active: [] },
          ethereal: { max: 8, active: [] }, // New ethereal voice pool
          digital: { max: 6, active: [] },  // New digital elements
          ambient: { max: 12, active: [] }, // New ambient textures
          shimmer: { max: 8, active: [] }   // New shimmer effects
        };
        
        // Enhanced dubstep layers with ethereal elements
        this.layers = {
          kick: false,
          snare: false,
          hihat: false,
          subbass: false,
          wobble: false,
          midbass: false,
          growl: false,
          lead: false,
          pad: false,
          noise: false,
          riser: false,
          impact: false,
          vocal: false,
          fx: false,
          halftime: false,
          ethereal: false, // Dreamy, floating elements
          digital: false,  // Precise, computer-like sounds
          ambient: false,  // Spacious atmospheric textures
          shimmer: false   // High-frequency sparkle and movement
        };
        
        // Musical Elements
        this.key = 'E';
        this.keyOffsets = {'C':0, 'D':2, 'E':4, 'F':5, 'G':7, 'A':9, 'B':11};
        this.mode = 'minor';
        this.scales = {
          minor: [0, 2, 3, 5, 7, 8, 10],
          major: [0, 2, 4, 5, 7, 9, 11],
          pentatonic: [0, 2, 4, 7, 9]
        };
        this.scale = this.scales[this.mode];
        this.bassline = [0, 7, 3, 10];
        this.leadPattern = [0, 12, 7, 15];
        this.currentBassIndex = 0;
        this.currentLeadIndex = 0;
        
        this.elements = {};
        this.spectrumBars = [];
        
        this.init();
      }

      init() {
        console.log('🎛️ Initializing engine components...');
        
        // Check if all elements exist before proceeding
        const requiredElements = ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'technique', 'motionBar', 'wobbleBar', 'bpmDisplay',
         'keyDisplay', 'voiceCount', 'cinematicOverlay', 'themeText', 'spectrumViz', 
         'impactFlash', 'dropFlash'];
        
        let allElementsFound = true;
        requiredElements.forEach(id => {
          const element = document.getElementById(id);
          if (!element) {
            console.error(`❌ Required element not found: ${id}`);
            allElementsFound = false;
          } else {
            this.elements[id] = element;
          }
        });
        
        if (!allElementsFound) {
          console.error('❌ Missing required DOM elements, cannot initialize');
          return;
        }
        
        console.log('✅ All DOM elements found');
        
        // Set up event listeners
        this.elements.startBtn.onclick = () => {
          console.log('🎵 Start button clicked');
          this.start();
        };
        
        this.setupMotionDetection();
        this.setupSpectrumVisualizer();
        this.setupInteractionListeners();
        
        console.log('✅ Engine initialization complete');
      }

      setupSpectrumVisualizer() {
        console.log('🎵 Setting up spectrum visualizer...');
        
        if (!this.elements.spectrumViz) {
          console.error('❌ Spectrum visualizer container not found');
          return;
        }
        
        // Clear any existing bars
        this.elements.spectrumViz.innerHTML = '';
        this.spectrumBars = [];
        
        for (let i = 0; i < 64; i++) {
          const bar = document.createElement('div');
          bar.className = 'spectrum-bar';
          bar.style.left = `${i * 1.5625}%`;
          bar.style.height = '0px';
          this.elements.spectrumViz.appendChild(bar);
          this.spectrumBars.push(bar);
        }
        
        console.log('✅ Spectrum visualizer ready');
      }

      setupInteractionListeners() {
        let touchSequence = [];
        
        window.addEventListener('touchstart', (e) => {
          if (!this.active) return;
          this.triggerManualDrop();
        });

        window.addEventListener('click', (e) => {
          if (!this.active) return;
          this.triggerManualDrop();
        });

        // Space bar for manual drops
        window.addEventListener('keydown', (e) => {
          if (!this.active) return;
          if (e.code === 'Space') {
            e.preventDefault();
            this.triggerManualDrop();
          }
        });
      }

      triggerManualDrop() {
        if (!this.isDropping) {
          console.log('🎵 MANUAL DROP TRIGGERED!');
          this.forceDrop();
          this.flashDrop();
        }
      }

      forceDrop() {
        this.isDropping = true;
        this.dropCountdown = 0;
        this.buildupIntensity = 1;
        this.stage = 'DROP';
        if (this.elements.orb) {
          this.elements.orb.className = 'orb drop';
        }
        this.currentTheme = 'drop';
        this.layers.wobble = true;
        this.layers.subbass = true;
        this.layers.kick = true;
        this.layers.impact = true;
        
        // Auto-exit drop after 8 beats
        setTimeout(() => {
          if (this.isDropping) {
            this.isDropping = false;
            this.stage = 'WOBBLE';
            if (this.elements.orb) {
              this.elements.orb.className = 'orb wobble';
            }
            this.currentTheme = 'wobble';
          }
        }, (60 / this.bpm) * 8 * 1000);
      }

      flashDrop() {
        if (this.elements.dropFlash) {
          this.elements.dropFlash.classList.add('active');
          setTimeout(() => this.elements.dropFlash.classList.remove('active'), 100);
        }
      }

      flashImpact() {
        if (this.elements.impactFlash) {
          this.elements.impactFlash.classList.add('active');
          setTimeout(() => this.elements.impactFlash.classList.remove('active'), 50);
        }
      }

      async start() {
        try {
          console.log('🚀 Starting Ethereal Dubstep Engine...');
          
          // Request permissions first if needed
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            try {
              const permission = await DeviceMotionEvent.requestPermission();
              if (permission !== 'granted') {
                console.log('Motion permission denied, using mouse/auto fallback');
              }
            } catch (e) {
              console.log('Permission request failed, continuing with fallback');
            }
          }

          // Enhanced audio context creation with error handling
          const AudioContext = window.AudioContext || window.webkitAudioContext;
          if (!AudioContext) {
            throw new Error('Web Audio API not supported in this browser');
          }

          this.ctx = new AudioContext();
          
          // Handle audio context state properly
          if (this.ctx.state === 'suspended') {
            await this.ctx.resume();
          }
          
          console.log('🔊 Audio context created and ready');
          
          this.setupAudioChain();
          console.log('🎛️ Professional audio chain initialized');

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.textContent = 'MOVE OR CLICK TO CREATE MUSIC';
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 4000);
          }, 1000);

          this.active = true;
          this.setDubstepStyle(0);
          this.startSequencer();
          this.animate();
          
          console.log('✨ Ethereal Dubstep Engine started successfully!');
          
        } catch (e) {
          console.error('❌ Failed to start engine:', e);
          alert('Failed to initialize audio engine. Please try refreshing the page. Error: ' + e.message);
        }
      }

      setDubstepStyle(index) {
        const style = this.dubstepStyles[index];
        this.key = style.key;
        this.mode = style.mode;
        this.scale = this.scales[this.mode];
        this.bpm = style.bpmBase;
        this.bassline = style.bassline;
        this.leadPattern = style.leadPattern;
        this.currentStyleIndex = index;

        console.log(`Switched to: ${style.name}`);
        
        this.elements.themeText.textContent = style.name;
        this.elements.themeText.classList.add('visible');
        setTimeout(() => this.elements.themeText.classList.remove('visible'), 3000);
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 256; // Higher resolution for better bass monitoring
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        // Professional limiter with lookahead
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -1; // Hard limiting
        this.limiter.knee.value = 0;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.0001;
        this.limiter.release.value = 0.01;
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.8; // Higher headroom
        
        // Multiband compression for professional sound
        this.multiband = this.ctx.createDynamicsCompressor();
        this.multiband.threshold.value = -18;
        this.multiband.knee.value = 8;
        this.multiband.ratio.value = 6;
        this.multiband.attack.value = 0.002;
        this.multiband.release.value = 0.15;
        
        // Enhanced low-end processing
        this.lowBoost = this.ctx.createBiquadFilter();
        this.lowBoost.type = 'lowshelf';
        this.lowBoost.frequency.value = 80;
        this.lowBoost.gain.value = 8; // More aggressive low boost
        this.lowBoost.Q.value = 0.7;
        
        // Professional saturation
        this.saturator = this.ctx.createWaveShaper();
        this.saturator.curve = this.makeAdvancedDistortionCurve(4);
        this.saturator.oversample = '4x';
        
        // Stereo imaging for width
        this.stereoImager = this.ctx.createStereoPanner();
        
        // Enhanced wobble LFO with multiple shapes
        this.wobbleLFO = this.ctx.createOscillator();
        this.wobbleLFO.type = 'sawtooth'; // More aggressive than sine
        this.wobbleLFO.frequency.value = 2;
        this.wobbleGain = this.ctx.createGain();
        this.wobbleGain.gain.value = 0;
        this.wobbleLFO.connect(this.wobbleGain);
        this.wobbleLFO.start();
        
        // FM modulator for growls and screeches
        this.fmModulator = this.ctx.createOscillator();
        this.fmModulator.type = 'sawtooth';
        this.fmModulator.frequency.value = 120;
        this.fmModulator.start();
        
        // Sidechain compressor for kick-bass separation
        this.sidechainCompressor = this.ctx.createDynamicsCompressor();
        this.sidechainCompressor.threshold.value = -30;
        this.sidechainCompressor.knee.value = 2;
        this.sidechainCompressor.ratio.value = 12;
        this.sidechainCompressor.attack.value = 0.001;
        this.sidechainCompressor.release.value = 0.1;
        
        // Professional layer setup with enhanced names
        const layerNames = ['kick', 'snare', 'hihat', 'subbass', 'wobble', 'midbass', 
                           'growl', 'lead', 'pad', 'noise', 'riser', 'impact', 
                           'vocal', 'fx', 'halftime'];
        const layerLevels = [1.2, 0.9, 0.25, 1.0, 0.7, 0.8, 
                            0.6, 0.4, 0.3, 0.35, 0.5, 1.0, 
                            0.3, 0.4, 0.8]; // Professional mix levels
        
        layerNames.forEach((name, i) => {
          this.layerGains[name] = this.ctx.createGain();
          this.layerGains[name].gain.value = layerLevels[i];
          
          this.layerFilters[name] = this.ctx.createBiquadFilter();
          this.layerFilters[name].type = name === 'subbass' ? 'lowpass' : 
                                        name === 'hihat' ? 'highpass' : 'allpass';
          this.layerFilters[name].frequency.value = name === 'subbass' ? 100 : 
                                                   name === 'hihat' ? 8000 : 20000;
          this.layerFilters[name].Q.value = name === 'subbass' ? 0.7 : 1;

          this.layerGains[name].connect(this.layerFilters[name]);
          this.layerFilters[name].connect(this.multiband);
        });
        
        // Special filters for professional bass design
        this.bassFilter = this.ctx.createBiquadFilter();
        this.bassFilter.type = 'lowpass';
        this.bassFilter.frequency.value = 150;
        this.bassFilter.Q.value = 20; // Very resonant for wobble
        
        this.midBassFilter = this.ctx.createBiquadFilter();
        this.midBassFilter.type = 'bandpass';
        this.midBassFilter.frequency.value = 300;
        this.midBassFilter.Q.value = 8;
        
        this.leadFilter = this.ctx.createBiquadFilter();
        this.leadFilter.type = 'bandpass';
        this.leadFilter.frequency.value = 1000;
        this.leadFilter.Q.value = 12;
        
        // Enhanced wobble and FM modulation with ethereal elements
        this.wobbleGain.connect(this.bassFilter.frequency);
        this.wobbleGain.connect(this.midBassFilter.frequency);
        this.fmModulator.connect(this.bassFilter.detune);
        
        // Ethereal LFO for dreamy modulation
        this.etherealLFO = this.ctx.createOscillator();
        this.etherealLFO.type = 'sine';
        this.etherealLFO.frequency.value = 0.1; // Very slow for ethereal drift
        this.etherealLFO.start();
        
        // Digital filter for precise computer-like effects
        this.digitalFilter = this.ctx.createBiquadFilter();
        this.digitalFilter.type = 'notch';
        this.digitalFilter.frequency.value = 2000;
        this.digitalFilter.Q.value = 30; // Very precise
        
        // Ambient reverb for spacious ethereal feel
        this.ambientReverb = this.ctx.createConvolver();
        this.ambientReverb.buffer = this.createEtherealReverbBuffer(12); // Long, dreamy reverb
        
        // Chorus effect for ethereal shimmer
        this.chorusEffect = this.ctx.createDelay(0.02);
        this.chorusEffect.delayTime.value = 0.01;
        const chorusLFO = this.ctx.createOscillator();
        const chorusGain = this.ctx.createGain();
        chorusLFO.type = 'sine';
        chorusLFO.frequency.value = 0.5;
        chorusGain.gain.value = 0.005;
        chorusLFO.connect(chorusGain);
        chorusGain.connect(this.chorusEffect.delayTime);
        chorusLFO.start();
        
        // Professional audio chain with parallel ethereal processing
        this.multiband.connect(this.lowBoost);
        this.lowBoost.connect(this.saturator);
        this.saturator.connect(this.sidechainCompressor);
        this.sidechainCompressor.connect(this.stereoImager);
        
        // Parallel ethereal path
        this.sidechainCompressor.connect(this.ambientReverb);
        this.sidechainCompressor.connect(this.chorusEffect);
        
        // Mix back together
        this.stereoImager.connect(this.limiter);
        this.ambientReverb.connect(this.limiter);
        this.chorusEffect.connect(this.limiter);
        
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      createEtherealReverbBuffer(time) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * time, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            const decay = Math.pow(1 - i / data.length, 0.5); // Slower decay for ethereal feel
            const shimmer = Math.sin(i * 0.001) * 0.3; // Add shimmer
            data[i] = (Math.random() * 2 - 1) * decay * 0.2 + shimmer * decay;
          }
        }
        return buffer;
      }

      makeAdvancedDistortionCurve(amount) {
        const k = amount;
        const n = 44100;
        const curve = new Float32Array(n);
        for (let i = 0; i < n; i++) {
          const x = (i * 2) / n - 1;
          // More sophisticated distortion algorithm
          curve[i] = Math.sign(x) * (1 - Math.exp(-Math.abs(x * k))) / (1 - Math.exp(-k));
        }
        return curve;
      }

      setupMotionDetection() {
        // Initialize motion tracking
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.isMotionSupported = false;
        this.mouseActive = false;
        this.lastMouseTime = Date.now();

        // Device motion with better error handling
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          try {
            const acc = e.accelerationIncludingGravity;
            if (!acc || acc.x === null || acc.x === undefined) return;

            this.isMotionSupported = true;
            this.mouseActive = false; // Prioritize device motion over mouse
            
            const dx = Math.abs((acc.x || 0) - this.lastAccel.x);
            const dy = Math.abs((acc.y || 0) - this.lastAccel.y);
            const dz = Math.abs((acc.z || 0) - this.lastAccel.z);
            
            const newMotion = Math.sqrt(dx * dx + dy * dy + dz * dz) * 0.5;
            this.updateMotion(newMotion);
            
            this.velocity.x += (acc.x || 0) * 0.01;
            this.velocity.y += (acc.y || 0) * 0.01;
            this.updatePosition();
            
            this.direction = Math.atan2(this.velocity.y, this.velocity.x) * (180 / Math.PI);
            
            // Detect drops and shakes with lower thresholds
            if (newMotion > 3) {
              this.gestureRecognition.drop += 0.3;
              if (this.gestureRecognition.drop > 0.8 && !this.isDropping) {
                this.triggerDropSequence();
              }
            }
            
            if (newMotion > 2) {
              this.gestureRecognition.shake += 0.2;
              if (this.gestureRecognition.shake > 1.5) {
                this.triggerBreakdown();
              }
            }
            
            this.lastAccel = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
          } catch (error) {
            console.warn('Device motion error:', error);
          }
        });

        // Enhanced mouse/desktop fallback
        let lastMouse = { x: 50, y: 50, time: Date.now() };
        
        window.addEventListener('mousemove', e => {
          if (!this.active || this.isMotionSupported) return;
          
          this.mouseActive = true;
          this.lastMouseTime = Date.now();
          const now = Date.now();
          const dt = Math.max(16, now - lastMouse.time); // Minimum 16ms for 60fps
          
          const newX = (e.clientX / window.innerWidth) * 100;
          const newY = (e.clientY / window.innerHeight) * 100;
          
          const velocityX = (newX - lastMouse.x) / dt * 50;
          const velocityY = (newY - lastMouse.y) / dt * 50;
          
          const mouseMotion = Math.sqrt(velocityX * velocityX + velocityY * velocityY);
          this.updateMotion(mouseMotion);
          
          this.pos.x = newX;
          this.pos.y = newY;
          this.direction = Math.atan2(velocityY, velocityX) * (180 / Math.PI);
          
          lastMouse = { x: newX, y: newY, time: now };
        });

        // Automatic motion simulation with improved timing
        setTimeout(() => {
          if (!this.mouseActive && !this.isMotionSupported && this.active) {
            console.log('Starting automatic motion simulation...');
            this.startAutoMotion();
          }
        }, 3000);
      }

      startAutoMotion() {
        let time = 0;
        const simulate = () => {
          if (!this.active || this.isMotionSupported || this.mouseActive) return;
          
          // Check if user has moved mouse recently
          if (Date.now() - this.lastMouseTime < 5000) {
            setTimeout(simulate, 100);
            return;
          }
          
          time += 0.02;
          const autoMotion = Math.sin(time) * 2 + Math.cos(time * 1.5) * 1.5 + 2;
          this.updateMotion(autoMotion);
          
          // Simulate position changes
          this.pos.x = 50 + Math.sin(time * 0.7) * 20;
          this.pos.y = 50 + Math.cos(time * 0.5) * 15;
          
          setTimeout(simulate, 50); // Use setTimeout instead of requestAnimationFrame for better control
        };
        simulate();
      }

      updateMotion(newMotion) {
        // Ensure motion is a valid number with bounds checking
        if (isNaN(newMotion) || newMotion < 0) newMotion = 0;
        if (newMotion > 20) newMotion = 20; // Cap extreme values
        
        this.motion = this.motion * 0.85 + newMotion * 0.15;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 50) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        if (this.motion > 0.3) {
          this.lastMotionTime = Date.now();
        }
        
        // First movement trigger with safety check
        if (!this.firstMovement && this.motion > 0.8) {
          this.firstMovement = true;
          this.evolveToBuildup();
        }
        
        // Calculate intensity and patterns with safety checks
        const avgMotion = this.motionHistory.length > 0 ? 
          this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length : 0;
        
        this.intensity = this.motionHistory.length > 5 ? 
          this.motionHistory.slice(-5).reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / 5 : 0;
        
        // Enhanced motion pattern detection with ethereal modes
        const variance = this.intensity;
        if (variance > 3.5 && avgMotion > 3.5) {
          this.motionPattern = 'breakdown';
        } else if (variance > 2.5 && avgMotion > 2) {
          this.motionPattern = 'halftime';
          this.gestureRecognition.halftime += 0.4;
        } else if (variance > 1.5 && avgMotion > 1.5) {
          this.motionPattern = 'wobble';
        } else if (avgMotion > 1.2 && variance < 1.5) {
          this.motionPattern = 'buildup';
        } else if (avgMotion < 0.8) {
          this.motionPattern = 'chill';
        } else if (avgMotion > 0.5 && variance < 0.8) {
          // New: Smooth, flowing movements trigger ethereal mode
          this.motionPattern = 'ethereal';
          this.gestureRecognition.ethereal += 0.3;
        } else if (this.isAngularMotion()) {
          // New: Sharp, precise movements trigger digital mode
          this.motionPattern = 'digital';
          this.gestureRecognition.digital += 0.3;
        } else {
          this.motionPattern = 'normal';
        }
        
        this.updateDubstepElements(avgMotion, variance);
        this.updateEvolution();
        
        // Update technique display
        this.currentTechnique = this.motionPattern;
        
        // Enhanced gesture recognition decay with bounds checking
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.05);
        });
        
        // Trigger modes with safety checks
        if (this.gestureRecognition.ethereal > 0.8 && !this.etherealMode) {
          this.triggerEtherealMode();
        }
        if (this.gestureRecognition.digital > 0.8 && !this.digitalMode) {
          this.triggerDigitalMode();
        }
        if (this.gestureRecognition.halftime > 1 && !this.halfTimeMode) {
          this.triggerHalfTimeMode();
        }
      }

      isAngularMotion() {
        // Detect sharp, angular movements (rapid direction changes)
        if (this.motionHistory.length < 10) return false;
        
        const recent = this.motionHistory.slice(-10);
        let directionChanges = 0;
        let lastDirection = 0;
        
        for (let i = 1; i < recent.length; i++) {
          const direction = recent[i] > recent[i-1] ? 1 : -1;
          if (direction !== lastDirection) directionChanges++;
          lastDirection = direction;
        }
        
        return directionChanges > 6; // Many quick direction changes = angular/digital
      }

      triggerEtherealMode() {
        console.log('✨ ETHEREAL MODE: Digital Dreams Activated');
        this.etherealMode = true;
        this.etherealIntensity = 1;
        this.stage = 'ETHEREAL';
        this.elements.orb.className = 'orb transcendent';
        this.currentTheme = 'ethereal';
        this.gestureRecognition.ethereal = 0;
        
        // Activate ethereal layers
        this.layers.ethereal = true;
        this.layers.ambient = true;
        this.layers.shimmer = true;
        this.layers.pad = true;
        
        // Softer bass for ethereal feel
        this.layerGains.subbass.gain.value *= 0.7;
        this.layerGains.growl.gain.value *= 0.3;
        
        console.log('🌌 Floating in digital space...');
        
        // Exit ethereal after 24 beats
        setTimeout(() => {
          if (this.etherealMode) {
            this.exitEtherealMode();
          }
        }, (60 / this.bpm) * 24 * 1000);
      }

      triggerDigitalMode() {
        console.log('💻 DIGITAL MODE: Computer Consciousness Activated');
        this.digitalMode = true;
        this.stage = 'DIGITAL';
        this.elements.orb.className = 'orb breakdown';
        this.currentTheme = 'hybrid';
        this.gestureRecognition.digital = 0;
        
        // Activate digital layers
        this.layers.digital = true;
        this.layers.fx = true;
        
        // More precise, digital-sounding effects
        this.digitalFilter.frequency.value = 1000 + Math.random() * 2000;
        
        console.log('🔲 Processing digital algorithms...');
        
        // Exit digital after 16 beats
        setTimeout(() => {
          if (this.digitalMode) {
            this.exitDigitalMode();
          }
        }, (60 / this.bpm) * 16 * 1000);
      }

      exitEtherealMode() {
        console.log('✨ EXITING ETHEREAL MODE');
        this.etherealMode = false;
        this.etherealIntensity = 0;
        this.stage = 'WOBBLE';
        this.elements.orb.className = 'orb wobble';
        this.currentTheme = 'wobble';
        
        // Restore bass levels
        this.layerGains.subbass.gain.value /= 0.7;
        this.layerGains.growl.gain.value /= 0.3;
      }

      exitDigitalMode() {
        console.log('💻 EXITING DIGITAL MODE');
        this.digitalMode = false;
        this.stage = 'WOBBLE';
        this.elements.orb.className = 'orb wobble';
        this.currentTheme = 'wobble';
      }

      triggerHalfTimeMode() {
        console.log('🔥 6/8 HALF-TIME MODE ACTIVATED!');
        this.halfTimeMode = true;
        this.halfTimeStep = 0;
        this.stage = 'HALFTIME';
        this.elements.orb.className = 'orb chaos';
        this.currentTheme = 'halftime';
        this.gestureRecognition.halftime = 0;
        
        // Modify BPM for half-time feel
        this.bpm = this.bpm * 0.75; // Slower tempo for nastier feel
        
        // Activate nasty layers
        this.layers.halftime = true;
        this.layers.growl = true;
        this.layers.subbass = true;
        this.layers.midbass = true;
        this.layers.fx = true;
        this.layers.impact = true;
        
        // Enhanced wobble for half-time
        this.wobbleIntensity = 1;
        this.wobbleLFO.frequency.value = 0.5; // Much slower wobble
        
        this.flashDrop();
        
        // Exit half-time after 32 beats (longer for full effect)
        setTimeout(() => {
          if (this.halfTimeMode) {
            this.exitHalfTimeMode();
          }
        }, (60 / this.bpm) * 32 * 1000);
      }

      exitHalfTimeMode() {
        console.log('🎵 EXITING HALF-TIME MODE');
        this.halfTimeMode = false;
        this.stage = 'WOBBLE';
        this.elements.orb.className = 'orb drop';
        this.currentTheme = 'drop';
        
        // Restore normal BPM
        this.bpm = this.bpm / 0.75;
        this.wobbleLFO.frequency.value = 2;
      }
        
        this.motion = this.motion * 0.85 + newMotion * 0.15;
        this.motionHistory.push(this.motion);
        if (this.motionHistory.length > 50) this.motionHistory.shift();
        
        this.totalMotion += this.motion;
        
        if (this.motion > 0.3) {
          this.lastMotionTime = Date.now();
        }
        
        // First movement trigger
        if (!this.firstMovement && this.motion > 0.8) {
          this.firstMovement = true;
          this.evolveToBuildup();
        }
        
        // Calculate intensity and patterns
        const avgMotion = this.motionHistory.length > 0 ? 
          this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length : 0;
        
        this.intensity = this.motionHistory.length > 5 ? 
          this.motionHistory.slice(-5).reduce((sum, m) => sum + Math.abs(m - avgMotion), 0) / 5 : 0;
        
        // Simpler motion pattern detection
        const variance = this.intensity;
        if (variance > 2.5 && avgMotion > 2.5) {
          this.motionPattern = 'breakdown';
        } else if (variance > 1.5 && avgMotion > 1.5) {
          this.motionPattern = 'wobble';
        } else if (avgMotion > 1.2 && variance < 1.5) {
          this.motionPattern = 'buildup';
        } else if (avgMotion < 0.8) {
          this.motionPattern = 'chill';
        } else {
          this.motionPattern = 'normal';
        }
        
        this.updateDubstepElements(avgMotion, variance);
        this.updateEvolution();
        
        // Update technique display
        this.currentTechnique = this.motionPattern;
        
        // Decay gesture recognition more aggressively
        Object.keys(this.gestureRecognition).forEach(key => {
          this.gestureRecognition[key] = Math.max(0, this.gestureRecognition[key] - 0.05);
        });
      }

      updateDubstepElements(avgMotion, variance) {
        // Update wobble intensity based on motion
        this.wobbleIntensity = Math.min(avgMotion / 4, 1);
        this.wobbleGain.gain.value = this.wobbleIntensity * 2000;
        
        const style = this.dubstepStyles[this.currentStyleIndex];
        this.wobbleLFO.frequency.value = style.wobbleFreq + (variance * 2);
        
        // Update buildup intensity
        if (this.motionPattern === 'buildup') {
          this.buildupIntensity = Math.min(this.buildupIntensity + 0.02, 1);
        } else {
          this.buildupIntensity = Math.max(this.buildupIntensity - 0.01, 0);
        }
        
        // Trigger drops based on buildup
        if (this.buildupIntensity > 0.8 && !this.isDropping) {
          this.dropCountdown++;
          if (this.dropCountdown > 30) { // ~2 seconds at 140 BPM
            this.triggerDropSequence();
          }
        }
      }

      triggerDropSequence() {
        console.log('🔥 DROP SEQUENCE TRIGGERED!');
        this.isDropping = true;
        this.dropCountdown = 0;
        this.buildupIntensity = 1;
        this.stage = 'DROP';
        this.elements.orb.className = 'orb drop';
        this.currentTheme = 'drop';
        this.gestureRecognition.drop = 0;
        
        // Activate drop layers
        this.layers.wobble = true;
        this.layers.bass = true;
        this.layers.kick = true;
        this.layers.impact = true;
        this.layers.fx = true;
        
        this.flashDrop();
        
        // End drop after 16 beats
        setTimeout(() => {
          if (this.isDropping) {
            this.isDropping = false;
            this.stage = 'WOBBLE';
            this.elements.orb.className = 'orb wobble';
            this.currentTheme = 'wobble';
          }
        }, (60 / this.bpm) * 16 * 1000);
      }

      triggerBreakdown() {
        console.log('💥 BREAKDOWN MODE!');
        this.gestureRecognition.shake = 0;
        this.stage = 'BREAKDOWN';
        this.elements.orb.className = 'orb chaos';
        this.currentTheme = 'breakdown';
        this.layers.fx = true;
        this.layers.noise = true;
        this.flashImpact();
        
        // Switch to more aggressive style
        this.setDubstepStyle((this.currentStyleIndex + 1) % this.dubstepStyles.length);
      }

      updatePosition() {
        this.pos.x += this.velocity.x;
        this.pos.y += this.velocity.y;
        
        if (this.pos.x < 5 || this.pos.x > 95) this.velocity.x *= -0.7;
        if (this.pos.y < 5 || this.pos.y > 95) this.velocity.y *= -0.7;
        
        this.pos.x = Math.max(5, Math.min(95, this.pos.x));
        this.pos.y = Math.max(5, Math.min(95, this.pos.y));
        
        this.velocity.x *= 0.9;
        this.velocity.y *= 0.9;
      }

      updateEvolution() {
        const avgMotion = this.motionHistory.reduce((a, b) => a + b, 0) / this.motionHistory.length;
        
        // Enhanced layer activation with ethereal elements
        this.layers.kick = this.stage !== 'SILENCE' && (this.step % 4 === 0 || this.isDropping || this.halfTimeMode);
        this.layers.snare = this.stage !== 'SILENCE' && avgMotion > 1;
        this.layers.hihat = this.stage !== 'SILENCE';
        
        // Professional bass layering system with ethereal adjustments
        this.layers.subbass = this.stage !== 'SILENCE' && avgMotion > 0.5;
        this.layers.wobble = this.isDropping || this.wobbleIntensity > 0.3 || this.halfTimeMode;
        this.layers.midbass = this.buildupIntensity > 0.4 || this.isDropping || this.halfTimeMode;
        this.layers.growl = this.motionPattern === 'breakdown' || this.halfTimeMode;
        
        this.layers.lead = this.buildupIntensity > 0.5 || this.isDropping;
        this.layers.pad = this.motionPattern === 'chill' || this.buildupIntensity > 0.3 || this.etherealMode;
        this.layers.noise = this.motionPattern === 'breakdown' || this.intensity > 3;
        this.layers.riser = this.buildupIntensity > 0.6;
        this.layers.impact = this.isDropping || this.gestureRecognition.drop > 0.5 || this.halfTimeMode;
        this.layers.vocal = this.stage === 'BREAKDOWN' || Math.random() < 0.01;
        this.layers.fx = this.isDropping || this.motionPattern === 'breakdown' || this.halfTimeMode || this.digitalMode;
        this.layers.halftime = this.halfTimeMode;
        
        // New ethereal layers
        this.layers.ethereal = this.etherealMode || this.motionPattern === 'ethereal' || avgMotion < 1.5;
        this.layers.digital = this.digitalMode || this.motionPattern === 'digital';
        this.layers.ambient = this.etherealMode || this.motionPattern === 'chill' || avgMotion < 1;
        this.layers.shimmer = this.etherealMode || this.buildupIntensity > 0.7 || Math.random() < 0.03;.stage !== 'SILENCE' && avgMotion > 1;
        this.layers.hihat = this.stage !== 'SILENCE';
        
        // Professional bass layering system
        this.layers.subbass = this.stage !== 'SILENCE' && avgMotion > 0.5;
        this.layers.wobble = this.isDropping || this.wobbleIntensity > 0.3 || this.halfTimeMode;
        this.layers.midbass = this.buildupIntensity > 0.4 || this.isDropping || this.halfTimeMode;
        this.layers.growl = this.motionPattern === 'breakdown' || this.halfTimeMode;
        
        this.layers.lead = this.buildupIntensity > 0.5 || this.isDropping;
        this.layers.pad = this.motionPattern === 'chill' || this.buildupIntensity > 0.3;
        this.layers.noise = this.motionPattern === 'breakdown' || this.intensity > 3;
        this.layers.riser = this.buildupIntensity > 0.6;
        this.layers.impact = this.isDropping || this.gestureRecognition.drop > 0.5 || this.halfTimeMode;
        this.layers.vocal = this.stage === 'BREAKDOWN' || Math.random() < 0.01;
        this.layers.fx = this.isDropping || this.motionPattern === 'breakdown' || this.halfTimeMode;
        this.layers.halftime = this.halfTimeMode;
        
        // Enhanced BPM calculation for different modes
        let targetBPM = 140;
        if (this.halfTimeMode) targetBPM = 105; // Much slower for nasty half-time
        else if (this.isDropping) targetBPM = 145;
        else if (this.buildupIntensity > 0.5) targetBPM = 135;
        else if (this.motionPattern === 'breakdown') targetBPM = 155;
        else if (this.motionPattern === 'chill') targetBPM = 120;
        
        targetBPM += avgMotion * 3; // Less volatile BPM changes
        this.bpm = this.bpm * 0.95 + targetBPM * 0.05; // Smoother transitions
        this.bpm = Math.max(80, Math.min(180, this.bpm));
        
        // Enhanced theme detection with ethereal modes
        let newTheme = 'silence';
        
        if (this.etherealMode) newTheme = 'ethereal';
        else if (this.digitalMode) newTheme = 'hybrid';
        else if (this.halfTimeMode) newTheme = 'halftime';
        else if (this.stage === 'BREAKDOWN') newTheme = 'breakdown';
        else if (this.isDropping) newTheme = 'drop';
        else if (this.buildupIntensity > 0.5) newTheme = 'buildup';
        else if (this.wobbleIntensity > 0.3) newTheme = 'wobble';
        else if (avgMotion < 1) newTheme = 'chill';
        else newTheme = 'wobble';
        
        if (newTheme !== this.currentTheme) {
          this.currentTheme = newTheme;
          this.elements.themeText.textContent = this.themes[newTheme].text;
          this.elements.themeText.classList.add('visible');
          setTimeout(() => this.elements.themeText.classList.remove('visible'), 3000);
        }
      }

      evolveToBuildup() {
        this.stage = 'BUILDUP';
        this.elements.orb.className = 'orb buildup';
        this.createParticles(30, '#ff00ff');
        console.log('🎵 BUILDUP EVOLUTION: Building the Drop');
      }

      createParticles(count, color) {
        const existing = document.querySelector('.particles');
        if (existing) existing.remove();
        
        const container = document.createElement('div');
        container.className = 'particles';
        document.body.appendChild(container);
        
        for (let i = 0; i < count; i++) {
          const particle = document.createElement('div');
          particle.className = 'particle';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.background = color;
          particle.style.animationDelay = Math.random() * 12 + 's';
          particle.style.animationDuration = (4 + Math.random() * 6) + 's';
          container.appendChild(particle);
        }
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          
          this.playStep();
          this.step = (this.step + 1) % this.sectionLength;
          
          if (this.step === 0) {
            this.phraseCount++;
            this.currentBassIndex = (this.currentBassIndex + 1) % this.bassline.length;
            this.currentLeadIndex = (this.currentLeadIndex + 1) % this.leadPattern.length;
          }
          
          const interval = (60 / this.bpm) * 250; // 16th notes
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep() {
        // Performance optimization - skip if context is not running
        if (!this.ctx || this.ctx.state !== 'running') return;
        
        if (this.step % 4 === 0) {
          this.elements.orb.classList.add('pulse');
          setTimeout(() => this.elements.orb.classList.remove('pulse'), 100);
        }
        
        // Professional dubstep rhythm patterns with optimized checks
        const isHalfTime = this.halfTimeMode;
        const stepMod = isHalfTime ? this.halfTimeStep % 24 : this.step;
        
        try {
          if (isHalfTime) {
            this.halfTimeStep++;
            // 6/8 half-time pattern - kick on 1 and 4, snare on 3
            if (this.layers.kick && (stepMod % 24 === 0 || stepMod % 24 === 12)) this.playKick();
            if (this.layers.snare && stepMod % 24 === 8) this.playSnare();
            if (this.layers.hihat && stepMod % 6 === 3) this.playHihat();
            if (this.layers.halftime && stepMod % 3 === 0) this.playHalfTimeElement();
          } else {
            // Standard 4/4 dubstep patterns
            if (this.layers.kick && this.step % 4 === 0) this.playKick();
            if (this.layers.snare && this.step % 8 === 4) this.playSnare();
            if (this.layers.hihat && this.step % 2 === 1) this.playHihat();
          }
          
          // Bass layers with professional separation
          if (this.layers.subbass && this.step % 4 === 0) this.playSubBass();
          if (this.layers.wobble && this.step % 1 === 0) this.playWobble();
          if (this.layers.midbass && this.step % 2 === 0) this.playMidBass();
          if (this.layers.growl && this.step % 1 === 0) this.playGrowl();
          
          // Enhanced elements with ethereal layers
          if (this.layers.lead && this.step % 2 === 0) this.playLead();
          if (this.layers.pad && this.step % 16 === 0) this.playPad();
          if (this.layers.noise && Math.random() < 0.1) this.playNoise();
          if (this.layers.riser && this.step % 32 === 0) this.playRiser();
          if (this.layers.impact && this.step % 8 === 0) this.playImpact();
          if (this.layers.vocal && Math.random() < 0.05) this.playVocal();
          if (this.layers.fx && Math.random() < 0.15) this.playFX();
          
          // New ethereal elements with reduced frequency for performance
          if (this.layers.ethereal && this.step % 8 === 0) this.playEthereal();
          if (this.layers.digital && this.step % 4 === 0) this.playDigital();
          if (this.layers.ambient && this.step % 32 === 0) this.playAmbient();
          if (this.layers.shimmer && this.step % 16 === 0 && Math.random() < 0.5) this.playShimmer();
        } catch (error) {
          console.warn('Audio playback error:', error);
        }
      }random() < 0.05) this.playVocal();
        if (this.layers.fx && Math.random() < 0.15) this.playFX();
        
        // New ethereal elements
        if (this.layers.ethereal && this.step % 8 === 0) this.playEthereal();
        if (this.layers.digital && this.step % 4 === 0) this.playDigital();
        if (this.layers.ambient && this.step % 32 === 0) this.playAmbient();
        if (this.layers.shimmer && Math.random() < 0.08) this.playShimmer();
      }

      // Ethereal floating elements - soft, dreamy
      playEthereal() {
        const noteIndex = this.scale[Math.floor(Math.random() * this.scale.length)];
        const freq = this.noteToFreq(noteIndex, 5);
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        if (!this.allocateVoice('ethereal', osc1, gain, 6)) return;
        
        // Dual oscillators for richness
        osc1.type = 'triangle';
        osc1.frequency.value = freq;
        osc2.type = 'sine';
        osc2.frequency.value = freq * 1.005; // Slight detune for shimmer
        
        // Slow LFO for ethereal drift
        lfo.type = 'sine';
        lfo.frequency.value = 0.2;
        lfoGain.gain.value = 50;
        lfo.connect(lfoGain);
        lfoGain.connect(filter.frequency);
        lfo.start();
        lfo.stop(this.ctx.currentTime + 6);
        
        filter.type = 'lowpass';
        filter.frequency.value = 800;
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 2);
        env.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 4);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 6);
        
        gain.gain.value = 0.15;
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(env).connect(gain);
        gain.connect(this.chorusEffect); // Through chorus for ethereal width
        this.chorusEffect.connect(this.layerGains.ethereal);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 6);
        osc2.stop(this.ctx.currentTime + 6);
      }

      // Digital computer elements - precise, algorithmic
      playDigital() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('digital', osc, gain, 0.1)) return;
        
        // Digital-style frequencies (precise mathematical ratios)
        const baseFreq = 440;
        const ratios = [1, 1.5, 2, 2.5, 3, 4];
        const freq = baseFreq * ratios[Math.floor(Math.random() * ratios.length)];
        
        osc.type = 'square'; // Digital square wave
        osc.frequency.value = freq;
        
        // Sharp, precise envelope
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.setValueAtTime(0.7, this.ctx.currentTime + 0.02);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        gain.gain.value = 0.2;
        
        osc.connect(this.digitalFilter);
        this.digitalFilter.connect(env).connect(gain).connect(this.layerGains.digital);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
      }

      // Ambient atmospheric textures
      playAmbient() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('ambient', noise, gain, 8)) return;
        
        // Create filtered noise for ambient texture
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 8, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * 0.5;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 200 + Math.random() * 400;
        filter.Q.value = 0.5;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.2, this.ctx.currentTime + 2);
        env.gain.setValueAtTime(0.2, this.ctx.currentTime + 6);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
        
        gain.gain.value = 0.1;
        
        noise.connect(filter);
        filter.connect(env).connect(gain);
        gain.connect(this.ambientReverb); // Heavy reverb for spaciousness
        this.ambientReverb.connect(this.layerGains.ambient);
        
        noise.start();
        noise.stop(this.ctx.currentTime + 8);
      }

      // High-frequency shimmer effects
      playShimmer() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        const lfo = this.ctx.createOscillator();
        const lfoGain = this.ctx.createGain();
        
        if (!this.allocateVoice('shimmer', osc, gain, 0.5)) return;
        
        osc.type = 'triangle';
        osc.frequency.value = 2000 + Math.random() * 2000;
        
        // Fast LFO for shimmer effect
        lfo.type = 'sine';
        lfo.frequency.value = 8 + Math.random() * 4;
        lfoGain.gain.value = 200;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start();
        lfo.stop(this.ctx.currentTime + 0.5);
        
        filter.type = 'highpass';
        filter.frequency.value = 1500;
        filter.Q.value = 2;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        gain.gain.value = 0.08;
        
        osc.connect(filter);
        filter.connect(env).connect(gain);
        gain.connect(this.chorusEffect); // Through chorus for width
        this.chorusEffect.connect(this.layerGains.shimmer);
        
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      // Professional sub bass - the foundation
      playSubBass() {
        const style = this.dubstepStyles[this.currentStyleIndex];
        const noteIndex = this.bassline[this.currentBassIndex % this.bassline.length];
        const freq = style.subFreq || 55; // Use style-specific sub frequency
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('subbass', osc, gain, 0.8)) return;
        
        osc.type = 'sine'; // Pure sine for clean sub
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        gain.gain.value = this.halfTimeMode ? 1.2 : 0.9; // Louder in half-time
        
        osc.connect(env).connect(gain).connect(this.layerGains.subbass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.8);
      }

      // Enhanced wobble with professional modulation
      playWobble() {
        const noteIndex = this.bassline[this.currentBassIndex % this.bassline.length];
        const freq = this.noteToFreq(noteIndex, 2);
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const osc3 = this.ctx.createOscillator(); // Third oscillator for richness
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('wobble', osc1, gain, 0.25)) return;
        
        // Multi-oscillator setup for rich harmonic content
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 1.01; // Slight detune
        osc3.type = 'triangle';
        osc3.frequency.value = freq * 0.5; // Sub-harmonic
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
        
        gain.gain.value = this.isDropping ? 0.9 : this.halfTimeMode ? 1.1 : 0.5;
        
        // All oscillators through the wobble filter
        osc1.connect(this.bassFilter);
        osc2.connect(this.bassFilter);
        osc3.connect(this.bassFilter);
        this.bassFilter.connect(env).connect(gain).connect(this.layerGains.wobble);
        
        osc1.start();
        osc2.start();
        osc3.start();
        osc1.stop(this.ctx.currentTime + 0.25);
        osc2.stop(this.ctx.currentTime + 0.25);
        osc3.stop(this.ctx.currentTime + 0.25);
      }

      // Mid-bass layer for fullness
      playMidBass() {
        const noteIndex = this.bassline[this.currentBassIndex % this.bassline.length];
        const freq = this.noteToFreq(noteIndex, 3);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('midbass', osc, gain, 0.4)) return;
        
        osc.type = 'square';
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        
        gain.gain.value = this.halfTimeMode ? 0.9 : 0.6;
        
        osc.connect(this.midBassFilter);
        this.midBassFilter.connect(env).connect(gain).connect(this.layerGains.midbass);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.4);
      }

      // FM growl synthesis for aggressive sounds
      playGrowl() {
        const noteIndex = this.bassline[this.currentBassIndex % this.bassline.length];
        const carrierFreq = this.noteToFreq(noteIndex, 2);
        
        const carrier = this.ctx.createOscillator();
        const modulator = this.ctx.createOscillator();
        const modGain = this.ctx.createGain();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('growl', carrier, gain, 0.3)) return;
        
        // FM synthesis setup
        carrier.type = 'sawtooth';
        carrier.frequency.value = carrierFreq;
        modulator.type = 'square';
        modulator.frequency.value = carrierFreq * 3.14; // Non-harmonic ratio for growl
        
        modGain.gain.value = carrierFreq * 2; // Modulation depth
        
        filter.type = 'lowpass';
        filter.frequency.value = 400 + this.intensity * 200;
        filter.Q.value = 15;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        gain.gain.value = this.halfTimeMode ? 0.8 : 0.5;
        
        // FM connection
        modulator.connect(modGain);
        modGain.connect(carrier.frequency);
        carrier.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.growl);
        
        carrier.start();
        modulator.start();
        carrier.stop(this.ctx.currentTime + 0.3);
        modulator.stop(this.ctx.currentTime + 0.3);
      }

      // 6/8 half-time specific elements
      playHalfTimeElement() {
        if (!this.halfTimeMode) return;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('halftime', osc, gain, 0.2)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(80 + Math.random() * 40, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(40 + Math.random() * 20, this.ctx.currentTime + 0.1);
        
        filter.type = 'bandpass';
        filter.frequency.value = 200 + Math.random() * 800;
        filter.Q.value = 20;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        gain.gain.value = 0.7;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.halftime);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
      }

      playKick() {
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();

        if (!this.allocateVoice('kick', osc, gain, 0.5)) return;

        osc.type = 'sine';
        osc.frequency.setValueAtTime(60, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.1);

        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);

        gain.gain.value = this.isDropping ? 1.2 : 0.8;

        osc.connect(env).connect(gain).connect(this.layerGains.kick);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.5);
      }

      playSnare() {
        const noise = this.ctx.createBufferSource();
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('snare', noise, gain, 0.2)) return;
        
        // Create snare noise
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 2);
        }
        noise.buffer = noiseBuffer;
        
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(250, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100, this.ctx.currentTime + 0.1);
        
        filter.type = 'highpass';
        filter.frequency.value = 2000;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        gain.gain.value = 0.6;
        
        osc.connect(env).connect(gain).connect(this.layerGains.snare);
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.snare);
        osc.start();
        noise.start();
        osc.stop(this.ctx.currentTime + 0.2);
        noise.stop(this.ctx.currentTime + 0.2);
      }

      playHihat() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('hihat', noise, gain, 0.1)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.1, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'highpass';
        filter.frequency.value = 8000;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        gain.gain.value = 0.3;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.hihat);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.1);
      }

      playWobble() {
        const noteIndex = this.bassline[this.currentBassIndex % this.bassline.length];
        const freq = this.noteToFreq(noteIndex, 2);
        
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('wobble', osc1, gain, 0.25)) return;
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'square';
        osc2.frequency.value = freq * 1.01;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.25);
        
        gain.gain.value = this.isDropping ? 0.8 : 0.4;
        
        osc1.connect(this.bassFilter);
        osc2.connect(this.bassFilter);
        this.bassFilter.connect(env).connect(gain).connect(this.layerGains.wobble);
        
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 0.25);
        osc2.stop(this.ctx.currentTime + 0.25);
      }

      playBass() {
        // This method is replaced by playSubBass, playMidBass, etc.
        // Keeping for compatibility but redirecting to sub bass
        this.playSubBass();
      }

      playLead() {
        const noteIndex = this.leadPattern[this.currentLeadIndex % this.leadPattern.length];
        const freq = this.noteToFreq(noteIndex, 4);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('lead', osc, gain, 0.3)) return;
        
        osc.type = 'sawtooth';
        osc.frequency.value = freq;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 0.05);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.3);
        
        gain.gain.value = this.buildupIntensity * 0.4;
        
        osc.connect(this.leadFilter);
        this.leadFilter.connect(env).connect(gain).connect(this.layerGains.lead);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.3);
      }

      playPad() {
        this.scale.forEach((note, i) => {
          if (i % 2 !== 0) return;
          
          const freq = this.noteToFreq(note, 3);
          
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const env = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          if (!this.allocateVoice('pad', osc, gain, 4)) return;
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          filter.type = 'lowpass';
          filter.frequency.value = 500 + this.buildupIntensity * 1000;
          filter.Q.value = 2;
          
          env.gain.setValueAtTime(0, this.ctx.currentTime);
          env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 1);
          env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          gain.gain.value = 0.2;
          
          osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.pad);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
        });
      }

      playNoise() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('noise', noise, gain, 0.5)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.5, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'bandpass';
        filter.frequency.value = 500 + Math.random() * 2000;
        filter.Q.value = 15;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        gain.gain.value = 0.3;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.noise);
        noise.start();
        noise.stop(this.ctx.currentTime + 0.5);
      }

      playRiser() {
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('riser', noise, gain, 2)) return;
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 2, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(8000, this.ctx.currentTime + 2);
        filter.Q.value = 10;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 2);
        
        gain.gain.value = 0.4;
        
        noise.connect(filter).connect(env).connect(gain).connect(this.layerGains.riser);
        noise.start();
        noise.stop(this.ctx.currentTime + 2);
      }

      playImpact() {
        const osc = this.ctx.createOscillator();
        const noise = this.ctx.createBufferSource();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        
        if (!this.allocateVoice('impact', osc, gain, 0.8)) return;
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(20, this.ctx.currentTime + 0.3);
        
        const noiseBuffer = this.ctx.createBuffer(1, this.ctx.sampleRate * 0.8, this.ctx.sampleRate);
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / noiseData.length, 3);
        }
        noise.buffer = noiseBuffer;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.8);
        
        gain.gain.value = 0.8;
        
        osc.connect(env).connect(gain).connect(this.layerGains.impact);
        noise.connect(env).connect(gain).connect(this.layerGains.impact);
        osc.start();
        noise.start();
        osc.stop(this.ctx.currentTime + 0.8);
        noise.stop(this.ctx.currentTime + 0.8);
        
        this.flashImpact();
      }

      playVocal() {
        // Synthetic vocal sound
        const osc1 = this.ctx.createOscillator();
        const osc2 = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('vocal', osc1, gain, 1)) return;
        
        const freq = this.noteToFreq(this.scale[Math.floor(Math.random() * this.scale.length)], 4);
        
        osc1.type = 'sawtooth';
        osc1.frequency.value = freq;
        osc2.type = 'triangle';
        osc2.frequency.value = freq * 2;
        
        filter.type = 'bandpass';
        filter.frequency.value = 800;
        filter.Q.value = 5;
        
        env.gain.setValueAtTime(0, this.ctx.currentTime);
        env.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.1);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 1);
        
        gain.gain.value = 0.2;
        
        osc1.connect(filter);
        osc2.connect(filter);
        filter.connect(env).connect(gain).connect(this.layerGains.vocal);
        osc1.start();
        osc2.start();
        osc1.stop(this.ctx.currentTime + 1);
        osc2.stop(this.ctx.currentTime + 1);
      }

      playFX() {
        // Random glitch/fx sounds
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const env = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        if (!this.allocateVoice('fx', osc, gain, 0.2)) return;
        
        osc.type = Math.random() > 0.5 ? 'square' : 'sawtooth';
        osc.frequency.setValueAtTime(200 + Math.random() * 1000, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(100 + Math.random() * 500, this.ctx.currentTime + 0.1);
        
        filter.type = 'bandpass';
        filter.frequency.value = 500 + Math.random() * 2000;
        filter.Q.value = 20;
        
        env.gain.setValueAtTime(1, this.ctx.currentTime);
        env.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.2);
        
        gain.gain.value = 0.3;
        
        osc.connect(filter).connect(env).connect(gain).connect(this.layerGains.fx);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.2);
      }

      allocateVoice(layer, source, gainNode, duration) {
        const pool = this.voicePool[layer];
        if (!pool) {
          console.warn(`Voice pool not found for layer: ${layer}`);
          return false;
        }
        
        try {
          // Efficient cleanup - remove expired voices
          const now = this.ctx.currentTime;
          pool.active = pool.active.filter(voice => {
            if (now > voice.startTime + voice.duration + 0.5) {
              try {
                if (voice.source && voice.source.stop) voice.source.stop();
              } catch(e) {
                // Ignore stop errors - voice may already be stopped
              }
              return false;
            }
            return true;
          });
          
          // If pool is full, remove oldest
          if (pool.active.length >= pool.max) {
            const oldest = pool.active.shift();
            if (oldest && oldest.source && oldest.source.stop) {
              try {
                oldest.source.stop();
              } catch(e) {
                // Ignore stop errors
              }
            }
          }
          
          const voice = { source, gain: gainNode, startTime: now, duration };
          pool.active.push(voice);
          
          return true;
        } catch (error) {
          console.warn(`Voice allocation error for ${layer}:`, error);
          return false;
        }
      }

      noteToFreq(note, octave = 4) {
        const semitones = this.keyOffsets[this.key] + note;
        return 261.63 * Math.pow(2, semitones / 12 + (octave - 4));
      }

      updateUI() {
        // Performance optimization - only update UI elements that have changed
        try {
          const newStageName = this.voidPhase ? 'VOID STATE' : this.stage;
          if (this.elements.stageName.textContent !== newStageName) {
            this.elements.stageName.textContent = newStageName;
          }
          
          const newTechnique = this.currentTechnique.toUpperCase();
          if (this.elements.technique.textContent !== newTechnique) {
            this.elements.technique.textContent = newTechnique;
          }
          
          const newBPM = Math.round(this.bpm).toString();
          if (this.elements.bpmDisplay.textContent !== newBPM) {
            this.elements.bpmDisplay.textContent = newBPM;
          }
          
          const newKey = `${this.key} ${this.mode.toUpperCase()}`;
          if (this.elements.keyDisplay.textContent !== newKey) {
            this.elements.keyDisplay.textContent = newKey;
          }
          
          // Optimized bar updates
          const motionPercent = Math.min((this.motion + this.intensity) * 15, 100);
          this.elements.motionBar.style.width = motionPercent + '%';
          
          const wobblePercent = Math.min(this.wobbleIntensity * 100, 100);
          this.elements.wobbleBar.style.width = wobblePercent + '%';
          
          const totalVoices = Object.values(this.voicePool).reduce((sum, pool) => sum + (pool.active?.length || 0), 0);
          const newVoiceCount = totalVoices.toString();
          if (this.elements.voiceCount.textContent !== newVoiceCount) {
            this.elements.voiceCount.textContent = newVoiceCount;
          }
          
          // Optimized spectrum visualizer
          if (this.analyser && this.dataArray) {
            this.analyser.getByteFrequencyData(this.dataArray);
            
            // Update every other bar for performance
            for (let i = 0; i < this.spectrumBars.length; i += 2) {
              if (this.spectrumBars[i]) {
                const height = (this.dataArray[i] / 255) * 80;
                this.spectrumBars[i].style.height = height + 'px';
                
                // Dynamic colors based on stage
                let color = 'rgba(255,255,255,0.8)';
                if (this.etherealMode) color = 'rgba(187,136,255,0.8)';
                else if (this.digitalMode) color = 'rgba(255,136,187,0.8)';
                else if (this.halfTimeMode) color = 'rgba(255,68,0,0.8)';
                else if (this.stage === 'BUILDUP') color = 'rgba(255,0,255,0.8)';
                else if (this.stage === 'DROP') color = 'rgba(0,255,0,0.8)';
                else if (this.stage === 'BREAKDOWN') {
                  const hue = (Date.now() / 10 + i * 10) % 360;
                  color = `hsla(${hue}, 100%, 50%, 0.8)`;
                }
                else if (this.stage === 'WOBBLE') color = 'rgba(0,136,255,0.8)';
                
                this.spectrumBars[i].style.background = `linear-gradient(0deg, ${color}, rgba(255,255,255,0.2))`;
              }
            }
          }
        } catch (error) {
          console.warn('UI update error:', error);
        }
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          try {
            // Update orb position
            this.elements.orb.style.left = this.pos.x + '%';
            this.elements.orb.style.top = this.pos.y + '%';
            
            // Update UI every 4 steps for performance
            if (this.step % 4 === 0) {
              this.updateUI();
            }
            
            // Optimized background updates
            const theme = this.themes[this.currentTheme];
            const intensityNorm = Math.min(this.intensity / 4, 1);
            const motionNorm = Math.min(this.motion / 6, 1);
            
            let bg;
            if (this.etherealMode) {
              const ethereal = Math.sin(Date.now() / 2000) * 0.3 + 0.7;
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(187,136,255,${ethereal * 0.4}) ${5 + motionNorm * 10}%, rgba(102,204,255,${ethereal * 0.3}) ${20 + intensityNorm * 20}%, #0a0a0a ${70}%)`;
            } else if (this.digitalMode) {
              const digital = Math.floor(Date.now() / 100) % 2 ? 0.8 : 0.6; // Digital flicker
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,136,187,${digital}) ${5 * motionNorm}%, rgba(136,255,187,${digital * 0.7}) ${20 * intensityNorm}%, #001100 ${70}%)`;
            } else if (this.halfTimeMode) {
              const chaos = Math.sin(Date.now() / 50) * 0.5 + 0.5;
              const hue = Date.now() / 10 % 360;
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 100%, 50%) ${chaos * 10}%, hsl(${(hue + 120) % 360}, 100%, 40%) ${20 + chaos * 20}%, #000 ${60}%)`;
            } else if (this.stage === 'BREAKDOWN') {
              const chaos = Math.sin(Date.now() / 50) * 0.5 + 0.5;
              const hue = Date.now() / 10 % 360;
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, hsl(${hue}, 100%, 50%) ${chaos * 10}%, hsl(${(hue + 120) % 360}, 100%, 40%) ${20 + chaos * 20}%, #000 ${60}%)`;
            } else if (this.isDropping) {
              const pulse = Math.sin(Date.now() / 100) * 0.3 + 0.7;
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(0,255,0,${pulse}) ${5 + motionNorm * 10}%, rgba(0,128,0,${pulse * 0.5}) ${20 + intensityNorm * 20}%, #001100 70%)`;
            } else if (this.buildupIntensity > 0.3) {
              const tension = this.buildupIntensity;
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, rgba(255,0,255,${tension}) ${5 * tension}%, rgba(128,0,128,${tension * 0.6}) ${20 * tension}%, #110011 ${60 + 20 * tension}%)`;
            } else {
              bg = `radial-gradient(circle at ${this.pos.x}% ${this.pos.y}%, ${theme.colors[0]} ${5 * motionNorm}%, ${theme.colors[1]} ${20 * intensityNorm}%, #0a0a0a ${70}%)`;
            }
            
            document.body.style.background = bg;
            
            // Cinematic overlay for intense moments
            const shouldShowOverlay = this.isDropping || this.stage === 'BREAKDOWN' || this.buildupIntensity > 0.7 || this.etherealMode;
            this.elements.cinematicOverlay.classList.toggle('active', shouldShowOverlay);
            
          } catch (error) {
            console.warn('Animation error:', error);
          }
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }
    }

    // Initialize engine when DOM is ready - Fixed initialization order
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', () => {
        console.log('🚀 DOM loaded, initializing engine...');
        new DubstepEngine();
      });
    } else {
      // DOM already loaded
      console.log('🚀 DOM ready, initializing engine immediately...');
      new DubstepEngine();
    }
  </script>
</body>
</html>
  </script>
</body>
</html>
