<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP - Jazz Orchestra</title>
    <style>
        :root{--phi:1.618}
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#050508;overflow:hidden;touch-action:none;height:100vh;font-family:system-ui,-apple-system,sans-serif}
        canvas{position:fixed;inset:0}

        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:100;cursor:pointer;background:#050508}
        #enter.off{display:none}
        #enter i{width:89px;height:89px;border-radius:50%;border:1px solid rgba(200,180,255,0.1);display:flex;align-items:center;justify-content:center}
        #enter i::after{content:'';width:34px;height:34px;border-radius:50%;border:1px solid rgba(200,180,255,0.2)}

        #loading{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:99;background:#050508;color:rgba(200,180,255,0.25);font-size:8px;letter-spacing:3px}
        #loading.off{display:none}

        #dials{position:fixed;bottom:0;left:0;right:0;z-index:50;padding:13px 21px 34px;touch-action:pan-x}
        .dial{display:flex;align-items:center;justify-content:center;gap:21px;margin-bottom:13px}
        .dial-opt{font-size:11px;color:rgba(200,180,255,0.15);cursor:pointer;padding:8px 13px;transition:all 0.3s;letter-spacing:1px;-webkit-tap-highlight-color:transparent}
        .dial-opt.on{color:rgba(200,180,255,0.8)}
        .dial-line{width:1px;height:13px;background:rgba(200,180,255,0.06)}

        #band-status{position:fixed;top:13px;left:13px;z-index:50;font-size:9px;color:rgba(200,180,255,0.35);letter-spacing:1px;line-height:1.6}
        #band-status .agent{opacity:0.4;transition:opacity 0.5s}
        #band-status .agent.active{opacity:1;color:rgba(200,180,255,0.7)}
        #band-status .direction{position:absolute;top:0;right:13px;color:rgba(200,180,255,0.25)}

        #settings-btn{position:fixed;top:13px;right:13px;z-index:60;width:24px;height:24px;border:1px solid rgba(200,180,255,0.15);border-radius:50%;background:transparent;color:rgba(200,180,255,0.4);font-size:12px;cursor:pointer;display:flex;align-items:center;justify-content:center}
        #settings-btn:hover{border-color:rgba(200,180,255,0.4);color:rgba(200,180,255,0.7)}
        #settings-panel{position:fixed;top:50px;right:13px;z-index:60;background:rgba(10,10,15,0.95);border:1px solid rgba(200,180,255,0.15);border-radius:8px;padding:13px;display:none;width:260px}
        #settings-panel.open{display:block}
        #settings-panel label{display:block;font-size:9px;color:rgba(200,180,255,0.5);margin-bottom:5px;letter-spacing:1px}
        #settings-panel input{width:100%;background:rgba(200,180,255,0.05);border:1px solid rgba(200,180,255,0.2);border-radius:4px;padding:8px;color:rgba(200,180,255,0.8);font-size:10px;font-family:monospace}
        #settings-panel input:focus{outline:none;border-color:rgba(200,180,255,0.5)}
        #settings-panel .status{font-size:8px;color:rgba(200,180,255,0.4);margin-top:8px}
        #settings-panel .status.ok{color:rgba(150,255,150,0.7)}
        #settings-panel .status.err{color:rgba(255,150,150,0.7)}
    </style>
</head>
<body>
<div id="enter"><i></i></div>
<div id="loading" class="off">...</div>
<div id="band-status" style="display:none">
    <div class="agent" id="st-drums">drums: steady</div>
    <div class="agent" id="st-bass">bass: root</div>
    <div class="agent" id="st-pad">pad: close</div>
    <div class="agent" id="st-lead">lead: rest</div>
    <div class="direction" id="st-direction">~</div>
</div>

<button id="settings-btn" style="display:none">*</button>
<div id="settings-panel">
    <label>CUSTOM AI KEY (optional)</label>
    <input type="password" id="groq-key" placeholder="gsk_..." autocomplete="off">
    <div class="status" id="groq-status">leave blank to use default</div>
</div>

<div id="dials" style="display:none">
    <div class="dial" data-dial="pulse">
        <span class="dial-opt" data-v="0">—</span>
        <span class="dial-line"></span>
        <span class="dial-opt on" data-v="dust">dust</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="gold">gold</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="drive">drive</span>
    </div>
    <div class="dial" data-dial="depth">
        <span class="dial-opt" data-v="0">—</span>
        <span class="dial-line"></span>
        <span class="dial-opt on" data-v="sub">sub</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="thick">thick</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="warm">warm</span>
    </div>
    <div class="dial" data-dial="haze">
        <span class="dial-opt" data-v="clear">clear</span>
        <span class="dial-line"></span>
        <span class="dial-opt on" data-v="fog">fog</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="glass">glass</span>
        <span class="dial-line"></span>
        <span class="dial-opt" data-v="heat">heat</span>
    </div>
</div>

<canvas id="c"></canvas>

<script>
// GUMP - THE CORE MAGIC
// Generative + Motion → Music + Layers + Lo-fi + Evolution

const TAU = Math.PI * 2;
const PHI = 1.618033988749;

let ctx, master, canvas, vc;
let running = false;

// State
let dial = { pulse: 'dust', depth: 'sub', haze: 'fog' };
let field = { x: 0.5, y: 0.5, energy: 0, time: 0, peak: 0 };

// Musical state - THE HEART
let music = {
    intensity: 0.4,
    bar: 0,
    phrase: 0,
    density: 0.5
};

// ============ SAMPLES ============

const URLS = {
    snare_a: 'https://cdn.freesound.org/previews/387/387186_7255534-lq.mp3',
    snare_b: 'https://cdn.freesound.org/previews/398/398712_183766-lq.mp3',
    hat_a: 'https://cdn.freesound.org/previews/250/250540_4486188-lq.mp3',
    hat_b: 'https://cdn.freesound.org/previews/353/353774_5121236-lq.mp3',
    perc: 'https://cdn.freesound.org/previews/250/250537_4486188-lq.mp3',
};

let samples = {};

async function loadSamples() {
    for (const [k, url] of Object.entries(URLS)) {
        try {
            const r = await fetch(url);
            samples[k] = await ctx.decodeAudioData(await r.arrayBuffer());
        } catch (e) {
            samples[k] = makeFallback(k);
        }
    }
    // Generate proper kicks and snares
    samples.kick_a = createKickBuffer('deep');
    samples.kick_b = createKickBuffer('punch');
}

// ============ SYNTHESIZED KICK - THE FOUNDATION ============

function createKickBuffer(type) {
    const sr = ctx.sampleRate;
    const len = sr * 0.5; // 500ms
    const buf = ctx.createBuffer(2, len, sr);

    // Kick parameters based on type
    const params = {
        deep: { // 808-style deep sub kick
            startFreq: 150,
            endFreq: 35,
            pitchDecay: 0.08,
            ampDecay: 0.4,
            clickAmt: 0.3,
            subAmt: 1.0,
            drive: 1.2
        },
        punch: { // Punchier, more attack
            startFreq: 180,
            endFreq: 45,
            pitchDecay: 0.05,
            ampDecay: 0.25,
            clickAmt: 0.5,
            subAmt: 0.8,
            drive: 1.4
        }
    }[type];

    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
            const t = i / sr;

            // Pitch envelope - exponential drop
            const pitchEnv = Math.exp(-t / params.pitchDecay);
            const freq = params.endFreq + (params.startFreq - params.endFreq) * pitchEnv;

            // Phase accumulation for smooth frequency sweep
            const phase = TAU * (params.endFreq * t + (params.startFreq - params.endFreq) * params.pitchDecay * (1 - pitchEnv));

            // Sub tone - pure sine
            const sub = Math.sin(phase) * params.subAmt;

            // Click/transient - noise burst + high sine
            const clickEnv = Math.exp(-t * 80);
            const click = (Math.sin(phase * 4) * 0.5 + (Math.random() * 2 - 1) * 0.5) * clickEnv * params.clickAmt;

            // Amp envelope - fast attack, controlled decay
            const ampEnv = Math.exp(-t / params.ampDecay) * Math.min(1, t * 500); // 2ms attack

            // Combine and soft clip for warmth
            let sample = (sub + click) * ampEnv * params.drive;
            sample = Math.tanh(sample * 0.8) * 0.9; // Soft saturation

            d[i] = sample;
        }
    }
    return buf;
}

function makeFallback(k) {
    const sr = ctx.sampleRate, len = sr * 0.4;
    const buf = ctx.createBuffer(2, len, sr);
    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        if (k.includes('snare')) {
            for (let i = 0; i < len; i++) {
                const t = i / sr;
                // Body + noise
                const body = Math.sin(TAU * 180 * t) * Math.exp(-t * 20);
                const noise = (Math.random() * 2 - 1) * Math.exp(-t * 12);
                d[i] = (body * 0.4 + noise * 0.6) * 0.7;
            }
        } else {
            for (let i = 0; i < len * 0.15; i++) {
                const t = i / sr;
                d[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40) * 0.35;
            }
        }
    }
    return buf;
}

// ============ SIDECHAIN - MAKES LOW END BREATHE ============

let sidechainGain;
let sidechainEnv = 1;

function initSidechain() {
    sidechainGain = ctx.createGain();
    sidechainGain.gain.value = 1;
}

function triggerSidechain(amount = 0.7, release = 0.15) {
    // Duck to (1 - amount), then release
    const now = ctx.currentTime;
    sidechainGain.gain.cancelScheduledValues(now);
    sidechainGain.gain.setValueAtTime(1 - amount, now);
    sidechainGain.gain.exponentialRampToValueAtTime(1, now + release);
}

// ============ FX CHAIN ============

let kickBus, drumBus, bassBus, padBus, masterBus;
let lofiFilter, verb, verbWet, dly, dlyWet, sat, comp, lim;
let subBass; // Separate sub bass bus for clean low end

function initFX() {
    // KICK gets its own bus - no reverb, no delay, clean and punchy
    kickBus = ctx.createGain();
    kickBus.gain.value = 0.85;

    // Sub bass - also clean, sidechained
    subBass = ctx.createGain();
    subBass.gain.value = 0.7;

    drumBus = ctx.createGain(); drumBus.gain.value = 0.7;
    bassBus = ctx.createGain(); bassBus.gain.value = 0.55;
    padBus = ctx.createGain(); padBus.gain.value = 0.35;
    masterBus = ctx.createGain();

    // Initialize sidechain
    initSidechain();

    // Warm saturation
    sat = ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    for (let i = 0; i < 65536; i++) {
        const x = (i / 32768 - 1);
        // Asymmetric soft clipping for analog warmth
        curve[i] = Math.tanh(x * 1.8) * 0.85 + x * 0.1;
    }
    sat.curve = curve;
    sat.oversample = '4x';

    lofiFilter = ctx.createBiquadFilter();
    lofiFilter.type = 'lowpass';
    lofiFilter.frequency.value = 18000;

    // Glue compressor - gentler
    comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -18;
    comp.ratio.value = 3;
    comp.attack.value = 0.01;
    comp.release.value = 0.15;
    comp.knee.value = 6;

    // Limiter
    lim = ctx.createDynamicsCompressor();
    lim.threshold.value = -3;
    lim.ratio.value = 20;
    lim.attack.value = 0.001;

    // Low cut on master (sub handled separately)
    const masterLowCut = ctx.createBiquadFilter();
    masterLowCut.type = 'highpass';
    masterLowCut.frequency.value = 30;
    masterLowCut.Q.value = 0.7;

    // Lush reverb - longer, more diffuse
    verb = ctx.createConvolver();
    const vLen = ctx.sampleRate * 3.2;
    const vBuf = ctx.createBuffer(2, vLen, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = vBuf.getChannelData(ch);
        for (let i = 0; i < vLen; i++) {
            // Early reflections + diffuse tail
            const early = i < ctx.sampleRate * 0.08 ? Math.random() * 0.3 : 0;
            const tail = (Math.random() * 2 - 1) * Math.exp(-i / ctx.sampleRate / 1.8);
            d[i] = (early + tail) * 0.4;
        }
    }
    verb.buffer = vBuf;
    verbWet = ctx.createGain();
    verbWet.gain.value = 0.2;

    // Tape delay
    dly = ctx.createDelay(1);
    dly.delayTime.value = 0.375;
    const dlyFb = ctx.createGain();
    dlyFb.gain.value = 0.32;
    const dlyFilt = ctx.createBiquadFilter();
    dlyFilt.type = 'lowpass';
    dlyFilt.frequency.value = 2200;
    dlyWet = ctx.createGain();
    dlyWet.gain.value = 0.14;
    dly.connect(dlyFilt).connect(dlyFb).connect(dly);
    dlyFilt.connect(dlyWet);

    master = ctx.createGain();
    master.gain.value = 0.9;

    // ROUTING - Key for clean low end

    // Kick goes direct to limiter (clean, punchy)
    kickBus.connect(lim);

    // Sub bass through sidechain, then direct to limiter (no FX)
    subBass.connect(sidechainGain).connect(lim);

    // Bass mids through sidechain, then to master bus for FX
    bassBus.connect(sidechainGain).connect(masterBus);

    // Drums and pads to master bus
    drumBus.connect(masterBus);
    padBus.connect(masterBus);

    // Master bus processing (everything except kick and sub)
    masterBus.connect(sat).connect(lofiFilter).connect(masterLowCut).connect(comp).connect(lim);

    // FX sends (not from kick or sub bass)
    masterBus.connect(verb); verb.connect(verbWet).connect(lim);
    masterBus.connect(dly); dlyWet.connect(lim);

    // Final output
    lim.connect(master).connect(ctx.destination);
}

// ============ EUCLIDEAN PATTERN ENGINE ============

function euclidean(steps, pulses, rot = 0) {
    const p = [];
    let b = 0;
    for (let i = 0; i < steps; i++) {
        b += pulses;
        p.push(b >= steps ? (b -= steps, 1) : 0);
    }
    for (let i = 0; i < rot; i++) p.push(p.shift());
    return p;
}

const GENES = {
    dust: { bpm: 72, kickP: 3, swing: 0.12, ghost: 0.28, hatP: 0.4, kit: 'a' },
    gold: { bpm: 88, kickP: 5, swing: 0.16, ghost: 0.22, hatP: 0.55, kit: 'b' },
    drive: { bpm: 122, kickP: 4, swing: 0, ghost: 0.12, hatP: 0.7, kit: 'b' }
};

let pattern = null;
let step = 0;
let lastStep = 0;

function genPattern(gene, bar) {
    const g = GENES[gene];

    // AI INFLUENCE: Use bandState.drums to shape pattern
    const aiDensity = bandState.drums.density;
    const aiEnergy = bandState.drums.energy;
    const aiPattern = bandState.drums.pattern;

    const evolution = Math.sin(bar * 0.3 + field.x * 2) * 0.6;
    let kickPulses = Math.round(g.kickP + evolution);

    // AI adjusts kick density
    if (aiPattern === 'pushing') kickPulses = Math.min(7, kickPulses + 1);
    if (aiPattern === 'sparse' || aiPattern === 'minimal') kickPulses = Math.max(2, kickPulses - 2);

    const kicks = euclidean(16, kickPulses, bar % 5);

    const snares = new Array(16).fill(0);
    snares[4] = 0.9; snares[12] = 1;
    // Variation based on phrase
    if (music.phrase === 3) snares[10] = 0.5;
    if (music.phrase === 7) snares[14] = 0.6;

    // AI FILL: Add extra hits when AI calls for fill
    if (aiPattern === 'fill' && bandState.drums.lastFill === bar) {
        // Jazz fill - toms and snare flurry in last 4 steps
        snares[13] = 0.6;
        snares[14] = 0.7;
        snares[15] = 0.5;
    }

    // AI ACCENT: Strong hit on downbeat
    if (aiPattern === 'accenting') {
        kicks[0] = 1;
        snares[4] = 1;
    }

    // Hats driven by intensity AND AI density
    const hats = [];
    const hatDensity = g.hatP * (0.4 + aiDensity * 0.4 + music.intensity * 0.3);
    for (let i = 0; i < 16; i++) {
        if (aiPattern === 'minimal' && i % 4 !== 0) {
            hats.push(0); // Minimal = only quarter notes
        } else {
            hats.push(Math.random() < hatDensity ? 0.2 + Math.random() * 0.35 : 0);
        }
    }

    // Ghost notes - AI sparse pattern reduces these
    const ghostProb = aiPattern === 'sparse' ? g.ghost * 0.3 : g.ghost;
    const ghosts = kicks.map((k, i) =>
        !k && !snares[i] && Math.random() < ghostProb * music.intensity * aiDensity ? 0.12 + Math.random() * 0.1 : 0
    );

    // Perc accents - more when pushing
    const percs = [];
    const percProb = aiPattern === 'pushing' ? 0.35 : 0.2;
    for (let i = 0; i < 16; i++) {
        percs.push(i % 4 === 2 && Math.random() < percProb * music.intensity ? 0.15 : 0);
    }

    return { kicks, snares, hats, ghosts, percs, swing: g.swing, kit: g.kit, bpm: g.bpm };
}

function play(buf, opts = {}) {
    if (!buf) return;
    const src = ctx.createBufferSource();
    src.buffer = buf;
    if (opts.pitch) src.playbackRate.value = Math.pow(2, opts.pitch / 12);

    const g = ctx.createGain();
    g.gain.value = opts.vol || 1;

    let node = src;
    if (opts.filter) {
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = opts.filter;
        src.connect(f);
        node = f;
    }

    if (opts.pan) {
        const p = ctx.createStereoPanner();
        p.pan.value = opts.pan;
        node.connect(p).connect(g);
    } else {
        node.connect(g);
    }

    g.connect(opts.bus || drumBus);
    // Humanize timing
    src.start(ctx.currentTime + (opts.delay || 0) + (Math.random() - 0.5) * 0.006);
}

function updateBeats() {
    if (dial.pulse === '0') return;

    const gene = GENES[dial.pulse];
    if (!gene) return;

    const stepDur = 60 / gene.bpm / 4;
    const now = ctx.currentTime;

    if (now - lastStep >= stepDur) {
        lastStep = now;

        // New pattern each bar
        if (step % 16 === 0) {
            music.bar++;
            music.phrase = music.bar % 8;
            pattern = genPattern(dial.pulse, music.bar);

            // CORE MAGIC: Motion → Intensity
            music.intensity = music.intensity * 0.85 + field.peak * 0.15;
            music.intensity = Math.max(0.25, Math.min(1, music.intensity));
            music.density = 0.4 + music.intensity * 0.4;
        }

        if (!pattern) return;

        const s = step % 16;
        const sw = s % 2 === 1 ? stepDur * pattern.swing : 0;
        const k = pattern.kit;

        // KICK - the foundation
        if (pattern.kicks[s]) {
            const vel = 0.85 + music.intensity * 0.15;
            play(samples['kick_' + k], { vol: vel, delay: sw, bus: kickBus });
            // Trigger sidechain - bass ducks
            triggerSidechain(0.6, 0.12 + (1 - music.intensity) * 0.08);
        }

        if (pattern.snares[s]) {
            const vel = pattern.snares[s] * (0.7 + music.intensity * 0.25);
            play(samples['snare_' + k], { vol: vel, delay: sw, pan: (Math.random() - 0.5) * 0.12 });
        }

        if (pattern.hats[s]) {
            const vel = pattern.hats[s] * (0.5 + music.density * 0.4);
            const filt = dial.haze === 'fog' ? 5500 : dial.haze === 'heat' ? 7000 : 11000;
            play(samples['hat_' + k], { vol: vel, delay: sw, pan: (Math.random() - 0.5) * 0.4, filter: filt });
        }

        if (pattern.ghosts[s]) {
            play(samples['kick_' + k], { vol: pattern.ghosts[s], delay: sw, filter: 700, pitch: -3 });
        }

        if (pattern.percs[s]) {
            play(samples['perc'], { vol: pattern.percs[s], delay: sw, pan: (Math.random() - 0.5) * 0.6, pitch: 5 });
        }

        step++;
    }
}

// ============ BASS - LAYERED, BREATHING ============

// Bass has two layers: SUB (pure low) and MID (harmonics for speakers)
let bassSubOsc, bassSubGain;
let bassMidOsc1, bassMidOsc2, bassMidFilter, bassMidGain;
let bassTargetFreq = 55;
let bassCurrentFreq = 55;
let bassNoteActive = false;

function initBass() {
    // SUB LAYER - Pure sine, very low, clean
    bassSubOsc = ctx.createOscillator();
    bassSubOsc.type = 'sine';
    bassSubOsc.frequency.value = 55;

    bassSubGain = ctx.createGain();
    bassSubGain.gain.value = 0;

    // Sub goes to dedicated sub bus (sidechained, no FX)
    bassSubOsc.connect(bassSubGain).connect(subBass);
    bassSubOsc.start();

    // MID LAYER - Harmonics that translate on small speakers
    bassMidOsc1 = ctx.createOscillator();
    bassMidOsc2 = ctx.createOscillator();
    bassMidOsc1.type = 'triangle';
    bassMidOsc2.type = 'sawtooth';
    bassMidOsc1.frequency.value = 55;
    bassMidOsc2.frequency.value = 55;
    bassMidOsc2.detune.value = 8;

    bassMidFilter = ctx.createBiquadFilter();
    bassMidFilter.type = 'lowpass';
    bassMidFilter.frequency.value = 400;
    bassMidFilter.Q.value = 2;

    bassMidGain = ctx.createGain();
    bassMidGain.gain.value = 0;

    const midMix = ctx.createGain();
    midMix.gain.value = 0.5;
    bassMidOsc1.connect(midMix);
    bassMidOsc2.connect(midMix);
    midMix.connect(bassMidFilter).connect(bassMidGain).connect(bassBus);
    bassMidOsc1.start();
    bassMidOsc2.start();
}

// Bass sequence evolves
let bassSeq = [0, 0, 5, 3];
let lastBassShift = 0;
let lastBassNote = -1;

// Walking bass patterns - jazz movement
const WALKING_PATTERNS = [
    [0, 2, 4, 5],
    [0, -2, -4, -5],
    [0, 5, 3, 7],
    [0, 7, 5, 3],
    [0, 0, 5, 7],
    [0, 3, 5, 6],
];

// Trigger a bass note with envelope - MAKES IT BREATHE
function triggerBassNote(freq, velocity = 1, duration = 0.4) {
    const now = ctx.currentTime;
    const attack = 0.008;
    const decay = 0.1;
    const sustain = 0.7;
    const release = duration * 0.4;

    // Glide to new frequency (portamento)
    bassSubOsc.frequency.exponentialRampToValueAtTime(freq, now + 0.03);
    bassMidOsc1.frequency.exponentialRampToValueAtTime(freq, now + 0.03);
    bassMidOsc2.frequency.exponentialRampToValueAtTime(freq, now + 0.03);

    // SUB envelope - slower, rounder
    const subVol = velocity * 0.65;
    bassSubGain.gain.cancelScheduledValues(now);
    bassSubGain.gain.setValueAtTime(bassSubGain.gain.value, now);
    bassSubGain.gain.linearRampToValueAtTime(subVol, now + attack * 2);
    bassSubGain.gain.linearRampToValueAtTime(subVol * sustain, now + attack * 2 + decay);
    bassSubGain.gain.linearRampToValueAtTime(subVol * sustain * 0.8, now + duration - release);
    bassSubGain.gain.linearRampToValueAtTime(0.001, now + duration);

    // MID envelope - punchier attack
    const midVol = velocity * 0.4;
    bassMidGain.gain.cancelScheduledValues(now);
    bassMidGain.gain.setValueAtTime(bassMidGain.gain.value, now);
    bassMidGain.gain.linearRampToValueAtTime(midVol * 1.2, now + attack); // Overshoot
    bassMidGain.gain.linearRampToValueAtTime(midVol * sustain, now + attack + decay);
    bassMidGain.gain.linearRampToValueAtTime(midVol * sustain * 0.6, now + duration - release);
    bassMidGain.gain.linearRampToValueAtTime(0.001, now + duration);

    // Filter envelope - opens then closes
    bassMidFilter.frequency.cancelScheduledValues(now);
    bassMidFilter.frequency.setValueAtTime(200, now);
    bassMidFilter.frequency.linearRampToValueAtTime(800 * velocity, now + attack);
    bassMidFilter.frequency.exponentialRampToValueAtTime(300, now + duration * 0.5);

    bassNoteActive = true;
    bassTargetFreq = freq;
}

function updateBass() {
    if (dial.depth === '0') {
        bassSubGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
        bassMidGain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.1);
        return;
    }

    const cfg = {
        sub: { base: 32.7, subVol: 1.0, midVol: 0.3, filter: 300 },
        thick: { base: 41.2, subVol: 0.7, midVol: 0.6, filter: 600 },
        warm: { base: 55, subVol: 0.8, midVol: 0.5, filter: 450 }
    }[dial.depth];

    if (!cfg) return;

    // AI INFLUENCE
    const aiWalking = bandState.bass.walking;
    const aiRegister = bandState.bass.register;
    const aiActivity = bandState.bass.activity;

    const registerMult = { low: 0.5, mid: 1, high: 2 }[aiRegister] || 1;

    // Pattern evolution
    if (aiWalking) {
        const walkPattern = WALKING_PATTERNS[music.bar % WALKING_PATTERNS.length];
        bassSeq = walkPattern;
    } else if (field.time - lastBassShift > 4 && Math.random() < 0.08 * aiActivity) {
        lastBassShift = field.time;
        bassSeq[Math.floor(Math.random() * 4)] = [0, 3, 5, 7, -5, -7][Math.floor(Math.random() * 6)];
    }

    // Get current note
    const noteIndex = step % 4;
    const note = bassSeq[noteIndex];

    // Only trigger on note change or every bar
    if (note !== lastBassNote || step % 16 === 0) {
        lastBassNote = note;

        const freq = cfg.base * registerMult * Math.pow(2, note / 12);
        const gene = GENES[dial.pulse] || GENES.dust;
        const noteDuration = (60 / gene.bpm) * (aiWalking ? 1 : 2); // Walking = quarter notes

        const velocity = 0.7 + aiActivity * 0.3 + music.intensity * 0.2;
        triggerBassNote(freq, Math.min(1, velocity), noteDuration);
    }

    // Mid layer character changes with dial
    bassMidOsc1.type = dial.depth === 'thick' ? 'sawtooth' : 'triangle';
}

// ============ PAD LAYER ============

let padOscs = [], padG, padF;

const CHORDS = {
    dust: [[0, 3, 7, 10], [5, 8, 12, 15], [3, 7, 10, 14], [7, 10, 14, 17]],
    gold: [[0, 4, 7, 11], [5, 9, 12, 16], [7, 11, 14, 17], [0, 4, 7, 11]],
    drive: [[0, 3, 7, 12], [5, 8, 12, 17], [7, 10, 14, 19], [0, 3, 7, 12]]
};

function initPad() {
    padG = ctx.createGain();
    padG.gain.value = 0;
    padF = ctx.createBiquadFilter();
    padF.type = 'lowpass';
    padF.frequency.value = 1600;

    for (let i = 0; i < 4; i++) {
        const o = ctx.createOscillator();
        o.type = 'sine';
        o.frequency.value = 220;
        const g = ctx.createGain();
        g.gain.value = 0.1 / (i + 1);
        o.connect(g).connect(padF);
        o.start();
        padOscs.push({ o, g });
    }
    padF.connect(padG).connect(padBus);
}

// AI voicing variations - jazz piano voicings
const VOICINGS = {
    close: [0, 3, 7, 10],      // Standard close voicing
    spread: [0, 7, 10, 15],    // Open voicing, more space
    shell: [0, 10, 14, 0],     // Shell voicing (root, 7th, 3rd)
    rich: [0, 4, 7, 11],       // Major 7 lush
    sparse: [0, 7, 0, 0],      // Just root and 5th - minimal
    out: [0, 6, 11, 16]        // Tritone sub - outside harmony
};

function updatePad() {
    const genre = dial.pulse === '0' ? 'dust' : dial.pulse;
    const chords = CHORDS[genre] || CHORDS.dust;
    const baseChord = chords[music.bar % 4];
    const base = 110 * Math.pow(2, (1 - field.y) * 0.35);

    // AI INFLUENCE: Voicing from bandState
    const aiVoicing = bandState.pad.voicing;
    const aiVolume = bandState.pad.volume;
    const voicing = VOICINGS[aiVoicing] || VOICINGS.close;

    // Blend base chord with AI voicing
    padOscs.forEach((p, i) => {
        // Use voicing offsets, but transpose based on base chord root
        const chordRoot = baseChord[0] || 0;
        const voicingNote = voicing[i] || 0;
        const finalNote = chordRoot + voicingNote;
        const freq = base * Math.pow(2, finalNote / 12);
        p.o.frequency.linearRampToValueAtTime(freq, ctx.currentTime + 0.3);

        // Sparse voicing = some oscillators silent
        if (aiVoicing === 'sparse' && i > 1) {
            p.g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
        } else if (aiVoicing === 'shell' && i === 3) {
            p.g.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.2);
        } else {
            p.g.gain.linearRampToValueAtTime(0.1 / (i + 1), ctx.currentTime + 0.2);
        }
    });

    // CORE MAGIC: Stillness = pad swells, modified by AI volume
    const still = 1 - Math.min(1, field.energy * 5);
    const padVol = still * aiVolume * music.intensity;
    padG.gain.linearRampToValueAtTime(padVol, ctx.currentTime + 0.2);

    // Filter affected by voicing type
    let filtBase = 1000 + still * 1800 + field.energy * 600;
    if (aiVoicing === 'rich') filtBase *= 1.3; // Brighter for rich voicing
    if (aiVoicing === 'sparse') filtBase *= 0.7; // Darker for sparse
    if (aiVoicing === 'out') filtBase *= 1.1; // Slightly brighter for tension
    padF.frequency.linearRampToValueAtTime(filtBase, ctx.currentTime + 0.1);
}

// ============ TEXTURE ============

let textureSrc, textureG;

function initTexture() {
    const len = ctx.sampleRate * 6;
    const buf = ctx.createBuffer(2, len, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const d = buf.getChannelData(ch);
        for (let i = 0; i < len; i++) {
            const crackle = Math.random() < 0.0006 ? (Math.random() - 0.5) * 0.35 : 0;
            d[i] = crackle + (Math.random() * 2 - 1) * 0.012;
        }
    }
    textureSrc = ctx.createBufferSource();
    textureSrc.buffer = buf;
    textureSrc.loop = true;

    const f = ctx.createBiquadFilter();
    f.type = 'bandpass';
    f.frequency.value = 2800;
    f.Q.value = 0.35;

    textureG = ctx.createGain();
    textureG.gain.value = 0;

    textureSrc.connect(f).connect(textureG).connect(masterBus);
    textureSrc.start();
}

// ============ MELODY LAYERS - DISCOVERY ============

let melodies = [];

// Store last melody note for development
let lastMelodyNote = 0;
let melodyMotif = [0, 3, 5]; // Current motif being developed

function createMelody() {
    if (melodies.length >= 4) {
        const old = melodies.shift();
        old.o.stop();
    }

    const genre = dial.pulse === '0' ? 'dust' : dial.pulse;
    const chord = (CHORDS[genre] || CHORDS.dust)[music.bar % 4];

    // AI INFLUENCE: Lead behavior from bandState
    const aiActive = bandState.lead.active;
    const aiDeveloping = bandState.lead.developing;
    const aiRegister = bandState.lead.register;

    // If not active, don't create melody
    if (!aiActive && Math.random() > 0.3) return;

    let note;
    if (aiDeveloping && melodyMotif.length > 0) {
        // JAZZ DEVELOPMENT: Transform the motif
        const motifIndex = melodies.length % melodyMotif.length;
        const motifNote = melodyMotif[motifIndex];

        // Transformation options: transpose, invert, retrograde
        const transforms = [
            motifNote,                    // Original
            motifNote + 2,                // Step up
            motifNote - 2,                // Step down
            12 - motifNote,               // Invert
            lastMelodyNote + (motifNote - lastMelodyNote) // Sequence
        ];
        note = transforms[Math.floor(Math.random() * transforms.length)];

        // Sometimes introduce new motif element
        if (Math.random() < 0.2) {
            melodyMotif.push(note % 12);
            if (melodyMotif.length > 5) melodyMotif.shift();
        }
    } else {
        // Standard chord tone selection
        note = chord[Math.floor(Math.random() * chord.length)];

        // Sometimes start a new motif
        if (Math.random() < 0.15) {
            melodyMotif = [note, note + 2, note + 4].map(n => n % 12);
            logMusicalEvent('lead', 'new motif');
        }
    }

    // AI register affects octave
    let base = 220 * Math.pow(2, (1 - field.y) * 0.7);
    if (aiRegister === 'high') base *= 2;
    if (aiRegister === 'low') base *= 0.5;

    const freq = base * Math.pow(2, note / 12);
    lastMelodyNote = note;

    const o = ctx.createOscillator();
    const g = ctx.createGain();
    const f = ctx.createBiquadFilter();

    // More variety in timbre
    const timbres = ['sine', 'triangle', 'sine', 'triangle'];
    o.type = timbres[melodies.length % timbres.length];
    o.frequency.value = freq;
    f.type = 'lowpass';

    // Filter brighter when developing, softer when spacing
    f.frequency.value = aiDeveloping ? 2200 : 1400;

    // Volume louder when AI is active
    const baseVol = aiActive ? 0.06 : 0.04;
    const vol = baseVol * Math.pow(0.65, melodies.length);
    g.gain.value = vol;

    o.connect(f).connect(g).connect(padBus);
    o.start();

    // Longer notes when spacing, shorter when developing
    const len = aiDeveloping ? 1.2 + Math.random() * 1.0 : 2.0 + Math.random() * 2.0;
    melodies.push({ o, g, f, freq, vol, phase: 0, len });
}

function updateMelodies(dt) {
    for (const m of melodies) {
        m.phase += dt / m.len;
        if (m.phase >= 1) m.phase -= 1;
        const env = 0.5 + 0.5 * Math.cos(m.phase * TAU);
        m.g.gain.value = m.vol * env;
    }
}

// ORB - motion creates melody
let orb = { on: false, x: 0.5, y: 0.5 };

function updateOrb(dt) {
    if (!orb.on && field.energy > 0.035) {
        orb.on = true;
        orb.x = field.x;
        orb.y = field.y;
    }
    if (orb.on) {
        const dx = 0.5 - orb.x, dy = 0.5 - orb.y;
        const d = Math.sqrt(dx * dx + dy * dy);
        if (d > 0.025) {
            const speed = 0.4 + field.energy * 0.3;
            orb.x += (dx / d) * speed * dt;
            orb.y += (dy / d) * speed * dt;
        } else {
            createMelody();
            orb.on = false;
        }
        if (field.energy < 0.008) orb.on = false;
    }
}

// ============ HAZE ============

const HAZE = {
    clear: { filt: 20000, verb: 0.1, dly: 0.06, tex: 0 },
    fog: { filt: 3200, verb: 0.28, dly: 0.18, tex: 0.1 },
    glass: { filt: 15000, verb: 0.18, dly: 0.1, tex: 0.02 },
    heat: { filt: 7500, verb: 0.14, dly: 0.22, tex: 0.05 }
};

function updateHaze() {
    const h = HAZE[dial.haze] || HAZE.fog;
    lofiFilter.frequency.linearRampToValueAtTime(h.filt, ctx.currentTime + 0.15);
    verbWet.gain.linearRampToValueAtTime(h.verb, ctx.currentTime + 0.15);
    dlyWet.gain.linearRampToValueAtTime(h.dly, ctx.currentTime + 0.15);
    textureG.gain.linearRampToValueAtTime(h.tex, ctx.currentTime + 0.15);
}

// ============ INPUT ============

function onMove(nx, ny) {
    const dx = nx - field.x, dy = ny - field.y;
    field.x += dx * 0.2;
    field.y += dy * 0.2;
    field.energy = field.energy * 0.85 + Math.sqrt(dx * dx + dy * dy) * 2.5;
    field.peak = Math.max(field.peak * 0.98, field.energy);
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;
    const ax = (a.x || 0) / 9, ay = (a.y || 0) / 9;
    field.x = Math.max(0, Math.min(1, field.x + ax * 0.06));
    field.y = Math.max(0, Math.min(1, field.y - ay * 0.06));
    field.energy = field.energy * 0.85 + Math.sqrt(ax * ax + ay * ay) * 0.6;
    field.peak = Math.max(field.peak * 0.98, field.energy);
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 40, gy = (e.beta || 0) / 40 - 0.5;
    onMove((gx + 1) / 2, (1 - gy) / 2);
}

// ============ DIALS ============

function initDials() {
    document.querySelectorAll('.dial').forEach(d => {
        const name = d.dataset.dial;
        d.querySelectorAll('.dial-opt').forEach(opt => {
            opt.addEventListener('click', e => {
                e.stopPropagation();
                d.querySelectorAll('.dial-opt').forEach(o => o.classList.remove('on'));
                opt.classList.add('on');
                dial[name] = opt.dataset.v;
                if (name === 'pulse') { step = 0; lastStep = ctx.currentTime; pattern = null; }
                if (name === 'haze') updateHaze();
            });
            opt.addEventListener('touchend', e => e.stopPropagation());
        });
    });
}

// ============ VISUALS ============

function resize() {
    const dpr = devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;

    // Subtle magenta-tinted fade
    vc.fillStyle = `rgba(5,5,8,${0.08 + music.intensity * 0.03})`;
    vc.fillRect(0, 0, w, h);

    // Center pulse - phi proportions
    const r = 21 + music.intensity * 13;
    vc.strokeStyle = `rgba(200,180,255,${0.03 + music.intensity * 0.04})`;
    vc.lineWidth = 1;
    vc.beginPath();
    vc.arc(w / 2, h / 2, r, 0, TAU);
    vc.stroke();

    // Melody rings
    melodies.forEach((m, i) => {
        const mr = 34 + i * 21;
        const a = 0.05 + (0.5 + 0.5 * Math.cos(m.phase * TAU)) * 0.1;
        vc.strokeStyle = `rgba(180,160,220,${a})`;
        vc.beginPath();
        vc.arc(w / 2, h / 2, mr, 0, TAU);
        vc.stroke();
    });

    // Orb
    if (orb.on) {
        vc.fillStyle = 'rgba(220,200,255,0.5)';
        vc.beginPath();
        vc.arc(orb.x * w, orb.y * h, 4, 0, TAU);
        vc.fill();
    }

    // Cursor
    vc.fillStyle = `rgba(200,180,255,${0.1 + field.energy * 0.4})`;
    vc.beginPath();
    vc.arc(field.x * w, field.y * h, 3 + field.energy * 10, 0, TAU);
    vc.fill();
}

// ============ MUSIC THEORY ENGINE ============

// The harmonic foundation everything builds on
const harmony = {
    // Current key (0 = C, 2 = D, etc.)
    key: 0,
    // Current mode/scale
    mode: 'minor', // minor, major, dorian, mixolydian
    // Current chord in progression
    chordIndex: 0,
    // The actual chord being played (degrees from root)
    currentChord: [0, 3, 7, 10], // m7 default
    // Root note of current chord (semitones from key)
    chordRoot: 0,
    // Chord name for display/AI
    chordName: 'im7',
    // Where are we in the form
    formPosition: 0, // 0-31 (8 bar sections)
    // Beats since last chord change
    beatsSinceChange: 0
};

// Scale degrees for different modes
const SCALES = {
    minor: [0, 2, 3, 5, 7, 8, 10],      // Natural minor
    major: [0, 2, 4, 5, 7, 9, 11],      // Major
    dorian: [0, 2, 3, 5, 7, 9, 10],     // Dorian (minor with raised 6)
    mixolydian: [0, 2, 4, 5, 7, 9, 10], // Mixolydian (major with flat 7)
    blues: [0, 3, 5, 6, 7, 10]          // Blues scale
};

// Jazz chord progressions (degrees and qualities)
const PROGRESSIONS = {
    // ii-V-I in minor
    minor_jazz: [
        { root: 0, type: 'm7', degrees: [0, 3, 7, 10], bars: 4, tension: 0.4 },
        { root: 5, type: '7', degrees: [0, 4, 7, 10], bars: 2, tension: 0.7 },  // V7
        { root: 0, type: 'm7', degrees: [0, 3, 7, 10], bars: 2, tension: 0.3 }   // im7
    ],
    // Blues-influenced
    blues: [
        { root: 0, type: '7', degrees: [0, 4, 7, 10], bars: 4, tension: 0.5 },
        { root: 5, type: '7', degrees: [0, 4, 7, 10], bars: 2, tension: 0.6 },
        { root: 0, type: '7', degrees: [0, 4, 7, 10], bars: 2, tension: 0.4 }
    ],
    // Coltrane changes (more movement)
    changes: [
        { root: 0, type: 'maj7', degrees: [0, 4, 7, 11], bars: 2, tension: 0.4 },
        { root: 4, type: '7', degrees: [0, 4, 7, 10], bars: 2, tension: 0.6 },
        { root: 8, type: 'maj7', degrees: [0, 4, 7, 11], bars: 2, tension: 0.5 },
        { root: 0, type: 'm7', degrees: [0, 3, 7, 10], bars: 2, tension: 0.3 }
    ],
    // Modal (stays on one chord longer)
    modal: [
        { root: 0, type: 'm7', degrees: [0, 3, 7, 10], bars: 8, tension: 0.4 }
    ]
};

// Get notes that work over current chord
function getChordTones() {
    return harmony.currentChord.map(d => (harmony.key + harmony.chordRoot + d) % 12);
}

// Get scale notes in current key
function getScaleNotes() {
    const scale = SCALES[harmony.mode] || SCALES.minor;
    return scale.map(d => (harmony.key + d) % 12);
}

// Get tension notes (color tones) - 9, 11, 13
function getTensionNotes() {
    const root = harmony.key + harmony.chordRoot;
    return [(root + 2) % 12, (root + 5) % 12, (root + 9) % 12]; // 9, 11, 13
}

// Update harmony based on bar position
function updateHarmony() {
    const progName = dial.pulse === 'drive' ? 'blues' :
                     dial.pulse === 'gold' ? 'changes' : 'minor_jazz';
    const prog = PROGRESSIONS[progName];

    // Find current chord based on bar
    let barInProg = music.bar % prog.reduce((sum, c) => sum + c.bars, 0);
    let accumulated = 0;

    for (let i = 0; i < prog.length; i++) {
        if (barInProg < accumulated + prog[i].bars) {
            if (harmony.chordIndex !== i) {
                // Chord change!
                harmony.chordIndex = i;
                harmony.chordRoot = prog[i].root;
                harmony.currentChord = prog[i].degrees;
                harmony.chordName = numToNote(prog[i].root) + prog[i].type;
                harmony.beatsSinceChange = 0;
                logMusicalEvent('harmony', `-> ${harmony.chordName}`);
            }
            harmony.formPosition = barInProg;
            break;
        }
        accumulated += prog[i].bars;
    }

    harmony.beatsSinceChange++;
}

function numToNote(n) {
    return ['C', 'Db', 'D', 'Eb', 'E', 'F', 'Gb', 'G', 'Ab', 'A', 'Bb', 'B'][n % 12];
}

// ============ JAZZ ORCHESTRA - AI MINDS ============

// Shared state - what all musicians can "hear"
const bandState = {
    // What each instrument is actually playing
    drums: {
        density: 0.5,
        lastFill: 0,
        energy: 0.5,
        pattern: 'steady',
        lastHit: null,  // 'kick', 'snare', 'hat'
        groove: 'straight' // straight, swung, broken
    },
    bass: {
        register: 'mid',
        activity: 0.5,
        walking: false,
        lastNote: 0,     // Last note played (semitones)
        approach: null,  // Approaching what note
        rhythm: 'quarter' // quarter, eighth, half
    },
    pad: {
        voicing: 'close',
        volume: 0.4,
        extensions: false, // Using 9ths, 11ths, 13ths
        lastVoicing: []    // Actual notes being played
    },
    lead: {
        active: false,
        register: 'mid',
        developing: false,
        lastPhrase: [],    // Recent notes played
        motifNotes: [],    // The motif being developed
        callWaiting: false // Expecting a response
    },

    // The conversation
    tension: 0.5,
    direction: 'building',
    barsInDirection: 0,
    recentEvents: [],

    // Musical memory
    lastSoloist: null,
    tradingFours: false,
    peakReached: false
};

// Jazz conversation - when someone plays, others might respond
function logMusicalEvent(who, what, notes = null) {
    const event = { who, what, bar: music.bar, time: Date.now() };
    if (notes) event.notes = notes;
    bandState.recentEvents.push(event);
    if (bandState.recentEvents.length > 16) bandState.recentEvents.shift();
}

// Agent personalities - how they approach music
const agentPersonality = {
    drums: {
        responsive: 0.7,
        leadTendency: 0.3,
        spaceLove: 0.4,
        fillFrequency: 0.15,
        dynamicRange: 0.6
    },
    bass: {
        responsive: 0.8,
        leadTendency: 0.2,
        spaceLove: 0.3,
        chromaticism: 0.3,  // Use passing tones
        walkingTendency: 0.5
    },
    pad: {
        responsive: 0.5,
        leadTendency: 0.1,
        spaceLove: 0.7,
        voiceLeading: 0.7,  // Smooth voice leading
        extensionLove: 0.5  // Add color tones
    },
    lead: {
        responsive: 0.6,
        leadTendency: 0.8,
        spaceLove: 0.5,
        motifDevelopment: 0.6,
        outsidePlaying: 0.2  // Play "outside" the changes
    }
};

// AI decision state
let aiEnabled = false;
let aiReady = false;
let groqKey = null;
let lastAICall = 0;
let aiCooldown = 3000; // ms between AI decisions (Groq is fast)
let pendingDecisions = {};

// Groq API call
async function callGroq(prompt) {
    if (!groqKey) return null;

    try {
        const response = await fetch('https://api.groq.com/openai/v1/chat/completions', {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${groqKey}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                model: 'llama-3.1-8b-instant', // Fast and free
                messages: [{ role: 'user', content: prompt }],
                max_tokens: 10,
                temperature: 0.7
            })
        });

        if (!response.ok) {
            throw new Error(`Groq API error: ${response.status}`);
        }

        const data = await response.json();
        return data.choices?.[0]?.message?.content?.trim().toLowerCase().split(/\s/)[0] || null;
    } catch (e) {
        console.log('[GUMP] Groq error:', e.message);
        return null;
    }
}

// Initialize Groq with saved key or default
function initGroqAI() {
    // Check for user-provided key first
    groqKey = localStorage.getItem('gump_groq_key');
    if (groqKey) {
        console.log('[GUMP] Using custom Groq key');
        aiReady = true;
        aiEnabled = true;
        updateGroqStatus('connected (custom key)', true);
        return true;
    }

    // Fallback to embedded key (obfuscated)
    try {
        const _0x = [103,115,107,95,82,113,89,116,105,48,70,116,116,76,117,51,
                     113,88,54,69,97,84,88,77,87,71,100,121,98,51,70,89,90,75,
                     54,53,89,49,100,54,122,97,72,122,117,70,76,87,57,90,107,55,87,109,87];
        groqKey = String.fromCharCode.apply(null, _0x);
        console.log('[GUMP] Jazz AI ready');
        aiReady = true;
        aiEnabled = true;
        updateGroqStatus('AI active', true);
        return true;
    } catch(e) {
        return false;
    }
}

// Save Groq key
function saveGroqKey(key) {
    if (key && key.startsWith('gsk_')) {
        localStorage.setItem('gump_groq_key', key);
        groqKey = key;
        aiReady = true;
        aiEnabled = true;
        updateGroqStatus('connected - AI active!', true);
        console.log('[GUMP] Groq API key saved');
        return true;
    } else {
        updateGroqStatus('invalid key (should start with gsk_)', false);
        return false;
    }
}

function updateGroqStatus(msg, ok) {
    const el = document.getElementById('groq-status');
    if (el) {
        el.textContent = msg;
        el.className = 'status ' + (ok ? 'ok' : 'err');
    }
    // Update direction display too
    const dir = document.getElementById('st-direction');
    if (dir && aiReady) {
        // Will be updated in updateBandStatus
    }
}

// Build rich musical context for AI decision
function buildMusicalContext() {
    const recent = bandState.recentEvents.slice(-4).map(e => `${e.who}:${e.what}`).join(',');
    const chordTones = getChordTones().map(numToNote).join('');
    const scaleName = harmony.mode;

    return {
        // Harmony
        key: numToNote(harmony.key),
        chord: harmony.chordName,
        chordTones: chordTones,
        scale: scaleName,
        formPos: harmony.formPosition,
        barsOnChord: Math.floor(harmony.beatsSinceChange / 4),

        // Energy
        energy: Math.round(music.intensity * 100),
        motion: Math.round(field.energy * 100),
        tension: Math.round(bandState.tension * 100),
        direction: bandState.direction,
        barsInDir: bandState.barsInDirection,

        // What others are doing
        drums: `${bandState.drums.pattern}/${bandState.drums.groove}`,
        bassNote: numToNote(bandState.bass.lastNote),
        bassStyle: bandState.bass.walking ? 'walking' : bandState.bass.rhythm,
        padVoicing: bandState.pad.voicing + (bandState.pad.extensions ? '+ext' : ''),
        leadActive: bandState.lead.active,
        leadMotif: bandState.lead.motifNotes.slice(-3).map(numToNote).join(''),

        // Context
        recent: recent || 'start',
        bar: music.bar % 8,
        peakReached: bandState.peakReached
    };
}

// SMART FALLBACK - Jazz decisions based on music theory
function jazzBrainFallback(agent, context) {
    const energy = context.energy / 100;
    const tension = context.tension / 100;
    const building = context.direction === 'building';
    const releasing = context.direction === 'releasing';
    const bar = context.bar; // Position in 8-bar phrase
    const r = Math.random();

    switch (agent) {
        case 'drums':
            // Fills on bar 4 or 8 (phrase endings)
            if ((bar === 3 || bar === 7) && r < 0.4) return 'fill';
            // Trading fours
            if (bandState.lead.callWaiting && r < 0.3) return 'trade';
            // Energy-based
            if (energy > 0.7 && building) return r < 0.5 ? 'push' : 'accent';
            if (energy < 0.3) return r < 0.4 ? 'pullback' : 'steady';
            if (releasing && r < 0.35) return 'breakdown';
            return 'steady';

        case 'bass':
            // Root on chord changes
            if (context.barsOnChord === 0) return 'root';
            // Walking when energy up
            if (energy > 0.5 && building && r < 0.5) return 'walk';
            // Chromatic approach before chord change
            if (bar === 3 || bar === 7) return r < 0.5 ? 'chromatic' : 'fifth';
            if (tension > 0.7) return r < 0.4 ? 'climb' : 'walk';
            if (releasing) return r < 0.4 ? 'descend' : 'pedal';
            if (energy < 0.2) return 'pedal';
            return r < 0.6 ? 'root' : 'fifth';

        case 'pad':
            // Shell voicings for sparse
            if (releasing || energy < 0.3) return r < 0.5 ? 'shell' : 'rest';
            // Build tension with clusters/quartal
            if (tension > 0.7 && building) return r < 0.4 ? 'quartal' : 'cluster';
            // Normal comping
            if (building) return r < 0.5 ? 'spread' : 'drop2';
            return r < 0.6 ? 'close' : 'shell';

        case 'lead':
            // Phrase endings - breathe or answer
            if (bar === 7) return bandState.lead.callWaiting ? 'answer' : 'breathe';
            // Peak at high tension
            if (tension > 0.85 && !context.peakReached && r < 0.5) return 'peak';
            // Develop motif if we have one
            if (bandState.lead.motifNotes.length > 0 && r < 0.5) {
                return r < 0.5 ? 'develop' : 'sequence';
            }
            // Start new idea
            if (energy > 0.5 && r < 0.4) return 'call';
            if (releasing) return r < 0.5 ? 'breathe' : 'rest';
            return r < 0.4 ? 'contrast' : 'rest';
    }
    return null;
}

// THE JAZZ BRAIN - asks Groq for musical decisions (or uses fallback)
async function askJazzMind(agent, context) {
    // If AI not ready, use smart fallback
    if (!aiReady || !groqKey) {
        return jazzBrainFallback(agent, context);
    }

    // Rich, musically-informed prompts
    const prompts = {
        drums: `You're a jazz drummer. Current: ${context.chord} chord, bar ${context.bar}/8, ${context.direction} tension(${context.tension}%).
Bass is ${context.bassStyle}, lead ${context.leadActive ? 'soloing' : 'resting'}.
Energy ${context.energy}%. Recent: ${context.recent}.
What groove? Reply ONE word: steady/push/pullback/fill/breakdown/accent/trade`,

        bass: `You're a jazz bassist on ${context.chord}. Root notes: ${context.chordTones}. Scale: ${context.scale}.
Drums: ${context.drums}. Lead: ${context.leadMotif || 'resting'}. Tension ${context.tension}%, ${context.direction}.
Bar ${context.bar}/8. Last note: ${context.bassNote}. Energy ${context.energy}%.
What to play? Reply ONE word: root/fifth/walk/chromatic/pedal/climb/descend/rest`,

        pad: `You're comping on ${context.chord} (${context.chordTones}). Key of ${context.key} ${context.scale}.
Bass on ${context.bassNote}. Drums ${context.drums}. Tension ${context.tension}%.
${context.barsOnChord} bars on this chord. ${context.direction}.
Voicing? Reply ONE word: shell/close/spread/drop2/quartal/cluster/rest`,

        lead: `You're soloing over ${context.chord}. Chord tones: ${context.chordTones}. Scale: ${context.key} ${context.scale}.
Your motif: ${context.leadMotif || 'none'}. Tension ${context.tension}%, ${context.direction}.
Drums ${context.drums}, bass ${context.bassStyle}. Bar ${context.bar}/8. Peak reached: ${context.peakReached}.
What phrase? Reply ONE word: develop/sequence/contrast/peak/breathe/call/answer/rest`
    };

    try {
        const decision = await callGroq(prompts[agent]);
        if (decision) {
            console.log(`[${agent}] AI: ${decision}`);
            return decision;
        }
        return jazzBrainFallback(agent, context);
    } catch (e) {
        console.log(`[${agent}] AI error, using fallback`);
        return jazzBrainFallback(agent, context);
    }
}

// Apply drum decisions with new vocabulary
function applyDrumDecision(decision) {
    const prev = bandState.drums.pattern;
    switch (decision) {
        case 'push':
            bandState.drums.density = Math.min(1, bandState.drums.density + 0.2);
            bandState.drums.energy = Math.min(1, bandState.drums.energy + 0.15);
            bandState.drums.pattern = 'pushing';
            bandState.drums.groove = 'driving';
            if (prev !== 'pushing') logMusicalEvent('drums', 'pushing');
            break;
        case 'pullback':
            bandState.drums.density = Math.max(0.2, bandState.drums.density - 0.25);
            bandState.drums.energy = Math.max(0.2, bandState.drums.energy - 0.2);
            bandState.drums.pattern = 'sparse';
            bandState.drums.groove = 'laid-back';
            if (prev !== 'sparse') logMusicalEvent('drums', 'pulled back');
            break;
        case 'fill':
            bandState.drums.lastFill = music.bar;
            bandState.drums.pattern = 'fill';
            logMusicalEvent('drums', 'fill');
            break;
        case 'breakdown':
            bandState.drums.density = 0.15;
            bandState.drums.pattern = 'minimal';
            bandState.drums.groove = 'sparse';
            if (prev !== 'minimal') logMusicalEvent('drums', 'breakdown');
            break;
        case 'accent':
            bandState.drums.pattern = 'accenting';
            logMusicalEvent('drums', 'accent');
            break;
        case 'trade':
            bandState.drums.pattern = 'trading';
            bandState.tradingFours = true;
            logMusicalEvent('drums', 'trading');
            break;
        default: // steady
            bandState.drums.pattern = 'steady';
            bandState.drums.groove = 'straight';
            bandState.drums.density = 0.5 + music.intensity * 0.3;
    }
}

// Apply bass decisions with harmony awareness
function applyBassDecision(decision) {
    const chordTones = getChordTones();
    const root = chordTones[0];
    const fifth = (root + 7) % 12;

    switch (decision) {
        case 'root':
            bandState.bass.walking = false;
            bandState.bass.lastNote = root;
            bandState.bass.rhythm = 'quarter';
            bandState.bass.activity = 0.5;
            break;
        case 'fifth':
            bandState.bass.walking = false;
            bandState.bass.lastNote = fifth;
            bandState.bass.rhythm = 'quarter';
            bandState.bass.activity = 0.6;
            logMusicalEvent('bass', 'to fifth');
            break;
        case 'walk':
            bandState.bass.walking = true;
            bandState.bass.rhythm = 'quarter';
            bandState.bass.activity = 0.8;
            logMusicalEvent('bass', 'walking');
            break;
        case 'chromatic':
            // Chromatic approach to next chord root
            bandState.bass.walking = false;
            bandState.bass.approach = root;
            bandState.bass.lastNote = (root + 11) % 12; // Half step below
            bandState.bass.activity = 0.7;
            logMusicalEvent('bass', 'chromatic');
            break;
        case 'pedal':
            bandState.bass.walking = false;
            bandState.bass.lastNote = root;
            bandState.bass.rhythm = 'half';
            bandState.bass.activity = 0.3;
            bandState.bass.register = 'low';
            logMusicalEvent('bass', 'pedal');
            break;
        case 'climb':
            bandState.bass.register = 'high';
            bandState.bass.activity = 0.7;
            bandState.bass.lastNote = (bandState.bass.lastNote + 5) % 12;
            logMusicalEvent('bass', 'climb');
            break;
        case 'descend':
            bandState.bass.register = 'low';
            bandState.bass.activity = 0.7;
            bandState.bass.lastNote = (bandState.bass.lastNote + 7) % 12; // Down a 5th = up a 4th
            logMusicalEvent('bass', 'descend');
            break;
        case 'rest':
            bandState.bass.activity = 0.1;
            bandState.bass.rhythm = 'rest';
            logMusicalEvent('bass', 'rest');
            break;
    }
}

// Apply pad decisions with voicing awareness
function applyPadDecision(decision) {
    const prev = bandState.pad.voicing;
    bandState.pad.voicing = decision || 'close';

    switch (decision) {
        case 'shell':
            // Just 3rd and 7th
            bandState.pad.volume = 0.25;
            bandState.pad.extensions = false;
            bandState.pad.lastVoicing = [3, 10]; // 3rd and 7th
            break;
        case 'close':
            bandState.pad.volume = 0.4;
            bandState.pad.extensions = false;
            break;
        case 'spread':
            bandState.pad.volume = 0.5;
            bandState.pad.extensions = true;
            if (prev !== 'spread') logMusicalEvent('pad', 'spread');
            break;
        case 'drop2':
            // Drop 2 voicing - 2nd voice dropped an octave
            bandState.pad.volume = 0.45;
            bandState.pad.extensions = false;
            if (prev !== 'drop2') logMusicalEvent('pad', 'drop2');
            break;
        case 'quartal':
            // Voicing in 4ths - modern jazz sound
            bandState.pad.volume = 0.45;
            bandState.pad.extensions = true;
            bandState.pad.lastVoicing = [0, 5, 10, 15]; // Stacked 4ths
            if (prev !== 'quartal') logMusicalEvent('pad', 'quartal');
            break;
        case 'cluster':
            // Cluster voicing - tension
            bandState.pad.volume = 0.35;
            bandState.pad.extensions = true;
            bandState.tension = Math.min(1, bandState.tension + 0.1);
            if (prev !== 'cluster') logMusicalEvent('pad', 'cluster tension');
            break;
        case 'rest':
            bandState.pad.volume = 0;
            logMusicalEvent('pad', 'rest');
            break;
    }
}

// Apply lead decisions with phrase awareness
function applyLeadDecision(decision) {
    const chordTones = getChordTones();

    switch (decision) {
        case 'develop':
            bandState.lead.active = true;
            bandState.lead.developing = true;
            // Keep working with existing motif
            logMusicalEvent('lead', 'developing');
            break;
        case 'sequence':
            bandState.lead.active = true;
            bandState.lead.developing = true;
            // Transpose the motif
            if (bandState.lead.motifNotes.length > 0) {
                bandState.lead.motifNotes = bandState.lead.motifNotes.map(n => (n + 2) % 12);
            }
            logMusicalEvent('lead', 'sequence');
            break;
        case 'contrast':
            bandState.lead.active = true;
            bandState.lead.register = bandState.lead.register === 'high' ? 'low' : 'high';
            bandState.lead.developing = false;
            // Start fresh motif
            bandState.lead.motifNotes = [chordTones[Math.floor(Math.random() * chordTones.length)]];
            logMusicalEvent('lead', 'contrast');
            break;
        case 'peak':
            bandState.lead.active = true;
            bandState.lead.register = 'high';
            bandState.peakReached = true;
            bandState.tension = Math.min(1, bandState.tension + 0.2);
            logMusicalEvent('lead', 'PEAK!');
            break;
        case 'breathe':
            bandState.lead.active = true;
            bandState.lead.developing = false;
            // Long note, space
            logMusicalEvent('lead', 'breathe');
            break;
        case 'call':
            bandState.lead.active = true;
            bandState.lead.callWaiting = true;
            // Start a new motif
            bandState.lead.motifNotes = [
                chordTones[0],
                chordTones[Math.floor(Math.random() * chordTones.length)],
                (chordTones[0] + 2) % 12
            ];
            logMusicalEvent('lead', 'call', bandState.lead.motifNotes);
            break;
        case 'answer':
            bandState.lead.active = true;
            bandState.lead.callWaiting = false;
            // Respond to previous call
            logMusicalEvent('lead', 'answer');
            break;
        case 'rest':
        default:
            bandState.lead.active = false;
            bandState.lead.developing = false;
            bandState.lead.callWaiting = false;
    }
}

// Orchestra conductor - coordinates all minds
async function updateOrchestra() {
    // Always update harmony (runs every frame, but only changes on bar)
    updateHarmony();

    const now = Date.now();
    if (now - lastAICall < aiCooldown) return;
    if (!aiEnabled) return;

    lastAICall = now;
    const context = buildMusicalContext();

    // Update direction based on recent tension and form position
    bandState.barsInDirection++;

    // Reset peak flag at start of new 8-bar section
    if (harmony.formPosition === 0) {
        bandState.peakReached = false;
    }

    // Natural jazz arc - tension follows form
    if (bandState.barsInDirection > 6) {
        if (bandState.direction === 'building' && (bandState.tension > 0.75 || bandState.peakReached)) {
            bandState.direction = 'releasing';
            bandState.barsInDirection = 0;
            logMusicalEvent('form', 'releasing');
        } else if (bandState.direction === 'releasing' && bandState.tension < 0.3) {
            bandState.direction = 'floating';
            bandState.barsInDirection = 0;
        } else if (bandState.direction === 'floating' && bandState.barsInDirection > 4) {
            bandState.direction = 'building';
            bandState.barsInDirection = 0;
            logMusicalEvent('form', 'building');
        }
    }

    // ALL FOUR AGENTS get called in parallel for faster response
    // But we stagger which one actually makes the decision this cycle
    const agents = ['drums', 'bass', 'pad', 'lead'];
    const agentIndex = music.bar % 4;
    const agent = agents[agentIndex];

    const decision = await askJazzMind(agent, context);
    if (decision) {
        switch (agent) {
            case 'drums': applyDrumDecision(decision); break;
            case 'bass': applyBassDecision(decision); break;
            case 'pad': applyPadDecision(decision); break;
            case 'lead': applyLeadDecision(decision); break;
        }
    }

    // Tension evolves with the direction AND motion
    const motionInfluence = field.energy * 0.08;
    if (bandState.direction === 'building') {
        bandState.tension = Math.min(1, bandState.tension + 0.025 + motionInfluence);
    } else if (bandState.direction === 'releasing') {
        bandState.tension = Math.max(0.1, bandState.tension - 0.035);
    } else {
        // Floating - follows motion more directly
        bandState.tension = bandState.tension * 0.95 + (0.4 + motionInfluence) * 0.05;
    }
}

// Update visual status display
function updateBandStatus() {
    const drums = document.getElementById('st-drums');
    const bass = document.getElementById('st-bass');
    const pad = document.getElementById('st-pad');
    const lead = document.getElementById('st-lead');
    const dir = document.getElementById('st-direction');

    if (drums) {
        drums.textContent = `drums: ${bandState.drums.pattern}`;
        drums.classList.toggle('active', bandState.drums.pattern !== 'steady');
    }
    if (bass) {
        const noteStr = numToNote(bandState.bass.lastNote);
        const bassStatus = bandState.bass.walking ? `walk(${noteStr})` : noteStr;
        bass.textContent = `bass: ${bassStatus}`;
        bass.classList.toggle('active', bandState.bass.walking || bandState.bass.activity > 0.6);
    }
    if (pad) {
        pad.textContent = `pad: ${bandState.pad.voicing}`;
        pad.classList.toggle('active', bandState.pad.voicing !== 'close' && bandState.pad.voicing !== 'shell');
    }
    if (lead) {
        const leadStatus = bandState.lead.developing ? 'developing' : (bandState.lead.active ? 'playing' : 'rest');
        lead.textContent = `lead: ${leadStatus}`;
        lead.classList.toggle('active', bandState.lead.active);
    }
    if (dir) {
        const dirSymbol = { building: '/', releasing: '\\', floating: '~' }[bandState.direction] || '~';
        const aiIndicator = aiReady ? '*' : '';
        // Show chord and tension
        dir.textContent = `${harmony.chordName} ${dirSymbol}${Math.round(bandState.tension * 100)}%${aiIndicator}`;
    }
}

// Wire band state back to audio parameters
function applyBandToAudio() {
    // Update visual display
    updateBandStatus();
    // Drums - density affects ghost notes and hat probability
    if (pattern) {
        // Will be picked up on next pattern generation
    }

    // Bass - register affects frequency multiplier
    const bassRegisterMult = {
        low: 0.5,
        mid: 1,
        high: 2
    }[bandState.bass.register] || 1;

    // Bass - walking creates more movement
    if (bandState.bass.walking && Math.random() < 0.3) {
        bassSeq[music.bar % 4] = [0, 2, 3, 5, 7, -5][Math.floor(Math.random() * 6)];
    }

    // Pad - voicing affects oscillator spread
    const voicingOffsets = {
        close: [0, 3, 7, 10],
        spread: [0, 7, 12, 19],
        shell: [0, 7, 10, 0], // Root, 5th, 7th only
        rich: [0, 4, 7, 11, 14],
        sparse: [0, 7, 0, 0],
        out: [0, 6, 10, 15] // Tritone tension
    };

    // Lead - active state affects melody creation rate
    if (bandState.lead.active && !bandState.lead.developing && Math.random() < 0.15) {
        createMelody();
    } else if (bandState.lead.developing && Math.random() < 0.3) {
        createMelody();
    }

    // Global - tension affects master intensity
    music.intensity = music.intensity * 0.9 + bandState.tension * 0.1;
}

// ============ LOOP ============

function tick() {
    if (!running) return;
    const dt = 1 / 60;
    field.time += dt;
    field.energy *= 0.96;

    // Jazz Orchestra makes decisions
    updateOrchestra();
    applyBandToAudio();

    updateBeats();
    updateBass();
    updatePad();
    updateOrb(dt);
    updateMelodies(dt);

    draw();
    requestAnimationFrame(tick);
}

// ============ INIT ============

async function init() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();
    initFX();
    initBass();
    initPad();
    initTexture();
    initDials();

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    addEventListener('resize', resize);

    document.getElementById('loading').classList.remove('off');
    await loadSamples();
    document.getElementById('loading').classList.add('off');
    document.getElementById('dials').style.display = 'block';
    document.getElementById('band-status').style.display = 'block';
    document.getElementById('settings-btn').style.display = 'flex';

    updateHaze();
    initSettings();

    // Start with smart fallback, upgrade to Groq if key exists
    aiEnabled = true;
    if (initGroqAI()) {
        console.log('[GUMP] Groq AI active!');
    } else {
        console.log('[GUMP] Jazz Orchestra with smart fallback (add Groq key for AI)');
    }
}

function initSettings() {
    const btn = document.getElementById('settings-btn');
    const panel = document.getElementById('settings-panel');
    const input = document.getElementById('groq-key');

    btn.addEventListener('click', (e) => {
        e.stopPropagation();
        panel.classList.toggle('open');
    });

    // Close panel when clicking outside
    document.addEventListener('click', (e) => {
        if (!panel.contains(e.target) && e.target !== btn) {
            panel.classList.remove('open');
        }
    });

    // Load existing key
    const savedKey = localStorage.getItem('gump_groq_key');
    if (savedKey) {
        input.value = savedKey;
    }

    // Save key on input
    input.addEventListener('change', () => {
        saveGroqKey(input.value.trim());
    });
    input.addEventListener('blur', () => {
        if (input.value.trim()) {
            saveGroqKey(input.value.trim());
        }
    });
}

async function start() {
    document.getElementById('enter').classList.add('off');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch (e) {}
    }
    if (typeof DeviceOrientationEvent?.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch (e) {}
    }

    await init();

    addEventListener('devicemotion', onMotion);
    addEventListener('deviceorientation', onOrientation);
    canvas.addEventListener('mousemove', e => onMove(e.clientX / innerWidth, e.clientY / innerHeight));
    canvas.addEventListener('touchmove', e => { e.preventDefault(); onMove(e.touches[0].clientX / innerWidth, e.touches[0].clientY / innerHeight); }, { passive: false });
    canvas.addEventListener('touchstart', e => { e.preventDefault(); onMove(e.touches[0].clientX / innerWidth, e.touches[0].clientY / innerHeight); }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();

    running = true;
    tick();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
