<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>NEURAL // COMPOSER</title>
<style>
  :root {
    --bg: #050505;
    --card: #111;
    --text: #eee;
    --accent: #ff0055; /* Suno-ish Pink/Red */
    --sec: #444;
  }
  
  * { margin: 0; padding: 0; box-sizing: border-box; user-select: none; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; }
  
  body {
    background: var(--bg);
    color: var(--text);
    overflow: hidden;
    height: 100vh;
    display: flex;
    flex-direction: column;
  }

  /* TOP BAR */
  .header {
    padding: 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: 1px solid #222;
    background: #080808;
    z-index: 10;
  }
  
  .logo { font-weight: 900; letter-spacing: -1px; font-size: 20px; }
  .logo span { color: var(--accent); }
  
  .status-pill {
    font-size: 10px;
    background: #222;
    padding: 4px 10px;
    border-radius: 100px;
    color: #888;
    text-transform: uppercase;
    letter-spacing: 1px;
  }
  .status-pill.active { background: var(--accent); color: white; }

  /* MAIN VISUALIZER */
  .stage {
    flex: 1;
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
  }

  canvas {
    position: absolute;
    inset: 0;
    width: 100%;
    height: 100%;
    opacity: 0.6;
  }

  /* HALLUCINATED LYRICS */
  .lyrics-container {
    z-index: 5;
    text-align: center;
    height: 60px;
    overflow: hidden;
    display: flex;
    flex-direction: column;
    justify-content: center;
    mask-image: linear-gradient(transparent, black 20%, black 80%, transparent);
  }
  
  .lyric-line {
    font-size: 24px;
    font-weight: 700;
    color: #fff;
    opacity: 0;
    transform: translateY(20px);
    transition: all 0.5s ease;
  }
  .lyric-line.visible { opacity: 1; transform: translateY(0); }
  
  /* CONTROLS */
  .controls {
    background: #080808;
    padding: 30px;
    border-top: 1px solid #222;
    display: flex;
    flex-direction: column;
    gap: 20px;
    z-index: 10;
  }
  
  .track-info {
    display: flex;
    justify-content: space-between;
    align-items: flex-end;
    margin-bottom: 10px;
  }
  
  .song-title { font-size: 18px; font-weight: bold; margin-bottom: 4px; color: #fff; }
  .song-meta { font-size: 12px; color: #666; font-family: 'Courier New', monospace; }

  .big-btn {
    background: var(--text);
    color: var(--bg);
    border: none;
    height: 50px;
    border-radius: 8px;
    font-weight: 700;
    font-size: 16px;
    cursor: pointer;
    box-shadow: 0 4px 20px rgba(255,255,255,0.1);
    transition: transform 0.1s;
  }
  .big-btn:active { transform: scale(0.98); }
  
  .bar-loader {
    width: 100%;
    height: 4px;
    background: #222;
    border-radius: 2px;
    overflow: hidden;
    margin-top: 10px;
  }
  .bar-fill {
    height: 100%;
    width: 0%;
    background: var(--accent);
    transition: width 0.2s linear;
  }

</style>
</head>
<body>

<div class="header">
  <div class="logo">NEURAL<span>COMPOSER</span></div>
  <div class="status-pill" id="stateIndicator">IDLE</div>
</div>

<div class="stage">
  <canvas id="viz"></canvas>
  <div class="lyrics-container">
    <div class="lyric-line" id="lyricBox">...</div>
  </div>
</div>

<div class="controls">
  <div class="track-info">
    <div>
      <div class="song-title" id="songTitle">Untitled Composition</div>
      <div class="song-meta" id="songMeta">AI WAITING FOR INPUT...</div>
    </div>
    <div class="song-meta" id="timer">00:00</div>
  </div>
  
  <button class="big-btn" id="actionBtn">TAP TO SAMPLE ENVIRONMENT</button>
  <div class="bar-loader"><div class="bar-fill" id="progress"></div></div>
</div>

<script>
/* NEURAL COMPOSER ENGINE
  - Captures audio
  - Extracts "Tonal Grains" for harmony
  - Extracts "Transients" for percussion
  - Generates a Song Structure (Verse/Chorus)
*/

const AudioEngine = {
  ctx: null,
  master: null,
  reverb: null,
  
  // Data
  buffer: null,
  kickSlice: { start:0, end:0.1 },
  snareSlice: { start:0.2, end:0.3 },
  toneSlice: { start:0.5, end:0.55 }, // Short grain for synthesis
  
  // State
  isPlaying: false,
  tempo: 110,
  beat: 0,
  bar: 0,
  nextTime: 0,
  section: 'VERSE', // VERSE, CHORUS, BREAK
  
  // Theory
  rootFreq: 440,
  scale: [0, 3, 5, 7, 10], // Minor Pentatonic
  chordProgression: [0, -2, 3, 0], // Scale degrees
  
  async init() {
    this.ctx = new (window.AudioContext || window.webkitAudioContext)();
    await this.ctx.resume();
    
    // Master Chain
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.8;
    this.master.connect(this.ctx.destination);
    
    // Reverb (Simulated Space)
    this.reverb = this.ctx.createConvolver();
    this.reverb.buffer = this.createImpulse(2.0);
    this.reverb.connect(this.master);
    
    Visuals.init(this.ctx, this.master);
  },
  
  createImpulse(duration) {
    const rate = this.ctx.sampleRate;
    const len = rate * duration;
    const buffer = this.ctx.createBuffer(2, len, rate);
    for (let i = 0; i < len; i++) {
      const decay = Math.pow(1 - i/len, 3);
      buffer.getChannelData(0)[i] = (Math.random() * 2 - 1) * decay;
      buffer.getChannelData(1)[i] = (Math.random() * 2 - 1) * decay;
    }
    return buffer;
  },

  async record(duration = 2000) {
    // 1. Setup Input
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = this.ctx.createMediaStreamSource(stream);
    const recNode = this.ctx.createScriptProcessor(4096, 1, 1);
    
    const chunks = [];
    recNode.onaudioprocess = e => chunks.push(new Float32Array(e.inputBuffer.getChannelData(0)));
    
    source.connect(recNode);
    recNode.connect(this.ctx.destination);
    
    return new Promise(resolve => {
      setTimeout(() => {
        source.disconnect();
        recNode.disconnect();
        
        // Flatten
        const len = chunks.length * 4096;
        const buf = this.ctx.createBuffer(1, len, this.ctx.sampleRate);
        const data = buf.getChannelData(0);
        let offset = 0;
        chunks.forEach(c => { data.set(c, offset); offset += c.length; });
        this.buffer = buf;
        
        this.analyzeAudio(data);
        resolve();
      }, duration);
    });
  },
  
  analyzeAudio(data) {
    // Find Loudest Peak (Kick)
    let max = 0, maxIdx = 0;
    for(let i=0; i<data.length; i++) {
      if(Math.abs(data[i]) > max) { max = Math.abs(data[i]); maxIdx = i; }
    }
    
    const sec = maxIdx / this.ctx.sampleRate;
    this.kickSlice = { start: sec, end: sec + 0.2 };
    
    // Find Tonal Grain (Zero crossings? Just offset from kick)
    // We grab a random slice away from the kick for texture
    let toneIdx = (maxIdx + 20000) % data.length;
    let toneSec = toneIdx / this.ctx.sampleRate;
    this.toneSlice = { start: toneSec, end: toneSec + 0.1 }; // 100ms grain
    
    this.snareSlice = { start: (sec + 0.5) % (data.length/this.ctx.sampleRate), end: 0 };
  },

  startSequence() {
    this.isPlaying = true;
    this.beat = 0;
    this.bar = 0;
    this.nextTime = this.ctx.currentTime + 0.1;
    this.section = 'VERSE';
    this.scheduler();
    UI.setPlaying(true);
  },
  
  stop() {
    this.isPlaying = false;
    UI.setPlaying(false);
  },

  scheduler() {
    while (this.nextTime < this.ctx.currentTime + 0.1) {
      this.playStep(this.beat, this.nextTime);
      
      const secondsPerBeat = 60.0 / this.tempo;
      this.nextTime += 0.25 * secondsPerBeat; // 16th notes
      this.beat++;
      
      if (this.beat === 16) {
        this.beat = 0;
        this.bar++;
        this.updateStructure();
      }
    }
    if(this.isPlaying) requestAnimationFrame(() => this.scheduler());
  },
  
  updateStructure() {
    // Basic Song Structure: 4 bars Verse, 4 bars Chorus
    const cycle = this.bar % 8;
    if (cycle < 4) {
      this.section = 'VERSE';
      UI.updateStatus("VERSE /// ATMOSPHERIC");
    } else {
      this.section = 'CHORUS';
      UI.updateStatus("CHORUS /// FULL ENERGY");
    }
    
    // Change Chord every 2 bars
    const chordIdx = Math.floor(this.bar / 2) % this.chordProgression.length;
    // Update root note logic here if we were generating MIDI
  },

  playStep(step, time) {
    // 1. DRUMS
    const isKick = (step === 0) || (step === 10 && this.section === 'CHORUS');
    const isSnare = (step === 4 || step === 12);
    const isHat = (step % 2 === 0); // 8th notes
    
    if (isKick) this.playSample(this.kickSlice, 1.0, time, false);
    if (isSnare && this.section === 'CHORUS') this.playSample(this.kickSlice, 1.5, time, false); // Repitched kick as snare
    
    // 2. HARMONY (The "Suno" Logic)
    // We play a chord on the 1st beat of the bar, or rhythmic pulses
    // Using Granular Synthesis: We loop the 'toneSlice' very fast
    
    if (step === 0 || (this.section === 'CHORUS' && step % 4 === 0)) {
      const chordIndex = Math.floor(this.bar / 2) % this.chordProgression.length;
      const degree = this.chordProgression[chordIndex];
      
      // Build a Chord (Triad)
      const intervals = [0, 3, 7]; // Minor triad intervals
      
      intervals.forEach((interval, i) => {
        // Calculate rate for pitch shifting
        // 2^(semitones/12)
        const semi = degree + interval;
        const rate = Math.pow(2, semi / 12);
        
        // Stagger entrances slightly for realism
        this.playGrain(this.toneSlice, rate, time + (i*0.02), 0.5);
      });
      
      // Trigger Lyric Hallucination
      if (step === 0 && Math.random() > 0.5) UI.showLyric();
    }
    
    UI.updateProgress(step);
  },

  playSample(slice, rate, time, toReverb) {
    const src = this.ctx.createBufferSource();
    src.buffer = this.buffer;
    src.playbackRate.value = rate;
    
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(1, time);
    gain.gain.exponentialRampToValueAtTime(0.01, time + 0.3);
    
    src.connect(gain);
    gain.connect(this.master);
    if(toReverb) gain.connect(this.reverb);
    
    src.start(time, slice.start, 0.5); // Play longer duration
  },
  
  playGrain(slice, rate, time, dur) {
    // Granular Synth: Loops a tiny segment to create a tone
    const src = this.ctx.createBufferSource();
    src.buffer = this.buffer;
    src.playbackRate.value = rate;
    src.loop = true;
    src.loopStart = slice.start;
    src.loopEnd = slice.start + 0.05; // 50ms loop = 20hz fundamental tone roughly
    
    const gain = this.ctx.createGain();
    gain.gain.setValueAtTime(0, time);
    gain.gain.linearRampToValueAtTime(0.2, time + 0.1);
    gain.gain.linearRampToValueAtTime(0, time + dur);
    
    // Filter to remove harshness
    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 800 + (rate * 500);
    
    src.connect(filter);
    filter.connect(gain);
    gain.connect(this.master);
    gain.connect(this.reverb); // Pads always go to reverb
    
    src.start(time, slice.start);
    src.stop(time + dur);
  }
};

/* UI CONTROLLER */
const UI = {
  lyricBox: document.getElementById('lyricBox'),
  btn: document.getElementById('actionBtn'),
  title: document.getElementById('songTitle'),
  meta: document.getElementById('songMeta'),
  timer: document.getElementById('timer'),
  bar: document.getElementById('progress'),
  
  // Fake "Gen AI" Data
  lyrics: [
    "TEARING THROUGH THE STATIC",
    "DIGITAL DREAMS COLLIDE",
    "THE SIGNAL IS FADING",
    "NEON LIGHTS IN RAIN",
    "SYSTEM OVERRIDE",
    "LOST IN THE ECHO",
    "FRAGMENTS OF MEMORY"
  ],
  
  titles: ["Midnight Protocol", "Static Soul", "Data Rot", "Neural Haze", "Silicon Heart"],
  
  init() {
    this.btn.onclick = async () => {
      if (AudioEngine.isPlaying) {
        AudioEngine.stop();
        this.reset();
        return;
      }
      
      // Start Flow
      this.btn.textContent = "LISTENING...";
      this.btn.style.background = "#ff0055";
      this.btn.style.color = "white";
      
      await AudioEngine.init();
      await AudioEngine.record(2500); // 2.5s recording
      
      this.btn.textContent = "GENERATING TRACK...";
      
      setTimeout(() => {
        // "Finished" Generation
        const t = this.titles[Math.floor(Math.random()*this.titles.length)];
        this.title.textContent = t;
        this.meta.textContent = "GENRE: LO-FI / GLITCH / AMBIENT";
        this.btn.textContent = "STOP PLAYBACK";
        this.btn.style.background = "white";
        this.btn.style.color = "black";
        
        AudioEngine.startSequence();
      }, 1000);
    };
  },
  
  setPlaying(bool) {
    document.getElementById('stateIndicator').className = bool ? "status-pill active" : "status-pill";
    document.getElementById('stateIndicator').textContent = bool ? "PLAYING" : "IDLE";
  },
  
  updateStatus(text) {
    this.meta.textContent = text;
  },
  
  updateProgress(step) {
    // Visualizer of 16 steps
    const pct = ((step+1)/16) * 100;
    this.bar.style.width = pct + "%";
    
    // Update Timer
    const now = AudioEngine.ctx.currentTime.toFixed(1);
    this.timer.textContent = "00:" + (now < 10 ? "0"+now : now).substring(0,4);
  },
  
  showLyric() {
    const l = this.lyrics[Math.floor(Math.random()*this.lyrics.length)];
    this.lyricBox.textContent = l;
    this.lyricBox.classList.remove('visible');
    void this.lyricBox.offsetWidth; // Trigger reflow
    this.lyricBox.classList.add('visible');
  },
  
  reset() {
    this.btn.textContent = "TAP TO SAMPLE ENVIRONMENT";
    this.bar.style.width = "0%";
    this.lyricBox.classList.remove('visible');
    this.title.textContent = "Untitled Composition";
  }
};

/* VISUALIZER */
const Visuals = {
  ctx: null,
  analyser: null,
  data: null,
  
  init(audioCtx, source) {
    this.canvas = document.getElementById('viz');
    this.ctx = this.canvas.getContext('2d');
    this.analyser = audioCtx.createAnalyser();
    this.analyser.fftSize = 256;
    source.connect(this.analyser);
    this.data = new Uint8Array(this.analyser.frequencyBinCount);
    
    this.resize();
    window.onresize = () => this.resize();
    this.loop();
  },
  
  resize() {
    this.canvas.width = window.innerWidth;
    this.canvas.height = window.innerHeight;
  },
  
  loop() {
    requestAnimationFrame(() => this.loop());
    if(!this.analyser) return;
    
    this.analyser.getByteFrequencyData(this.data);
    const w = this.canvas.width;
    const h = this.canvas.height;
    const ctx = this.ctx;
    
    ctx.clearRect(0,0,w,h);
    
    // Draw Suno-style rolling bars
    const bars = 30;
    const step = w / bars;
    
    ctx.fillStyle = '#ff0055';
    for(let i=0; i<bars; i++) {
      const val = this.data[i * 2] / 255.0;
      const hBar = val * h * 0.8;
      
      // Draw mirrored
      ctx.globalAlpha = 0.5;
      ctx.fillRect(i*step, (h/2) - (hBar/2), step-2, hBar);
    }
  }
};

UI.init();

</script>
</body>
</html>
