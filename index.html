<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - Grand Unified Music Platform</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: radial-gradient(circle at center, #0a0a0a 0%, #000 100%);
      color: rgba(255,255,255,0.9);
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'SF Mono', 'Monaco', 'Inconsolata', 'Fira Code', monospace;
      font-weight: 300;
      letter-spacing: 0.5px;
    }
    
    .start-screen {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
      background: rgba(0,0,0,0.95);
      backdrop-filter: blur(20px);
    }
    
    .logo {
      font-size: 4rem;
      font-weight: 100;
      letter-spacing: 8px;
      margin-bottom: 1rem;
      background: linear-gradient(45deg, #fff 0%, rgba(255,255,255,0.6) 100%);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .tagline {
      font-size: 0.9rem;
      opacity: 0.7;
      margin-bottom: 3rem;
      letter-spacing: 3px;
      text-transform: uppercase;
    }
    
    .start-btn {
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.05);
      border: 1px solid rgba(255,255,255,0.2);
      color: rgba(255,255,255,0.8);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7rem;
      letter-spacing: 2px;
      backdrop-filter: blur(10px);
      transition: all 0.3s ease;
      text-transform: uppercase;
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(255,255,255,0.1);
      transform: scale(1.05);
    }
    
    .main-stage {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 1.5s ease;
    }
    
    .main-stage.active { opacity: 1; }
    
    .central-orb {
      position: absolute;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(255,255,255,0.9);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease-out;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
      z-index: 10;
    }
    
    .central-orb.pulse {
      animation: orbPulse 0.15s ease-out;
    }
    
    @keyframes orbPulse {
      0% { transform: translate(-50%, -50%) scale(1); }
      50% { transform: translate(-50%, -50%) scale(2.5); box-shadow: 0 0 40px rgba(255,255,255,0.6); }
      100% { transform: translate(-50%, -50%) scale(1); }
    }
    
    .ui-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 20;
    }
    
    .ui-corner {
      position: absolute;
      font-size: 0.65rem;
      color: rgba(255,255,255,0.6);
      font-weight: 300;
      letter-spacing: 1px;
    }
    
    .ui-corner.tl { top: 20px; left: 20px; }
    .ui-corner.tr { top: 20px; right: 20px; text-align: right; }
    .ui-corner.bl { bottom: 20px; left: 20px; }
    .ui-corner.br { bottom: 20px; right: 20px; text-align: right; }
    
    .metric { margin: 3px 0; }
    .metric-label { opacity: 0.5; }
    .metric-value { color: rgba(255,255,255,0.9); font-weight: 400; }
    
    .mood-indicator {
      width: 40px;
      height: 2px;
      background: rgba(255,255,255,0.2);
      margin: 4px 0;
      overflow: hidden;
      border-radius: 1px;
    }
    
    .mood-fill {
      height: 100%;
      background: rgba(255,255,255,0.7);
      width: 0%;
      transition: width 0.3s ease;
      border-radius: 1px;
    }
    
    .scene-title {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 0.8rem;
      color: rgba(255,255,255,0.4);
      letter-spacing: 3px;
      margin-top: 40px;
      opacity: 0;
      transition: opacity 1s ease;
      text-transform: uppercase;
    }
    
    .scene-title.show { opacity: 1; }
    
    .hidden { display: none !important; }
    
    .ripple {
      position: absolute;
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 50%;
      pointer-events: none;
      animation: rippleOut 2s ease-out forwards;
    }
    
    @keyframes rippleOut {
      from {
        width: 0;
        height: 0;
        opacity: 0.8;
      }
      to {
        width: 200px;
        height: 200px;
        opacity: 0;
      }
    }
    
    .atmosphere {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      z-index: 1;
    }
    
    .particle {
      position: absolute;
      width: 1px;
      height: 1px;
      background: rgba(255,255,255,0.3);
      border-radius: 50%;
      animation: drift 15s linear infinite;
    }
    
    @keyframes drift {
      0% { 
        transform: translateY(100vh) translateX(0) scale(0); 
        opacity: 0; 
      }
      10% { opacity: 1; transform: scale(1); }
      90% { opacity: 1; }
      100% { 
        transform: translateY(-10vh) translateX(var(--drift-x, 0)) scale(0); 
        opacity: 0; 
      }
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="logo">GUMP</div>
    <div class="tagline">Grand Unified Music Platform</div>
    <div class="start-btn" id="startBtn">Begin</div>
  </div>
  
  <div class="main-stage" id="mainStage">
    <div class="central-orb" id="centralOrb"></div>
    <div class="scene-title" id="sceneTitle">Listen to your life</div>
    <div class="atmosphere" id="atmosphere"></div>
    
    <div class="ui-overlay">
      <div class="ui-corner tl">
        <div class="metric">
          <span class="metric-label">Scene:</span> 
          <span class="metric-value" id="currentScene">Awakening</span>
        </div>
        <div class="metric">
          <span class="metric-label">Tempo:</span> 
          <span class="metric-value" id="currentTempo">72</span>
        </div>
      </div>
      
      <div class="ui-corner tr">
        <div class="metric">
          <span class="metric-label">Movement</span>
        </div>
        <div class="mood-indicator">
          <div class="mood-fill" id="movementMeter"></div>
        </div>
        <div class="metric">
          <span class="metric-label">Tension</span>
        </div>
        <div class="mood-indicator">
          <div class="mood-fill" id="tensionMeter"></div>
        </div>
      </div>
      
      <div class="ui-corner bl">
        <div class="metric">
          <span class="metric-label">Energy:</span> 
          <span class="metric-value" id="energyLevel">Low</span>
        </div>
        <div class="metric">
          <span class="metric-label">Layers:</span> 
          <span class="metric-value" id="layerCount">1</span>
        </div>
      </div>
      
      <div class="ui-corner br">
        <div class="metric">
          <span class="metric-label">Key:</span> 
          <span class="metric-value" id="currentKey">C maj</span>
        </div>
        <div class="metric">
          <span class="metric-label">Mode:</span> 
          <span class="metric-value" id="currentMode">Adaptive</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    class GUMP {
      constructor() {
        this.ctx = null;
        this.active = false;
        
        // Core Music DNA
        this.musicDNA = {
          tempo: 72,
          key: 'C',
          mode: 'major',
          tension: 0,
          energy: 0,
          narrative: 'intro'
        };
        
        // Scene System (like movie scenes)
        this.scenes = {
          'awakening': { tempo: [65, 75], tension: [0, 0.2], mood: 'contemplative' },
          'discovery': { tempo: [80, 95], tension: [0.2, 0.5], mood: 'curious' },
          'journey': { tempo: [90, 110], tension: [0.3, 0.7], mood: 'adventurous' },
          'conflict': { tempo: [100, 130], tension: [0.6, 0.9], mood: 'intense' },
          'resolution': { tempo: [70, 85], tension: [0.1, 0.4], mood: 'peaceful' },
          'transcendence': { tempo: [60, 90], tension: [0, 0.8], mood: 'ethereal' }
        };
        
        this.currentScene = 'awakening';
        this.sceneProgress = 0;
        this.sceneChangeTimer = 0;
        
        // Motion & Narrative
        this.motion = { x: 0, y: 0, intensity: 0, smoothed: 0 };
        this.position = { x: 50, y: 50 };
        this.motionHistory = [];
        this.gesturePattern = [];
        
        // Adaptive Music Engine
        this.instruments = {};
        this.activeNotes = new Set();
        this.harmonicMemory = [];
        this.rhythmicMemory = [];
        
        // Narrative Arc
        this.storyArc = {
          phase: 'exposition', // exposition, rising, climax, falling, resolution
          intensity: 0,
          character: 'explorer', // explorer, hero, sage, rebel
          journey: []
        };
        
        this.init();
      }

      init() {
        // Get elements
        this.elements = {
          startScreen: document.getElementById('startScreen'),
          startBtn: document.getElementById('startBtn'),
          mainStage: document.getElementById('mainStage'),
          centralOrb: document.getElementById('centralOrb'),
          sceneTitle: document.getElementById('sceneTitle'),
          currentScene: document.getElementById('currentScene'),
          currentTempo: document.getElementById('currentTempo'),
          movementMeter: document.getElementById('movementMeter'),
          tensionMeter: document.getElementById('tensionMeter'),
          energyLevel: document.getElementById('energyLevel'),
          layerCount: document.getElementById('layerCount'),
          currentKey: document.getElementById('currentKey'),
          currentMode: document.getElementById('currentMode'),
          atmosphere: document.getElementById('atmosphere')
        };
        
        this.elements.startBtn.onclick = () => this.begin();
        this.setupMotionTracking();
      }

      async begin() {
        try {
          // Request permissions
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const permission = await DeviceMotionEvent.requestPermission();
            if (permission !== 'granted') {
              alert('Motion sensing required for GUMP to sync with your life');
              return;
            }
          }

          // Initialize audio context
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.setupAudioArchitecture();

          // Transition to main stage
          this.elements.startScreen.classList.add('hidden');
          this.elements.mainStage.classList.add('active');
          
          // Show initial scene hint
          setTimeout(() => {
            this.elements.sceneTitle.classList.add('show');
            setTimeout(() => this.elements.sceneTitle.classList.remove('show'), 3000);
          }, 1000);

          this.active = true;
          this.startMusicEngine();
          this.startNarrativeEngine();
          this.animate();
          
        } catch (e) {
          console.error('GUMP initialization failed:', e);
        }
      }

      setupAudioArchitecture() {
        // Master chain with spatial processing
        this.master = this.ctx.createGain();
        this.master.gain.value = 0.6;
        
        // Create reverb impulse (cathedral-like)
        this.reverb = this.ctx.createConvolver();
        const length = this.ctx.sampleRate * 3;
        const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
        
        for (let c = 0; c < 2; c++) {
          const channel = impulse.getChannelData(c);
          for (let i = 0; i < length; i++) {
            const decay = Math.pow(1 - i / length, 2);
            channel[i] = (Math.random() * 2 - 1) * decay * 0.4;
          }
        }
        this.reverb.buffer = impulse;
        
        // Delay for movement echo
        this.delay = this.ctx.createDelay(1);
        this.delay.delayTime.value = 0.25;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.25;
        
        this.delay.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        
        // Instrument buses
        this.instruments = {
          foundation: this.ctx.createGain(), // Bass, drums
          harmony: this.ctx.createGain(),    // Chords, pads
          melody: this.ctx.createGain(),     // Lead lines
          texture: this.ctx.createGain(),    // Atmosphere
          impulse: this.ctx.createGain()     // Percussive elements
        };
        
        // Connect everything
        Object.values(this.instruments).forEach(bus => {
          bus.connect(this.reverb);
          bus.connect(this.delay);
          bus.connect(this.master);
        });
        
        this.reverb.connect(this.master);
        this.delay.connect(this.master);
        this.master.connect(this.ctx.destination);
      }

      setupMotionTracking() {
        let lastMotion = { x: 0, y: 0, time: Date.now() };
        
        // Device motion for real devices
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;

          const intensity = Math.sqrt(acc.x*acc.x + acc.y*acc.y + acc.z*acc.z) / 10;
          this.updateMotion(acc.x, acc.y, intensity);
        });

        // Mouse tracking for desktop
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          
          const now = Date.now();
          const dt = Math.max(16, now - lastMotion.time);
          
          const x = (e.clientX / window.innerWidth - 0.5) * 2;
          const y = (e.clientY / window.innerHeight - 0.5) * 2;
          
          const vx = (x - lastMotion.x) / dt * 1000;
          const vy = (y - lastMotion.y) / dt * 1000;
          const intensity = Math.sqrt(vx*vx + vy*vy) * 0.1;
          
          this.updateMotion(vx, vy, intensity);
          this.position.x = e.clientX / window.innerWidth * 100;
          this.position.y = e.clientY / window.innerHeight * 100;
          
          lastMotion = { x, y, time: now };
        });
      }

      updateMotion(x, y, intensity) {
        // Smooth motion data
        this.motion.x = this.motion.x * 0.7 + x * 0.3;
        this.motion.y = this.motion.y * 0.7 + y * 0.3;
        this.motion.intensity = this.motion.intensity * 0.8 + intensity * 0.2;
        this.motion.smoothed = this.motion.smoothed * 0.9 + this.motion.intensity * 0.1;
        
        // Track motion patterns for gesture recognition
        this.motionHistory.push({
          x: this.motion.x,
          y: this.motion.y,
          intensity: this.motion.intensity,
          time: Date.now()
        });
        
        if (this.motionHistory.length > 100) this.motionHistory.shift();
        
        // Analyze gesture patterns
        this.analyzeGesture();
        
        // Update musical DNA based on motion
        this.adaptMusic();
      }

      analyzeGesture() {
        if (this.motionHistory.length < 20) return;
        
        const recent = this.motionHistory.slice(-20);
        const avgIntensity = recent.reduce((sum, m) => sum + m.intensity, 0) / recent.length;
        const variance = recent.reduce((sum, m) => sum + Math.pow(m.intensity - avgIntensity, 2), 0) / recent.length;
        
        // Detect gesture types
        let gestureType = 'still';
        
        if (avgIntensity > 3) gestureType = 'energetic';
        else if (avgIntensity > 1.5) gestureType = 'flowing';
        else if (variance > 0.5) gestureType = 'erratic';
        
        // Track pattern for scene evolution
        this.gesturePattern.push(gestureType);
        if (this.gesturePattern.length > 50) this.gesturePattern.shift();
      }

      adaptMusic() {
        const intensity = this.motion.smoothed;
        
        // Adapt tempo based on movement
        const scene = this.scenes[this.currentScene];
        const targetTempo = scene.tempo[0] + (scene.tempo[1] - scene.tempo[0]) * Math.min(intensity / 5, 1);
        this.musicDNA.tempo = this.musicDNA.tempo * 0.95 + targetTempo * 0.05;
        
        // Adapt tension
        const targetTension = scene.tension[0] + (scene.tension[1] - scene.tension[0]) * Math.min(intensity / 3, 1);
        this.musicDNA.tension = this.musicDNA.tension * 0.9 + targetTension * 0.1;
        
        // Adapt energy
        this.musicDNA.energy = Math.min(intensity / 4, 1);
        
        // Evolve scene based on accumulated motion patterns
        this.evolveScene();
      }

      evolveScene() {
        this.sceneProgress += this.motion.intensity * 0.01;
        this.sceneChangeTimer += 16; // Rough 60fps
        
        // Scene transitions based on motion patterns and time
        const patternEnergy = this.gesturePattern.slice(-10).filter(g => g === 'energetic').length;
        const patternFlow = this.gesturePattern.slice(-10).filter(g => g === 'flowing').length;
        const patternErratic = this.gesturePattern.slice(-10).filter(g => g === 'erratic').length;
        
        let nextScene = this.currentScene;
        
        // Scene evolution logic (creating a cinematic flow)
        if (this.currentScene === 'awakening' && (patternFlow > 3 || this.sceneChangeTimer > 30000)) {
          nextScene = 'discovery';
        } else if (this.currentScene === 'discovery' && (patternEnergy > 4 || this.sceneProgress > 50)) {
          nextScene = 'journey';
        } else if (this.currentScene === 'journey' && patternErratic > 3) {
          nextScene = 'conflict';
        } else if (this.currentScene === 'conflict' && this.motion.smoothed < 1) {
          nextScene = 'resolution';
        } else if (this.currentScene === 'resolution' && patternFlow > 5) {
          nextScene = 'transcendence';
        } else if (this.currentScene === 'transcendence' && this.sceneChangeTimer > 60000) {
          nextScene = 'awakening'; // Cycle back for continuous narrative
        }
        
        if (nextScene !== this.currentScene) {
          this.transitionToScene(nextScene);
        }
      }

      transitionToScene(newScene) {
        console.log(`🎬 Scene transition: ${this.currentScene} → ${newScene}`);
        this.currentScene = newScene;
        this.sceneProgress = 0;
        this.sceneChangeTimer = 0;
        
        // Create visual ripple effect
        this.createRipple();
        
        // Trigger musical transition
        this.triggerMusicalTransition();
        
        // Update story arc
        this.updateStoryArc();
      }

      createRipple() {
        const ripple = document.createElement('div');
        ripple.className = 'ripple';
        ripple.style.left = this.position.x + '%';
        ripple.style.top = this.position.y + '%';
        ripple.style.marginLeft = '-100px';
        ripple.style.marginTop = '-100px';
        
        document.body.appendChild(ripple);
        setTimeout(() => ripple.remove(), 2000);
      }

      startMusicEngine() {
        const beatLength = 60000 / this.musicDNA.tempo / 4; // 16th notes
        let beat = 0;
        
        const tick = () => {
          if (!this.active) return;
          
          this.playBeat(beat);
          beat = (beat + 1) % 64; // 4 bars
          
          // Pulse orb on downbeats
          if (beat % 16 === 0) {
            this.elements.centralOrb.classList.add('pulse');
            setTimeout(() => this.elements.centralOrb.classList.remove('pulse'), 150);
          }
          
          const nextBeatLength = 60000 / this.musicDNA.tempo / 4;
          setTimeout(tick, nextBeatLength);
        };
        
        tick();
      }

      playBeat(beat) {
        const scene = this.scenes[this.currentScene];
        const intensity = this.motion.smoothed;
        
        // Foundation layer (always present but evolving)
        if (beat % 16 === 0) this.playFoundation();
        if (beat % 8 === 4 && intensity > 1) this.playSubBeat();
        
        // Harmonic layer (responds to position and scene)
        if (beat % 32 === 0) this.playHarmony();
        if (beat % 16 === 8 && this.musicDNA.tension > 0.3) this.playTension();
        
        // Melodic layer (responds to motion patterns)
        if (beat % 4 === 2 && intensity > 2) this.playMelody(beat);
        
        // Textural layer (atmospheric, responds to scene mood)
        if (beat % 64 === 0) this.playTexture();
        if (Math.random() < intensity * 0.1) this.playImpulse();
      }

      playFoundation() {
        // Kick drum
        const kick = this.ctx.createOscillator();
        const kickGain = this.ctx.createGain();
        const kickFilter = this.ctx.createBiquadFilter();
        
        kick.type = 'sine';
        kick.frequency.setValueAtTime(50, this.ctx.currentTime);
        kick.frequency.exponentialRampToValueAtTime(30, this.ctx.currentTime + 0.3);
        
        kickFilter.type = 'lowpass';
        kickFilter.frequency.value = 100;
        
        kickGain.gain.setValueAtTime(0.7, this.ctx.currentTime);
        kickGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.4);
        
        kick.connect(kickFilter).connect(kickGain).connect(this.instruments.foundation);
        kick.start();
        kick.stop(this.ctx.currentTime + 0.4);
      }

      playSubBeat() {
        // Sub bass following root progression
        const freq = this.getFrequency(0, 1); // Root note, low octave
        
        const sub = this.ctx.createOscillator();
        const subGain = this.ctx.createGain();
        
        sub.type = 'sine';
        sub.frequency.value = freq;
        
        subGain.gain.setValueAtTime(0.4, this.ctx.currentTime);
        subGain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.5);
        
        sub.connect(subGain).connect(this.instruments.foundation);
        sub.start();
        sub.stop(this.ctx.currentTime + 0.5);
      }

      playHarmony() {
        // Evolving chords based on position and scene
        const chord = this.generateChord();
        
        chord.forEach((note, i) => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sawtooth';
          osc.frequency.value = this.getFrequency(note, 3 + i * 0.01); // Slight detuning
          
          filter.type = 'lowpass';
          filter.frequency.value = 800 + this.musicDNA.tension * 1200;
          filter.Q.value = 1 + this.musicDNA.tension * 3;
          
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.5);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 4);
          
          osc.connect(filter).connect(gain).connect(this.instruments.harmony);
          osc.start();
          osc.stop(this.ctx.currentTime + 4);
          
          this.activeNotes.add(osc);
          setTimeout(() => this.activeNotes.delete(osc), 4000);
        });
      }

      playMelody(beat) {
        // Generate melody based on movement and narrative
        const scale = this.getCurrentScale();
        const noteIndex = this.motion.x * scale.length + beat * 0.25;
        const note = scale[Math.floor(Math.abs(noteIndex)) % scale.length];
        const freq = this.getFrequency(note, 4 + this.motion.y * 0.5);
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = this.musicDNA.tension > 0.5 ? 'square' : 'triangle';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = 400 + this.motion.intensity * 800;
        filter.Q.value = 2 + this.musicDNA.tension * 8;
        
        gain.gain.setValueAtTime(0.2, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.6);
        
        osc.connect(filter).connect(gain).connect(this.instruments.melody);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.6);
      }

      playTexture() {
        // Atmospheric layer that reflects current scene mood
        const scene = this.scenes[this.currentScene];
        const fundamentalFreq = this.getFrequency(0, 5);
        
        // Create harmonic series for richness
        for (let harmonic = 1; harmonic <= 5; harmonic++) {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          const filter = this.ctx.createBiquadFilter();
          
          osc.type = 'sine';
          osc.frequency.value = fundamentalFreq * harmonic * (1 + Math.random() * 0.01);
          
          filter.type = 'lowpass';
          filter.frequency.value = 300 + this.musicDNA.tension * 700;
          filter.Q.value = 0.5;
          
          const amplitude = 0.08 / harmonic;
          gain.gain.setValueAtTime(0, this.ctx.currentTime);
          gain.gain.linearRampToValueAtTime(amplitude, this.ctx.currentTime + 2);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 8);
          
          osc.connect(filter).connect(gain).connect(this.instruments.texture);
          osc.start();
          osc.stop(this.ctx.currentTime + 8);
        }
      }

      playImpulse() {
        // Random textural hits based on motion
        const freq = 200 + Math.random() * 2000;
        
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = Math.random() > 0.5 ? 'square' : 'triangle';
        osc.frequency.value = freq;
        
        filter.type = 'bandpass';
        filter.frequency.value = freq;
        filter.Q.value = 10;
        
        gain.gain.setValueAtTime(0.1, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 0.1);
        
        osc.connect(filter).connect(gain).connect(this.instruments.impulse);
        osc.start();
        osc.stop(this.ctx.currentTime + 0.1);
      }

      playTension() {
        // Dissonant elements for dramatic tension
        const dissonantInterval = 6; // Tritone
        const freq1 = this.getFrequency(0, 3);
        const freq2 = this.getFrequency(dissonantInterval, 3);
        
        [freq1, freq2].forEach(freq => {
          const osc = this.ctx.createOscillator();
          const gain = this.ctx.createGain();
          
          osc.type = 'sawtooth';
          osc.frequency.value = freq;
          
          gain.gain.setValueAtTime(0.05, this.ctx.currentTime);
          gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
          
          osc.connect(gain).connect(this.instruments.harmony);
          osc.start();
          osc.stop(this.ctx.currentTime + 2);
        });
      }

      generateChord() {
        // Generate chords based on current scene and position
        const baseChord = [0, 4, 7]; // Major triad
        const scene = this.scenes[this.currentScene];
        
        // Modify chord based on scene mood and position
        let chord = [...baseChord];
        
        if (scene.mood === 'intense') {
          chord = [0, 3, 6]; // Diminished for tension
        } else if (scene.mood === 'ethereal') {
          chord = [0, 4, 7, 11]; // Major 7th
        } else if (scene.mood === 'adventurous') {
          chord = [0, 4, 7, 10]; // Dominant 7th
        }
        
        // Add complexity based on position
        if (this.position.y < 30) {
          chord.push(chord[chord.length - 1] + 7); // Add octave
        }
        
        return chord;
      }

      getCurrentScale() {
        // Return scale based on current scene and tension
        const major = [0, 2, 4, 5, 7, 9, 11];
        const minor = [0, 2, 3, 5, 7, 8, 10];
        const dorian = [0, 2, 3, 5, 7, 9, 10];
        const pentatonic = [0, 2, 4, 7, 9];
        
        if (this.musicDNA.tension > 0.7) return minor;
        if (this.currentScene === 'transcendence') return dorian;
        if (this.currentScene === 'awakening') return pentatonic;
        
        return major;
      }

      getFrequency(note, octave = 4) {
        // Convert note to frequency with current key
        return 440 * Math.pow(2, (note - 9) / 12 + (octave - 4));
      }

      triggerMusicalTransition() {
        // Create smooth transitions between scenes
        Object.values(this.instruments).forEach(bus => {
          bus.gain.setValueAtTime(bus.gain.value, this.ctx.currentTime);
          bus.gain.linearRampToValueAtTime(0.1, this.ctx.currentTime + 0.5);
          bus.gain.linearRampToValueAtTime(1, this.ctx.currentTime + 2);
        });
        
        // Special transition sound
        this.playTransitionSound();
      }

      playTransitionSound() {
        // Cinematic transition sound
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        const filter = this.ctx.createBiquadFilter();
        
        osc.type = 'sine';
        osc.frequency.setValueAtTime(100, this.ctx.currentTime);
        osc.frequency.exponentialRampToValueAtTime(800, this.ctx.currentTime + 1);
        osc.frequency.exponentialRampToValueAtTime(200, this.ctx.currentTime + 2);
        
        filter.type = 'lowpass';
        filter.frequency.setValueAtTime(200, this.ctx.currentTime);
        filter.frequency.exponentialRampToValueAtTime(2000, this.ctx.currentTime + 1);
        filter.Q.value = 5;
        
        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, this.ctx.currentTime + 2);
        
        osc.connect(filter).connect(gain).connect(this.instruments.texture);
        osc.start();
        osc.stop(this.ctx.currentTime + 2);
      }

      updateStoryArc() {
        // Update narrative based on scene progression
        const sceneToPhase = {
          'awakening': 'exposition',
          'discovery': 'rising',
          'journey': 'rising',
          'conflict': 'climax',
          'resolution': 'falling',
          'transcendence': 'resolution'
        };
        
        this.storyArc.phase = sceneToPhase[this.currentScene];
        this.storyArc.intensity = this.musicDNA.tension;
        
        // Log the journey for potential future AI learning
        this.storyArc.journey.push({
          scene: this.currentScene,
          time: Date.now(),
          motion: this.motion.smoothed,
          tension: this.musicDNA.tension,
          position: { ...this.position }
        });
        
        if (this.storyArc.journey.length > 100) {
          this.storyArc.journey.shift();
        }
      }

      startNarrativeEngine() {
        // Create floating particles for atmosphere
        setInterval(() => {
          if (!this.active) return;
          this.createAtmosphericParticle();
        }, 2000);
      }

      createAtmosphericParticle() {
        const particle = document.createElement('div');
        particle.className = 'particle';
        
        particle.style.left = Math.random() * 100 + '%';
        particle.style.setProperty('--drift-x', (Math.random() - 0.5) * 100 + 'px');
        particle.style.animationDuration = (10 + Math.random() * 10) + 's';
        particle.style.animationDelay = Math.random() * 2 + 's';
        
        // Color based on current scene
        const sceneColors = {
          'awakening': 'rgba(255,255,255,0.2)',
          'discovery': 'rgba(255,255,255,0.3)',
          'journey': 'rgba(255,255,255,0.4)',
          'conflict': 'rgba(255,200,200,0.3)',
          'resolution': 'rgba(200,255,200,0.3)',
          'transcendence': 'rgba(200,200,255,0.4)'
        };
        
        particle.style.background = sceneColors[this.currentScene] || 'rgba(255,255,255,0.2)';
        
        this.elements.atmosphere.appendChild(particle);
        
        setTimeout(() => {
          if (particle.parentNode) particle.remove();
        }, 15000);
      }

      updateUI() {
        // Update all UI elements with current state
        this.elements.currentScene.textContent = this.currentScene.charAt(0).toUpperCase() + this.currentScene.slice(1);
        this.elements.currentTempo.textContent = Math.round(this.musicDNA.tempo);
        
        // Movement meter
        const movementPercent = Math.min(this.motion.smoothed * 20, 100);
        this.elements.movementMeter.style.width = movementPercent + '%';
        
        // Tension meter
        const tensionPercent = this.musicDNA.tension * 100;
        this.elements.tensionMeter.style.width = tensionPercent + '%';
        
        // Energy level
        const energyLevels = ['Minimal', 'Low', 'Moderate', 'High', 'Intense'];
        const energyIndex = Math.floor(this.musicDNA.energy * energyLevels.length);
        this.elements.energyLevel.textContent = energyLevels[Math.min(energyIndex, energyLevels.length - 1)];
        
        // Layer count
        const activeLayers = Math.min(Math.floor(this.motion.smoothed * 2) + 1, 8);
        this.elements.layerCount.textContent = activeLayers;
        
        // Current key and mode
        this.elements.currentKey.textContent = this.musicDNA.key + ' ' + this.musicDNA.mode.slice(0, 3);
        this.elements.currentMode.textContent = 'Adaptive';
      }

      animate() {
        const loop = () => {
          if (!this.active) return;
          
          // Update orb position
          this.elements.centralOrb.style.left = this.position.x + '%';
          this.elements.centralOrb.style.top = this.position.y + '%';
          
          // Scale orb based on intensity
          const scale = 1 + this.motion.intensity * 0.5;
          this.elements.centralOrb.style.transform = `translate(-50%, -50%) scale(${scale})`;
          
          // Update background based on scene and motion
          this.updateBackground();
          
          // Update UI periodically
          if (Date.now() % 100 < 16) { // Roughly every 100ms
            this.updateUI();
          }
          
          requestAnimationFrame(loop);
        };
        requestAnimationFrame(loop);
      }

      updateBackground() {
        const intensity = Math.min(this.motion.smoothed / 5, 1);
        const x = this.position.x;
        const y = this.position.y;
        
        // Subtle gradient that follows movement
        const gradient = `radial-gradient(circle at ${x}% ${y}%, 
          rgba(255,255,255,${0.02 + intensity * 0.05}) 0%, 
          rgba(255,255,255,${0.01 + intensity * 0.02}) 30%,
          #000 70%)`;
        
        document.body.style.background = gradient;
      }
    }

    // Initialize GUMP
    const gump = new GUMP();
    
    // Global GUMP interface for potential future expansion
    window.GUMP = {
      instance: gump,
      getStoryArc: () => gump.storyArc,
      getCurrentScene: () => gump.currentScene,
      getMusicDNA: () => gump.musicDNA
    };
  </script>
</body>
</html>
