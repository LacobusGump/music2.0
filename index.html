<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP - Quantum DJ Mind</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            background: #000;
            color: #fff;
            font-family: -apple-system, BlinkMacSystemFont, "Inter", sans-serif;
            height: 100vh;
            overflow: hidden;
            cursor: none;
        }

        /* Quantum Brain Core */
        #quantum-brain {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 400px;
            height: 400px;
            pointer-events: none;
        }

        .neural-layer {
            position: absolute;
            width: 100%;
            height: 100%;
            border-radius: 50%;
        }

        .synaptic-ring {
            position: absolute;
            border: 1px solid rgba(138, 43, 226, 0.2);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(138, 43, 226, 0.1);
        }

        .synaptic-ring:nth-child(1) {
            width: 100%;
            height: 100%;
            animation: quantumRotate 20s linear infinite;
        }

        .synaptic-ring:nth-child(2) {
            width: 75%;
            height: 75%;
            top: 12.5%;
            left: 12.5%;
            animation: quantumRotate 15s linear infinite reverse;
        }

        .synaptic-ring:nth-child(3) {
            width: 50%;
            height: 50%;
            top: 25%;
            left: 25%;
            animation: quantumRotate 10s linear infinite;
        }

        .synaptic-ring.processing {
            border-color: rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.6),
                        inset 0 0 40px rgba(255, 0, 255, 0.3);
            animation-duration: 2s !important;
        }

        @keyframes quantumRotate {
            from { transform: rotate(0deg) scale(1); }
            50% { transform: rotate(180deg) scale(1.1); }
            to { transform: rotate(360deg) scale(1); }
        }

        /* Neural Pathways */
        .neural-pathway {
            position: absolute;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        .synapse {
            position: absolute;
            width: 4px;
            height: 4px;
            background: radial-gradient(circle, rgba(0, 255, 255, 1), transparent);
            border-radius: 50%;
            opacity: 0;
            animation: synapsefire 2s infinite;
        }

        @keyframes synapsefire {
            0%, 100% { opacity: 0; transform: scale(0.5); }
            50% { opacity: 1; transform: scale(1.5); }
        }

        /* Start Screen */
        .initialization {
            position: fixed;
            inset: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            background: radial-gradient(circle at center, rgba(138, 43, 226, 0.1), #000);
            z-index: 1000;
        }

        .quantum-init-btn {
            padding: 30px 60px;
            background: transparent;
            border: 1px solid rgba(0, 255, 255, 0.3);
            color: #0ff;
            font-size: 12px;
            letter-spacing: 6px;
            cursor: pointer;
            transition: all 0.5s;
            position: relative;
            overflow: hidden;
        }

        .quantum-init-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(0, 255, 255, 0.4), transparent);
            transition: all 0.5s;
            transform: translate(-50%, -50%);
        }

        .quantum-init-btn:hover {
            border-color: rgba(0, 255, 255, 0.8);
            text-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            box-shadow: 0 0 50px rgba(0, 255, 255, 0.4),
                        inset 0 0 50px rgba(0, 255, 255, 0.1);
        }

        .quantum-init-btn:hover::before {
            width: 300px;
            height: 300px;
        }

        /* Performance HUD */
        .performance-hud {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            text-align: center;
            font-family: 'Courier New', monospace;
            z-index: 100;
        }

        .dj-state {
            font-size: 10px;
            letter-spacing: 4px;
            color: rgba(255, 255, 255, 0.5);
            margin-bottom: 10px;
        }

        .performance-mode {
            font-size: 24px;
            font-weight: 100;
            background: linear-gradient(90deg, #0ff, #f0f, #0ff);
            background-size: 200% 100%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s linear infinite;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        /* Quantum Cursor */
        .quantum-cursor {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 1px solid rgba(0, 255, 255, 0.5);
            border-radius: 50%;
            pointer-events: none;
            mix-blend-mode: screen;
            transition: all 0.1s;
        }

        .quantum-cursor::after {
            content: '';
            position: absolute;
            top: -10px;
            left: -10px;
            width: 50px;
            height: 50px;
            border: 1px solid rgba(255, 0, 255, 0.3);
            border-radius: 50%;
            animation: cursorPulse 2s infinite;
        }

        @keyframes cursorPulse {
            0%, 100% { transform: scale(1); opacity: 0.5; }
            50% { transform: scale(1.5); opacity: 0; }
        }

        .quantum-cursor.capturing {
            background: radial-gradient(circle, rgba(0, 255, 255, 0.8), transparent);
            box-shadow: 0 0 40px rgba(0, 255, 255, 0.8);
        }

        /* Spectral Matrix */
        .spectral-matrix {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            width: 90%;
            max-width: 1200px;
        }

        .track-lanes {
            display: grid;
            grid-template-rows: repeat(4, 60px);
            gap: 10px;
            margin-bottom: 20px;
        }

        .track-lane {
            background: linear-gradient(90deg, 
                rgba(138, 43, 226, 0.05) 0%,
                rgba(0, 255, 255, 0.05) 50%,
                rgba(138, 43, 226, 0.05) 100%);
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        .track-label {
            position: absolute;
            left: 10px;
            top: 5px;
            font-size: 10px;
            letter-spacing: 2px;
            color: rgba(255, 255, 255, 0.4);
        }

        .track-waveform {
            position: absolute;
            width: 100%;
            height: 100%;
            opacity: 0.8;
        }

        .sample-block {
            position: absolute;
            height: 80%;
            top: 10%;
            background: linear-gradient(90deg, 
                transparent,
                rgba(0, 255, 255, 0.4),
                transparent);
            border-left: 2px solid rgba(0, 255, 255, 0.8);
            border-right: 2px solid rgba(0, 255, 255, 0.8);
            transition: all 0.3s;
        }

        .sample-block.playing {
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.8);
            background: linear-gradient(90deg, 
                transparent,
                rgba(0, 255, 255, 0.8),
                transparent);
        }

        /* Energy Meters */
        .energy-system {
            position: fixed;
            right: 30px;
            top: 50%;
            transform: translateY(-50%);
            display: none;
        }

        .energy-meter {
            width: 60px;
            height: 300px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            position: relative;
            overflow: hidden;
            margin-bottom: 20px;
        }

        .energy-label {
            position: absolute;
            top: -20px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 10px;
            letter-spacing: 1px;
            color: rgba(255, 255, 255, 0.5);
        }

        .energy-fill {
            position: absolute;
            bottom: 0;
            width: 100%;
            transition: height 0.3s ease-out;
        }

        #tension-fill {
            background: linear-gradient(to top, 
                #ff0000, 
                #ff00ff, 
                #00ffff);
        }

        #harmonic-fill {
            background: linear-gradient(to top, 
                #00ff00, 
                #00ffff, 
                #ffffff);
        }

        #crowd-fill {
            background: linear-gradient(to top, 
                #ff8800, 
                #ffff00, 
                #ffffff);
        }

        /* Quantum Parameters */
        .quantum-params {
            position: fixed;
            left: 30px;
            top: 50%;
            transform: translateY(-50%);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            display: none;
        }

        .param-group {
            margin-bottom: 30px;
        }

        .param-title {
            color: rgba(0, 255, 255, 0.8);
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .param-line {
            display: flex;
            justify-content: space-between;
            width: 200px;
            margin: 5px 0;
            color: rgba(255, 255, 255, 0.5);
        }

        .param-value {
            color: rgba(255, 0, 255, 0.9);
            font-weight: bold;
        }

        /* Processing Indicator */
        .quantum-process {
            position: fixed;
            background: rgba(0, 0, 0, 0.9);
            border: 1px solid rgba(0, 255, 255, 0.5);
            padding: 10px 20px;
            font-size: 10px;
            letter-spacing: 3px;
            opacity: 0;
            transition: opacity 0.3s;
            pointer-events: none;
            z-index: 200;
        }

        .quantum-process.active {
            opacity: 1;
            animation: processPulse 0.5s infinite;
        }

        @keyframes processPulse {
            0%, 100% { border-color: rgba(0, 255, 255, 0.5); }
            50% { border-color: rgba(0, 255, 255, 1); 
                  box-shadow: 0 0 20px rgba(0, 255, 255, 0.8); }
        }

        /* Canvas Layers */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        #spectrum-canvas { z-index: 1; }
        #waveform-canvas { z-index: 2; opacity: 0.6; }
        #particle-canvas { z-index: 3; }
        #fractal-canvas { z-index: 4; opacity: 0.3; }

        /* BPM Display */
        .bpm-display {
            position: fixed;
            bottom: 20px;
            right: 30px;
            font-family: 'Courier New', monospace;
            font-size: 48px;
            font-weight: 100;
            color: rgba(0, 255, 255, 0.8);
            display: none;
        }

        .bpm-label {
            font-size: 10px;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.4);
        }

        /* FX Rack */
        .fx-rack {
            position: fixed;
            top: 100px;
            right: 30px;
            display: none;
        }

        .fx-unit {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px;
            margin-bottom: 10px;
            width: 150px;
        }

        .fx-name {
            font-size: 10px;
            letter-spacing: 2px;
            color: rgba(0, 255, 255, 0.8);
            margin-bottom: 5px;
        }

        .fx-param {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: rgba(255, 255, 255, 0.5);
            margin: 3px 0;
        }

        .fx-value {
            color: rgba(255, 0, 255, 0.8);
        }
    </style>
</head>
<body>
    <!-- Visual Layers -->
    <canvas id="spectrum-canvas"></canvas>
    <canvas id="waveform-canvas"></canvas>
    <canvas id="particle-canvas"></canvas>
    <canvas id="fractal-canvas"></canvas>

    <!-- Initialization -->
    <div class="initialization" id="initScreen">
        <button class="quantum-init-btn" id="initBtn">QUANTUM SYNC</button>
    </div>

    <!-- Quantum Cursor -->
    <div class="quantum-cursor" id="cursor"></div>

    <!-- Quantum Brain -->
    <div id="quantum-brain" style="display: none;">
        <div class="neural-layer">
            <div class="synaptic-ring"></div>
            <div class="synaptic-ring"></div>
            <div class="synaptic-ring"></div>
        </div>
        <div class="neural-pathway" id="neuralPathway"></div>
    </div>

    <!-- Performance HUD -->
    <div class="performance-hud" id="performanceHud">
        <div class="dj-state">QUANTUM DJ SYSTEM</div>
        <div class="performance-mode" id="performanceMode">INITIALIZING</div>
    </div>

    <!-- Spectral Matrix (Track Lanes) -->
    <div class="spectral-matrix" id="spectralMatrix">
        <div class="track-lanes" id="trackLanes">
            <div class="track-lane" data-track="0">
                <div class="track-label">BASS DIMENSION</div>
                <canvas class="track-waveform" width="1200" height="60"></canvas>
            </div>
            <div class="track-lane" data-track="1">
                <div class="track-label">HARMONIC FIELD</div>
                <canvas class="track-waveform" width="1200" height="60"></canvas>
            </div>
            <div class="track-lane" data-track="2">
                <div class="track-label">TEXTURE CLOUD</div>
                <canvas class="track-waveform" width="1200" height="60"></canvas>
            </div>
            <div class="track-lane" data-track="3">
                <div class="track-label">RHYTHM MATRIX</div>
                <canvas class="track-waveform" width="1200" height="60"></canvas>
            </div>
        </div>
    </div>

    <!-- Energy System -->
    <div class="energy-system" id="energySystem">
        <div class="energy-meter">
            <div class="energy-label">TENSION</div>
            <div class="energy-fill" id="tension-fill"></div>
        </div>
        <div class="energy-meter">
            <div class="energy-label">HARMONIC</div>
            <div class="energy-fill" id="harmonic-fill"></div>
        </div>
        <div class="energy-meter">
            <div class="energy-label">CROWD</div>
            <div class="energy-fill" id="crowd-fill"></div>
        </div>
    </div>

    <!-- Quantum Parameters -->
    <div class="quantum-params" id="quantumParams">
        <div class="param-group">
            <div class="param-title">SPECTRAL ANALYSIS</div>
            <div class="param-line">
                <span>CENTROID</span>
                <span class="param-value" id="spectralCentroid">0000</span>
            </div>
            <div class="param-line">
                <span>FLUX</span>
                <span class="param-value" id="spectralFlux">0.00</span>
            </div>
            <div class="param-line">
                <span>ROLLOFF</span>
                <span class="param-value" id="spectralRolloff">0000</span>
            </div>
        </div>
        <div class="param-group">
            <div class="param-title">RHYTHM ENGINE</div>
            <div class="param-line">
                <span>GROOVE</span>
                <span class="param-value" id="grooveCoeff">0.00</span>
            </div>
            <div class="param-line">
                <span>SWING</span>
                <span class="param-value" id="swingAmount">0.00</span>
            </div>
            <div class="param-line">
                <span>POLYRHYTHM</span>
                <span class="param-value" id="polyrhythm">4:4</span>
            </div>
        </div>
        <div class="param-group">
            <div class="param-title">TRANSFORMATION</div>
            <div class="param-line">
                <span>MORPH</span>
                <span class="param-value" id="morphRate">0.00</span>
            </div>
            <div class="param-line">
                <span>QUANTUM</span>
                <span class="param-value" id="quantumCoherence">0.00</span>
            </div>
            <div class="param-line">
                <span>DIMENSION</span>
                <span class="param-value" id="dimensionShift">0</span>
            </div>
        </div>
    </div>

    <!-- FX Rack -->
    <div class="fx-rack" id="fxRack">
        <div class="fx-unit">
            <div class="fx-name">SPECTRAL GATE</div>
            <div class="fx-param">
                <span>FREQ</span>
                <span class="fx-value" id="fx-gate-freq">1000</span>
            </div>
            <div class="fx-param">
                <span>RES</span>
                <span class="fx-value" id="fx-gate-res">20</span>
            </div>
        </div>
        <div class="fx-unit">
            <div class="fx-name">DIMENSION DELAY</div>
            <div class="fx-param">
                <span>TIME</span>
                <span class="fx-value" id="fx-delay-time">0.25</span>
            </div>
            <div class="fx-param">
                <span>FEED</span>
                <span class="fx-value" id="fx-delay-feed">0.6</span>
            </div>
        </div>
        <div class="fx-unit">
            <div class="fx-name">QUANTUM VERB</div>
            <div class="fx-param">
                <span>SIZE</span>
                <span class="fx-value" id="fx-verb-size">0.8</span>
            </div>
            <div class="fx-param">
                <span>DECAY</span>
                <span class="fx-value" id="fx-verb-decay">4.0</span>
            </div>
        </div>
    </div>

    <!-- BPM Display -->
    <div class="bpm-display" id="bpmDisplay">
        <div class="bpm-label">BPM</div>
        <div id="currentBpm">105</div>
    </div>

    <!-- Processing Indicator -->
    <div class="quantum-process" id="processIndicator">QUANTUM PROCESSING</div>

    <script>
        // GUMP: Quantum AI DJ System - Advanced Alien Intelligence
        class QuantumDJ {
            constructor() {
                // Core Quantum Audio Engine
                this.audioContext = null;
                this.masterLimiter = null;
                this.sampleRate = 48000;
                
                // Quantum State
                this.quantumState = {
                    dimension: 0,
                    coherence: 1,
                    entanglement: new Map(),
                    wavefunction: new Float32Array(2048),
                    probability: new Float32Array(128)
                };
                
                // Advanced Beat Engine
                this.rhythmEngine = {
                    bpm: 105,
                    targetBpm: 105,
                    groove: 0,
                    swing: 0,
                    polyrhythms: [4, 3, 5, 7],
                    currentPattern: 0,
                    patternBank: [],
                    microTiming: new Float32Array(16),
                    evolutionRate: 0.001,
                    kickPhase: 0,
                    subBassPhase: 0,
                    nextEvent: 0
                };
                
                // DJ Performance State
                this.performance = {
                    mode: 'INTRO',
                    energy: 0,
                    tension: 0,
                    harmonicEnergy: 0,
                    crowdEnergy: 0,
                    narrative: {
                        arc: 'building',
                        chapter: 1,
                        intensity: 0.2
                    },
                    crossfader: 0.5,
                    eqKills: {
                        low: false,
                        mid: false,
                        high: false
                    }
                };
                
                // Multi-Track System
                this.tracks = {
                    bass: { samples: [], active: null, volume: 0.8, filter: null },
                    harmonic: { samples: [], active: null, volume: 0.6, filter: null },
                    texture: { samples: [], active: null, volume: 0.4, filter: null },
                    rhythm: { samples: [], active: null, volume: 0.7, filter: null }
                };
                
                // Spectral Memory & Analysis
                this.spectralMemory = {
                    history: [],
                    maxHistory: 100,
                    centroid: 0,
                    flux: 0,
                    rolloff: 0,
                    mfcc: new Float32Array(13),
                    chroma: new Float32Array(12),
                    zeroCrossing: 0,
                    spectralContrast: new Float32Array(7),
                    tonnetz: new Float32Array(6)
                };
                
                // Advanced Sampling System
                this.sampler = {
                    recordBuffer: null,
                    bufferSize: 0,
                    writePosition: 0,
                    capturedSamples: [],
                    grainCloud: [],
                    freezeBuffer: null,
                    spectralBuffer: null
                };
                
                // Transformation Chains
                this.transformers = {
                    spectralMorph: null,
                    harmonicShift: null,
                    formantShift: null,
                    granularEngine: null,
                    convolutionEngine: null,
                    phaseVocoder: null
                };
                
                // Advanced FX Rack
                this.fx = {
                    // Master chain
                    multiband: null,
                    sidechain: null,
                    
                    // Spatial
                    convolutionReverb: null,
                    shimmerReverb: null,
                    
                    // Time
                    tapDelay: null,
                    pingPongDelay: null,
                    reverseDelay: null,
                    
                    // Spectral
                    spectralGate: null,
                    spectralDelay: null,
                    frequencyShifter: null,
                    
                    // Modulation
                    ringMod: null,
                    chorus: null,
                    phaser: null,
                    
                    // Dynamics
                    transientShaper: null,
                    gateSequencer: null,
                    
                    // Filters
                    morphFilter: null,
                    combFilter: null,
                    
                    // Distortion
                    bitCrusher: null,
                    waveshaper: null,
                    
                    // Special
                    freezeVerb: null,
                    spectralFreeze: null,
                    grainDelay: null
                };
                
                // Motion & Gesture System
                this.motion = {
                    x: 0.5,
                    y: 0.5,
                    vx: 0,
                    vy: 0,
                    acceleration: 0,
                    gesture: null,
                    history: [],
                    patterns: []
                };
                
                // Visual Feedback System
                this.visuals = {
                    particles: [],
                    waveformData: new Float32Array(2048),
                    spectrumData: new Uint8Array(1024),
                    fractalParams: { zoom: 1, offsetX: 0, offsetY: 0 }
                };
                
                // Neural Network Simulation
                this.neuralNet = {
                    layers: 3,
                    neurons: [],
                    connections: [],
                    activationPattern: new Float32Array(64)
                };
                
                // Initialize UI references
                this.ui = {};
                
                // Automation System
                this.automation = {
                    lfos: [],
                    envelopes: [],
                    sequencers: []
                };
                
                this.init();
            }
            
            init() {
                this.setupUI();
                this.setupEventListeners();
                this.initializeNeuralNetwork();
            }
            
            setupUI() {
                this.ui = {
                    initScreen: document.getElementById('initScreen'),
                    initBtn: document.getElementById('initBtn'),
                    cursor: document.getElementById('cursor'),
                    brain: document.getElementById('quantum-brain'),
                    performanceHud: document.getElementById('performanceHud'),
                    performanceMode: document.getElementById('performanceMode'),
                    spectralMatrix: document.getElementById('spectralMatrix'),
                    trackLanes: document.getElementById('trackLanes'),
                    energySystem: document.getElementById('energySystem'),
                    quantumParams: document.getElementById('quantumParams'),
                    fxRack: document.getElementById('fxRack'),
                    bpmDisplay: document.getElementById('bpmDisplay'),
                    processIndicator: document.getElementById('processIndicator'),
                    neuralPathway: document.getElementById('neuralPathway')
                };
                
                // Create neural synapses
                for (let i = 0; i < 20; i++) {
                    const synapse = document.createElement('div');
                    synapse.className = 'synapse';
                    synapse.style.left = Math.random() * 100 + '%';
                    synapse.style.top = Math.random() * 100 + '%';
                    synapse.style.animationDelay = Math.random() * 2 + 's';
                    this.ui.neuralPathway.appendChild(synapse);
                }
            }
            
            setupEventListeners() {
                // Initialize button
                this.ui.initBtn.addEventListener('click', () => this.initialize());
                
                // Advanced motion tracking
                let lastX = 0, lastY = 0, lastTime = Date.now();
                
                document.addEventListener('mousemove', (e) => {
                    const now = Date.now();
                    const dt = (now - lastTime) / 1000;
                    
                    const x = e.clientX / window.innerWidth;
                    const y = e.clientY / window.innerHeight;
                    
                    // Calculate velocity and acceleration
                    const vx = (x - lastX) / dt;
                    const vy = (y - lastY) / dt;
                    
                    this.motion.acceleration = Math.sqrt(
                        Math.pow(vx - this.motion.vx, 2) + 
                        Math.pow(vy - this.motion.vy, 2)
                    ) / dt;
                    
                    this.motion.x = x;
                    this.motion.y = y;
                    this.motion.vx = vx;
                    this.motion.vy = vy;
                    
                    // Update cursor
                    this.ui.cursor.style.left = e.clientX + 'px';
                    this.ui.cursor.style.top = e.clientY + 'px';
                    
                    // Gesture detection
                    this.detectGesture();
                    
                    // Store history
                    this.motion.history.push({
                        x, y, vx, vy, a: this.motion.acceleration, t: now
                    });
                    
                    if (this.motion.history.length > 60) {
                        this.motion.history.shift();
                    }
                    
                    lastX = x;
                    lastY = y;
                    lastTime = now;
                });
                
                // Keyboard controls for DJ performance
                document.addEventListener('keydown', (e) => {
                    if (!this.audioContext) return;
                    
                    switch(e.key) {
                        case ' ':
                            this.triggerDrop();
                            break;
                        case 'q':
                            this.performance.eqKills.low = !this.performance.eqKills.low;
                            break;
                        case 'w':
                            this.performance.eqKills.mid = !this.performance.eqKills.mid;
                            break;
                        case 'e':
                            this.performance.eqKills.high = !this.performance.eqKills.high;
                            break;
                        case 'ArrowUp':
                            this.rhythmEngine.targetBpm = Math.min(140, this.rhythmEngine.targetBpm + 1);
                            break;
                        case 'ArrowDown':
                            this.rhythmEngine.targetBpm = Math.max(90, this.rhythmEngine.targetBpm - 1);
                            break;
                    }
                });
            }
            
            initializeNeuralNetwork() {
                // Create simulated neural network structure
                const layers = [16, 32, 16];
                
                for (let l = 0; l < layers.length; l++) {
                    this.neuralNet.neurons[l] = [];
                    for (let n = 0; n < layers[l]; n++) {
                        this.neuralNet.neurons[l].push({
                            activation: 0,
                            bias: Math.random() - 0.5
                        });
                    }
                }
                
                // Create connections
                for (let l = 0; l < layers.length - 1; l++) {
                    this.neuralNet.connections[l] = [];
                    for (let i = 0; i < layers[l]; i++) {
                        for (let j = 0; j < layers[l + 1]; j++) {
                            this.neuralNet.connections[l].push({
                                from: i,
                                to: j,
                                weight: (Math.random() - 0.5) * 2
                            });
                        }
                    }
                }
            }
            
            async initialize() {
                // Hide init screen
                this.ui.initScreen.style.display = 'none';
                
                // Show all UI elements
                this.ui.brain.style.display = 'block';
                this.ui.performanceHud.style.display = 'block';
                this.ui.spectralMatrix.style.display = 'block';
                this.ui.energySystem.style.display = 'block';
                this.ui.quantumParams.style.display = 'block';
                this.ui.fxRack.style.display = 'block';
                this.ui.bpmDisplay.style.display = 'block';
                
                try {
                    // Create high-quality audio context
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)({
                        latencyHint: 'playback',
                        sampleRate: this.sampleRate
                    });
                    
                    // Get microphone input
                    const stream = await navigator.mediaDevices.getUserMedia({
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false,
                            sampleRate: this.sampleRate,
                            channelCount: 2
                        }
                    });
                    
                    // Setup quantum audio system
                    await this.setupQuantumAudioSystem(stream);
                    
                    // Start the performance
                    this.startPerformance();
                    
                    this.ui.performanceMode.textContent = 'QUANTUM SYNC';
                    
                } catch (err) {
                    console.error('Initialization failed:', err);
                    alert('Quantum sync failed. Ensure microphone access is granted.');
                }
            }
            
            async setupQuantumAudioSystem(stream) {
                // Input processing
                const input = this.audioContext.createMediaStreamSource(stream);
                
                // Create analysis chain
                const splitter = this.audioContext.createChannelSplitter(2);
                const analyzerL = this.audioContext.createAnalyser();
                const analyzerR = this.audioContext.createAnalyser();
                analyzerL.fftSize = 4096;
                analyzerR.fftSize = 4096;
                analyzerL.smoothingTimeConstant = 0.65;
                analyzerR.smoothingTimeConstant = 0.65;
                
                // Setup recording buffer (60 seconds circular buffer)
                this.sampler.bufferSize = this.sampleRate * 60;
                this.sampler.recordBuffer = new Float32Array(this.sampler.bufferSize);
                
                // Create script processor for recording
                const recorder = this.audioContext.createScriptProcessor(4096, 1, 1);
                recorder.onaudioprocess = (e) => {
                    this.processQuantumAudio(e.inputBuffer.getChannelData(0));
                };
                
                // Master processing chain
                await this.setupMasterChain();
                
                // Setup all FX
                await this.setupQuantumFX();
                
                // Setup track chains
                this.setupTrackChains();
                
                // Initialize beat engine
                this.initializeRhythmEngine();
                
                // Connect input
                input.connect(splitter);
                splitter.connect(analyzerL, 0);
                splitter.connect(analyzerR, 1);
                input.connect(recorder);
                recorder.connect(this.audioContext.destination); // Required for script processor
                
                // Store analyzers
                this.analyzerL = analyzerL;
                this.analyzerR = analyzerR;
                
                // Initialize spectral processing
                this.spectralDataL = new Uint8Array(analyzerL.frequencyBinCount);
                this.spectralDataR = new Uint8Array(analyzerR.frequencyBinCount);
            }
            
            async setupMasterChain() {
                // Multiband compressor
                this.fx.multiband = {
                    lowBand: this.createCompressor(-20, 4, 0.003, 0.1),
                    midBand: this.createCompressor(-24, 3, 0.002, 0.05),
                    highBand: this.createCompressor(-28, 2, 0.001, 0.03),
                    
                    lowFilter: this.audioContext.createBiquadFilter(),
                    midFilter: this.audioContext.createBiquadFilter(),
                    highFilter: this.audioContext.createBiquadFilter(),
                    
                    lowGain: this.audioContext.createGain(),
                    midGain: this.audioContext.createGain(),
                    highGain: this.audioContext.createGain()
                };
                
                // Setup crossover filters
                this.fx.multiband.lowFilter.type = 'lowpass';
                this.fx.multiband.lowFilter.frequency.value = 250;
                
                this.fx.multiband.midFilter.type = 'bandpass';
                this.fx.multiband.midFilter.frequency.value = 1000;
                this.fx.multiband.midFilter.Q.value = 0.7;
                
                this.fx.multiband.highFilter.type = 'highpass';
                this.fx.multiband.highFilter.frequency.value = 4000;
                
                // Master limiter
                this.masterLimiter = this.audioContext.createDynamicsCompressor();
                this.masterLimiter.threshold.value = -0.5;
                this.masterLimiter.knee.value = 0;
                this.masterLimiter.ratio.value = 20;
                this.masterLimiter.attack.value = 0.001;
                this.masterLimiter.release.value = 0.05;
                
                // Master output gain
                this.masterGain = this.audioContext.createGain();
                this.masterGain.gain.value = 0.9;
                
                // Connect master chain
                this.masterGain.connect(this.masterLimiter);
                this.masterLimiter.connect(this.audioContext.destination);
            }
            
            createCompressor(threshold, ratio, attack, release) {
                const comp = this.audioContext.createDynamicsCompressor();
                comp.threshold.value = threshold;
                comp.ratio.value = ratio;
                comp.attack.value = attack;
                comp.release.value = release;
                return comp;
            }
            
            async setupQuantumFX() {
                // Sidechain compression
                this.fx.sidechain = this.audioContext.createGain();
                this.fx.sidechain.gain.value = 1;
                
                // Convolution reverb with multiple IRs
                this.fx.convolutionReverb = await this.createConvolutionReverb(4, 3);
                
                // Shimmer reverb
                this.fx.shimmerReverb = await this.createShimmerReverb();
                
                // Multi-tap delay
                this.fx.tapDelay = this.createMultiTapDelay([0.25, 0.375, 0.5, 0.75]);
                
                // Ping pong delay
                this.fx.pingPongDelay = this.createPingPongDelay();
                
                // Spectral gate
                this.fx.spectralGate = this.createSpectralGate();
                
                // Frequency shifter
                this.fx.frequencyShifter = this.createFrequencyShifter();
                
                // Ring modulator
                this.fx.ringMod = this.createRingModulator();
                
                // Morph filter
                this.fx.morphFilter = this.createMorphFilter();
                
                // Bit crusher
                this.fx.bitCrusher = this.createBitCrusher();
                
                // Spectral freeze
                this.fx.spectralFreeze = this.createSpectralFreeze();
                
                // Gate sequencer
                this.fx.gateSequencer = this.createGateSequencer();
                
                // Connect FX sends
                this.setupFXRouting();
            }
            
            async createConvolutionReverb(seconds, decay) {
                const convolver = this.audioContext.createConvolver();
                const length = this.audioContext.sampleRate * seconds;
                const impulse = this.audioContext.createBuffer(2, length, this.audioContext.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        // Create complex IR with early reflections and diffuse tail
                        const early = i < 1000 ? Math.random() * Math.pow(1 - i/1000, 0.5) : 0;
                        const tail = Math.random() * Math.pow(1 - i/length, decay);
                        channelData[i] = (early * 0.3 + tail * 0.7) * (Math.random() * 2 - 1);
                    }
                }
                
                convolver.buffer = impulse;
                
                const wetGain = this.audioContext.createGain();
                const dryGain = this.audioContext.createGain();
                wetGain.gain.value = 0.3;
                dryGain.gain.value = 0.7;
                
                return { convolver, wetGain, dryGain };
            }
            
            async createShimmerReverb() {
                // Shimmer = reverb + pitch shift up an octave
                const shimmer = {
                    input: this.audioContext.createGain(),
                    pitchShift: this.audioContext.createScriptProcessor(4096, 1, 1),
                    reverb: await this.createConvolutionReverb(6, 4),
                    output: this.audioContext.createGain()
                };
                
                // Simple pitch shifter (octave up)
                let phase = 0;
                shimmer.pitchShift.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    for (let i = 0; i < input.length; i++) {
                        // Simple octave up by taking every other sample
                        output[i] = input[Math.floor(i * 0.5) % input.length] * 0.5;
                    }
                };
                
                shimmer.input.connect(shimmer.pitchShift);
                shimmer.pitchShift.connect(shimmer.reverb.convolver);
                shimmer.reverb.convolver.connect(shimmer.output);
                
                return shimmer;
            }
            
            createMultiTapDelay(taps) {
                const delays = [];
                const gains = [];
                const merger = this.audioContext.createChannelMerger(2);
                
                taps.forEach((time, i) => {
                    const delay = this.audioContext.createDelay(5);
                    const gain = this.audioContext.createGain();
                    const feedback = this.audioContext.createGain();
                    
                    delay.delayTime.value = time;
                    gain.gain.value = 0.5 / (i + 1);
                    feedback.gain.value = 0.4;
                    
                    // Create feedback loop
                    delay.connect(feedback);
                    feedback.connect(delay);
                    
                    // Connect to merger (alternate L/R)
                    delay.connect(gain);
                    gain.connect(merger, 0, i % 2);
                    
                    delays.push({ delay, gain, feedback });
                });
                
                return { delays, merger };
            }
            
            createPingPongDelay() {
                const delayL = this.audioContext.createDelay(2);
                const delayR = this.audioContext.createDelay(2);
                const feedbackL = this.audioContext.createGain();
                const feedbackR = this.audioContext.createGain();
                const merger = this.audioContext.createChannelMerger(2);
                
                delayL.delayTime.value = 0.375;
                delayR.delayTime.value = 0.375;
                feedbackL.gain.value = 0.6;
                feedbackR.gain.value = 0.6;
                
                // Cross-feedback for ping pong
                delayL.connect(feedbackL);
                feedbackL.connect(delayR);
                delayR.connect(feedbackR);
                feedbackR.connect(delayL);
                
                delayL.connect(merger, 0, 0);
                delayR.connect(merger, 0, 1);
                
                return { delayL, delayR, feedbackL, feedbackR, merger };
            }
            
            createSpectralGate() {
                const bands = 32;
                const gate = {
                    input: this.audioContext.createGain(),
                    output: this.audioContext.createGain(),
                    bands: []
                };
                
                for (let i = 0; i < bands; i++) {
                    const freq = 20 * Math.pow(1000, i / bands);
                    
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = 'bandpass';
                    filter.frequency.value = freq;
                    filter.Q.value = 10;
                    
                    const gate = this.audioContext.createGain();
                    gate.gain.value = 1;
                    
                    gate.input.connect(filter);
                    filter.connect(gate);
                    gate.connect(gate.output);
                    
                    gate.bands.push({ filter, gate });
                }
                
                return gate;
            }
            
            createFrequencyShifter() {
                // Frequency shifting using ring modulation with quadrature oscillator
                const shifter = {
                    input: this.audioContext.createGain(),
                    output: this.audioContext.createGain(),
                    oscillator: this.audioContext.createOscillator(),
                    modGain: this.audioContext.createGain()
                };
                
                shifter.oscillator.frequency.value = 0; // Start at 0 Hz shift
                shifter.modGain.gain.value = 0;
                
                shifter.input.connect(shifter.modGain);
                shifter.oscillator.connect(shifter.modGain.gain);
                shifter.modGain.connect(shifter.output);
                
                shifter.oscillator.start();
                
                return shifter;
            }
            
            createRingModulator() {
                const ringMod = {
                    input: this.audioContext.createGain(),
                    output: this.audioContext.createGain(),
                    carrier: this.audioContext.createOscillator(),
                    modGain: this.audioContext.createGain()
                };
                
                ringMod.carrier.frequency.value = 440;
                ringMod.modGain.gain.value = 0;
                
                ringMod.input.connect(ringMod.modGain);
                ringMod.carrier.connect(ringMod.modGain.gain);
                ringMod.modGain.connect(ringMod.output);
                
                ringMod.carrier.start();
                
                return ringMod;
            }
            
            createMorphFilter() {
                // Morphing filter with multiple modes
                const morph = {
                    input: this.audioContext.createGain(),
                    output: this.audioContext.createGain(),
                    filters: []
                };
                
                const types = ['lowpass', 'highpass', 'bandpass', 'notch'];
                
                types.forEach(type => {
                    const filter = this.audioContext.createBiquadFilter();
                    filter.type = type;
                    filter.frequency.value = 1000;
                    filter.Q.value = 5;
                    
                    const gain = this.audioContext.createGain();
                    gain.gain.value = 0;
                    
                    morph.input.connect(filter);
                    filter.connect(gain);
                    gain.connect(morph.output);
                    
                    morph.filters.push({ filter, gain, type });
                });
                
                // Start with lowpass
                morph.filters[0].gain.gain.value = 1;
                
                return morph;
            }
            
            createBitCrusher() {
                const crusher = this.audioContext.createScriptProcessor(4096, 1, 1);
                let bits = 16;
                let normFreq = 1;
                
                crusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    const step = Math.pow(0.5, bits);
                    const invStep = 1 / step;
                    
                    for (let i = 0; i < input.length; i++) {
                        // Bit reduction
                        output[i] = step * Math.floor(input[i] * invStep + 0.5);
                        
                        // Sample rate reduction
                        if (i % Math.floor(1 / normFreq) !== 0) {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };
                
                crusher.setBits = (b) => { bits = b; };
                crusher.setFreq = (f) => { normFreq = f; };
                
                return crusher;
            }
            
            createSpectralFreeze() {
                // FFT-based spectral freezer
                const freeze = {
                    input: this.audioContext.createGain(),
                    output: this.audioContext.createGain(),
                    processor: this.audioContext.createScriptProcessor(4096, 1, 1),
                    frozen: false,
                    spectrum: new Float32Array(2048)
                };
                
                let frozenSpectrum = null;
                
                freeze.processor.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    if (!freeze.frozen) {
                        // Pass through and capture spectrum
                        output.set(input);
                        frozenSpectrum = new Float32Array(input);
                    } else if (frozenSpectrum) {
                        // Output frozen spectrum
                        for (let i = 0; i < output.length; i++) {
                            output[i] = frozenSpectrum[i % frozenSpectrum.length] * 0.95;
                        }
                    }
                };
                
                freeze.input.connect(freeze.processor);
                freeze.processor.connect(freeze.output);
                
                return freeze;
            }
            
            createGateSequencer() {
                const sequencer = {
                    input: this.audioContext.createGain(),
                    output: this.audioContext.createGain(),
                    gate: this.audioContext.createGain(),
                    pattern: [1, 0, 1, 0, 1, 1, 0, 1],
                    step: 0,
                    isRunning: false
                };
                
                sequencer.input.connect(sequencer.gate);
                sequencer.gate.connect(sequencer.output);
                
                const updateGate = () => {
                    if (!sequencer.isRunning) return;
                    
                    const now = this.audioContext.currentTime;
                    const stepTime = 60 / this.rhythmEngine.bpm / 4; // 16th notes
                    
                    sequencer.gate.gain.cancelScheduledValues(now);
                    sequencer.gate.gain.setValueAtTime(
                        sequencer.pattern[sequencer.step] ? 1 : 0, 
                        now
                    );
                    
                    sequencer.step = (sequencer.step + 1) % sequencer.pattern.length;
                    
                    setTimeout(updateGate, stepTime * 1000);
                };
                
                sequencer.start = () => {
                    sequencer.isRunning = true;
                    updateGate();
                };
                
                sequencer.stop = () => {
                    sequencer.isRunning = false;
                };
                
                return sequencer;
            }
            
            setupFXRouting() {
                // Create send buses
                this.sendBuses = {
                    reverb: this.audioContext.createGain(),
                    delay: this.audioContext.createGain(),
                    shimmer: this.audioContext.createGain(),
                    spectral: this.audioContext.createGain()
                };
                
                // Set initial send levels
                this.sendBuses.reverb.gain.value = 0.3;
                this.sendBuses.delay.gain.value = 0.2;
                this.sendBuses.shimmer.gain.value = 0.1;
                this.sendBuses.spectral.gain.value = 0.15;
                
                // Connect sends to effects
                this.sendBuses.reverb.connect(this.fx.convolutionReverb.convolver);
                this.sendBuses.delay.connect(this.fx.tapDelay.delays[0].delay);
                this.sendBuses.shimmer.connect(this.fx.shimmerReverb.input);
                
                // Connect effects to master
                this.fx.convolutionReverb.convolver.connect(this.masterGain);
                this.fx.tapDelay.merger.connect(this.masterGain);
                this.fx.shimmerReverb.output.connect(this.masterGain);
                
                // Connect sidechain
                this.fx.sidechain.connect(this.masterGain);
            }
            
            setupTrackChains() {
                Object.keys(this.tracks).forEach(trackName => {
                    const track = this.tracks[trackName];
                    
                    // Create processing chain for each track
                    track.input = this.audioContext.createGain();
                    track.eq = {
                        low: this.audioContext.createBiquadFilter(),
                        mid: this.audioContext.createBiquadFilter(),
                        high: this.audioContext.createBiquadFilter()
                    };
                    
                    // EQ setup
                    track.eq.low.type = 'lowshelf';
                    track.eq.low.frequency.value = 320;
                    track.eq.low.gain.value = 0;
                    
                    track.eq.mid.type = 'peaking';
                    track.eq.mid.frequency.value = 1000;
                    track.eq.mid.Q.value = 0.5;
                    track.eq.mid.gain.value = 0;
                    
                    track.eq.high.type = 'highshelf';
                    track.eq.high.frequency.value = 3200;
                    track.eq.high.gain.value = 0;
                    
                    // Track filter
                    track.filter = this.audioContext.createBiquadFilter();
                    track.filter.type = 'lowpass';
                    track.filter.frequency.value = 20000;
                    track.filter.Q.value = 1;
                    
                    // Output gain
                    track.output = this.audioContext.createGain();
                    track.output.gain.value = track.volume;
                    
                    // Connect chain
                    track.input.connect(track.eq.low);
                    track.eq.low.connect(track.eq.mid);
                    track.eq.mid.connect(track.eq.high);
                    track.eq.high.connect(track.filter);
                    track.filter.connect(track.output);
                    
                    // Connect to sidechain and sends
                    track.output.connect(this.fx.sidechain);
                    track.output.connect(this.sendBuses.reverb);
                    track.output.connect(this.sendBuses.delay);
                });
            }
            
            initializeRhythmEngine() {
                // Generate initial patterns
                this.generateRhythmPatterns();
                
                // Start the quantum beat
                this.startQuantumBeat();
                
                // Initialize LFOs for automation
                this.initializeLFOs();
            }
            
            generateRhythmPatterns() {
                // Generate evolving polyrhythmic patterns
                const patterns = [
                    // Basic 4/4
                    { kick: [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0], weight: 1 },
                    // Syncopated
                    { kick: [1,0,0,1,0,0,1,0,1,0,0,0,1,0,1,0], weight: 0.7 },
                    // Complex
                    { kick: [1,0,0,1,0,1,0,0,1,0,0,0,1,1,0,0], weight: 0.5 },
                    // Breakbeat influenced
                    { kick: [1,0,0,0,0,0,1,0,1,0,1,0,0,0,1,0], weight: 0.4 }
                ];
                
                this.rhythmEngine.patternBank = patterns;
            }
            
            startQuantumBeat() {
                let phase = 0;
                const schedule = () => {
                    const now = this.audioContext.currentTime;
                    const beatLength = 60 / this.rhythmEngine.bpm;
                    
                    // Smooth BPM morphing
                    if (this.rhythmEngine.bpm !== this.rhythmEngine.targetBpm) {
                        const diff = this.rhythmEngine.targetBpm - this.rhythmEngine.bpm;
                        this.rhythmEngine.bpm += diff * 0.02;
                        document.getElementById('currentBpm').textContent = 
                            Math.round(this.rhythmEngine.bpm);
                    }
                    
                    // Check if we should trigger kick
                    if (now >= this.rhythmEngine.nextEvent) {
                        this.triggerQuantumKick(phase);
                        
                        // Calculate swing
                        let swingOffset = 0;
                        if (phase % 2 === 1) {
                            swingOffset = this.rhythmEngine.swing * beatLength * 0.1;
                        }
                        
                        this.rhythmEngine.nextEvent = now + beatLength / 4 + swingOffset;
                        phase = (phase + 1) % 16;
                        
                        // Trigger other rhythm elements
                        this.processRhythmMatrix(phase);
                    }
                    
                    requestAnimationFrame(schedule);
                };
                
                this.rhythmEngine.nextEvent = this.audioContext.currentTime;
                schedule();
            }
            
            triggerQuantumKick(phase) {
                const now = this.audioContext.currentTime;
                
                // Get current pattern
                const pattern = this.rhythmEngine.patternBank[this.rhythmEngine.currentPattern];
                
                if (!pattern.kick[phase]) return;
                
                // Create layered kick
                const createKickLayer = (freq, decay, gain, dist = 0) => {
                    const osc = this.audioContext.createOscillator();
                    const env = this.audioContext.createGain();
                    
                    osc.frequency.setValueAtTime(freq, now);
                    osc.frequency.exponentialRampToValueAtTime(30, now + decay);
                    
                    env.gain.setValueAtTime(gain, now);
                    env.gain.exponentialRampToValueAtTime(0.001, now + decay);
                    
                    osc.connect(env);
                    
                    if (dist > 0) {
                        const distortion = this.audioContext.createWaveShaper();
                        distortion.curve = this.makeDistortionCurve(dist);
                        env.connect(distortion);
                        distortion.connect(this.masterGain);
                    } else {
                        env.connect(this.masterGain);
                    }
                    
                    osc.start(now);
                    osc.stop(now + decay);
                };
                
                // Layer 1: Sub
                createKickLayer(40 + this.rhythmEngine.kickPhase * 10, 0.8, 0.9);
                
                // Layer 2: Punch
                createKickLayer(150 + this.rhythmEngine.kickPhase * 20, 0.15, 0.7, 5);
                
                // Layer 3: Click
                createKickLayer(800, 0.01, 0.3, 10);
                
                // Evolve kick phase
                this.rhythmEngine.kickPhase = (this.rhythmEngine.kickPhase + 0.1) % 1;
                
                // Trigger sidechain
                this.triggerSidechain(0.95);
                
                // Visual feedback
                this.flashNeuralRings();
            }
            
            triggerSidechain(depth) {
                const now = this.audioContext.currentTime;
                
                this.fx.sidechain.gain.cancelScheduledValues(now);
                this.fx.sidechain.gain.setValueAtTime(this.fx.sidechain.gain.value, now);
                this.fx.sidechain.gain.linearRampToValueAtTime(1 - depth, now + 0.01);
                this.fx.sidechain.gain.exponentialRampToValueAtTime(1, now + 0.2);
            }
            
            processRhythmMatrix(phase) {
                // Process each track's rhythm
                Object.keys(this.tracks).forEach(trackName => {
                    const track = this.tracks[trackName];
                    
                    // Check if track has active sample
                    if (track.active && Math.random() < this.getTrackProbability(trackName, phase)) {
                        this.triggerTrackSample(trackName, track.active);
                    }
                });
            }
            
            getTrackProbability(trackName, phase) {
                // Different probability patterns for each track
                const patterns = {
                    bass: [1,0,0,0,0.5,0,0,0,1,0,0,0,0.5,0,0,0],
                    harmonic: [0,0,0.3,0,0,0,0.7,0,0,0,0.3,0,0,0,1,0],
                    texture: [0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2,0.2],
                    rhythm: [0,1,0,0.5,0,1,0,0,0,1,0.5,0,0,1,0,0.7]
                };
                
                return patterns[trackName][phase] * this.performance.energy;
            }
            
            triggerTrackSample(trackName, sample) {
                if (!sample || !sample.buffer) return;
                
                const source = this.audioContext.createBufferSource();
                source.buffer = sample.buffer;
                
                // Apply track-specific processing
                switch(trackName) {
                    case 'bass':
                        source.playbackRate.value = 0.5 + Math.random() * 0.1;
                        break;
                    case 'harmonic':
                        source.playbackRate.value = this.quantizePitch(Math.random() * 2);
                        break;
                    case 'texture':
                        source.loop = true;
                        source.loopStart = Math.random() * sample.buffer.duration * 0.5;
                        source.loopEnd = source.loopStart + 0.1;
                        break;
                    case 'rhythm':
                        source.playbackRate.value = 1 + (Math.random() - 0.5) * 0.1;
                        break;
                }
                
                source.connect(this.tracks[trackName].input);
                source.start();
                
                // Auto-stop for non-looping
                if (!source.loop) {
                    source.stop(this.audioContext.currentTime + sample.buffer.duration);
                }
                
                // Visual feedback
                this.updateTrackVisual(trackName);
            }
            
            quantizePitch(value) {
                // Quantize to harmonic series
                const harmonics = [0.25, 0.5, 0.75, 1, 1.5, 2, 3, 4];
                let nearest = harmonics[0];
                let minDiff = Math.abs(value - nearest);
                
                for (const h of harmonics) {
                    const diff = Math.abs(value - h);
                    if (diff < minDiff) {
                        minDiff = diff;
                        nearest = h;
                    }
                }
                
                return nearest;
            }
            
            initializeLFOs() {
                // Create multiple LFOs for parameter automation
                const lfoFreqs = [0.1, 0.25, 0.5, 1, 2];
                
                lfoFreqs.forEach(freq => {
                    const lfo = this.audioContext.createOscillator();
                    const gain = this.audioContext.createGain();
                    
                    lfo.frequency.value = freq;
                    lfo.type = 'sine';
                    gain.gain.value = 1;
                    
                    lfo.connect(gain);
                    lfo.start();
                    
                    this.automation.lfos.push({ lfo, gain, freq });
                });
                
                // Connect LFOs to parameters
                this.automateParameters();
            }
            
            automateParameters() {
                // Automate filter cutoffs
                const filterLFO = this.automation.lfos[0];
                filterLFO.gain.gain.value = 5000;
                
                Object.keys(this.tracks).forEach(trackName => {
                    const track = this.tracks[trackName];
                    filterLFO.gain.connect(track.filter.frequency);
                });
                
                // Automate FX parameters
                const fxLFO = this.automation.lfos[1];
                fxLFO.gain.gain.value = 2000;
                fxLFO.gain.connect(this.fx.spectralGate.bands[0].filter.frequency);
            }
            
            processQuantumAudio(input) {
                // Write to circular buffer
                for (let i = 0; i < input.length; i++) {
                    this.sampler.recordBuffer[this.sampler.writePosition] = input[i];
                    this.sampler.writePosition = (this.sampler.writePosition + 1) % this.sampler.bufferSize;
                }
                
                // Perform spectral analysis
                this.analyzeSpectrum();
                
                // Detect interesting features
                if (this.detectQuantumEvent()) {
                    this.captureQuantumSample();
                }
                
                // Update neural network
                this.updateNeuralNetwork(input);
            }
            
            analyzeSpectrum() {
                // Get frequency data
                this.analyzerL.getByteFrequencyData(this.spectralDataL);
                this.analyzerR.getByteFrequencyData(this.spectralDataR);
                
                // Calculate spectral features
                const features = this.calculateSpectralFeatures(this.spectralDataL);
                
                // Update memory
                this.spectralMemory.centroid = features.centroid;
                this.spectralMemory.flux = features.flux;
                this.spectralMemory.rolloff = features.rolloff;
                
                // Store in history
                this.spectralMemory.history.push(features);
                if (this.spectralMemory.history.length > this.spectralMemory.maxHistory) {
                    this.spectralMemory.history.shift();
                }
                
                // Update display
                this.updateQuantumParameters();
            }
            
            calculateSpectralFeatures(data) {
                const nyquist = this.audioContext.sampleRate / 2;
                let weightedSum = 0;
                let magnitudeSum = 0;
                let flux = 0;
                
                // Spectral centroid
                for (let i = 0; i < data.length; i++) {
                    const magnitude = data[i] / 255;
                    const frequency = (i / data.length) * nyquist;
                    weightedSum += frequency * magnitude;
                    magnitudeSum += magnitude;
                }
                
                const centroid = magnitudeSum > 0 ? weightedSum / magnitudeSum : 0;
                
                // Spectral flux
                if (this.previousSpectrum) {
                    for (let i = 0; i < data.length; i++) {
                        const diff = (data[i] / 255) - this.previousSpectrum[i];
                        flux += diff > 0 ? diff * diff : 0;
                    }
                    flux = Math.sqrt(flux);
                }
                
                this.previousSpectrum = new Float32Array(data.length);
                for (let i = 0; i < data.length; i++) {
                    this.previousSpectrum[i] = data[i] / 255;
                }
                
                // Spectral rolloff
                let rolloffSum = 0;
                let rolloff = 0;
                const rolloffThreshold = magnitudeSum * 0.85;
                
                for (let i = 0; i < data.length; i++) {
                    rolloffSum += data[i] / 255;
                    if (rolloffSum >= rolloffThreshold) {
                        rolloff = (i / data.length) * nyquist;
                        break;
                    }
                }
                
                return { centroid, flux, rolloff };
            }
            
            detectQuantumEvent() {
                // Multi-dimensional event detection
                const threshold = 0.3 - (this.performance.tension * 0.15);
                
                const spectralEvent = this.spectralMemory.flux > threshold;
                const motionEvent = Math.abs(this.motion.acceleration) > 0.5;
                const harmonicEvent = this.detectHarmonicContent();
                const rhythmicEvent = this.detectRhythmicContent();
                
                // Combine events with quantum probability
                const quantumProbability = 
                    (spectralEvent ? 0.3 : 0) +
                    (motionEvent ? 0.3 : 0) +
                    (harmonicEvent ? 0.2 : 0) +
                    (rhythmicEvent ? 0.2 : 0);
                
                return Math.random() < quantumProbability;
            }
            
            detectHarmonicContent() {
                // Check for harmonic relationships in spectrum
                const fundamentalBin = Math.floor(this.spectralMemory.centroid / 20);
                
                if (fundamentalBin < 10) return false;
                
                let harmonicStrength = 0;
                for (let harmonic = 2; harmonic <= 5; harmonic++) {
                    const bin = fundamentalBin * harmonic;
                    if (bin < this.spectralDataL.length) {
                        harmonicStrength += this.spectralDataL[bin] / 255;
                    }
                }
                
                return harmonicStrength > 1.5;
            }
            
            detectRhythmicContent() {
                // Onset detection using spectral flux
                if (this.spectralMemory.history.length < 10) return false;
                
                const recentFlux = this.spectralMemory.history
                    .slice(-10)
                    .map(h => h.flux);
                
                const mean = recentFlux.reduce((a, b) => a + b) / recentFlux.length;
                const variance = recentFlux.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / recentFlux.length;
                
                return variance > 0.1;
            }
            
            captureQuantumSample() {
                // Show capture feedback
                this.ui.cursor.classList.add('capturing');
                setTimeout(() => this.ui.cursor.classList.remove('capturing'), 300);
                
                // Determine capture parameters based on quantum state
                const captureLength = this.calculateCaptureLength();
                const samples = Math.floor(this.audioContext.sampleRate * captureLength);
                
                // Create audio buffer
                const buffer = this.audioContext.createBuffer(1, samples, this.audioContext.sampleRate);
                const channelData = buffer.getChannelData(0);
                
                // Copy from circular buffer with quantum windowing
                const startPos = (this.sampler.writePosition - samples + this.sampler.bufferSize) % this.sampler.bufferSize;
                
                for (let i = 0; i < samples; i++) {
                    const pos = (startPos + i) % this.sampler.bufferSize;
                    
                    // Apply quantum window function
                    const window = this.quantumWindow(i / samples);
                    channelData[i] = this.sampler.recordBuffer[pos] * window;
                }
                
                // Process and assign to tracks
                this.processQuantumSample(buffer);
                
                // Update performance state
                this.updatePerformanceState();
                
                // Show processing indicator
                this.showQuantumProcess();
            }
            
            calculateCaptureLength() {
                // Dynamic capture length based on multiple factors
                const baseLength = 0.05;
                const maxLength = 4.0;
                
                const motionFactor = Math.min(1, this.motion.acceleration * 0.5);
                const spectralFactor = Math.min(1, this.spectralMemory.flux);
                const tensionFactor = this.performance.tension;
                
                const length = baseLength + (maxLength - baseLength) * 
                    (motionFactor * 0.3 + spectralFactor * 0.3 + tensionFactor * 0.4);
                
                // Quantize to beat grid
                const beatLength = 60 / this.rhythmEngine.bpm;
                const beats = Math.round(length / beatLength);
                
                return Math.max(beatLength / 4, beats * beatLength);
            }
            
            quantumWindow(x) {
                // Quantum-inspired window function
                const gaussian = Math.exp(-Math.pow((x - 0.5) * 4, 2));
                const hann = 0.5 - 0.5 * Math.cos(2 * Math.PI * x);
                const quantum = Math.sin(Math.PI * x) * Math.cos(4 * Math.PI * x);
                
                return gaussian * 0.5 + hann * 0.3 + quantum * 0.2;
            }
            
            processQuantumSample(buffer) {
                // Analyze sample characteristics
                const analysis = this.analyzeSampleCharacteristics(buffer);
                
                // Determine best track assignment
                const trackAssignment = this.determineTrackAssignment(analysis);
                
                // Apply quantum transformations
                const transformed = this.applyQuantumTransformations(buffer, analysis, trackAssignment);
                
                // Store in appropriate track
                this.tracks[trackAssignment].samples.push({
                    buffer: transformed,
                    analysis: analysis,
                    timestamp: Date.now()
                });
                
                // Set as active if track is empty
                if (!this.tracks[trackAssignment].active) {
                    this.tracks[trackAssignment].active = 
                        this.tracks[trackAssignment].samples[this.tracks[trackAssignment].samples.length - 1];
                }
                
                // Update track visual
                this.updateTrackLane(trackAssignment, transformed);
            }
            
            analyzeSampleCharacteristics(buffer) {
                const data = buffer.getChannelData(0);
                
                // Zero crossing rate
                let zeroCrossings = 0;
                for (let i = 1; i < data.length; i++) {
                    if ((data[i] >= 0) !== (data[i-1] >= 0)) {
                        zeroCrossings++;
                    }
                }
                const zcr = zeroCrossings / data.length;
                
                // RMS energy
                let rms = 0;
                for (let i = 0; i < data.length; i++) {
                    rms += data[i] * data[i];
                }
                rms = Math.sqrt(rms / data.length);
                
                // Spectral characteristics (simplified)
                const spectralContent = zcr * this.audioContext.sampleRate / 2;
                
                // Transient detection
                let maxDiff = 0;
                for (let i = 1; i < Math.min(100, data.length); i++) {
                    maxDiff = Math.max(maxDiff, Math.abs(data[i] - data[i-1]));
                }
                const transientStrength = maxDiff;
                
                return {
                    zcr,
                    rms,
                    spectralContent,
                    transientStrength,
                    duration: buffer.duration
                };
            }
            
            determineTrackAssignment(analysis) {
                // AI decision for track assignment
                if (analysis.spectralContent < 200 && analysis.rms > 0.3) {
                    return 'bass';
                } else if (analysis.transientStrength > 0.5 && analysis.duration < 0.2) {
                    return 'rhythm';
                } else if (analysis.spectralContent > 1000 && analysis.spectralContent < 4000) {
                    return 'harmonic';
                } else {
                    return 'texture';
                }
            }
            
            applyQuantumTransformations(buffer, analysis, trackType) {
                const transformed = this.audioContext.createBuffer(
                    1, 
                    buffer.length, 
                    this.audioContext.sampleRate
                );
                
                const input = buffer.getChannelData(0);
                const output = transformed.getChannelData(0);
                
                switch(trackType) {
                    case 'bass':
                        // Heavy lowpass and distortion
                        this.applyBassTransform(input, output);
                        break;
                    case 'harmonic':
                        // Harmonic enhancement and spectral shaping
                        this.applyHarmonicTransform(input, output);
                        break;
                    case 'texture':
                        // Granular and spectral effects
                        this.applyTextureTransform(input, output);
                        break;
                    case 'rhythm':
                        // Transient shaping and gating
                        this.applyRhythmTransform(input, output);
                        break;
                }
                
                return transformed;
            }
            
            applyBassTransform(input, output) {
                // Simple lowpass filter
                let prev = 0;
                const cutoff = 0.1;
                
                for (let i = 0; i < input.length; i++) {
                    // Lowpass
                    output[i] = prev + cutoff * (input[i] - prev);
                    prev = output[i];
                    
                    // Soft clipping
                    output[i] = Math.tanh(output[i] * 3);
                    
                    // Boost
                    output[i] *= 2;
                }
            }
            
            applyHarmonicTransform(input, output) {
                // Spectral enhancement
                for (let i = 0; i < input.length; i++) {
                    output[i] = input[i];
                    
                    // Add harmonics
                    if (i >= 2) {
                        output[i] += input[i-1] * 0.3;
                        output[i] += input[i-2] * 0.1;
                    }
                    
                    // Gentle saturation
                    output[i] = Math.tanh(output[i] * 1.5) * 0.8;
                }
            }
            
            applyTextureTransform(input, output) {
                // Granular-style processing
                const grainSize = 64;
                
                for (let i = 0; i < input.length; i++) {
                    const grainPos = i % grainSize;
                    const window = 0.5 - 0.5 * Math.cos(2 * Math.PI * grainPos / grainSize);
                    
                    // Random grain reversal
                    const reversed = Math.random() < 0.3;
                    const samplePos = reversed ? 
                        Math.max(0, i - grainPos * 2 + grainSize) : i;
                    
                    output[i] = input[Math.min(samplePos, input.length - 1)] * window;
                }
            }
            
            applyRhythmTransform(input, output) {
                // Transient enhancement and gating
                const threshold = 0.1;
                const attack = 0.001;
                const release = 0.01;
                
                let envelope = 0;
                
                for (let i = 0; i < input.length; i++) {
                    const rectified = Math.abs(input[i]);
                    
                    if (rectified > envelope) {
                        envelope += (rectified - envelope) * attack;
                    } else {
                        envelope += (rectified - envelope) * release;
                    }
                    
                    // Gate
                    if (envelope > threshold) {
                        output[i] = input[i] * 2;
                    } else {
                        output[i] = 0;
                    }
                }
            }
            
            updatePerformanceState() {
                // Update energy levels
                this.performance.energy = Math.min(1, this.performance.energy + 0.05);
                this.performance.tension = Math.min(1, this.performance.tension + 0.03);
                this.performance.harmonicEnergy = this.calculateHarmonicEnergy();
                this.performance.crowdEnergy = this.calculateCrowdEnergy();
                
                // Update narrative
                this.updateNarrative();
                
                // Update UI
                this.updateEnergyMeters();
                
                // Trigger performance events
                this.checkPerformanceEvents();
            }
            
            calculateHarmonicEnergy() {
                // Based on spectral content and harmonic relationships
                const harmonicSamples = this.tracks.harmonic.samples.length;
                const recentHarmonics = Math.min(1, harmonicSamples / 10);
                
                return recentHarmonics * 0.5 + this.spectralMemory.centroid / 10000 * 0.5;
            }
            
            calculateCrowdEnergy() {
                // Simulated crowd response based on performance
                const base = this.performance.energy * 0.4;
                const motion = Math.min(1, Math.abs(this.motion.vx) + Math.abs(this.motion.vy)) * 0.3;
                const tension = this.performance.tension * 0.3;
                
                return base + motion + tension;
            }
            
            updateNarrative() {
                // DJ set narrative arc
                const totalSamples = Object.keys(this.tracks).reduce(
                    (sum, track) => sum + this.tracks[track].samples.length, 0
                );
                
                if (totalSamples < 10) {
                    this.performance.mode = 'INTRO';
                    this.performance.narrative.arc = 'building';
                } else if (totalSamples < 30) {
                    this.performance.mode = 'BUILD UP';
                    this.performance.narrative.arc = 'rising';
                } else if (totalSamples < 50) {
                    this.performance.mode = 'PEAK TIME';
                    this.performance.narrative.arc = 'peak';
                } else if (totalSamples < 70) {
                    this.performance.mode = 'BREAKDOWN';
                    this.performance.narrative.arc = 'breakdown';
                } else {
                    this.performance.mode = 'OUTRO';
                    this.performance.narrative.arc = 'outro';
                }
                
                this.ui.performanceMode.textContent = this.performance.mode;
            }
            
            updateEnergyMeters() {
                document.getElementById('tension-fill').style.height = 
                    (this.performance.tension * 100) + '%';
                document.getElementById('harmonic-fill').style.height = 
                    (this.performance.harmonicEnergy * 100) + '%';
                document.getElementById('crowd-fill').style.height = 
                    (this.performance.crowdEnergy * 100) + '%';
            }
            
            checkPerformanceEvents() {
                // Trigger special events based on performance state
                if (this.performance.tension > 0.8 && Math.random() < 0.1) {
                    this.triggerDrop();
                }
                
                if (this.performance.crowdEnergy > 0.9 && Math.random() < 0.05) {
                    this.triggerBuildUp();
                }
            }
            
            triggerDrop() {
                // Epic drop sequence
                const now = this.audioContext.currentTime;
                
                // Kill all frequencies except sub
                this.performance.eqKills.mid = true;
                this.performance.eqKills.high = true;
                
                // Ramp down
                this.masterGain.gain.exponentialRampToValueAtTime(0.1, now + 0.5);
                
                // Wait...
                setTimeout(() => {
                    // Drop!
                    this.performance.eqKills.mid = false;
                    this.performance.eqKills.high = false;
                    
                    this.masterGain.gain.cancelScheduledValues(this.audioContext.currentTime);
                    this.masterGain.gain.setValueAtTime(0.1, this.audioContext.currentTime);
                    this.masterGain.gain.exponentialRampToValueAtTime(1, this.audioContext.currentTime + 0.05);
                    
                    // Trigger all tracks
                    Object.keys(this.tracks).forEach(track => {
                        if (this.tracks[track].active) {
                            this.triggerTrackSample(track, this.tracks[track].active);
                        }
                    });
                    
                    // Visual explosion
                    this.createVisualExplosion();
                }, 500);
            }
            
            triggerBuildUp() {
                // Build up sequence
                const now = this.audioContext.currentTime;
                
                // Automate filter sweep
                Object.keys(this.tracks).forEach(track => {
                    this.tracks[track].filter.frequency.cancelScheduledValues(now);
                    this.tracks[track].filter.frequency.setValueAtTime(200, now);
                    this.tracks[track].filter.frequency.exponentialRampToValueAtTime(20000, now + 4);
                });
                
                // Increase reverb
                this.sendBuses.reverb.gain.linearRampToValueAtTime(0.7, now + 4);
                
                // Speed up slightly
                this.rhythmEngine.targetBpm = Math.min(130, this.rhythmEngine.bpm + 5);
            }
            
            updateNeuralNetwork(input) {
                // Simulate neural processing
                const inputLayer = this.neuralNet.neurons[0];
                
                // Map audio to input neurons
                for (let i = 0; i < inputLayer.length; i++) {
                    const sampleIndex = Math.floor(i * input.length / inputLayer.length);
                    inputLayer[i].activation = Math.tanh(input[sampleIndex] * 10);
                }
                
                // Forward propagation
                for (let l = 0; l < this.neuralNet.layers - 1; l++) {
                    const currentLayer = this.neuralNet.neurons[l];
                    const nextLayer = this.neuralNet.neurons[l + 1];
                    
                    // Reset next layer
                    nextLayer.forEach(neuron => neuron.activation = 0);
                    
                    // Propagate activations
                    currentLayer.forEach((neuron, i) => {
                        nextLayer.forEach((nextNeuron, j) => {
                            const connection = this.neuralNet.connections[l].find(
                                c => c.from === i && c.to === j
                            );
                            if (connection) {
                                nextNeuron.activation += neuron.activation * connection.weight;
                            }
                        });
                    });
                    
                    // Apply activation function
                    nextLayer.forEach(neuron => {
                        neuron.activation = Math.tanh(neuron.activation + neuron.bias);
                    });
                }
                
                // Update visual synapses
                this.updateNeuralVisuals();
            }
            
            updateNeuralVisuals() {
                const synapses = this.ui.neuralPathway.querySelectorAll('.synapse');
                const outputLayer = this.neuralNet.neurons[this.neuralNet.layers - 1];
                
                synapses.forEach((synapse, i) => {
                    if (i < outputLayer.length) {
                        const activation = Math.abs(outputLayer[i].activation);
                        synapse.style.opacity = activation;
                        synapse.style.transform = `scale(${1 + activation})`;
                    }
                });
            }
            
            detectGesture() {
                if (this.motion.history.length < 10) return;
                
                const recent = this.motion.history.slice(-10);
                
                // Detect circular motion
                let angleSum = 0;
                for (let i = 1; i < recent.length; i++) {
                    const dx = recent[i].x - recent[i-1].x;
                    const dy = recent[i].y - recent[i-1].y;
                    angleSum += Math.atan2(dy, dx);
                }
                
                if (Math.abs(angleSum) > Math.PI) {
                    this.motion.gesture = 'circle';
                    this.applyCircularGesture();
                }
                
                // Detect scratch motion
                const velocityChanges = recent.map((h, i) => 
                    i > 0 ? Math.abs(h.vx - recent[i-1].vx) + Math.abs(h.vy - recent[i-1].vy) : 0
                ).reduce((a, b) => a + b);
                
                if (velocityChanges > 10) {
                    this.motion.gesture = 'scratch';
                    this.applyScratchGesture();
                }
            }
            
            applyCircularGesture() {
                // Circular motion creates filter sweep
                const now = this.audioContext.currentTime;
                const centerX = 0.5;
                const centerY = 0.5;
                const radius = Math.sqrt(
                    Math.pow(this.motion.x - centerX, 2) + 
                    Math.pow(this.motion.y - centerY, 2)
                );
                
                // Map radius to filter frequency
                const freq = 200 + radius * 10000;
                
                Object.keys(this.tracks).forEach(track => {
                    this.tracks[track].filter.frequency.cancelScheduledValues(now);
                    this.tracks[track].filter.frequency.setTargetAtTime(freq, now, 0.1);
                });
            }
            
            applyScratchGesture() {
                // Scratch motion creates glitch effects
                this.fx.bitCrusher.setBits(Math.floor(Math.random() * 8 + 2));
                this.fx.bitCrusher.setFreq(Math.random() * 0.5 + 0.1);
                
                // Temporary gate pattern
                this.fx.gateSequencer.pattern = Array(8).fill(0).map(() => Math.random() > 0.3 ? 1 : 0);
            }
            
            showQuantumProcess() {
                this.ui.processIndicator.classList.add('active');
                this.ui.processIndicator.style.left = (this.motion.x * window.innerWidth) + 'px';
                this.ui.processIndicator.style.top = (this.motion.y * window.innerHeight) + 'px';
                
                // Flash neural rings
                this.flashNeuralRings();
                
                setTimeout(() => {
                    this.ui.processIndicator.classList.remove('active');
                }, 500);
            }
            
            flashNeuralRings() {
                const rings = this.ui.brain.querySelectorAll('.synaptic-ring');
                rings.forEach(ring => {
                    ring.classList.add('processing');
                    setTimeout(() => ring.classList.remove('processing'), 500);
                });
            }
            
            updateQuantumParameters() {
                // Update parameter displays
                document.getElementById('spectralCentroid').textContent = 
                    Math.round(this.spectralMemory.centroid);
                document.getElementById('spectralFlux').textContent = 
                    this.spectralMemory.flux.toFixed(2);
                document.getElementById('spectralRolloff').textContent = 
                    Math.round(this.spectralMemory.rolloff);
                
                document.getElementById('grooveCoeff').textContent = 
                    this.rhythmEngine.groove.toFixed(2);
                document.getElementById('swingAmount').textContent = 
                    this.rhythmEngine.swing.toFixed(2);
                document.getElementById('polyrhythm').textContent = 
                    `${this.rhythmEngine.polyrhythms[0]}:4`;
                
                document.getElementById('morphRate').textContent = 
                    (this.performance.energy * this.performance.tension).toFixed(2);
                document.getElementById('quantumCoherence').textContent = 
                    this.quantumState.coherence.toFixed(2);
                document.getElementById('dimensionShift').textContent = 
                    this.quantumState.dimension;
                
                // Update FX parameters
                document.getElementById('fx-gate-freq').textContent = 
                    Math.round(this.fx.spectralGate.bands[0].filter.frequency.value);
                document.getElementById('fx-gate-res').textContent = 
                    Math.round(this.fx.spectralGate.bands[0].filter.Q.value);
                document.getElementById('fx-delay-time').textContent = 
                    this.fx.tapDelay.delays[0].delay.delayTime.value.toFixed(2);
                document.getElementById('fx-delay-feed').textContent = 
                    this.fx.tapDelay.delays[0].feedback.gain.value.toFixed(1);
                document.getElementById('fx-verb-size').textContent = 
                    this.sendBuses.reverb.gain.value.toFixed(1);
                document.getElementById('fx-verb-decay').textContent = '4.0';
            }
            
            updateTrackLane(trackName, buffer) {
                const lane = document.querySelector(`[data-track="${Object.keys(this.tracks).indexOf(trackName)}"]`);
                if (!lane) return;
                
                const canvas = lane.querySelector('.track-waveform');
                const ctx = canvas.getContext('2d');
                
                // Create visual block for the sample
                const block = document.createElement('div');
                block.className = 'sample-block';
                block.style.left = (Math.random() * 80) + '%';
                block.style.width = (buffer.duration / 4 * 100) + '%'; // Relative to 4 seconds
                
                lane.appendChild(block);
                
                // Animate block
                setTimeout(() => block.classList.add('playing'), 100);
                
                // Draw waveform
                this.drawWaveform(ctx, buffer);
                
                // Remove after playing
                setTimeout(() => {
                    block.classList.remove('playing');
                    setTimeout(() => block.remove(), 1000);
                }, buffer.duration * 1000);
            }
            
            updateTrackVisual(trackName) {
                const trackIndex = Object.keys(this.tracks).indexOf(trackName);
                const lane = document.querySelector(`[data-track="${trackIndex}"]`);
                if (!lane) return;
                
                // Flash lane
                lane.style.borderColor = 'rgba(0, 255, 255, 0.8)';
                lane.style.boxShadow = '0 0 20px rgba(0, 255, 255, 0.6)';
                
                setTimeout(() => {
                    lane.style.borderColor = '';
                    lane.style.boxShadow = '';
                }, 200);
            }
            
            drawWaveform(ctx, buffer) {
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const data = buffer.getChannelData(0);
                
                ctx.clearRect(0, 0, width, height);
                ctx.strokeStyle = 'rgba(0, 255, 255, 0.6)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                for (let i = 0; i < width; i++) {
                    const min = Math.min(...data.slice(i * step, (i + 1) * step));
                    const max = Math.max(...data.slice(i * step, (i + 1) * step));
                    
                    ctx.moveTo(i, amp * (1 - max));
                    ctx.lineTo(i, amp * (1 - min));
                }
                
                ctx.stroke();
            }
            
            createVisualExplosion() {
                // Create particle explosion
                for (let i = 0; i < 100; i++) {
                    const angle = (Math.PI * 2 * i) / 100;
                    const velocity = 5 + Math.random() * 10;
                    
                    this.visuals.particles.push({
                        x: window.innerWidth / 2,
                        y: window.innerHeight / 2,
                        vx: Math.cos(angle) * velocity,
                        vy: Math.sin(angle) * velocity,
                        life: 1,
                        color: `hsl(${Math.random() * 60 + 180}, 100%, 50%)`,
                        size: Math.random() * 10 + 5
                    });
                }
            }
            
            makeDistortionCurve(amount) {
                const samples = 44100;
                const curve = new Float32Array(samples);
                
                for (let i = 0; i < samples; i++) {
                    const x = (i * 2) / samples - 1;
                    curve[i] = Math.tanh(x * amount);
                }
                
                return curve;
            }
            
            startPerformance() {
                // Start all systems
                this.fx.gateSequencer.start();
                
                // Start visualization
                this.animate();
                
                // Start AI thinking
                this.runQuantumAI();
                
                console.log('Quantum DJ System Online');
            }
            
            runQuantumAI() {
                const think = () => {
                    // Evolve quantum state
                    this.quantumState.coherence = 0.5 + 0.5 * Math.sin(Date.now() * 0.0001);
                    
                    // Evolve rhythm
                    this.rhythmEngine.groove = Math.sin(Date.now() * 0.0002) * 0.5 + 0.5;
                    this.rhythmEngine.swing = Math.cos(Date.now() * 0.0003) * 0.3;
                    
                    // Pattern evolution
                    if (Math.random() < 0.01) {
                        this.rhythmEngine.currentPattern = 
                            (this.rhythmEngine.currentPattern + 1) % this.rhythmEngine.patternBank.length;
                    }
                    
                    // Dimensional shift
                    if (Math.random() < 0.005) {
                        this.quantumState.dimension = (this.quantumState.dimension + 1) % 5;
                        this.applyDimensionalShift();
                    }
                    
                    // Energy decay
                    this.performance.energy *= 0.995;
                    this.performance.tension *= 0.993;
                    
                    // FX automation
                    this.automateFX();
                    
                    setTimeout(think, 100);
                };
                
                think();
            }
            
            applyDimensionalShift() {
                // Change entire sonic character based on dimension
                const dimensions = [
                    { name: 'DEEP', filter: 500, reverb: 0.8, delay: 0.1 },
                    { name: 'SPACE', filter: 2000, reverb: 0.9, delay: 0.4 },
                    { name: 'CRYSTAL', filter: 8000, reverb: 0.3, delay: 0.2 },
                    { name: 'QUANTUM', filter: 1000, reverb: 0.5, delay: 0.3 },
                    { name: 'VOID', filter: 200, reverb: 1.0, delay: 0.6 }
                ];
                
                const dim = dimensions[this.quantumState.dimension];
                const now = this.audioContext.currentTime;
                
                // Apply dimension parameters
                Object.keys(this.tracks).forEach(track => {
                    this.tracks[track].filter.frequency.exponentialRampToValueAtTime(
                        dim.filter, now + 2
                    );
                });
                
                this.sendBuses.reverb.gain.linearRampToValueAtTime(dim.reverb, now + 2);
                this.sendBuses.delay.gain.linearRampToValueAtTime(dim.delay, now + 2);
            }
            
            automateFX() {
                const now = this.audioContext.currentTime;
                
                // Spectral gate automation
                const gateFreq = 500 + Math.sin(now * 0.5) * 2000;
                this.fx.spectralGate.bands.forEach((band, i) => {
                    band.filter.frequency.setTargetAtTime(
                        gateFreq * (i + 1) / this.fx.spectralGate.bands.length,
                        now, 0.1
                    );
                });
                
                // Ring mod automation
                this.fx.ringMod.carrier.frequency.setTargetAtTime(
                    220 * Math.pow(2, Math.sin(now * 0.1) * 2),
                    now, 0.1
                );
                
                // Morph filter automation
                const morphPosition = (Math.sin(now * 0.05) + 1) / 2;
                this.fx.morphFilter.filters.forEach((f, i) => {
                    const targetGain = i === Math.floor(morphPosition * 4) ? 1 : 0;
                    f.gain.gain.setTargetAtTime(targetGain, now, 0.1);
                });
            }
            
            animate() {
                const canvases = {
                    spectrum: document.getElementById('spectrum-canvas'),
                    waveform: document.getElementById('waveform-canvas'),
                    particle: document.getElementById('particle-canvas'),
                    fractal: document.getElementById('fractal-canvas')
                };
                
                const contexts = {};
                Object.keys(canvases).forEach(key => {
                    contexts[key] = canvases[key].getContext('2d');
                });
                
                const draw = () => {
                    requestAnimationFrame(draw);
                    
                    // Clear canvases with trails
                    Object.values(contexts).forEach(ctx => {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                        ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                    });
                    
                    // Get audio data
                    if (this.analyzerL) {
                        this.analyzerL.getByteFrequencyData(this.spectralDataL);
                        this.analyzerR.getByteFrequencyData(this.spectralDataR);
                        
                        // Draw spectrum
                        this.drawSpectrum(contexts.spectrum);
                        
                        // Draw waveform
                        this.drawWaveformVisualization(contexts.waveform);
                    }
                    
                    // Update particles
                    this.updateParticles(contexts.particle);
                    
                    // Draw fractal background
                    this.drawFractal(contexts.fractal);
                };
                
                draw();
            }
            
            drawSpectrum(ctx) {
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const barWidth = width / this.spectralDataL.length * 2;
                
                for (let i = 0; i < this.spectralDataL.length / 2; i++) {
                    const valueL = this.spectralDataL[i] / 255;
                    const valueR = this.spectralDataR[i] / 255;
                    
                    const heightL = valueL * height / 2;
                    const heightR = valueR * height / 2;
                    
                    // Color based on frequency and energy
                    const hue = 280 - (i / this.spectralDataL.length) * 120;
                    const brightness = (valueL + valueR) * 50;
                    
                    ctx.fillStyle = `hsla(${hue}, 70%, ${brightness}%, 0.8)`;
                    
                    // Draw mirrored bars
                    ctx.fillRect(i * barWidth, height/2 - heightL, barWidth - 1, heightL);
                    ctx.fillRect(i * barWidth, height/2, barWidth - 1, heightR);
                }
            }
            
            drawWaveformVisualization(ctx) {
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                
                const timeData = new Uint8Array(this.analyzerL.frequencyBinCount);
                this.analyzerL.getByteTimeDomainData(timeData);
                
                ctx.strokeStyle = `rgba(0, 255, 255, ${0.3 + this.performance.energy * 0.5})`;
                ctx.lineWidth = 2 + this.performance.tension * 3;
                ctx.beginPath();
                
                const sliceWidth = width / timeData.length * 2;
                let x = 0;
                
                for (let i = 0; i < timeData.length; i++) {
                    const v = timeData[i] / 128.0;
                    const y = v * height / 2;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
                
                // Draw second waveform with phase shift
                ctx.strokeStyle = `rgba(255, 0, 255, ${0.2 + this.performance.harmonicEnergy * 0.3})`;
                ctx.beginPath();
                x = 0;
                
                for (let i = 0; i < timeData.length; i++) {
                    const v = timeData[(i + 100) % timeData.length] / 128.0;
                    const y = v * height / 2 + height / 4;
                    
                    if (i === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                    
                    x += sliceWidth;
                }
                
                ctx.stroke();
            }
            
            updateParticles(ctx) {
                // Add new particles based on energy
                if (Math.random() < this.performance.energy * 0.3) {
                    for (let i = 0; i < 3; i++) {
                        this.visuals.particles.push({
                            x: Math.random() * ctx.canvas.width,
                            y: ctx.canvas.height,
                            vx: (Math.random() - 0.5) * 4,
                            vy: -Math.random() * 10 - 5,
                            life: 1,
                            color: `hsl(${180 + Math.random() * 120}, 100%, 50%)`,
                            size: Math.random() * 5 + 2
                        });
                    }
                }
                
                // Update and draw particles
                for (let i = this.visuals.particles.length - 1; i >= 0; i--) {
                    const p = this.visuals.particles[i];
                    
                    // Physics
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.2; // Gravity
                    p.life -= 0.01;
                    
                    // Remove dead particles
                    if (p.life <= 0 || p.y > ctx.canvas.height) {
                        this.visuals.particles.splice(i, 1);
                        continue;
                    }
                    
                    // Draw
                    ctx.globalAlpha = p.life;
                    ctx.fillStyle = p.color;
                    ctx.shadowBlur = 20;
                    ctx.shadowColor = p.color;
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, p.size, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.shadowBlur = 0;
                    ctx.globalAlpha = 1;
                }
            }
            
            drawFractal(ctx) {
                // Simple fractal pattern based on audio
                const width = ctx.canvas.width;
                const height = ctx.canvas.height;
                const time = Date.now() * 0.0001;
                
                ctx.strokeStyle = `rgba(138, 43, 226, ${0.1 * this.quantumState.coherence})`;
                ctx.lineWidth = 1;
                
                for (let i = 0; i < 5; i++) {
                    const scale = 1 + i * 0.5;
                    const rotation = time * (i + 1) * 0.1;
                    
                    ctx.save();
                    ctx.translate(width / 2, height / 2);
                    ctx.rotate(rotation);
                    ctx.scale(scale, scale);
                    
                    ctx.beginPath();
                    for (let j = 0; j < 6; j++) {
                        const angle = (Math.PI * 2 * j) / 6;
                        const x = Math.cos(angle) * 100;
                        const y = Math.sin(angle) * 100;
                        
                        if (j === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    ctx.closePath();
                    ctx.stroke();
                    
                    ctx.restore();
                }
            }
        }
        
        // Initialize Quantum DJ
        const quantumDJ = new QuantumDJ();
    </script>
</body>
</html>
