<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP: Enhanced Cinematic Void Engine</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      background: #0a0a0a;
      color: #fff;
      overflow: hidden;
      touch-action: none;
      height: 100vh;
      font-family: 'Courier New', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .start-screen {
      text-align: center;
      z-index: 100;
    }
    
    .start-btn {
      width: 180px;
      height: 180px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,255,255,0.08) 0%, transparent 70%);
      border: 1px solid rgba(255,255,255,0.2);
      color: #fff;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: bold;
      letter-spacing: 3px;
      backdrop-filter: blur(15px);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }
    
    .start-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: radial-gradient(circle, rgba(255,255,255,0.15) 0%, transparent 70%);
      transform: scale(1.1);
    }
    
    .evolution-space {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      opacity: 0;
      transition: opacity 3s ease;
    }
    
    .evolution-space.active { opacity: 1; }
    
    .orb {
      position: absolute;
      width: 35px;
      height: 35px;
      border-radius: 50%;
      background: radial-gradient(circle, #fff 0%, rgba(255,255,255,0.4) 40%, transparent 80%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      box-shadow: 0 0 60px rgba(255,255,255,0.6);
      backdrop-filter: blur(8px);
      filter: drop-shadow(0 0 20px rgba(255,255,255,0.3));
    }
    
    .orb.pulse {
      transform: translate(-50%, -50%) scale(1.5);
    }
    
    .orb.void {
      opacity: 0.5;
      box-shadow: 0 0 100px rgba(255,215,0,0.6);
      filter: drop-shadow(0 0 40px rgba(255,215,0,0.4));
    }
    
    .ui-minimal {
      position: fixed;
      top: 15px;
      left: 15px;
      font-size: 9px;
      color: rgba(255,255,255,0.6);
      font-weight: normal;
      letter-spacing: 1px;
      background: rgba(0,0,0,0.2);
      padding: 8px 12px;
      border-radius: 4px;
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255,255,255,0.1);
    }
    
    .stage-name {
      font-size: 11px;
      color: rgba(255,255,255,0.9);
      margin-bottom: 4px;
      font-weight: bold;
    }
    
    .metric {
      margin: 2px 0;
      font-size: 8px;
    }
    
    .hidden { display: none !important; }
    
    .instruction {
      position: fixed;
      top: 60%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 12px;
      color: rgba(255,255,255,0.5);
      text-align: center;
      letter-spacing: 2px;
      opacity: 0;
      transition: opacity 3s ease;
      font-weight: normal;
    }
    
    .instruction.show { opacity: 1; }

    .cinematic-overlay {
      position: fixed;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
      background: radial-gradient(circle at center, transparent 20%, rgba(0,0,0,0.7) 100%);
      opacity: 0;
      transition: opacity 4s ease;
      z-index: 2;
    }
    
    .cinematic-overlay.active { opacity: 1; }
    
    .waveform {
      position: fixed;
      bottom: 0;
      left: 0;
      width: 100%;
      height: 60px;
      pointer-events: none;
      z-index: 3;
      opacity: 0.6;
    }
    
    .wave-bar {
      position: absolute;
      bottom: 0;
      width: 16px;
      background: linear-gradient(0deg, rgba(255,255,255,0.6), rgba(255,255,255,0.1));
      border-radius: 2px 2px 0 0;
      transition: height 0.08s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    }

    .impact-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255,255,255,0.1);
      opacity: 0;
      pointer-events: none;
      z-index: 10;
    }

    .impact-flash.active {
      opacity: 1;
      transition: opacity 0.15s ease-out;
    }
  </style>
</head>
<body>
  <div class="start-screen" id="startScreen">
    <div class="start-btn" id="startBtn">
      AWAKEN
    </div>
  </div>
  
  <div class="evolution-space" id="evolutionSpace">
    <div class="orb" id="orb"></div>
    
    <div class="instruction" id="instruction">MOVE TO UNRAVEL THE VOID</div>
    
    <div class="ui-minimal" id="uiMinimal">
      <div class="stage-name" id="stageName">SILENCE</div>
      <div class="metric">BPM: <span id="bpmDisplay">60</span> | INTENSITY: <span id="intensityDisplay">0%</span></div>
    </div>
    
    <div class="waveform" id="waveform"></div>
  </div>

  <div class="cinematic-overlay" id="cinematicOverlay"></div>
  <div class="impact-flash" id="impactFlash"></div>

  <script>
    class EnhancedVoidEngine {
      constructor() {
        this.ctx = null;
        this.active = false;
        this.analyser = null;
        this.dataArray = null;
        
        this.bpm = 60;
        this.step = 0;
        
        this.motion = 0;
        this.intensity = 0;
        this.pos = { x: 50, y: 50 };
        this.velocity = { x: 0, y: 0 };
        this.lastAccel = { x: 0, y: 0, z: 0 };
        this.motionHistory = [];
        this.firstMovement = false;
        this.noMotionCounter = 0;
        this.isVoid = false;
        
        this.stage = 'SILENCE';
        this.totalMotion = 0;
        
        this.masterGain = null;
        this.limiter = null;
        this.compressor = null;
        this.masterEQ = null;
        this.reverb = null;
        this.delay = null;
        
        this.listener = null;
        this.orientation = { alpha: 0, beta: 0, gamma: 0 };
        
        this.layers = ['strings', 'sineOverlay', 'drums', 'ambient', 'healing'];
        this.layerGains = {};
        this.layerCompressors = {};
        this.layerEQs = {};
        this.layerPanners = {};
        this.layerFilters = {};
        
        this.key = 'C';
        this.mode = 'major';
        this.scale = [0, 2, 4, 5, 7, 9, 11];
        this.chordProgression = [[0, 4, 7], [5, 9, 0], [7, 11, 2], [0, 4, 7]];
        this.currentChordIndex = 0;
        
        this.healingFrequencies = [174, 285, 396, 417, 528, 639, 741, 852, 963];
        
        this.ambientNoise = null;
        this.ambientGain = null;
        this.ambientFilter = null;
        
        this.elements = {};
        this.waveBars = [];
        
        this.init();
      }

      init() {
        ['startScreen', 'startBtn', 'evolutionSpace', 'orb', 'instruction',
         'stageName', 'bpmDisplay', 'intensityDisplay', 'uiMinimal',
         'cinematicOverlay', 'waveform', 'impactFlash']
        .forEach(id => this.elements[id] = document.getElementById(id));
        
        this.elements.startBtn.onclick = () => this.start();
        this.setupMotionDetection();
        this.setupOrientationDetection();
        this.setupWaveformVisualizer();
      }

      setupWaveformVisualizer() {
        for (let i = 0; i < 16; i++) {
          const bar = document.createElement('div');
          bar.className = 'wave-bar';
          bar.style.left = (i * (100 / 16)) + '%';
          bar.style.width = (100 / 16) + '%';
          bar.style.height = '0px';
          this.elements.waveform.appendChild(bar);
          this.waveBars.push(bar);
        }
      }

      setupOrientationDetection() {
        window.addEventListener('deviceorientation', e => {
          if (!this.active) return;
          this.orientation.alpha = e.alpha || 0;
          this.orientation.beta = e.beta || 0;
          this.orientation.gamma = e.gamma || 0;
          this.updateListenerOrientation();
        });
      }

      updateListenerOrientation() {
        if (!this.listener) return;
        const now = this.ctx.currentTime;
        const forwardX = Math.cos(this.orientation.alpha * Math.PI / 180) * Math.cos(this.orientation.beta * Math.PI / 180);
        const forwardY = Math.sin(this.orientation.alpha * Math.PI / 180) * Math.cos(this.orientation.beta * Math.PI / 180);
        const forwardZ = Math.sin(this.orientation.beta * Math.PI / 180);
        const upX = Math.sin(this.orientation.gamma * Math.PI / 180);
        const upY = Math.cos(this.orientation.gamma * Math.PI / 180);
        const upZ = 0;
        
        this.listener.forwardX.linearRampToValueAtTime(forwardX, now + 0.05);
        this.listener.forwardY.linearRampToValueAtTime(forwardY, now + 0.05);
        this.listener.forwardZ.linearRampToValueAtTime(forwardZ, now + 0.05);
        this.listener.upX.linearRampToValueAtTime(upX, now + 0.05);
        this.listener.upY.linearRampToValueAtTime(upY, now + 0.05);
        this.listener.upZ.linearRampToValueAtTime(upZ, now + 0.05);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent.requestPermission === 'function') {
            await DeviceMotionEvent.requestPermission();
          }
          if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            await DeviceOrientationEvent.requestPermission();
          }

          this.ctx = new AudioContext();
          await this.ctx.resume();
          this.setupAudioChain();
          this.setupAmbientBackground();
          this.setLayerPositions();

          this.elements.startScreen.classList.add('hidden');
          this.elements.evolutionSpace.classList.add('active');
          
          setTimeout(() => {
            this.elements.instruction.classList.add('show');
            setTimeout(() => this.elements.instruction.classList.remove('show'), 5000);
          }, 1500);

          this.active = true;
          this.startSequencer();
          this.animate();
        } catch (e) {
          console.error('Failed to start engine:', e);
        }
      }

      setupAudioChain() {
        this.analyser = this.ctx.createAnalyser();
        this.analyser.fftSize = 1024;
        this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
        
        this.limiter = this.ctx.createDynamicsCompressor();
        this.limiter.threshold.value = -6;
        this.limiter.knee.value = 5;
        this.limiter.ratio.value = 20;
        this.limiter.attack.value = 0.003;
        this.limiter.release.value = 0.1;
        
        this.compressor = this.ctx.createDynamicsCompressor();
        this.compressor.threshold.value = -24;
        this.compressor.knee.value = 12;
        this.compressor.ratio.value = 8;
        this.compressor.attack.value = 0.005;
        this.compressor.release.value = 0.2;
        
        this.masterEQ = this.createMultibandEQ();
        
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.85;
        
        this.reverb = this.ctx.createConvolver();
        this.reverb.buffer = this.createReverbBuffer(3);
        const reverbGain = this.ctx.createGain();
        reverbGain.gain.value = 0.25;
        this.reverb.connect(reverbGain);
        reverbGain.connect(this.compressor);
        
        this.delay = this.ctx.createDelay(1);
        this.delay.delayTime.value = 0.4;
        const delayFeedback = this.ctx.createGain();
        delayFeedback.gain.value = 0.35;
        const delayFilter = this.ctx.createBiquadFilter();
        delayFilter.type = 'lowpass';
        delayFilter.frequency.value = 3000;
        delayFilter.Q.value = 1;
        this.delay.connect(delayFilter);
        delayFilter.connect(delayFeedback);
        delayFeedback.connect(this.delay);
        const delayMix = this.ctx.createGain();
        delayMix.gain.value = 0.15;
        this.delay.connect(delayMix);
        delayMix.connect(this.compressor);
        
        this.listener = this.ctx.listener;
        
        this.layers.forEach(layer => {
          this.layerGains[layer] = this.ctx.createGain();
          this.layerCompressors[layer] = this.ctx.createDynamicsCompressor();
          this.layerEQs[layer] = this.createLayerEQ(layer);
          this.layerPanners[layer] = this.ctx.createPanner();
          this.layerPanners[layer].panningModel = 'HRTF';
          this.layerPanners[layer].distanceModel = 'inverse';
          this.layerPanners[layer].refDistance = 1;
          this.layerPanners[layer].maxDistance = 10000;
          this.layerPanners[layer].rolloffFactor = 1.5;
          this.layerPanners[layer].coneInnerAngle = 60;
          this.layerPanners[layer].coneOuterAngle = 120;
          this.layerPanners[layer].coneOuterGain = -6;
          
          this.layerFilters[layer] = this.ctx.createBiquadFilter();
          this.layerFilters[layer].type = 'lowpass';
          this.layerFilters[layer].frequency.value = 20000;
          this.layerFilters[layer].Q.value = 0.7;
          
          this.layerGains[layer].connect(this.layerFilters[layer]);
          this.layerFilters[layer].connect(this.layerCompressors[layer]);
          this.layerCompressors[layer].connect(this.layerEQs[layer]);
          this.layerEQs[layer].connect(this.layerPanners[layer]);
          this.layerPanners[layer].connect(this.compressor);
          
          if (['strings', 'sineOverlay', 'ambient', 'healing'].includes(layer)) {
            const revSend = this.ctx.createGain();
            revSend.gain.value = layer === 'ambient' ? 0.4 : 0.3;
            this.layerPanners[layer].connect(revSend);
            revSend.connect(this.reverb);
          }
          
          if (['sineOverlay', 'healing'].includes(layer)) {
            const delSend = this.ctx.createGain();
            delSend.gain.value = 0.2;
            this.layerPanners[layer].connect(delSend);
            delSend.connect(this.delay);
          }
        });
        
        this.compressor.connect(this.masterEQ);
        this.masterEQ.connect(this.limiter);
        this.limiter.connect(this.analyser);
        this.analyser.connect(this.masterGain);
        this.masterGain.connect(this.ctx.destination);
      }

      createMultibandEQ() {
        const eq = this.ctx.createGain();
        const low = this.ctx.createBiquadFilter();
        low.type = 'lowshelf';
        low.frequency.value = 120;
        low.gain.value = 1;
        
        const midLow = this.ctx.createBiquadFilter();
        midLow.type = 'peaking';
        midLow.frequency.value = 400;
        midLow.Q.value = 0.8;
        midLow.gain.value = 0.5;
        
        const midHigh = this.ctx.createBiquadFilter();
        midHigh.type = 'peaking';
        midHigh.frequency.value = 2500;
        midHigh.Q.value = 0.8;
        midHigh.gain.value = 1;
        
        const high = this.ctx.createBiquadFilter();
        high.type = 'highshelf';
        high.frequency.value = 8000;
        high.gain.value = 2;
        
        eq.connect(low);
        low.connect(midLow);
        midLow.connect(midHigh);
        midHigh.connect(high);
        
        return eq;
      }

      createLayerEQ(layer) {
        const eq = this.ctx.createGain();
        let low = this.ctx.createBiquadFilter();
        low.type = 'lowshelf';
        low.frequency.value = 200;
        low.gain.value = layer === 'drums' ? 4 : layer === 'ambient' ? -2 : 0;
        
        let mid = this.ctx.createBiquadFilter();
        mid.type = 'peaking';
        mid.frequency.value = 1000;
        mid.Q.value = 1;
        mid.gain.value = layer === 'strings' ? 2 : layer === 'sineOverlay' ? -1 : 0;
        
        let high = this.ctx.createBiquadFilter();
        high.type = 'highshelf';
        high.frequency.value = 5000;
        high.gain.value = layer === 'healing' ? 3 : layer === 'drums' ? -3 : 1;
        
        eq.connect(low);
        low.connect(mid);
        mid.connect(high);
        
        return eq;
      }

      createReverbBuffer(length) {
        const buffer = this.ctx.createBuffer(2, this.ctx.sampleRate * length, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          const data = buffer.getChannelData(c);
          for (let i = 0; i < data.length; i++) {
            data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / data.length, 3);
          }
        }
        return buffer;
      }

      setupAmbientBackground() {
        const bufferSize = this.ctx.sampleRate * 2;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        let last = 0;
        for (let i = 0; i < bufferSize; i++) {
          const white = Math.random() * 2 - 1;
          data[i] = (last + (0.02 * white)) / 1.02;
          last = data[i];
          data[i] *= 3.5;
        }
        
        this.ambientNoise = this.ctx.createBufferSource();
        this.ambientNoise.buffer = buffer;
        this.ambientNoise.loop = true;
        
        this.ambientFilter = this.ctx.createBiquadFilter();
        this.ambientFilter.type = 'lowpass';
        this.ambientFilter.frequency.value = 400;
        this.ambientFilter.Q.value = 0.5;
        
        this.ambientGain = this.ctx.createGain();
        this.ambientGain.gain.value = 0.1;
        
        this.ambientNoise.connect(this.ambientFilter);
        this.ambientFilter.connect(this.ambientGain);
        this.ambientGain.connect(this.layerGains.ambient);
        this.ambientNoise.start();
      }

      setLayerPositions() {
        const positions = {
          strings: { x: 0, y: 0, z: -5 },
          sineOverlay: { x: 0, y: 2, z: -3 },
          drums: { x: 0, y: -1, z: -2 },
          ambient: { x: 0, y: 5, z: 10 },
          healing: { x: 0, y: 3, z: 8 }
        };
        
        Object.entries(positions).forEach(([layer, pos]) => {
          this.layerPanners[layer].positionX.value = pos.x;
          this.layerPanners[layer].positionY.value = pos.y;
          this.layerPanners[layer].positionZ.value = pos.z;
        });
      }

      setupMotionDetection() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          
          const acc = e.accelerationIncludingGravity;
          if (!acc) return;
          
          const dx = Math.abs(acc.x - this.lastAccel.x);
          const dy = Math.abs(acc.y - this.lastAccel.y);
          const dz = Math.abs(acc.z - this.lastAccel.z);
          
          const newMotion = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.motion = this.motion * 0.85 + newMotion * 0.15;
          this.motionHistory.push(this.motion);
          if (this.motionHistory.length > 30) this.motionHistory.shift();
          
          this.intensity = this.motionHistory.reduce((sum, m) => sum + m, 0) / this.motionHistory.length;
          
          this.velocity.x += acc.x * 0.02;
          this.velocity.y += acc.y * 0.02;
          this.pos.x = Math.clamp(this.pos.x + this.velocity.x, 0, 100);
          this.pos.y = Math.clamp(this.pos.y + this.velocity.y, 0, 100);
          this.velocity.x *= 0.9;
          this.velocity.y *= 0.9;
          
          this.lastAccel = { x: acc.x || 0, y: acc.y || 0, z: acc.z || 0 };
          
          if (this.motion > 1 && !this.firstMovement) {
            this.firstMovement = true;
            this.stage = 'ACTIVE';
          }
          
          if (this.motion > 5) {
            this.triggerDrums();
          }
          
          if (this.motion < 0.5) {
            this.noMotionCounter++;
            if (this.noMotionCounter > 50) this.enterVoid();
          } else {
            this.noMotionCounter = 0;
            if (this.isVoid) this.exitVoid();
          }
          
          this.updateAmbient();
        });
        
        // Mouse fallback
        let lastMouse = { x: 0, y: 0, time: 0 };
        window.addEventListener('mousemove', e => {
          if (!this.active) return;
          const dt = Date.now() - lastMouse.time || 1;
          const dx = (e.clientX - lastMouse.x) / dt * 10;
          const dy = (e.clientY - lastMouse.y) / dt * 10;
          const newMotion = Math.sqrt(dx*dx + dy*dy);
          this.motion = this.motion * 0.85 + newMotion * 0.15;
          lastMouse = { x: e.clientX, y: e.clientY, time: Date.now() };
          this.pos.x = (e.clientX / window.innerWidth) * 100;
          this.pos.y = (e.clientY / window.innerHeight) * 100;
        });
      }

      startSequencer() {
        const tick = () => {
          if (!this.active) return;
          this.playStep();
          this.updateUI();
          this.step = (this.step + 1) % 16;
          const interval = 60000 / this.bpm / 4;
          setTimeout(tick, interval);
        };
        tick();
      }

      playStep() {
        const now = this.ctx.currentTime;
        if (this.isVoid) {
          this.playHealing(now);
        } else {
          this.playStrings(now);
          this.playSineOverlay(now);
        }
      }

      playStrings(now) {
        // Karplus-Strong for strings
        const freq = this.noteToFreq(this.chordProgression[this.currentChordIndex][0], 3);
        const delayTime = 1 / freq;
        const bufferSize = this.ctx.sampleRate * delayTime;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
          data[i] = Math.random() * 2 - 1;
        }
        
        const source = this.ctx.createBufferSource();
        source.buffer = buffer;
        source.loop = true;
        
        const delay = this.ctx.createDelay(delayTime);
        delay.delayTime.value = delayTime;
        
        const feedback = this.ctx.createGain();
        feedback.gain.value = 0.995;
        
        const lowpass = this.ctx.createBiquadFilter();
        lowpass.type = 'lowpass';
        lowpass.frequency.value = freq * 2;
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.6, now + 0.5);
        env.gain.exponentialRampToValueAtTime(0.001, now + 8);
        
        source.connect(lowpass);
        lowpass.connect(delay);
        delay.connect(feedback);
        feedback.connect(lowpass);
        delay.connect(env);
        env.connect(this.layerGains.strings);
        
        source.start(now);
        setTimeout(() => source.stop(), 8000);
      }

      playSineOverlay(now) {
        const chord = this.chordProgression[this.currentChordIndex];
        chord.forEach((note, i) => {
          const freq = this.noteToFreq(note, 4 + i);
          const osc = this.ctx.createOscillator();
          osc.type = 'sine';
          osc.frequency.value = freq;
          
          const env = this.ctx.createGain();
          env.gain.setValueAtTime(0, now);
          env.gain.linearRampToValueAtTime(0.3, now + 1);
          env.gain.exponentialRampToValueAtTime(0.001, now + 6);
          
          osc.connect(env);
          env.connect(this.layerGains.sineOverlay);
          osc.start(now);
          osc.stop(now + 6);
        });
        this.currentChordIndex = (this.currentChordIndex + 1) % this.chordProgression.length;
      }

      triggerDrums() {
        const now = this.ctx.currentTime;
        const kickFreq = 60 + this.motion * 5;
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.setValueAtTime(kickFreq * 3, now);
        osc.frequency.exponentialRampToValueAtTime(kickFreq, now + 0.05);
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(1, now);
        env.gain.exponentialRampToValueAtTime(0.001, now + 0.3);
        
        osc.connect(env);
        env.connect(this.layerGains.drums);
        osc.start(now);
        osc.stop(now + 0.3);
      }

      playHealing(now) {
        const freq = this.healingFrequencies[Math.floor(Math.random() * this.healingFrequencies.length)];
        const osc = this.ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = freq;
        
        const env = this.ctx.createGain();
        env.gain.setValueAtTime(0, now);
        env.gain.linearRampToValueAtTime(0.2, now + 2);
        env.gain.exponentialRampToValueAtTime(0.001, now + 10);
        
        osc.connect(env);
        env.connect(this.layerGains.healing);
        osc.start(now);
        osc.stop(now + 10);
      }

      updateAmbient() {
        const now = this.ctx.currentTime;
        const targetFreq = 300 + Math.sin(now * 0.1) * 100 + this.intensity * 50;
        this.ambientFilter.frequency.linearRampToValueAtTime(targetFreq, now + 0.1);
        this.ambientGain.gain.linearRampToValueAtTime(0.08 + this.intensity * 0.02, now + 0.1);
      }

      enterVoid() {
        if (this.isVoid) return;
        this.isVoid = true;
        this.elements.orb.classList.add('void');
        this.elements.stageName.textContent = 'VOID';
        this.layerGains.strings.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        this.layerGains.sineOverlay.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        this.layerGains.drums.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
        this.layerGains.healing.gain.linearRampToValueAtTime(0.5, this.ctx.currentTime + 1);
      }

      exitVoid() {
        this.isVoid = false;
        this.elements.orb.classList.remove('void');
        this.elements.stageName.textContent = 'ACTIVE';
        this.layerGains.strings.gain.linearRampToValueAtTime(0.6, this.ctx.currentTime + 1);
        this.layerGains.sineOverlay.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 1);
        this.layerGains.drums.gain.linearRampToValueAtTime(0.8, this.ctx.currentTime + 1);
        this.layerGains.healing.gain.linearRampToValueAtTime(0, this.ctx.currentTime + 1);
      }

      noteToFreq(note, octave) {
        return 440 * Math.pow(2, (note + (octave - 4) * 12) / 12);
      }

      updateUI() {
        this.elements.bpmDisplay.textContent = Math.round(this.bpm);
        this.elements.intensityDisplay.textContent = Math.round(this.intensity * 10) + '%';
        
        this.analyser.getByteFrequencyData(this.dataArray);
        this.waveBars.forEach((bar, i) => {
          const avg = Array.from(this.dataArray.slice(i*32, (i+1)*32)).reduce((a,b)=>a+b,0)/32;
          bar.style.height = (avg / 255 * 60) + 'px';
        });
      }

      animate() {
        requestAnimationFrame(this.animate.bind(this));
        if (!this.active) return;
        
        this.elements.orb.style.left = this.pos.x + '%';
        this.elements.orb.style.top = this.pos.y + '%';
        
        this.bpm = 50 + this.intensity * 15;
      }
    }

    new EnhancedVoidEngine();
  </script>
</body>
</html>
