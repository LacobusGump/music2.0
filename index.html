<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP</title>
    <style>
        *{margin:0;padding:0;box-sizing:border-box}
        body{background:#000;overflow:hidden;touch-action:none;height:100vh;height:100dvh}
        canvas{position:fixed;top:0;left:0;width:100%;height:100%}
        #enter{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:10;cursor:pointer}
        #enter.off{opacity:0;pointer-events:none;transition:opacity 1.5s}
        #enter div{width:100px;height:100px;border-radius:50%;border:1px solid rgba(255,255,255,0.15);display:flex;align-items:center;justify-content:center;font:9px system-ui;letter-spacing:3px;color:rgba(255,255,255,0.3);transition:0.3s}
        #enter:hover div{border-color:rgba(255,255,255,0.4);color:rgba(255,255,255,0.6)}
    </style>
</head>
<body>
<div id="enter"><div>ENTER</div></div>
<canvas id="c"></canvas>
<script>
// GUMP - Grand Unified Music Project
// You are the waveform. Movement is music.
// Stillness becomes pulse. Memory leaves traces.

const TAU = Math.PI * 2;
const PHI = 1.618033988749;

// ============ STATE ============

let ctx, master, verb, dly, sub;
let voices = [];
let canvas, vc;
let running = false;

const field = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    energy: 0,
    stillness: 0,
    pulse: 0,
    pulsePhase: 0,
    time: 0
};

// Memory - where you've been leaves harmonic traces
const memory = [];
const MAX_MEMORY = 50;

// Harmonic series - the DNA of music
const HARMONICS = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
const BASE = 55; // A1

// ============ AUDIO INIT ============

function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master chain
    master = ctx.createGain();
    master.gain.value = 0.5;

    const comp = ctx.createDynamicsCompressor();
    comp.threshold.value = -20;
    comp.ratio.value = 4;
    comp.attack.value = 0.005;
    comp.release.value = 0.2;

    // Sub bass - the ground
    sub = ctx.createOscillator();
    const subGain = ctx.createGain();
    const subFilter = ctx.createBiquadFilter();
    sub.type = 'sine';
    sub.frequency.value = BASE;
    subFilter.type = 'lowpass';
    subFilter.frequency.value = 80;
    subGain.gain.value = 0;
    sub.connect(subFilter);
    subFilter.connect(subGain);
    subGain.connect(master);
    sub.start();
    sub.gainNode = subGain;

    // Reverb - space
    verb = createVerb();

    // Delay - echoes
    dly = createDelay();

    // Routing
    master.connect(comp);
    comp.connect(ctx.destination);
    verb.output.connect(master);
    dly.output.connect(master);

    // Create harmonic voices
    HARMONICS.forEach((h, i) => {
        voices.push(createVoice(BASE * h, i));
    });
}

function createVerb() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.4;

    const times = [0.029, 0.067, 0.113, 0.179, 0.233, 0.307, 0.419, 0.541, 0.709];
    times.forEach((t, i) => {
        const d = ctx.createDelay(1);
        d.delayTime.value = t;
        const g = ctx.createGain();
        g.gain.value = 0.35 * Math.pow(0.82, i);
        const f = ctx.createBiquadFilter();
        f.type = 'lowpass';
        f.frequency.value = 3500 - i * 350;
        input.connect(d);
        d.connect(f);
        f.connect(g);
        g.connect(output);
    });

    return { input, output };
}

function createDelay() {
    const input = ctx.createGain();
    const output = ctx.createGain();
    output.gain.value = 0.25;

    const d = ctx.createDelay(2);
    d.delayTime.value = 0.375;
    const fb = ctx.createGain();
    fb.gain.value = 0.35;
    const f = ctx.createBiquadFilter();
    f.type = 'lowpass';
    f.frequency.value = 2000;

    input.connect(d);
    d.connect(f);
    f.connect(fb);
    fb.connect(d);
    f.connect(output);

    return { input, output, delay: d, feedback: fb };
}

function createVoice(freq, index) {
    const osc = ctx.createOscillator();
    const osc2 = ctx.createOscillator();
    const filter = ctx.createBiquadFilter();
    const gain = ctx.createGain();
    const pan = ctx.createStereoPanner();

    // Primary oscillator
    osc.type = index < 4 ? 'sine' : (index < 8 ? 'triangle' : 'sine');
    osc.frequency.value = freq;

    // Detuned pair for warmth
    osc2.type = 'sine';
    osc2.frequency.value = freq * 1.003;

    // Filter
    filter.type = 'lowpass';
    filter.frequency.value = 100;
    filter.Q.value = 0.7;

    // Start silent
    gain.gain.value = 0;

    // Spread across stereo field
    pan.pan.value = ((index % 6) / 5) * 1.6 - 0.8;

    // Connect
    osc.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(pan);
    pan.connect(master);
    pan.connect(verb.input);
    if (index > 2) pan.connect(dly.input);

    osc.start();
    osc2.start();

    return {
        osc, osc2, filter, gain, pan,
        baseFreq: freq,
        harmonic: HARMONICS[index],
        index
    };
}

// ============ THE SHAPING ============
// Your movement shapes the harmonic field continuously

function shapeField(dt) {
    const now = ctx.currentTime;

    // Energy from velocity
    const speed = Math.sqrt(field.vx * field.vx + field.vy * field.vy);
    field.energy = field.energy * 0.92 + speed * 0.8;

    // Stillness accumulates when not moving
    if (speed < 0.01) {
        field.stillness = Math.min(1, field.stillness + dt * 0.3);
    } else {
        field.stillness *= 0.9;
    }

    // Pulse emerges from stillness
    if (field.stillness > 0.3) {
        field.pulsePhase += dt * (1 + field.stillness);
        field.pulse = Math.sin(field.pulsePhase * TAU * 0.5) * 0.5 + 0.5;
        field.pulse *= field.stillness;
    } else {
        field.pulse *= 0.95;
        field.pulsePhase *= 0.95;
    }

    // Each voice responds to position
    voices.forEach((v, i) => {
        // X position = which harmonics sing (spread across screen)
        const harmonicX = (i + 0.5) / voices.length;
        const xDistance = Math.abs(field.x - harmonicX);
        const xPresence = Math.max(0, 1 - xDistance * 2.5);

        // Y position = register/brightness (lower harmonics bottom, higher top)
        const harmonicY = i / voices.length;
        const yDistance = Math.abs(field.y - harmonicY);
        const yPresence = Math.max(0, 1 - yDistance * 2);

        // Combined presence
        let presence = (xPresence * 0.7 + yPresence * 0.3);

        // Energy amplifies everything
        const energyBoost = 0.3 + field.energy * 2;

        // Stillness pulse modulates amplitude
        const pulseAmp = 1 + field.pulse * 0.5 * (1 - field.energy);

        // Final amplitude
        const amp = presence * energyBoost * pulseAmp * 0.12;
        v.gain.gain.linearRampToValueAtTime(Math.min(0.2, amp), now + 0.08);

        // Filter opens with Y and energy
        const filterBase = 80 + field.y * 2500 + field.energy * 2000;
        const filterPulse = field.pulse * 500 * field.stillness;
        v.filter.frequency.linearRampToValueAtTime(filterBase + filterPulse, now + 0.08);

        // Pitch responds to movement (subtle)
        const pitchDrift = 1 + field.vx * 0.015 * (i - voices.length / 2) / voices.length;
        v.osc.frequency.linearRampToValueAtTime(v.baseFreq * pitchDrift, now + 0.1);
        v.osc2.frequency.linearRampToValueAtTime(v.baseFreq * pitchDrift * 1.003, now + 0.1);

        // Pan follows movement
        const panBase = ((i % 6) / 5) * 1.6 - 0.8;
        const panMod = field.vx * 0.4;
        v.pan.pan.linearRampToValueAtTime(
            Math.max(-1, Math.min(1, panBase + panMod)),
            now + 0.08
        );
    });

    // Sub bass from stillness pulse
    const subAmp = field.pulse * field.stillness * 0.3;
    sub.gainNode.gain.linearRampToValueAtTime(subAmp, now + 0.1);

    // Reverb grows with stillness
    verb.output.gain.linearRampToValueAtTime(0.25 + field.stillness * 0.4, now + 0.2);

    // Delay feedback grows with energy
    dly.feedback.gain.linearRampToValueAtTime(0.2 + field.energy * 0.35, now + 0.1);
    dly.delay.delayTime.linearRampToValueAtTime(0.25 + field.energy * 0.25, now + 0.15);
}

// ============ MEMORY ============
// Where you've been leaves traces

function updateMemory() {
    // Add current position to memory occasionally
    if (field.energy > 0.1 && Math.random() < 0.1) {
        memory.push({
            x: field.x,
            y: field.y,
            energy: field.energy,
            time: field.time,
            hue: (field.x * 360 + field.y * 60) % 360
        });

        if (memory.length > MAX_MEMORY) {
            memory.shift();
        }
    }

    // Fade old memories
    for (let i = memory.length - 1; i >= 0; i--) {
        memory[i].energy *= 0.995;
        if (memory[i].energy < 0.01) {
            memory.splice(i, 1);
        }
    }
}

// ============ INPUT ============

function onMove(nx, ny) {
    field.vx = field.vx * 0.6 + (nx - field.x) * 0.4;
    field.vy = field.vy * 0.6 + (ny - field.y) * 0.4;
    field.x = nx;
    field.y = ny;
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 12;
    const ay = (a.y || 0) / 12;

    field.vx = field.vx * 0.7 + ax * 0.3;
    field.vy = field.vy * 0.7 + ay * 0.3;

    field.x = Math.max(0, Math.min(1, field.x + field.vx * 0.08));
    field.y = Math.max(0, Math.min(1, field.y - field.vy * 0.08));
}

function onOrientation(e) {
    const gx = (e.gamma || 0) / 50;
    const gy = (e.beta || 0) / 50 - 0.8;

    const nx = Math.max(0, Math.min(1, (gx + 1) / 2));
    const ny = Math.max(0, Math.min(1, 1 - (gy + 1) / 2));

    onMove(nx, ny);
}

// ============ VISUALS ============

function resize() {
    const dpr = window.devicePixelRatio || 1;
    const w = window.innerWidth;
    const h = window.innerHeight;

    canvas.width = w * dpr;
    canvas.height = h * dpr;

    // Reset and set transform properly
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = window.innerWidth;
    const h = window.innerHeight;

    // Fade
    const fadeAlpha = 0.08 + (1 - field.energy) * 0.04 + field.stillness * 0.02;
    vc.fillStyle = `rgba(0, 0, 0, ${fadeAlpha})`;
    vc.fillRect(0, 0, w, h);

    const cx = field.x * w;
    const cy = (1 - field.y) * h;

    // Memory traces
    memory.forEach(m => {
        const mx = m.x * w;
        const my = (1 - m.y) * h;
        const r = 5 + m.energy * 30;

        vc.beginPath();
        vc.arc(mx, my, r, 0, TAU);
        vc.fillStyle = `hsla(${m.hue}, 50%, 50%, ${m.energy * 0.3})`;
        vc.fill();
    });

    // Harmonic rings
    voices.forEach((v, i) => {
        const amp = v.gain.gain.value;
        if (amp < 0.003) return;

        // Position based on harmonic
        const vx = ((i + 0.5) / voices.length) * w;
        const vy = h / 2 + Math.sin(field.time * 0.5 + i) * 20 * field.stillness;

        // Connection line to cursor
        const dist = Math.sqrt((cx - vx) ** 2 + (cy - vy) ** 2);
        const maxDist = w * 0.4;
        const conn = Math.max(0, 1 - dist / maxDist);

        if (conn > 0.05) {
            vc.beginPath();
            vc.moveTo(cx, cy);
            vc.lineTo(vx, vy);
            vc.strokeStyle = `rgba(255, 255, 255, ${conn * amp * 0.4})`;
            vc.lineWidth = conn * 2;
            vc.stroke();
        }

        // Voice circle
        const r = 15 + amp * 120 + field.pulse * 20 * field.stillness;
        const hue = 200 + i * 12;

        vc.beginPath();
        vc.arc(vx, vy, r, 0, TAU);
        const grad = vc.createRadialGradient(vx, vy, 0, vx, vy, r);
        grad.addColorStop(0, `hsla(${hue}, 70%, 60%, ${amp * 1.5})`);
        grad.addColorStop(0.6, `hsla(${hue}, 50%, 40%, ${amp * 0.5})`);
        grad.addColorStop(1, 'transparent');
        vc.fillStyle = grad;
        vc.fill();
    });

    // Stillness pulse ring
    if (field.stillness > 0.1) {
        const pulseR = 50 + field.pulse * 100;
        vc.beginPath();
        vc.arc(cx, cy, pulseR, 0, TAU);
        vc.strokeStyle = `rgba(255, 255, 255, ${field.stillness * field.pulse * 0.3})`;
        vc.lineWidth = 2;
        vc.stroke();
    }

    // Cursor glow
    const glowR = 25 + field.energy * 60 + field.pulse * 20;
    const cursorGrad = vc.createRadialGradient(cx, cy, 0, cx, cy, glowR);
    cursorGrad.addColorStop(0, `rgba(255, 255, 255, ${0.4 + field.energy * 0.4})`);
    cursorGrad.addColorStop(0.4, `rgba(200, 220, 255, ${0.15 + field.energy * 0.2})`);
    cursorGrad.addColorStop(1, 'transparent');
    vc.fillStyle = cursorGrad;
    vc.beginPath();
    vc.arc(cx, cy, glowR, 0, TAU);
    vc.fill();

    // Movement trail
    if (field.energy > 0.03) {
        const trailLen = field.energy * 100;
        vc.beginPath();
        vc.moveTo(cx, cy);
        vc.lineTo(cx - field.vx * trailLen * 8, cy + field.vy * trailLen * 8);
        vc.strokeStyle = `rgba(255, 255, 255, ${field.energy * 0.6})`;
        vc.lineWidth = 2 + field.energy * 3;
        vc.lineCap = 'round';
        vc.stroke();
    }
}

// ============ LOOP ============

let lastTime = 0;

function tick(timestamp) {
    if (!running) return;

    const dt = Math.min(0.05, (timestamp - lastTime) / 1000);
    lastTime = timestamp;
    field.time += dt;

    shapeField(dt);
    updateMemory();
    draw();

    requestAnimationFrame(tick);
}

// ============ START ============

async function start() {
    document.getElementById('enter').classList.add('off');

    // iOS motion permissions
    if (typeof DeviceMotionEvent !== 'undefined' &&
        typeof DeviceMotionEvent.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }
    if (typeof DeviceOrientationEvent !== 'undefined' &&
        typeof DeviceOrientationEvent.requestPermission === 'function') {
        try { await DeviceOrientationEvent.requestPermission(); } catch(e) {}
    }

    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);

    initAudio();

    // Input
    window.addEventListener('devicemotion', onMotion);
    window.addEventListener('deviceorientation', onOrientation);

    document.addEventListener('mousemove', e => {
        onMove(e.clientX / window.innerWidth, 1 - e.clientY / window.innerHeight);
    });

    document.addEventListener('touchmove', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    document.addEventListener('touchstart', e => {
        e.preventDefault();
        const t = e.touches[0];
        onMove(t.clientX / window.innerWidth, 1 - t.clientY / window.innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') {
        await ctx.resume();
    }

    running = true;
    lastTime = performance.now();
    tick(lastTime);
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
