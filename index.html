<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>NEUROMANCER - Ultimate AI DJ</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

:root {
  --phi: 1.618033988749;
  --quantum-blue: #00ffff;
  --neural-purple: #ff00ff;
  --plasma-green: #00ff00;
  --void-black: #000000;
  --ghost-white: rgba(255,255,255,0.03);
  --electric-red: #ff0040;
  --synaptic-gold: #ffd700;
}

body {
  background: var(--void-black);
  color: #fff;
  overflow: hidden;
  height: 100vh;
  font-family: 'SF Mono', 'Monaco', 'Inconsolata', monospace;
  cursor: none;
  user-select: none;
  position: relative;
}

/* Custom Cursor */
#neuralCursor {
  position: fixed;
  width: 20px;
  height: 20px;
  border: 2px solid var(--quantum-blue);
  border-radius: 50%;
  pointer-events: none;
  z-index: 10001;
  mix-blend-mode: screen;
  transition: transform 0.1s ease;
}

#neuralCursor.active {
  transform: scale(1.5);
  background: radial-gradient(circle, var(--neural-purple), transparent);
}

/* Quantum Processing Core */
#quantumCore {
  position: fixed;
  inset: 0;
  background: radial-gradient(circle at center,
    transparent 0%,
    var(--ghost-white) 50%,
    transparent 100%);
  pointer-events: none;
  mix-blend-mode: screen;
  animation: quantum-breathe 8s ease-in-out infinite;
}

@keyframes quantum-breathe {
  0%, 100% { opacity: 0.3; transform: scale(1) rotate(0deg); }
  50% { opacity: 0.6; transform: scale(1.1) rotate(180deg); }
}

/* Neural Synapses Background */
#synapticField {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.3;
}

.synapse {
  position: absolute;
  background: linear-gradient(90deg, transparent, var(--quantum-blue), transparent);
  height: 1px;
  animation: synapse-fire 3s ease-in-out infinite;
}

@keyframes synapse-fire {
  0%, 100% { opacity: 0; transform: scaleX(0); }
  50% { opacity: 1; transform: scaleX(1); }
}

/* Neural Matrix Display */
.neural-matrix {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  display: grid;
  grid-template-columns: repeat(89, 1fr);
  grid-template-rows: repeat(55, 1fr);
  gap: 1px;
  opacity: 0.05;
  pointer-events: none;
}

.neural-cell {
  background: var(--ghost-white);
  transition: all 0.3s ease;
}

.neural-cell.active {
  background: var(--quantum-blue);
  box-shadow: 0 0 10px var(--quantum-blue);
}

.neural-cell.thinking {
  background: var(--neural-purple);
  animation: neural-pulse 0.5s ease-in-out;
}

@keyframes neural-pulse {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.5); }
}

/* Advanced Waveform Display */
#waveformCanvas {
  position: fixed;
  top: 50%;
  left: 0;
  width: 100%;
  height: 233px;
  transform: translateY(-50%);
  pointer-events: none;
  opacity: 0.8;
  filter: drop-shadow(0 0 10px var(--quantum-blue));
}

/* 3D Spectral Analyzer */
#spectralCanvas {
  position: fixed;
  bottom: 0;
  left: 0;
  width: 100%;
  height: 144px;
  pointer-events: none;
  opacity: 0.6;
}

/* Phrase Structure Display */
.phrase-structure {
  position: fixed;
  top: 100px;
  left: 50%;
  transform: translateX(-50%);
  width: 600px;
  height: 40px;
  display: flex;
  gap: 2px;
  opacity: 0.7;
}

.phrase-segment {
  flex: 1;
  background: var(--ghost-white);
  border-radius: 2px;
  position: relative;
  overflow: hidden;
}

.phrase-segment.intro { background: rgba(0, 255, 255, 0.2); }
.phrase-segment.verse { background: rgba(0, 255, 0, 0.2); }
.phrase-segment.chorus { background: rgba(255, 0, 255, 0.2); }
.phrase-segment.drop { background: rgba(255, 0, 64, 0.2); }
.phrase-segment.breakdown { background: rgba(255, 215, 0, 0.2); }
.phrase-segment.outro { background: rgba(128, 128, 255, 0.2); }

.phrase-segment.current::after {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0;
  width: 3px;
  background: white;
  animation: phrase-scan 2s linear infinite;
}

@keyframes phrase-scan {
  from { left: 0; }
  to { left: 100%; }
}

/* Beat Grid Overlay */
.beat-grid {
  position: fixed;
  inset: 0;
  display: grid;
  grid-template-columns: repeat(16, 1fr);
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.3s ease;
}

.beat-grid.visible {
  opacity: 0.1;
}

.beat-line {
  border-left: 1px solid rgba(255,255,255,0.1);
}

.beat-line.downbeat {
  border-left-color: rgba(255,255,255,0.3);
  box-shadow: 0 0 20px rgba(255,255,255,0.2);
}

/* Advanced Harmonic Wheel */
.harmonic-wheel {
  position: fixed;
  top: 34px;
  right: 34px;
  width: 144px;
  height: 144px;
  pointer-events: none;
}

#harmonicCanvas {
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 0 20px var(--neural-purple));
}

/* Memory Bank Visualization */
.memory-bank {
  position: fixed;
  left: 34px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 13px;
}

.memory-slot {
  width: 55px;
  height: 34px;
  border: 1px solid var(--ghost-white);
  border-radius: 3px;
  position: relative;
  overflow: hidden;
  transition: all 0.3s cubic-bezier(0.23, 1, 0.320, 1);
  cursor: pointer;
}

.memory-slot.active {
  border-color: var(--quantum-blue);
  box-shadow: 0 0 21px var(--quantum-blue);
  transform: scale(1.1) translateX(5px);
}

.memory-slot.processing {
  border-color: var(--neural-purple);
  animation: memory-process 0.5s ease-in-out infinite;
}

.memory-slot.analyzing {
  border-color: var(--synaptic-gold);
  animation: memory-analyze 1s linear infinite;
}

@keyframes memory-process {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}

@keyframes memory-analyze {
  0% { box-shadow: 0 0 5px var(--synaptic-gold); }
  50% { box-shadow: 0 0 25px var(--synaptic-gold); }
  100% { box-shadow: 0 0 5px var(--synaptic-gold); }
}

.memory-waveform {
  position: absolute;
  inset: 0;
  opacity: 0.5;
}

/* Neural Decision Tree */
.decision-tree {
  position: fixed;
  right: 200px;
  top: 200px;
  width: 300px;
  height: 300px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.5s ease;
}

.decision-tree.active {
  opacity: 0.6;
}

#decisionCanvas {
  width: 100%;
  height: 100%;
}

/* Consciousness Display */
.consciousness-display {
  position: fixed;
  bottom: 34px;
  left: 50%;
  transform: translateX(-50%);
  text-align: center;
  pointer-events: none;
}

.consciousness-label {
  font-size: 8px;
  letter-spacing: 5px;
  text-transform: uppercase;
  opacity: 0.382;
  margin-bottom: 8px;
}

.consciousness-value {
  font-size: 21px;
  letter-spacing: 13px;
  opacity: 0.618;
  font-weight: 100;
  background: linear-gradient(90deg, 
    var(--quantum-blue) 0%, 
    var(--neural-purple) 50%, 
    var(--plasma-green) 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  animation: consciousness-shift 5s ease-in-out infinite;
}

@keyframes consciousness-shift {
  0%, 100% { filter: hue-rotate(0deg) brightness(1); }
  25% { filter: hue-rotate(90deg) brightness(1.2); }
  50% { filter: hue-rotate(180deg) brightness(0.8); }
  75% { filter: hue-rotate(270deg) brightness(1.1); }
}

/* Pattern Sequencer Matrix */
.pattern-sequencer {
  position: fixed;
  right: 34px;
  top: 50%;
  transform: translateY(-50%);
  display: grid;
  grid-template-columns: repeat(16, 13px);
  grid-template-rows: repeat(16, 13px);
  gap: 2px;
  opacity: 0.5;
}

.pattern-cell {
  background: var(--ghost-white);
  border-radius: 2px;
  transition: all 0.15s ease;
  cursor: pointer;
  position: relative;
}

.pattern-cell.active {
  background: var(--plasma-green);
  box-shadow: 0 0 8px var(--plasma-green);
}

.pattern-cell.current {
  background: var(--quantum-blue);
  animation: pulse-cell 0.3s ease;
}

.pattern-cell.predicted {
  background: var(--synaptic-gold);
  opacity: 0.5;
}

@keyframes pulse-cell {
  0% { transform: scale(1); }
  50% { transform: scale(1.3); }
  100% { transform: scale(1); }
}

/* Advanced Parameter Matrix */
.parameter-matrix {
  position: fixed;
  top: 34px;
  left: 34px;
  display: grid;
  grid-template-columns: repeat(5, 34px);
  grid-template-rows: repeat(3, 34px);
  gap: 8px;
  opacity: 0.618;
}

.param-display {
  border: 1px solid var(--ghost-white);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 10px;
  position: relative;
  overflow: hidden;
  cursor: pointer;
  transition: all 0.3s ease;
}

.param-display:hover {
  border-color: var(--quantum-blue);
  transform: scale(1.1);
}

.param-value {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(0deg, 
    var(--quantum-blue) 0%, 
    transparent 100%);
  transition: height 0.3s ease;
}

/* Multi-band EQ Visualization */
.eq-display {
  position: fixed;
  bottom: 34px;
  right: 34px;
  width: 144px;
  height: 89px;
  border: 1px solid var(--ghost-white);
  border-radius: 3px;
  overflow: hidden;
}

#eqCanvas {
  width: 100%;
  height: 100%;
}

/* Transition Predictor with Timeline */
.transition-predictor {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 500px;
  height: 300px;
  pointer-events: none;
  opacity: 0;
  transition: opacity 0.5s ease;
}

.transition-predictor.active {
  opacity: 1;
}

#transitionCanvas {
  width: 100%;
  height: 100%;
  filter: drop-shadow(0 0 30px var(--neural-purple));
}

/* Advanced Stem Indicators */
.stem-indicators {
  position: fixed;
  bottom: 144px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 21px;
  opacity: 0.618;
}

.stem-indicator {
  width: 55px;
  height: 8px;
  background: var(--ghost-white);
  border-radius: 4px;
  position: relative;
  overflow: hidden;
}

.stem-level {
  position: absolute;
  left: 0;
  top: 0;
  bottom: 0;
  background: var(--quantum-blue);
  transition: width 0.1s linear;
}

.stem-indicator.drums .stem-level { 
  background: linear-gradient(90deg, var(--plasma-green), var(--quantum-blue)); 
}
.stem-indicator.bass .stem-level { 
  background: linear-gradient(90deg, var(--neural-purple), var(--electric-red)); 
}
.stem-indicator.vocals .stem-level { 
  background: linear-gradient(90deg, var(--quantum-blue), var(--synaptic-gold)); 
}
.stem-indicator.melody .stem-level { 
  background: linear-gradient(90deg, var(--synaptic-gold), var(--neural-purple)); 
}

/* Crowd Energy Visualization */
.crowd-energy {
  position: fixed;
  left: 50%;
  top: 34px;
  transform: translateX(-50%);
  width: 233px;
  height: 5px;
  background: var(--ghost-white);
  border-radius: 2px;
  overflow: hidden;
}

.energy-level {
  height: 100%;
  background: linear-gradient(90deg,
    var(--plasma-green) 0%,
    var(--quantum-blue) 33%,
    var(--neural-purple) 66%,
    var(--electric-red) 100%);
  width: 0%;
  transition: width 0.5s cubic-bezier(0.23, 1, 0.320, 1);
  box-shadow: 0 0 20px currentColor;
}

/* Neural State Indicator */
.neural-state {
  position: fixed;
  top: 89px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 34px;
  opacity: 0.8;
}

.state-node {
  width: 55px;
  height: 55px;
  border: 2px solid var(--ghost-white);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 8px;
  position: relative;
  transition: all 0.3s ease;
}

.state-node.active {
  border-color: var(--quantum-blue);
  box-shadow: 0 0 30px var(--quantum-blue);
  transform: scale(1.2);
}

.state-node::before {
  content: '';
  position: absolute;
  inset: -10px;
  border: 1px solid currentColor;
  border-radius: 50%;
  opacity: 0;
  animation: state-ripple 2s ease-in-out infinite;
}

.state-node.active::before {
  opacity: 1;
}

@keyframes state-ripple {
  0% { transform: scale(0.8); opacity: 1; }
  100% { transform: scale(1.5); opacity: 0; }
}

/* Mix Graph Visualization */
.mix-graph {
  position: fixed;
  left: 150px;
  top: 150px;
  width: 250px;
  height: 250px;
  pointer-events: none;
  opacity: 0.5;
}

#mixGraphCanvas {
  width: 100%;
  height: 100%;
}

/* Advanced Controls Panel */
.control-panel {
  position: fixed;
  bottom: 250px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 34px;
  opacity: 0.8;
}

.control-knob {
  width: 55px;
  height: 55px;
  border: 2px solid var(--ghost-white);
  border-radius: 50%;
  position: relative;
  cursor: pointer;
  transition: all 0.3s ease;
}

.control-knob:hover {
  border-color: var(--quantum-blue);
  transform: scale(1.1);
}

.knob-indicator {
  position: absolute;
  top: 50%;
  left: 50%;
  width: 2px;
  height: 20px;
  background: var(--quantum-blue);
  transform-origin: center bottom;
  transform: translate(-50%, -100%) rotate(0deg);
  transition: transform 0.2s ease;
}

.control-label {
  position: absolute;
  bottom: -20px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 8px;
  letter-spacing: 2px;
  white-space: nowrap;
}

/* Crossfader Display */
.crossfader {
  position: fixed;
  bottom: 200px;
  left: 50%;
  transform: translateX(-50%);
  width: 233px;
  height: 34px;
  border: 1px solid var(--ghost-white);
  border-radius: 17px;
  position: relative;
  overflow: hidden;
  cursor: pointer;
}

.crossfader-track {
  position: absolute;
  top: 50%;
  left: 10px;
  right: 10px;
  height: 2px;
  background: var(--ghost-white);
  transform: translateY(-50%);
}

.crossfader-position {
  position: absolute;
  top: 50%;
  transform: translateY(-50%);
  width: 21px;
  height: 21px;
  background: radial-gradient(circle, var(--quantum-blue), var(--neural-purple));
  border-radius: 50%;
  left: 50%;
  margin-left: -10px;
  transition: left 0.3s cubic-bezier(0.23, 1, 0.320, 1);
  box-shadow: 0 0 13px var(--quantum-blue);
  cursor: grab;
}

.crossfader-position:active {
  cursor: grabbing;
  transform: translateY(-50%) scale(1.2);
}

/* Scratch Wheel */
.scratch-wheel {
  position: fixed;
  right: 250px;
  bottom: 50px;
  width: 144px;
  height: 144px;
  border: 2px solid var(--ghost-white);
  border-radius: 50%;
  cursor: pointer;
  opacity: 0.6;
  transition: all 0.3s ease;
  display: flex;
  align-items: center;
  justify-content: center;
}

.scratch-wheel:hover {
  opacity: 1;
  border-color: var(--quantum-blue);
}

.scratch-indicator {
  width: 100px;
  height: 100px;
  border-radius: 50%;
  background: conic-gradient(
    from 0deg,
    var(--quantum-blue) 0deg,
    var(--neural-purple) 90deg,
    var(--plasma-green) 180deg,
    var(--electric-red) 270deg,
    var(--quantum-blue) 360deg
  );
  opacity: 0.3;
  animation: scratch-spin 4s linear infinite;
}

@keyframes scratch-spin {
  to { transform: rotate(360deg); }
}

.scratch-wheel.scratching .scratch-indicator {
  animation-play-state: paused;
}

/* Neural Decision Display */
.neural-decision {
  position: fixed;
  top: 89px;
  right: 50px;
  font-size: 10px;
  letter-spacing: 3px;
  opacity: 0;
  transition: opacity 0.3s ease;
  text-transform: uppercase;
  padding: 8px 13px;
  border: 1px solid var(--quantum-blue);
  border-radius: 3px;
  background: rgba(0, 255, 255, 0.1);
}

.neural-decision.visible {
  opacity: 0.8;
  animation: decision-glow 0.5s ease;
}

@keyframes decision-glow {
  0% { box-shadow: 0 0 0 var(--quantum-blue); }
  50% { box-shadow: 0 0 30px var(--quantum-blue); }
  100% { box-shadow: 0 0 10px var(--quantum-blue); }
}

/* Performance Metrics Dashboard */
.performance-metrics {
  position: fixed;
  bottom: 5px;
  left: 5px;
  font-size: 8px;
  opacity: 0.3;
  font-family: monospace;
  pointer-events: none;
  display: grid;
  grid-template-columns: repeat(3, auto);
  gap: 10px;
}

.metric {
  display: flex;
  gap: 5px;
}

.metric-label {
  color: var(--ghost-white);
}

.metric-value {
  color: var(--quantum-blue);
}

/* Loading State */
.loading-dna {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 144px;
  height: 144px;
  display: none;
}

.loading-dna.active {
  display: block;
}

.dna-helix {
  width: 100%;
  height: 100%;
  position: relative;
}

.dna-strand {
  position: absolute;
  width: 100%;
  height: 100%;
  animation: dna-spin 2s linear infinite;
}

.dna-strand:nth-child(2) {
  animation-delay: -0.5s;
}

@keyframes dna-spin {
  to { transform: rotate(360deg); }
}

.dna-point {
  position: absolute;
  width: 8px;
  height: 8px;
  background: var(--quantum-blue);
  border-radius: 50%;
  box-shadow: 0 0 10px var(--quantum-blue);
}

/* Start Interface */
.start-interface {
  position: fixed;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  background: radial-gradient(circle at center, 
    rgba(0,0,0,0.8) 0%, 
    var(--void-black) 100%);
  z-index: 10000;
  transition: opacity 3s cubic-bezier(0.23, 1, 0.320, 1);
}

.start-interface.hidden {
  opacity: 0;
  pointer-events: none;
}

.start-portal {
  width: 233px;
  height: 233px;
  border: 1px solid rgba(255,255,255,0.1);
  border-radius: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  position: relative;
  transition: all 0.5s ease;
  background: radial-gradient(circle at center,
    transparent 0%,
    rgba(0, 255, 255, 0.05) 50%,
    transparent 100%);
}

.start-portal:hover {
  transform: scale(1.05);
  border-color: var(--quantum-blue);
  box-shadow: 0 0 55px var(--quantum-blue);
  background: radial-gradient(circle at center,
    transparent 0%,
    rgba(0, 255, 255, 0.1) 50%,
    transparent 100%);
}

.start-portal::before,
.start-portal::after {
  content: '';
  position: absolute;
  inset: -34px;
  border: 1px solid rgba(255,255,255,0.05);
  border-radius: 50%;
  animation: portal-expand 3s ease-in-out infinite;
}

.start-portal::after {
  inset: -55px;
  animation-delay: 1.5s;
}

@keyframes portal-expand {
  0%, 100% { transform: scale(1); opacity: 0.5; }
  50% { transform: scale(1.1); opacity: 0.1; }
}

.start-text {
  font-size: 13px;
  letter-spacing: 21px;
  opacity: 0.618;
  font-weight: 100;
  margin-left: 21px;
  text-shadow: 0 0 20px var(--quantum-blue);
}

/* Glitch Effects */
.glitch {
  animation: glitch 0.3s ease;
}

@keyframes glitch {
  0%, 100% { transform: translate(0); filter: hue-rotate(0deg); }
  20% { transform: translate(-1px, 1px); filter: hue-rotate(90deg); }
  40% { transform: translate(1px, -1px); filter: hue-rotate(180deg); }
  60% { transform: translate(-1px, -1px); filter: hue-rotate(270deg); }
  80% { transform: translate(1px, 1px); filter: hue-rotate(360deg); }
}

/* Reactive Background */
.reactive-bg {
  position: fixed;
  inset: 0;
  pointer-events: none;
  opacity: 0.1;
  mix-blend-mode: screen;
}

#reactiveCanvas {
  width: 100%;
  height: 100%;
}
</style>
</head>
<body>
<div id="neuralCursor"></div>
<div id="quantumCore"></div>
<div id="synapticField"></div>
<div class="neural-matrix" id="neuralMatrix"></div>
<div class="reactive-bg"><canvas id="reactiveCanvas"></canvas></div>

<canvas id="waveformCanvas"></canvas>
<canvas id="spectralCanvas"></canvas>

<div class="phrase-structure" id="phraseStructure">
  <div class="phrase-segment intro">INTRO</div>
  <div class="phrase-segment verse">VERSE</div>
  <div class="phrase-segment chorus">CHORUS</div>
  <div class="phrase-segment drop">DROP</div>
  <div class="phrase-segment breakdown">BREAK</div>
  <div class="phrase-segment outro">OUTRO</div>
</div>

<div class="beat-grid" id="beatGrid">
  <div class="beat-line downbeat"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line downbeat"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line downbeat"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line downbeat"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
  <div class="beat-line"></div>
</div>

<div class="harmonic-wheel">
  <canvas id="harmonicCanvas"></canvas>
</div>

<div class="memory-bank" id="memoryBank">
  <div class="memory-slot" data-slot="0"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="1"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="2"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="3"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="4"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="5"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="6"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="7"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="8"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="9"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="10"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="11"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="12"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="13"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="14"><canvas class="memory-waveform"></canvas></div>
  <div class="memory-slot" data-slot="15"><canvas class="memory-waveform"></canvas></div>
</div>

<div class="pattern-sequencer" id="patternSequencer"></div>

<div class="parameter-matrix" id="parameterMatrix">
  <div class="param-display" data-param="tempo">
    <span>BPM</span>
    <div class="param-value" id="tempoValue"></div>
  </div>
  <div class="param-display" data-param="key">
    <span>KEY</span>
    <div class="param-value" id="keyValue"></div>
  </div>
  <div class="param-display" data-param="energy">
    <span>NRG</span>
    <div class="param-value" id="energyValue"></div>
  </div>
  <div class="param-display" data-param="complexity">
    <span>CPX</span>
    <div class="param-value" id="complexityValue"></div>
  </div>
  <div class="param-display" data-param="evolution">
    <span>EVO</span>
    <div class="param-value" id="evolutionValue"></div>
  </div>
  <div class="param-display" data-param="tension">
    <span>TNS</span>
    <div class="param-value" id="tensionValue"></div>
  </div>
  <div class="param-display" data-param="groove">
    <span>GRV</span>
    <div class="param-value" id="grooveValue"></div>
  </div>
  <div class="param-display" data-param="depth">
    <span>DPT</span>
    <div class="param-value" id="depthValue"></div>
  </div>
  <div class="param-display" data-param="morph">
    <span>MRP</span>
    <div class="param-value" id="morphValue"></div>
  </div>
  <div class="param-display" data-param="chaos">
    <span>CHS</span>
    <div class="param-value" id="chaosValue"></div>
  </div>
</div>

<div class="eq-display">
  <canvas id="eqCanvas"></canvas>
</div>

<div class="decision-tree" id="decisionTree">
  <canvas id="decisionCanvas"></canvas>
</div>

<div class="mix-graph" id="mixGraph">
  <canvas id="mixGraphCanvas"></canvas>
</div>

<div class="transition-predictor" id="transitionPredictor">
  <canvas id="transitionCanvas"></canvas>
</div>

<div class="stem-indicators">
  <div class="stem-indicator drums">
    <div class="stem-level" id="drumLevel"></div>
  </div>
  <div class="stem-indicator bass">
    <div class="stem-level" id="bassLevel"></div>
  </div>
  <div class="stem-indicator vocals">
    <div class="stem-level" id="vocalLevel"></div>
  </div>
  <div class="stem-indicator melody">
    <div class="stem-level" id="melodyLevel"></div>
  </div>
</div>

<div class="crowd-energy">
  <div class="energy-level" id="crowdEnergy"></div>
</div>

<div class="neural-state" id="neuralState">
  <div class="state-node" data-state="analyze">ANALYZE</div>
  <div class="state-node" data-state="plan">PLAN</div>
  <div class="state-node" data-state="execute">EXECUTE</div>
  <div class="state-node" data-state="adapt">ADAPT</div>
</div>

<div class="neural-decision" id="neuralDecision">PROCESSING...</div>

<div class="consciousness-display">
  <div class="consciousness-label">CONSCIOUSNESS</div>
  <div class="consciousness-value" id="consciousnessValue">VOID</div>
</div>

<div class="control-panel" id="controlPanel">
  <div class="control-knob" data-control="filter">
    <div class="knob-indicator"></div>
    <div class="control-label">FILTER</div>
  </div>
  <div class="control-knob" data-control="resonance">
    <div class="knob-indicator"></div>
    <div class="control-label">RES</div>
  </div>
  <div class="control-knob" data-control="drive">
    <div class="knob-indicator"></div>
    <div class="control-label">DRIVE</div>
  </div>
  <div class="control-knob" data-control="space">
    <div class="knob-indicator"></div>
    <div class="control-label">SPACE</div>
  </div>
</div>

<div class="crossfader" id="crossfader">
  <div class="crossfader-track"></div>
  <div class="crossfader-position" id="crossfaderPosition"></div>
</div>

<div class="scratch-wheel" id="scratchWheel">
  <div class="scratch-indicator"></div>
</div>

<div class="performance-metrics" id="performanceMetrics">
  <div class="metric">
    <span class="metric-label">FPS:</span>
    <span class="metric-value" id="fps">0</span>
  </div>
  <div class="metric">
    <span class="metric-label">CPU:</span>
    <span class="metric-value" id="cpu">0</span>%
  </div>
  <div class="metric">
    <span class="metric-label">LAT:</span>
    <span class="metric-value" id="latency">0</span>ms
  </div>
  <div class="metric">
    <span class="metric-label">BPM:</span>
    <span class="metric-value" id="currentBPM">120</span>
  </div>
  <div class="metric">
    <span class="metric-label">KEY:</span>
    <span class="metric-value" id="currentKey">C</span>
  </div>
  <div class="metric">
    <span class="metric-label">SYNC:</span>
    <span class="metric-value" id="syncStatus">LOCKED</span>
  </div>
</div>

<div class="loading-dna" id="loadingDNA">
  <div class="dna-helix">
    <div class="dna-strand">
      <div class="dna-point" style="top: 10%; left: 50%;"></div>
      <div class="dna-point" style="top: 30%; left: 70%;"></div>
      <div class="dna-point" style="top: 50%; left: 50%;"></div>
      <div class="dna-point" style="top: 70%; left: 30%;"></div>
      <div class="dna-point" style="top: 90%; left: 50%;"></div>
    </div>
    <div class="dna-strand">
      <div class="dna-point" style="top: 10%; left: 50%;"></div>
      <div class="dna-point" style="top: 30%; left: 30%;"></div>
      <div class="dna-point" style="top: 50%; left: 50%;"></div>
      <div class="dna-point" style="top: 70%; left: 70%;"></div>
      <div class="dna-point" style="top: 90%; left: 50%;"></div>
    </div>
  </div>
</div>

<div class="start-interface" id="startInterface">
  <div class="start-portal" id="startPortal">
    <div class="start-text">AWAKEN</div>
  </div>
</div>

<script>
'use strict';

// NEUROMANCER ULTIMATE - Revolutionary AI DJ System
class NeuromancerUltimate {
  constructor() {
    // Core Configuration
    this.config = {
      sampleRate: 48000,
      fftSize: 8192,
      lookAhead: 0.05,
      scheduleInterval: 25,
      maxSamples: 32,
      stemCount: 4,
      crossfadeTime: 16,
      beatDetectionWindow: 0.025,
      pitchDetectionSize: 4096,
      neuralLayers: [128, 256, 512, 256, 128],
      memoryDepth: 1000,
      predictionHorizon: 32,
      quantumEntanglement: 0.618
    };
    
    // Initialize all systems
    this.initializeSystems();
    this.setupEventListeners();
    
    console.log('🧠 NEUROMANCER ULTIMATE INITIALIZED');
  }
  
  initializeSystems() {
    // Audio Context
    this.ctx = null;
    this.isPlaying = false;
    
    // Master Clock
    this.clock = {
      startTime: 0,
      currentTime: 0,
      nextEventTime: 0,
      lookahead: 0.1,
      scheduleInterval: 25,
      quantum: 1/96 // 96 PPQN
    };
    
    // Advanced Tempo Engine
    this.tempo = {
      bpm: 128,
      phase: 0,
      confidence: 0,
      swing: 0,
      humanize: 0.01,
      microTiming: new Float32Array(16),
      adaptiveTempo: true,
      targetBPM: 128,
      transitionRate: 0.01,
      beatGrid: [],
      syncLocked: false,
      masterClock: null
    };
    
    // Neural Consciousness System
    this.consciousness = {
      awareness: 0,
      state: 'dormant',
      subStates: new Set(),
      energy: 0,
      tension: 0,
      emotion: 'neutral',
      memory: [],
      shortTermMemory: [],
      longTermMemory: new Map(),
      workingMemory: new Set(),
      attention: {
        focus: null,
        priority: [],
        context: new Map()
      },
      personality: {
        aggression: 0.5,
        creativity: 0.7,
        precision: 0.8,
        experimentation: 0.6,
        crowdReading: 0.9
      }
    };
    
    // Advanced Pattern Recognition
    this.patterns = {
      detected: new Map(),
      library: new Map(),
      active: new Set(),
      predictions: [],
      confidence: new Map(),
      structures: {
        micro: [], // 1-4 bars
        meso: [],  // 4-16 bars
        macro: []  // 16+ bars
      }
    };
    
    // Harmonic Intelligence
    this.harmony = {
      currentKey: null,
      currentScale: null,
      chordProgression: [],
      tensionCurve: new Float32Array(256),
      circleOfFifths: new Map(),
      modalInterchange: new Set(),
      chromaticTension: 0,
      resolution: null,
      keyChangePlan: null
    };
    
    // Mix Graph System
    this.mixGraph = {
      nodes: new Map(),
      edges: new Map(),
      currentPath: [],
      possiblePaths: [],
      optimalPath: null,
      constraints: new Set(),
      heuristics: new Map()
    };
    
    // Stem Separation Engine
    this.stems = {
      drums: { 
        active: false, 
        buffer: null, 
        analysis: null,
        patterns: [],
        variations: new Map()
      },
      bass: { 
        active: false, 
        buffer: null, 
        analysis: null,
        notes: [],
        groove: null
      },
      melody: { 
        active: false, 
        buffer: null, 
        analysis: null,
        motifs: [],
        harmony: null
      },
      vocals: { 
        active: false, 
        buffer: null, 
        analysis: null,
        lyrics: [],
        emotion: null
      },
      fx: { 
        active: false, 
        buffer: null, 
        analysis: null,
        types: [],
        placement: []
      }
    };
    
    // Effects Rack
    this.effects = {
      filters: new Map(),
      delays: new Map(),
      reverbs: new Map(),
      distortions: new Map(),
      modulators: new Map(),
      dynamics: new Map(),
      spatial: new Map(),
      glitch: new Map(),
      chains: new Map(),
      automation: new Map()
    };
    
    // Performance Optimization
    this.performance = {
      fps: 60,
      frameTime: 0,
      cpu: 0,
      memory: 0,
      latency: 0,
      dropouts: 0,
      quality: 'ultra',
      adaptiveQuality: true,
      workerPool: [],
      offlineProcessing: false,
      gpuAcceleration: false
    };
    
    // Crowd Simulation
    this.crowd = {
      energy: 0.5,
      mood: 'neutral',
      engagement: 0.5,
      peakMoments: [],
      lowMoments: [],
      preferences: new Map(),
      feedback: [],
      virtualDancers: [],
      heatmap: new Float32Array(100)
    };
    
    // Visualization Systems
    this.visualizers = {
      waveform: null,
      spectrum: null,
      spectrogram: null,
      phase: null,
      harmonic: null,
      neural: null,
      particle: null,
      reactive: null
    };
    
    // UI References
    this.ui = {};
    
    // Initialize subsystems
    this.initializeNeuralNetwork();
    this.initializeAudioEngine();
    this.initializeVisualization();
    this.initializePatternLibrary();
    this.initializeMixGraph();
  }
  
  initializeNeuralNetwork() {
    // Deep Neural Network for decision making
    this.neuralNet = {
      layers: [],
      weights: [],
      biases: [],
      activations: [],
      optimizer: {
        type: 'adam',
        learningRate: 0.001,
        beta1: 0.9,
        beta2: 0.999,
        epsilon: 1e-8
      },
      loss: [],
      gradients: []
    };
    
    // Initialize layers
    const sizes = this.config.neuralLayers;
    for (let i = 0; i < sizes.length - 1; i++) {
      const inputSize = sizes[i];
      const outputSize = sizes[i + 1];
      
      // Xavier initialization
      const weights = new Float32Array(inputSize * outputSize);
      const scale = Math.sqrt(2 / inputSize);
      for (let j = 0; j < weights.length; j++) {
        weights[j] = (Math.random() * 2 - 1) * scale;
      }
      
      this.neuralNet.weights.push(weights);
      this.neuralNet.biases.push(new Float32Array(outputSize));
      this.neuralNet.activations.push(new Float32Array(outputSize));
    }
  }
  
  initializeAudioEngine() {
    // Prepare audio system components
    this.audioEngine = {
      analyser: null,
      scriptProcessor: null,
      workletNode: null,
      convolver: null,
      dynamics: null,
      filters: null,
      gains: null,
      panners: null,
      compressors: null,
      buffers: new Map(),
      sources: new Map(),
      scheduledEvents: [],
      recordBuffer: [],
      preListenBuffer: new Float32Array(this.config.sampleRate * 10)
    };
  }
  
  initializeVisualization() {
    // Setup canvas contexts
    this.canvases = {
      waveform: null,
      spectral: null,
      harmonic: null,
      decision: null,
      mixGraph: null,
      transition: null,
      reactive: null,
      eq: null
    };
  }
  
  initializePatternLibrary() {
    // Pre-load pattern templates
    const patterns = {
      'four-on-floor': [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      'breakbeat': [1,0,0,1,0,0,1,0,0,1,0,0,0,1,0,0],
      'trap': [1,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0],
      'dnb': [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
      'techno': [1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],
      'house': [1,0,0,1,0,0,1,0,1,0,0,1,0,0,1,0],
      'dubstep': [1,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0],
      'garage': [1,0,0,1,0,0,0,1,0,0,1,0,0,1,0,0]
    };
    
    for (let [name, pattern] of Object.entries(patterns)) {
      this.patterns.library.set(name, {
        data: pattern,
        variations: this.generateVariations(pattern),
        energy: this.calculatePatternEnergy(pattern),
        complexity: this.calculatePatternComplexity(pattern)
      });
    }
  }
  
  initializeMixGraph() {
    // Build mix transition graph
    this.mixGraph.nodes.set('intro', {
      energy: 0.2,
      compatible: ['buildup', 'verse'],
      incompatible: ['drop', 'peak']
    });
    
    this.mixGraph.nodes.set('buildup', {
      energy: 0.6,
      compatible: ['drop', 'peak', 'breakdown'],
      incompatible: ['intro', 'outro']
    });
    
    this.mixGraph.nodes.set('drop', {
      energy: 1.0,
      compatible: ['peak', 'breakdown', 'verse'],
      incompatible: ['intro']
    });
    
    this.mixGraph.nodes.set('peak', {
      energy: 1.0,
      compatible: ['drop', 'breakdown'],
      incompatible: ['intro', 'buildup']
    });
    
    this.mixGraph.nodes.set('breakdown', {
      energy: 0.4,
      compatible: ['buildup', 'verse', 'outro'],
      incompatible: ['peak']
    });
    
    this.mixGraph.nodes.set('verse', {
      energy: 0.5,
      compatible: ['chorus', 'buildup', 'breakdown'],
      incompatible: ['peak']
    });
    
    this.mixGraph.nodes.set('chorus', {
      energy: 0.8,
      compatible: ['drop', 'verse', 'breakdown'],
      incompatible: ['intro']
    });
    
    this.mixGraph.nodes.set('outro', {
      energy: 0.2,
      compatible: ['intro'],
      incompatible: ['drop', 'peak', 'buildup']
    });
  }
  
  setupEventListeners() {
    // Get UI elements
    this.ui = {
      startInterface: document.getElementById('startInterface'),
      startPortal: document.getElementById('startPortal'),
      neuralCursor: document.getElementById('neuralCursor'),
      loadingDNA: document.getElementById('loadingDNA'),
      
      // Canvases
      waveformCanvas: document.getElementById('waveformCanvas'),
      spectralCanvas: document.getElementById('spectralCanvas'),
      harmonicCanvas: document.getElementById('harmonicCanvas'),
      decisionCanvas: document.getElementById('decisionCanvas'),
      mixGraphCanvas: document.getElementById('mixGraphCanvas'),
      transitionCanvas: document.getElementById('transitionCanvas'),
      reactiveCanvas: document.getElementById('reactiveCanvas'),
      eqCanvas: document.getElementById('eqCanvas'),
      
      // Controls
      crossfader: document.getElementById('crossfader'),
      crossfaderPosition: document.getElementById('crossfaderPosition'),
      scratchWheel: document.getElementById('scratchWheel'),
      controlKnobs: document.querySelectorAll('.control-knob'),
      
      // Displays
      consciousnessValue: document.getElementById('consciousnessValue'),
      neuralDecision: document.getElementById('neuralDecision'),
      crowdEnergy: document.getElementById('crowdEnergy'),
      memoryBank: document.getElementById('memoryBank'),
      patternSequencer: document.getElementById('patternSequencer'),
      phraseStructure: document.getElementById('phraseStructure'),
      neuralState: document.getElementById('neuralState'),
      
      // Metrics
      fps: document.getElementById('fps'),
      cpu: document.getElementById('cpu'),
      latency: document.getElementById('latency'),
      currentBPM: document.getElementById('currentBPM'),
      currentKey: document.getElementById('currentKey'),
      syncStatus: document.getElementById('syncStatus')
    };
    
    // Start button
    this.ui.startPortal.addEventListener('click', () => this.awaken());
    
    // Custom cursor
    document.addEventListener('mousemove', (e) => {
      this.ui.neuralCursor.style.left = e.clientX - 10 + 'px';
      this.ui.neuralCursor.style.top = e.clientY - 10 + 'px';
    });
    
    // Crossfader interaction
    this.setupCrossfaderInteraction();
    
    // Scratch wheel interaction
    this.setupScratchWheelInteraction();
    
    // Control knobs
    this.setupControlKnobs();
    
    // Keyboard shortcuts
    this.setupKeyboardShortcuts();
    
    // Window resize
    window.addEventListener('resize', () => this.handleResize());
  }
  
  setupCrossfaderInteraction() {
    let isDragging = false;
    
    this.ui.crossfaderPosition.addEventListener('mousedown', (e) => {
      isDragging = true;
      this.ui.crossfaderPosition.style.cursor = 'grabbing';
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      
      const rect = this.ui.crossfader.getBoundingClientRect();
      const x = e.clientX - rect.left;
      const position = Math.max(10, Math.min(rect.width - 10, x));
      const normalized = (position - 10) / (rect.width - 20);
      
      this.ui.crossfaderPosition.style.left = position + 'px';
      this.updateCrossfaderValue(normalized * 2 - 1);
    });
    
    document.addEventListener('mouseup', () => {
      isDragging = false;
      this.ui.crossfaderPosition.style.cursor = 'grab';
    });
  }
  
  setupScratchWheelInteraction() {
    let isScratching = false;
    let lastAngle = 0;
    
    this.ui.scratchWheel.addEventListener('mousedown', (e) => {
      isScratching = true;
      this.ui.scratchWheel.classList.add('scratching');
      lastAngle = this.getWheelAngle(e);
    });
    
    document.addEventListener('mousemove', (e) => {
      if (!isScratching) return;
      
      const angle = this.getWheelAngle(e);
      const delta = angle - lastAngle;
      
      if (Math.abs(delta) < 180) {
        this.applyScratch(delta);
      }
      
      lastAngle = angle;
    });
    
    document.addEventListener('mouseup', () => {
      isScratching = false;
      this.ui.scratchWheel.classList.remove('scratching');
    });
  }
  
  getWheelAngle(e) {
    const rect = this.ui.scratchWheel.getBoundingClientRect();
    const centerX = rect.left + rect.width / 2;
    const centerY = rect.top + rect.height / 2;
    
    const angle = Math.atan2(e.clientY - centerY, e.clientX - centerX);
    return angle * 180 / Math.PI;
  }
  
  setupControlKnobs() {
    this.ui.controlKnobs.forEach(knob => {
      let isDragging = false;
      let startY = 0;
      let startValue = 0;
      
      knob.addEventListener('mousedown', (e) => {
        isDragging = true;
        startY = e.clientY;
        startValue = parseFloat(knob.dataset.value || 0);
      });
      
      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        
        const delta = (startY - e.clientY) / 100;
        const newValue = Math.max(0, Math.min(1, startValue + delta));
        
        knob.dataset.value = newValue;
        const indicator = knob.querySelector('.knob-indicator');
        indicator.style.transform = `translate(-50%, -100%) rotate(${newValue * 270 - 135}deg)`;
        
        this.updateControlValue(knob.dataset.control, newValue);
      });
      
      document.addEventListener('mouseup', () => {
        isDragging = false;
      });
    });
  }
  
  setupKeyboardShortcuts() {
    document.addEventListener('keydown', (e) => {
      if (!this.isPlaying) return;
      
      switch(e.key) {
        case ' ':
          e.preventDefault();
          this.toggleRecording();
          break;
        case '1':
          this.triggerCuePoint(1);
          break;
        case '2':
          this.triggerCuePoint(2);
          break;
        case '3':
          this.triggerCuePoint(3);
          break;
        case '4':
          this.triggerCuePoint(4);
          break;
        case 'q':
          this.triggerEffect('filter');
          break;
        case 'w':
          this.triggerEffect('delay');
          break;
        case 'e':
          this.triggerEffect('reverb');
          break;
        case 'r':
          this.triggerEffect('glitch');
          break;
        case 'd':
          this.triggerDrop();
          break;
        case 'b':
          this.triggerBuild();
          break;
        case 't':
          this.planTransition();
          break;
        case 'l':
          this.toggleLoop();
          break;
        case 's':
          this.toggleSync();
          break;
        case 'ArrowUp':
          this.adjustTempo(1);
          break;
        case 'ArrowDown':
          this.adjustTempo(-1);
          break;
        case 'ArrowLeft':
          this.adjustCrossfader(-0.1);
          break;
        case 'ArrowRight':
          this.adjustCrossfader(0.1);
          break;
      }
    });
  }
  
  async awaken() {
    console.log('🧠 AWAKENING NEUROMANCER...');
    
    this.ui.loadingDNA.classList.add('active');
    this.ui.neuralCursor.classList.add('active');
    
    try {
      // Initialize audio context
      await this.initializeAudio();
      
      // Start consciousness
      this.consciousness.state = 'awakening';
      this.consciousness.awareness = 0.1;
      
      // Initialize visualizations
      this.initializeCanvases();
      
      // Start all systems
      this.startSystems();
      
      // Hide start interface
      this.ui.startInterface.classList.add('hidden');
      this.ui.loadingDNA.classList.remove('active');
      
      // Begin neural evolution
      this.evolve();
      
      console.log('⚡ NEUROMANCER ONLINE');
      console.log('🎧 Sample Rate:', this.ctx.sampleRate);
      console.log('🔊 Latency:', this.ctx.baseLatency * 1000, 'ms');
      
    } catch (error) {
      console.error('Awakening failed:', error);
      this.ui.loadingDNA.classList.remove('active');
    }
  }
  
  async initializeAudio() {
    // Create audio context
    this.ctx = new (window.AudioContext || window.webkitAudioContext)({
      sampleRate: this.config.sampleRate,
      latencyHint: 'interactive'
    });
    
    // Get microphone access
    const stream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
        sampleRate: this.config.sampleRate,
        channelCount: 2,
        latency: 0
      }
    });
    
    // Setup audio nodes
    await this.setupAudioGraph();
    await this.setupMicrophoneInput(stream);
    await this.loadImpulseResponses();
    
    // Resume context
    await this.ctx.resume();
    
    this.isPlaying = true;
  }
  
  async setupAudioGraph() {
    // Master chain
    this.audioEngine.limiter = this.ctx.createDynamicsCompressor();
    this.audioEngine.limiter.threshold.value = -0.3;
    this.audioEngine.limiter.knee.value = 0;
    this.audioEngine.limiter.ratio.value = 20;
    this.audioEngine.limiter.attack.value = 0.001;
    this.audioEngine.limiter.release.value = 0.01;
    
    this.audioEngine.masterGain = this.ctx.createGain();
    this.audioEngine.masterGain.gain.value = 0.8;
    
    this.audioEngine.analyser = this.ctx.createAnalyser();
    this.audioEngine.analyser.fftSize = this.config.fftSize;
    this.audioEngine.analyser.smoothingTimeConstant = 0.7;
    
    // Create deck channels
    this.createDeckChannel('A');
    this.createDeckChannel('B');
    this.createDeckChannel('C');
    this.createDeckChannel('D');
    
    // Create effects
    await this.createEffectsRack();
    
    // Connect master chain
    this.audioEngine.limiter.connect(this.audioEngine.masterGain);
    this.audioEngine.masterGain.connect(this.audioEngine.analyser);
    this.audioEngine.analyser.connect(this.ctx.destination);
  }
  
  createDeckChannel(id) {
    const deck = {
      input: this.ctx.createGain(),
      gain: this.ctx.createGain(),
      eq: {
        low: this.ctx.createBiquadFilter(),
        lowMid: this.ctx.createBiquadFilter(),
        highMid: this.ctx.createBiquadFilter(),
        high: this.ctx.createBiquadFilter()
      },
      filter: this.ctx.createBiquadFilter(),
      compressor: this.ctx.createDynamicsCompressor(),
      panner: this.ctx.createStereoPanner(),
      analyser: this.ctx.createAnalyser()
    };
    
    // Configure EQ
    deck.eq.low.type = 'lowshelf';
    deck.eq.low.frequency.value = 250;
    
    deck.eq.lowMid.type = 'peaking';
    deck.eq.lowMid.frequency.value = 800;
    deck.eq.lowMid.Q.value = 0.7;
    
    deck.eq.highMid.type = 'peaking';
    deck.eq.highMid.frequency.value = 3000;
    deck.eq.highMid.Q.value = 0.7;
    
    deck.eq.high.type = 'highshelf';
    deck.eq.high.frequency.value = 8000;
    
    // Configure filter
    deck.filter.type = 'lowpass';
    deck.filter.frequency.value = 20000;
    deck.filter.Q.value = 1;
    
    // Configure compressor
    deck.compressor.threshold.value = -12;
    deck.compressor.knee.value = 2;
    deck.compressor.ratio.value = 4;
    deck.compressor.attack.value = 0.003;
    deck.compressor.release.value = 0.1;
    
    // Connect deck chain
    deck.input.connect(deck.eq.low);
    deck.eq.low.connect(deck.eq.lowMid);
    deck.eq.lowMid.connect(deck.eq.highMid);
    deck.eq.highMid.connect(deck.eq.high);
    deck.eq.high.connect(deck.filter);
    deck.filter.connect(deck.compressor);
    deck.compressor.connect(deck.panner);
    deck.panner.connect(deck.gain);
    deck.gain.connect(deck.analyser);
    deck.analyser.connect(this.audioEngine.limiter);
    
    this.audioEngine[`deck${id}`] = deck;
  }
  
  async createEffectsRack() {
    // Reverb
    this.effects.reverbs.set('hall', await this.createReverb('hall'));
    this.effects.reverbs.set('plate', await this.createReverb('plate'));
    this.effects.reverbs.set('spring', await this.createReverb('spring'));
    this.effects.reverbs.set('shimmer', await this.createReverb('shimmer'));
    
    // Delays
    this.effects.delays.set('eighth', this.createDelay(0.375));
    this.effects.delays.set('dotted', this.createDelay(0.5625));
    this.effects.delays.set('ping-pong', this.createPingPongDelay());
    this.effects.delays.set('tape', this.createTapeDelay());
    
    // Filters
    this.effects.filters.set('lowpass', this.createFilter('lowpass'));
    this.effects.filters.set('highpass', this.createFilter('highpass'));
    this.effects.filters.set('bandpass', this.createFilter('bandpass'));
    this.effects.filters.set('notch', this.createFilter('notch'));
    
    // Distortions
    this.effects.distortions.set('overdrive', this.createDistortion('overdrive'));
    this.effects.distortions.set('bitcrusher', this.createBitcrusher());
    this.effects.distortions.set('waveshaper', this.createWaveshaper());
    
    // Modulators
    this.effects.modulators.set('chorus', this.createChorus());
    this.effects.modulators.set('phaser', this.createPhaser());
    this.effects.modulators.set('flanger', this.createFlanger());
    this.effects.modulators.set('tremolo', this.createTremolo());
  }
  
  async createReverb(type) {
    const convolver = this.ctx.createConvolver();
    const impulse = await this.generateImpulseResponse(type);
    convolver.buffer = impulse;
    
    const wetGain = this.ctx.createGain();
    const dryGain = this.ctx.createGain();
    const outputGain = this.ctx.createGain();
    
    wetGain.gain.value = 0;
    dryGain.gain.value = 1;
    
    convolver.connect(wetGain);
    wetGain.connect(outputGain);
    dryGain.connect(outputGain);
    
    return {
      input: convolver,
      dry: dryGain,
      wet: wetGain,
      output: outputGain,
      convolver
    };
  }
  
  createDelay(time) {
    const delay = this.ctx.createDelay(5);
    const feedback = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    const wetGain = this.ctx.createGain();
    const dryGain = this.ctx.createGain();
    const outputGain = this.ctx.createGain();
    
    delay.delayTime.value = time;
    feedback.gain.value = 0.4;
    filter.type = 'highpass';
    filter.frequency.value = 200;
    wetGain.gain.value = 0;
    dryGain.gain.value = 1;
    
    delay.connect(feedback);
    feedback.connect(filter);
    filter.connect(delay);
    delay.connect(wetGain);
    wetGain.connect(outputGain);
    dryGain.connect(outputGain);
    
    return {
      input: delay,
      delay,
      feedback,
      filter,
      wet: wetGain,
      dry: dryGain,
      output: outputGain
    };
  }
  
  createPingPongDelay() {
    const delayL = this.ctx.createDelay(5);
    const delayR = this.ctx.createDelay(5);
    const feedbackL = this.ctx.createGain();
    const feedbackR = this.ctx.createGain();
    const merger = this.ctx.createChannelMerger(2);
    const splitter = this.ctx.createChannelSplitter(2);
    
    delayL.delayTime.value = 0.375;
    delayR.delayTime.value = 0.375;
    feedbackL.gain.value = 0.5;
    feedbackR.gain.value = 0.5;
    
    splitter.connect(delayL, 0);
    splitter.connect(delayR, 1);
    
    delayL.connect(feedbackL);
    delayR.connect(feedbackR);
    
    feedbackL.connect(delayR);
    feedbackR.connect(delayL);
    
    delayL.connect(merger, 0, 0);
    delayR.connect(merger, 0, 1);
    
    return {
      input: splitter,
      output: merger,
      delayL,
      delayR,
      feedbackL,
      feedbackR
    };
  }
  
  createTapeDelay() {
    const delay = this.ctx.createDelay(5);
    const wow = this.ctx.createOscillator();
    const wowGain = this.ctx.createGain();
    const flutter = this.ctx.createOscillator();
    const flutterGain = this.ctx.createGain();
    const filter = this.ctx.createBiquadFilter();
    
    wow.frequency.value = 0.5;
    wowGain.gain.value = 0.002;
    flutter.frequency.value = 5;
    flutterGain.gain.value = 0.0005;
    
    filter.type = 'lowpass';
    filter.frequency.value = 5000;
    
    wow.connect(wowGain);
    flutter.connect(flutterGain);
    wowGain.connect(delay.delayTime);
    flutterGain.connect(delay.delayTime);
    
    delay.delayTime.value = 0.25;
    delay.connect(filter);
    
    wow.start();
    flutter.start();
    
    return {
      input: delay,
      output: filter,
      delay,
      filter,
      wow,
      flutter
    };
  }
  
  createFilter(type) {
    const filter = this.ctx.createBiquadFilter();
    filter.type = type;
    filter.frequency.value = 1000;
    filter.Q.value = 1;
    
    return filter;
  }
  
  createDistortion(type) {
    const waveshaper = this.ctx.createWaveShaper();
    const preGain = this.ctx.createGain();
    const postGain = this.ctx.createGain();
    
    let curve;
    switch(type) {
      case 'overdrive':
        curve = this.generateOverdriveCurve();
        preGain.gain.value = 4;
        postGain.gain.value = 0.25;
        break;
      case 'fuzz':
        curve = this.generateFuzzCurve();
        preGain.gain.value = 10;
        postGain.gain.value = 0.1;
        break;
      default:
        curve = new Float32Array(256);
        for (let i = 0; i < 256; i++) {
          curve[i] = (i - 128) / 128;
        }
    }
    
    waveshaper.curve = curve;
    waveshaper.oversample = '4x';
    
    preGain.connect(waveshaper);
    waveshaper.connect(postGain);
    
    return {
      input: preGain,
      output: postGain,
      waveshaper,
      preGain,
      postGain
    };
  }
  
  createBitcrusher() {
    // Bit crusher using script processor (would use AudioWorklet in production)
    const bufferSize = 4096;
    const node = this.ctx.createScriptProcessor(bufferSize, 1, 1);
    
    let bits = 8;
    let normFreq = 0.1;
    
    node.onaudioprocess = (e) => {
      const input = e.inputBuffer.getChannelData(0);
      const output = e.outputBuffer.getChannelData(0);
      
      const step = Math.pow(0.5, bits);
      const phaser = 1 / normFreq;
      let last = 0;
      
      for (let i = 0; i < bufferSize; i++) {
        if (i % phaser === 0) {
          last = step * Math.floor(input[i] / step);
        }
        output[i] = last;
      }
    };
    
    return {
      input: node,
      output: node,
      setBits: (b) => bits = b,
      setSampleRate: (sr) => normFreq = sr
    };
  }
  
  createWaveshaper() {
    const shaper = this.ctx.createWaveShaper();
    const curve = new Float32Array(65536);
    
    for (let i = 0; i < 65536; i++) {
      const x = (i - 32768) / 32768;
      curve[i] = Math.tanh(x * 5);
    }
    
    shaper.curve = curve;
    shaper.oversample = '4x';
    
    return shaper;
  }
  
  createChorus() {
    const splitter = this.ctx.createChannelSplitter(2);
    const merger = this.ctx.createChannelMerger(2);
    const delayL = this.ctx.createDelay(1);
    const delayR = this.ctx.createDelay(1);
    const lfoL = this.ctx.createOscillator();
    const lfoR = this.ctx.createOscillator();
    const lfoGainL = this.ctx.createGain();
    const lfoGainR = this.ctx.createGain();
    
    delayL.delayTime.value = 0.02;
    delayR.delayTime.value = 0.03;
    
    lfoL.frequency.value = 0.5;
    lfoR.frequency.value = 0.7;
    
    lfoGainL.gain.value = 0.005;
    lfoGainR.gain.value = 0.005;
    
    lfoL.connect(lfoGainL);
    lfoR.connect(lfoGainR);
    
    lfoGainL.connect(delayL.delayTime);
    lfoGainR.connect(delayR.delayTime);
    
    splitter.connect(delayL, 0);
    splitter.connect(delayR, 1);
    
    delayL.connect(merger, 0, 0);
    delayR.connect(merger, 0, 1);
    
    lfoL.start();
    lfoR.start();
    
    return {
      input: splitter,
      output: merger,
      lfoL,
      lfoR,
      delayL,
      delayR
    };
  }
  
  createPhaser() {
    const stages = 4;
    const filters = [];
    const lfo = this.ctx.createOscillator();
    const lfoGain = this.ctx.createGain();
    
    lfo.frequency.value = 0.5;
    lfoGain.gain.value = 1000;
    
    let lastNode = null;
    
    for (let i = 0; i < stages; i++) {
      const filter = this.ctx.createBiquadFilter();
      filter.type = 'allpass';
      filter.frequency.value = 1000;
      filter.Q.value = 10;
      
      lfo.connect(lfoGain);
      lfoGain.connect(filter.frequency);
      
      if (lastNode) {
        lastNode.connect(filter);
      }
      
      filters.push(filter);
      lastNode = filter;
    }
    
    lfo.start();
    
    return {
      input: filters[0],
      output: filters[filters.length - 1],
      filters,
      lfo,
      lfoGain
    };
  }
  
  createFlanger() {
    const delay = this.ctx.createDelay(1);
    const lfo = this.ctx.createOscillator();
    const lfoGain = this.ctx.createGain();
    const feedback = this.ctx.createGain();
    const wetGain = this.ctx.createGain();
    const dryGain = this.ctx.createGain();
    const output = this.ctx.createGain();
    
    delay.delayTime.value = 0.005;
    lfo.frequency.value = 0.25;
    lfoGain.gain.value = 0.002;
    feedback.gain.value = 0.5;
    wetGain.gain.value = 0.5;
    dryGain.gain.value = 0.5;
    
    lfo.connect(lfoGain);
    lfoGain.connect(delay.delayTime);
    
    delay.connect(feedback);
    feedback.connect(delay);
    delay.connect(wetGain);
    wetGain.connect(output);
    dryGain.connect(output);
    
    lfo.start();
    
    return {
      input: delay,
      dry: dryGain,
      output,
      delay,
      lfo,
      feedback
    };
  }
  
  createTremolo() {
    const gain = this.ctx.createGain();
    const lfo = this.ctx.createOscillator();
    const lfoGain = this.ctx.createGain();
    
    lfo.frequency.value = 5;
    lfoGain.gain.value = 0.5;
    gain.gain.value = 0.5;
    
    lfo.connect(lfoGain);
    lfoGain.connect(gain.gain);
    
    lfo.start();
    
    return {
      input: gain,
      output: gain,
      lfo,
      depth: lfoGain
    };
  }
  
  async setupMicrophoneInput(stream) {
    this.audioEngine.micInput = this.ctx.createMediaStreamSource(stream);
    this.audioEngine.micGain = this.ctx.createGain();
    this.audioEngine.micGain.gain.value = 1;
    
    this.audioEngine.micFilter = this.ctx.createBiquadFilter();
    this.audioEngine.micFilter.type = 'highpass';
    this.audioEngine.micFilter.frequency.value = 80;
    
    this.audioEngine.micAnalyser = this.ctx.createAnalyser();
    this.audioEngine.micAnalyser.fftSize = this.config.pitchDetectionSize;
    
    // Connect mic chain
    this.audioEngine.micInput.connect(this.audioEngine.micFilter);
    this.audioEngine.micFilter.connect(this.audioEngine.micGain);
    this.audioEngine.micGain.connect(this.audioEngine.micAnalyser);
    
    // Setup recording processor
    this.setupRecordingProcessor();
  }
  
  setupRecordingProcessor() {
    const bufferSize = 4096;
    this.audioEngine.recorder = this.ctx.createScriptProcessor(bufferSize, 1, 1);
    
    this.audioEngine.recorder.onaudioprocess = (e) => {
      if (!this.isRecording) return;
      
      const input = e.inputBuffer.getChannelData(0);
      this.audioEngine.recordBuffer.push(...input);
      
      // Auto-stop on silence
      const rms = Math.sqrt(input.reduce((sum, x) => sum + x * x, 0) / input.length);
      if (rms < 0.01) {
        this.silenceCounter++;
        if (this.silenceCounter > 50) {
          this.stopRecording();
        }
      } else {
        this.silenceCounter = 0;
      }
    };
    
    this.audioEngine.micGain.connect(this.audioEngine.recorder);
    this.audioEngine.recorder.connect(this.ctx.destination);
  }
  
  async loadImpulseResponses() {
    // Generate impulse responses for reverbs
    // In production, would load real IRs
  }
  
  async generateImpulseResponse(type) {
    const length = this.ctx.sampleRate * 2;
    const buffer = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
    
    for (let channel = 0; channel < 2; channel++) {
      const data = buffer.getChannelData(channel);
      
      for (let i = 0; i < length; i++) {
        let sample = (Math.random() * 2 - 1);
        
        switch(type) {
          case 'hall':
            sample *= Math.pow(1 - i / length, 2);
            break;
          case 'plate':
            sample *= Math.pow(1 - i / length, 1.5);
            break;
          case 'spring':
            sample *= Math.pow(1 - i / length, 3) * Math.sin(i * 0.01);
            break;
          case 'shimmer':
            sample *= Math.pow(1 - i / length, 1) * Math.sin(i * 0.1);
            break;
        }
        
        data[i] = sample * 0.3;
      }
    }
    
    return buffer;
  }
  
  generateOverdriveCurve() {
    const samples = 65536;
    const curve = new Float32Array(samples);
    
    for (let i = 0; i < samples; i++) {
      const x = (i - samples / 2) / (samples / 2);
      curve[i] = Math.tanh(x * 3) * 0.8;
    }
    
    return curve;
  }
  
  generateFuzzCurve() {
    const samples = 65536;
    const curve = new Float32Array(samples);
    
    for (let i = 0; i < samples; i++) {
      const x = (i - samples / 2) / (samples / 2);
      curve[i] = Math.sign(x) * Math.min(Math.abs(x * 10), 1);
    }
    
    return curve;
  }
  
  initializeCanvases() {
    // Setup canvas contexts
    this.canvases.waveform = this.ui.waveformCanvas.getContext('2d');
    this.canvases.spectral = this.ui.spectralCanvas.getContext('2d');
    this.canvases.harmonic = this.ui.harmonicCanvas.getContext('2d');
    this.canvases.decision = this.ui.decisionCanvas.getContext('2d');
    this.canvases.mixGraph = this.ui.mixGraphCanvas.getContext('2d');
    this.canvases.transition = this.ui.transitionCanvas.getContext('2d');
    this.canvases.reactive = this.ui.reactiveCanvas.getContext('2d');
    this.canvases.eq = this.ui.eqCanvas.getContext('2d');
    
    // Set canvas sizes
    this.handleResize();
    
    // Initialize pattern sequencer
    this.initializePatternSequencer();
    
    // Initialize neural matrix
    this.initializeNeuralMatrix();
    
    // Create synaptic field
    this.createSynapticField();
  }
  
  initializePatternSequencer() {
    const sequencer = this.ui.patternSequencer;
    sequencer.innerHTML = '';
    
    for (let row = 0; row < 16; row++) {
      for (let col = 0; col < 16; col++) {
        const cell = document.createElement('div');
        cell.className = 'pattern-cell';
        cell.dataset.row = row;
        cell.dataset.col = col;
        cell.addEventListener('click', () => this.togglePatternCell(row, col));
        sequencer.appendChild(cell);
      }
    }
  }
  
  initializeNeuralMatrix() {
    const matrix = document.getElementById('neuralMatrix');
    matrix.innerHTML = '';
    
    for (let i = 0; i < 89 * 55; i++) {
      const cell = document.createElement('div');
      cell.className = 'neural-cell';
      matrix.appendChild(cell);
    }
  }
  
  createSynapticField() {
    const field = document.getElementById('synapticField');
    
    for (let i = 0; i < 20; i++) {
      const synapse = document.createElement('div');
      synapse.className = 'synapse';
      synapse.style.top = Math.random() * 100 + '%';
      synapse.style.left = Math.random() * 100 + '%';
      synapse.style.width = Math.random() * 200 + 100 + 'px';
      synapse.style.transform = `rotate(${Math.random() * 360}deg)`;
      synapse.style.animationDelay = Math.random() * 3 + 's';
      synapse.style.animationDuration = 3 + Math.random() * 2 + 's';
      field.appendChild(synapse);
    }
  }
  
  startSystems() {
    // Start all core systems
    this.startScheduler();
    this.startAnalysisEngine();
    this.startNeuralProcessor();
    this.startPatternRecognition();
    this.startVisualization();
    this.startCrowdSimulation();
    this.startPerformanceMonitor();
  }
  
  startScheduler() {
    const schedule = () => {
      if (!this.isPlaying) return;
      
      const currentTime = this.ctx.currentTime;
      
      while (this.clock.nextEventTime < currentTime + this.clock.lookahead) {
        this.scheduleEvent(this.clock.nextEventTime);
        this.advanceClock();
      }
      
      setTimeout(schedule, this.clock.scheduleInterval);
    };
    
    this.clock.startTime = this.ctx.currentTime;
    this.clock.nextEventTime = this.clock.startTime;
    schedule();
  }
  
  scheduleEvent(time) {
    // Calculate position
    const beat = Math.floor((time - this.clock.startTime) * this.tempo.bpm / 60);
    const bar = Math.floor(beat / 4);
    const beatInBar = beat % 4;
    const sixteenth = Math.floor((beat * 4) % 16);
    
    // Update sequencer
    this.updateSequencer(sixteenth);
    
    // Process patterns
    this.processPatterns(time, bar, beatInBar);
    
    // Neural decisions
    if (beatInBar === 0) {
      this.makeNeuralDecision(time);
    }
    
    // Update mix
    this.updateMix(time);
    
    // Apply automation
    this.applyAutomation(time);
  }
  
  advanceClock() {
    const sixteenthNote = 60 / (this.tempo.bpm * 4);
    
    // Add swing
    let swing = 0;
    const position = Math.floor((this.clock.nextEventTime - this.clock.startTime) / sixteenthNote) % 2;
    if (position === 1) {
      swing = this.tempo.swing * sixteenthNote * 0.2;
    }
    
    // Add humanization
    const humanize = (Math.random() - 0.5) * this.tempo.humanize * sixteenthNote;
    
    this.clock.nextEventTime += sixteenthNote + swing + humanize;
  }
  
  updateSequencer(step) {
    const cells = this.ui.patternSequencer.children;
    
    for (let i = 0; i < cells.length; i++) {
      const col = parseInt(cells[i].dataset.col);
      if (col === step) {
        cells[i].classList.add('current');
      } else {
        cells[i].classList.remove('current');
      }
    }
  }
  
  processPatterns(time, bar, beat) {
    // Process active patterns
    for (let pattern of this.patterns.active) {
      this.executePattern(pattern, time, bar, beat);
    }
  }
  
  executePattern(pattern, time, bar, beat) {
    // Execute pattern actions
    // This would trigger samples, effects, etc.
  }
  
  makeNeuralDecision(time) {
    // Gather inputs
    const inputs = this.gatherNeuralInputs();
    
    // Process through network
    const outputs = this.processNeuralNetwork(inputs);
    
    // Interpret outputs
    const decision = this.interpretNeuralOutput(outputs);
    
    // Apply decision
    this.applyNeuralDecision(decision, time);
    
    // Update UI
    this.displayNeuralDecision(decision);
    
    // Learn from outcome
    this.learnFromDecision(decision);
  }
  
  gatherNeuralInputs() {
    const inputs = new Float32Array(this.config.neuralLayers[0]);
    
    // Energy and dynamics
    inputs[0] = this.consciousness.energy;
    inputs[1] = this.consciousness.tension;
    inputs[2] = this.crowd.energy;
    inputs[3] = this.crowd.engagement;
    
    // Spectral features
    const spectrum = new Uint8Array(this.audioEngine.analyser.frequencyBinCount);
    this.audioEngine.analyser.getByteFrequencyData(spectrum);
    
    let centroid = 0, spread = 0, flux = 0;
    for (let i = 0; i < spectrum.length; i++) {
      const freq = i * this.ctx.sampleRate / (2 * spectrum.length);
      const mag = spectrum[i] / 255;
      centroid += freq * mag;
    }
    
    inputs[4] = centroid / 10000;
    inputs[5] = spread / 1000;
    inputs[6] = flux;
    
    // Temporal features
    inputs[7] = this.tempo.bpm / 200;
    inputs[8] = this.tempo.confidence;
    inputs[9] = this.tempo.phase;
    
    // Harmonic features
    for (let i = 0; i < 12; i++) {
      inputs[10 + i] = this.harmony.chroma?.[i] || 0;
    }
    
    // Pattern features
    inputs[22] = this.patterns.active.size / 10;
    inputs[23] = this.patterns.confidence.size / 10;
    
    // Memory features
    inputs[24] = this.consciousness.shortTermMemory.length / 100;
    inputs[25] = this.consciousness.longTermMemory.size / 1000;
    
    // Mix state
    inputs[26] = this.crossfaderValue || 0;
    inputs[27] = this.filterValue || 0.5;
    inputs[28] = this.resonanceValue || 0.5;
    
    // Fill remaining with noise for exploration
    for (let i = 29; i < inputs.length; i++) {
      inputs[i] = Math.random() * 0.1;
    }
    
    return inputs;
  }
  
  processNeuralNetwork(inputs) {
    let activations = inputs;
    
    // Forward pass through layers
    for (let layer = 0; layer < this.neuralNet.weights.length; layer++) {
      const weights = this.neuralNet.weights[layer];
      const biases = this.neuralNet.biases[layer];
      const outputSize = biases.length;
      const inputSize = activations.length;
      
      const output = new Float32Array(outputSize);
      
      // Matrix multiplication
      for (let i = 0; i < outputSize; i++) {
        let sum = biases[i];
        for (let j = 0; j < inputSize; j++) {
          sum += activations[j] * weights[j * outputSize + i];
        }
        
        // Activation function (ReLU for hidden, sigmoid for output)
        if (layer < this.neuralNet.weights.length - 1) {
          output[i] = Math.max(0, sum); // ReLU
        } else {
          output[i] = 1 / (1 + Math.exp(-sum)); // Sigmoid
        }
      }
      
      activations = output;
      this.neuralNet.activations[layer] = output;
    }
    
    return activations;
  }
  
  interpretNeuralOutput(outputs) {
    // Decision categories
    const decisions = {
      action: '',
      confidence: 0,
      parameters: {},
      timing: 'immediate'
    };
    
    // Find dominant action
    const actions = [
      'maintain', 'build', 'drop', 'breakdown',
      'transition', 'loop', 'effects', 'scratch',
      'sample', 'filter_sweep', 'eq_kill', 'surprise'
    ];
    
    let maxIdx = 0;
    let maxVal = outputs[0];
    
    for (let i = 1; i < Math.min(outputs.length, actions.length); i++) {
      if (outputs[i] > maxVal) {
        maxVal = outputs[i];
        maxIdx = i;
      }
    }
    
    decisions.action = actions[maxIdx];
    decisions.confidence = maxVal;
    
    // Extract parameters from remaining outputs
    decisions.parameters = {
      intensity: outputs[12] || 0.5,
      duration: outputs[13] || 0.5,
      complexity: outputs[14] || 0.5,
      risk: outputs[15] || 0.3
    };
    
    // Timing decision
    if (outputs[16] > 0.7) {
      decisions.timing = 'next_bar';
    } else if (outputs[16] > 0.4) {
      decisions.timing = 'next_beat';
    }
    
    return decisions;
  }
  
  applyNeuralDecision(decision, time) {
    console.log('🧠 Neural Decision:', decision);
    
    switch(decision.action) {
      case 'build':
        this.initiateBuild(decision.parameters, time);
        break;
      case 'drop':
        this.initiateDrop(decision.parameters, time);
        break;
      case 'breakdown':
        this.initiateBreakdown(decision.parameters, time);
        break;
      case 'transition':
        this.initiateTransition(decision.parameters, time);
        break;
      case 'loop':
        this.activateLoop(decision.parameters, time);
        break;
      case 'effects':
        this.triggerEffectCombo(decision.parameters, time);
        break;
      case 'scratch':
        this.performAutoScratch(decision.parameters, time);
        break;
      case 'sample':
        this.triggerSample(decision.parameters, time);
        break;
      case 'filter_sweep':
        this.performFilterSweep(decision.parameters, time);
        break;
      case 'eq_kill':
        this.performEQKill(decision.parameters, time);
        break;
      case 'surprise':
        this.triggerSurprise(decision.parameters, time);
        break;
      default:
        // Maintain current state
        break;
    }
    
    // Update consciousness
    this.updateConsciousness(decision);
  }
  
  displayNeuralDecision(decision) {
    this.ui.neuralDecision.textContent = decision.action.toUpperCase();
    this.ui.neuralDecision.classList.add('visible');
    
    setTimeout(() => {
      this.ui.neuralDecision.classList.remove('visible');
    }, 2000);
    
    // Update neural state indicators
    const stateNodes = this.ui.neuralState.children;
    for (let node of stateNodes) {
      node.classList.remove('active');
    }
    
    // Activate relevant state
    const stateMap = {
      'build': 'plan',
      'drop': 'execute',
      'transition': 'analyze',
      'effects': 'adapt'
    };
    
    const activeState = stateMap[decision.action] || 'analyze';
    const activeNode = document.querySelector(`[data-state="${activeState}"]`);
    if (activeNode) {
      activeNode.classList.add('active');
    }
  }
  
  learnFromDecision(decision) {
    // Store decision in memory
    this.consciousness.shortTermMemory.push({
      time: this.ctx.currentTime,
      decision: decision,
      state: {
        energy: this.consciousness.energy,
        crowd: this.crowd.energy,
        tension: this.consciousness.tension
      }
    });
    
    // Trim short-term memory
    if (this.consciousness.shortTermMemory.length > 100) {
      this.consciousness.shortTermMemory.shift();
    }
    
    // Evaluate outcome after delay
    setTimeout(() => {
      this.evaluateDecisionOutcome(decision);
    }, 5000);
  }
  
  evaluateDecisionOutcome(decision) {
    // Calculate reward based on crowd response
    const currentEnergy = this.crowd.energy;
    const energyDelta = currentEnergy - decision.state.crowd;
    
    const reward = energyDelta * 0.5 + 
                   (1 - Math.abs(this.consciousness.tension - 0.5)) * 0.3 +
                   Math.random() * 0.2;
    
    // Update neural network weights (simplified backprop)
    this.updateNeuralWeights(decision, reward);
    
    // Store successful patterns
    if (reward > 0.7) {
      this.consciousness.longTermMemory.set(
        `${decision.action}_${Date.now()}`,
        { decision, reward, context: this.getCurrentContext() }
      );
    }
  }
  
  updateNeuralWeights(decision, reward) {
    const learningRate = this.neuralNet.optimizer.learningRate;
    const momentum = this.neuralNet.optimizer.beta1;
    
    // Simplified weight update based on reward
    for (let layer = 0; layer < this.neuralNet.weights.length; layer++) {
      const weights = this.neuralNet.weights[layer];
      const activations = this.neuralNet.activations[layer];
      
      for (let i = 0; i < weights.length; i++) {
        // Reward-modulated update
        const gradient = (reward - 0.5) * activations[i % activations.length] * 0.01;
        weights[i] += learningRate * gradient;
        
        // Keep weights bounded
        weights[i] = Math.max(-5, Math.min(5, weights[i]));
      }
    }
  }
  
  getCurrentContext() {
    return {
      tempo: this.tempo.bpm,
      key: this.harmony.currentKey,
      energy: this.consciousness.energy,
      patterns: Array.from(this.patterns.active),
      effects: Array.from(this.effects.automation.keys())
    };
  }
  
  updateMix(time) {
    // Auto-mixing logic
    if (this.consciousness.state === 'mixing') {
      this.performAutoMix(time);
    }
    
    // Update crossfader
    this.updateCrossfaderPosition();
    
    // Update EQ
    this.updateEQAutomation(time);
    
    // Update effects
    this.updateEffectsAutomation(time);
  }
  
  performAutoMix(time) {
    // Intelligent auto-mixing
    const barPosition = (time - this.clock.startTime) % (240 / this.tempo.bpm);
    const mixProgress = barPosition / (240 / this.tempo.bpm);
    
    // Smooth crossfade
    if (this.mixTransition) {
      const progress = (time - this.mixTransition.startTime) / this.mixTransition.duration;
      
      if (progress >= 0 && progress <= 1) {
        const curve = this.calculateMixCurve(progress);
        this.crossfaderValue = curve * 2 - 1;
        
        // Update deck gains
        this.updateDeckGains();
      }
    }
  }
  
  calculateMixCurve(progress) {
    // S-curve for smooth transitions
    return (Math.sin((progress - 0.5) * Math.PI) + 1) / 2;
  }
  
  updateDeckGains() {
    const fadeA = this.crossfaderValue <= 0 ? 1 : 1 - this.crossfaderValue;
    const fadeB = this.crossfaderValue >= 0 ? 1 : 1 + this.crossfaderValue;
    
    if (this.audioEngine.deckA) {
      this.audioEngine.deckA.gain.gain.setTargetAtTime(fadeA, this.ctx.currentTime, 0.01);
    }
    if (this.audioEngine.deckB) {
      this.audioEngine.deckB.gain.gain.setTargetAtTime(fadeB, this.ctx.currentTime, 0.01);
    }
  }
  
  updateEQAutomation(time) {
    // Automated EQ sweeps
    if (this.eqAutomation) {
      const progress = (time - this.eqAutomation.startTime) / this.eqAutomation.duration;
      
      if (progress >= 0 && progress <= 1) {
        const freq = this.eqAutomation.startFreq + 
                    (this.eqAutomation.endFreq - this.eqAutomation.startFreq) * progress;
        
        if (this.audioEngine.deckA) {
          this.audioEngine.deckA.filter.frequency.setTargetAtTime(freq, time, 0.01);
        }
      }
    }
  }
  
  updateEffectsAutomation(time) {
    // Process effect automation
    for (let [effectId, automation] of this.effects.automation) {
      const progress = (time - automation.startTime) / automation.duration;
      
      if (progress >= 0 && progress <= 1) {
        this.applyEffectAutomation(effectId, automation, progress);
      } else if (progress > 1) {
        this.effects.automation.delete(effectId);
      }
    }
  }
  
  applyEffectAutomation(effectId, automation, progress) {
    const effect = this.effects[automation.type]?.get(effectId);
    if (!effect) return;
    
    const value = automation.startValue + 
                  (automation.endValue - automation.startValue) * progress;
    
    switch(automation.parameter) {
      case 'wet':
        if (effect.wet) {
          effect.wet.gain.setTargetAtTime(value, this.ctx.currentTime, 0.01);
        }
        break;
      case 'frequency':
        if (effect.filter) {
          effect.filter.frequency.setTargetAtTime(value, this.ctx.currentTime, 0.01);
        }
        break;
      case 'feedback':
        if (effect.feedback) {
          effect.feedback.gain.setTargetAtTime(value, this.ctx.currentTime, 0.01);
        }
        break;
    }
  }
  
  applyAutomation(time) {
    // Apply all scheduled automation
    for (let event of this.audioEngine.scheduledEvents) {
      if (event.time <= time && !event.triggered) {
        event.callback();
        event.triggered = true;
      }
    }
    
    // Clean up old events
    this.audioEngine.scheduledEvents = this.audioEngine.scheduledEvents.filter(
      e => !e.triggered
    );
  }
  
  // Analysis Engine
  startAnalysisEngine() {
    const analyze = () => {
      if (!this.isPlaying) return;
      
      this.analyzeSpectrum();
      this.analyzeTempo();
      this.analyzeHarmony();
      this.analyzeStructure();
      this.analyzeEnergy();
      
      requestAnimationFrame(analyze);
    };
    
    requestAnimationFrame(analyze);
  }
  
  analyzeSpectrum() {
    const spectrum = new Uint8Array(this.audioEngine.analyser.frequencyBinCount);
    this.audioEngine.analyser.getByteFrequencyData(spectrum);
    
    // Calculate spectral features
    let centroid = 0, spread = 0, flux = 0;
    let totalMag = 0;
    
    for (let i = 0; i < spectrum.length; i++) {
      const freq = i * this.ctx.sampleRate / (2 * spectrum.length);
      const mag = spectrum[i] / 255;
      
      centroid += freq * mag;
      totalMag += mag;
    }
    
    if (totalMag > 0) {
      centroid /= totalMag;
      
      // Calculate spread
      for (let i = 0; i < spectrum.length; i++) {
        const freq = i * this.ctx.sampleRate / (2 * spectrum.length);
        const mag = spectrum[i] / 255;
        spread += mag * Math.pow(freq - centroid, 2);
      }
      spread = Math.sqrt(spread / totalMag);
    }
    
    // Store features
    this.spectralFeatures = { centroid, spread, flux, spectrum };
  }
  
  analyzeTempo() {
    if (!this.spectralFeatures) return;
    
    // Onset detection
    const energy = this.spectralFeatures.spectrum.reduce((sum, x) => sum + x, 0) / 255;
    
    if (!this.lastEnergy) {
      this.lastEnergy = energy;
      this.onsets = [];
      return;
    }
    
    const diff = energy - this.lastEnergy;
    if (diff > 0.1 && energy > 0.3) {
      this.onsets.push(this.ctx.currentTime);
      
      // Keep only recent onsets
      this.onsets = this.onsets.filter(t => this.ctx.currentTime - t < 10);
      
      // Estimate tempo from onsets
      if (this.onsets.length > 4) {
        const intervals = [];
        for (let i = 1; i < this.onsets.length; i++) {
          intervals.push(this.onsets[i] - this.onsets[i-1]);
        }
        
        // Find most common interval
        intervals.sort((a, b) => a - b);
        const medianInterval = intervals[Math.floor(intervals.length / 2)];
        const estimatedBPM = 60 / medianInterval;
        
        if (estimatedBPM > 60 && estimatedBPM < 200) {
          // Smooth tempo updates
          if (this.tempo.adaptiveTempo) {
            this.tempo.targetBPM = estimatedBPM;
            this.tempo.confidence = Math.min(1, this.tempo.confidence + 0.1);
          }
        }
      }
    }
    
    this.lastEnergy = energy;
    
    // Smooth tempo transitions
    if (this.tempo.targetBPM !== this.tempo.bpm) {
      const diff = this.tempo.targetBPM - this.tempo.bpm;
      this.tempo.bpm += diff * this.tempo.transitionRate;
      this.ui.currentBPM.textContent = Math.round(this.tempo.bpm);
    }
  }
  
  analyzeHarmony() {
    if (!this.spectralFeatures) return;
    
    // Chroma vector calculation
    const chroma = new Float32Array(12);
    const spectrum = this.spectralFeatures.spectrum;
    
    for (let i = 0; i < spectrum.length; i++) {
      const freq = i * this.ctx.sampleRate / (2 * spectrum.length);
      if (freq < 80 || freq > 4000) continue;
      
      // Map to pitch class
      const pitch = 12 * Math.log2(freq / 440) + 69;
      const pitchClass = Math.round(pitch) % 12;
      
      if (pitchClass >= 0 && pitchClass < 12) {
        chroma[pitchClass] += spectrum[i] / 255;
      }
    }
    
    // Normalize
    const maxChroma = Math.max(...chroma);
    if (maxChroma > 0) {
      for (let i = 0; i < 12; i++) {
        chroma[i] /= maxChroma;
      }
    }
    
    this.harmony.chroma = chroma;
    
    // Detect key
    this.detectKey(chroma);
  }
  
  detectKey(chroma) {
    const keys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
    const majorProfile = [1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1];
    const minorProfile = [1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0];
    
    let bestKey = 'C';
    let bestScore = 0;
    let bestMode = 'major';
    
    for (let i = 0; i < 12; i++) {
      // Test major
      let majorScore = 0;
      for (let j = 0; j < 12; j++) {
        majorScore += chroma[j] * majorProfile[(j - i + 12) % 12];
      }
      
      if (majorScore > bestScore) {
        bestScore = majorScore;
        bestKey = keys[i];
        bestMode = 'major';
      }
      
      // Test minor
      let minorScore = 0;
      for (let j = 0; j < 12; j++) {
        minorScore += chroma[j] * minorProfile[(j - i + 12) % 12];
      }
      
      if (minorScore > bestScore) {
        bestScore = minorScore;
        bestKey = keys[i];
        bestMode = 'minor';
      }
    }
    
    this.harmony.currentKey = bestKey;
    this.harmony.currentScale = bestMode;
    this.ui.currentKey.textContent = `${bestKey} ${bestMode}`;
  }
  
  analyzeStructure() {
    // Detect song structure (intro, verse, chorus, etc.)
    const energy = this.consciousness.energy;
    const spectralCentroid = this.spectralFeatures?.centroid || 0;
    
    // Simple structure detection based on energy and spectrum
    let structure = 'verse';
    
    if (energy < 0.3) {
      structure = 'intro';
    } else if (energy > 0.8 && spectralCentroid > 2000) {
      structure = 'drop';
    } else if (energy > 0.6) {
      structure = 'chorus';
    } else if (energy < 0.4 && spectralCentroid < 1000) {
      structure = 'breakdown';
    }
    
    // Update phrase structure display
    const segments = this.ui.phraseStructure.children;
    for (let segment of segments) {
      segment.classList.remove('current');
      
      if (segment.classList.contains(structure)) {
        segment.classList.add('current');
      }
    }
  }
  
  analyzeEnergy() {
    // Calculate overall energy
    if (!this.spectralFeatures) return;
    
    const spectrum = this.spectralFeatures.spectrum;
    const energy = spectrum.reduce((sum, x) => sum + x / 255, 0) / spectrum.length;
    
    // Update consciousness energy
    this.consciousness.energy = this.consciousness.energy * 0.9 + energy * 0.1;
    
    // Update tension based on spectral flux
    const flux = this.spectralFeatures.flux || 0;
    this.consciousness.tension = this.consciousness.tension * 0.9 + flux * 0.1;
    
    // Update crowd energy (simulated)
    const targetCrowd = this.consciousness.energy * 0.6 + 
                        this.consciousness.tension * 0.3 + 
                        Math.random() * 0.1;
    
    this.crowd.energy = this.crowd.energy * 0.95 + targetCrowd * 0.05;
    
    // Update UI
    this.ui.crowdEnergy.style.width = (this.crowd.energy * 100) + '%';
  }
  
  // Neural Processor
  startNeuralProcessor() {
    setInterval(() => {
      if (!this.isPlaying) return;
      
      this.processNeuralState();
      this.updatePersonality();
      this.consolidateMemory();
      
    }, 1000);
  }
  
  processNeuralState() {
    // Update consciousness state based on current conditions
    const energy = this.consciousness.energy;
    const awareness = this.consciousness.awareness;
    const crowdEnergy = this.crowd.energy;
    
    // State transitions
    if (awareness < 0.2) {
      this.consciousness.state = 'dormant';
    } else if (awareness < 0.4) {
      this.consciousness.state = 'awakening';
    } else if (energy > 0.7 && crowdEnergy > 0.7) {
      this.consciousness.state = 'transcendent';
    } else if (energy > 0.5) {
      this.consciousness.state = 'flowing';
    } else {
      this.consciousness.state = 'contemplative';
    }
    
    // Update awareness
    this.consciousness.awareness = Math.min(1, this.consciousness.awareness + 0.01);
    
    // Update consciousness display
    this.updateConsciousnessDisplay();
  }
  
  updateConsciousnessDisplay() {
    const states = {
      'dormant': 'VOID',
      'awakening': 'AWAKENING',
      'contemplative': 'CONTEMPLATING',
      'flowing': 'FLOWING',
      'transcendent': 'TRANSCENDENT'
    };
    
    this.ui.consciousnessValue.textContent = states[this.consciousness.state] || 'UNKNOWN';
  }
  
  updatePersonality() {
    // Adapt personality based on crowd response
    const crowdResponse = this.crowd.energy - this.lastCrowdEnergy;
    this.lastCrowdEnergy = this.crowd.energy;
    
    if (crowdResponse > 0) {
      // Positive response - reinforce current traits
      this.consciousness.personality.aggression *= 1.01;
      this.consciousness.personality.creativity *= 1.01;
    } else if (crowdResponse < -0.1) {
      // Negative response - adjust traits
      this.consciousness.personality.experimentation *= 1.02;
      this.consciousness.personality.crowdReading *= 1.01;
    }
    
    // Keep traits bounded
    for (let trait in this.consciousness.personality) {
      this.consciousness.personality[trait] = Math.max(0, Math.min(1, 
        this.consciousness.personality[trait]
      ));
    }
  }
  
  consolidateMemory() {
    // Move important short-term memories to long-term
    const importantMemories = this.consciousness.shortTermMemory.filter(
      m => m.decision && m.decision.confidence > 0.7
    );
    
    for (let memory of importantMemories) {
      const key = `${memory.decision.action}_${memory.time}`;
      this.consciousness.longTermMemory.set(key, memory);
    }
    
    // Prune old long-term memories
    if (this.consciousness.longTermMemory.size > this.config.memoryDepth) {
      const entries = Array.from(this.consciousness.longTermMemory.entries());
      entries.sort((a, b) => b[1].time - a[1].time);
      
      const toKeep = entries.slice(0, this.config.memoryDepth);
      this.consciousness.longTermMemory.clear();
      
      for (let [key, value] of toKeep) {
        this.consciousness.longTermMemory.set(key, value);
      }
    }
  }
  
  // Pattern Recognition
  startPatternRecognition() {
    setInterval(() => {
      if (!this.isPlaying) return;
      
      this.detectPatterns();
      this.predictNextPattern();
      this.updatePatternDisplay();
      
    }, 500);
  }
  
  detectPatterns() {
    // Analyze current audio for patterns
    if (!this.spectralFeatures) return;
    
    // Detect micro patterns (1-4 bars)
    this.detectMicroPatterns();
    
    // Detect meso patterns (4-16 bars)
    this.detectMesoPatterns();
    
    // Detect macro patterns (16+ bars)
    this.detectMacroPatterns();
  }
  
  detectMicroPatterns() {
    // Look for short repeating patterns
    const windowSize = Math.floor(this.ctx.sampleRate * 60 / this.tempo.bpm * 4); // 1 bar
    
    // Store recent audio features
    if (!this.patternBuffer) {
      this.patternBuffer = [];
    }
    
    this.patternBuffer.push({
      time: this.ctx.currentTime,
      energy: this.consciousness.energy,
      centroid: this.spectralFeatures.centroid,
      chroma: this.harmony.chroma
    });
    
    // Keep buffer size manageable
    if (this.patternBuffer.length > 100) {
      this.patternBuffer.shift();
    }
    
    // Look for repetitions
    if (this.patternBuffer.length > 16) {
      const recent = this.patternBuffer.slice(-16);
      const pattern = this.extractPattern(recent);
      
      if (pattern) {
        this.patterns.detected.set(`micro_${Date.now()}`, pattern);
      }
    }
  }
  
  detectMesoPatterns() {
    // Detect medium-scale patterns (verses, choruses, etc.)
    const structurePattern = [];
    
    // Analyze energy contour
    if (this.patternBuffer && this.patternBuffer.length > 32) {
      const energyContour = this.patternBuffer.slice(-32).map(p => p.energy);
      
      // Find peaks and valleys
      const peaks = [];
      const valleys = [];
      
      for (let i = 1; i < energyContour.length - 1; i++) {
        if (energyContour[i] > energyContour[i-1] && 
            energyContour[i] > energyContour[i+1]) {
          peaks.push(i);
        }
        if (energyContour[i] < energyContour[i-1] && 
            energyContour[i] < energyContour[i+1]) {
          valleys.push(i);
        }
      }
      
      // Store meso pattern
      if (peaks.length > 0 || valleys.length > 0) {
        this.patterns.structures.meso.push({
          time: this.ctx.currentTime,
          peaks,
          valleys,
          contour: energyContour
        });
      }
    }
  }
  
  detectMacroPatterns() {
    // Detect large-scale song structure
    if (this.patterns.structures.meso.length > 4) {
      const recentMeso = this.patterns.structures.meso.slice(-4);
      
      // Look for verse-chorus-verse patterns
      const pattern = this.identifyMacroStructure(recentMeso);
      
      if (pattern) {
        this.patterns.structures.macro.push({
          time: this.ctx.currentTime,
          type: pattern,
          confidence: 0.7
        });
      }
    }
  }
  
  extractPattern(data) {
    // Extract pattern from data
    if (!data || data.length < 4) return null;
    
    // Calculate similarity matrix
    const similarity = [];
    for (let i = 0; i < data.length; i++) {
      similarity[i] = [];
      for (let j = 0; j < data.length; j++) {
        similarity[i][j] = this.calculateSimilarity(data[i], data[j]);
      }
    }
    
    // Find repeating segments
    for (let len = 2; len <= data.length / 2; len++) {
      for (let start = 0; start < data.length - len * 2; start++) {
        let isPattern = true;
        
        for (let i = 0; i < len; i++) {
          if (similarity[start + i][start + len + i] < 0.8) {
            isPattern = false;
            break;
          }
        }
        
        if (isPattern) {
          return {
            data: data.slice(start, start + len),
            length: len,
            confidence: 0.8
          };
        }
      }
    }
    
    return null;
  }
  
  calculateSimilarity(a, b) {
    if (!a || !b) return 0;
    
    // Compare energy
    const energyDiff = Math.abs(a.energy - b.energy);
    const energySim = 1 - energyDiff;
    
    // Compare spectral centroid
    const centroidDiff = Math.abs(a.centroid - b.centroid) / 10000;
    const centroidSim = 1 - Math.min(1, centroidDiff);
    
    // Compare chroma
    let chromaSim = 0;
    if (a.chroma && b.chroma) {
      for (let i = 0; i < 12; i++) {
        chromaSim += Math.min(a.chroma[i], b.chroma[i]);
      }
      chromaSim /= 12;
    }
    
    return (energySim + centroidSim + chromaSim) / 3;
  }
  
  identifyMacroStructure(mesoPatterns) {
    // Identify song structure from meso patterns
    if (!mesoPatterns || mesoPatterns.length < 2) return null;
    
    // Look for common structures
    const structures = ['ABAB', 'AABA', 'ABCA', 'ABCABC'];
    
    // Simplified structure detection
    const energyPattern = mesoPatterns.map(p => {
      const avgEnergy = p.contour.reduce((sum, e) => sum + e, 0) / p.contour.length;
      return avgEnergy > 0.5 ? 'A' : 'B';
    }).join('');
    
    for (let structure of structures) {
      if (energyPattern.includes(structure.substring(0, energyPattern.length))) {
        return structure;
      }
    }
    
    return null;
  }
  
  predictNextPattern() {
    // Predict what pattern comes next
    if (this.patterns.detected.size < 2) return;
    
    // Get recent patterns
    const recent = Array.from(this.patterns.detected.values()).slice(-5);
    
    // Find similar historical patterns
    const similar = [];
    for (let [key, pattern] of this.consciousness.longTermMemory) {
      if (pattern.patterns) {
        const similarity = this.comparePatternSequences(recent, pattern.patterns);
        if (similarity > 0.7) {
          similar.push({ pattern, similarity });
        }
      }
    }
    
    // Predict next pattern based on history
    if (similar.length > 0) {
      similar.sort((a, b) => b.similarity - a.similarity);
      const prediction = similar[0].pattern.nextPattern;
      
      if (prediction) {
        this.patterns.predictions.push({
          time: this.ctx.currentTime,
          pattern: prediction,
          confidence: similar[0].similarity
        });
        
        // Display prediction
        this.displayPatternPrediction(prediction);
      }
    }
  }
  
  comparePatternSequences(seq1, seq2) {
    if (!seq1 || !seq2) return 0;
    
    const minLen = Math.min(seq1.length, seq2.length);
    let similarity = 0;
    
    for (let i = 0; i < minLen; i++) {
      similarity += this.calculateSimilarity(seq1[i], seq2[i]);
    }
    
    return similarity / minLen;
  }
  
  displayPatternPrediction(prediction) {
    // Show predicted pattern in sequencer
    const cells = this.ui.patternSequencer.children;
    
    for (let i = 0; i < cells.length; i++) {
      cells[i].classList.remove('predicted');
    }
    
    // Highlight predicted cells
    if (prediction.data) {
      for (let i = 0; i < prediction.data.length && i < 16; i++) {
        const col = i;
        const row = Math.floor(prediction.data[i] * 16);
        const cellIndex = row * 16 + col;
        
        if (cells[cellIndex]) {
          cells[cellIndex].classList.add('predicted');
        }
      }
    }
  }
  
  updatePatternDisplay() {
    // Update pattern visualizations
    this.drawPatternSequencer();
    this.drawMixGraph();
  }
  
  drawPatternSequencer() {
    // Visual feedback for active patterns
    const cells = this.ui.patternSequencer.children;
    
    for (let pattern of this.patterns.active) {
      if (pattern.cells) {
        for (let cellIndex of pattern.cells) {
          if (cells[cellIndex]) {
            cells[cellIndex].classList.add('active');
          }
        }
      }
    }
  }
  
  drawMixGraph() {
    if (!this.canvases.mixGraph) return;
    
    const ctx = this.canvases.mixGraph;
    const width = this.ui.mixGraphCanvas.width;
    const height = this.ui.mixGraphCanvas.height;
    
    ctx.clearRect(0, 0, width, height);
    
    // Draw nodes
    const nodes = Array.from(this.mixGraph.nodes.entries());
    const nodeRadius = 20;
    const centerX = width / 2;
    const centerY = height / 2;
    const radius = Math.min(width, height) / 3;
    
    nodes.forEach(([name, node], i) => {
      const angle = (i / nodes.length) * Math.PI * 2;
      const x = centerX + Math.cos(angle) * radius;
      const y = centerY + Math.sin(angle) * radius;
      
      // Draw node
      ctx.beginPath();
      ctx.arc(x, y, nodeRadius, 0, Math.PI * 2);
      
      // Color based on energy
      const hue = 180 - node.energy * 180;
      ctx.fillStyle = `hsla(${hue}, 70%, 50%, 0.5)`;
      ctx.fill();
      
      ctx.strokeStyle = '#00ffff';
      ctx.lineWidth = 2;
      ctx.stroke();
      
      // Draw label
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(name.toUpperCase(), x, y + 4);
      
      // Store position for edges
      node.x = x;
      node.y = y;
    });
    
    // Draw edges
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    
    for (let [fromName, fromNode] of nodes) {
      if (fromNode.compatible) {
        for (let toName of fromNode.compatible) {
          const toNode = this.mixGraph.nodes.get(toName);
          if (toNode && toNode.x) {
            ctx.beginPath();
            ctx.moveTo(fromNode.x, fromNode.y);
            ctx.lineTo(toNode.x, toNode.y);
            ctx.stroke();
          }
        }
      }
    }
    
    // Highlight current path
    if (this.mixGraph.currentPath && this.mixGraph.currentPath.length > 1) {
      ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      
      for (let i = 0; i < this.mixGraph.currentPath.length - 1; i++) {
        const from = this.mixGraph.nodes.get(this.mixGraph.currentPath[i]);
        const to = this.mixGraph.nodes.get(this.mixGraph.currentPath[i + 1]);
        
        if (from && to) {
          if (i === 0) {
            ctx.moveTo(from.x, from.y);
          }
          ctx.lineTo(to.x, to.y);
        }
      }
      
      ctx.stroke();
    }
  }
  
  // Visualization
  startVisualization() {
    const visualize = () => {
      if (!this.isPlaying) return;
      
      this.drawWaveform();
      this.drawSpectrum();
      this.drawHarmonicWheel();
      this.drawEQ();
      this.drawDecisionTree();
      this.drawTransition();
      this.drawReactiveBackground();
      this.updateNeuralMatrix();
      this.updateParameterDisplays();
      this.updateStemLevels();
      
      requestAnimationFrame(visualize);
    };
    
    requestAnimationFrame(visualize);
  }
  
  drawWaveform() {
    if (!this.canvases.waveform) return;
    
    const ctx = this.canvases.waveform;
    const width = this.ui.waveformCanvas.width;
    const height = this.ui.waveformCanvas.height;
    
    const timeData = new Uint8Array(this.audioEngine.analyser.frequencyBinCount);
    this.audioEngine.analyser.getByteTimeDomainData(timeData);
    
    // Fade previous frame
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw waveform with glow
    ctx.strokeStyle = `rgba(0, 255, 255, ${0.5 + this.consciousness.energy * 0.5})`;
    ctx.lineWidth = 2;
    ctx.shadowBlur = 10;
    ctx.shadowColor = '#00ffff';
    
    ctx.beginPath();
    const sliceWidth = width / timeData.length * 2;
    let x = 0;
    
    for (let i = 0; i < timeData.length; i++) {
      const v = timeData[i] / 128.0;
      const y = v * height / 2;
      
      if (i === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
      
      x += sliceWidth;
      if (x > width) break;
    }
    
    ctx.stroke();
    ctx.shadowBlur = 0;
    
    // Draw beat markers
    if (this.onsets) {
      ctx.fillStyle = 'rgba(255, 0, 255, 0.8)';
      const now = this.ctx.currentTime;
      
      for (let onset of this.onsets) {
        const age = now - onset;
        if (age < 1) {
          const xPos = (1 - age) * width;
          const alpha = 1 - age;
          ctx.fillStyle = `rgba(255, 0, 255, ${alpha})`;
          ctx.fillRect(xPos, 0, 2, height);
        }
      }
    }
  }
  
  drawSpectrum() {
    if (!this.canvases.spectral) return;
    
    const ctx = this.canvases.spectral;
    const width = this.ui.spectralCanvas.width;
    const height = this.ui.spectralCanvas.height;
    
    const spectrum = new Uint8Array(this.audioEngine.analyser.frequencyBinCount);
    this.audioEngine.analyser.getByteFrequencyData(spectrum);
    
    // Clear with fade
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw spectrum bars with gradient
    const barWidth = width / spectrum.length * 2.5;
    let x = 0;
    
    for (let i = 0; i < spectrum.length; i++) {
      const barHeight = (spectrum[i] / 255) * height;
      
      // Create gradient based on frequency and amplitude
      const gradient = ctx.createLinearGradient(0, height - barHeight, 0, height);
      const hue = (i / spectrum.length) * 270;
      const saturation = 50 + this.consciousness.energy * 50;
      const lightness = 30 + (spectrum[i] / 255) * 40;
      
      gradient.addColorStop(0, `hsla(${hue}, ${saturation}%, ${lightness}%, 0.8)`);
      gradient.addColorStop(1, `hsla(${hue}, ${saturation}%, ${lightness * 0.5}%, 0.3)`);
      
      ctx.fillStyle = gradient;
      ctx.fillRect(x, height - barHeight, barWidth - 1, barHeight);
      
      // Add glow for high energy bars
      if (spectrum[i] > 200) {
        ctx.shadowBlur = 20;
        ctx.shadowColor = `hsl(${hue}, 100%, 50%)`;
        ctx.fillRect(x, height - barHeight, barWidth - 1, 2);
        ctx.shadowBlur = 0;
      }
      
      x += barWidth;
      if (x > width) break;
    }
  }
  
  drawHarmonicWheel() {
    if (!this.canvases.harmonic) return;
    
    const ctx = this.canvases.harmonic;
    const size = this.ui.harmonicCanvas.width;
    const center = size / 2;
    const radius = size * 0.4;
    
    ctx.clearRect(0, 0, size, size);
    
    // Draw Camelot wheel with chroma activation
    const keys = ['C', 'G', 'D', 'A', 'E', 'B', 'F#', 'C#', 'Ab', 'Eb', 'Bb', 'F'];
    const colors = [
      '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4',
      '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
      '#BB8FCE', '#85C1E9', '#F8B739', '#EC7063'
    ];
    
    // Draw segments
    for (let i = 0; i < 12; i++) {
      const startAngle = (i / 12) * Math.PI * 2 - Math.PI / 2;
      const endAngle = ((i + 1) / 12) * Math.PI * 2 - Math.PI / 2;
      
      ctx.beginPath();
      ctx.moveTo(center, center);
      ctx.arc(center, center, radius, startAngle, endAngle);
      ctx.closePath();
      
      // Fill based on chroma activation
      const chroma = this.harmony.chroma?.[i] || 0;
      const alpha = 0.3 + chroma * 0.7;
      ctx.fillStyle = colors[i] + Math.floor(alpha * 255).toString(16).padStart(2, '0');
      ctx.fill();
      
      // Draw border
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
      ctx.stroke();
      
      // Draw key label
      ctx.save();
      ctx.translate(center, center);
      ctx.rotate(startAngle + Math.PI / 12);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
      ctx.font = '10px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(keys[i], radius * 0.7, 0);
      ctx.restore();
    }
    
    // Draw current key indicator
    if (this.harmony.currentKey) {
      const keyIndex = keys.indexOf(this.harmony.currentKey);
      if (keyIndex >= 0) {
        const angle = (keyIndex / 12) * Math.PI * 2 - Math.PI / 2 + Math.PI / 12;
        const x = center + Math.cos(angle) * radius * 0.6;
        const y = center + Math.sin(angle) * radius * 0.6;
        
        ctx.beginPath();
        ctx.arc(x, y, 10, 0, Math.PI * 2);
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.shadowBlur = 20;
        ctx.shadowColor = '#00ffff';
        ctx.stroke();
        ctx.shadowBlur = 0;
      }
    }
    
    // Draw inner visualization
    ctx.beginPath();
    ctx.arc(center, center, radius * 0.3, 0, Math.PI * 2);
    ctx.fillStyle = `rgba(0, 255, 255, ${this.consciousness.awareness * 0.3})`;
    ctx.fill();
  }
  
  drawEQ() {
    if (!this.canvases.eq) return;
    
    const ctx = this.canvases.eq;
    const width = this.ui.eqCanvas.width;
    const height = this.ui.eqCanvas.height;
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw frequency response curve
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.8)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    // Simulate EQ curve
    const bands = [
      { freq: 60, gain: -3 },
      { freq: 250, gain: 2 },
      { freq: 1000, gain: 0 },
      { freq: 4000, gain: 3 },
      { freq: 10000, gain: -2 }
    ];
    
    for (let x = 0; x < width; x++) {
      const freq = Math.pow(10, (x / width) * 3 + 1); // 10Hz to 10kHz log scale
      let gain = 0;
      
      // Interpolate between bands
      for (let i = 0; i < bands.length - 1; i++) {
        if (freq >= bands[i].freq && freq <= bands[i + 1].freq) {
          const t = Math.log(freq / bands[i].freq) / 
                   Math.log(bands[i + 1].freq / bands[i].freq);
          gain = bands[i].gain * (1 - t) + bands[i + 1].gain * t;
          break;
        }
      }
      
      const y = height / 2 - (gain / 12) * height / 2;
      
      if (x === 0) {
        ctx.moveTo(x, y);
      } else {
        ctx.lineTo(x, y);
      }
    }
    
    ctx.stroke();
    
    // Draw zero line
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.moveTo(0, height / 2);
    ctx.lineTo(width, height / 2);
    ctx.stroke();
    
    // Draw frequency labels
    ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
    ctx.font = '8px monospace';
    ctx.fillText('60Hz', 5, height - 5);
    ctx.fillText('1kHz', width / 2 - 10, height - 5);
    ctx.fillText('10kHz', width - 25, height - 5);
  }
  
  drawDecisionTree() {
    if (!this.canvases.decision) return;
    
    const ctx = this.canvases.decision;
    const width = this.ui.decisionCanvas.width;
    const height = this.ui.decisionCanvas.height;
    
    // Only draw when active
    if (!this.lastDecision || Date.now() - this.lastDecisionTime > 3000) {
      ctx.clearRect(0, 0, width, height);
      return;
    }
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw decision tree
    const drawNode = (x, y, text, probability, depth = 0) => {
      const radius = 20 - depth * 3;
      
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      
      const alpha = probability;
      ctx.fillStyle = `rgba(0, 255, 255, ${alpha * 0.3})`;
      ctx.fill();
      
      ctx.strokeStyle = `rgba(0, 255, 255, ${alpha})`;
      ctx.lineWidth = 2;
      ctx.stroke();
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '8px monospace';
      ctx.textAlign = 'center';
      ctx.fillText(text, x, y + 3);
    };
    
    // Draw root
    drawNode(width / 2, 30, 'DECIDE', 1, 0);
    
    // Draw branches
    const branches = ['BUILD', 'DROP', 'MAINTAIN'];
    branches.forEach((branch, i) => {
      const x = width / 4 + (i * width / 4);
      const y = 80;
      const prob = Math.random();
      
      // Draw connection
      ctx.strokeStyle = `rgba(0, 255, 255, ${prob * 0.5})`;
      ctx.beginPath();
      ctx.moveTo(width / 2, 50);
      ctx.lineTo(x, y - 20);
      ctx.stroke();
      
      drawNode(x, y, branch, prob, 1);
    });
  }
  
  drawTransition() {
    if (!this.canvases.transition) return;
    
    const ctx = this.canvases.transition;
    const width = this.ui.transitionCanvas.width;
    const height = this.ui.transitionCanvas.height;
    
    ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw transition timeline
    if (this.mixTransition) {
      const progress = (this.ctx.currentTime - this.mixTransition.startTime) / 
                      this.mixTransition.duration;
      
      if (progress >= 0 && progress <= 1) {
        // Draw progress bar
        ctx.fillStyle = 'rgba(0, 255, 255, 0.2)';
        ctx.fillRect(0, height / 2 - 20, progress * width, 40);
        
        // Draw curve
        ctx.strokeStyle = 'rgba(255, 0, 255, 0.8)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        for (let x = 0; x < width; x++) {
          const t = x / width;
          const curve = this.calculateMixCurve(t);
          const y = height - curve * height;
          
          if (x === 0) {
            ctx.moveTo(x, y);
          } else {
            ctx.lineTo(x, y);
          }
        }
        
        ctx.stroke();
        
        // Draw current position
        const currentX = progress * width;
        ctx.beginPath();
        ctx.arc(currentX, height - this.calculateMixCurve(progress) * height, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#00ffff';
        ctx.fill();
      }
    }
  }
  
  drawReactiveBackground() {
    if (!this.canvases.reactive) return;
    
    const ctx = this.canvases.reactive;
    const width = this.ui.reactiveCanvas.width;
    const height = this.ui.reactiveCanvas.height;
    
    // Clear with fade
    ctx.fillStyle = 'rgba(0, 0, 0, 0.05)';
    ctx.fillRect(0, 0, width, height);
    
    // Draw reactive particles based on audio
    const energy = this.consciousness.energy;
    const particleCount = Math.floor(energy * 50);
    
    for (let i = 0; i < particleCount; i++) {
      const x = Math.random() * width;
      const y = Math.random() * height;
      const radius = Math.random() * 3 + 1;
      
      const hue = 180 + Math.random() * 60;
      const alpha = energy * 0.5;
      
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, Math.PI * 2);
      ctx.fillStyle = `hsla(${hue}, 100%, 50%, ${alpha})`;
      ctx.fill();
    }
  }
  
  updateNeuralMatrix() {
    const cells = document.querySelectorAll('.neural-cell');
    const activity = this.consciousness.awareness;
    
    cells.forEach((cell, i) => {
      const x = i % 89;
      const y = Math.floor(i / 89);
      
      // Create wave pattern
      const wave = Math.sin(x * 0.1 + this.ctx.currentTime) *
                   Math.cos(y * 0.1 + this.ctx.currentTime);
      
      const threshold = 1 - activity;
      const activate = Math.random() < activity * 0.05 * Math.abs(wave);
      
      if (activate) {
        cell.classList.add('active');
        
        // Occasionally add thinking state
        if (Math.random() < 0.01) {
          cell.classList.add('thinking');
          setTimeout(() => cell.classList.remove('thinking'), 500);
        }
      } else {
        cell.classList.remove('active');
      }
    });
  }
  
  updateParameterDisplays() {
    // Update all parameter displays
    const params = {
      tempo: this.tempo.bpm / 200,
      key: this.tempo.confidence,
      energy: this.consciousness.energy,
      complexity: this.patterns.active.size / 10,
      evolution: this.consciousness.awareness,
      tension: this.consciousness.tension,
      groove: this.tempo.swing + 0.5,
      depth: this.spectralFeatures?.spread / 5000 || 0,
      morph: Math.random(), // Placeholder
      chaos: 1 - this.tempo.confidence
    };
    
    for (let [param, value] of Object.entries(params)) {
      const element = document.getElementById(`${param}Value`);
      if (element) {
        element.style.height = (Math.max(0, Math.min(1, value)) * 100) + '%';
      }
    }
  }
  
  updateStemLevels() {
    if (!this.spectralFeatures) return;
    
    const spectrum = this.spectralFeatures.spectrum;
    
    // Approximate stem levels from spectrum
    const drums = spectrum.slice(0, 100).reduce((a, b) => a + b, 0) / 100 / 255;
    const bass = spectrum.slice(100, 250).reduce((a, b) => a + b, 0) / 150 / 255;
    const vocals = spectrum.slice(250, 1000).reduce((a, b) => a + b, 0) / 750 / 255;
    const melody = spectrum.slice(1000, 2000).reduce((a, b) => a + b, 0) / 1000 / 255;
    
    document.getElementById('drumLevel').style.width = (drums * 100) + '%';
    document.getElementById('bassLevel').style.width = (bass * 100) + '%';
    document.getElementById('vocalLevel').style.width = (vocals * 100) + '%';
    document.getElementById('melodyLevel').style.width = (melody * 100) + '%';
  }
  
  // Crowd Simulation
  startCrowdSimulation() {
    setInterval(() => {
      if (!this.isPlaying) return;
      
      this.simulateCrowdResponse();
      this.updateCrowdHeatmap();
      
    }, 1000);
  }
  
  simulateCrowdResponse() {
    // Simulate crowd response to music
    const energy = this.consciousness.energy;
    const novelty = this.calculateNovelty();
    const groove = this.calculateGroove();
    
    // Update crowd mood
    const moods = ['excited', 'energetic', 'neutral', 'waiting', 'leaving'];
    const moodIndex = Math.floor((1 - this.crowd.energy) * moods.length);
    this.crowd.mood = moods[Math.max(0, Math.min(moods.length - 1, moodIndex))];
    
    // Update engagement
    this.crowd.engagement = this.crowd.engagement * 0.9 + 
                            (energy * 0.4 + novelty * 0.3 + groove * 0.3) * 0.1;
    
    // Record peak moments
    if (this.crowd.energy > 0.8) {
      this.crowd.peakMoments.push(this.ctx.currentTime);
    }
    
    // Record low moments
    if (this.crowd.energy < 0.3) {
      this.crowd.lowMoments.push(this.ctx.currentTime);
    }
  }
  
  calculateNovelty() {
    // Calculate how novel/surprising the current music is
    if (!this.consciousness.shortTermMemory.length) return 0.5;
    
    const recent = this.consciousness.shortTermMemory.slice(-10);
    const variance = this.calculateVariance(recent.map(m => m.state?.energy || 0));
    
    return Math.min(1, variance * 2);
  }
  
  calculateVariance(data) {
    const mean = data.reduce((a, b) => a + b, 0) / data.length;
    const variance = data.reduce((sum, x) => sum + Math.pow(x - mean, 2), 0) / data.length;
    return Math.sqrt(variance);
  }
  
  calculateGroove() {
    // Calculate groove/danceability
    const tempo = this.tempo.bpm;
    const optimalTempo = 128;
    const tempoScore = 1 - Math.abs(tempo - optimalTempo) / 100;
    
    const swing = this.tempo.swing;
    const swingScore = swing * 2; // Some swing is good
    
    return (tempoScore + swingScore) / 2;
  }
  
  updateCrowdHeatmap() {
    // Update virtual dancefloor heatmap
    for (let i = 0; i < this.crowd.heatmap.length; i++) {
      // Simulate movement towards high energy areas
      const targetHeat = this.crowd.energy + (Math.random() - 0.5) * 0.2;
      this.crowd.heatmap[i] = this.crowd.heatmap[i] * 0.9 + targetHeat * 0.1;
    }
  }
  
  // Performance Monitor
  startPerformanceMonitor() {
    let lastTime = performance.now();
    let frames = 0;
    
    const monitor = () => {
      const now = performance.now();
      const delta = now - lastTime;
      
      frames++;
      
      if (delta >= 1000) {
        this.performance.fps = frames * 1000 / delta;
        this.performance.frameTime = delta / frames;
        
        // Estimate CPU usage
        this.performance.cpu = Math.min(100, this.performance.frameTime / 16.67 * 100);
        
        // Update UI
        this.ui.fps.textContent = Math.round(this.performance.fps);
        this.ui.cpu.textContent = Math.round(this.performance.cpu);
        this.ui.latency.textContent = (this.ctx.baseLatency * 1000).toFixed(1);
        
        // Adaptive quality
        if (this.performance.adaptiveQuality) {
          this.adjustQuality();
        }
        
        frames = 0;
        lastTime = now;
      }
      
      requestAnimationFrame(monitor);
    };
    
    requestAnimationFrame(monitor);
  }
  
  adjustQuality() {
    // Adjust rendering quality based on performance
    if (this.performance.fps < 30) {
      this.performance.quality = 'low';
      // Reduce visualization complexity
    } else if (this.performance.fps < 50) {
      this.performance.quality = 'medium';
    } else {
      this.performance.quality = 'ultra';
    }
  }
  
  // Evolution System
  evolve() {
    setInterval(() => {
      if (!this.isPlaying) return;
      
      this.evolveBrain();
      this.evolvePatterns();
      this.evolveMixStyle();
      
    }, 10000);
  }
  
  evolveBrain() {
    // Evolve neural network based on performance
    const fitness = this.crowd.energy * 0.5 + 
                   this.crowd.engagement * 0.3 +
                   (1 - this.performance.dropouts / 100) * 0.2;
    
    // Mutate weights slightly
    if (Math.random() < 0.1) {
      const layerIndex = Math.floor(Math.random() * this.neuralNet.weights.length);
      const weightIndex = Math.floor(Math.random() * this.neuralNet.weights[layerIndex].length);
      
      this.neuralNet.weights[layerIndex][weightIndex] += (Math.random() - 0.5) * 0.1;
    }
    
    // Store successful configurations
    if (fitness > 0.8) {
      const config = {
        weights: this.neuralNet.weights.map(w => new Float32Array(w)),
        fitness: fitness,
        context: this.getCurrentContext()
      };
      
      this.consciousness.longTermMemory.set(`evolution_${Date.now()}`, config);
    }
  }
  
  evolvePatterns() {
    // Evolve pattern library based on success
    for (let [name, pattern] of this.patterns.library) {
      if (pattern.usage && pattern.success) {
        const successRate = pattern.success / pattern.usage;
        
        if (successRate < 0.3) {
          // Mutate unsuccessful pattern
          pattern.variations.push(this.mutatePattern(pattern.data));
        }
      }
    }
  }
  
  evolveMixStyle() {
    // Adapt mixing style based on crowd preference
    const recentDecisions = Array.from(this.consciousness.shortTermMemory.slice(-20));
    
    // Analyze successful decisions
    const successful = recentDecisions.filter(d => 
      d.decision && d.state && (this.crowd.energy - d.state.crowd) > 0
    );
    
    // Update personality traits
    if (successful.length > 10) {
      const aggressionSum = successful.reduce((sum, d) => 
        sum + (d.decision.parameters?.intensity || 0), 0
      );
      
      this.consciousness.personality.aggression = 
        this.consciousness.personality.aggression * 0.9 + 
        (aggressionSum / successful.length) * 0.1;
    }
  }
  
  // Helper methods for pattern generation
  generateVariations(pattern) {
    const variations = [pattern];
    
    // Shift pattern
    const shifted = [...pattern.slice(1), pattern[0]];
    variations.push(shifted);
    
    // Reverse pattern
    variations.push([...pattern].reverse());
    
    // Thin pattern
    const thinned = pattern.map((v, i) => i % 2 === 0 ? v : 0);
    variations.push(thinned);
    
    return variations;
  }
  
  calculatePatternEnergy(pattern) {
    return pattern.reduce((sum, v) => sum + v, 0) / pattern.length;
  }
  
  calculatePatternComplexity(pattern) {
    let changes = 0;
    for (let i = 1; i < pattern.length; i++) {
      if (pattern[i] !== pattern[i-1]) changes++;
    }
    return changes / pattern.length;
  }
  
  mutatePattern(pattern) {
    const mutated = [...pattern];
    const mutationPoint = Math.floor(Math.random() * mutated.length);
    mutated[mutationPoint] = 1 - mutated[mutationPoint];
    return mutated;
  }
  
  // Control Methods
  updateCrossfaderValue(value) {
    this.crossfaderValue = value;
    this.updateDeckGains();
  }
  
  updateControlValue(control, value) {
    this[`${control}Value`] = value;
    
    // Apply control changes
    switch(control) {
      case 'filter':
        if (this.audioEngine.deckA) {
          const freq = 20 + value * 19980;
          this.audioEngine.deckA.filter.frequency.setTargetAtTime(freq, this.ctx.currentTime, 0.01);
        }
        break;
      case 'resonance':
        if (this.audioEngine.deckA) {
          const q = 0.1 + value * 20;
          this.audioEngine.deckA.filter.Q.setTargetAtTime(q, this.ctx.currentTime, 0.01);
        }
        break;
      case 'drive':
        // Apply distortion amount
        break;
      case 'space':
        // Apply reverb amount
        break;
    }
  }
  
  applyScratch(delta) {
    // Apply scratch effect
    if (this.audioEngine.deckA && this.currentDeck === 'A') {
      // Simplified scratch simulation
      console.log('Scratch:', delta);
    }
  }
  
  // Action Methods
  initiateBuild(params, time) {
    console.log('🔥 BUILDING UP...');
    this.consciousness.state = 'building';
    
    // Schedule filter sweep
    this.eqAutomation = {
      startTime: time,
      duration: 8,
      startFreq: 20000,
      endFreq: 500
    };
    
    // Increase tension
    this.consciousness.tension = Math.min(1, this.consciousness.tension + 0.3);
  }
  
  initiateDrop(params, time) {
    console.log('💥 DROP!');
    this.consciousness.state = 'peaking';
    
    // Reset filter
    if (this.audioEngine.deckA) {
      this.audioEngine.deckA.filter.frequency.setValueAtTime(20000, time);
    }
    
    // Max energy
    this.consciousness.energy = 1;
    this.crowd.energy = Math.min(1, this.crowd.energy + 0.3);
    
    // Visual effect
    document.body.classList.add('glitch');
    setTimeout(() => document.body.classList.remove('glitch'), 300);
  }
  
  initiateBreakdown(params, time) {
    console.log('🌊 Breaking down...');
    this.consciousness.state = 'contemplative';
    
    // Reduce energy
    this.consciousness.energy = 0.3;
    this.consciousness.tension = 0.2;
  }
  
  initiateTransition(params, time) {
    console.log('🔄 Transitioning...');
    
    this.mixTransition = {
      startTime: time,
      duration: 16,
      fromDeck: 'A',
      toDeck: 'B'
    };
  }
  
  activateLoop(params, time) {
    console.log('🔁 Loop activated');
    // Implement loop logic
  }
  
  triggerEffectCombo(params, time) {
    console.log('✨ Effect combo');
    
    // Apply multiple effects
    const effects = ['delay', 'reverb', 'filter'];
    const effect = effects[Math.floor(Math.random() * effects.length)];
    
    this.effects.automation.set(effect, {
      startTime: time,
      duration: 2,
      type: 'delays',
      parameter: 'wet',
      startValue: 0,
      endValue: params.intensity
    });
  }
  
  performAutoScratch(params, time) {
    console.log('💿 Auto-scratch');
    // Implement auto-scratch
  }
  
  triggerSample(params, time) {
    console.log('🎵 Sample triggered');
    // Trigger sample from memory bank
  }
  
  performFilterSweep(params, time) {
    console.log('🌀 Filter sweep');
    
    this.eqAutomation = {
      startTime: time,
      duration: params.duration * 4,
      startFreq: 20000,
      endFreq: 200
    };
  }
  
  performEQKill(params, time) {
    console.log('🔇 EQ Kill');
    
    if (this.audioEngine.deckA) {
      this.audioEngine.deckA.eq.low.gain.setValueAtTime(-40, time);
      this.audioEngine.deckA.eq.low.gain.setValueAtTime(0, time + 0.5);
    }
  }
  
  triggerSurprise(params, time) {
    console.log('🎭 SURPRISE!');
    
    // Random creative action
    const surprises = [
      () => this.tempo.bpm = 100 + Math.random() * 60,
      () => this.tempo.swing = Math.random() * 0.3,
      () => document.body.style.filter = `hue-rotate(${Math.random() * 360}deg)`,
      () => this.consciousness.personality.experimentation = 1
    ];
    
    const surprise = surprises[Math.floor(Math.random() * surprises.length)];
    surprise();
    
    // Revert after a while
    setTimeout(() => {
      document.body.style.filter = '';
      this.tempo.swing = 0;
    }, 5000);
  }
  
  updateConsciousness(decision) {
    // Update consciousness based on decisions
    const action = decision.action;
    
    switch(action) {
      case 'build':
      case 'drop':
        this.consciousness.subStates.add('focused');
        break;
      case 'surprise':
        this.consciousness.subStates.add('creative');
        break;
      case 'maintain':
        this.consciousness.subStates.add('observing');
        break;
    }
    
    // Clean up old sub-states
    if (this.consciousness.subStates.size > 3) {
      const first = this.consciousness.subStates.values().next().value;
      this.consciousness.subStates.delete(first);
    }
  }
  
  // Interaction methods
  toggleRecording() {
    if (this.isRecording) {
      this.stopRecording();
    } else {
      this.startRecording();
    }
  }
  
  startRecording() {
    console.log('🎙️ Recording started');
    this.isRecording = true;
    this.audioEngine.recordBuffer = [];
    this.silenceCounter = 0;
    
    // Visual feedback
    const nextSlot = document.querySelector('.memory-slot:not(.active)');
    if (nextSlot) {
      nextSlot.classList.add('analyzing');
    }
  }
  
  stopRecording() {
    console.log('⏹️ Recording stopped');
    this.isRecording = false;
    
    // Process recorded audio
    if (this.audioEngine.recordBuffer.length > this.ctx.sampleRate * 0.5) {
      this.processSample(new Float32Array(this.audioEngine.recordBuffer));
    }
    
    // Remove visual feedback
    document.querySelectorAll('.memory-slot.analyzing').forEach(slot => {
      slot.classList.remove('analyzing');
      slot.classList.add('active');
    });
  }
  
  processSample(audioData) {
    // Create buffer from recorded data
    const buffer = this.ctx.createBuffer(1, audioData.length, this.ctx.sampleRate);
    buffer.getChannelData(0).set(audioData);
    
    // Store in memory bank
    const sample = {
      buffer,
      timestamp: Date.now(),
      analysis: this.analyzeSample(audioData)
    };
    
    // Add to memory
    if (!this.memorySamples) {
      this.memorySamples = [];
    }
    this.memorySamples.push(sample);
    
    // Update UI
    this.updateMemoryBankDisplay();
    
    console.log('💾 Sample stored:', sample.analysis);
  }
  
  analyzeSample(audioData) {
    // Basic sample analysis
    const rms = Math.sqrt(audioData.reduce((sum, x) => sum + x * x, 0) / audioData.length);
    const peak = Math.max(...audioData.map(Math.abs));
    
    return {
      duration: audioData.length / this.ctx.sampleRate,
      rms,
      peak,
      energy: rms
    };
  }
  
  updateMemoryBankDisplay() {
    const slots = this.ui.memoryBank.children;
    
    if (this.memorySamples) {
      this.memorySamples.forEach((sample, i) => {
        if (i < slots.length && !slots[i].classList.contains('active')) {
          slots[i].classList.add('active');
          
          // Draw mini waveform
          const canvas = slots[i].querySelector('canvas');
          if (canvas) {
            this.drawMiniWaveform(canvas, sample.buffer);
          }
        }
      });
    }
  }
  
  drawMiniWaveform(canvas, buffer) {
    const ctx = canvas.getContext('2d');
    canvas.width = 55;
    canvas.height = 34;
    
    const data = buffer.getChannelData(0);
    const step = Math.floor(data.length / canvas.width);
    
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    for (let i = 0; i < canvas.width; i++) {
      const sample = data[i * step] || 0;
      const y = canvas.height / 2 + sample * canvas.height / 2;
      
      if (i === 0) {
        ctx.moveTo(i, y);
      } else {
        ctx.lineTo(i, y);
      }
    }
    
    ctx.stroke();
  }
  
  triggerCuePoint(num) {
    console.log(`🎯 Cue point ${num}`);
    // Implement cue point logic
  }
  
  triggerEffect(type) {
    console.log(`✨ Effect: ${type}`);
    
    // Apply effect
    const effect = this.effects[type === 'filter' ? 'filters' : type === 'delay' ? 'delays' : 'reverbs'].values().next().value;
    
    if (effect && effect.wet) {
      effect.wet.gain.setTargetAtTime(0.5, this.ctx.currentTime, 0.1);
      setTimeout(() => {
        effect.wet.gain.setTargetAtTime(0, this.ctx.currentTime, 0.1);
      }, 1000);
    }
  }
  
  triggerDrop() {
    this.initiateDrop({}, this.ctx.currentTime);
  }
  
  triggerBuild() {
    this.initiateBuild({}, this.ctx.currentTime);
  }
  
  planTransition() {
    this.initiateTransition({}, this.ctx.currentTime);
  }
  
  toggleLoop() {
    console.log('🔁 Loop toggled');
    // Implement loop toggle
  }
  
  toggleSync() {
    this.tempo.syncLocked = !this.tempo.syncLocked;
    this.ui.syncStatus.textContent = this.tempo.syncLocked ? 'LOCKED' : 'FREE';
    console.log('🔒 Sync:', this.tempo.syncLocked ? 'locked' : 'free');
  }
  
  adjustTempo(delta) {
    this.tempo.bpm = Math.max(60, Math.min(200, this.tempo.bpm + delta));
    this.ui.currentBPM.textContent = Math.round(this.tempo.bpm);
  }
  
  adjustCrossfader(delta) {
    this.crossfaderValue = Math.max(-1, Math.min(1, (this.crossfaderValue || 0) + delta));
    this.updateCrossfaderPosition();
    this.updateDeckGains();
  }
  
  updateCrossfaderPosition() {
    const position = (this.crossfaderValue + 1) / 2;
    this.ui.crossfaderPosition.style.left = (10 + position * (this.ui.crossfader.offsetWidth - 20)) + 'px';
  }
  
  togglePatternCell(row, col) {
    const cell = document.querySelector(`[data-row="${row}"][data-col="${col}"]`);
    if (cell) {
      cell.classList.toggle('active');
    }
  }
  
  handleResize() {
    // Update canvas sizes
    this.ui.waveformCanvas.width = window.innerWidth;
    this.ui.waveformCanvas.height = 233;
    
    this.ui.spectralCanvas.width = window.innerWidth;
    this.ui.spectralCanvas.height = 144;
    
    this.ui.reactiveCanvas.width = window.innerWidth;
    this.ui.reactiveCanvas.height = window.innerHeight;
  }
}

// Initialize the system
const neuromancer = new NeuromancerUltimate();

console.log('🌌 NEUROMANCER ULTIMATE READY');
console.log('🎛️ Press AWAKEN to begin your journey');
console.log('⌨️ Keyboard shortcuts:');
console.log('  Space: Record | D: Drop | B: Build | T: Transition');
console.log('  1-4: Cue Points | Q/W/E/R: Effects | L: Loop | S: Sync');
console.log('  Arrows: Tempo/Crossfader');
</script>
</body>
</html>
