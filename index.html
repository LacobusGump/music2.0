<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GUMP - The Emergence</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #000;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            font-family: 'Georgia', serif;
        }
        #enter {
            position: fixed; inset: 0;
            display: flex; align-items: center; justify-content: center;
            flex-direction: column; gap: 30px;
            z-index: 100; cursor: pointer;
            background: #000;
        }
        #enter.off { display: none; }
        #enter h1 {
            font-size: 12px;
            font-weight: 300;
            letter-spacing: 8px;
            color: rgba(255,255,255,0.25);
        }
        #enter .circle {
            width: 80px; height: 80px;
            border-radius: 50%;
            border: 1px solid rgba(255,255,255,0.06);
            transition: all 0.8s;
        }
        #enter:hover .circle { border-color: rgba(255,255,255,0.15); }
        #world {
            position: fixed; inset: 0;
            display: none;
            background: #000;
        }
        #world.on { display: block; }
        canvas { position: fixed; inset: 0; }

        #evolution-bar {
            position: fixed;
            bottom: 0; left: 0; right: 0;
            height: 2px;
            background: rgba(255,255,255,0.03);
            z-index: 50;
        }
        #evolution-fill {
            height: 100%;
            width: 0%;
            background: rgba(255,255,255,0.15);
            transition: width 0.5s ease-out;
        }

        #era-name {
            position: fixed;
            bottom: 25px; left: 0; right: 0;
            text-align: center;
            font-size: 10px;
            letter-spacing: 8px;
            color: rgba(255,255,255,0.12);
            text-transform: uppercase;
            transition: all 2s;
            z-index: 50;
        }

        #phase-name {
            position: fixed;
            bottom: 50px; left: 0; right: 0;
            text-align: center;
            font-size: 9px;
            letter-spacing: 4px;
            color: rgba(255,255,255,0.08);
            font-style: italic;
            z-index: 50;
        }

        #status {
            position: fixed; top: 20px; left: 20px;
            font-size: 9px;
            color: rgba(255,255,255,0.1);
            letter-spacing: 1px;
            line-height: 2;
            font-family: monospace;
        }
    </style>
</head>
<body>

<div id="enter">
    <h1>THE EMERGENCE</h1>
    <div class="circle"></div>
</div>

<div id="world">
    <canvas id="c"></canvas>
    <div id="evolution-bar"><div id="evolution-fill"></div></div>
    <div id="phase-name"></div>
    <div id="era-name">void</div>
    <div id="status"></div>
</div>

<script>
// ═══════════════════════════════════════════════════════════════════════════
// GUMP - THE EMERGENCE
// ═══════════════════════════════════════════════════════════════════════════
//
// A journey through the birth and evolution of music.
// Each era contains multiple phases that unlock progressively.
// Movement fills the bar. When full, the next phase/era begins.
//
// ═══════════════════════════════════════════════════════════════════════════

const TAU = Math.PI * 2;

// ═══════════════════════════════════════════════════════════════════════════
// THE JOURNEY - Eras and their phases
// ═══════════════════════════════════════════════════════════════════════════

const JOURNEY = [
    // ═══════════════════════════════════════════════════════════════════════
    // ACT I: GENESIS - The divine emergence of sound
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'genesis',
        name: 'The Void',
        threshold: 0,
        description: 'Before all things',
        phase: 0
    },
    {
        era: 'genesis',
        name: 'First Vibration',
        threshold: 80,
        description: 'Something stirs in the darkness',
        phase: 1
    },
    {
        era: 'genesis',
        name: 'Let There Be Light',
        threshold: 200,
        description: 'The overtones bloom',
        phase: 2
    },
    {
        era: 'genesis',
        name: 'The Expansion',
        threshold: 400,
        description: 'Sound fills the void',
        phase: 3
    },
    {
        era: 'genesis',
        name: 'First Pulse',
        threshold: 650,
        description: 'A heartbeat forms',
        phase: 4
    },

    // ═══════════════════════════════════════════════════════════════════════
    // ACT II: TRIBAL - The discovery of rhythm
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'tribal',
        name: 'Footsteps',
        threshold: 950,
        description: 'The body discovers rhythm',
        phase: 0
    },
    {
        era: 'tribal',
        name: 'Hands',
        threshold: 1300,
        description: 'Claps and slaps',
        phase: 1
    },
    {
        era: 'tribal',
        name: 'Wood & Stone',
        threshold: 1700,
        description: 'The world becomes instrument',
        phase: 2
    },
    {
        era: 'tribal',
        name: 'The First Drums',
        threshold: 2200,
        description: 'Animal skin stretched tight',
        phase: 3
    },
    {
        era: 'tribal',
        name: 'Voice Awakens',
        threshold: 2800,
        description: 'The first song',
        phase: 4
    },

    // ═══════════════════════════════════════════════════════════════════════
    // ACT III: ANCIENT - Melody is born
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'ancient',
        name: 'The Chant',
        threshold: 3500,
        description: 'Voices in unison',
        phase: 0
    },
    {
        era: 'ancient',
        name: 'First Instruments',
        threshold: 4300,
        description: 'Bone flutes, lyres of gut',
        phase: 1
    },

    // ═══════════════════════════════════════════════════════════════════════
    // ACT IV: CLASSICAL - Harmony emerges
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'classical',
        name: 'Strings Alone',
        threshold: 5200,
        description: 'The violin sings',
        phase: 0
    },
    {
        era: 'classical',
        name: 'The Orchestra Swells',
        threshold: 6200,
        description: 'Brass and winds join',
        phase: 1
    },

    // ═══════════════════════════════════════════════════════════════════════
    // ACT V: SOUL - The American sound
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'blues',
        name: 'The Blues',
        threshold: 7300,
        description: 'Sorrow becomes beauty',
        phase: 0
    },
    {
        era: 'jazz',
        name: 'Jazz',
        threshold: 8500,
        description: 'Freedom in complexity',
        phase: 0
    },

    // ═══════════════════════════════════════════════════════════════════════
    // ACT VI: ELECTRIC - The revolution
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'rock',
        name: 'Rock',
        threshold: 9800,
        description: 'Raw power unleashed',
        phase: 0
    },

    // ═══════════════════════════════════════════════════════════════════════
    // ACT VII: NOW - Everything converges
    // ═══════════════════════════════════════════════════════════════════════
    {
        era: 'electronic',
        name: 'Electronic',
        threshold: 11200,
        description: 'The machine sings',
        phase: 0
    },
    {
        era: 'modern',
        name: 'The Convergence',
        threshold: 12800,
        description: 'All music is one',
        phase: 0
    }
];

// ═══════════════════════════════════════════════════════════════════════════
// GLOBAL STATE
// ═══════════════════════════════════════════════════════════════════════════

const world = {
    x: 0.5, y: 0.5,
    vx: 0, vy: 0,
    tilt: { x: 0, y: 0 },
    energy: 0,
    totalMovement: 0,
    breath: 0,
    heartbeat: 0,
    heartbeatPhase: 0,
};

const music = {
    journeyIndex: 0,
    phaseProgress: 0,
    tick: 0,
    bar: 0,
};

let ctx, masterGain, masterFilter, reverbGain, compressor;
let canvas, vc;
let audioReady = false;

// ═══════════════════════════════════════════════════════════════════════════
// AUDIO ENGINE
// ═══════════════════════════════════════════════════════════════════════════

async function initAudio() {
    ctx = new (window.AudioContext || window.webkitAudioContext)();

    // Master filter - tilt controlled
    masterFilter = ctx.createBiquadFilter();
    masterFilter.type = 'lowpass';
    masterFilter.frequency.value = 2000;
    masterFilter.Q.value = 0.7;

    // Large reverb for cosmic space
    const reverbBuffer = createReverb(6.0);
    const reverb = ctx.createConvolver();
    reverb.buffer = reverbBuffer;
    reverbGain = ctx.createGain();
    reverbGain.gain.value = 0.4;

    // Gentle compression
    compressor = ctx.createDynamicsCompressor();
    compressor.threshold.value = -18;
    compressor.ratio.value = 3;
    compressor.attack.value = 0.01;
    compressor.release.value = 0.2;

    // Master output
    masterGain = ctx.createGain();
    masterGain.gain.value = 0.85;

    // Routing
    masterFilter.connect(compressor);
    masterFilter.connect(reverb);
    reverb.connect(reverbGain);
    reverbGain.connect(compressor);
    compressor.connect(masterGain);
    masterGain.connect(ctx.destination);

    // Initialize all sound layers
    initGenesis();
    initTribal();
    initAncient();
    initClassical();
    initBlues();
    initJazz();
    initRock();
    initElectronic();
    initModern();

    audioReady = true;
}

function createReverb(duration) {
    const length = ctx.sampleRate * duration;
    const buffer = ctx.createBuffer(2, length, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = buffer.getChannelData(ch);
        for (let i = 0; i < length; i++) {
            const t = i / ctx.sampleRate;
            // Early reflections
            const early = i < ctx.sampleRate * 0.1 ? Math.random() * 0.2 * Math.exp(-t * 10) : 0;
            // Late reverb
            const late = (Math.random() * 2 - 1) * Math.exp(-t / (duration * 0.45)) * 0.35;
            data[i] = early + late;
        }
    }
    return buffer;
}

// ═══════════════════════════════════════════════════════════════════════════
// GENESIS - The divine emergence
// ═══════════════════════════════════════════════════════════════════════════
//
// Phase 0: The Void - near silence, a presence felt not heard
// Phase 1: First Vibration - the primordial tone emerges
// Phase 2: Let There Be Light - overtones bloom like light separating
// Phase 3: The Expansion - sound fills cosmic space
// Phase 4: First Pulse - a heartbeat begins
//
// ═══════════════════════════════════════════════════════════════════════════

let genesis = {
    // The fundamental - the first sound
    fundamental: null,
    fundamentalGain: null,

    // Overtone series - harmonics that bloom
    overtones: [],
    overtonesGain: null,

    // Sub frequencies - felt more than heard
    sub: null,
    subGain: null,

    // Cosmic texture - the breath of the void
    texture: null,
    textureGain: null,

    // The first heartbeat
    heartbeatOsc: null,
    heartbeatGain: null,

    // LFOs for organic movement
    lfos: []
};

function initGenesis() {
    // ═══════════════════════════════════════════════════════════════════════
    // THE VOID (Phase 0) - Almost imperceptible presence
    // ═══════════════════════════════════════════════════════════════════════

    // Sub-bass rumble - you feel it in your chest
    genesis.sub = ctx.createOscillator();
    genesis.sub.type = 'sine';
    genesis.sub.frequency.value = 20; // Below hearing, felt

    const subFilter = ctx.createBiquadFilter();
    subFilter.type = 'lowpass';
    subFilter.frequency.value = 40;

    genesis.subGain = ctx.createGain();
    genesis.subGain.gain.value = 0;

    genesis.sub.connect(subFilter);
    subFilter.connect(genesis.subGain);
    genesis.subGain.connect(masterFilter);
    genesis.sub.start();

    // Cosmic texture - filtered noise, barely there
    const textureBuffer = ctx.createBuffer(2, ctx.sampleRate * 10, ctx.sampleRate);
    for (let ch = 0; ch < 2; ch++) {
        const data = textureBuffer.getChannelData(ch);
        for (let i = 0; i < data.length; i++) {
            // Very subtle, slowly varying noise
            const t = i / ctx.sampleRate;
            data[i] = (Math.random() * 2 - 1) * 0.015 * (0.5 + 0.5 * Math.sin(t * 0.1));
        }
    }

    genesis.texture = ctx.createBufferSource();
    genesis.texture.buffer = textureBuffer;
    genesis.texture.loop = true;

    const textureFilter = ctx.createBiquadFilter();
    textureFilter.type = 'bandpass';
    textureFilter.frequency.value = 100;
    textureFilter.Q.value = 0.5;

    genesis.textureGain = ctx.createGain();
    genesis.textureGain.gain.value = 0;

    genesis.texture.connect(textureFilter);
    textureFilter.connect(genesis.textureGain);
    genesis.textureGain.connect(masterFilter);
    genesis.texture.start();

    // ═══════════════════════════════════════════════════════════════════════
    // FIRST VIBRATION (Phase 1) - The primordial tone
    // ═══════════════════════════════════════════════════════════════════════

    // The fundamental frequency - A0 (27.5 Hz) - the beginning of all music
    genesis.fundamental = ctx.createOscillator();
    genesis.fundamental.type = 'sine';
    genesis.fundamental.frequency.value = 27.5;

    // LFO to make it breathe
    const fundLfo = ctx.createOscillator();
    fundLfo.type = 'sine';
    fundLfo.frequency.value = 0.06; // Very slow breathing
    const fundLfoGain = ctx.createGain();
    fundLfoGain.gain.value = 2;
    fundLfo.connect(fundLfoGain);
    fundLfoGain.connect(genesis.fundamental.frequency);
    fundLfo.start();
    genesis.lfos.push(fundLfo);

    // Amplitude LFO for pulsing
    const ampLfo = ctx.createOscillator();
    ampLfo.type = 'sine';
    ampLfo.frequency.value = 0.08;
    const ampLfoGain = ctx.createGain();
    ampLfoGain.gain.value = 0.15;

    genesis.fundamentalGain = ctx.createGain();
    genesis.fundamentalGain.gain.value = 0;

    ampLfo.connect(ampLfoGain);
    ampLfoGain.connect(genesis.fundamentalGain.gain);
    ampLfo.start();
    genesis.lfos.push(ampLfo);

    genesis.fundamental.connect(genesis.fundamentalGain);
    genesis.fundamentalGain.connect(masterFilter);
    genesis.fundamental.start();

    // ═══════════════════════════════════════════════════════════════════════
    // LET THERE BE LIGHT (Phase 2) - Overtones bloom
    // ═══════════════════════════════════════════════════════════════════════

    genesis.overtonesGain = ctx.createGain();
    genesis.overtonesGain.gain.value = 0;

    // The harmonic series - each overtone is a "color" of light
    const harmonics = [
        { ratio: 2, gain: 0.5 },     // Octave - pure
        { ratio: 3, gain: 0.35 },    // Fifth - the first harmony
        { ratio: 4, gain: 0.25 },    // Second octave
        { ratio: 5, gain: 0.2 },     // Major third
        { ratio: 6, gain: 0.15 },    // Fifth again
        { ratio: 7, gain: 0.1 },     // Harmonic seventh (blue note)
        { ratio: 8, gain: 0.08 },    // Third octave
        { ratio: 9, gain: 0.06 },    // Major second
        { ratio: 10, gain: 0.05 },   // Third again
    ];

    harmonics.forEach((h, i) => {
        const osc = ctx.createOscillator();
        osc.type = 'sine';
        osc.frequency.value = 27.5 * h.ratio;

        // Each harmonic has its own slow LFO for shimmer
        const lfo = ctx.createOscillator();
        lfo.type = 'sine';
        lfo.frequency.value = 0.03 + i * 0.008;
        const lfoGain = ctx.createGain();
        lfoGain.gain.value = h.ratio * 0.3;
        lfo.connect(lfoGain);
        lfoGain.connect(osc.frequency);
        lfo.start();

        const gain = ctx.createGain();
        gain.gain.value = h.gain;

        osc.connect(gain);
        gain.connect(genesis.overtonesGain);
        osc.start();

        genesis.overtones.push({ osc, gain, lfo, ratio: h.ratio, baseGain: h.gain });
    });

    genesis.overtonesGain.connect(masterFilter);

    // ═══════════════════════════════════════════════════════════════════════
    // FIRST PULSE (Phase 4) - The cosmic heartbeat
    // ═══════════════════════════════════════════════════════════════════════

    genesis.heartbeatOsc = ctx.createOscillator();
    genesis.heartbeatOsc.type = 'sine';
    genesis.heartbeatOsc.frequency.value = 40;

    genesis.heartbeatGain = ctx.createGain();
    genesis.heartbeatGain.gain.value = 0;

    const heartFilter = ctx.createBiquadFilter();
    heartFilter.type = 'lowpass';
    heartFilter.frequency.value = 80;
    heartFilter.Q.value = 2;

    genesis.heartbeatOsc.connect(heartFilter);
    heartFilter.connect(genesis.heartbeatGain);
    genesis.heartbeatGain.connect(masterFilter);
    genesis.heartbeatOsc.start();
}

function triggerHeartbeat() {
    if (!genesis.heartbeatGain || !audioReady) return;

    const now = ctx.currentTime;
    const current = JOURNEY[music.journeyIndex];
    if (current.era !== 'genesis' || current.phase < 4) return;

    // Heartbeat envelope - quick attack, slow decay
    genesis.heartbeatGain.gain.cancelScheduledValues(now);
    genesis.heartbeatGain.gain.setValueAtTime(0.01, now);
    genesis.heartbeatGain.gain.linearRampToValueAtTime(0.4 + world.energy * 0.3, now + 0.02);
    genesis.heartbeatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.5);

    // Pitch drop like a real heartbeat
    genesis.heartbeatOsc.frequency.setValueAtTime(55, now);
    genesis.heartbeatOsc.frequency.exponentialRampToValueAtTime(35, now + 0.15);
}

function updateGenesis() {
    if (!audioReady) return;

    const current = JOURNEY[music.journeyIndex];
    const isGenesis = current.era === 'genesis';
    const phase = isGenesis ? current.phase : -1;
    const progress = music.phaseProgress;

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 0: THE VOID
    // ═══════════════════════════════════════════════════════════════════════
    if (phase === 0) {
        // Sub rumble - barely perceptible, grows with movement
        const subVol = 0.15 + world.energy * 0.25 + progress * 0.2;
        genesis.subGain.gain.setTargetAtTime(subVol, ctx.currentTime, 0.5);

        // Texture emerges slowly
        const textureVol = 0.1 + progress * 0.3;
        genesis.textureGain.gain.setTargetAtTime(textureVol, ctx.currentTime, 0.8);

        // Fundamental begins to fade in at the end of void
        if (progress > 0.7) {
            const fundVol = (progress - 0.7) * 0.5;
            genesis.fundamentalGain.gain.setTargetAtTime(fundVol, ctx.currentTime, 1.0);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 1: FIRST VIBRATION
    // ═══════════════════════════════════════════════════════════════════════
    else if (phase === 1) {
        // The fundamental tone grows in presence
        const fundVol = 0.25 + progress * 0.3 + world.energy * 0.2;
        genesis.fundamentalGain.gain.setTargetAtTime(fundVol, ctx.currentTime, 0.4);

        // Sub continues
        genesis.subGain.gain.setTargetAtTime(0.35, ctx.currentTime, 0.5);
        genesis.textureGain.gain.setTargetAtTime(0.3, ctx.currentTime, 0.5);

        // Tilt modulates the fundamental pitch slightly
        const pitchMod = world.tilt.y * 5;
        genesis.fundamental.frequency.setTargetAtTime(27.5 + pitchMod, ctx.currentTime, 0.2);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 2: LET THERE BE LIGHT
    // ═══════════════════════════════════════════════════════════════════════
    else if (phase === 2) {
        // Fundamental stays strong
        genesis.fundamentalGain.gain.setTargetAtTime(0.5, ctx.currentTime, 0.3);

        // Overtones bloom in sequence based on progress
        genesis.overtones.forEach((h, i) => {
            const threshold = i * 0.1; // Each harmonic has a threshold
            if (progress > threshold) {
                const harmonicProgress = (progress - threshold) / (1 - threshold);
                const vol = h.baseGain * harmonicProgress * (0.7 + world.energy * 0.3);
                h.gain.gain.setTargetAtTime(vol, ctx.currentTime, 0.5 + i * 0.1);
            }
        });

        // Overall overtones volume
        const overtonesVol = 0.15 + progress * 0.35;
        genesis.overtonesGain.gain.setTargetAtTime(overtonesVol, ctx.currentTime, 0.6);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 3: THE EXPANSION
    // ═══════════════════════════════════════════════════════════════════════
    else if (phase === 3) {
        // Full fundamental and overtones
        genesis.fundamentalGain.gain.setTargetAtTime(0.55, ctx.currentTime, 0.3);
        genesis.overtonesGain.gain.setTargetAtTime(0.45 + world.energy * 0.15, ctx.currentTime, 0.3);

        // Spread the overtones wider with tilt
        genesis.overtones.forEach((h, i) => {
            const spread = 1 + world.tilt.x * 0.05 * i;
            h.osc.frequency.setTargetAtTime(27.5 * h.ratio * spread, ctx.currentTime, 0.1);
        });

        // Sub becomes more prominent
        genesis.subGain.gain.setTargetAtTime(0.4 + world.energy * 0.2, ctx.currentTime, 0.3);
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 4: FIRST PULSE
    // ═══════════════════════════════════════════════════════════════════════
    else if (phase === 4) {
        // Everything continues
        genesis.fundamentalGain.gain.setTargetAtTime(0.45, ctx.currentTime, 0.3);
        genesis.overtonesGain.gain.setTargetAtTime(0.35, ctx.currentTime, 0.3);
        genesis.subGain.gain.setTargetAtTime(0.35, ctx.currentTime, 0.3);

        // Heartbeat rhythm - irregular at first, becoming steady
        world.heartbeat += 0.015 + progress * 0.01;
        const heartRate = 0.7 + progress * 0.5; // Gets faster and more regular
        const shouldBeat = Math.sin(world.heartbeat * heartRate) > 0.7;

        if (shouldBeat && world.heartbeatPhase === 0) {
            triggerHeartbeat();
            world.heartbeatPhase = 1;
        } else if (!shouldBeat) {
            world.heartbeatPhase = 0;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // FADE OUT when leaving Genesis
    // ═══════════════════════════════════════════════════════════════════════
    else if (!isGenesis && current.era === 'tribal') {
        // Slow crossfade
        const fadeout = 1 - Math.min(1, progress * 2);
        genesis.fundamentalGain.gain.setTargetAtTime(0.3 * fadeout, ctx.currentTime, 0.5);
        genesis.overtonesGain.gain.setTargetAtTime(0.2 * fadeout, ctx.currentTime, 0.5);
        genesis.subGain.gain.setTargetAtTime(0.2 * fadeout, ctx.currentTime, 0.5);
        genesis.textureGain.gain.setTargetAtTime(0.1 * fadeout, ctx.currentTime, 0.5);
    }
    else if (!isGenesis) {
        // Fully faded
        genesis.fundamentalGain.gain.setTargetAtTime(0, ctx.currentTime, 1);
        genesis.overtonesGain.gain.setTargetAtTime(0, ctx.currentTime, 1);
        genesis.subGain.gain.setTargetAtTime(0, ctx.currentTime, 1);
        genesis.textureGain.gain.setTargetAtTime(0, ctx.currentTime, 1);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// TRIBAL - The discovery of rhythm
// ═══════════════════════════════════════════════════════════════════════════
//
// Phase 0: Footsteps - basic pulse, stomping
// Phase 1: Hands - claps, body percussion
// Phase 2: Wood & Stone - found objects
// Phase 3: First Drums - animal skins
// Phase 4: Voice Awakens - first melodies
//
// ═══════════════════════════════════════════════════════════════════════════

let tribal = {
    lastStep: 0,
    lastClap: 0,
    lastWood: 0,
    lastDrum: 0,
    voiceOsc: null,
    voiceGain: null,
    droneOsc: null,
    droneGain: null,
    stepBuffer: null,
    clapBuffer: null,
    woodBuffer: null,
    stoneBuffer: null,
    drumBuffer: null,
};

function initTribal() {
    // Create percussion buffers

    // Footstep - low thud
    tribal.stepBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.3, ctx.sampleRate);
    const stepData = tribal.stepBuffer.getChannelData(0);
    for (let i = 0; i < stepData.length; i++) {
        const t = i / ctx.sampleRate;
        const freq = 60 + 40 * Math.exp(-t * 30);
        stepData[i] = Math.sin(TAU * freq * t) * Math.exp(-t * 12) * 0.7;
    }

    // Clap - short noise burst
    tribal.clapBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.15, ctx.sampleRate);
    const clapData = tribal.clapBuffer.getChannelData(0);
    for (let i = 0; i < clapData.length; i++) {
        const t = i / ctx.sampleRate;
        clapData[i] = (Math.random() * 2 - 1) * Math.exp(-t * 40) * 0.6;
    }

    // Wood hit - resonant
    tribal.woodBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.4, ctx.sampleRate);
    const woodData = tribal.woodBuffer.getChannelData(0);
    for (let i = 0; i < woodData.length; i++) {
        const t = i / ctx.sampleRate;
        const freq = 400 + 200 * Math.exp(-t * 20);
        woodData[i] = (Math.sin(TAU * freq * t) * 0.6 + Math.sin(TAU * freq * 2.3 * t) * 0.3) * Math.exp(-t * 15) * 0.5;
    }

    // Stone click - high, short
    tribal.stoneBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
    const stoneData = tribal.stoneBuffer.getChannelData(0);
    for (let i = 0; i < stoneData.length; i++) {
        const t = i / ctx.sampleRate;
        stoneData[i] = (Math.sin(TAU * 2500 * t) + Math.sin(TAU * 3200 * t) * 0.5) * Math.exp(-t * 60) * 0.4;
    }

    // Drum - animal skin, deep and resonant
    tribal.drumBuffer = ctx.createBuffer(1, ctx.sampleRate * 0.8, ctx.sampleRate);
    const drumData = tribal.drumBuffer.getChannelData(0);
    for (let i = 0; i < drumData.length; i++) {
        const t = i / ctx.sampleRate;
        const freq = 80 + 60 * Math.exp(-t * 15);
        const body = Math.sin(TAU * freq * t) * Math.exp(-t * 5);
        const skin = (Math.random() * 2 - 1) * Math.exp(-t * 20) * 0.2;
        const slap = Math.sin(TAU * 300 * t) * Math.exp(-t * 50) * 0.3;
        drumData[i] = (body + skin + slap) * 0.7;
    }

    // Vocal drone
    tribal.droneOsc = ctx.createOscillator();
    tribal.droneOsc.type = 'sawtooth';
    tribal.droneOsc.frequency.value = 110;

    const droneFilter = ctx.createBiquadFilter();
    droneFilter.type = 'lowpass';
    droneFilter.frequency.value = 400;
    droneFilter.Q.value = 3;

    tribal.droneGain = ctx.createGain();
    tribal.droneGain.gain.value = 0;

    // Vibrato for voice
    const vibrato = ctx.createOscillator();
    vibrato.frequency.value = 5;
    const vibratoGain = ctx.createGain();
    vibratoGain.gain.value = 4;
    vibrato.connect(vibratoGain);
    vibratoGain.connect(tribal.droneOsc.frequency);
    vibrato.start();

    tribal.droneOsc.connect(droneFilter);
    droneFilter.connect(tribal.droneGain);
    tribal.droneGain.connect(masterFilter);
    tribal.droneOsc.start();
}

function playTribalSound(type, vol = 1, pan = 0) {
    if (!audioReady) return;

    let buffer;
    if (type === 'step') buffer = tribal.stepBuffer;
    else if (type === 'clap') buffer = tribal.clapBuffer;
    else if (type === 'wood') buffer = tribal.woodBuffer;
    else if (type === 'stone') buffer = tribal.stoneBuffer;
    else if (type === 'drum') buffer = tribal.drumBuffer;
    else return;

    const source = ctx.createBufferSource();
    source.buffer = buffer;

    const gain = ctx.createGain();
    gain.gain.value = vol;

    const panner = ctx.createStereoPanner();
    panner.pan.value = pan;

    source.connect(gain);
    gain.connect(panner);
    panner.connect(masterFilter);
    source.start();
}

function updateTribal() {
    if (!audioReady) return;

    const current = JOURNEY[music.journeyIndex];
    const isTribal = current.era === 'tribal';
    const phase = isTribal ? current.phase : -1;
    const progress = music.phaseProgress;
    const now = ctx.currentTime;

    // Base tempo gets faster with phases
    const baseTempo = 0.7 + phase * 0.15;

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 0: FOOTSTEPS
    // ═══════════════════════════════════════════════════════════════════════
    if (phase >= 0 && isTribal) {
        // Simple walking rhythm
        world.heartbeat += 0.012 * baseTempo;
        const stepPattern = Math.sin(world.heartbeat) > 0.6;

        if (stepPattern && now - tribal.lastStep > 0.3) {
            playTribalSound('step', 0.5 + world.energy * 0.3, (Math.random() - 0.5) * 0.3);
            tribal.lastStep = now;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 1: HANDS - Claps join
    // ═══════════════════════════════════════════════════════════════════════
    if (phase >= 1 && isTribal) {
        const clapPattern = Math.sin(world.heartbeat * 2 + 1.5) > 0.75;

        if (clapPattern && now - tribal.lastClap > 0.2) {
            playTribalSound('clap', 0.4 + world.energy * 0.2, (Math.random() - 0.5) * 0.5);
            tribal.lastClap = now;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 2: WOOD & STONE
    // ═══════════════════════════════════════════════════════════════════════
    if (phase >= 2 && isTribal) {
        // Wood on off-beats
        const woodPattern = Math.sin(world.heartbeat * 2 + 0.5) > 0.8;
        if (woodPattern && now - tribal.lastWood > 0.25) {
            playTribalSound('wood', 0.35, (Math.random() - 0.5) * 0.4);
            tribal.lastWood = now;
        }

        // Occasional stone clicks
        if (Math.random() < 0.008 + world.energy * 0.01) {
            playTribalSound('stone', 0.25, (Math.random() - 0.5) * 0.8);
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 3: FIRST DRUMS
    // ═══════════════════════════════════════════════════════════════════════
    if (phase >= 3 && isTribal) {
        // Deep drum on the one
        const drumPattern = Math.sin(world.heartbeat * 0.5) > 0.85;
        if (drumPattern && now - tribal.lastDrum > 0.5) {
            playTribalSound('drum', 0.6 + world.energy * 0.3, 0);
            tribal.lastDrum = now;
        }
    }

    // ═══════════════════════════════════════════════════════════════════════
    // PHASE 4: VOICE AWAKENS
    // ═══════════════════════════════════════════════════════════════════════
    if (phase >= 4 && isTribal) {
        // Drone voice
        const droneVol = 0.15 + Math.sin(world.breath * 0.3) * 0.05 + world.energy * 0.1;
        tribal.droneGain.gain.setTargetAtTime(droneVol, now, 0.3);

        // Pentatonic melody - movement selects notes
        const pentatonic = [0, 2, 4, 7, 9]; // Minor pentatonic intervals
        const noteIndex = Math.floor(world.y * pentatonic.length);
        const note = 110 * Math.pow(2, pentatonic[noteIndex] / 12);
        tribal.droneOsc.frequency.setTargetAtTime(note, now, 0.15);
    } else {
        tribal.droneGain.gain.setTargetAtTime(0, now, 0.5);
    }

    // Fade out when leaving tribal
    if (!isTribal && current.era === 'ancient') {
        // Let sounds fade naturally, reduce trigger frequency
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// ANCIENT - Melody is born (placeholder - expand later)
// ═══════════════════════════════════════════════════════════════════════════

let ancient = {
    chantOsc: null,
    chantGain: null,
    fluteOsc: null,
    fluteGain: null
};

function initAncient() {
    // Monophonic chant
    ancient.chantOsc = ctx.createOscillator();
    ancient.chantOsc.type = 'sawtooth';
    ancient.chantOsc.frequency.value = 165;

    const chantFilter = ctx.createBiquadFilter();
    chantFilter.type = 'lowpass';
    chantFilter.frequency.value = 600;
    chantFilter.Q.value = 2;

    ancient.chantGain = ctx.createGain();
    ancient.chantGain.gain.value = 0;

    ancient.chantOsc.connect(chantFilter);
    chantFilter.connect(ancient.chantGain);
    ancient.chantGain.connect(masterFilter);
    ancient.chantOsc.start();

    // Bone flute
    ancient.fluteOsc = ctx.createOscillator();
    ancient.fluteOsc.type = 'sine';
    ancient.fluteOsc.frequency.value = 440;

    const fluteFilter = ctx.createBiquadFilter();
    fluteFilter.type = 'bandpass';
    fluteFilter.frequency.value = 800;
    fluteFilter.Q.value = 5;

    ancient.fluteGain = ctx.createGain();
    ancient.fluteGain.gain.value = 0;

    // Breath noise for flute
    const breathNoise = ctx.createBufferSource();
    const breathBuffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
    const breathData = breathBuffer.getChannelData(0);
    for (let i = 0; i < breathData.length; i++) {
        breathData[i] = (Math.random() * 2 - 1) * 0.02;
    }
    breathNoise.buffer = breathBuffer;
    breathNoise.loop = true;

    ancient.fluteOsc.connect(fluteFilter);
    breathNoise.connect(ancient.fluteGain);
    fluteFilter.connect(ancient.fluteGain);
    ancient.fluteGain.connect(masterFilter);

    ancient.fluteOsc.start();
    breathNoise.start();
}

function updateAncient() {
    if (!audioReady) return;
    const current = JOURNEY[music.journeyIndex];
    const isAncient = current.era === 'ancient';

    if (isAncient) {
        const phase = current.phase;

        if (phase >= 0) {
            // Chant
            const chantVol = 0.2 + Math.sin(world.breath * 0.2) * 0.08;
            ancient.chantGain.gain.setTargetAtTime(chantVol, ctx.currentTime, 0.4);

            // Dorian mode for ancient feel
            const dorian = [0, 2, 3, 5, 7, 9, 10];
            const noteIndex = Math.floor(world.y * dorian.length);
            const note = 165 * Math.pow(2, dorian[noteIndex] / 12);
            ancient.chantOsc.frequency.setTargetAtTime(note, ctx.currentTime, 0.2);
        }

        if (phase >= 1) {
            // Flute joins
            const fluteVol = 0.12 + world.energy * 0.1;
            ancient.fluteGain.gain.setTargetAtTime(fluteVol, ctx.currentTime, 0.3);

            const phrygian = [0, 1, 3, 5, 7, 8, 10];
            const noteIndex = Math.floor(world.x * phrygian.length);
            const note = 440 * Math.pow(2, phrygian[noteIndex] / 12);
            ancient.fluteOsc.frequency.setTargetAtTime(note, ctx.currentTime, 0.1);
        }
    } else {
        ancient.chantGain.gain.setTargetAtTime(0, ctx.currentTime, 0.8);
        ancient.fluteGain.gain.setTargetAtTime(0, ctx.currentTime, 0.8);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// CLASSICAL - Orchestra (placeholder)
// ═══════════════════════════════════════════════════════════════════════════

let classical = { strings: [], stringsGain: null, brassGain: null };

function initClassical() {
    classical.stringsGain = ctx.createGain();
    classical.stringsGain.gain.value = 0;

    // String section - layered oscillators
    for (let i = 0; i < 6; i++) {
        const osc = ctx.createOscillator();
        osc.type = 'sawtooth';
        osc.frequency.value = 220 * Math.pow(2, i * 0.4);
        osc.detune.value = (Math.random() - 0.5) * 10;

        const g = ctx.createGain();
        g.gain.value = 0.06;

        osc.connect(g);
        g.connect(classical.stringsGain);
        osc.start();

        classical.strings.push({ osc, gain: g });
    }

    const stringsFilter = ctx.createBiquadFilter();
    stringsFilter.type = 'lowpass';
    stringsFilter.frequency.value = 3000;

    classical.stringsGain.connect(stringsFilter);
    stringsFilter.connect(masterFilter);
}

function updateClassical() {
    if (!audioReady) return;
    const current = JOURNEY[music.journeyIndex];
    const isClassical = current.era === 'classical';

    if (isClassical) {
        classical.stringsGain.gain.setTargetAtTime(0.3 + world.energy * 0.2, ctx.currentTime, 0.5);
    } else {
        classical.stringsGain.gain.setTargetAtTime(0, ctx.currentTime, 1);
    }
}

// ═══════════════════════════════════════════════════════════════════════════
// BLUES, JAZZ, ROCK, ELECTRONIC, MODERN - Placeholders
// ═══════════════════════════════════════════════════════════════════════════

function initBlues() {}
function updateBlues() {}
function initJazz() {}
function updateJazz() {}
function initRock() {}
function updateRock() {}
function initElectronic() {}
function updateElectronic() {}
function initModern() {}
function updateModern() {}

// ═══════════════════════════════════════════════════════════════════════════
// JOURNEY PROGRESSION
// ═══════════════════════════════════════════════════════════════════════════

function updateJourney() {
    const current = JOURNEY[music.journeyIndex];
    const next = JOURNEY[music.journeyIndex + 1];

    if (next) {
        const range = next.threshold - current.threshold;
        const progress = world.totalMovement - current.threshold;
        music.phaseProgress = Math.min(1, Math.max(0, progress / range));

        if (world.totalMovement >= next.threshold) {
            music.journeyIndex++;
            music.phaseProgress = 0;
            console.log(`Entering: ${JOURNEY[music.journeyIndex].name}`);
        }
    } else {
        music.phaseProgress = 1;
    }

    // Update UI
    document.getElementById('evolution-fill').style.width = (music.phaseProgress * 100) + '%';
    document.getElementById('era-name').textContent = current.era;
    document.getElementById('phase-name').textContent = current.name;
}

// ═══════════════════════════════════════════════════════════════════════════
// INPUT
// ═══════════════════════════════════════════════════════════════════════════

function onMove(nx, ny) {
    const dx = nx - world.x;
    const dy = ny - world.y;

    world.vx = world.vx * 0.7 + dx * 0.3;
    world.vy = world.vy * 0.7 + dy * 0.3;
    world.x = nx;
    world.y = ny;

    const movement = Math.sqrt(dx*dx + dy*dy);
    world.energy = Math.min(1, world.energy * 0.85 + movement * 6);
    world.totalMovement += movement * 60; // Slower accumulation
}

function onMotion(e) {
    const a = e.accelerationIncludingGravity;
    if (!a) return;

    const ax = (a.x || 0) / 10;
    const ay = (a.y || 0) / 10;

    world.x = Math.max(0, Math.min(1, world.x + ax * 0.04));
    world.y = Math.max(0, Math.min(1, world.y - ay * 0.04));

    world.tilt.x = Math.max(-1, Math.min(1, ax * 1.5));
    world.tilt.y = Math.max(-1, Math.min(1, ay * 1.5));

    const movement = Math.sqrt(ax*ax + ay*ay);
    world.energy = Math.min(1, world.energy * 0.8 + movement * 0.35);
    world.totalMovement += movement * 5;
}

// ═══════════════════════════════════════════════════════════════════════════
// VISUALS
// ═══════════════════════════════════════════════════════════════════════════

function initVisuals() {
    canvas = document.getElementById('c');
    vc = canvas.getContext('2d');
    resize();
    window.addEventListener('resize', resize);
}

function resize() {
    const dpr = window.devicePixelRatio || 1;
    canvas.width = innerWidth * dpr;
    canvas.height = innerHeight * dpr;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
    vc.setTransform(dpr, 0, 0, dpr, 0, 0);
}

function draw() {
    const w = innerWidth, h = innerHeight;
    const current = JOURNEY[music.journeyIndex];

    // Fade based on era
    const fadeSpeeds = {
        genesis: 0.03,
        tribal: 0.06,
        ancient: 0.05,
        classical: 0.04,
        blues: 0.07,
        jazz: 0.06,
        rock: 0.08,
        electronic: 0.05,
        modern: 0.04
    };

    vc.fillStyle = `rgba(0,0,0,${fadeSpeeds[current.era] || 0.05})`;
    vc.fillRect(0, 0, w, h);

    // Central presence - grows with journey
    const breath = Math.sin(world.breath * 0.4) * 0.5 + 0.5;
    const baseSize = 20 + music.journeyIndex * 8;
    const size = baseSize + breath * 15 + world.energy * 40;

    // Color shifts through journey
    const hueShift = music.journeyIndex * 20;
    const alpha = 0.03 + world.energy * 0.04 + music.phaseProgress * 0.02;

    vc.strokeStyle = `hsla(${hueShift}, 20%, 60%, ${alpha})`;
    vc.lineWidth = 1;

    // Multiple rings
    for (let i = 0; i < 4; i++) {
        const ringSize = size + i * (20 + music.journeyIndex * 5);
        vc.beginPath();
        vc.arc(w/2, h/2, ringSize, 0, TAU);
        vc.stroke();
    }

    // Position dot
    const px = world.x * w;
    const py = world.y * h;
    const ps = 3 + world.energy * 12;

    vc.fillStyle = `rgba(255,255,255,${0.15 + world.energy * 0.4})`;
    vc.beginPath();
    vc.arc(px, py, ps, 0, TAU);
    vc.fill();
}

// ═══════════════════════════════════════════════════════════════════════════
// MAIN LOOP
// ═══════════════════════════════════════════════════════════════════════════

function frame() {
    world.breath += 0.015;
    world.energy *= 0.992;

    // Update journey progression
    updateJourney();

    // Update all sound layers
    updateGenesis();
    updateTribal();
    updateAncient();
    updateClassical();
    updateBlues();
    updateJazz();
    updateRock();
    updateElectronic();
    updateModern();

    // Master filter follows tilt
    if (masterFilter && audioReady) {
        const baseFreq = 800 + music.journeyIndex * 200;
        const tiltMod = world.tilt.x * 1500;
        masterFilter.frequency.setTargetAtTime(
            Math.max(200, baseFreq + tiltMod + world.energy * 1000),
            ctx.currentTime, 0.1
        );
    }

    // Draw
    draw();

    // Status
    const status = `${Math.round(world.totalMovement)} | ${JOURNEY[music.journeyIndex].name}`;
    document.getElementById('status').textContent = status;

    requestAnimationFrame(frame);
}

// ═══════════════════════════════════════════════════════════════════════════
// INIT
// ═══════════════════════════════════════════════════════════════════════════

async function start() {
    document.getElementById('enter').classList.add('off');
    document.getElementById('world').classList.add('on');

    if (typeof DeviceMotionEvent?.requestPermission === 'function') {
        try { await DeviceMotionEvent.requestPermission(); } catch(e) {}
    }

    await initAudio();
    initVisuals();

    window.addEventListener('devicemotion', onMotion);
    canvas.addEventListener('mousemove', e => onMove(e.clientX/innerWidth, e.clientY/innerHeight));
    canvas.addEventListener('touchmove', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });
    canvas.addEventListener('touchstart', e => {
        e.preventDefault();
        onMove(e.touches[0].clientX/innerWidth, e.touches[0].clientY/innerHeight);
    }, { passive: false });

    if (ctx.state === 'suspended') await ctx.resume();
    frame();
}

document.getElementById('enter').addEventListener('click', start);
</script>
</body>
</html>
