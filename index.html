<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GUMP</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #000;
            color: #fff;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: none;
        }

        .orb {
            position: fixed;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(255,255,255,0.6) 0%, rgba(255,255,255,0.2) 50%, transparent 80%);
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            transition: all 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            box-shadow: 0 0 15px rgba(255,255,255,0.3);
            pointer-events: none;
            z-index: 10;
            filter: blur(0.5px);
        }

        .orb.pulse {
            animation: pulse 0.3s ease-out;
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
            50% { transform: translate(-50%, -50%) scale(3); box-shadow: 0 0 30px rgba(255,255,255,0.6); filter: blur(0); }
            100% { transform: translate(-50%, -50%) scale(1); filter: blur(0.5px); }
        }

        .orb.recording {
            background: radial-gradient(circle, rgba(255,100,100,0.8) 0%, rgba(255,0,0,0.3) 50%, transparent 80%);
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
            animation: rec 1s ease-in-out infinite;
        }

        @keyframes rec {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.2); }
        }
    </style>
</head>
<body>
    <div id="orb" class="orb"></div>

    <script>
        'use strict';

        // Beat Matcher - finds transients and stretches samples to fit
        class BeatMatcher {
            constructor() {
                this.bpm = 75; // Lo-fi trip hop tempo
            }

            findPeaks(buffer, sr) {
                const data = buffer.getChannelData(0);
                const peaks = [];
                const windowSize = 1024;
                const hop = 512;
                
                // Energy-based peak detection
                for (let i = 0; i < data.length - windowSize; i += hop) {
                    let energy = 0;
                    for (let j = 0; j < windowSize; j++) {
                        energy += data[i + j] * data[i + j];
                    }
                    energy = Math.sqrt(energy / windowSize);
                    
                    if (i > 0 && energy > peaks[peaks.length - 1]?.energy * 1.3 && energy > 0.05) {
                        peaks.push({ time: i / sr, energy, index: i });
                    }
                }
                
                return peaks;
            }

            matchToGrid(peaks, barLength = 4) {
                if (peaks.length < 2) return 1;
                
                // Find average interval between peaks
                const intervals = [];
                for (let i = 1; i < peaks.length; i++) {
                    intervals.push(peaks[i].time - peaks[i - 1].time);
                }
                
                const avgInterval = intervals.reduce((a, b) => a + b) / intervals.length;
                const beatDuration = 60 / this.bpm;
                
                // Find closest musical division (1/4, 1/8, 1/16, etc.)
                const divisions = [4, 2, 1, 0.5, 0.25];
                let bestDiv = 1;
                let minDiff = Infinity;
                
                for (const div of divisions) {
                    const targetInterval = beatDuration * div;
                    const diff = Math.abs(avgInterval - targetInterval);
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestDiv = div;
                    }
                }
                
                // Calculate stretch factor
                const targetDuration = beatDuration * barLength;
                const actualDuration = peaks[peaks.length - 1].time - peaks[0].time;
                
                return targetDuration / actualDuration;
            }

            chopSample(buffer, peaks, chopsPerBar = 4) {
                const chops = [];
                const beatDuration = 60 / this.bpm;
                const chopLength = beatDuration * 4 / chopsPerBar;
                
                // Create chops at peak positions
                for (let i = 0; i < Math.min(peaks.length - 1, chopsPerBar); i++) {
                    const start = peaks[i].time;
                    const end = Math.min(start + chopLength, buffer.duration);
                    chops.push({ start, end, peak: peaks[i].energy });
                }
                
                return chops;
            }
        }

        // Lo-fi processor
        class LoFi {
            constructor(ctx) {
                this.ctx = ctx;
            }

            process(source) {
                // Bitcrusher
                const bitcrusher = this.ctx.createScriptProcessor(4096, 1, 1);
                const bits = 8; // 8-bit sound
                const normFreq = 0.3; // Downsample
                
                let phaser = 0;
                bitcrusher.onaudioprocess = (e) => {
                    const input = e.inputBuffer.getChannelData(0);
                    const output = e.outputBuffer.getChannelData(0);
                    
                    for (let i = 0; i < input.length; i++) {
                        phaser += normFreq;
                        if (phaser >= 1) {
                            phaser -= 1;
                            const step = Math.pow(0.5, bits);
                            output[i] = step * Math.floor(input[i] / step + 0.5);
                        } else {
                            output[i] = output[i - 1] || 0;
                        }
                    }
                };
                
                // Warm filter
                const filter = this.ctx.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 3000;
                filter.Q.value = 1;
                
                // Subtle saturation
                const waveshaper = this.ctx.createWaveShaper();
                const curve = new Float32Array(256);
                for (let i = 0; i < 128; i++) {
                    const x = i / 128;
                    curve[128 + i] = Math.tanh(x * 2);
                    curve[128 - i - 1] = -Math.tanh(x * 2);
                }
                waveshaper.curve = curve;
                
                // Chain
                source.connect(bitcrusher);
                bitcrusher.connect(filter);
                filter.connect(waveshaper);
                
                return {processed: waveshaper, bitcrusher, filter, waveshaper};
            }
        }

        // Harmonic Analyzer
        class HarmonicAnalyzer {
            constructor(ctx) {
                this.ctx = ctx;
                this.analyzer = ctx.createAnalyser();
                this.analyzer.fftSize = 4096;
                this.freqData = new Float32Array(this.analyzer.frequencyBinCount);
                
                // Musical key detection
                this.noteFreqs = {
                    'C': [65.41, 130.81, 261.63, 523.25, 1046.50],
                    'C#': [69.30, 138.59, 277.18, 554.37, 1108.73],
                    'D': [73.42, 146.83, 293.66, 587.33, 1174.66],
                    'D#': [77.78, 155.56, 311.13, 622.25, 1244.51],
                    'E': [82.41, 164.81, 329.63, 659.25, 1318.51],
                    'F': [87.31, 174.61, 349.23, 698.46, 1396.91],
                    'F#': [92.50, 185.00, 369.99, 739.99, 1479.98],
                    'G': [98.00, 196.00, 392.00, 783.99, 1567.98],
                    'G#': [103.83, 207.65, 415.30, 830.61, 1661.22],
                    'A': [110.00, 220.00, 440.00, 880.00, 1760.00],
                    'A#': [116.54, 233.08, 466.16, 932.33, 1864.66],
                    'B': [123.47, 246.94, 493.88, 987.77, 1975.53]
                };
            }

            async analyze(buffer) {
                const analysisRate = 8; // Speed up analysis by 8x
                const source = this.ctx.createBufferSource();
                source.buffer = buffer;
                source.playbackRate.value = analysisRate;
                source.connect(this.analyzer);
                source.start();

                const peaks = [];
                const binCount = this.analyzer.frequencyBinCount;
                const freqBin = this.ctx.sampleRate / this.analyzer.fftSize / analysisRate; // Scale frequency bin

                const collect = () => {
                    this.analyzer.getFloatFrequencyData(this.freqData);
                    for (let i = 1; i < binCount - 1; i++) {
                        if (this.freqData[i] > this.freqData[i - 1] && this.freqData[i] > this.freqData[i + 1] && this.freqData[i] > -60) {
                            const freq = i * freqBin;
                            peaks.push({ freq, magnitude: this.freqData[i] });
                        }
                    }
                };

                const intervalMs = 100 / analysisRate;
                const intervalId = setInterval(collect, intervalMs); // Adjust interval for speed up

                await new Promise(resolve => {
                    source.onended = resolve;
                    setTimeout(resolve, buffer.duration * 1000 / analysisRate + 500); // Safety timeout adjusted for rate
                });

                clearInterval(intervalId);
                source.stop();
                source.disconnect();

                // Sort and take top peaks
                peaks.sort((a, b) => b.magnitude - a.magnitude);
                const topPeaks = peaks.slice(0, 50);

                // Find best key
                let bestKey = 'C';
                let bestScore = 0;
                for (const [key, freqs] of Object.entries(this.noteFreqs)) {
                    let score = 0;
                    for (const peak of topPeaks) {
                        for (let freq of freqs) {
                            for (let harm = 1; harm < 8; harm++) {
                                const target = freq * harm;
                                const diff = Math.abs(peak.freq - target) / target;
                                if (diff < 0.02) {
                                    score += peak.magnitude / harm;
                                }
                            }
                        }
                    }
                    if (score > bestScore) {
                        bestScore = score;
                        bestKey = key;
                    }
                }

                // Spectral centroid (using linear magnitude)
                const linearMag = mag => Math.pow(10, mag / 20);
                const sumFM = topPeaks.reduce((sum, p) => sum + p.freq * linearMag(p.magnitude), 0);
                const sumM = topPeaks.reduce((sum, p) => sum + linearMag(p.magnitude), 0);
                const centroid = sumFM / sumM || 0;

                const brightness = centroid / (this.ctx.sampleRate / 2); // Normalized 0-1

                return {
                    key: bestKey,
                    brightness,
                    harmonicDensity: topPeaks.length,
                    spectralCentroid: centroid
                };
            }
        }

        // Evolution Engine - handles musical transformation over time
        class EvolutionEngine {
            constructor() {
                this.generation = 0;
                this.memory = [];
                this.maxMemory = 16;
                this.traits = {
                    density: 0.5,      // How busy the rhythm is
                    harmony: 0.5,      // Harmonic complexity
                    energy: 0.5,       // Overall energy level
                    space: 0.5,        // Amount of reverb/delay
                    mutation: 0.1      // How quickly things change
                };
                this.scale = [0, 3, 5, 7, 10, 12, 15, 17, 19, 22, 24]; // Minor pentatonic intervals
            }

            evolve(analysis) {
                // Add to memory
                this.memory.push(analysis);
                if (this.memory.length > this.maxMemory) this.memory.shift();
                
                // Calculate trends
                if (this.memory.length > 2) {
                    const recent = this.memory.slice(-4);
                    const avgBrightness = recent.reduce((sum, a) => sum + a.brightness, 0) / recent.length;
                    const avgDensity = recent.reduce((sum, a) => sum + a.harmonicDensity, 0) / recent.length;
                    
                    // Evolve traits based on environment
                    this.traits.harmony = Math.max(0, Math.min(1, this.traits.harmony + (avgBrightness - 0.5) * 0.15)); // More change
                    this.traits.density = Math.max(0, Math.min(1, this.traits.density + (avgDensity - 20) * 0.015)); // More responsive
                    this.traits.energy = Math.max(0, Math.min(1, this.traits.energy * 0.9 + avgBrightness * 0.1)); // Faster adaptation
                    this.traits.space = Math.max(0, Math.min(1, this.traits.space + (1 - avgBrightness) * 0.1)); // More space if dark
                    
                    // Occasional mutations
                    if (Math.random() < this.traits.mutation * 1.5) { // More frequent mutations
                        const trait = ['density', 'harmony', 'energy', 'space'][Math.floor(Math.random() * 4)];
                        this.traits[trait] += (Math.random() - 0.5) * 0.4;
                        this.traits[trait] = Math.max(0, Math.min(1, this.traits[trait]));
                    }
                } else {
                    // Slow decay if no new inputs
                    this.traits.energy *= 0.99;
                    this.traits.density *= 0.99;
                }
                
                this.generation++;
                return this.traits;
            }

            getPattern() {
                // Generate evolving patterns based on traits
                const patterns = {
                    kick: [],
                    snare: [],
                    hats: [],
                    bass: []
                };
                
                // Kick pattern - sparser when density is low
                if (this.traits.density > 0.3) {
                    patterns.kick = [0, 10];
                    if (this.traits.density > 0.6) patterns.kick.push(20, 26);
                }
                
                // Snare - energy affects placement
                if (this.traits.energy > 0.4) {
                    patterns.snare = [8, 24];
                    if (this.traits.energy > 0.7) patterns.snare.push(14, 30);
                }
                
                // Hats - density directly affects
                const hatDensity = Math.floor(this.traits.density * 16);
                for (let i = 0; i < hatDensity; i++) {
                    const pos = Math.floor(Math.random() * 32);
                    if (!patterns.kick.includes(pos) && !patterns.snare.includes(pos)) {
                        patterns.hats.push(pos);
                    }
                }
                
                // Bass - evolved bass line based on harmony and density
                let currentIntervalIndex = 0;
                for (let i = 0; i < 32; i += 4) { // Downbeats
                    patterns.bass.push({pos: i, interval: this.scale[currentIntervalIndex % this.scale.length]});
                    if (Math.random() < this.traits.density) {
                        patterns.bass.push({pos: i + 2, interval: this.scale[(currentIntervalIndex + 1) % this.scale.length]});
                    }
                    if (Math.random() < this.traits.harmony * 0.5) {
                        patterns.bass.push({pos: i + 1, interval: this.scale[(currentIntervalIndex - 1 + this.scale.length) % this.scale.length]});
                    }
                    currentIntervalIndex += Math.floor(Math.random() * 3) - 1; // Random walk
                    if (currentIntervalIndex < 0) currentIntervalIndex = 0;
                }
                
                return patterns;
            }
        }

        // Main Engine
        class Engine {
            constructor() {
                this.ctx = null;
                this.nodes = {};
                this.samples = new Map();
                this.beatMatcher = new BeatMatcher();
                this.recording = false;
                this.buffer = [];
                this.seq = { step: 0, swing: 0.15 };
                this.orb = document.getElementById('orb');
                
                // Evolution
                this.evolution = new EvolutionEngine();
                this.harmonicAnalyzer = null;
                this.currentPattern = null;
                this.currentSample = null;
                this.currentSampleChain = null;
                
                // Kanye-style pitch shifts
                this.pitchShifts = [0.5, 0.667, 0.75, 1, 1.5, 2];
                
                // Environmental memory
                this.sampleHistory = [];
                this.maxHistory = 8;
                
                // Note frequencies for bass root
                this.noteFreqs = {
                    'C': [65.41, 130.81, 261.63, 523.25, 1046.50],
                    'C#': [69.30, 138.59, 277.18, 554.37, 1108.73],
                    'D': [73.42, 146.83, 293.66, 587.33, 1174.66],
                    'D#': [77.78, 155.56, 311.13, 622.25, 1244.51],
                    'E': [82.41, 164.81, 329.63, 659.25, 1318.51],
                    'F': [87.31, 174.61, 349.23, 698.46, 1396.91],
                    'F#': [92.50, 185.00, 369.99, 739.99, 1479.98],
                    'G': [98.00, 196.00, 392.00, 783.99, 1567.98],
                    'G#': [103.83, 207.65, 415.30, 830.61, 1661.22],
                    'A': [110.00, 220.00, 440.00, 880.00, 1760.00],
                    'A#': [116.54, 233.08, 466.16, 932.33, 1864.66],
                    'B': [123.47, 246.94, 493.88, 987.77, 1975.53]
                };
                
                document.addEventListener('click', () => this.start());
                document.addEventListener('touchstart', () => this.start()); // For mobile
            }

            async start() {
                if (this.ctx) return this.toggle();
                
                try {
                    this.ctx = new AudioContext({ sampleRate: 44100 });
                    if (this.ctx.state === 'suspended') await this.ctx.resume();
                    this.lofi = new LoFi(this.ctx);
                    this.harmonicAnalyzer = new HarmonicAnalyzer(this.ctx);
                    
                    // Master chain - lo-fi trip hop style
                    this.nodes.out = this.ctx.createGain();
                    this.nodes.out.gain.value = 0.8;
                    
                    // Vinyl simulation
                    this.nodes.vinyl = this.ctx.createBiquadFilter();
                    this.nodes.vinyl.type = 'highpass';
                    this.nodes.vinyl.frequency.value = 30;
                    
                    // Tape warmth
                    this.nodes.warmth = this.ctx.createBiquadFilter();
                    this.nodes.warmth.type = 'lowshelf';
                    this.nodes.warmth.frequency.value = 200;
                    this.nodes.warmth.gain.value = 2;
                    
                    // Gentle compression
                    this.nodes.comp = this.ctx.createDynamicsCompressor();
                    this.nodes.comp.threshold.value = -20;
                    this.nodes.comp.knee.value = 10;
                    this.nodes.comp.ratio.value = 3;
                    this.nodes.comp.attack.value = 0.01;
                    this.nodes.comp.release.value = 0.25;
                    
                    // Master filter for that dusty sound
                    this.nodes.dust = this.ctx.createBiquadFilter();
                    this.nodes.dust.type = 'lowpass';
                    this.nodes.dust.frequency.value = 8000;
                    this.nodes.dust.Q.value = 0.7;
                    
                    // Adaptive reverb
                    this.nodes.reverb = this.ctx.createConvolver();
                    this.createReverb();
                    this.nodes.reverbSend = this.ctx.createGain();
                    this.nodes.reverbSend.gain.value = 0.2;
                    this.nodes.reverbReturn = this.ctx.createGain();
                    this.nodes.reverbReturn.gain.value = 0.3;
                    
                    // Delay for space
                    this.nodes.delay = this.ctx.createDelay(1);
                    this.nodes.delay.delayTime.value = 60 / this.beatMatcher.bpm * 0.75; // Dotted eighth
                    this.nodes.delayFeedback = this.ctx.createGain();
                    this.nodes.delayFeedback.gain.value = 0.4;
                    this.nodes.delaySend = this.ctx.createGain();
                    this.nodes.delaySend.gain.value = 0.15;
                    
                    // Connect master chain
                    this.nodes.out.connect(this.nodes.vinyl);
                    this.nodes.vinyl.connect(this.nodes.warmth);
                    this.nodes.warmth.connect(this.nodes.comp);
                    this.nodes.comp.connect(this.nodes.dust);
                    this.nodes.dust.connect(this.ctx.destination);
                    
                    // Effects sends
                    this.nodes.out.connect(this.nodes.reverbSend);
                    this.nodes.reverbSend.connect(this.nodes.reverb);
                    this.nodes.reverb.connect(this.nodes.reverbReturn);
                    this.nodes.reverbReturn.connect(this.nodes.dust);
                    
                    this.nodes.out.connect(this.nodes.delaySend);
                    this.nodes.delaySend.connect(this.nodes.delay);
                    this.nodes.delay.connect(this.nodes.delayFeedback);
                    this.nodes.delayFeedback.connect(this.nodes.delay);
                    this.nodes.delay.connect(this.nodes.dust);
                    
                    // Create layers with trip hop levels
                    const layers = {
                        kick: 0.9,
                        snare: 0.7,
                        hats: 0.3,
                        sample: 0.8,
                        bass: 0.85,
                        vinyl: 0.15,
                        texture: 0.4
                    };
                    
                    Object.entries(layers).forEach(([name, vol]) => {
                        this.nodes[name] = this.ctx.createGain();
                        this.nodes[name].gain.value = vol;
                        this.nodes[name].connect(this.nodes.out);
                        this.samples.set(name, []);
                    });
                    
                    // Create lo-fi drums
                    await this.createDrums();
                    
                    // Add vinyl noise
                    this.createVinyl();
                    
                    // Mic setup
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: false,
                            noiseSuppression: false,
                            autoGainControl: false
                        }
                    });
                    
                    this.nodes.mic = this.ctx.createMediaStreamSource(stream);
                    this.nodes.rec = this.ctx.createScriptProcessor(4096, 1, 1);
                    
                    this.nodes.rec.onaudioprocess = e => {
                        if (this.recording) {
                            this.buffer.push(...e.inputBuffer.getChannelData(0));
                            // Longer samples for that Kanye feel (up to 8 seconds)
                            if (this.buffer.length > this.ctx.sampleRate * 8) this.stopRec();
                        }
                    };
                    
                    // Start
                    this.loop();
                    this.seq.last = this.ctx.currentTime;
                    requestAnimationFrame(() => this.tick());
                    
                    // Keys
                    document.onkeydown = e => {
                        if (e.key === ' ') this.toggle();
                    };
                    
                } catch (e) {
                    console.error(e);
                }
            }

            toggle() {
                if (this.recording) {
                    this.stopRec();
                } else {
                    this.recording = true;
                    this.buffer = [];
                    this.nodes.mic.connect(this.nodes.rec);
                    this.nodes.rec.connect(this.ctx.destination);
                    this.orb.classList.add('recording');
                }
            }

            stopRec() {
                this.recording = false;
                this.nodes.mic.disconnect(this.nodes.rec);
                this.nodes.rec.disconnect();
                this.orb.classList.remove('recording');
                
                if (this.buffer.length > this.ctx.sampleRate * 0.5) { // Min 0.5 seconds
                    const buf = this.ctx.createBuffer(1, this.buffer.length, this.ctx.sampleRate);
                    buf.getChannelData(0).set(this.buffer);
                    this.processSample(buf);
                }
            }

            async processSample(buf) {
                const analysis = await this.harmonicAnalyzer.analyze(buf);
                
                // Evolve based on analysis
                const traits = this.evolution.evolve(analysis);
                this.updateEffects(traits);
                
                // Find peaks and match to beat
                const peaks = this.beatMatcher.findPeaks(buf, this.ctx.sampleRate);
                const stretch = this.beatMatcher.matchToGrid(peaks);
                
                // Pitch selection based on harmonic analysis
                let pitchIndex = Math.floor(analysis.brightness * (this.pitchShifts.length - 1));
                pitchIndex = Math.max(0, Math.min(this.pitchShifts.length - 1, pitchIndex));
                const pitch = this.pitchShifts[pitchIndex];
                
                // Create chops
                const chops = this.beatMatcher.chopSample(buf, peaks);
                
                const sample = {
                    buffer: buf,
                    rate: stretch * pitch,
                    chops,
                    pitch,
                    analysis,
                    generation: this.evolution.generation
                };
                
                // Add to history
                this.sampleHistory.push(sample);
                if (this.sampleHistory.length > this.maxHistory) this.sampleHistory.shift();
                
                // Distribute samples based on characteristics
                if (analysis.harmonicDensity > 30) {
                    // Dense samples become main loops
                    const samples = this.samples.get('sample');
                    if (samples.length >= 2) samples.shift();
                    samples.push(sample);
                } else {
                    // Sparse samples become textures
                    const textures = this.samples.get('texture');
                    if (textures.length >= 4) textures.shift();
                    textures.push(sample);
                }
                
                console.log(`Gen ${this.evolution.generation}: ${analysis.key} ${pitch}x, HD:${analysis.harmonicDensity}`);
            }

            updateEffects(traits) {
                // Update reverb based on space trait
                this.nodes.reverbReturn.gain.linearRampToValueAtTime(
                    0.1 + traits.space * 0.4, 
                    this.ctx.currentTime + 1
                );
                
                // Update delay based on density
                this.nodes.delayFeedback.gain.linearRampToValueAtTime(
                    0.2 + (1 - traits.density) * 0.4,
                    this.ctx.currentTime + 1
                );
                
                // Update filter based on energy
                this.nodes.dust.frequency.linearRampToValueAtTime(
                    4000 + traits.energy * 8000,
                    this.ctx.currentTime + 2
                );
                
                // Evolve BPM based on energy
                this.beatMatcher.bpm = 60 + 30 * traits.energy;
                this.nodes.delay.delayTime.value = 60 / this.beatMatcher.bpm * 0.75;
                
                // Update patterns
                this.currentPattern = this.evolution.getPattern();
            }

            async createDrums() {
                const sr = this.ctx.sampleRate;
                
                // Multiple kick variations
                for (let variant = 0; variant < 3; variant++) {
                    const kick = this.ctx.createBuffer(1, sr * 0.3, sr);
                    const kd = kick.getChannelData(0);
                    const pitch = 60 - variant * 10;
                    
                    for (let i = 0; i < kd.length; i++) {
                        const t = i / sr;
                        const env = Math.exp(-10 * t);
                        const pitchEnv = pitch * Math.exp(-50 * t);
                        let s = Math.sin(2 * Math.PI * pitchEnv * t) * env;
                        // Bit reduction
                        s = Math.round(s * (8 - variant)) / (8 - variant);
                        kd[i] = s * 0.9;
                    }
                    this.samples.get('kick').push({ buffer: kick, rate: 1 });
                }
                
                // Multiple snare variations
                for (let variant = 0; variant < 2; variant++) {
                    const snare = this.ctx.createBuffer(1, sr * 0.15, sr);
                    const sd = snare.getChannelData(0);
                    const tonePitch = 200 + variant * 50;
                    
                    for (let i = 0; i < sd.length; i++) {
                        const t = i / sr;
                        const env = Math.exp(-30 * t);
                        const tone = Math.sin(2 * Math.PI * tonePitch * t) * (0.3 - variant * 0.1);
                        const noise = (Math.random() * 2 - 1) * (0.6 + variant * 0.2);
                        let s = (tone + noise) * env;
                        // Bit reduction
                        s = Math.round(s * 6) / 6;
                        sd[i] = s * 0.8;
                    }
                    this.samples.get('snare').push({ buffer: snare, rate: 1 });
                }
                
                // Multiple hat variations
                for (let variant = 0; variant < 4; variant++) {
                    const hat = this.ctx.createBuffer(1, sr * (0.05 + variant * 0.02), sr);
                    const hd = hat.getChannelData(0);
                    
                    for (let i = 0; i < hd.length; i++) {
                        const t = i / sr;
                        const env = Math.exp(-(100 - variant * 20) * t);
                        let s = (Math.random() * 2 - 1) * env;
                        // Heavy filtering
                        if (i > 0) s = s * (0.3 + variant * 0.1) + hd[i-1] * (0.7 - variant * 0.1);
                        hd[i] = s * 0.5;
                    }
                    this.samples.get('hats').push({ buffer: hat, rate: 1 });
                }
                
                // Bass with single base buffer
                const baseFreq = 55; // A1
                const bass = this.ctx.createBuffer(1, sr * 1, sr);
                const bd = bass.getChannelData(0);
                
                for (let i = 0; i < bd.length; i++) {
                    const t = i / sr;
                    const env = t < 0.02 ? t / 0.02 : Math.exp(-2 * (t - 0.02));
                    bd[i] = Math.sin(2 * Math.PI * baseFreq * t) * env * 0.8;
                }
                this.samples.get('bass').push({ buffer: bass, freq: baseFreq });
            }

            createVinyl() {
                // Continuous vinyl crackle
                const duration = 10;
                const vinyl = this.ctx.createBuffer(1, this.ctx.sampleRate * duration, this.ctx.sampleRate);
                const data = vinyl.getChannelData(0);
                
                for (let i = 0; i < data.length; i++) {
                    // Crackle
                    if (Math.random() < 0.0001) {
                        data[i] = (Math.random() - 0.5) * 0.3;
                    } else {
                        // Surface noise
                        data[i] = (Math.random() - 0.5) * 0.02;
                    }
                    
                    // Low rumble
                    data[i] += Math.sin(2 * Math.PI * 0.5 * i / this.ctx.sampleRate) * 0.01;
                }
                
                // Loop the vinyl noise
                const playVinyl = () => {
                    const source = this.ctx.createBufferSource();
                    source.buffer = vinyl;
                    source.loop = true;
                    source.connect(this.nodes.vinyl);
                    source.start();
                };
                
                playVinyl();
            }

            createReverb() {
                // Create impulse response for reverb
                const length = this.ctx.sampleRate * 2;
                const impulse = this.ctx.createBuffer(2, length, this.ctx.sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const data = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        data[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 2);
                    }
                }
                
                this.nodes.reverb.buffer = impulse;
            }

            getRootFreq() {
                if (this.sampleHistory.length > 0) {
                    const lastKey = this.sampleHistory[this.sampleHistory.length - 1].analysis.key;
                    return this.noteFreqs[lastKey][0] / 2; // Lower octave for bass
                }
                return 55; // Default A
            }

            tick() {
                if (!this.ctx) return;
                
                const now = this.ctx.currentTime;
                const beat = 60 / this.beatMatcher.bpm / 4;
                
                // Evolving swing based on generation
                const swingAmount = this.seq.swing + (this.evolution.generation * 0.01);
                let swing = this.seq.step % 2 === 1 ? beat * (1 + swingAmount) : beat * (1 - swingAmount);
                
                if (now >= this.seq.last + swing) {
                    this.seq.last = now;
                    
                    // Pulse
                    if (this.seq.step % 4 === 0) {
                        this.orb.classList.add('pulse');
                        setTimeout(() => this.orb.classList.remove('pulse'), 300);
                    }
                    
                    // Use evolved patterns or default
                    const pattern = this.currentPattern || {
                        kick: [0, 10],
                        snare: [8, 24],
                        hats: [2, 6, 10, 12, 14, 18, 22, 26, 30],
                        bass: [{pos: 0, interval: 0}, {pos: 8, interval: 0}, {pos: 16, interval: 0}, {pos: 24, interval: 0}]
                    };
                    
                    // Dynamic velocity based on evolution
                    const energy = this.evolution.traits.energy;
                    
                    if (pattern.kick.includes(this.seq.step)) {
                        this.play('kick', 0.7 + energy * 0.3);
                    }
                    
                    if (pattern.snare.includes(this.seq.step)) {
                        this.play('snare', 0.5 + energy * 0.4);
                    }
                    
                    if (pattern.hats.includes(this.seq.step)) {
                        this.play('hats', 0.2 + Math.random() * 0.2 * energy);
                    }
                    
                    const bassNote = pattern.bass.find(p => p.pos === this.seq.step);
                    if (bassNote) {
                        this.playBass(0.6 + energy * 0.3, bassNote.interval);
                    }
                    
                    // Main sample - plays continuously when available
                    const samples = this.samples.get('sample');
                    if (samples.length > 0 && this.seq.step % 16 === 0) {
                        // Play most recent sample
                        this.playSample(samples[samples.length - 1]);
                    }
                    
                    // Texture layers - sparse placement
                    const textures = this.samples.get('texture');
                    if (textures.length > 0 && Math.random() < 0.1 * this.evolution.traits.density) {
                        this.playTexture(textures[Math.floor(Math.random() * textures.length)]);
                    }
                    
                    // Occasionally play older samples as ghosts
                    if (this.sampleHistory.length > 4 && Math.random() < 0.05) {
                        const ghost = this.sampleHistory[Math.floor(Math.random() * (this.sampleHistory.length - 2))];
                        this.playGhost(ghost);
                    }
                    
                    // Evolve even without new sample every 32 steps
                    if (this.seq.step === 0) {
                        this.evolution.evolve(this.memory.length > 0 ? this.memory[this.memory.length - 1] : {brightness: 0.5, harmonicDensity: 20});
                    }
                    
                    this.seq.step = (this.seq.step + 1) % 32;
                }
                
                requestAnimationFrame(() => this.tick());
            }

            play(type, vel) {
                const samples = this.samples.get(type);
                if (!samples.length) return;
                
                // Select variation based on evolution
                const index = Math.floor(Math.random() * samples.length);
                const sample = samples[index];
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate || 1;
                
                // Slight pitch variations for organic feel
                if (type === 'hats') {
                    src.playbackRate.value *= 0.95 + Math.random() * 0.1;
                }
                
                gain.gain.value = vel;
                
                // Lo-fi processing
                const {processed, bitcrusher, filter, waveshaper} = this.lofi.process(src);
                processed.connect(gain);
                gain.connect(this.nodes[type]);
                
                src.onended = () => {
                    bitcrusher.onaudioprocess = null;
                    bitcrusher.disconnect();
                    filter.disconnect();
                    waveshaper.disconnect();
                    gain.disconnect();
                    src.disconnect();
                };
                
                src.start();
            }

            playBass(vel, interval) {
                const samples = this.samples.get('bass');
                if (!samples.length) return;
                
                const sample = samples[0];
                const rootFreq = this.getRootFreq();
                const targetFreq = rootFreq * Math.pow(2, interval / 12);
                const rate = targetFreq / sample.freq;
                
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = rate;
                gain.gain.value = vel;
                
                // Lo-fi processing
                const {processed, bitcrusher, filter, waveshaper} = this.lofi.process(src);
                processed.connect(gain);
                gain.connect(this.nodes.bass);
                
                src.onended = () => {
                    bitcrusher.onaudioprocess = null;
                    bitcrusher.disconnect();
                    filter.disconnect();
                    waveshaper.disconnect();
                    gain.disconnect();
                    src.disconnect();
                };
                
                src.start();
            }

            playSample(sample) {
                // Stop previous main sample
                if (this.currentSample) {
                    this.currentSample.stop();
                    // onended will handle disconnect
                }
                
                // Play the full sample loop Kanye-style
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate;
                src.loop = true;
                src.loopStart = 0;
                src.loopEnd = Math.min(sample.buffer.duration, 60 / this.beatMatcher.bpm * 4); // 4 bar loop
                
                // Filter based on sample characteristics
                filter.type = 'lowpass';
                filter.frequency.value = 2000 + sample.analysis.brightness * 3000;
                filter.Q.value = 2 + sample.analysis.harmonicDensity * 0.1;
                
                // Filter automation based on generation
                const sweepTime = 8 + (sample.generation % 4) * 2;
                filter.frequency.setValueAtTime(filter.frequency.value, this.ctx.currentTime);
                filter.frequency.linearRampToValueAtTime(
                    filter.frequency.value * 1.5, 
                    this.ctx.currentTime + sweepTime / 2
                );
                filter.frequency.linearRampToValueAtTime(
                    filter.frequency.value, 
                    this.ctx.currentTime + sweepTime
                );
                
                gain.gain.value = 0.7;
                
                // Lo-fi processing
                const {processed, bitcrusher, lofiFilter, waveshaper} = this.lofi.process(src);
                processed.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.sample);
                
                // Clean up on end or stop
                src.onended = () => {
                    bitcrusher.onaudioprocess = null;
                    bitcrusher.disconnect();
                    lofiFilter.disconnect();
                    waveshaper.disconnect();
                    filter.disconnect();
                    gain.disconnect();
                    src.disconnect();
                };
                
                // Sidechain compression effect
                const sidechain = () => {
                    // Duck on kicks
                    if (this.seq.step === 0 || this.seq.step === 10) {
                        gain.gain.cancelScheduledValues(this.ctx.currentTime);
                        gain.gain.setValueAtTime(0.3, this.ctx.currentTime);
                        gain.gain.linearRampToValueAtTime(0.7, this.ctx.currentTime + 0.1);
                    }
                    
                    setTimeout(sidechain, 60000 / this.beatMatcher.bpm / 4);
                };
                
                src.start();
                sidechain();
                
                this.currentSample = src;
            }

            playTexture(sample) {
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const panner = this.ctx.createStereoPanner();
                
                src.buffer = sample.buffer;
                
                // Varied playback rates for texture
                let rate = sample.rate * (0.5 + Math.random());
                src.playbackRate.value = rate;
                
                // Random detune
                src.detune.value = (Math.random() - 0.5) * 200;
                
                // Random reverse
                const isReverse = Math.random() < 0.2 * this.evolution.traits.mutation;
                const dur = 1 + Math.random() * 1.5;
                let startPos = Math.random() * (sample.buffer.duration - dur);
                
                // Random panning
                panner.pan.value = -0.8 + Math.random() * 1.6;
                
                // Fade in/out
                gain.gain.setValueAtTime(0, this.ctx.currentTime);
                gain.gain.linearRampToValueAtTime(0.3, this.ctx.currentTime + 0.5);
                gain.gain.linearRampToValueAtTime(0, this.ctx.currentTime + dur);
                
                // Connect without lofi for textures to save resources
                src.connect(panner);
                panner.connect(gain);
                gain.connect(this.nodes.texture);
                
                src.onended = () => {
                    panner.disconnect();
                    gain.disconnect();
                    src.disconnect();
                };
                
                if (isReverse) {
                    src.playbackRate.value *= -1;
                    src.start(0, startPos + dur, dur);
                } else {
                    src.start(0, startPos, dur);
                }
            }

            playGhost(sample) {
                // Play old samples as atmospheric ghosts
                const src = this.ctx.createBufferSource();
                const gain = this.ctx.createGain();
                const filter = this.ctx.createBiquadFilter();
                
                src.buffer = sample.buffer;
                src.playbackRate.value = sample.rate * 0.5; // Always pitched down
                
                // Heavy filtering for ghostly effect
                filter.type = 'bandpass';
                filter.frequency.value = 400 + Math.random() * 600;
                filter.Q.value = 5;
                
                // Very quiet
                gain.gain.value = 0.1;
                
                // Extra reverb send
                const reverbSend = this.ctx.createGain();
                reverbSend.gain.value = 0.8;
                
                // Connect without lofi
                src.connect(filter);
                filter.connect(gain);
                gain.connect(this.nodes.out);
                gain.connect(reverbSend);
                reverbSend.connect(this.nodes.reverb);
                
                src.onended = () => {
                    filter.disconnect();
                    gain.disconnect();
                    reverbSend.disconnect();
                    src.disconnect();
                };
                
                // Play a random section
                const startTime = Math.random() * Math.max(0, sample.buffer.duration - 1);
                src.start(0, startTime, 1);
            }

            loop() {
                // Auto-sample interesting sounds
                const analyser = this.ctx.createAnalyser();
                this.nodes.mic.connect(analyser);
                analyser.fftSize = 2048;
                
                const data = new Uint8Array(analyser.frequencyBinCount);
                let cooldown = 0;
                
                setInterval(() => {
                    if (this.recording || cooldown > 0) {
                        cooldown--;
                        return;
                    }
                    
                    analyser.getByteFrequencyData(data);
                    
                    // Look for interesting harmonic content
                    let harmonics = 0;
                    let lowEnergy = 0;
                    let midEnergy = 0;
                    let highEnergy = 0;
                    
                    // Analyze frequency bands
                    for (let i = 0; i < data.length; i++) {
                        const freq = i * this.ctx.sampleRate / analyser.fftSize;
                        if (freq < 200 && data[i] > 100) lowEnergy += data[i];
                        else if (freq < 2000 && data[i] > 80) midEnergy += data[i];
                        else if (freq < 8000 && data[i] > 60) highEnergy += data[i];
                        
                        if (data[i] > 100) harmonics++;
                    }
                    
                    // Auto-record based on evolution preferences
                    const threshold = 20 - (this.evolution.traits.density * 10);
                    const energyBalance = midEnergy / (lowEnergy + 1); // Prefer tonal content
                    
                    if (harmonics > threshold && energyBalance > 0.5) {
                        this.toggle();
                        cooldown = 200; // 4 second cooldown
                    }
                }, 20);
            }
        }

        new Engine();
    </script>
</body>
</html>
