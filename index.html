<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>GUMP - No Labels Club</title>
  <style>
    html,body { height: 100%; margin: 0; padding: 0;}
    body { font-family: -apple-system,BlinkMacSystemFont,sans-serif; background: radial-gradient(circle at 40% 60%, #0a0a0a 0%, #1a1a2e 40%, #16213e 100%);
      overflow: hidden; min-height: 100vh; width: 100vw; display: flex; align-items: center; justify-content: center; transition: background 2s cubic-bezier(.6,0,.6,1);}
    body.heaven { background: radial-gradient(circle at 60% 40%, #180042 0%, #381466 50%, #ffe4fa 100%);}
    body.drop { background: radial-gradient(circle at 55% 45%, #ff2e81 0%, #34036d 70%, #191432 100%);}
    .app { width: 100vw; height: 100vh; display: flex; align-items: center; justify-content: center; }
    .viz { width: 380px; height: 380px; border-radius: 30px; background: rgba(0,255,170,0.035); margin: 0; position: relative; border: 3px solid #00ffaa33;
      box-shadow: 0 0 0 0 #00ffaa22, 0 0 60px 0 #ff6b6b0f; transition: border .8s, box-shadow 2s;}
    .viz.heaven { border-color: #ff88cc80; box-shadow: 0 0 60px #ff88cc33, 0 0 120px #ffeee311; }
    .viz.drop { border-color: #ff2e81ee; box-shadow: 0 0 20px 8px #ff2e8155, 0 0 80px 0 #b3a3fa33;}
    .orb { position: absolute; width: 120px; height: 120px; border-radius: 50%; background: radial-gradient(circle, #00ffaa 0%, transparent 85%);
      top: 50%; left: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 30px #00ffaa55; transition: all .23s;}
    .orb.heaven { background: radial-gradient(circle, #ff88cc 0%, #ffeee3 50%, transparent 100%);
      box-shadow: 0 0 90px #ff88cc99, 0 0 120px #ffeee355;}
    .orb.drop { background: radial-gradient(circle, #ff2e81 10%, #ffe7f7 70%, transparent 100%);
      box-shadow: 0 0 80px #ff2e81cc, 0 0 120px #ffe7f755;}
    .pulse { animation: pulse 0.7s cubic-bezier(.7,0,.3,1) alternate infinite;}
    @keyframes pulse { from { transform: translate(-50%, -50%) scale(1);} to { transform: translate(-50%, -50%) scale(1.13);} }
    .start-btn { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); font-size:1.2rem; padding: 20px 50px; border-radius:30px;
      background: linear-gradient(45deg,#00ffaa,#4ecdc4); color:#000; border:none; font-weight:700; cursor:pointer; z-index:10; box-shadow: 0 4px 22px #00ffaa22;}
    .hidden { display:none!important;}
    .error { position: absolute; top: 20%; left: 50%; transform: translateX(-50%); background: #220 1px solid #c33; border-radius: 15px; padding: 18px; color: #ff6b6b; }
  </style>
</head>
<body>
  <div class="app">
    <div class="viz" id="viz"><div class="orb" id="orb"></div></div>
    <button class="start-btn" id="start">Start</button>
    <div class="error hidden" id="error"></div>
  </div>
  <script>
    // --------- GOD GRID MUSIC: NO LABELS ---------
    class GUMP {
      constructor() {
        this.ctx = null;
        this.motion = 0;
        this.motionWindow = [];
        this.windowSize = 6;
        this.last = { x: 0, y: 0, z: 0 };
        this.lastMotionTime = Date.now();
        this.pos = { x: 50, y: 50 };
        this.active = false;
        this.state = 'heaven'; // heaven, build, drop
        this.tickCount = 0;
        this.chordStep = 0;
        // Music
        this.scale = [261.63, 293.66, 329.63, 392, 440, 523.25]; // C D E G A C5
        this.progression = [[0,2,4],[1,3,5],[0,3,4],[2,4,5]]; // Chord degrees
        this.currentChord = 0;
        // Drums
        this.kickPat = [1,0,0,0,1,0,1,0];
        this.snarePat = [0,0,1,0,0,0,1,0];
        this.hatPat = [1,1,1,1,1,1,1,1];
        // Momentum/Build tracking
        this.momentum = 0;
        this.momentumWindow = [];
        this.dropActive = false;
        this.dropBars = 0;
        this.reverb = null;
        this.init();
      }

      init() {
        document.getElementById('start').onclick = () => this.start();
      }

      createReverb() {
        this.reverb = this.ctx.createConvolver();
        const b = this.ctx.createBuffer(2, this.ctx.sampleRate * 2, this.ctx.sampleRate);
        for (let c = 0; c < 2; c++) {
          let d = b.getChannelData(c);
          for (let i = 0; i < d.length; i++) d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i/d.length, 2.5);
        }
        this.reverb.buffer = b;
        this.reverb.connect(this.ctx.destination);
      }

      async start() {
        try {
          if (typeof DeviceMotionEvent?.requestPermission === 'function') {
            const perm = await DeviceMotionEvent.requestPermission();
            if (perm !== 'granted') throw new Error('Permission denied');
          }
          this.ctx = new (window.AudioContext || window.webkitAudioContext)();
          await this.ctx.resume();
          this.createReverb();
          document.getElementById('start').classList.add('hidden');
          this.active = true;
          this.startSensors();
          this.godGridLoop();
          this.animate();
        } catch (e) {
          this.showError('Motion sensors unavailable. Please use a mobile device.');
        }
      }

      startSensors() {
        window.addEventListener('devicemotion', e => {
          if (!this.active) return;
          const acc = e.accelerationIncludingGravity;
          if (!acc || acc.x === null) return;
          const dx = acc.x - this.last.x, dy = acc.y - this.last.y, dz = acc.z - this.last.z;
          let power = Math.sqrt(dx*dx + dy*dy + dz*dz);
          this.last = { x: acc.x, y: acc.y, z: acc.z };
          this.motionWindow.push(power); if (this.motionWindow.length > this.windowSize) this.motionWindow.shift();
          this.motion = this.motionWindow.reduce((a,b)=>a+b,0)/this.motionWindow.length;
          if (this.motion > 0.8) this.lastMotionTime = Date.now();
          this.pos.x = Math.max(10, Math.min(90, 50 + acc.x*7));
          this.pos.y = Math.max(10, Math.min(90, 50 + acc.y*7));
        });
      }

      animate() {
        const update = () => {
          if (!this.active) return;
          // ORB visual: orientation, color by state
          let orb = document.getElementById('orb');
          let viz = document.getElementById('viz');
          orb.style.left = this.pos.x + '%';
          orb.style.top = this.pos.y + '%';
          // Visual state by music section
          orb.className = 'orb' + (this.state === 'heaven' ? ' heaven' : this.state === 'drop' ? ' drop pulse' : this.state === 'build' ? ' pulse' : '');
          viz.className = 'viz' + (this.state === 'heaven' ? ' heaven' : this.state === 'drop' ? ' drop' : '');
          document.body.className = (this.state === 'heaven' ? 'heaven' : this.state === 'drop' ? 'drop' : '');
          requestAnimationFrame(update);
        };
        update();
      }

      godGridLoop() {
        setInterval(() => {
          if (!this.active) return;
          // Momentum tracking: sum of motion over last 16 bars (32 ticks = 8 bars)
          if (!this.momentumWindow) this.momentumWindow = [];
          this.momentumWindow.push(this.motion);
          if (this.momentumWindow.length > 32) this.momentumWindow.shift();
          this.momentum = this.momentumWindow.reduce((a,b)=>a+b,0)/this.momentumWindow.length;
          // State logic: heaven, build, drop
          const now = Date.now();
          const moving = (now - this.lastMotionTime < 1200);
          if (!moving) {
            this.state = 'heaven'; this.dropActive = false; this.dropBars = 0;
            this.heavenEngine();
          } else if (this.state === 'drop') {
            this.dropEngine();
            this.dropBars++;
            if (this.dropBars >= 32) { this.state = 'build'; this.dropActive = false; } // fade drop after 8 bars
          } else if (this.momentum > 1.2 && !this.dropActive) {
            this.state = 'build';
            this.dropBars++;
            if (this.dropBars >= 32) { this.state = 'drop'; this.dropActive = true; this.dropBars = 0; }
            else this.buildEngine();
          } else {
            this.state = 'build'; this.dropBars = 0;
            this.buildEngine();
          }
          this.tickCount = (this.tickCount+1) % (8*16);
          if (this.tickCount % (16*8) === 0) {
            this.currentChord = (this.currentChord+1)%this.progression.length;
          }
        }, 250);
      }

      heavenEngine() {
        // Radiohead/Weeknd halftime mode, floaty, pads, bells, no heavy hats
        let posInBar = this.tickCount % 16;
        let chord = this.progression[this.currentChord];
        if (posInBar===0) this.voidKick();
        if (posInBar===8) this.voidKick(0.37);
        if (posInBar===7 || posInBar===15) this.voidSnare();
        if (posInBar===0||posInBar===8) this.voidBass(chord[0]);
        if (posInBar===0 || posInBar===8) this.voidPad(chord);
        if ((posInBar===5 || posInBar===13) && Math.random()<0.45) this.heavenSynth(chord);
      }
      buildEngine() {
        // Subtle groove, filtered hats/pads, more anticipation, rising synth
        let posInBar = this.tickCount % 16;
        let chord = this.progression[this.currentChord];
        if (this.kickPat[posInBar%8] && this.tickCount % 2 === 0) this.kick();
        if (this.snarePat[posInBar%8] && this.tickCount % 4 === 0) this.snare();
        if (this.hatPat[posInBar%8] && this.tickCount % 2 === 0 && posInBar<12) this.buildHat();
        if (posInBar===0||posInBar===8) this.bass(chord[0]);
        if (posInBar===0 && this.tickCount%16===0) this.buildPad(chord);
        if (posInBar===12 && Math.random()>0.6) this.riser(chord);
      }
      dropEngine() {
        // Club drop, open hats, sidechain bass, huge synth
        let posInBar = this.tickCount % 16;
        let chord = this.progression[this.currentChord];
        if (posInBar===0 || posInBar===8) this.dropKick();
        if (posInBar===4 || posInBar===12) this.dropSnare();
        if (this.hatPat[posInBar%8]) this.dropHat();
        if (posInBar%4===0) this.clubBass(chord[0]);
        if (posInBar%8===0) this.dropPad(chord);
        if (posInBar===6 && Math.random()>0.8) this.stab(chord);
      }
      // ---- Instrument voices ----
      kick() {
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(82,this.ctx.currentTime);
        o.frequency.exponentialRampToValueAtTime(31,this.ctx.currentTime+0.13);
        g.gain.setValueAtTime(0.8,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.21);
        o.connect(g).connect(this.reverb); o.start(); o.stop(this.ctx.currentTime+0.22);
      }
      snare() {
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.13,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.17,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.12);
        n.connect(g).connect(this.reverb); n.start(); n.stop(this.ctx.currentTime+0.13);
      }
      buildHat() {
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.04,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=5400;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.07,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.08);
        n.connect(f).connect(g).connect(this.reverb); n.start(); n.stop(this.ctx.currentTime+0.08);
      }
      bass(degree) {
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='triangle'; o.frequency.value = this.scale[degree]*0.5;
        g.gain.setValueAtTime(0.13,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.27);
        o.connect(g).connect(this.reverb); o.start(); o.stop(this.ctx.currentTime+0.29);
      }
      buildPad(chord) {
        let now = this.ctx.currentTime;
        chord.forEach((deg,i)=>{
          let freq=this.scale[deg];
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='triangle'; o.frequency.value=freq;
          g.gain.setValueAtTime(0.08, now);
          g.gain.linearRampToValueAtTime(0.09, now+0.8+0.11*i);
          g.gain.linearRampToValueAtTime(0.001, now+2.0+0.12*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.04*i); o.stop(now+2.1+0.1*i);
        });
      }
      riser(chord) {
        let now = this.ctx.currentTime;
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type = 'sawtooth'; o.frequency.setValueAtTime(this.scale[chord[1]], now);
        o.frequency.linearRampToValueAtTime(this.scale[chord[1]]*2, now+1.2);
        g.gain.setValueAtTime(0.02,now);
        g.gain.linearRampToValueAtTime(0.13,now+1.13);
        g.gain.linearRampToValueAtTime(0.001,now+1.33);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+1.33);
      }
      // --- Club DROP engine
      dropKick() {
        let now = this.ctx.currentTime;
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(42,now);
        o.frequency.exponentialRampToValueAtTime(26,now+0.26);
        g.gain.setValueAtTime(1.13,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.37);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+0.38);
      }
      dropSnare() {
        let now = this.ctx.currentTime;
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.23,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=1410;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.23,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.23);
        n.connect(f).connect(g).connect(this.reverb); n.start(now); n.stop(now+0.25);
        // Snap
        let o = this.ctx.createOscillator(), g2=this.ctx.createGain();
        o.type='triangle'; o.frequency.setValueAtTime(334,now);
        g2.gain.setValueAtTime(0.18,now); g2.gain.exponentialRampToValueAtTime(0.001,now+0.21);
        o.connect(g2).connect(this.reverb); o.start(now); o.stop(now+0.23);
      }
      dropHat() {
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.047,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=9700;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.14,this.ctx.currentTime);
        g.gain.exponentialRampToValueAtTime(0.001,this.ctx.currentTime+0.08);
        n.connect(f).connect(g).connect(this.reverb); n.start(); n.stop(this.ctx.currentTime+0.08);
      }
      clubBass(degree) {
        let now = this.ctx.currentTime;
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='triangle'; o.frequency.value = this.scale[degree]*0.3;
        g.gain.setValueAtTime(0.25,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.47);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+0.5);
      }
      dropPad(chord) {
        let now = this.ctx.currentTime;
        chord.forEach((deg,i)=>{
          let freq=this.scale[deg]*0.9;
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='triangle'; o.frequency.value=freq;
          g.gain.setValueAtTime(0.12, now);
          g.gain.linearRampToValueAtTime(0.13, now+0.95+0.12*i);
          g.gain.linearRampToValueAtTime(0.001, now+2.5+0.15*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.06*i); o.stop(now+2.6+0.13*i);
        });
      }
      stab(chord) {
        let now = this.ctx.currentTime;
        let deg = chord[2];
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'sawtooth'; o.frequency.value = this.scale[deg]*2.05;
        g.gain.setValueAtTime(0.23, now);
        g.gain.linearRampToValueAtTime(0.001, now+0.22);
        o.connect(g).connect(this.reverb);
        o.start(now); o.stop(now+0.23);
      }
      // --- Heaven mode (Radiohead/Weeknd halftime) ---
      voidKick(offset=0) {
        let now = this.ctx.currentTime + offset;
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='sine'; o.frequency.setValueAtTime(41,now);
        o.frequency.exponentialRampToValueAtTime(22,now+0.37);
        g.gain.setValueAtTime(1.0,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.47);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+0.48);
      }
      voidSnare() {
        let now = this.ctx.currentTime;
        let b = this.ctx.createBuffer(1,this.ctx.sampleRate*0.21,this.ctx.sampleRate);
        let d = b.getChannelData(0); for(let i=0;i<d.length;i++)d[i]=Math.random()*2-1;
        let n = this.ctx.createBufferSource(); n.buffer = b;
        let f = this.ctx.createBiquadFilter(); f.type='bandpass'; f.frequency.value=1100;
        let g = this.ctx.createGain(); g.gain.setValueAtTime(0.24,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.22);
        n.connect(f).connect(g).connect(this.reverb); n.start(now); n.stop(now+0.24);
        // Snap
        let o = this.ctx.createOscillator(), g2=this.ctx.createGain();
        o.type='triangle'; o.frequency.setValueAtTime(241,now);
        g2.gain.setValueAtTime(0.13,now); g2.gain.exponentialRampToValueAtTime(0.001,now+0.18);
        o.connect(g2).connect(this.reverb); o.start(now); o.stop(now+0.2);
      }
      voidBass(degree) {
        let now = this.ctx.currentTime;
        let o = this.ctx.createOscillator(), g=this.ctx.createGain();
        o.type='sine'; o.frequency.value = this.scale[degree]*0.23;
        g.gain.setValueAtTime(0.21,now);
        g.gain.exponentialRampToValueAtTime(0.001,now+0.61);
        o.connect(g).connect(this.reverb); o.start(now); o.stop(now+0.66);
      }
      voidPad(chord) {
        let now = this.ctx.currentTime;
        chord.forEach((deg,i)=>{
          let freq=this.scale[deg]*0.4;
          let o = this.ctx.createOscillator(), g=this.ctx.createGain();
          o.type='triangle'; o.frequency.value=freq;
          g.gain.setValueAtTime(0.14, now);
          g.gain.linearRampToValueAtTime(0.13, now+0.7+0.13*i);
          g.gain.linearRampToValueAtTime(0.001, now+2.2+0.11*i);
          o.connect(g).connect(this.reverb);
          o.start(now+0.08*i); o.stop(now+2.2+0.13*i);
        });
      }
      heavenSynth(chord) {
        let now = this.ctx.currentTime;
        let root = this.scale[chord[2]];
        let o = this.ctx.createOscillator(), g = this.ctx.createGain();
        o.type = 'triangle'; o.frequency.value = root*2;
        g.gain.setValueAtTime(0.13, now);
        g.gain.linearRampToValueAtTime(0.001, now+1.33);
        o.connect(g).connect(this.reverb);
        o.start(now); o.stop(now+1.33);
      }

      showError(msg) {
        let e = document.getElementById('error');
        e.textContent = msg;
        e.classList.remove('hidden');
      }
    }
    new GUMP();
  </script>
</body>
</html>
